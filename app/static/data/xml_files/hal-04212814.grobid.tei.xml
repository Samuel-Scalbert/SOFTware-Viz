<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalable Analytics on Multi-Streams Dynamic Graphs</title>
				<funder ref="#_MHgDBBU">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Angelos</forename><surname>Anadiotis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ghufran</forename><surname>Muhammad</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Khan</surname></persName>
						</author>
						<author>
							<persName><surname>Manolescu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Muhammad</forename><surname>Ghufran Khan</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Oracle Lausanne</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scalable Analytics on Multi-Streams Dynamic Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F6B7CA2966BD698ABAAFD0640FC62DCB</idno>
					<idno type="DOI">10.1145/nnnnnnn.nnnnnnn</idno>
					<note type="submission">Submitted on 20 Sep 2023</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Dynamic graph</term>
					<term>read-only present and historical queries</term>
					<term>multistream graph processing</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>de niveau recherche, publi√©s ou non, √©manant des √©tablissements d'enseignement et de recherche fran√ßais ou √©trangers, des laboratoires publics ou priv√©s.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Dynamic graphs are omnipresent in the context of real-time applications that generate massive amounts of events. These events can be seen as high-velocity data streams, whose timely analysis is critical for applications such as monitoring of cyber attacks in system security applications <ref type="bibr" target="#b15">[16]</ref>, fraud detection in financial institutions <ref type="bibr" target="#b15">[16]</ref>, anomaly detection in computer networks <ref type="bibr" target="#b7">[8]</ref> and many more.</p><p>Our work considers the above-mentioned real-time use cases. We consider a database modeled as a labeled property graph (LPG), that is continuously updated. Updates may arrive from multiple streams, creating a need for appropriate transaction support, in order to avoid inconsistencies; on such a graph, we must be able to answer analytical queries about the current graph state, as well as historical queries.</p><p>In this paper, we present the challenges (Section 2), outline the approach we investigate (Section 3), describe a new data structure we propose for storing dynamic graph data, named HAL (Section 4), together with its associated algorithms (Section 5 to <ref type="bibr">Section 7)</ref>. We present an experimental evaluation showing that our system's specific optimizations allow it to cut a good compromise between memory and speed, and outperform comparable systems, in Section 9, before discussing more related work and concluding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">CHALLENGES</head><p>In our problem setting, we focus on systems that can continuously ingest temporal labeled property graph (LPG) updates from multiple streams while at the same time supporting a diverse set of graph analytic queries with snapshot isolation consistency guarantees. Further, we assume that the clocks at the sites where streams originate are synchronized; this can be achieved by various techniques wellknown in the distributed systems area, e.g., <ref type="bibr" target="#b8">[9]</ref>.</p><p>Figure <ref type="figure">1</ref>: Example scenario for out-of-order update Systems providing snapshot isolation guarantees typically order transactions based on their timestamps. Ideally, these timestamps would reflect the generation time of each ingested event, especially given that the clocks on the sources are synchronized. However, updates from a given stream may arrive later with respect to other streams due to any kind of transmission delay, leading to out-oforder <ref type="bibr" target="#b5">[6]</ref> updates. Therefore, for every pair of events, the order of their ingestion time does not necessarily correspond to the order of creation time, and hence, any causal order between events may not be reflected by the database at all times.</p><p>Figure <ref type="figure">1</ref> exemplifies a sequence of updates labeled A to E, considering the update generation time (the time when the update is generated by a given stream) ùëâ ùëá . Note that update B arrives out of order (after D, which was emmitted later than B). After the first three received updates have been ingested, that is, reflected in the database state, query ùëÑ arrives and requires two iterations on the updates ingested up to that time. In the first iteration, the query ùëÑ ùëñ computes on the updates (A, C, and D), and before starting the second iteration ùëÑ (ùëñ+1) , the delayed update B arrives. At this point, if B became visible to the query, then the database state would be consistent with respect to the data sources, but it would also break snapshot the isolation guarantees, which is not acceptable.</p><p>Existing systems, e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b15">16]</ref>, support temporal queries in a multi-stream setting, such as the one that the paper studies, by storing the event generation time as a property and then considering it during querying. However, in such a case, each query would need to access the whole database in order to filter out the events that do not match the time frame that the query considers. Therefore, the event generation time needs to be treated as a first-class citizen in dynamic graph databases.</p><p>A straight-forward approach to the above problem is to use an index on the event generation time. Nevertheless, graph queries already require indices to efficiently navigate through the graph with varying access patterns per query/graph traversal type. Accordingly, there is a need for a system design that addresses the challenges that are present both in traditional and in temporal graph queries.</p><p>In summary, this paper identifies the following challenges in building a scalable temporal graph database management system:</p><p>‚Ä¢ C1: Provide scalable and consistent storage for multi-stream graph data ingestion.</p><p>‚Ä¢ C2: Enable scalable time-based graph analytics for point queries. ‚Ä¢ C3: Design storage organization and layout for dynamic property graphs.</p><p>Prior work addressing some of the challenges described above will be discussed in more detail in Section 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">APPROACH</head><p>We aim at a scalable system that can answer analytical queries (present, historical) over dynamic graphs, updated multiple streams, whose updates may arrive out-of-order. To address the challenges listed in Section 2:</p><p>‚Ä¢ We maintain a data store that follows the multi-version concurrency control (MVCC, in short) <ref type="bibr" target="#b14">[15]</ref> storage model. In this store, the temporal graph updates from multiple streams are considered write-only transactions, while analytical queries (present and historical) are executed as read-only transactions. This ensures consistent graph analytics even in the presence of out-of-order updates, addressing challenges C1. Furthermore, to ensure correct edge semantics and consistency, we assume that each sender (stream) is coherent, which means that:</p><p>-No sender ever sends a redundant edge insertion; an insertion is redundant if the stream previously sent such an insertion with no deletion of the same data item in between; -Similarly, there are no redundant edge deletions; a delete is redundant if the stream has already sent such a deletion, and the stream has not sent an insertion of an identical same data in between; -No sender will send a deletion of an entry for which it has not sent an insertion previously. ‚Ä¢ To efficiently process point queries based on source time, we ensure that the per-source neighbors lists are sorted by source time (the time when an event originates on its source machine) in descending order, i.e., from the latest to the oldest. We use an Adaptive Radix Tree (ART) <ref type="bibr" target="#b9">[10]</ref> index to preserve this order in the presence of an out-of-order update; this addresses the challenge C2. Details of the use of the ART appear in Section 4. ‚Ä¢ To address challenge C3, we design the system in such a way that the graph topology and graph properties are stored separately, thus updates to the topology are processed separately from graph property updates. This allows us to optimize data access paths separately for these two largely orthogonal components of the property graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Core Design Decisions</head><p>We consider an in-memory dynamic graph database management system. The graph is stored in an adjacency list, which provides a good trade-off between data access locality, required in queries, and high ingestion throughput, required in insertions. In the following, the data structures and algorithms that we propose achieve low computational complexity while maintaining high data access locality to optimize the use of modern hardware in scale-up servers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DATA STORE: HISTORY ADJACENCY LIST (HAL)</head><p>In this section, we describe the main data structure we use to address challenges C1 and C2.</p><p>We introduce the append-only History Adjacency List (HAL, in short) data store, which ensures scalable data ingestion in the multi-stream scenarios as well as graph analytics in the presence of present and historical read-only queries.</p><p>As a general rule, each update is an edge addition or deletion, and we organize such updates primarily according to the source vertex of the added/deleted edge (not to be confused with an update source, one stream or site from which updates originate).</p><p>Within the HAL, we use a Vertex Array (VA, in short), and Source Time sorted Adjacency List (STAL, in short) as shown in Figure <ref type="figure" target="#fig_1">2</ref>. Both the VA and the STAL have an entry for each graph vertex, denoted, respectively, VA[ùë†] and STAL <ref type="bibr">[ùë†]</ref>.</p><p>Each VA[ùë†] entry stores five fields:</p><p>(1) A reference to the STAL entry corresponding to this vertex;</p><p>(2) The Latest Source Time (LST, in short), i.e., the latest source time of an in-order update received so far for this vertex; (3) A Hash  <ref type="figure" target="#fig_1">2</ref>).</p><p>Each STALB stores information about a (fixed) number of edges going from ùë† to various destination nodes. Specifically, the STALB comprises:</p><p>(1) Metadata in the first 8 bytes (items <ref type="bibr" target="#b4">(5)</ref>   DestEntries and IEMEntries each occupy half of the STALB space not taken by the metadata or by PropertyRef. For instance, Figure <ref type="figure" target="#fig_1">2</ref> illustrates the STALB labeled S 0 , over 64 bytes: 8 bytes for metadata (at the left), 8 bytes for edge properties (at the right), 24 bytes (3 entries) for DestEntries and 24 bytes (3 entries) for IEMEntries.</p><p>Each IEM (In-order Edge entry Metadata) block consists of:</p><p>(1) The write time-stamp (WTS) is the transaction time of the edge, that is, the time when it is received at the database site; (2) The SrcTime is the time when an edge is emitted from the source machine; (3) The Invalidation Time Metadata (ITM) stores information about edge deletion (if applicable):</p><p>‚Ä¢ The source time of the deletion request, SrcTime;</p><p>‚Ä¢ The transaction time of the deletion request, WTS. (4) The out-of-order update (OOO) field stores the root of an ART <ref type="bibr" target="#b9">[10]</ref> in which out-of-order edge entry metadata (OEM, in short) will be inserted. The order among entries in the ART is that of the update source time (recall that we consider the stream sources "reasonably" synchronized among themselves, thus a single timeline can be constructed from their source times). Overall, the STAL structure ensures the update entries for a given source vertex ùë† are stored in the descending order of their source time.</p><p>This is achieved on one hand through the ARTs, and on the other hand by keeping other data structures time-sorted during insertions, updates, and when querying, while also ensuring low complexity (in ùëÇ (1)) for the operations we expect to be most common: in-order insertions and deletions. We discuss these algorithms next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">INSERTION</head><p>We detail the steps necessary in our platform for recording the arrival of a new edge, denoted ùë† ‚Üí ùëë. As a recall, we need to ensure scalable and consistent storage (challenge C1) whether updates arrive in order (the database site receives them in the order of their emission at the source sites), or out of order. Our algorithms leverage our proposed storage organization and layout for dynamic graphs (challenge C3). Further, meeting this challenges will enable to also provide efficient querying of the dynamic graphs (challenge C2), as we will show in Section 8. A new edge (insertion) entry ùë† ‚Üí ùëë received at the database site is procesed as follows:</p><p>(1) Locate in the VA the position corresponding to ùë†, e.g., if the new edge is 0 ‚Üí 1 arriving at 10:00 am (ùëâ ùëá ), this is the VA[0]. Lock this position to prevent conflicts between several write-transactions having the source vertex ùë†. We next show how each of these insertions is handled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">In-order insertion</head><p>We handle these as follows.</p><p>(1) Create an IEM block with: the edge's source time in SrcTime, NULL in the ITM, NULL in the OOO, WTS as the edge's transaction time. (2) Locate the STALB, say ùëÜ ùëñùëú , which is currently receiving updates. If ùëÜ ùëñùëú is full (that is, it contains L2Size entries), proceed to (3) below, otherwise, to (4). (3) If the L2Size of ùëÜ ùëñùëú is still smaller than an upper bound MaxBlockSize, then double the size of ùëÜ ùëñùëú , update the metadata accordingly, and follow step (4). The aggressive resizing (by doubling up), on top of a small initial size, is adopted since it has been shown <ref type="bibr" target="#b4">[5]</ref> to yield good performance in the (frequent) case when the number of edges adjacent to a node follows a power-law distribution. Otherwise (ùëÜ ùëñùëú had already been extended up to size MaxBlockSize), create a new STALB, call it ùëÜ ùëõùëíùë§ , of size 1, with the appropriate metadata, and insert ùëÜ ùëõùëíùë§ in STAL <ref type="bibr">[ùë†]</ref>. The role of ùëÜ ùëñùëú below (4) will be played by ùëÜ ùëõùëíùë§ . (4) In ùëÜ ùëñùëú , at position ùëÜ ùëñùëú .CurIndex-1, store ùëë in the DestEntries, the IEM block in the IEMEntries, the ùë† ‚Üí ùëë edge properties in the Property vector. Then, update ùëÜ ùëñùëú .CurIndex, decrementing it by 1. (5) Create a new UPI, denoted UPI ùëí , storing the position (in the STAL) of the newly inserted edge entry. We say UPI ùëí is an in-order UPI, since it is due to an in-order insertion.</p><p>Concretely, UPI ùëí is an 8-bytes bit vector, structured in six fields. Figure <ref type="figure" target="#fig_2">3</ref> details their relative positions and lengths in the UPI, starting with the 0-th bit at the right:</p><formula xml:id="formula_0">ùëñ ùë¢ ùëë ùë† ùëè ùë† ùëè ùëñ ùë† ùë†</formula><p>ùë† ùëñ 63 (52, 62) (48, 51) (37, 47) (32, 36) (0, 31) ‚Ä¢ ùë† ùëñ , starting at position 0, stores on 32 bits ùëÜ ùëñùëú .CurrPos, the current position where ùë† ‚Üí ùëë was inserted; ‚Ä¢ ùë† ùë† stores on 5 bits as required to store the currrent size of STAL <ref type="bibr">[ùë†]</ref>. Recall that STAL[ùë†] is created with an initial size of 1 and then its size is always a power of 2; for example, in Figure <ref type="figure" target="#fig_1">2</ref>, the size of the ùëÜùëá ùê¥ùêø[ùë†] is 1, we store ùëôùëúùëî 2 (1) = 0. With 5 bits we can store values up to 32, leading to MaxBlockSize=2 32 . ‚Ä¢ ùëè ùëñ stores on 11 bits ùëÜ ùëñùëú .CurIndex.</p><p>‚Ä¢ ùëè ùë† stores the size of S ùëñùëú , the STALB where the edge entry is inserted. ‚Ä¢ ùëë ùë† stores the 11-bit suffix of ùëë's node ID;</p><p>‚Ä¢ The ùëñ ùë¢ flag (bit at position 63) is set to 1. Then, UPI ùëí is added to the hash table HT[ùë†]. More details on the UPI and the hash table will be provided in Section 7. For instance, assume we receive the following successive insertions: 0 ‚Üí 1 and 0 ‚Üí 2 at timestamps 10:00 am, and 10:05 am respectively. The resulting entries in our data structures are shown in black in Figure <ref type="figure" target="#fig_1">2</ref>, while the newly created UPI (at the bottom left in Figure <ref type="figure" target="#fig_1">2</ref>) has the values 1 1 3 2 0 0 in its six fields. Note that we store in ùëë ùë† only an 11-bit suffix of ùëë's identifier (not the full ID). While we rely on suffices for compactness, extra measures are taken when reading the data, to avoid confusing nodes whose IDs have the same suffix. We detail how this is achieved in Section 7. As shown above, the computational complexity of handling an in-order insertion is ùëÇ (1), since each step (including doubling up a STALB) takes constant time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Out-of-order insertion</head><p>To handle the out-of-order insertion ùë† ‚Üí ùëë:</p><p>(1) Create an out-of-order edge entry metadata (OEM) block. In this block, DNode stores ùëë, WTS refers to the transaction time, SrcTime is the source time of the out-of-order update, and the ITM block is set to null. ( <ref type="formula" target="#formula_1">2</ref>  For instance, assume that after the insertion illustrated in black text Figure <ref type="figure" target="#fig_1">2</ref>, we receive the out-of-order insertion 0 ‚Üí 9 with timestamp 10:02 am. The resulting entries are shown in red font in Figure <ref type="figure" target="#fig_1">2</ref>, while the new UPI ùëí is 0 9 10:02 in Figure <ref type="figure" target="#fig_1">2</ref>. Unlike in-order insertions, out-of-order ones accumulate in ART trees, and only the ART roots are stored in the in-order IEM blocks. Thus, out-of-order updates never lead to STAL blocks becoming full (or splitting); only in-order updates do that. Out-of-order insertions require binary search (in STAL[ùë†] based on SrcTimestamp, then in the STALB to find the IEM block where the ART root is/should be stored), and also incurs the cost of searching the ART, leading to a worst-case complexity of ùëÇ (ùëôùëúùëî(|ùê∏|)). While this is not constant-time, we can reasonably expect out-of-order updates to be less frequent than in-order ones; ours is the first dynamic graph management system capable of correctly handling a mix of in-order and out-of-order updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DELETION</head><p>We now consider the deletion of an edge ùëí of the form ùë† ‚Üí ùëë. Recall that we assume that an edge deletion only occurs after the respective edge has been inserted. We proceed as follows:</p><p>(1) Locate the position of the source vertex ùë† in the VA.</p><p>( </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">In-order deletion</head><p>(1) From UPI ùëí (recall Figure <ref type="figure" target="#fig_2">3</ref>), access ùë† ùëñ to get the position, in STAL[ùë†], of the STAL block, call it ùëÜ ùëñ , where the insertion ùë† ‚Üí ùëë had been stored, at the time of that insertion. Note that this position may no longer be correct, in case the STAL <ref type="bibr">[ùë†]</ref> has been resized at some point in time after ùëí was inserted! We discuss how to handle such situations shortly below. (2) To account for the possible resize that may have changed the position of ùëÜ ùëñ , from the STAL metadata, we get the current size of STAL[ùë†] (Size in Figure <ref type="figure" target="#fig_1">2</ref>). We then compute the current position of For instance, assume that we receive the in-order deletion 0 ‚Üí 1 with timestamp 10:08 am. The resulting ITM entry is shown in green font in Figure <ref type="figure" target="#fig_1">2</ref>: 10:08 10:09 . As shown above, the complexity of handling in-order deletions is ùëÇ (1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Out-of-order deletion</head><p>This process is slightly different, given that for OOO updates we need to store the source timestamp in UPI ùëí (see Figure <ref type="figure" target="#fig_3">4</ref>). To keep the data structures compact, UPI ùëí does not store the STAL position of the insertion entry. Instead, we have to retrieve it by binary search on the ordered data structures, as follows.</p><p>(1) Get the source timestamp of the insertion of ùëí, from UPI ùëí .</p><p>(2) Based on this, in STAL[ùë†], find the STALB, say ùëÜ ùëñ , where the out-of-order insertion of ùëí was placed. For instance, assume that we receive the out-of-order deletion 0 ‚Üí 9 with timestamp 10:10 am. The resulting ITM entry is shown in blue font in Figure <ref type="figure" target="#fig_1">2</ref>: 10:10 10:11 .</p><p>Similarly to out-of-order insertions, the complexity of handling out-of-order deletions is ùëÇ (ùëôùëúùëî(|ùê∏|)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">PER-SOURCE VERTEX TABLE (HT)</head><p>Recall that we store for each destination node ùëë present in the STAL[ùë†], the most recent position of the each destination node's entry, called Update Position Indicator of ùë† and ùëë (or UPI[ùë†, ùëë], in short). Each edge insertion leads to creating an UPI; each edge look-up needs to read the UPI, and similarly, each edge deletion must locate, then delete an UPI. In this section, we describe these operations: UPI creation on one hand, UPI look-up or deletion (their processing is quite similar) on the other hand. We store UPIs in a dedicated optimized hash table, based on the open-addressing technique <ref type="bibr" target="#b11">[12]</ref>; we call this structure Per-Source Vertex Hash Table (HT[ùë†, ùëë], in short).</p><p>Below, Sections 7.1, 7.2, respectively, describe how we insert, look up, and delete content from the HT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">UPI Insertion</head><p>For inserting the UPI of a newly inserted edge entry ùë† ‚Üí ùëë, call this edge ùëí, in the HT. Insertions of in-order UPIs are described under (1) below, while out-of-order UPI insertions follow (2).</p><p>(1) In-order UPI</p><p>‚Ä¢ Create an in-order UPI, call it ùëà ùëÉùêº ùëñ , then store the ùëí position of STAL[ùë†] as described in Section 5.1. ‚Ä¢ Compute the position, say ùëñ, in the HT where ùëà ùëÉùêº ùëñ should be stored, as (ùëë modulo HT size), and store ùëà ùëÉùêº ùëñ there HT[ùëñ] is empty; otherwise, increase ùëñ until we find a free position HT[ùëñ] and store ùëà ùëÉùêº ùëñ there. (2) Out-of-order UPI</p><p>‚Ä¢ Create an out-of-order UPI, call it ùëà ùëÉùêº ùëú , then store the ùëí source timestamp in ùëà ùëÉùêº ùëú .ùë° ùë† as described in Section 5.2. ‚Ä¢ Compute the position, say ùëñ, in the HT where ùëà ùëÉùêº ùëú should be stored, as (ùëë modulo HT size) and store ùëà ùëÉùêº ùëú there if HT[ùëñ] is free; otherwise, increase ùëñ until we find a free position and store ùëà ùëÉùêº ùëú there.</p><p>As shown above, collision handling is potentially expensive. To keep its cost under control in practice, the HT size is twice as large as its number of entries, making it likely to find an empty space very fast.</p><p>More generally, collisions could be further avoided by using the double hashing techniques proposed in Robin Hood hashing <ref type="bibr" target="#b2">[3]</ref> and GraphTango <ref type="bibr" target="#b0">[1]</ref> (not published yet). An important observation is that the former causes cache misses in case of collision; the more recent GraphTango <ref type="bibr" target="#b0">[1]</ref> presents a cache-friendly double hashing technique; we could also experiment with it in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">UPI Deletion or Lookup</head><p>Now assume we need to find, in the HT, the UPI of an edge entry ùëí corresponding to ùë† ‚Üí ùëë, in order to delete the UPI. We do that as follows:</p><p>(1) Compute the position, say ùëô, where the UPI related to ùëí may exist in the HT, as (ùëë modulo HT size). Call that ùëà ùëÉùêº ùëí .</p><p>(2) Check the field ùëà ùëÉùêº ùëí .ùëñ ùë¢ field to see whether ùëà ùëÉùêº ùëí is an inorder or out-of-order UPI. In the former case, follow with step (2a) below; in the latter, follow with (2b). (a) In-order UPI (i) Access the field ùëà ùëÉùêº ùëí .ùëë ùë† (suffix of the destination node for which ùëà ùëÉùêº ùëí was created). Compare the 11-bit suffix of ùëë, the destination node in ùëí, with ùëà ùëÉùêº ùëí .ùëë ùë† : if they match, then follow step (2(a)ii); otherwise, read the UPI at the the next HT position ùëô + 1 into ùëà ùëÉùêº ùëí , and return to step (2). This search stops when we find the precise UPI created when ùëí was inserted, or we find an empty position in the HT. (ii) Go to the ùëà ùëÉùêº ùëí indicated position in the STAL, read the destination id, and compare it with the ID of destination node ùëë. -Otherwise, increment the HT index to ùëô + 1, read into ùëà ùëÉùêº ùëí the entry at that index, and repeat from (2). The search stops when we find a UPI related to ùëí or an empty space in the HT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">QUERIES</head><p>Dynamic graph systems, including ours, can be used for a large variety of computations. Popular benchmarks compare them on algorithms including such as Breadth-First Search, PageRank, Community Detection, etc. The computation steps necessary for implementing any of these algorithms are well-known, and remain the same regardless of the graph data management system. Thus, existing evaluation frameworks implement a set of graph algorithms, on top of a uniform graph data access API, whereas dynamic graph systems implement simple getEdge(s, d, time) and getVertex(id, time)-style operations. Since the graph algorithm costs are the same, the remaining performance differences can directly be attributed to the efficiency of the data store.</p><p>The main operations dynamic graph systems have to support are simple edge requests, of several forms. Present queries require the last committed state of the edge at the database site, i.e., the edge's current state. Historical queries explicitly specify time information. They can be either point (or snapshot) queries request an edge such as it was at a certain point in the past, or interval queries focused on a specific past time interval. Interval querries can be implemented as a sequence of point queries, one for each timestamp in the interval. Thus, below, we discuss the processing of present and point edge queries. Without loss of generality, below, we show how to evaluate a query requesting all the edges whose source node is ùë† (the query node). The modifications needed to handle variants of this elementary query, e.g., asking for the edges' properties, or filtering based on them, etc., are quite straightforward. Each query also specifies either the present time, or a specific requested timestamp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Present queries</head><p>We denote the present query by ùëù ùëû , and the time when the query is asked, by ùúè. For each STALB in STAL[ùë†], starting from the currently inserted STALB towards the oldest STALB:</p><p>(1) Check the IsDelete and OOO fields of each STALB. Four cases can occur: (a) If both are true, the STALB contains both deletion entries and out-of-order updates. In this case, when traversing the metadata entries associated with this STALB, we will check each IEM entry's ITM and OOO fields to ensure that we do not read a deleted IEM entry, and do not miss out-of-order updates. (b) If IsDelete is true and OOO is false, the STALB contains deleted entries but no out-of-order one. We will check the ITM field only. (c) If OOO is true and IsDelete is false, there are out-of-order updates in the STALB, but no deletion. We will check the OOO field only. (d) Both are false: we will not check ITM nor OOO fields in the IEM entries, thus speeding up the STALB traversal. This case analysis is done once per STALB; it may avoid accessing and testing fields in all the IEM entries for this STALB.</p><p>Avoiding to access and read these boolean fields makes our system more cache-friendly. As our experiments show (Section 9), competitor systems such as LiveGraph, which makes some checks for each traversed edge, suffer, among others, from their poor usage of the cache. ( <ref type="formula" target="#formula_1">2</ref> For present queries, the worst-case complexity is ùëÇ (|ùëÖ|), where ùëÖ ‚äÜ ùëÑ is the set of edges that belong to the query result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Point queries</head><p>Let ‚Ñé ùëû be a point query, issued at the query transaction time ùúè ‚Ñé , and containing a user-specified source timestamp ùúè. This query asks for all the nodes ùëë such that an edge ùë† ‚Üí ùëë had been inserted in the graph, and had not been deleted, by ùúè ‚Ñé . We proceed as follows:</p><p>(1) Through binary search on STAL[ùë†], with ùúè as the search key, find the STALB from where we start reading, call it ùëÜ ùëù . We will read up to the oldest STALB. ( <ref type="formula" target="#formula_1">2</ref> The worst-case computational complexity is ùëÇ (ùëôùëúùëî(|ùê∏|) + |ùëÖ|) where the edge set ùëÖ is the query result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">EVALUATION</head><p>We implemented the data structures and algorithms previously described, and describe experiments which confirm its performance advantages with respect to the state of the art. Below, we describe our hardware and software experimental setup (Section 9.1); the benchmark dataset and the algorithm used for analytics (Section 9.2); the qualitative analysis of related systems (Section 9.3). We conclude by performance studies on insertions (Section 9.4), updates (Section 9.5), and analytic querying (Section 9.6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Hardware and software settings</head><p>We run our experiments on a dual-socket machine with intel Xeon E5-2640 v4, which has 40 hardware threads and 256 GB of RAM. All system source code is written in C++ and compiled on GCC v10.2, with the optimization flag -O3. In our system, the maximum number of entries allowed per block is 2047; for the competitor Sortledton <ref type="bibr" target="#b4">[5]</ref>, it is set to 512 entries per block. All reported times are medians over five runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Workloads</head><p>We use the synthetic graph datasets graph-500 <ref type="bibr" target="#b6">[7]</ref> with scale factors (SF) 22, 24, and 26; the node fan-out in these graphs follows a power-law degree distribution. We also use one real-world graph, namely dota-league from <ref type="bibr" target="#b6">[7]</ref>. These datasets, used in previous comparable works, are undirected, and do not contain multiple edges between two vertices. Translating them in our framework designed for directed graphs, like in prior work, we replace each undirected edge (ùë†, ùëë) by two directed edges, ùë† ‚Üí ùëë and ùëë ‚Üí ùë†. Each edge has just one property, namely weight, that is double precision real number; we generate these weights at random between 0 and 1 with a uniform distribution The main dataset metrics appear in Figure <ref type="figure" target="#fig_5">5</ref>. We compare our system with existing competitors using the LDBC graph analytics benchmark <ref type="bibr" target="#b6">[7]</ref>, from which we use five graph algorithms: Breadth-First Search (BFS), PageRank (PR), Single-Source Shortest Path (SSSP), Community Detection Via Label Propagation (CDLP), and the Weakly Connected Components (WCC). For fair comparison, the implementation of the graph algorithms is taken from the Graph Algorithm Platform Benchmark Suite (GAP BS) <ref type="bibr" target="#b1">[2]</ref>, and runs on the driver implemented by Teseo <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dataset</head><p>Vertices  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Competitors and complexity comparison</head><p>We compared our system with three other cache-friendly hybrid analytical/transactional processing (HTAP) systems for graphs, namely: LiveGraph <ref type="bibr" target="#b15">[16]</ref>, Teseo <ref type="bibr" target="#b10">[11]</ref>, and Sortledton <ref type="bibr" target="#b4">[5]</ref>. LiveGraph stores graph edges in adjacency list, one for each source node; it supports random vertex access, and sequential neighborhood access. The edges in each adjacency list are stored contiguously, thus reading them does not cause random accesses. To handle graph updates, LiveGraph manages versions of edge entries in the vector. This is costly in terms of memory, as we need to store, for each edge update, the transaction timestamp and the possible invalidation timestamp. Its advantage is to efficiently support historical queries, by appending new edges to their respective adjacency lists as they arrive. Thus, edges are naturally sorted by transaction time, allowing historical queries to run in ùëÇ (ùëôùëúùëî(|ùê∏|)).</p><p>In contrast, Sortledton and Teseo follow a set-based neighborhood design, where the blocks of edges are sorted by destination id. The maintenance of edge entry versions is done by the Hyper Multi-Version Concurrency Control <ref type="bibr" target="#b13">[14]</ref> protocol: both systems store the latest version of the edges in a sequential block, and older versions are stored in a linked list. In Sortledton, blocks of edges are sorted and connected through a skiplist. Teseo follows a Compressed Sparse Row (CSR) design, where the vertices and edges are stored in a B+ tree with 2MB-size leaves, called a FAT tree, which is a packed memory array supporting sequential vertex access and sequential neighborhood access. However, the set-based neighborhood design (sorted by destination ids) does not maintain the arrival order of the edges; hence, for historical queries, its complexity is worse, ùëÇ (|ùê∏|), than the one of LiveGraph, ùëÇ (ùëôùëúùëî(|ùê∏|)). Figure <ref type="figure" target="#fig_6">6</ref> shows the time complexity of for the main operations (edge insertion, edge deletion, and edge look-up) on related systems. In practice, edge insertion requires two steps: (ùëñ) check if the edge exists already, (ùëñùëñ) insert it if not already there. Sortledton and Teseo perform (ùëñ,ùëñùëñ) in ùëÇ (ùëôùëúùëî(|ùê∏|)). LiveGraph does not sort but simply appends the edges in the neighborhood list; it uses Bloom filters to check the edge's existence, which takes ùëÇ (1). However, if false  positives occur, the verification raises the cost to ùëÇ (|ùê∏|). For inorder insertion, our system HAL does not need (ùëñ), as we treat each insertion (from a distinct site) as a separate update; we perform (ùëñùëñ) in ùëÇ (1) as we simply append edges to the neighborhood list. At the same time, we are able to check for the existence of an edge in ùëÇ (1) thanks to our HT. Out-of-order insertions, supported only in HAL, take ùëÇ (ùëôùëúùëî|ùê∏|) for step (ùëñùëñ). HAL's complexity is better than competitors' for in-order insertion. For out-of-order insertion, the complexity is similar to those of Sortledton and Teseo, but worse than LiveGraph's best-case scenario (no false positive in the Bloom filter).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>System</head><p>To find and delete edges, Sortledton and Teseo take ùëÇ (ùëôùëúùëî(|ùê∏|)) because of the set-based neighborhood design, while HAL needs ùëÇ (1) for in-order updates and ùëÇ (ùëôùëúùëî(|ùê∏|)) for out-of-order updates. LiveGraph takes ùëÇ (1) (without false positive) for deletions, and up to ùëÇ (|ùê∏|) (with false positives) to find an edge. For both deletions and edge search, for in-order updates, HAL has better complexity than the existing systems; for out-of-order updates, its complexity is the same as that of Sortledton and Teseo, and better than LiveGraph's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4">Edge insertions</head><p>To measure insertion performance, we insert successively all the edges of the graph500-24 dataset, in a random order. Since the competitor systems do not support out-of-order insertions, we do not have them in our workload.</p><p>Figure <ref type="figure" target="#fig_7">7</ref> reports the insertion throughput, measured in Million (of inserted) Edges Per Second (MEPS, in short), as we increase the number of threads (on the ùë• axis) from 1 to 2, 4, 6, . . . until 40. HAL scales up very well, better than the other systems, as we increase the number of threads. While Sortledton and Teseo also gain from parallelism, they do so much less than HAL; LiveGraph does not benefit at all from it. This is due to contention between multiple writer threads, simultaneously trying to (ùëñ) search linearly in the adjacency list for many edge existence checks, and (ùëñùëñ) resize requests. At maximum parallelism, HAL outperforms Sortledton and Teseo by 3√ó, and LiveGraph by 30√ó. From now on, we report on experiments with 40 threads.</p><p>Figure <ref type="figure" target="#fig_8">8</ref> shows insertion throughput, again in MEPS, on different systems for our four datasets. HAL performs better in all cases. Its running time shows some variability when increasing the size of the datasets; this reflects the cost we pay for maintaining the HT and resizing the STAL vector. HAL performs better since we simply append the edges in adjacency lists, without sorting by destination id (insertions mostly in ùëÇ (1)).</p><p>Sortledton and Teseo perform very similarly on all the datasets, because of their similar set-based neighborhood design; for edge existence check, this requires takes ùëÇ (ùëôùëúùëî 2 |ùê∏|)). Even though Live-Graph append newly arrived edges (without sorting by destination ids) in the adjacency list, it still performs significantly slower than the other systems. This is because LiveGraph provides completely sequential access to the adjacency list, which in turn leads to more resize requests as the edge vector, initially of size 1, is resized. The cost to check for the existence of the new edge also plays a role (see the discussion of false positives in Bloom filters above).</p><p>As previously explained, in our setting, edge existence checks are not needed upon insertions. But just to check whether HAL could efficiently also perform these checks, we ran an extra experiment, inserting the graph500-24 dataset with 40 threads and existence checks. The throughput decreased modestly, from 9.3 MEPS to 9.1 MEPS (2%), which is not significant, still leaves HAL the bestperforming system.</p><p>Lesson learned: In systems that follow the set-based neighborhood design, with edge blocks that are connected through B+ tree (Teseo) or skip lists (Sortledton), the necessary sorting steps limit the throughput due to contention between writer threads; their advantage is that they do not need an extra index when checking for edge existence. In contrast, HAL simply appends edges in the adjacency list without sorting by destination ids, hence, its throughput is significantly better, because of lower contention between writer threads. However, it needs extra space for maintaining the secondary index (our hash table HT).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5">Updates (insertions and deletions)</head><p>Next, we evaluate our system on a mixed workload made of insertions and deletions, introduced in Teseo <ref type="bibr" target="#b10">[11]</ref>. Unlike the previous insertion experiments, 10% of the operations in the update workload load the graph, after which, 90% of the operations are insertions and deletions keeping the (already large) graph of more or less the same size. The size of the update workload is 10 √ó |ùê∏|. Lesson learned: Set-based systems have a lower update throughput as compared to HAL due to the reasons described above. However, these competitors need less space to manage different versions of the edges, compared to HAL which needs to store with each edge a transaction time (WTS), and invalidation time (deletion time of an edge), as well as the HT. Thus, HAL's performance is obtained trading some space for more throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.6">Analytics</head><p>We run the LDBC graph analytics benchmark <ref type="bibr" target="#b6">[7]</ref> on top of Teseo, Sortledton, LiveGraph and HAL, for our four datasets. We choose Sortledton (the latest system in the literature) as baseline, and measure the slowdown of other systems with respect to it.</p><p>Figure <ref type="figure" target="#fig_10">10</ref> shows the benchmark analytics algorithm results on these datasets and systems: the algorithms on the ùë• axis, and the slowdowns on the ùë¶ axis, the lower, the better. BFS and SSSP require random vertex access and sequential neighborhood access, where HAL performs three times better than the baseline system. In contrast, PageRank, WCC, and CDLP require sequential vertex access and sequential neighborhood access, in which HAL performs significantly better than LiveGraph and Teseo, and slightly better than Sortledton.</p><p>LiveGraph is slower than HAL due to storing edge entry metadata (transaction timestamp, invalidation timestamp, property size) with destination ids, which causes more cache misses during the access. For instance, a single edge entry takes 32 bytes, which means a cache miss occurs every two edge entries. On the other hand, in HAL, destination ids (DestEntries in STALBs) are stored separately from the edge entry metadata (IEMs), hence, cache misses occur more rarely, after eight edge entries. Additionally, LiveGraph checks each entry's invalidation time to see whether the edge entry is deleted or safe to read. In contrast, in HAL system, the IsDelete flag in each STALB helps to read the edge entry directly, if there is no deletion in the STALB.</p><p>Teseo performs significantly worse than HAL mainly because: (ùëñ) Teseo needs a per-edge entry mapping from sparse to dense vertex ids in the analytics part of the graph algorithm using a hash table, which is costly. (ùëñùëñ) In Teseo, sorted neighborhood block contains up to 512 edges as compared to HAL, where the maximum number of edges in a STALB is 2047, resulting in fewer random accesses. Sortledton's performance is slightly slower than HAL's because of the number of edges allowed in the block (512 for Sortledton, there are 512 edges per block, 2047 for HAL), leading to more random accesses for Sortledton.</p><p>Lessons learned Set-based systems (Sortledton and Teseo) incur fewer cache misses than LiveGraph, since the former read the latest version of the destination ids, while LiveGraph must traverse all versions of the destination ids in the adjacency list, together with per-edge information. LiveGraph is also hampered by the need to check invalidation timestamps, to see if an edge entry is still valid. Thus, set-based systems outperform LiveGraph. However, set-based systems do not preserve edge entry order, slowing down historical queries.</p><p>To provide scalable support for both present and historical queries, HAL adopts an approach in-between the two above. Specifically, HAL stores the destination ids separately from the edge entry metadata in the STALB, given that destination IDs are accessed more often. HAL spares per-edge deletion checks by checking each STALB's isDelete flag, which may signal that a block contains no deletion, thus no check is needed on its edges.</p><p>Finally, converting sparse vertex identifiers into dense ones during analytics computation (like Teseo does) is costly. In contrast, HAL (like Sortledton) makes this conversion at edge insertion time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">RELATED WORK</head><p>Existing systems supporting multi-stream dynamic graph analytics can be classified into two main categories: those which provide transactional guarantees, such as LiveGraph <ref type="bibr" target="#b15">[16]</ref>, Teseo <ref type="bibr" target="#b10">[11]</ref>, and Sortledton <ref type="bibr" target="#b4">[5]</ref>, and those that do not, such as Llama <ref type="bibr" target="#b12">[13]</ref>, GraphOne <ref type="bibr" target="#b7">[8]</ref>, and STINGER <ref type="bibr" target="#b3">[4]</ref>.</p><p>Our work belongs to the former group, and Table <ref type="table" target="#tab_1">1</ref> summarizes the challenges associated with these systems. Further, there are two main different data storage designs in transactional systems: (ùëñ) set-based neighborhood blocks, where the edges are sorted by destination ids and edge entry version maintenance is done by the Hyper protocol <ref type="bibr" target="#b13">[14]</ref>; sample systems are Sortledton <ref type="bibr" target="#b4">[5]</ref> and Teseo <ref type="bibr" target="#b10">[11]</ref>, and (ùëñùëñ) edges stored in the adjacency blocks without sorting by destination ids, with per-entry version management within the adjacency block, represented by LiveGraph <ref type="bibr" target="#b15">[16]</ref>. We discussed these systems' details in Section 9.3.</p><p>The advantage of the set-based design is that we do not need any extra index on the adjacency list to delete or lookup any specific destination entry. Also, it takes less space, as we do not manage the version in the adjacency list. However, it does not preserve the historical arrival order; hence, historical queries run on top of set-based systems are not efficient. On the other hand, in LiveGraph <ref type="bibr" target="#b15">[16]</ref>, the order of edge arrival is maintained. All the systems mentioned in Table <ref type="table" target="#tab_1">1</ref>, as well as the one we aim for, support queries based on the current state of the dynamic graph. Except for LiveGraph <ref type="bibr" target="#b15">[16]</ref> and this paper, no other system supports historical state queries. In our work, we follow the LiveGraph <ref type="bibr" target="#b15">[16]</ref> MVCC protocol with the optimization described in Section 4 to improve update throughput and performance on analytics. Live-Graph <ref type="bibr" target="#b15">[16]</ref> supports historical queries based on transaction time; on the other hand, we are supporting historical queries based on source time (time when the update was emitted from the source machine). Existing systems do not provide consistency guarantees in the presence of out-of-order updates, while our system attains this goal, as explained in Section 4 to 7 and validated through our experiments (Section 9).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">CONCLUSION AND PERSPECTIVES</head><p>This paper aims to provide a scalable storage and indexing solution that can ingest real-time graph updates from multiple streams and, on top of that, provide consistent graph analytics (read-only present and historical queries) even in the presence of out-of-order updates. Our system performs approximately 9 million updates per second, which is three times faster than the Sortledton. We are still doing further experimentation to proof our system. In the future, we will provide mixed-workload (updates and analytics in parallel) and historical query results.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :( 3 )</head><label>23</label><figDesc>Figure 2: History Adjacency List (HAL)</figDesc><graphic coords="4,65.06,184.39,481.87,262.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>( 2 )</head><label>2</label><figDesc>Compare the new edge entry update source time (ùëÜ ùëá ) to the LST value in VA[ùë†]. (a) If LST &lt; ùëÜ ùëá , then ùë† ‚Üí ùëë is an in-order update; follow the steps in Section 5.1 below. (b) Otherwise, it is an out-of-order update; follow the steps in Section 5.2 below. (3) Unlock STAL[ùë†].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: In-order Update position indicator (UPI) Bit Vector</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Out-of-order UPI for sample insertion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>( 3 )</head><label>3</label><figDesc>Locate the IEM block, say IEM ùëñ , corresponding to the insertion of ùëí, by binary search on ùëÜ ùëñ .IEMEntries. (4) IEM ùëñ .OOO field is the root of an ART, in which we look up the OEM block, call it OEM ùëñ , corresponding to the insertion. (5) Create an ITM block, ITM ùëë , with the deletion request source time as SrcTime. (6) Store ITM ùëë in the ITM field of OEM ùëñ . (7) Set the IsDelete flag of ùëÜ ùëñ to true. (8) Commit the deletion request by storing the current (transaction) time in the WTS of ITM ùëë .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Dataset description</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Complexity comparison for elementary graph operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Graph500-24 scalability analysis.</figDesc><graphic coords="10,73.04,83.69,201.75,151.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Insertion throughput on all systems and datasets.</figDesc><graphic coords="10,73.04,276.78,201.76,117.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Graph500-24 update workload result</figDesc><graphic coords="11,73.04,83.69,201.76,106.71" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Performance evaluation on graph analytics.</figDesc><graphic coords="12,79.02,225.48,453.97,137.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>DestEntries stores edge entries whose source is ùë† and having various destination ids. These are sorted in the descending order of the source time of the update ùë† ‚Üí ùëë;State-of-the-art Present query Historical queries Out-of-order update Comparison of state-of-the-art systems in the context of our dynamic graph challenges.</figDesc><table><row><cell>to (9) below);</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>) Through binary search on STAL[ùë†], using the update source timestamp, find the STALB, say ùëÜ ùëúùëú , where the out-of-order update should be placed.(3) Through binary search on ùëÜ ùëúùëú .IEMEntries, using the update source timestamp, locate the IEM block where the out-oforder update should be placed. (a) If the OOO field of that IEM block is null, create an ART tree ordered by update source time, and holding the newly created OEM block as its first leaf. Otherwise (the ART exists), insert the OEM block to the ART. (b) Set the OOO field of ùëÜ ùëúùëú field to true. (4) Create a new UPI denoted UPI ùëí , to record the position of the newly inserted edge entry. UPI ùëí is itself called out-of-order UPI, with a structure simpler than that of in-order UPIs (see Figure4). It is also a 8-byte array, where:‚Ä¢ the ùëñ ùë¢ bit (position 63) is 0;‚Ä¢ ùëë ùëú stores the 15-bits suffix of the destination node ID ùëë;‚Ä¢ the entry source time is stored in SrcTimestamp. Then, UPI ùëí is added in the hash table HT[ùë†].</figDesc><table><row><cell>ùëñ ùë¢</cell><cell>ùëë ùëú</cell><cell>ùë° ùë†</cell></row><row><cell cols="3">63 (48, 62) (0, 47)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>In the above, UPI ùëí .ùë† ùë† -UPI ùëí .ùë† ùëñ computes how far the ùëÜ ùëñ position is, from the last index of STAL[ùëí]  when the edge entry was inserted. Call this difference Œî ùë†ùëñ . Then, we substract Œî ùë†ùëñ from STAL[ùëí].Size to obtain the current entry position in the STAL[ùëí]. For instance, in Figure 2, UPI ùëí .ùë† ùëñ is 0, UPI ùëí .ùë† ùë† is 1, and the current STAL[ùëí].Size is 1, thus (1 -(1 -0) is 0, indicating the current position of ùëÜ ùëñ . (3) Locate ùëÜ ùëñ in STAL[ùë†] as the block at the position computed as above. (4) UPI ùëí .ùëè ùëñ is the position of the ùëí insertion entry in ùëÜ ùëñ .IEMEntries, when ùëí was inserted. (5) UPI ùëí .ùëè ùë† is the size of ùëÜ ùëñ when ùëí was inserted say. (6) Compute the exact position of the insertion in ùëÜ ùëñ .IEMEntries as: ùëÜ ùëñ .BlockSize -(UPI ùëí .ùë† ùë† -UPI ùëí .ùë† ùëñ ) The reasoning behind the calculation is the same as above (leveraging the same Œî ùë†ùëñ ). Then, we take the following steps: (a) Access the IEM block in ùëÜ ùëñ .IEMEntries, call it IEM ùëñ , corresponding to the insertion of ùëí in ùëÜ ùëñ . (b) Create an ITM block, call it ITM ùëë , with SrcTime as the timestamp when the deletion request originated from the source machine. Store ITM ùëë in the ITM field of ùêº ùê∏ùëÄ ùëí . (c) Set the ùëÜ ùëñ IsDelete flag to true. (d) Commit the deletion request by storing the current (transaction) time in the WTS of ITM ùëë .</figDesc><table /><note><p>ùëÜ ùëñ in STAL[ùë†], of as STAL[ùëí].Size -(UPI ùëí .ùë† ùë† -UPI ùëí .ùë† ùëñ )</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>‚Ä¢ If they are equal, we have found the ùëà ùëÉùêº related to ùëí. If we are handling a deletion, delete the UPI at HT[ùëô]. ‚Ä¢ Otherwise, read the UPI at the next HT position ùëô + 1 into ùëà ùëÉùêº ùëí , and return to (2). Search stops when we find the UPI created when inserting ùëí, or we find an empty position in the STAL, signifying that the desired UPI does not exist. Access the DNode field of the OEM block, and compare it with the destination node id ùëë. -If they match, ùëà ùëÉùêº ùëí indeed corresponds to the insertion of ùëí. If we are handling a deletion, delete ùëà ùëÉùêº ùëí from HT[ùëô].</figDesc><table /><note><p>(b) Out-of-order UPI (i) Access the field ùëà ùëÉùêº ùëí .ùëë ùë† and compare it with the 15-bit suffix of the destination node ID ùëë. If they match, then follow with step (2(b)ii); otherwise, increment the HT index by 1 to get the next ùëà ùëÉùêº ùëí and return to step (2). Search stops when we find a UPI related to ùëí ùëñ or we find an empty space in the HT which means ùëí ùëñ does not exist in the STAL. (ii) Access the source timestamp field ùëà ùëÉùêº ùëí .ùë° ùë† , and follow these steps: ‚Ä¢ Apply a binary search on STAL[ùë†] using ùëà ùëÉùêº ùëí .ùë° ùë† to get the STALB to which ùë° ùë† belongs, again apply a binary search on that STALB to get the IEM block where the out-of-order update is placed, further access the OOO field of that IEM block to get the ART root, and search the ART with ùë° ùë† as a key, to get the OEM block of ùëà ùëÉùêº ùëí . ‚Ä¢</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>) Traverse IEMEntries and in parrallel DestEntries, from the position IEMEntries.CurIndex. For each IEM entry ùëö, at position ùëùùëö in IEMEntries: (a) Check whether ùëö.WTS &lt; ùúè: recall that WTS is the transaction time of ùëö. If this holds, and the current STALB is in case (1d), return DestEntries[ùëùùëö], the destination node corresponding to the position of ùëö (recall from Section 4 that IEMEntries and DestEntries are parallel, same-size arrays). Otherwise, ignore ùëö it and move to the next IEM entry. The check helps ensuring snapshot isolation: we only read the (non-deleted) edge entries that existed in the STALB before ùúè. (b) Check ùëö's OOO and/or ITM fields, or both, when the STALB is in case (1a), (1b) or (1c) above. If ùëö has out-oforder updates, its OOO field points to an ART. For each OEM entry in that ART, call it ùëú, proceed as follows: (i) Check that ùëú.WTS &lt; ùúè; WTS is the transaction time of the out-of-order entry ùëú. If this holds, and the current STALB meets only case (1c), return ùëú.ùê∑ùëÅùëúùëëùëí; otherwise move to the next ART entry. (ii) If the current STALB includes deletions (IsDelete flag), also check the ITM field of ùëú, to see whether ùëú is deleted or not. If it is not deleted, return ùëú.ùê∑ùëÅùëúùëëùëí; otherwise, the OEM entry is ignored. If ùëö has ITM, then ignore the entry; otherwise, return ùê∑ùëíùë†ùë°ùê∏ùëõùë°ùëüùëñùëíùë† [pm].</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>) Through binary search on ùëÜ ùëù with ùúè as search key, get the entry location to start reading, say, ùëí ùëñ . (3) Access the IEMEntries, and DestEntries fields of each STALB. For ùëÜ ùëù , scanning starts from the IEMEntries[ùëí ùëñ ]; for older STALBs, it starts from the IEMEntries[CurIndex]. For each IEM entry in the STALB, call it ùëö, we check the below conditions: (a) ùëö.WTS &lt; ùúè ‚Ñé , where WTS is the transaction time of the IEM entry. If it is true and the current STALB is in the case (1d) introduced in the Section 8.1, return DestEntries[current index]; otherwise, ignore it and move to the next. This ensures that ‚Ñé ùëû only reads edge entries that existed before the ùúè ‚Ñé timestamp, contributing to consistency (snapshot Check if ùëö.SrcTime &gt; ùúè. If yes, ùëö belongs to the result, because at timestamp ùúè, ùëö was valid (not yet deleted). Hence, return DestEntries[DestEntries.CurIndex]. If ùëö.OOO exists, access the root of the ART, and for each OEM entry in that ART, call it ùëú, do the following: (i) Check if ùëú.WTS &lt; ùúè ‚Ñé ; WTS refers to the transaction time of out-of-order entry. If this holds, and if the current STALB is in the case (1c) introduced in Section 8.1, return ùëú.DNode; otherwise move to the next ART entry. (ii) If the STALB currently read contains some deletions, check ùëú.ITM to see whether the ùëú is deleted or not. If it is not deleted, return ùëú.DNode. If ùëú is deleted, follow the below steps: (A) Access the ùëú.ITM block, say ùêºùëá ùëÄ ùëú . (B) Check if ùêºùëá ùëÄ ùëú .SrcTime &lt; ùúè. If yes, then ùëú should contribute to the result, because at the ùúè timestamp, ùëú was valid; hence, return the ùëú.DNode.</figDesc><table><row><cell>isolation).</cell></row><row><cell>(b) Check the ùëö's OOO and/or ITM fields, or both, when the</cell></row><row><cell>current STALB is in one among the cases (1a), (1c), or</cell></row><row><cell>(1b, introduced in Section 8.1. If ùëö.ITM exists, proceed as</cell></row><row><cell>follows:</cell></row><row><cell>(i)</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments This work received support from the <rs type="funder">ANR</rs> <rs type="programName">AI Chair SourcesSay</rs> project.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_MHgDBBU">
					<orgName type="program" subtype="full">AI Chair SourcesSay</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">GraphTango: A Hybrid Representation Format for Efficient Streaming Graph Updates and Analysis</title>
		<author>
			<persName><forename type="first">Alif</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Farzana</forename><surname>Ahmed Siddique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Skadron</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2212.11935[cs.DS</idno>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Scott</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krste</forename><surname>Asanoviƒá</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Patterson</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1508.03619[cs.DC</idno>
		<title level="m">The GAP Benchmark Suite</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Robin hood hashing</title>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Celis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Per-√Öke</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Munro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>sfcs</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985. 1985. 1985</date>
			<biblScope unit="page" from="281" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">STINGER: High performance data structure for streaming graphs</title>
		<author>
			<persName><forename type="first">David</forename><surname>Ediger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rob</forename><surname>Mccoll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Riedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A</forename><surname>Bader</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPEC.2012.6408680</idno>
		<ptr target="https://doi.org/10.1109/HPEC.2012.6408680" />
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on High Performance Extreme Computing</title>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Sortledton: A Universal, Transactional Graph Data Structure</title>
		<author>
			<persName><forename type="first">Per</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Margan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jana</forename><surname>Giceva</surname></persName>
		</author>
		<idno type="DOI">10.14778/3514061.3514065</idno>
		<ptr target="https://doi.org/10.14778/3514061.3514065" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1173" to="1186" />
			<date type="published" when="2022-02">2022. feb 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Position Paper: Bitemporal Dynamic Graph Analytics</title>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Halawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matei</forename><surname>Ripeanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GRADES-NDA &apos;21</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">LDBC Graphalytics: A Benchmark for Large-scale Graph Analysis on Parallel and Distributed Platforms</title>
		<author>
			<persName><forename type="first">Alexandru</forename><surname>Iosup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Hegeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lung</forename><surname>Wing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Ngai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnau</forename><surname>Heldens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Prat-P√©rez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Manhardto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihai</forename><surname>Chafio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Narayanan</forename><surname>CapotƒÉ</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilie</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yinglong</forename><surname>Gabriel TƒÉnase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lifeng</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Nai</surname></persName>
		</author>
		<author>
			<persName><surname>Boncz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1317" to="1328" />
			<date type="published" when="2016-09">2016. Sept. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">GraphOne: A Data Store for Realtime Analytics on Evolving Graphs</title>
		<author>
			<persName><forename type="first">Pradeep</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Howie</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th USENIX Conference on File and Storage Technologies (FAST 19)</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="249" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Time, Clocks, and the Ordering of Events in a Distributed System</title>
		<author>
			<persName><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
		<idno type="DOI">10.1145/359545.359563</idno>
		<ptr target="https://doi.org/10.1145/359545.359563" />
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07">1978. jul 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The adaptive radix tree: ARTful indexing for main-memory databases</title>
		<author>
			<persName><forename type="first">Viktor</forename><surname>Leis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfons</forename><surname>Kemper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="38" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Teseo and the Analysis of Structural Dynamic Graphs</title>
		<author>
			<persName><forename type="first">Dean</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leo</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1053" to="1066" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Comparison of Hash Table Performance with Open Addressing and Closed Addressing: An Empirical Study</title>
		<author>
			<persName><forename type="first">Dapeng</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shaochun</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Networked Distributed Comput</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="60" to="68" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">LLAMA: Efficient graph analytics using Large Multiversioned Arrays</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Macko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Virendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">W</forename><surname>Marathe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Margo</forename><forename type="middle">I</forename><surname>Margo</surname></persName>
		</author>
		<author>
			<persName><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 31st International Conference on Data Engineering</title>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="363" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>M√ºhlbauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfons</forename><surname>Kemper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2015 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An empirical evaluation of in-memory multi-version concurrency control</title>
		<author>
			<persName><forename type="first">Yingjun</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joy</forename><surname>Arulraj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiexi</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ran</forename><surname>Xian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Pavlo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="781" to="792" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">LiveGraph: a transactional graph storage system with purely sequential adjacency list scans</title>
		<author>
			<persName><forename type="first">Xiaowei</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guanyu</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Serafini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaosong</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiping</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashraf</forename><surname>Aboulnaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1020" to="1034" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
