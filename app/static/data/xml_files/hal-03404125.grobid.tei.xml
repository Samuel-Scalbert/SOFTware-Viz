<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Beyond Classical SERVICE Clause in Federated SPARQL Queries: Leveraging the Full Potential of URI Parameters</title>
				<funder ref="#_SuCcJhN">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Corby</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Catherine</forename><surname>Faron</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Damien</forename><surname>Graux</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Franck</forename><surname>Michel</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Beyond Classical SERVICE Clause in Federated SPARQL Queries: Leveraging the Full Potential of URI Parameters</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">8057488724BFB4BF84475C008ED908F3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Semantic Web</term>
					<term>URI parameters</term>
					<term>federated querying</term>
					<term>SPARQL</term>
					<term>SPARQL federated query services</term>
					<term>extended SPARQL-based services</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Semantic Web applications integrating very different software and data sources have to face the heterogeneity of the quality and compliance to standards exhibited by each involved resource. In this paper we propose a uniform way of adapting and customizing the behavior of both the client and the server components of an HTTP exchange to cope with this diversity. We revisit the classical SERVICE clause in SPARQL federated queries in order to parameterize the behavior of both the SPARQL client and the SPARQL service. We propose mechanisms to identify and specify SPARQL federated query services and extended SPARQL-based services.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Thanks to the W3C standards, the Web benefits from an unprecedented interoperability that propelled it beyond an "Information management proposal" <ref type="bibr" target="#b3">(Berners-Lee, 1989</ref>) to a universal "application integration platform" <ref type="bibr" target="#b9">(Fielding et al., 2017)</ref> and toward a platform linking all forms of intelligence <ref type="bibr" target="#b1">(Berendt et al., 2021)</ref>.</p><p>To parameterize the calls made between the applications on the Web, the RFC 3986 <ref type="bibr" target="#b2">(Berners-Lee et al., 2005)</ref> defines the query component of a URI as indicated by the first question mark ("?" character) and terminated by a number sign ("#" character) or by the end of the URI. However, the exact structure of the query string is not standardized at the URI level. Although methods used to compose a query string may differ between websites, the original usage in HTML forms popularized the use of query strings composed of a series of field-value pairs where the field name and value are separated by an equals sign ("=") and the pairs are separated by the ampersand sign ("&amp;") as in this example with two parameters gname and fname respectively set to "doe" and "john". The query string of a URI is essentially perceived as a way to pass parameters to the server and to the logic invoked in producing a response. But the position we take in that paper is that, because they are at the frontier between the client and the servers of a Web application, URI parameters can be used to influence the behavior of both these components. Instead of resolving to adhoc hacks, we propose a uniform way, based on the URI query string, to adapt and customize the behavior of the client and the server components of an HTTP exchange. By relying on the standard URI parameters, the approach remains backward compatible as it is transparent for clients or servers that do not implement them and simply ignore them. Moreover, in the context of federated systems, for instance, the same software component may endorse the role of a client or a server in different interactions and this uniform way of parameterizing behaviours works seamlessly in that case too.</p><p>In particular, we propose to exploit the full potential of the query string of a URI in the context of Semantic Web applications <ref type="bibr" target="#b10">(Gandon, 2018)</ref> where the communication between clients and servers is based on SPARQL, standing for SPARQL Protocol and RDF Query Language <ref type="bibr" target="#b11">(Harris and Seaborne, 2013)</ref>. It provides a fully declarative language for query and update operations <ref type="bibr" target="#b0">(Allemang et al., 2020)</ref>. Therefore, unlike with imperative programming languages, it is not possible to embed any instruction to tune the behavior of the SPARQL query processor that is evaluating a SERVICE clause, or to control the query plan that it will come up with. Yet, we may want to customize its behavior based on what we know about the remote service <ref type="bibr">(quotas, supported features, etc.)</ref>.</p><p>In this article, we report our return on experience on using URI parameters to parameterize the behavior of both SPARQL clients and services. Our proposal is motivated by the fact that, although the W3C standards provide an excellent common ground for interoperability, in practice applications integrating very different software and data sources have to face the heterogeneity of the quality and compliance to standards exhibited by each involved resource. One application of great interest is to cope with heterogeneity in the context of federated querying. In particular, in real-world scenarios, a SPARQL query processor evaluating a federated query must be able, on one side, to parameterize the remote SPARQL services' behaviors (for which it is the client) according to their capabilities and specificity, and, on the other side, to adapt its own behavior to the limitations and characteristics of these remote services.</p><p>Nowadays, many national or international projects are facing such a situation, in particular any project targeting scientific data integration will have to address this heterogeneity, for example: the German DFG project FAIR Data Infrastructure for Condensed-Matter Physics and the Chemical Physics of Solids (FAIRmat<ref type="foot" target="#foot_0">1</ref> ) aiming to integrate and make accessible and reusable the enormous amount of data on materials (basic and applied science and engineering) produced in recent years; the French ANR project Data to Knowledge in Agronomy and Biodiversity (D2KAB<ref type="foot" target="#foot_1">2</ref> ) aiming to create a framework to turn agronomy and biodiversity data into an integrated, interoperable and open knowledge graph; the European ERIC project Analysis and Experimentation on Ecosystems (AnaEE<ref type="foot" target="#foot_2">3</ref> ) aiming to integrate all the steps of the scientific experimental methods, modelling and experimentation in order to understand the impact of change drivers on terrestrial and aquatic continental ecosystems across Europe; etc. A common challenge in the development of such research infrastructures (RI) is to provide a unique entry point to the databases provided by the project partners; these are most of the time hugely heterogeneous, not only regarding the data they store and their schemas, but also regarding the servers chosen to store and serve them and the practices adopted by the research teams in charge of configuring them and managing their creation and maintenance.</p><p>Thus, the main research question of this article is: do URI parameters provide an effective way to improve and extend SPARQL-based interaction between Web clients and services? It entails two specific subquestions : can URI parameters allow SPARQL-based interactions that could not be done before? and can URI parameters make existing SPARQL-based interactions more efficient in time, space, etc.?</p><p>To answer these questions, this article is organized as follows: Section 2 discusses related work on the parameterization of client/server exchanges in the context of SPARQL services. Section 3 presents the general principle of our approach to customize the behavior of SPARQL services and clients. The three next sections start from what is already possible to do in terms of parameterization with the standards, and gradually build on it to provide controls over the behaviors of both the client and the server components of a SPARQL exchange. Section 7 presents some experiments that we conducted to validate and demonstrate our approach. Section 8 draws some conclusions and gives directions for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Nowadays, there are many SPARQL endpoints and most of them suffer from partial coverage of the SPARQL query language together with a lack of availability for a great majority of them, as reported by <ref type="bibr" target="#b5">(Buil-Aranda et al., 2013)</ref>. In addition, one recurring problem when dealing with SPARQL endpoints is the limitation of the server's resources allocated to each individual query, often leading to timeouts, errors if the queries were too complex, or even incomplete results. To circumvent these limitations some efforts have been made to set up alternative solutions to the "traditional" SPARQL endpoints such as the SaGe initiative by Minier et al. which relies on Web preemption <ref type="bibr" target="#b15">(Minier et al., 2019)</ref>. Others like C. <ref type="bibr" target="#b6">Buil-Aranda et al. (Buil-Aranda et al., 2014)</ref> propose to split the query into pieces so as to respect the various quotas of the distant SPARQL server. Another approach tackles the challenge the other way around by providing specific interfaces, named Linked Data Fragments <ref type="bibr" target="#b12">(Hartig et al., 2017)</ref> to access the datasets which can then be chosen by users depending on their needs. For example, in the Triple Pattern Fragments approach <ref type="bibr" target="#b20">(Verborgh et al., 2016)</ref>, the server only evaluates triple patterns. However, these fragment approaches generate a large number of subqueries and substantial data transfer.</p><p>Unfortunately, all these methods are applied after reaching these limitations. We aim at preventing these situations. We propose to consider that a wide set of URI parameters -to tune the server's behavior-could prevent these issues by providing SPARQL practitioners with the useful tools. Moreover, we also introduce URI parameters to be interpreted by the client too; which is, to the best of our knowledge, unprece-dented. In particular, we focus our effort (and validate it) on the parameterization of federated querying using the SPARQL SERVICE clause 4 .</p><p>Technically, SPARQL 1.1 Graph Store HTTP Protocol 5 defines a mean for updating and fetching RDF graph content from a Graph Store over HTTP in the REST style. For example the following: DELETE /rdf -graph -store ? graph =&lt; graph_uri &gt; HTTP /1.1 Host : examp . le would be the equivalent of the following SPARQL 1.1. Update operation:</p><formula xml:id="formula_0">DROP GRAPH &lt; graph_uri &gt;</formula><p>As a consequence, some SPARQL engines such as GraphDB 6 , Fuseki 7 or BrightStarDB 8 rely on this to let the SPARQL practitioners slightly tune the queries with additional parameters. Typically, practitioners are e.g. able to select the return format of a query using output=xml to obtain RDF/XML. In addition, GraphDB also provides some additional features for internal federation 9 which unfortunately does not comply with the SPARQL 1.1 standard anymore, at the time of writing of this article, in June 2021. Other solutions like RDF4J 10 <ref type="bibr" target="#b4">(Broekstra et al., 2002)</ref>, Virtuoso 11 <ref type="bibr" target="#b8">(Erling and Mikhailov, 2010)</ref>, Anzo 12 or also BlazeGraph 13 extend the set of possible parameters. For example, RDF4J allows the practitioner to add timeout or limit; with explain, BlazeGraph enables a mode where the query results are extended with explanations of the query plan. When compared to these approaches, we notice that, while these SPARQL endpoint implementations support parameters, they remain specific to the server side and in particular the idea of using them in the context of SPARQL SERVICE clauses is not widespread yet.</p><p>Alternatively to using the SERVICE keyword to access additional endpoints, one may use federated SPARQL services which provide a unified access interface to a set of autonomous data sources. Their main objective is to transform a query posed on a federation of data sources into a query composed of the union of subqueries over individual data sources of the federation. In particular, Saleem et al. studied federated RDF query engines with web access interfaces <ref type="bibr" target="#b17">(Saleem et al., 2016)</ref>. So far, most of the ef-4 SPARQL 1.1 Federated Query 5 Graph Store HTTP Protocol 6 GraphDB compliance with the Graph Store HTTP Protocol 7 Jena Fuseki endpoint configuration 8 BrightStarDB configuration 9 GraphDB internal federation 10 RDF4J repository queries 11 Virtuoso documentation 12 Anzo endpoint configuration 13 BlazeGraph rest API forts have been tackling challenges such as source selection or query planning and few implemented tools provide the practitioners with a way to configure the behaviour of the data sources' endpoints. For example, FedX <ref type="bibr" target="#b18">(Schwarte et al., 2011)</ref> only provides setMaxExecutionTime to define the maximum time for the whole query.</p><p>Finally, regarding the technique we present about unifiying several endpoints under the same banner (see Section 6.1), it is worth mentioning that Comunica <ref type="bibr" target="#b19">(Taelman et al., 2018)</ref> does also provide a similar concept of querying several-at-once. However, Comunica requires practitioners to enter all the wanted sources' URLs<ref type="foot" target="#foot_3">14</ref> from the beginning when our implementation allows the description of a set of endpoints through the use of a dedicated vocabulary. In addition, Comunica does not set up a process to configure the endpoints' behaviors as we propose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">GENERAL PRINCIPLE</head><p>We start with a reminder of the terms of the SPARQL 1.1 Protocol<ref type="foot" target="#foot_4">15</ref> that describes a means for SPARQL protocol clients to submit SPARQL protocol operations (either query or update operations) to a SPARQL protocol service. For brevity, from now on we will omit the protocol term, speaking simply of SPARQL client, SPARQL operation and SPARQL service. We will use the term SPARQL query to denote a SPARQL operation of type query. Furthermore, we will use the terms SPARQL endpoint and SPARQL service interchangeably. In the rest of the paper, we also use the term URL instead of URI because SPARQL endpoints are identified and accessed using URLs.</p><p>A SPARQL client submits a SPARQL operation over HTTP to a SPARQL service that handles the operation and sends the response back to the client. query operations may be submitted using either the HTTP GET or POST method, whereas update operations must be submitted using the POST method. When a SPARQL query is submitted using the GET method, the URL includes, among other possible parameters, the URL-encoded SPARQL query parameter. For instance, the following URL conveys a SPARQL query to a SPARQL service to get all its triples<ref type="foot" target="#foot_5">16</ref> : http :// e.g/ sparql ? query = select * where {? x ?p ?y}</p><p>We propose to use the standard mechanism of URL-encoded query string parameters as a common means to tune the behavior of SPARQL clients and servers involved in an HTTP exchange. Newly defined parameters may pertain to different aspects of the submitted SPARQL operation, such as query planning, authentication, output format, or execution traces. For instance, we can amend the previous example URL to instruct the service to provide some execution traces: http :// e.g/ sparql ?log_level log_level log_level = debug &amp; query = select * where {? x ?p ?y}</p><p>This use of parameters in the URL of an HTTP query is "natural" in the sense that the parameters are interpreted by the service being invoked. We call them "server-side" parameters and explore them in Section 4. We propose to complement this approach with a set of "client-side" parameters in the URL of an HTTP query, meant to tune the behavior of the SPARQL client that initiates the exchange. As far as we know, this is the first documented case of usage of URL parameters for tuning SPARQL clients and it is detailed in Section 5. The primary use case that we foresee is when the SPARQL client is processing a federated query. Within a federated SPARQL query, the SERVICE keyword instructs the query processor to invoke (a portion of) the SPARQL query against a remote SPARQL endpoint identified by its URL. 17 Our rationale here is to tune the behavior of the SPARQL federated query processor that takes the role of a SPARQL client with respect to the remote SPARQL services it federates, by adding query string parameters to the URL of the remote endpoint in a SERVICE clause. For example, if we know that a remote endpoint does not support the HTTP POST method, we can instruct the federated query processor to use only the GET method to communicate with it: SERVICE &lt; http :// e.g/ sparql ?method method method =get &gt; { SELECT * WHERE {? x ?p ?y} }</p><p>Other methods could be figured out to pass such parameters to the SPARQL federated query processor, in the form of SPARQL extensions, for instance using Java-like annotations (introduced with the '@' character). Yet, this would make the SPARQL query invalid for processors that do not support this extension.</p><p>The main interest of using query string parameters in the URL of the SERVICE clause of a SPARQL federated query is that the query remains syntactically fully SPARQL-compliant. Finally, in the continuation of this incremental enrichment of the SPARQL 1.1 Protocol, we propose to also leverage URL parameters as a means to control the behavior of what we call "extended 17 https://www.w3.org/TR/sparql11-federated-query/ SPARQL-based services". Such services are invoked with regular SPARQL query operations, but their behavior differs from regular SPARQL services in that their output may be different from regular SPARQL query results, or they may implement a custom service logic fulfilling specific needs. Typically, a SPARQL federated query processor can be such an extended SPARQL-based service: it takes as an input a SPARQL query, rewrites it into a federated query, communicates with remote SPARQL services to evaluate the query, then returns the SPARQL results. Although its interface complies with that of a SPARQL service, it implements a different logic and therefore may require additional parameters to properly tune its behavior. Another example is that of a service that evaluates an input SPARQL query, applies a custom transformation to the results (e.g. generates an HTML page), and returns the result of this transformation instead of the SPARQL query results. For instance, the following URL asks an extended and named SPARQL-based service to get all its triples and transforms the results in XML format into, by using an XSLT transformation. In the next three sections we will present in details the three patterns of URL parameters for SPARQL:</p><p>• Parameters that modify the behavior of a SPARQL service in Section 4;</p><p>• Parameters that modify the behavior of a SPARQL client, focusing on the case of federated querying using SERVICE clauses, in Section 5;</p><p>• Parameters that impact the behavior of a named extended SPARQL-based service in Section 6.</p><p>The list of all the URL parameters presented in the paper is given in Table <ref type="table" target="#tab_0">1</ref>. It is worth noticing 1) that this is not a closed list and that other URL parameters may be introduced following the same approach to answer new needs, and that 2) the same parameter can modify both the behavior of a service and the behavior of the client, for instance enforcing the format in which a result will be serialized on one side and parsed on the other side. This is notably the case every time a parameter concerns some aspect of the communication (HTTP method, representation format, etc.). As a result, such parameters will appear in both Section 4 and Section 5 where their impact on the behaviors will be explained respectively for the service side and the client side. Yet it can be noticed that, while many SPARQL endpoint implementations support parameters (Virtuoso, BlazeGraph, etc.), the idea of using them in the context of SPARQL SERVICE clauses is not widespread yet. In this section, we first want to establish the interest of these parameters in the context of a SERVICE clause and then propose several new parameters for SPARQL query and update operations.</p><p>The default-graph-uri and the named-graph-uri parameters provide an immediate and standard example as they are defined in the SPARQL 1.1 Protocol to specify the dataset to be used by a SPARQL service in solving a query. In the context of a SERVICE clause, this ability addresses an important limitation of the SPARQL query language that does not support the declarative specification of the dataset for such a clause: FROM and FROM NAMED are not supported at the SERVICE clause level in SPARQL. Although this usage is neither documented in the standards nor widespread in online documentation, it is a perfect example from the standards of the impact of being able to parameterize the behavior of the invoked SPARQL service directly through the URL query string.</p><p>The format parameter was introduced in our implementation to enable us to specify the format of the SPARQL query result expected from the SPARQL service (the SPARQL update operation is not concerned). The motivating scenario is that, in a perfect Web, SPARQL services all support content negotiation and provide correctly formatted results, but in the World Wild Web, SPARQL services may have limitations or bugs in their content negotiation or serializer implementations. The value of a format parameter is a media type<ref type="foot" target="#foot_6">18</ref> . If set, this parameter overrides values provided by the optional HTTP Accept header, if any, and thus bypasses any content negotiation process. For instance, the following URL asks a SPARQL service to provide all its triples in the JSON-LD format.</p><p>http :// e.g/ sparql ?format format format = application / ld + json &amp; query = select * where {? x ?p ?y}</p><p>The access parameter introduced in our implementation enables us to enforce a key-based access control policy on SPARQL services. The motivating scenario is that, in a perfect Web, SPARQL services should serve open data at will to all users, but in the World Wild Web, some private or critical SPARQL services need to limit their access to authorized users for security and privacy concerns or to avoid saturation. Typically, a SPARQL service running in protected mode will not process an HTTP query operation unless this request is parameterized with an authentication key that was delivered by the SPARQL service manager to the authorized users. For instance, the following URL can be used by an authorized user to submit a SPARQL query to a SPARQL service while passing the authentication key a6h3fb58Fbd3:</p><p>http :// e.g/ sparql ?access access access =a6h3fb58Fbd3 a6h3fb58Fbd3 a6h3fb58Fbd3 &amp; query = select * where {? x ?p ?y}</p><p>Note that other authentication and/or authorization mechanisms may be required. For instance, Section 5 describes how a header parameter can pass a security token via the standard Authorization HTTP header.</p><p>The log level parameter was introduced in our implementation to enable us to instruct SPARQL services to turn on the generation of execution traces.</p><p>The motivating scenario is that, in a perfect Web, SPARQL services should always receive SPARQL queries implementing the actual user need and serve the expected data, but in the World Wild Web, some unexpected or missing data may be delivered by a SPARQL service, and like for any program, execution traces are highly valuable to understand abnormal behavior, detect bugs in the service or modify the SPARQL query sent to it. An example URL containing a log level=debug parameter is provided in Section 3. The execution traces are produced in the SPARQL service's logging system. Another implementation could choose to provide the client with such traces by means of the header's link field within XML or JSON SPARQL results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">URL PARAMETERS FOR SPARQL CLIENTS</head><p>In a perfect Web, all SPARQL services implement the full set of SPARQL recommendations, have no timeout nor limited number of results, and perfectly comply with serialization specifications. In the World Wild Web, a SPARQL service may support the HTTP GET method but not the POST method, or may be able to return a valid JSON document but an invalid XML document. Furthermore, public SPARQL endpoints often limit the maximum number of results with quotas, such that a client would need to add the LIMIT and OFFSET modifiers to its SPARQL query in order to incrementally get a complete result set. This is even more striking when federated querying. In the worstcase scenario, to evaluate the SERVICE clauses in a SPARQL federated query, the SPARQL query processor may need to adapt its behavior to the issues or limitations of each one of the SPARQL remote services that the query involves. Unfortunately, SPARQL does not allow specifying such a fine-tuning in a declarative manner. Therefore, in this section we consider the case where URL parameters are not only meant for the SPARQL service being invoked but also, or rather, meant to modify the behavior of the SPARQL client sending an HTTP request to a SPARQL service or receiving its response. More precisely, in our implementation we have introduced several query string parameters in the URL of the SERVICE clause, that are interpreted by the SPARQL federated query processor (the client) to tune its behavior -and that may also be interpreted by the remote SPARQL service or simply be ignored.</p><p>The method parameter specifies the HTTP method (GET or POST) to be used by the federated query processor to submit a SPARQL query to a remote SPARQL service. For instance, the URL in the following SERVICE clause can be used to ask the federated query processor (the client) to use the HTTP POST method to submit its query to the remote SPARQL service -and to pass the authentication key a6h3fb58Fbd3. The remote SPARQL service may use or ignore any of the parameters, in particular it can ignore the method parameter but enforce the authentication key: SERVICE &lt; http :// e.g/ sparql ?method method method =post post post &amp; access = a6h3fb58Fbd3 &gt; { ?x ?p ?y }</p><p>The format parameter specifies the media type of the query results returned by the SPARQL service. It may be used when the SPARQL service does not support content negotiation and returns results in a fixed format. It may also be the counterpart of the server-side format parameter described in Section 4, that skips the content negotiation process and forces the SPARQL service to return results in the specified media type. Accordingly, on the client side, this parameter instructs the SPARQL federated query processor to select an appropriate parser for the results of a remote service without considering any content negotiation.</p><p>The log level parameter is the counterpart of the server-side log level parameter presented in Section 4. When federated querying, it instructs the client SPARQL federated query processor to turn on the generation of execution traces. This is particularly handy when drafting a SPARQL federated query. Indeed, how a federated query processor rewrites each SERVICE clause, for instance by adding variable bindings, is implementation-dependent. The log level parameter can help query debugging by providing insight into the strategy adopted by the federated query processor when rewriting a certain SERVICE clause.</p><p>The header parameter specifies an HTTP header to be sent by the client SPARQL federated query processor to a remote SPARQL service along with the SPARQL operation. Each parameter value, formatted as name:value, will be passed as a header of the HTTP request. For instance, let us consider the following SERVICE clause: SERVICE &lt; http :// e.g/ sparql ?</p><p>header header header = Authorization : Basic YvcGVuc2VzY &gt; { ?s ?p ?o }</p><p>In this example, the value of parameter header is the HTTP Authorization request header with the Basic type and YvcGVuc2VzY for the credentials value. If the federated query processor uses the HTTP POST method to send the query to the remote SPARQL service, the HTTP request that it will send will look like this:</p><p>POST / sparql HTTP /1.1 Host : e.g Content -Type : application / sparql -query Authorization : Basic YvcGVuc2VzYW SELECT * WHERE { ?s ?p ?o } The limit parameter specifies a limit for the number of results returned by one service call. It instructs the client SPARQL federated query processor to add a LIMIT solution modifier to the query it submits to the remote SPARQL service. For example, the URL in the following SERVICE clause tells the query processor to query the remote service for only its 100 first results for the graph pattern in the clause. SERVICE &lt; http :// e.g/ sparql ?limit limit limit =100 &gt; { ?s ?p ?o }</p><p>The timeout parameter specifies a time quota (in milliseconds) during which the client SPARQL federated query processor will wait for the remote SPARQL service to respond. Once this timeout expires without receiving a response, the federated query processor deems the query as failed. Example: SERVICE &lt; http :// e.g/ sparql ?timeout timeout timeout =5000 &gt; {? s ?p ?o} For simplicity, we consider the connect and read timeouts at once, however they could be distinguished by introducing two different timeout parameters.</p><p>Binding-related parameters. The query plan and strategy adopted by a SPARQL federated query processor to evaluate a SPARQL federated query is implementation-dependent. We introduced in our implementation a set of binding-related, client-side URL parameters to enable a SPARQL practitioner to leverage prior knowledge about a SPARQL service to help the client SPARQL federated query processor to come up with a more efficient query plan.</p><p>The binding parameter specifies the way the client SPARQL federated query processor should pass variable bindings to a remote SPARQL service. Bindings coming from the evaluation of some graph pattern in the federated query are passed to a remote SPARQL service in case the graph pattern it should evaluate shares in-scope<ref type="foot" target="#foot_7">19</ref> variables with the previously evaluated ones. The method used by a client SPARQL federated query processor to pass variable bindings to a remote SPARQL service is implementation-dependent. In a perfect Web, the "natural" way to pass bindings would be to use a VALUES block in the SERVICE clause. But, in the World Wild Web, some SPARQL services do not implement the VALUES clause. Therefore, for the sake of interoperability, by default our implementation uses filters to pass bindings, and we defined a binding parameter to choose among both possible ways. For instance, let us consider the following federated query:</p><p>SELECT * WHERE { ?s ?p ?o. SERVICE &lt; http :// e.g/ sparql ?&gt; {? s ?q ?v. ?o ?q ?w }} and the intermediate variable binding coming from the evaluation of triple pattern ?s ?p ?o: {(?s , s1 ), (?p , p1 ), (?o , o1 )}</p><p>Adding parameter binding=filter to the URL of the SERVICE clause (the default behavior) will cause the federated query processor to generate the SPARQL code:</p><formula xml:id="formula_1">FILTER (? s = s1 &amp;&amp; ?o = o1 )</formula><p>Conversely, adding parameter binding=values will generate the SPARQL code:</p><formula xml:id="formula_2">VALUES (? s ?o) { ( s1 o1 ) }</formula><p>The binding focus and binding skip parameters specify a subset of variables for which variable bindings should or should not be passed to the service. In the example below, the bindings consider variable s and not variable o. The binding slice parameter enables to specify the number of distinct variable bindings sent within one service call. The set of variable bindings is split into subsets of size less than or equal to this number. The service is called once for each such subset of variable bindings. In our implementation, the default value of binding slice is 20. But one could, for instance, force one call per binding:</p><p>SELECT * WHERE { ?s ?p ?o. SERVICE &lt; http :// e.g/ sparql ?binding_slice binding_slice binding_slice =1 &gt; { ?s ?q ?o } }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">NAMED AND EXTENDED SPARQL-BASED SERVICES</head><p>In this section, we generalize on the server-side parameters approach of Section 4. We now propose to mint 20 URLs that identify and specify "extended SPARQL-based services", a kind of services invoked with regular SPARQL query operations, but whose behavior differs from that of regular SPARQL services in that their output may be different from regular SPARQL query results, or they may implement a custom service logic fulfilling specific needs. Their URLs are minted to unambiguously name these services. We put a specific stress on this naming concern because what is at stake here is not just to figure out the URL to access such a service. We mean to use those URLs as URIs, free from any optional query component, identifying these services as firstclass resources, so that we can not only invoke these services, but also annotate them in RDF descriptions, and configure them with server-side URL parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">The common case of SPARQL Federated Query Services</head><p>As federated querying over multiple sources is a very common and important use case in applications such as scientific data integration, this section makes a focus on SPARQL federated query services. In Section 5 we considered the client role of a SPARQL federated query processor communicating with remote SPARQL services to evaluate a SPARQL federated query. Here we consider the service role of a SPARQL federated query processor, serving its results to SPARQL clients that ignore everything about the federation. We denote by "SPARQL federated query service" a set of approaches implementing the federation of several SPARQL services. These can be seen as extended SPARQL-based services insofar as they take as input a regular SPARQL query, but implement a service logic that differs from that of a regular SPARQL service.</p><p>We defined a succinct vocabulary to declare in RDF a SPARQL federated query service. For instance the following RDF/Turtle configuration describes the X SPARQL federated query service, identified by http://e.g/X/sparql, that federates three SPARQL services.</p><p>prefix st : &lt; http :// e.g/ sparql -template /&gt; &lt; http :// e.g ./ X/ sparql &gt; a st : Federation ; st : definition ( &lt; http :// a.b/ blazegraph /Y/ sparql &gt; 20 Minting a URI is the act of establishing the association between the URI and the resource it denotes <ref type="bibr" target="#b0">(Allemang et al., 2020)</ref>.</p><p>&lt; https :// c.d/ fuseki / annotation / sparql &gt; &lt; http :// i.j/ repositories / sparql &gt; ) .</p><p>Below we present two examples of alternative implementations of such SPARQL federated query services that we developed and tested.</p><p>The first one receives a SPARQL query and sends it as is to the remote SPARQL services that it federates, performs the union of partial results and aggregates, if any, and returns the results. The URLs of this first implementation continue to use the /sparql that appears in the URL of standard SPARQL services to suggest that they do not change the query itself.</p><p>The second implementation is what is commonly referred to as a "federation engine". It starts by asking remote SPARQL services which properties and classes occur in their datasets and builds an index from the results. Then, using this index, it rewrites the SPARQL query it received with SERVICE clauses. Each clause is targeting a SPARQL service that, according to the index, may contain results for the triple patterns it specifies. To distinguish this second implementation from the first one, the endpoint URL is minted with /federate in its name: http :// e.g/X/federate federate federate ? query = select * where {? x ?p ?y}</p><p>Similarly to what we demonstrated in Section 4, like for any SPARQL service, we can tune the behavior of such a named SPARQL federated query service by adding query string parameters to its URL:</p><p>The mode=provenance parameter enables to track the provenance of each result. For instance, the query below asks the D2KAB federated service to retrieve arboriculture sub-concepts from any of the federated endpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SELECT DISTINCT * WHERE {</head><p>[] skos : prefLabel " arboriculture " @fr ; skos : narrower + [ skos : prefLabel ? lbl ]. }</p><p>We can submit it with the URL below, where the URL-encoded query is ommitted for clarity: http :// corese . inria . fr / d2kab / sparql ? mode mode mode = provenance &amp; query =...</p><p>Table <ref type="table" target="#tab_2">2</ref> shows a short subset of the results returned, where a pseudo-variable server is added to output the provenance of the variable bindings.</p><p>The accept and reject parameters specify a subset of the SPARQL services to be involved in the evaluation of the query submitted to the SPARQL federated query service. The value of these parameters is Example query result when using the mode=provenance parameter. Variable server provides the URL of the service that yielded this variable binding. server lbl http://ontology.irstea.fr/bsv/sparql vigne de cuve http://ontology.inrae.fr/frenchcropusage/sparql abricotier a string pattern. The SPARQL federated query service should skip the services in its federation whose URL matches the pattern value of the reject parameter and/or consider those whose URL matches the pattern value of the accept parameter. For instance, assuming that the federation configuration names the endpoints of several DBpedia chapters, to answer the SPARQL query encoded in the following URL, the X SPARQL federated query service should consider any DBpedia chapter except the French one.</p><p>http :// e.g/X/ sparql ?accept accept accept =dbpedia dbpedia dbpedia &amp;reject reject reject =dbpedia dbpedia dbpedia .fr fr fr &amp; query = select * where {? x ?p ?y}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Extended SPARQL-based services for application integration</head><p>Generalizing on the previous example of SPARQL federated query services and data integration, we now report on a number of other extended services we experimented with in the more general context of Web application integration. The approach remains the same but is no longer focused on the problem of query federation: we mint URLs to unambiguously name a new service, to annotate it in RDF descriptions, to call it and to configure it with URL parameters.</p><p>RDF transformation services. The transform parameter enables us to turn a SPARQL service into an RDF transformation service. In an ideal Web, everyone would be using the same transformation and rendering techniques and pipelines. In the World Wild Web, the loose coupling of applications and the variety of formats and presentation solutions requires flexible transformation means. A parameterized RDF transformation service returns the result of a transformation that could come from any existing approach such as XSLT <ref type="bibr" target="#b13">(Kay, 2021)</ref>, FRESNEL <ref type="bibr" target="#b16">(Pietriga et al., 2006)</ref> or STTL <ref type="bibr" target="#b7">(Corby et al., 2015)</ref>. For instance, the following parameterized service outputs the transformation of the query results into an HTML page.</p><p>http :// e.g/X/ sparql ?transform transform transform = st :rdf2html rdf2html rdf2html &amp; query = select * where {? x ?p ?y}</p><p>Another example is the generation of widgets exploiting dimensions of the data (time, location, etc.), for instance, a map with plots when the SPARQL query results contain longitude and latitude values.</p><p>SPARQL query result annotation services. The mode=link parameter together with the transform parameter enable us to turn a SPARQL service into a SPARQL query result annotation service. The result of the transformation is stored in a document on the server, a URL is provided for this document and is returned as the value of the link element in the head of the SPARQL query result. For example, the following parameterized service will generate a map with location longitude and latitude, and a link mode that adds the URL of the generated map in the head of the SPARQL query result. SHACL services. In a perfect Web, the data sources we consume would be complete and would meet the level of quality we need. In the World Wild Web, data sources do not always match our criteria and we need means to check if the constraints we have are met. The mode=shacl parameter used in combination with the uri parameter enables to turn a SPARQL service into a SHACL service that evaluate the shapes in the SHACL document, the URL of which is given as value of parameter uri, on the RDF graph it serves. Moreover, the query passed as parameter in the URL is executed on the SHACL validation report graph. For example, the following parameterized service will output the conformity boolean value.</p><p>http :// e.g/X/ sparql ?mode mode mode =shacl shacl shacl &amp;uri uri uri =shape shape shape .rdf rdf rdf &amp; query = select * where {? report sh : conforms ?b }</p><p>Service Definition Specifying a list of parameter values to define extended SPARQL-based services may be cumbersome for some developers and one may want to synthesize a specific list of parameter values within a specific mode. For this purpose, we defined a small vocabulary to enable the user to define in RDF new modes as the combination of several parameters that can be used to parameterize a service just like any predefined mode. For example, the following RDF description defines a map mode as the combination of the st:map transformation that generates a map with location longitude and latitude, and a link mode that adds the URL of the generated map in the head of the SPARQL query result.</p><p>[] st : mode " map " ; st : param ((" mode " " link ")(" transform " st : map )) .</p><p>Developers can then use such defined modes to define an extended service. For example, the following parameterized service is equivalent to the example service illustrating the annotation services.</p><p>http :// e.g/X/ sparql ?mode mode mode =map map map &amp; query = select * where {? x ?p ?y} A generic mode, named "*", enables us to specify parameters that are shared by all the SPARQL-based services offered at a given SPARQL service. For example, the following RDF description states that all the services will run in debug mode.</p><p>[] st : mode "*" ; st : param ((" mode " " debug ")) .</p><p>Services can also be described to associate them a parameter setting, so that the URL that should be used to invoke them will not have any query string parameter. For example, the following RDF description defines a service as parameterized by the (user-defined) map mode:</p><p>&lt; http :// e.g/ map / sparql &gt; st : param ((" mode " " map ")) .</p><p>Once defined like this it can be invoked without any other parameter than the standard query one: http :// e.g/map map map / sparql ? query = select * where {? x ?p ?y}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXPERIMENTS &amp; EVALUATION</head><p>The URL query string parameters presented in the previous sections have been implemented in the Corese Semantic Web factory. 21 In this section, we demonstrate their interest in the context of two example queries that originate from on-going scientific data integration projects. In particular, we show the impact of this parameterization against baseline queries solving the same issues in standard conditions. 21 https://project.inria.fr/corese/</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Binding variables: FILTER / VALUES</head><p>The following query searches the URIs of some spatial entities in a local dataset, and tries to fetch additional information about each of them from Wikidata using a SERVICE clause.</p><p>SELECT ?e ? label WHERE { [] dct : spatial ?e. SERVICE &lt; https :// query . wikidata . org / sparql &gt; { ?e rdfs : label ? label . FILTER ( lang (? label ) = " en ") }} When a SPARQL engine evaluates this query, a possible strategy is to first retrieve the values of variable e (91 distinct values in our case), then pass them to the SERVICE clause as variable bindings. The SPARQL federated query recommendation does not specify the way to pass such bindings. A possible way is to pass them using a filter, i.e. the following query is submitted to Wikidata:</p><p>SELECT * WHERE { ?e rdfs : label ? label . FILTER ( lang (? label ) = " en ") FILTER ((? e= wd : Q6730 ) || (? e= wd : Q12589 ) || ...) }} Unfortunately, Wikidata systematically times out when evaluating such a query. 22 However, we can work around this issue using the binding URL parameter described in Section 5. When we add it to the Wikidata URL as depicted below, &lt; https :// query . wikidata . org / sparql ?binding binding binding =values values values &gt; we instruct our SPARQL engine to use a VALUES block instead of a FILTER. The rewritten query sent to Wikidata now completes in less than one second:</p><p>SELECT * WHERE { VALUES (? entity ) { ( wd : Q6730 ) ( wd : Q12589 ) ... } ?e rdfs : label ? label . FILTER ( lang (? label ) = " en ") }}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Slicing variables bindings</head><p>In the same on-going projects, we identified a second use case that involves the following SPARQL federated query to match resources from two RDF sources using their names: In the first SERVICE clause, variable ?name is matched with 166 values. In the second SERVICE clause, variable ?fullname is matched with over 600,000 values. The second SERVICE clause cannot retrieve values for the ?name variable which is only used in the FILTER. Therefore, our implementation will start with the evaluation of the first SERVICE clause, and then pass the values of variable ?name as bindings to the second SERVICE clause. Furthermore, building on the experience of the use case described in Section 7.1, we added the parameter binding=values to perform the binding using a VALUES block rather than a FILTER.</p><p>The join between the two SERVICE clauses must be done on the ?name variable. Note however that, in the second SERVICE clause, ?name is not directly used as the term of a triple pattern but instead used in a string comparison (strstarts). This makes the query optimization much harder and, consequently, during our experimentations, the Virtuoso OS server at http://e2.g/sparql took in the order of 45 minutes to return the results.</p><p>We made further experiments to assess the number of values that can be passed in the VALUES block while keeping the query processing time below one minute. With one value, Virtuoso consistently took between 4s and 8s to respond. With two values, it took between 2min 30s and 3min. The more values, the longer it took to respond. Therefore, we added parameter binding slice=1 to pass the values of variable ?name one by one. The URL of the second SERVICE clause is as follows:</p><p>&lt; http :// e2 .g/ sparql ?binding binding binding = values &amp;binding_slice binding_slice binding_slice =1 &gt;</p><p>The whole query processing completed in approximately 21 minutes, which is roughly half of the time it took to process the query without the binding slice. The improvement may be deemed modest. It is however important to remind that with a public SPARQL endpoint, where the time quota is typically in the order of one minute, the initial query would never complete, whereas, with our method, it will take time but will complete eventually.</p><p>Without the URL query string parameters introduced in this paper and demonstrated in this section, it is hardly possible to obtain the results solely within SPARQL. Instead, the SPARQL practitioner would have to code a hack in another language to circumvent the limitations. As a comparison, we developed a Python application to achieve the same goal. Based on the SPARQLWrapper library, the program evaluates the first SERVICE clause, stores the temporary results in a DataFrame, and submits the second SERVICE clause one value at a time. This does exactly the same that what we achieve declaratively with just one parameter: binding slice. While the SPARQL query is 10 lines long, the Python program is approximately 100 lines long. Besides, both solutions complete in a similar time since they submit the same number of queries.</p><p>Ultimately, this example also shows that beyond the federated querying use cases we used to demonstrate the interest of URL parameters in SPARQL, this technique is also a way to provide customized proxies masking the limitations and specificities of SPARQL service implementations and supporting the loose-coupling that make the Web an attractive application integration platform <ref type="bibr" target="#b9">(Fielding et al., 2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>In a perfect Web, following standards would be enough. In the World Wild Web, the ability to tune, customize, parameterize the applications may make the difference between a running application and a frozen one. In this paper, we proposed a uniform way of adapting and customizing the behavior of both the client and the server components of an HTTP exchange to cope with the heterogeneity of implementations we find in Web applications. More specifically we designed and experimented the use of URL parameters to parameterize the behaviors of both the SPARQL client and the SPARQL service, in particular in the context of SERVICE clauses used in SPARQL federated queries. We believe that this method has the potential to make federated querying in SPARQL more flexible, actionable, and suited to World Wild Web contexts, far beyond the examples that are generally demonstrated in ideal, controlled environments.</p><p>Another interesting general use case we did not develop here is the debugging of federated queries in the case where the query result is empty. It may be interesting to provide parameters such as mode=explain to obtain additional data such as intermediate query results that can be provided using linked results (mode=link). Hence, URL parameters could be used to tune a debugger.</p><p>In our future work, we also intend to study the relation of the extension we proposed with other parts of the SPARQL standard such as the SPARQL Service Description that "provides a mechanism by which a client or end user can discover information about the SPARQL service" <ref type="bibr" target="#b21">(Williams, 2013)</ref>.</p><p>In the longer term, the annotation technique in-troduced by the mode=link parameter holds the huge potential to turn what are essentially one-off queries into entry points of a hypermedia network of queries. For instance, by providing links to reformulated or relaxed queries, expanded queries, suggested follow-up queries, etc., we would allow non SPARQL clients with classical Web client capabilities to still navigate and discover the content of endpoints as a classical Web hypermedia space just by applying the "follow your nose" principle.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>https :// examp . le / search ? gname = doe &amp; fname = john</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>http :// e.g/transform transform transform / sparql ? format = text / xml &amp; transform transform transform =transfo transfo transfo .xsl xsl xsl &amp; query = select * where {? x ?p ?y}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Overview of URL parameters examples. Parameters in bold are part of the SPARQL protocol.</figDesc><table><row><cell>Parameter</cell><cell>Definition</cell></row><row><cell>default-graph-uri</cell><cell>specify the default named graph</cell></row><row><cell>named-graph-uri</cell><cell>specify the named graphs to use</cell></row><row><cell>format</cell><cell>specify expected result format</cell></row><row><cell>access</cell><cell>provide an access control key</cell></row><row><cell>log level</cell><cell>require logs of the execution</cell></row><row><cell>method</cell><cell>force the HTTP method to use</cell></row><row><cell>header</cell><cell>add an HTTP header</cell></row><row><cell>limit</cell><cell>maximum number of results</cell></row><row><cell>timeout</cell><cell>maximum time for a response</cell></row><row><cell>binding</cell><cell>specify variable binding method</cell></row><row><cell>binding focus</cell><cell>variables to pass in bindings</cell></row><row><cell>binding skip</cell><cell>variables not to pass in bindings</cell></row><row><cell>binding slice</cell><cell>size of bindings for each call</cell></row><row><cell>mode</cell><cell>generic behaviour customizing</cell></row><row><cell>accept</cell><cell>subset of federated services to be used</cell></row><row><cell>reject</cell><cell>subset of federated services not to be used</cell></row><row><cell>transform</cell><cell>apply a transformation to the data</cell></row><row><cell cols="2">4 URL PARAMETERS FOR</cell></row><row><cell cols="2">SPARQL SERVICES</cell></row></table><note><p>This first family of URL parameters is certainly the most natural, standard and common one. It aims at modifying the behavior of the SPARQL service being invoked: a SPARQL service receiving a parameterized HTTP request should adapt its behavior and the returned answer according to the query parameters.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Alternatively, in the example below the bindings do not consider s and consider o only.</figDesc><table><row><cell>SELECT * WHERE {</cell></row><row><cell>?s ?p ?o.</cell></row><row><cell>SERVICE &lt; http :// e.g/ sparql ?binding_focus binding_focus binding_focus =s &gt;</cell></row><row><cell>{ ?s ?q ?o }</cell></row><row><cell>}</cell></row><row><cell>SELECT * WHERE {</cell></row><row><cell>?s ?p ?o.</cell></row><row><cell>SERVICE &lt; http :// e.g/ sparql ?binding_skip binding_skip binding_skip =s &gt;</cell></row><row><cell>{ ?s ?q ?o }</cell></row><row><cell>}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://www.fair-di.eu/fairmat/proposal</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.d2kab.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>https://www.anaee.eu/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_3"><p>Comunica endpoint over multiple sources</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_4"><p>https://www.w3.org/TR/sparql11-protocol/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_5"><p>For readability, the SPARQL query is not URL-encoded.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_6"><p>https://www.iana.org/assignments/media-types/media-types.xhtml</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="19" xml:id="foot_7"><p>https://www.w3.org/TR/sparql11-query/#variableScope</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGEMENTS</head><p>This work was partially supported by the <rs type="funder">French National Research Agency</rs> under grant <rs type="grantNumber">ANR-18-CE23-0017</rs> (<rs type="projectName">D2KAB</rs> project).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_SuCcJhN">
					<idno type="grant-number">ANR-18-CE23-0017</idno>
					<orgName type="project" subtype="full">D2KAB</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Semantic Web for the Working Ontologist</title>
		<author>
			<persName><forename type="first">D</forename><surname>Allemang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
			<publisher>ACM Books</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Web Futures: Inclusive, Intelligent, Sustainable The 2020 Manifesto for Web Science</title>
		<author>
			<persName><forename type="first">B</forename><surname>Berendt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Kinder-Kurlanda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ntoutsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Dagstuhl Manifestos</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Uniform resource identifier (URI): Generic syntax</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berners-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Masinter</surname></persName>
		</author>
		<ptr target="http://www.rfc-editor.org/rfc/rfc3986.txt" />
	</analytic>
	<monogr>
		<title level="j">STD</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Information management: A proposal</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Berners-Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>CERN</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Sesame: A generic architecture for storing and querying RDF and RDF schema</title>
		<author>
			<persName><forename type="first">J</forename><surname>Broekstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kampman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International semantic web conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="54" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">SPARQL web-querying infrastructure: Ready for action?</title>
		<author>
			<persName><forename type="first">C</forename><surname>Buil-Aranda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Umbrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-Y</forename><surname>Vandenbussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="277" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Strategies for executing federated queries in SPARQL 1.1</title>
		<author>
			<persName><forename type="first">C</forename><surname>Buil-Aranda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Umbrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="390" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Generic RDF Transformation Software and its Application to an Online Translation Service for Common Languages of Linked Data</title>
		<author>
			<persName><forename type="first">O</forename><surname>Corby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faron-Zucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th International Semantic Web Conference</title>
		<meeting>14th International Semantic Web Conference<address><addrLine>Bethlehem, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ISWC</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Virtuoso: RDF support in a native RDBMS</title>
		<author>
			<persName><forename type="first">O</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mikhailov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantic Web Information Management</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="501" to="519" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reflections on the rest architectural style and&quot; principled design of the modern web architecture</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Erenkrantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Gorlick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whitehead</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Khare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Oreizy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</title>
		<meeting>the 2017 11th Joint Meeting on Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="4" to="14" />
		</imprint>
	</monogr>
	<note>impact paper award</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Survey of the First 20 Years of Research on Semantic Web and Linked Data</title>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Revue des Sciences et Technologies de l&apos;Information -Série ISI</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<publisher>Ingénierie des Systèmes d&apos;Information</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">SPARQL 1.1 Query Language</title>
		<author>
			<persName><forename type="first">S</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seaborne</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/sparql11-query/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Recommendation, W3C</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A formal framework for comparing linked data fragments</title>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Letter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ternational semantic web conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="364" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">XSL transformations (XSLT) version 2.0</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kay</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2021/REC-xslt20-20210330/" />
	</analytic>
	<monogr>
		<title level="m">W3C recommendation, W3C</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
	<note>second edition)</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Knublauch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Idehen</surname></persName>
		</author>
		<ptr target="https://www.w3.org/Submission/spin-overview/" />
		<title level="m">SPIN-overview and motivation</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>W3C.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">SaGe: Web preemption for public SPARQL query services</title>
		<author>
			<persName><forename type="first">T</forename><surname>Minier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Skaf-Molli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Molli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The World Wide Web Conference</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1268" to="1278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fresnel: A browser-independent presentation vocabulary for rdf</title>
		<author>
			<persName><forename type="first">E</forename><surname>Pietriga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="158" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A fine-grained evaluation of SPARQL endpoint federation systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Saleem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hasnain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ermilov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-C</forename><surname>Ngonga Ngomo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="493" to="518" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fedx: Optimization techniques for federated query processing on linked data</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schwarte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schenkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ternational semantic web conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="601" to="616" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Comunica: a modular SPARQL query engine for the Web</title>
		<author>
			<persName><forename type="first">R</forename><surname>Taelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Herwegen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vander Sande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Verborgh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="239" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Triple Pattern Fragments: a low-cost knowledge graph interface for the Web</title>
		<author>
			<persName><forename type="first">R</forename><surname>Verborgh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vander Sande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Herwegen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Vocht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>De Meester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Haesendonck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Colpaert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="184" to="206" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Williams</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2013/REC-sparql11-service-description-20130321/" />
		<title level="m">SPARQL 1.1 service description. W3C recommendation, W3C</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
