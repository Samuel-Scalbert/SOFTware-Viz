<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Subhedge Projection for Stepwise Hedge Automata</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Al Serhali</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Lille</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Lille</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Subhedge Projection for Stepwise Hedge Automata</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F43CAF2C95FE7085A7282E117CA10925</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show how to evaluate stepwise hedge automata (Shas) with subhedge projection. Since this requires passing finite state information top-down, we introduce the notion of downward stepwise hedge automata. We use them to define an in-memory and a streaming evaluator with subhedge projection for Shas. We then tune the streaming evaluator so that it can decide membership at the earliest time point. We apply our algorithms to the problem of answering regular XPath queries on Xml streams. Our experiments show that subhedge projection of Shas can indeed speed up earliest query answering on Xml streams.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Projection is necessary for running automata on words, trees, hedges or nested words efficiently without having to evaluate irrelevant parts of the input structure. Projection is most relevant for Xml processing as already noticed by <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14</ref>]. Saxon's in-memory evaluator, for instance, projects input Xml document relative to an Xslt program, which contains a collection of XPath queries to be answered simultaneously <ref type="bibr" target="#b10">[11]</ref>. When it comes to processing Xml streams, quite some algorithms <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b5">6]</ref> are based on nested word automata (Nwas), for which an efficient projection algorithm exists <ref type="bibr" target="#b19">[20]</ref>.</p><p>More recently, it was noticed that stepwise hedge automata (Sha) <ref type="bibr" target="#b18">[19]</ref> have important advantages over Nwas when it comes to determinization and earliest query answering <ref type="bibr" target="#b9">[10]</ref>. Shas are a recent variant of standard hedge automata that go back to the sixties <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b20">21]</ref>. They mix up bottom-up processing of standard tree automata with the left-to-right processing of finite word automata (Nfas), but do neither support top-down processing nor have an explicit stack in contrast to Nwas. In particular, it could be shown that earliest query answering for regular queries defined by deterministic Shas <ref type="bibr" target="#b2">[3]</ref> has a lower worst case complexity than for deterministic Nwas <ref type="bibr" target="#b9">[10]</ref>. Shas have the advantage that the set of states that are accessible over some hedge from a given set of start states can be computed in linear time, while for Nwas this requires cubic time.</p><p>Based on deterministic Shas, earliest query answering for regular queries became feasible in practice <ref type="bibr" target="#b2">[3]</ref>, as shown for a collection of deterministic Shas for real word regular XPath queries on Xml documents <ref type="bibr" target="#b1">[2]</ref>. On the other hand side, it is still experimentally slower than the best non-earliest approaches <ref type="bibr" target="#b5">[6]</ref>. We believe that this is due to the fact that projection algorithms for Sha evaluation are missing. Projecting in-memory evaluation assumes that the full graph of the input hedge is constructed at beforehand. Nevertheless, projection may still save time, if one has to run several queries on the same input hedge, or, if the graph got constructed for different reasons anyway. In the streaming case with subhedge projection, the situation is similar: the whole input hedge on the stream needs to be parsed. But only for the nodes that are not projected away, the automaton transitions need to be computed. Given that pure parsing is by two or three orders of magnitude faster, one can save considerable time as noticed in <ref type="bibr" target="#b19">[20]</ref>.</p><p>Consider the example of the XPath filter [self::list][child::item] that is satisfied by an Xml document if its root is an list element that has some item child. When evaluating this filter on an Xml document, it is sufficient to inspect its roots for having label list and then all its children until some item is found. The subhedges of these children can be projected away. However, one must memoize whether the level of the current node is 0, 1, or greater. This level information can be naturally updated in a top-down manner. The evaluators of Shas, however, operate bottom-up and left-to-right exclusively. Therefore, projecting evaluators for Shas need to be based on more general machines. It would not be sufficient to map Shas to Nwas and use their projecting evaluators <ref type="bibr" target="#b19">[20]</ref>. The Nwas obtained by compilation from Shas do not push any information top-down, so no projection is enabled. Thus, the objective of the present paper is to develop evaluators with subhedge projection for Shas.</p><p>As more general machines we propose downward stepwise hedge automata (Sha ↓ s), a variant of Shas that support top-down processing in addition. They are basically Neumann and Seidl's pushdown forest automata <ref type="bibr" target="#b16">[17]</ref>, except that they apply to unlabeled hedges instead of labeled forests. Nwas are known to operate similarly on nested words <ref type="bibr" target="#b8">[9]</ref>, while allowing for more general visible pushdowns. We then distinguish subhedge projection states for Sha ↓ s, and show how to use them to evaluate Shas with subhedge projection both in-memory and in streaming mode. Alternatively, subtree projecting evaluators for Sha ↓ s could be obtained by compiling them to Nwas, distinguishing irrelevant subtrees there <ref type="bibr" target="#b19">[20]</ref>, and using them for subtree projecting evaluation via projecting Nwas.</p><p>As a first and main contribution, we show how to compile Shas to Sha ↓ s so that one can distinguish appropriate subhedge projection states. The idea is to distinguish contexts in which states of the Sha will safely not change. For instance, the XPath filter [self::list][child::item] can be defined by the deterministic Sha in Fig. <ref type="figure" target="#fig_0">1</ref>, which our compiler maps to the Sha ↓ in Fig. <ref type="figure" target="#fig_1">2</ref> (up to renaming of states). The context information made explicit is about the levels of the states. This permits us to distinguish a projection state Π taken from level 2 on in which subhedges can be ignored.</p><p>We prove the soundness of our compiler given in the appendix. The proof is based on an nontrivial invariant, that we establish for a slight adaptation of the original projection algorithm published at FCT <ref type="bibr" target="#b3">[4]</ref>. We also note that our compiler may in the worst case increase the size of the automata exponentially. Therefore, we avoid constructing the Sha ↓ s statically but rather construct only  the needed part of the Sha ↓ s dynamically on the fly when using it to evaluate some hedge with subhedge projection.</p><p>Our second contribution is a refinement of the compiler from Shas to Sha ↓ s for distinguishing safe states for rejection and selection. In this way, we obtain an earliest membership tester for deterministic Shas in streaming mode which improves the recent earliest membership tester of <ref type="bibr" target="#b2">[3]</ref> with subhedge projection. The property of being earliest carries over from there. We lifted this earliest membership tester to an earliest query answering algorithm with subhedge projection for monadic queries defined by deterministic Shas but omit the details.</p><p>Our third contribution is an implementation and experimental evaluation of an earliest query answering algorithm for dShas with subhedge projection (not only of earliest membership testing), by introducing subhedge projection into the AStream tool <ref type="bibr" target="#b2">[3]</ref>. For the evaluation, we consider the deterministic Shas constructed with the compiler from <ref type="bibr" target="#b18">[19]</ref> for the forward regular XPath queries of the XPathMark benchmark <ref type="bibr" target="#b6">[7]</ref> and real-world XPath queries <ref type="bibr" target="#b1">[2]</ref>. It turns out that we can reduce the running time for all regular XPath queries that contain only child axes considerably since large parts of the input hedges can be projected away. For such XPath queries, the earliest query answering algorithm of AStream with projection becomes competitive in efficiency with the best existing streaming algorithm from QuiXPath <ref type="bibr" target="#b5">[6]</ref> (which is non-earliest on some queries though). The win is smaller for XPath queries with descendant axis, where only few subhedge projection is possible. Outline. After some preliminaries in Section 2 and 3. In Section 4 we introduce Sha ↓ s and show that they enable in-memory evaluation with subhedge projection. In Section 5 we show how to compile Shas to Sha ↓ s with subhedge projection states. Streaming evaluators for Sha ↓ s with subhedge projection follow in Section 6. Section 7 improves the compiler from Shas to Sha ↓ s for obtaining an earliest membership tester. Section 8 discusses our practical experiments.</p><p>Publication Comments. This orignial version of this paper paper was published at FCT <ref type="bibr" target="#b3">[4]</ref> without appendix. The appendix of the present longer version <ref type="bibr" target="#b0">[1]</ref> contains supplementary material including in particular the soundness proof of the safe-no-change subhedge projection algorithm. It also contains further discussion on related work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Let A and B be sets and r ⊆ A × B a binary relation. The domain of r is</p><formula xml:id="formula_0">dom(r) = {a ∈ A | ∃b ∈ B. (a, b) ∈ r}. We call r total if dom(r) = A. A partial function f : A → B is a relation f ⊆ A × B that is functional. A total function f : A → B is a partial function f : A → B that is total.</formula><p>Words. Let N be the set of natural numbers including 0. Let the alphabet Σ be a set. The set of words over</p><formula xml:id="formula_1">Σ is Σ * = ∪ n∈N Σ n . A word (a 1 , . . . , a n ) ∈ Σ n</formula><p>where n ∈ N is written as a 1 . . . a n . We denote the empty word of length 0 by ε ∈ Σ 0 and by</p><formula xml:id="formula_2">v 1 • v 2 ∈ Σ * the concatenation of two words v 1 , v 2 ∈ Σ * .</formula><p>Hedges. Hedges are sequences of letters and trees ⟨h⟩ with some hedge h. More formally, a hedge h ∈ H Σ has the following abstract syntax:</p><formula xml:id="formula_3">h, h ′ ∈ H Σ ::= ε | a | ⟨h⟩ | h • h ′ where a ∈ Σ We assume ε • h = h • ε = h and (h • h 1 ) • h 2 = h • (h 1 • h 2 )</formula><p>. Therefore, we consider any word in Σ * as a hedge in H Σ , i.e.,</p><formula xml:id="formula_4">Σ * ∋ aab = a • a • b ∈ H Σ .</formula><p>Nested Words. Hedges can be identified with nested words, i.e., words over the alphabet Σ = Σ ∪ {⟨, ⟩} in which all parentheses are well-nested. This is done by the function nw (h) :</p><formula xml:id="formula_5">H Σ → (Σ ∪ {⟨, ⟩}) * such that: nw (ε) = ε, nw (⟨h⟩) = ⟨ • nw (h) • ⟩, nw (a) = a, and nw (h • h ′ ) = nw (h) • nw (h ′ ).</formula><p>3 Stepwise Hedge Automata (SHAs)</p><p>Stepwise hedge automata (Shas) are automata for hedges mixing up bottom-up tree automata and left-to-right word automata.</p><formula xml:id="formula_6">Definition 1. A stepwise hedge automaton ( Sha) is a tuple A = (Σ, Q, ∆, I, F )</formula><p>where Σ and Q are finite sets, I, F ⊆ Q, and ∆ = ((a ∆ ) a∈Σ , ⟨⟩ ∆ , @ ∆ ) where:</p><formula xml:id="formula_7">a ∆ ⊆ Q × Q, ⟨⟩ ∆ ⊆ Q, and @ ∆ : (Q × Q) × Q.</formula><p>A Sha is deterministic or equivalently a d Sha if I and ⟨⟩ ∆ contain at most one element, and all relations (a ∆ ) a∈Σ and @ ∆ are partial functions.</p><p>The set of state q ∈ Q, subsumes a subset I of initial state, a subset F of final states, and a subset ⟨⟩ ∆ of tree initial states. The transition rules in ∆ have three forms: If (q, q ′ ) ∈ a ∆ then we have a letter rule that we write as q a -→ q ′ in ∆. If (q, p, q ′ ) ∈ @ ∆ then we have an apply rule that we write as: q@p → q ′ in ∆.</p><p>And if q ∈ ⟨⟩ ∆ ∈ Q then we have a tree initial rule that we denote as ⟨⟩ -→ q in ∆. For any hedge h ∈ H Σ we define the transition relation h -→ wrt ∆ such that for all q, q ′ , p, p ′ ∈ Q, a ∈ Σ, and h, h ′ ∈ H Σ :</p><formula xml:id="formula_8">true q ε -→ q wrt ∆ q a -→ q ′ in ∆ q a -→ q ′ wrt ∆ q h -→ q ′ wrt ∆ q ′ h ′ -→ q ′′ wrt ∆ q h•h ′ --→ q ′′ wrt ∆ ⟨⟩ -→ p in ∆ p h -→ p ′ q@p ′ → q ′ in ∆ q ⟨h⟩ --→ q ′ wrt ∆</formula><p>A run of the dSha in Fig. <ref type="figure" target="#fig_0">1</ref> on the tree ⟨h⟩ with subhedge h = list • ⟨item⟩ is illustrated graphically in Fig. <ref type="figure" target="#fig_1">2</ref>. It justifies the transition 0 ⟨h⟩ --→ 4 wrt ∆. The run starts on the top-most level of ⟨h⟩ in the initial state 0 of the automaton. The run on the topmost level is suspended immediately. Instead, a run on the tree's subhedge h on the level below is started in the tree initial state, which is 0 since ⟨⟩ -→ 0 in ∆. This run eventually ends up in state 3 justifying the transition 0 h -→ 3 wrt ∆. The run of the upper level is then resumed from state 0. Given that 0@3 → 4 in ∆ it continues in state 4. In the graph, this instance of the suspension/resumption mechanism is illustrated by the box in the edge 0 4. The box stands for a future value. Eventually, the box is filled by state 3, as illustrated by 3 so that the computation can continue. But in state 4, the upper hedge ends. Since state 4 is final the run ends successfully. The run on the subhedge justifying 0 h -→ 3 wrt ∆ works in analogy. A hedge is accepted if its transition started in some initial state reaches some final state. The language L(A) is the set of all accepted hedges:</p><formula xml:id="formula_9">L(A) = {h ∈ H Σ | q h -→ q ′ wrt ∆, q ∈ I, q ′ ∈ F }</formula><p>For any subset Q ⊆ Q and hedge h ∈ H Σ we define the in-memory evaluation:</p><formula xml:id="formula_10">h (Q) = {q ′ | q h -→ q ′ wrt</formula><p>∆, q ∈ Q}. An in-memory membership tester for h ∈ L(A) can be obtained by computing h (I) by applying the transition relation to all elements recursively and testing whether it contains some final state in F .</p><formula xml:id="formula_11">0 0' 1' 0" 1 ′′ h2 h1 Π 1 ′′ 1' 0" 2" Π 2" 3' 4 list ⟨⟩ ⟨⟩ list ⟨⟩ item</formula><p>Fig. <ref type="figure">4</ref>: A run of the Sha ↓ in Fig. <ref type="figure" target="#fig_1">2</ref> on ⟨list</p><formula xml:id="formula_12">• ⟨list • h 1 ⟩ • ⟨item • h 2 ⟩⟩.</formula><p>4 Downward Stepwise Hedge Automata (SHA ↓ s)</p><p>Shas process information bottom-up and left-to-right exclusively. We next propose an extension to downward stepwise hedge automata with the ability to pass finite state information top-down. These can also be seen as an extension of Neumann and Seidl's pushdown forest automata <ref type="bibr" target="#b17">[18]</ref> from (labeled) forests to (unlabeled) hedges.</p><p>Definition 2. A downward stepwise hedge automaton (Sha ↓ ) is a tuple A = (Σ, Q, ∆, I, F ) where Σ and Q are finite sets, I, F ⊆ Q, and ∆ = ((a ∆ ) a∈Σ , ⟨⟩ ∆ , @ ∆ ). Furthermore,</p><formula xml:id="formula_13">a ∆ ⊆ Q × Q, ⟨⟩ ∆ ⊆ Q × Q, and @ ∆ : (Q × Q) × Q. A Sha ↓</formula><p>is deterministic or equivalently a dSha ↓ if I contains at most one element, and all relations ⟨⟩ ∆ , a ∆ , and @ ∆ are partial functions.</p><p>The only difference to Shas is the form of the tree opening rules. If (q, q ′ ) ∈ ⟨⟩ ∆ ∈ Q then we have a tree initial rule that we denote as: q ⟨⟩ -→ q ′ in ∆. So here the state q ′ where the evaluation of a subhedge starts depends on the state q of the parent. The definition of the transition relation and thus the evaluator of a Sha ↓ differs from that of a Sha by the following equation:</p><formula xml:id="formula_14">q ⟨⟩ -→ p in ∆ p h -→ p ′ wrt ∆ q@p ′ → q ′ in ∆ q ⟨h⟩ --→ q ′ wrt ∆</formula><p>This means that the evaluation of the subhedge h starts in some state p such that q ⟨⟩ -→ p in ∆. So the restart state p now depends on the state q above. This is how finite state information is passed top-down by Sha ↓ s. Shas in contrast operate purely bottom-up and left-to-right.</p><p>An example of an in-memory evaluation on the dSha ↓ in Fig. <ref type="figure" target="#fig_1">2</ref> for the filter [self::list][child::item] is shown in Fig. <ref type="figure">4</ref>. The run of Sha ↓ s works quite similarly to the runs of Shas, just that when restarting a computation in the subhedge of some tree in state q, then it will start in some state p such that q ⟨⟩ -→ p (rather than in some tree initial state that is independent of q). This Fig. <ref type="figure">5</ref>: The Sha ↓ A down for the dSha A in Fig. <ref type="figure" target="#fig_0">1</ref>. can be noticed for example when opening the first subtree labeled with item where a transition rule 1 ′ ⟨⟩ -→ 0 ′′ is applied. One can see that all nodes of the subtrees h 1 and h 2 are evaluated to the projection state Π, which holds finitestate information on the current level that was passed top-down.</p><p>Any Sha A = (Σ, Q, ∆, I, F ) can be mapped to a Sha ↓ A down = (Σ, Q, ∆ down , I, F ) with the same runs and language. The only change is described by the following rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>⟨⟩</head><formula xml:id="formula_15">-→ p in ∆ q ∈ Q q ⟨⟩ -→ p in ∆ down</formula><p>Independently of the current state q ∈ Q, the Sha ↓ A down can start the evaluation of the subhedge of a subtree in any open tree state p ∈ ∆. Note that the conversion preserves determinism. For illustration, the dSha ↓ for dSha from Fig. <ref type="figure" target="#fig_0">1</ref> of the introduction is given in Fig. <ref type="figure">5</ref>. As for other kinds of automata, making them multi-way does not add expressiveness. So we can convert any dSha ↓ A into an equivalent Sha by introducing nondeterminism . Since Shas can be determinized in at most exponential time, the same holds for Sha ↓ s. It is sufficient to convert it to a Sha, determinize it, and identify the resulting dSha with a dSha ↓ .</p><p>We next show how to get subhedge projection for Sha ↓ s. Two notions will be relevant here, automata completeness and subhedge projection states.</p><p>So let A = (Σ, Q, ∆, I, F ) be a Sha ↓ . We call ∆ complete if all its relations (a ∆ ) a∈Σ , ⟨⟩ ∆ and @ ∆ are total. We call A complete if ∆ is complete and I ̸ = ∅. Definition 3. We call a state q ∈ Q a subhedge projection state of ∆ if there exists q ′ ∈ Q called the witness of q such that the set of transition rules of ∆ containing q ′ or with q on the leftmost position is included in:</p><formula xml:id="formula_16">{q ⟨⟩ -→ q ′ , q@q ′ → q, q ′ ⟨⟩ -→ q ′ , q ′ @q ′ → q ′ } ∪{q ′ a -→ q ′ , q a -→ q | a ∈ Σ} q q ′ ⟨⟩ ⟨⟩ a ∈ Σ q ′ q ′ a ∈ Σ</formula><p>In the example Sha ↓ in Fig. <ref type="figure" target="#fig_1">2</ref> Π is a subhedge projection state with witness Π, but also the states 3 ′ , 4, and 2 ′′ are subhedge projection states with witness Π. Note that only inclusion holds for the latter but not equality since this automaton is not complete.</p><p>For complete Sha ↓ s A, the above set must be equal to the set of transition rules of ∆ with q or q ′ on the leftmost position. In the soundness expressed in Proposition 4, completeness will be assumed and the proof relies on it. In the examples, however, we will consider automata that are not complete. Still they are "sufficiently complete" to illustrate the constructions.</p><p>Note that a subhedge projection state q may be equal to its witness q ′ . Therefore the witness q ′ of any subhedge projection state is itself a subhedge projection state with witness q ′ . Let P ⊆ Q be a subset of subhedge projection states of ∆. We define the transition relation with projection h -→ P ⊆ Q × Q with respect to ∆ such that for all hedges h, h ′ ∈ H Σ and letters a ∈ Σ:</p><formula xml:id="formula_17">q ∈ P q h -→ P q wrt ∆ q ̸ ∈ P q a -→ q ′ in ∆ q a -→ P q ′ wrt ∆ q ̸ ∈ P q ε -→ P q wrt ∆ q ̸ ∈ P q h -→ P q ′ wrt ∆ q ′ h ′ -→ P q ′′ wrt ∆ q h•h ′ --→ P q ′′ wrt ∆ q ̸ ∈ P q ⟨⟩ -→ p in ∆ p h -→ P p ′ q@p ′ → q ′ in ∆ q ⟨h⟩ --→ P q ′′ wrt ∆</formula><p>Transitions with respect to P stay in states q ∈ P until the end of the current subhedge is reached. This is correct if p is a subhedge projection state since transitions without subhedge projection don't change state p nor if the run is not blocking.</p><p>Proposition 4. Let A = (Σ, Q, ∆, I, F ) be a complete Sha ↓ and P a subset of subhedge projection states for ∆. Then for all hedges h ∈ H Σ and states q, q ′ ∈ Q:</p><formula xml:id="formula_18">q h -→ q ′ wrt ∆ iff q h -→ P q ′ wrt ∆.</formula><p>For any subset Q ⊆ Q and hedge h ∈ H Σ , we define the in-memory evaluation with subhedge projection:</p><formula xml:id="formula_19">h P (Q) = {q ′ ∈ Q | q h -→ P q ′ wrt</formula><p>∆, q ∈ Q}. An inmemory membership tester for h ∈ L(A) with subtree projection can be obtained by computing h P (I) and testing whether it contains some state in F .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Compiling SHAs to SHA ↓ s with Projection States</head><p>We show how to compile any Sha to some Sha ↓ with subhedge projection states, yielding an evaluator with appropriate subhedge projection for the Sha via the Sha ↓ . This compiler is the most original contribution of the paper.</p><p>Let A = (Σ, Q, ∆, I, F ) be a Sha. For any set Q ⊆ Q we define the set</p><formula xml:id="formula_20">acc ∆ (Q) = {q ′ ∈ Q | ∃ q ∈ Q, h ∈ H Σ . q h -→ q ′ wrt</formula><p>∆}. We note that acc ∆ (Q) can be computed in linear time in the size of ∆. We define:</p><formula xml:id="formula_21">safe ∆ (Q) = {q ∈ Q | acc ∆ ({q}) ⊆ Q}</formula><p>If A is complete and deterministic then safety can be used to characterize universal states, since for all q ∈ Q: L(A[I/{q}]) = H Σ if and only if q ∈ safe ∆ (F ). See Lemma 5 of <ref type="bibr" target="#b2">[3]</ref>. Note that safe ∆ (Q) can be computed in linear time in the size of ∆. We define the set of states that may no more change by:</p><formula xml:id="formula_22">no-change ∆ = {q | q ∈ safe ∆ ({q})}</formula><p>Note that q ∈ no-change ∆ if and only if acc ∆ ({q}) ⊆ {q}. In the example automaton from Fig. <ref type="figure" target="#fig_0">1</ref> we have no-change ∆ = {2, 3, 4}. For any state q ∈ Q and subset of states Q ⊆ Q we define:</p><formula xml:id="formula_23">s-down ∆ (q, Q) = safe ∆ ({p ∈ Q | q@ ∆ p ⊆ Q}) s-no-change ∆ (q) = s-down ∆ (q, {q})</formula><p>A state belongs to s-down ∆ (q, Q) if it can either no more change or if all accessible states p satisfy that q@ ∆ p ⊆ Q.</p><p>We next compile the Sha A to a</p><formula xml:id="formula_24">Sha ↓ A π = (Σ, Q π , ∆ π , I π , F π ).</formula><p>For this let Π be a fresh symbol and consider the state set:</p><formula xml:id="formula_25">Q π = {Π} ⊎ (Q × 2 Q )</formula><p>A pair (q, P ) means that the evaluator in state q may project subhedges if q ∈ P since these will no more lead to any relevant change. The sets of initial and final states are defined as follows:</p><formula xml:id="formula_26">I π = {(q, ∅) | q ∈ I} F π = {(q, ∅) | q ∈ F }</formula><p>How to generated the transition rules of A π from those of A is described in Fig. <ref type="figure" target="#fig_3">6</ref>. When applied to the Sha in Fig. <ref type="figure" target="#fig_0">1</ref> for [self::list][child::item], the construction yields the Sha ↓ in Fig. <ref type="figure" target="#fig_4">7</ref> which is indeed equal to the Sha ↓ from Fig. <ref type="figure" target="#fig_1">2</ref> up to state renaming. When run on the hedge ⟨list</p><formula xml:id="formula_27">• ⟨list • h 1 ⟩ • ⟨item • h 2 ⟩⟩</formula><p>as shown in Fig. <ref type="figure">4</ref>, it does not have to visit the subhedges h 1 nor h 2 , since all of them will be reached starting from the projection state Π.</p><p>Proposition 5 (Soundness). L(A π ) = L(A) for any complete Sha A.</p><p>We have to prove that no more changing states q ∈ P ∪ no-change ∆ is sound. If q ∈ no-change ∆ this follows from the completeness of ∆, so that one can neither block nor change the state. In the case q ∈ P , the intuition is that the state on level above -say r -can no more change, since then P = s-no-change ∆ (r). Neither can the automaton block by completeness. The projecting in-memory evaluator of A π will be more efficient than that the nonprojecting evaluator of A. Note, however, that the size of A π may be exponentially bigger than that of A. Therefore, for evaluating a dSha A with subhedge projection on a given hedge h, we create only the needed part of A π on the fly. This part has size O(|h|) and can be computed in time O(|A| |h|), so the exponential preprocessing time is avoid. Example 6. In order to see how the exponential worst case may happen, we consider a family of regular languages, for which the minimal left-to-right Dfa is exponentially bigger than the minimal right-to-left Dfa. The classical example languages with this property are L n = Σ * .a.Σ n where n ∈ N and Σ = {a, b}. Intuitively, a word in Σ * belongs to L n if and only its n + 1-th letter from the end is equal to "a". The minimal left-to-right Dfa for L n has 2 n+1 many states, since needs to memoize a window of n + 1-letters. In contrast, its minimal rightto-left Dfa has only n + 1 states; in this direction, it is sufficient to memoize the distance from the end modulo n + 1.</p><formula xml:id="formula_28">q a -→ q ′ in ∆ q ̸ ∈ P ∪ no-change ∆ (q, P ) a -→ (q ′ , P ) in ∆ π q ∈ P ∪ no-change ∆ (q, P ) a -→ (q, P ) in ∆ π ⟨⟩ -→ q ′ in ∆ q ̸ ∈ P ∪ no-change ∆ (q, P ) ⟨⟩ -→ (q ′ , s-no-change ∆ (q)) in ∆ π q ∈ P ∪ no-change ∆ (q, P ) ⟨⟩ -→ Π in ∆ π q@p → q ′ in ∆ q ̸ ∈ P ∪ no-change ∆ (q, P )@(p, s-no-change ∆ (q)) → (q ′ , P ) in ∆ π q ∈ P ∪ no-change ∆ (q, P )@Π → (q, P ) in ∆ π a ∈ Σ Π a -→ Π in ∆ π true Π@Π → Π in ∆ π true Π ⟨⟩ -→ Π in ∆ π</formula><p>We next consider the family of hedge languages H n ∈ H Σ such that each node of h ∈ H n is labeled by one symbol in Σ and so that the sequence of labels of some root-to-leave path of h n belongs to L n . Note that H n can be recognized in a bottom-up manner by the dSha A n with O(n + 1) states, which simulates the minimal deterministic Dfa of L n on all paths of the input hedge. For an evaluator with subhedge projection the situation is different. When moving topdown, it needs to memoize the sequence of labels of the n + 1-last ancestors, possibly filled with b ′ s, and there a 2 n+1 such sequences. If for some leaf, its sequence starts with an "a" then the following subhedges with the following leaves can be projected away. As a consequence, there cannot be any Sha ↓ recognizing H n that projects away all irrelevant subhedges with less than 2 n+1 states. In particular, the size of A π n must be exponential in the size of A n . 6 Streaming Evaluators for SHA ↓ s</p><p>Any Sha ↓ yields a visibly pushdown machine <ref type="bibr" target="#b11">[12]</ref> that evaluates nested words in a streaming manner. The same property was already noticed for Neumann and Seidl's pushdown forest automata <ref type="bibr" target="#b8">[9]</ref>. Let A = (Σ, Q, ∆, q init , F ) be a Sha ↓ . A configuration of the corresponding visibly pushdown machine is a pair in K = Q×Q * containing a state and a stack of states. For any word v ∈ Σ * we define the transition relation of the visibly pushdown machine v -→ str ⊆ K × K such that for all q, q ′ ∈ Q and σ ∈ Q * : true</p><formula xml:id="formula_29">(q, σ) ε -→ str (q, σ) wrt ∆ (q, σ) v -→ str (q ′ , σ) (q ′ , σ) v ′ -→ str (q ′′ , σ) wrt ∆ (q, σ) v•v ′ --→ str (q ′′ , σ) wrt ∆ q a -→ q ′ in ∆ q a -→ str q ′ wrt ∆ q ⟨⟩ -→ q ′ in ∆ (q, σ) ⟨ - → str (q ′ , σ • q) wrt ∆ q@p → q ′ in ∆ (p, σ • q) ⟩ - → str (q ′ , σ) wrt ∆</formula><p>The same visibly pushdown machine can be obtained by compiling the Sha to an Nwa. In analogy to Theorem 4 of <ref type="bibr" target="#b8">[9]</ref>, we can show for any hedge h that the streaming transition relation</p><formula xml:id="formula_30">nw (h) ----→ str wrt ∆ is correct for its in-memory transition relation h -→ wrt ∆: Proposition 7. L(A) = {h ∈ H Σ | (q, ε) nw (h) ----→ str (q ′ , ε) wrt ∆, q ∈ I, q ′ ∈ F }.</formula><p>Any nested word v ∈ Σ * can be evaluated in streaming mode on any subset of configurations K ⊆ K: v str (K) = {(q ′ , σ ′ ) | (q, σ) v -→ str (q ′ , σ ′ ) wrt ∆, (q, σ) ∈ K}. So any hedge can be evaluated in streaming mode by computing nw (h) str (I× {ε}). The hedge is accepted if it can reach some final configuration in F × {ε}.</p><p>Going one step further, we show how to enhance the streaming evaluator of an Sha ↓ with subhedge projection, in analogy to the in-memory evaluator. This approach yields a similar result in a more direct manner, as obtained by mapping Sha ↓ s to Nwas, identifying subtree projection states there, and mapping Nwas with subtree projection states to projecting Nwas <ref type="bibr" target="#b19">[20]</ref>.</p><p>Let P ⊆ Q be the subset of subhedge projection states of ∆. We define a transition relation with subhedge projection h -→ str P ⊆ K × K with respect to ∆ such that for all nested words v, v ′ ∈ N Σ , letters a ∈ Σ, states p, q, q ′ , q ′′ ∈ Q and stacks σ, σ ′ , σ ′′ ∈ Q * :</p><formula xml:id="formula_31">q ∈ P (q, σ) v -→ str P (q, σ) wrt ∆ q ̸ ∈ P q a -→ q ′ in ∆ (q, σ) a -→ str P (q ′ , σ) wrt ∆ q ̸ ∈ P q ε -→ str P q wrt ∆ q ̸ ∈ P (q, σ) v -→ str P (q ′ , σ ′ ) wrt ∆ (q ′ , σ ′ ) v ′ -→ str P (q ′′ , σ ′′ ) wrt ∆ (q, σ) v•v ′ --→ str P (q ′′ , σ ′′ ) wrt ∆ q ̸ ∈ P q ⟨⟩ -→ q ′ in ∆ (q, σ) ⟨ - → str P (q ′ , σ • q) wrt ∆ p ̸ ∈ P q@p → q ′ in ∆ (p, σ • q) ⟩ - → str P (q ′ , σ) wrt ∆</formula><p>The projecting transition relation stays in a configuration with a projection state until the end of the current subhedge is reached. This is correct since the state of the non-projecting transition relation would not change the state either, while the visible stack comes back to its original value after the evaluation of a nested word (that by definition is well-nested).</p><p>Proposition 8. Let v be a word in Σ * , ∆ a set of transition rules of a complete Sha ↓ with state set Q, q ∈ Q a state and σ ∈ Q * a stack. For any subset P ⊆ Q of subhedge projection states of ∆:</p><formula xml:id="formula_32">(q, σ) v -→ str (q ′ , σ ′ ) wrt ∆ iff (q, σ) v -→ str P (q ′ , σ ′ ) wrt ∆.</formula><p>For any subset K ⊆ K and nested word v ∈ N Σ we define the streaming evaluation with subhedge projection:</p><formula xml:id="formula_33">v str P (K) = {(q ′ , σ ′ ) | (q, σ) v -→ str P (q ′ , σ ′ ) wrt ∆, (q, σ) ∈ K}</formula><p>A streaming membership tester for h ∈ L(A) with subtree projection can be obtained by computing nw (h) str P (I ×{ε}) and testing whether it contains some state in F × {ε}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Earliest Membership with Subhedge Projection</head><p>We next enhance our compiler from Shas to Sha ↓ s for introducing subtree projection such that it can take safe rejection and safe selection into account. The streaming version for deterministic Shas leads us to an earliest membership tester, which enhances the previous earliest membership tester for dShas from <ref type="bibr" target="#b2">[3]</ref> with subtree projection.</p><p>The idea is as follows: A state is called safe for rejection if whenever the evaluator reaches this state on some subhedge then it can safely reject the hedge independently of the parts that were not yet evaluated. In analogy, a state is safe for selection if whenever the evaluator reaches this state for some subhedge, the full hedge will be accepted.</p><p>Consider a dSha A = (Σ, Q, ∆, I, F ). The states of our dSha ↓ will contain tuples (q, Q, R, S) stating that the evaluator is in state q, that the states in Q are safe no-changes, the states in R are safe for rejection, and the states in S safe for selection. State changes are relevant only if they are not safe for no-change, rejection or selection. Let sel be a fresh symbols beside of Π.</p><p>We next compile the given Sha A to a Sha ↓ A π e = (Σ, Q π e , ∆ π e , I π e , F π e ). We start with set set of states that are safe for selection S 0 = safe ∆ (F ) and respectively safe for rejection R 0 = safe ∆ (Q \ F ). The state sets of A π e are then:</p><formula xml:id="formula_34">Q π e = (Q × 2 Q × 2 Q × 2 Q ) ∪ {Π, sel } I π e = {(q, ∅, R 0 , S 0 ) | q ∈ I, q ̸ ∈ R 0 ∪ S 0 } ∪ {sel | I ∩ S 0 ̸ = ∅} F π e = {(q, ∅, R 0 , S 0 ) | q ∈ F } ∪ {sel }</formula><p>The transition rules in ∆ π e are given by the in Fig. <ref type="figure">8</ref>. For illustration, reconsider the dSha from Fig. <ref type="figure" target="#fig_0">1</ref>. However, it is not sufficiently complete to obtain the expected results. The problem is that s-down ∆ (0, {4}) = {0, 1, 2, 3, 4} there, but only the states 3 is really safe for selection one level down. We therefore add a sink state to it -that we call 5 -yielding the dSha ↓ in Fig. ??. For this dSha, which is still not complete but complete for the intended schema µX.⟨(item+list)•X * ⟩ * . We then get s-down ∆ (0, {4}) = {3, 4}. I may seem counter intuitive that note only state 3 but also state 4 down remains safe for selection. This reflects the fact that no proper subhedge of any hedge satisfying the intended schema may ever get into state 4. Applying the earliest construction with safe-no-change projection to dSha in Fig. ?? yields the dSha ↓ in Fig. <ref type="figure" target="#fig_5">9</ref>. This automaton is the best dSha ↓ that we could hope for the XPath filter [self::list][child::item], enabling earliest query answering with earliest rejection and perfect subhedge projection.</p><p>Running the Sha ↓ s A π e in streaming mode with subtree projection yields an earliest membership tester for dShas with subtree projection. A single adaptations are in order. Whenever the safe selection state sel is reached, the evaluation can be stopped and the input hedge on the stream is accepted. Theorem 1. Let A = (Σ, Q, ∆, I, F ) and P the set of its projection states of ∆ π e with witness either sel or Π. For any hedge h ∈ H Σ with h (I) ̸ = ∅ wrt ∆ (q, P ) a -→ (q ′ , P ) in ∆ π q ′ ̸ ∈ S ∪ R (q, P, S, R) a -→ (q ′ , P, S, R) in ∆ π e (q, P ) ⟨⟩ -→ (q ′ , P ′ ) in ∆ π q ′ ̸ ∈ S ∪ R (q, P, S, R) ⟨⟩ -→ (q ′ , P ′ , s-down ∆ (q, S), s-down ∆ (q, R)) in ∆ π e (q, P )@(p, P ′ ) → (q ′ , P ) in ∆ π q ′ ̸ ∈ S ∪ R (q, P, S, R)@(p, P ′ , s-down ∆ (q, S), s-down ∆ (q, R)) → (q ′ , P, S, R) in ∆ π e (q, P )@Π → (q, P ) in ∆ π q ′ ̸ ∈ S ∪ R (q, P, S, R)@Π → (q, P, S, R) in ∆ π e (q, P ) a -→ (q ′ , P ) in ∆ π q ′ ∈ S (q, P, S, R)</p><formula xml:id="formula_35">a -→ sel in ∆ π e (q, P ) ⟨⟩ -→ (q ′ , P ) in ∆ π q ′ ∈ S (q, P, S, R) ⟨⟩ -→ sel in ∆ π e</formula><p>(q, P )@(p, P ′ ) → (q ′ , P ) in ∆ π q ′ ∈ S (q, P, S, R)@(p, P ′ , s-down ∆ (q, S), s-down ∆ (q, R)) → sel in ∆ π e (q, P )@Π → (q, P ) in</p><formula xml:id="formula_36">∆ π q ′ ∈ S (q, P, S, R)@Π → sel in ∆ π e a ∈ Σ Π a -→ Π in ∆ π e true Π@Π → Π in ∆ π e true Π ⟨⟩ -→ Π in ∆ π e a ∈ Σ sel a -→ sel in ∆ π e µ ∈ Q π e sel @µ → sel in ∆ π e µ ∈ Q π e µ@sel → sel in ∆ π e true sel ⟨⟩ -→ sel in ∆ π e</formula><p>Fig. <ref type="figure">8</ref>: The transition rules of the Sha ↓ A π e inferred from those of the Sha A.</p><p>the streaming evaluation nw (h) str P (I π e ) with respect to ∆ π e checks membership h ∈ L(A) at the earliest event when streaming nw (h).</p><p>The hedge h is accepted once the evaluator reaches state sel . It this doesn't happend online, the truth value of q ∈ F is returned where q is the state in the final tuple.</p><p>Proof (sketch). Let P ′ be the set of projection states of A that use state sel as witness (but not state Π). We obtain an streaming membership tester with earliest selection and earliest rejection (but no safe-no-change subhedge projection) by computing: h str P ′ (I π e ) wrt. ∆ π e Earliest selection is detected by reaching the state sel , while earliest rejection happens when the run fails. We notice that this algorithm is basically the same as the earliest membership tester from Proposition 6 of <ref type="bibr" target="#b2">[3]</ref>, except that it also check for safe rejection. The fact that nested word automata are used there instead of Sha ↓ s here is not essential. So we can rely on the definitions of earliest membership testing and the result given there. In order to add safe-no-change subtree projection, we consider the set of all projection state P of ∆ π e whose witnesses are either Π or sel . We then compute: h str P (I π e ) wrt. ∆ π e . The difference is that the evaluator based on P does also ignore subtrees that go to safe-no-change projection states. Clearly, this does not affect earliest selection nor earliest rejection, so we still have an earliest membership tester, but now safe-no-change subtree projection is added.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Experimental Evaluation</head><p>We integrated subhedge projection into the earliest query answering tool AStream <ref type="bibr" target="#b2">[3]</ref>. It is implemented in Scala while computing safety with ABC Datalog.</p><p>In order to benchmark AStream 2.01 with subhedge projection for efficiency, and to compare it to AStream 1.01 without projection, we considered the regular XPath queries from the XPathMark <ref type="bibr" target="#b6">[7]</ref> A1-A8. We used the deterministic Shas for all these XPath queries constructed by the compiler from <ref type="bibr" target="#b18">[19]</ref>. These were evaluated on Xml documents of variable size created by the XPathMark generator. We did further experiments on a sub-corpus of 79 regular XPath queries extracted by Lick and Schmitz from real-world Xslt and XQuery programs, for which dShas are available <ref type="bibr" target="#b1">[2]</ref>. These experiments confirm the results presented here, so we don't describe them in detail.</p><p>The XPath queries of the XPathMark without descendant axis are A1,A4 and A6-A8. The evaluation time on these queries a 1.2 GB document are reduced between 88 -97%. In average, it is 92.5%, so the overall time is divided by 12. While the parsing time remains unchanged the gain on the automaton evaluation time is proportional to the percentage of subhedge projection for the respective query. This remains true for the other queries with the descendant axis, just that the projection percentage is much lower.</p><p>Finally, we compared AStream with for QuiXPath <ref type="bibr" target="#b5">[6]</ref>, the best previous streaming tool that can answer A1-A8 in an earliest manner. QuiXPath compiles regular XPath queries to possibly nondeterministic early Nwas, and evaluates them with subtree and descendant projection <ref type="bibr" target="#b19">[20]</ref>. QuiXPath is not generally earliest though. On the queries without descendant axis, AStream 1.01 without projection is by a factor of 60 slower than QuiXPath <ref type="bibr" target="#b2">[3]</ref>. With subhedge projection in version 2.01, the overhead goes down to a factor of 5 = 60/12. So our current implementation is close to becoming competitive with the best existing streaming tool while guaranteeing earliest query answering in addition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion and Future Work</head><p>We developed evaluators with subhedge projection for Shas in in-memory mode and in streaming mode. One difficulty was how to push the needed finite state information for subtree projection top-down given that Shas operate bottom-up. We solved it based on a compiler from Shas to downward Shas. This compiler propagates safety information about non-changing states, similar to the propagation of safety information proposed for earliest query answering for dSha queries on nested word streams. We confirmed the usefulness of our novel subhedge projection algorithm for Shas experimentally. We showed that it can indeed speed up the best previously existing earliest query answering algorithm for dSha queries on nested word streams, as needed for answering regular XPath queries on Xml streams. In future work, we plan to improve on subhedge projection for Shas with descendant projection for Shas and to use it for efficient stream processing. Another question is whether and how to obtain completeness results for subhedge projection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proofs for Section 4 (Downward Stepwise Hedge</head><p>Automata (SHA ↓ s))</p><p>Proposition 4. Let A = (Σ, Q, ∆, I, F ) be a complete Sha ↓ and P a subset of subhedge projection states for ∆. Then for all hedges h ∈ H Σ and states q, q ′ ∈ Q:</p><formula xml:id="formula_37">q h -→ q ′ wrt ∆ iff q h -→ P q ′ wrt ∆.</formula><p>Proof. If q ̸ ∈ P, then for any p ∈ Q, q h -→ p wrt ∆ iff q h -→ P p wrt ∆ by definition of the projecting transition relation. If q ∈ P then p is a subhedge projection state of ∆, so the set of transition rules of ∆ containing q ′ or with q on the leftmost position are included in the following:</p><formula xml:id="formula_38">q q ′ ⟨⟩ ⟨⟩ a ∈ Σ q ′ q ′ a ∈ Σ</formula><p>Since ∆ is complete, equality holds. Hence for any hedge h ∈ H Σ it holds that q h -→ q wrt ∆ while q ̸ h -→ p wrt ∆ for all p ̸ = q. The projecting transition relation does the same: q h -→ P q wrt ∆ while q ̸ h -→ P p wrt ∆ for all p ̸ = q. Related Work. We can convert any dSha ↓ A into an equivalent Sha elim ↓ (A) as follows.</p><formula xml:id="formula_39">I elim ↓ = Q × I F elim ↓ = Q × F q ⟨⟩ -→ q ′ in ∆ ⟨⟩ -→ (q, q ′ ) in ∆ elim ↓ q a -→ q ′ in ∆ r ∈ Q (q, r) a -→ (q ′ , r) in ∆ elim ↓ q@p → q ′ in ∆ r ∈ Q (q, r)@(p, q) → (q ′ , r) in ∆ elim ↓ Proposition 9. L(A) = L(elim ↓ (A)).</formula><p>Proof. The construction is analogous to the conversion of Nwas to Shas <ref type="bibr" target="#b18">[19]</ref> or to hedge automata <ref type="bibr" target="#b8">[9]</ref>. The correctness proofs for these compilers are standard.</p><p>It should be noticed that unique minimization fails for Sha ↓ , as usual for deterministic multiway automata. This even happens for deterministic two-way finite state automata on words. In contrast, the class of dShas with the same initial and tree initial state enjoys unique minimization.</p><p>Standard hedge automata [21,5,?,?] have the same expressiveness as Neumann and Seidl's pushdown forest automata <ref type="bibr" target="#b16">[17]</ref> and also as Bojanczyk's forest automata (see Section 3.3 of [?]). Note, however, that there is an exponential difference in succinctness between Shas and Bojanczyk's forest automata. Therefore, these forest automata are of quite different nature from those of Neumann and Seidl.</p><p>B Proofs for Section 5 (Compiling SHAs to SHA ↓ s with Projection States)</p><p>Proposition 5 (Soundness). L(A π ) = L(A) for any complete Sha A.</p><p>Proof. We have to prove that no more changing states q ∈ P ∪ no-change ∆ is sound. If q ∈ no-change ∆ this follows from the completeness of ∆, so that one can neither block nor change the state. In the case q ∈ P , the intuition is that the state on level above -say r -can no more change, since then P = s-no-change ∆ (r). Neither can the automaton block by completeness. We prove the first inclusion L(A) ⊆ L(A π ) based on the following three Claims 5.1a, 5.2a, and 5.3a:</p><formula xml:id="formula_40">Claim 5.1a. Π h -→ Π wrt ∆ π for all hedges h ∈ H Σ .</formula><p>The proof is straightforward by induction on the structure of h. It uses the last three transition rules of ∆ π in Fig. <ref type="figure" target="#fig_3">6</ref> permitting to always stay in Π for whatever hedge follows.</p><p>Claim 5.2a. For all h ∈ H Σ , q ∈ Q, and P ⊆ Q such that q ∈ P ∪ no-change ∆ :</p><formula xml:id="formula_41">(q, P ) h -→ (q, P ) wrt ∆ π</formula><p>We prove Claim 5.2a by induction on the structure of h. Note that the completeness of ∆ will be needed.</p><p>Case h = ⟨h ′ ⟩. In this case, we can use Claim 5.1a to show Π h ′ -→ Π wrt ∆ π and the inference rules</p><formula xml:id="formula_42">q ∈ P ∪ no-change ∆ (q, P ) ⟨⟩ -→ Π in ∆ π</formula><p>q ∈ P ∪ no-change ∆ (q, P )@Π → (q, P ) in ∆ π in order to close the following diagram with respect to ∆ π :</p><formula xml:id="formula_43">(q, P ) Π h ′ Π (q, P ) ⟨⟩</formula><p>This proves (q, P ) h -→ (q, P ) wrt ∆ π as required by the claim. Case h = a. By completeness of ∆ there exists some state q ′ such that q a -→ q ′ in ∆. Since q ∈ P ∪ no-change ∆ we can apply the inference rule:</p><formula xml:id="formula_44">q ∈ P ∪ no-change ∆ (q, P ) a -→ (q, P ) in ∆ π</formula><p>This proves this case of the claim.</p><p>Case h = ε. We trivially have (q, P ) ε -→ (q, P ) wrt ∆ π .</p><p>Case h = h ′ • h ′′ . By induction hypothesis applied to h ′ and h ′′ we have: (q, P ) h ′ -→ (q, P ) and (q, P ) h ′′ --→ (q, P ). Hence (q, P )</p><formula xml:id="formula_45">h ′ •h ′′ ---→ (q, P ).</formula><p>This ends the proof of Claim 5.2. The next claim, in which the induction step is a little more tedious to prove, is the key of the soundness proof.</p><p>Claim 5.3a. Let h ∈ H Σ a hedge, q, q ′ ∈ Q states and P ⊆ Q a subset of states such that acc ∆ (P ) ⊆ P and q ̸ ∈ P ∪ no-change ∆ . If q h -→ q ′ wrt ∆ then there exists q ′′ such that (q, P ) h -→ (q ′′ , P ) wrt ∆ π and (q ′ = q ′′ or q ′ , q ′′ ∈ P ).</p><p>Proof. By induction on the structure of h.</p><p>Case h = ⟨h ′ ⟩. The assumption q h -→ q ′ wrt ∆ shows that there exists some state p ∈ Q closing the following diagram:</p><formula xml:id="formula_46">q ⟨⟩ ∆ h ′ p q ′</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>⟨⟩</head><p>Let P ′ = s-no-change ∆ (q) and note that acc ∆ (P ′ ) ⊆ P ′ . Since q ̸ ∈ P ∪ no-change ∆ we can infer:</p><p>⟨⟩ -→ ⟨⟩ ∆ in ∆ q ̸ ∈ P ∪ no-change ∆ (q, P ) ⟨⟩ -→ (⟨⟩ ∆ , P ′ ) in ∆ π q@p → q ′ in ∆ q ̸ ∈ P ∪ no-change ∆ (q, P )@(p, P ′ ) → (q ′ , P ) in ∆ π Subcase ⟨⟩ ∆ ̸ ∈ P ′ ∪ no-change ∆ . The induction hypothesis applies to h ′ yielding that shows that there exists p ′ such that (⟨⟩ ∆ , P ′ ) h ′ -→ (p, P ′ ) wrt ∆ π and p = p ′ ∨ p, p ′ ∈ P . We distinguish the latter two cases: Subsubcase (⟨⟩ ∆ , P ′ ) h ′ -→ (p, P ′ ) wrt ∆ π . We can close the diagram as follows:</p><p>(q, P )</p><formula xml:id="formula_47">(⟨⟩ ∆ , P ′ ) h ′ (p, P ′ ) (q ′ , P ) ⟨⟩</formula><p>This shows that (q, P ) h -→ (q ′ , P ) wrt ∆ π , so the first disjunct of the claim holds for h. Subsubcase p ∈ P ′ ∧ ∃p ′ ∈ P ′ . (⟨⟩ ∆ , P ′ ) h ′ -→ (p ′ , P ′ ) wrt ∆ π . Since ∆ is complete, there exists a state q ′′ such that q ′′ ∈ q@ ∆ p ′ . Since both p, p ′ ∈ P ′ we have q ′ = q = q ′′ by definition of P ′ = s-no-change ∆ (q). Hence we can close the diagram as follows:</p><p>(q, P ) (⟨⟩ ∆ , P ′ ) h ′ (p ′ , P ′ ) (q ′′ , P )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>⟨⟩</head><p>Since q ′′ = q ′ this shows that (q, P ) h -→ (q ′ , P ) wrt ∆ π , so the first disjunct of the claim holds again.</p><p>Subcase ⟨⟩ ∆ ∈ P ′ ∪ no-change ∆ . Claim 5.2a then shows that (⟨⟩ ∆ , P ′ )</p><formula xml:id="formula_48">h ′ -→ (⟨⟩ ∆ , P ′ ) wrt ∆ π .</formula><p>Subsubcase ⟨⟩ ∆ ∈ P ′ . Since p ∈ acc ∆ (⟨⟩ ∆ ) and acc ∆ (P ′ ) ⊆ P ′ it follows that p ∈ P ′ too. By definition P ′ = s-no-change ∆ (q) and the completeness of ∆, the memberships ⟨⟩ ∆ ∈ P ′ and p ∈ P ′ imply that q@ ∆ ⟨⟩ ∆ = {q} = q@ ∆ p. We can now close the diagram below as follows:</p><p>(q, P )</p><formula xml:id="formula_49">(⟨⟩ ∆ , P ′ ) h ′ (⟨⟩ ∆ , P ′ ) (q, P ) ⟨⟩ Subsubcase ⟨⟩ ∆ ∈ no-change ∆ .</formula><p>In this case ⟨⟩ ∆ = p so that q ′ ∈ q@ ∆ ⟨⟩ ∆ . Hence:</p><p>(q, P ) (⟨⟩ ∆ , P ′ ) h ′ (p, P ′ ) (q ′ , P )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>⟨⟩</head><p>Case h = a. Since q ̸ ∈ P ∪ no-change ∆ we can apply the inference rule:</p><formula xml:id="formula_50">q a -→ q ′ in ∆ q ̸ ∈ P ∪ no-change ∆ (q, P ) a -→ (q ′ , P ) in ∆ π</formula><p>This shows that (q, P ) h -→ (q ′ , P ), so claim is valid with the first disjunct. Case h = ε. In this case we have q = q ′ and (q, P ) ε -→ (q, P ) so the first property required by the claim holds. Case h = h 1 • h 2 . Since q h -→ q ′ wrt ∆, there exists q 1 ∈ Q such that q h1 -→ q 1 wrt ∆ and q 1 h2 -→ q ′ wrt ∆. Since q ̸ ∈ P ∪no-change ∆ , we apply the induction hypothesis on h 1 . This implies that there exists q ′ 1 such that:</p><p>(q, P )</p><formula xml:id="formula_51">h1 -→ (q ′ 1 , P ) wrt ∆ π ∧ (q 1 = q ′ 1 ∨ q 1 , q ′ 1 ∈ P )</formula><p>We distinguish the two cases of the disjunction: Subcase q 1 = q ′ 1 . We also distinguish two subcases here:</p><p>(q, P )</p><formula xml:id="formula_52">µ1 h ′ µ ′ 1 µ ⟨⟩</formula><p>Since q ∈ P ∪ no-change ∆ , the following rule must have been applied to infer (q, P )</p><formula xml:id="formula_53">⟨⟩ -→ µ 1 wrt ∆ π : q ∈ P ∪ no-change ∆ (q, P ) ⟨⟩ -→ Π in ∆ π</formula><p>Therefore µ 1 = Π. Claim 5.1b shows that µ ′ 1 = Π too. So µ must have been infered by applying the rule: q ∈ P ∪ no-change ∆ (q, P )@Π → (q, P ) in ∆ π So µ = (q, P ) as required.</p><p>Case h = a. The following rule must have been applied:</p><formula xml:id="formula_54">q ∈ P ∪ no-change ∆ (q, P ) a -→ (q, P ) in ∆ π</formula><p>Hence, µ = (q, P ). Case h = ε. Obvious. Case h = h 1 • h 2 . There must exist µ 1 such that (q, P )</p><formula xml:id="formula_55">h1 -→ µ 1 h2 -→ µ wrt ∆ π .</formula><p>By induction hypothesis applied to h 1 , we have µ 1 = (q, P ). We can thus apply the induction hypothesis to h 2 to obtain µ 2 = (q, P ). This ends the proof of Claim 5.2b. We next need an inverse of Claim 5.3a. Claim 5.3b. Let h ∈ H Σ a hedge, q ∈ Q states and P ⊆ Q a subset of states such that acc ∆ (P ) ⊆ P and q ̸ ∈ P ∪ no-change ∆ . If (q, P ) h -→ µ wrt ∆ π then there exists q ′ , q ′′ such that µ = (q ′ , P ), q h -→ q ′′ wrt ∆ and (q ′ = q ′′ or q ′ , q ′′ ∈ P ).</p><p>Proof. Let P ⊆ Q and q ∈ Q such that acc ∆ (P ) ⊆ P and q ̸ ∈ P ∪ no-change ∆ . Assume that (q, P ) h -→ µ wrt ∆ π . We prove by induction on h that there exists q ′ such that µ = (q ′ , P ) and ∃q ′′ . (q ′ = q ′′ ∨ q ′ , q ′′ ∈ P ) ∧ q h -→ q ′′ wrt ∆.</p><p>Case h = ⟨h ′ ⟩. By definition of (q, P ) h -→ µ wrt ∆ π there must exist µ 1 , µ ′ 1 ∈ Q π such that the following diagram can be closed:</p><formula xml:id="formula_56">(q, P ) µ1 h ′ µ ′ 1 µ ⟨⟩</formula><p>Since q ̸ ∈ P ∪ no-change ∆ , the following inference rule got applied:</p><formula xml:id="formula_57">⟨⟩ -→ p in ∆ q ̸ ∈ P ∪ no-change ∆ (q, P ) ⟨⟩ -→ (p, s-no-change ∆ (q)) in ∆ π</formula><p>Let P ′ = s-no-change ∆ (q). Hence there exists p ∈ ⟨⟩ ∆ such that µ 1 = (p, P ′ ). Subcase p ∈ P ′ ∪ no-change ∆ . Subsubcase p ∈ P ′ . Since p ∈ acc ∆ ({p}) and P ′ = s-no-change ∆ (q) we have q@p = {q}. So q = q ′ . Furthermore, by completeness of ∆ there exists p ′ such that p h ′ -→ p ′ wrt ∆. In particular p ′ ∈ acc ∆ ({p}) so by definition of P ′ , it follows that q@p ′ → q wrt ∆. Hence, we can close the following diagram:</p><formula xml:id="formula_58">q p h ′ p ′ q ⟨⟩ Since q = q ′ this shows that q ⟨h ′ ⟩ --→ q ′ wrt ∆. Subsubcase p ∈ no-change ∆ . By completeness of ∆ there exists p ′ such that p h ′ -→ p ′ wrt ∆. Since p ∈ no-change ∆ it follows that p ′ = p.</formula><p>Hence, we can close the following diagram:</p><formula xml:id="formula_59">q p h ′ p q ′ ⟨⟩</formula><p>This shows that q ⟨h ′ ⟩ --→ q ′ wrt ∆. Subcase p ̸ ∈ P ′ ∪ no-change ∆ . By induction hypothesis, there exists p ′ , p ′′ such that µ ′ 1 = (p ′ , P ′ ), p h ′ -→ p ′′ wrt ∆, and (p ′ = p ′′ or p ′ , p ′′ ∈ P ′ . By completeness of ∆ there exist q ′′ ∈ q@ ∆ p ′′ and q ′ ∈ q@ ∆ p ′ . Subsubcase p ′ = p ′′ . Hence, we have:</p><formula xml:id="formula_60">q p h ′ p ′ q ′ ⟨⟩ This shows q ⟨h ′ ⟩</formula><p>--→ q ′ wrt ∆. Subsubcase p ′ , p ′′ ∈ P . By definition of P ′ it follows that q ′ = q = q ′′ . Hence:</p><formula xml:id="formula_61">q p h ′ p ′′ q ⟨⟩ h2</formula><p>-→ µ wrt ∆ π and q ′′ 1 ∈ P . Claim 5.2b shows that µ = (q ′′ 1 , P ) wrt ∆ π . We also have q h1 -→ q ′′ 1 wrt ∆. By completeness of ∆, there exist a state q ′′ such that q ′′ 1 h -→ q ′′ wrt ∆. Since q ′ 1 ∈ P and P is closed by accessibility, we have q ′′ ∈ acc({q ′′ 1 }) ⊆ acc(P ) ⊆ P . From q h1 -→ q ′′ 1 wrt ∆, we get q h -→ q ′′ wrt ∆. The claim follows since q ′′ 1 , q ′′ ∈ P . This ends the proof of Claim 5.3b.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of inclusion L(A π ) ⊆ L(A).</head><p>Let h ∈ L(A π ). Then there exists q 0 ∈ I and q ∈ F such that (q 0 , ∅) h -→ (q, ∅) wrt ∆ π . We distinguish two cases:</p><p>Case q 0 ∈ no-change ∆ . Claim 5.2b shows that q = q 0 . Claim 5.2a proves that q 0 h -→ q 0 wrt ∆. Hence q 0 h -→ q wrt ∆ and thus h ∈ L(A). Case q 0 ̸ ∈ no-change ∆ . Claim 5.3b with P = ∅ shows that q 0 h -→ q wrt ∆ π and hence h ∈ L(A π ). This end the proof of the inverse inclusion, and thus of L(A) = L(A π ).</p><p>C Proofs for Section 6 (Streaming Evaluators for SHA ↓ s)</p><formula xml:id="formula_62">Proposition 7. L(A) = {h ∈ H Σ | (q, ε) nw (h) ----→ str (q ′ , ε) wrt ∆, q ∈ I, q ′ ∈ F }.</formula><p>Proof. Straightforward. Proposition 8. Let v be a word in Σ * , ∆ a set of transition rules of a complete Sha ↓ with state set Q, q ∈ Q a state and σ ∈ Q * a stack. For any subset P ⊆ Q of subhedge projection states of ∆:</p><formula xml:id="formula_63">(q, σ) v -→ str (q ′ , σ ′ ) wrt ∆ iff (q, σ) v -→ str P (q ′ , σ ′ ) wrt ∆.</formula><p>Proof. Analogous to the proof of Proposition 4, i.e., the soundness of the inmemory evaluator with projection for complete Sha ↓ s. Related Work. A streaming evaluator for Sha ↓ s via a visibly pushdown machine can also be obtained by compiling a Sha ↓ to a nested word automaton (Nwa) [?], whose streaming evaluator is given by a visibly pushdown machine [?], previously known as input driven automata [?,?,?]. Definition 10. A nested word automata ( Nwa) is a tuple (Σ, Q, Γ, ∆, I, F ), where Σ, Γ and Q are sets, I, F ⊆ Q, and</p><formula xml:id="formula_64">∆ = ((a ∆ ) a∈Σ , ⟨ ∆ , ⟩ ∆ ) contains relations: a ∆ ⊆ Q × Q, ⟨ ∆ ⊆ Q × (Γ × Q) and ⟩ ∆ : Q × Γ × Q.</formula><p>A Nwa is deterministic or equivalently a d Nwa if I contains at most one element and all above relations are partial functions.</p><p>The elements of Γ are called stack symbols. The transition rules in ∆ again have three forms: Internal rules q a -→ q ′ as for Shas, opening rules q ⟨↓γ --→ q ′ if ⟨ ∆ (q) = (q ′ , γ) and closing rules q ⟩↑γ --→ q ′ if ⟩ ∆ (q, γ) = q ′ . The streaming evaluator for Nwas can be seen as pushdown machines for evaluating the nested words of hedges in streaming manner. A configuration of the pushdown machine is a pair in K = Q × Γ * containing a state and a stack. For any word v ∈ Σ * we define a streaming transition relation v -→ str ⊆ K × K such that for all q, q ′ ∈ Q and S ∈ Γ * : true (q, S) ε -→ str (q, S) wrt ∆ (q, S) v -→ str (q ′ , S) (q ′ , S) v ′ -→ str (q ′′ , S) wrt ∆ (q, S)</p><formula xml:id="formula_65">v•v ′ --→ str (q ′′ , S) wrt ∆ q a -→ q ′ in ∆ q a -→ str q ′ wrt ∆ q ⟨↓γ --→ q ′ in ∆ (q, S) ⟨ - → str (q ′ , S) wrt ∆ q ⟩↑γ --→ q ′ in ∆ (q, S • γ) ⟩ - → str (q ′ , S) wrt ∆</formula><p>For any dSha ↓ A = (Σ, Q, ∆, I, F ) we can define the dNwa A nwa = (Σ, Q, Γ, ∆ nwa , I nwa , F nwa ) such that Γ = Q, while ∆ nwa contains for all a ∈ Σ and q, p ∈ Q the transition rules: q a -→ q ′ in ∆ q a -→ q ′ in ∆ nwa q ⟨⟩ -→ q ′ in ∆ q ⟨↓q --→ q in ∆ nwa p@q → q ′ in ∆ q ⟩↑p --→ q ′ in ∆ nwa Lemma 11. L(A nwa ) = L(A).</p><p>The runs of Sha ↓ s A and Nwas A nwa can be identified. Projecting evaluators for Nwas were proposed in the context of projecting Nwas <ref type="bibr" target="#b19">[20]</ref>. They are based on the following notion of states of irrelevant subtrees for Nwas.</p><p>Definition 12 (Variant of Definition 3 of <ref type="bibr" target="#b19">[20]</ref>). We call a state q of an Nwa a state of irrelevant subtrees if there exist two different stack symbols γ, γ ′ and a state q ′ such that the transitions shown on the right exist, but no further opening transitions with γ, no further transitions with γ ′ , and no further closing transition in q popping γ. In this case, we write q ∈ i-tree Σ\∅ .</p><formula xml:id="formula_66">q q ′ ⟨ ↓ γ ⟩ ↑ γ ⟨ ↓ γ ′ ⟩ ↑ γ ′ a ∈ Σ</formula><p>Lemma 13. Any subhedge projection state of a complete Sha ↓ A is a state of irrelevant subtrees of A nwa .</p><p>It was then shown in <ref type="bibr" target="#b19">[20]</ref> how to map an Nwa with a subset P of states of irrelevant subtrees to a projecting Nwa, whose streaming semantics yields a streaming evaluator with subhedge projection. The presentation of subhedge projection for Sha ↓ s without passing via Nwas yields the same result in a more direct manner.</p><p>It should also be notice that projecting Nwas support descendant projection beside of subhedge projection. For Shas this is left to future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Proofs for Section 7 (Earliest Membership with</head><p>Subhedge Projection) Lemma 14. Let P be a subset of projection states of ∆ π e . For any hedge h and prefix v of nw (h), state q ∈ Q, state sets Q, R, S ⊆ Q, and stack σ ∈ Q * : if (I π e , ε) π e v -→ str P ((q, Q, R, S), σ) wrt. ∆ π e and q ∈ S then h ∈ L(A).</p><p>E Proofs for Section 8 (Experimental Evaluation)  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: A unique minimal deterministic Sha (with initial state equal tree initial state) for the XPath filter [self::list][child::item].</figDesc><graphic coords="4,184.91,115.84,100.29,78.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: The deterministic Sha ↓ with subhedge projection state Π obtained by our compiler.</figDesc><graphic coords="4,134.77,201.91,200.57,96.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: A successful run of the Sha in Fig. 1 on ⟨list • ⟨item⟩⟩.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 :</head><label>6</label><figDesc>Fig.6: The transition rules of the Sha ↓ A π inferred from those of the Sha A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: The dSha ↓ A π constructed from the dSha A in Fig. 1 except for useless state transitions leading out of the schema of our application. Note that no-change ∆ = {2, 3, 4}. It is equal to the Sha ↓ in Fig. 2 up to the state renaming 0 = (0, {}), 0 ′ = (0, {2, 4}), 0 ′′ = (0, {1, 3, 4}), 1 ′ = (1, {2, 4}), 1 ′′ = (1, {1, 3, 4}), 2 ′ = (2, {2, 4}), 2 ′′ = (2, {1, 3, 4}), 3 ′ = (3, {2, 4}), 4 = (4, {}).</figDesc><graphic coords="12,134.77,115.83,345.82,158.64" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: The earliest dSha ↓ A π e with safe-no-change subhedge projection for the the Sha A in Fig. 10 adding sink 5 to the dSha in Fig. 1. The states of A π e correspond to the following tuples: 0 = (0, ∅, {1, 2, 3, 5}, {4}), 0 ′ = (0, ∅, {2, 4, 5}, {3, 4}), 1 ′ = (1, ∅, {2, 4, 5}, {3, 4}), 0 ′′ = (0, {1, 3, 4, 5}, ∅, {2, 4, 5}), and 1 ′′ = (1, {1, 3, 4, 5}, ∅, {2, 4, 5}).</figDesc><graphic coords="16,169.35,115.84,276.67,178.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 10 :</head><label>10</label><figDesc>Fig. 10: Adding a sink 5 to the dSha from Fig. 1 for the XPath filter [self::list][child::item].</figDesc><graphic coords="30,221.22,281.65,172.91,181.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>XPathMark list of queries.</figDesc><table><row><cell>Id</cell><cell>XPath Query</cell></row><row><cell>A1:</cell><cell>/site/closed auctions/closed auction/annotation/</cell></row><row><cell></cell><cell>description/text/keyword</cell></row><row><cell>A2:</cell><cell>//closed auction//keyword</cell></row><row><cell>A3:</cell><cell>/site/closed auctions/closed auction//keyword</cell></row><row><cell>A4:</cell><cell>/site/closed auctions/closed auction[annotation/description/</cell></row><row><cell></cell><cell>text/keyword]/date</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Timings in seconds for XPathMark queries that have child axis exclusively with QuiXPath and the two versions of our tool.</figDesc><table><row><cell></cell><cell cols="3">QuiXPath Astream Astream</cell><cell>Gain:</cell><cell>Factor:</cell></row><row><cell></cell><cell></cell><cell>1.01</cell><cell cols="3">2.01 Astream2.01 vs QuiXPath/</cell></row><row><cell></cell><cell></cell><cell cols="2">nonproj. proj.</cell><cell cols="2">Astream1.01 Astream2.01</cell></row><row><cell>A1</cell><cell>11</cell><cell cols="2">644.67 72.83</cell><cell>88.7%</cell><cell>*6.62</cell></row><row><cell>A4</cell><cell>11.6</cell><cell>723.03</cell><cell>78.5</cell><cell>89.14%</cell><cell>*6.77</cell></row><row><cell>A6</cell><cell>10.7</cell><cell cols="2">780.78 65.26</cell><cell>91.64%</cell><cell>*6.1</cell></row><row><cell>A7</cell><cell>8.6</cell><cell cols="2">601.26 24.64</cell><cell>95.9 %</cell><cell>*2.87</cell></row><row><cell>A8</cell><cell>8.8</cell><cell cols="2">801.96 24.85</cell><cell>96.9%</cell><cell>*2.82</cell></row><row><cell cols="2">average 10.14</cell><cell>710.34</cell><cell>53.2</cell><cell>92.45%</cell><cell>*5.036</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Timings in seconds for XPathMark queries that have descendant axis with QuiXPath and the two versions of our tool.</figDesc><table><row><cell></cell><cell cols="3">QuiXPath Astream Astream</cell><cell>Gain:</cell><cell>Factor:</cell></row><row><cell></cell><cell></cell><cell>1.01</cell><cell cols="3">2.01 Astream2.01 vs QuiXPath/</cell></row><row><cell></cell><cell></cell><cell cols="2">nonproj. proj.</cell><cell cols="2">Astream1.01 Astream2.01</cell></row><row><cell>A2</cell><cell>11.4</cell><cell cols="2">569.0112 664.6</cell><cell>-16.8%</cell><cell>*58.3</cell></row><row><cell>A3</cell><cell>11.5</cell><cell cols="2">673.716 666.124</cell><cell>1.13%</cell><cell>*57.92</cell></row><row><cell>A5</cell><cell>12</cell><cell cols="2">593.4648 77.785</cell><cell>86.89%</cell><cell>*6.48</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Subsubcase q 1 ̸ ∈ P . The induction hypothesis applied to h 2 yields: ∃q ′′ .(q 1 , P ) h2 -→ (q ′′ , P ) wrt ∆ π ∧ (q ′ = q ′′ ∨ q ′ , q ′′ ∈ P ) Hence ∃q ′′ . (q, P ) h -→ (q ′′ , P ) wrt ∆ π ∧ (q ′ = q ′′ ∨ q ′ , q ′′ ∈ P ) Subsubcase q 1 ∈ P . By Claim 5.2a, we have (q 1 , P ) h2 -→ (q 1 , P ). We also have q ′ ∈ acc({q 1 }) and since we assume acc(P ) ⊆ P , this implies q ′ ∈ P . Hence (q, P ) h -→ (q 1 , P ) and q ′ , q 1 ∈ P implying the claim with the second disjunct valid. Subcase q 1 , q ′ 1 ∈ P . Since q ′ 1 ∈ P , Claim 5.2a, implies (q ′ 1 , P ) h2 -→ (q ′ 1 , P ) wrt ∆ π . Thus (q, P ) h -→ (q ′ 1 , P ) wrt ∆ π . Since q ′ ∈ acc ∆ ({q 1 }) and q 1 ∈ P it follows that q ′ ∈ acc ∆ (P ) ⊆ P . Here we used as in the previous subsubcase that acc(P ) ⊆ P is assumed by the claim. Let q ′′ = q ′ 1 . Then we have (q, P ) h -→ (q ′′ , P ) wrt ∆ π and q ′ , q ′′ ∈ P showing the claim. This ends the proof of Claim 5.3a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of inclusion L(A) ⊆ L(A π ). Let h ∈ L(A).</head><p>Then there exists q 0 ∈ I and q ∈ F such that q 0 h -→ q. We distinguish two cases:</p><p>Case q 0 ∈ no-change ∆ . By definition of no-change ∆ and since q ∈ acc ∆ (q 0 ) we have q 0 = q. Claim 5.2a shows that (q 0 , ∅) h -→ (q 0 , ∅) wrt ∆ π and thus (q 0 , ∅) h -→ (q, ∅) so that h ∈ L(A π ).</p><p>Case q 0 ̸ ∈ no-change ∆ . Claim 5.3a with P = ∅ shows that (q 0 , ∅)</p><p>This ends the proof of the first inclusion. We next want to show the inverse inclusion L(A π ) ⊆ L(A). It will eventually follow from the following three Claims 5.1b., 5.2b, and 5.3b.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Claim 5.1b. For any hedge h and state</head><p>The proof is straightforward by induction on the structure of h: the only transitions rules of ∆ π with Π on the left hand side are inferred by the last three rules in Fig. <ref type="figure">6</ref>. These require to stay in Π whatever hedge follows.</p><p>Claim 5.2b. For any hedge h, set P ⊆ Q, state q ∈ P ∪ no-change ∆ , and state</p><p>Proof. By induction on the structure of h. Suppose that (q, P )</p><p>This shows q ⟨h ′ ⟩ --→ q wrt ∆. Case h = a. Since q ̸ ∈ P ∪ no-change ∆ , the following inference rule must be used:</p><p>-→ µ wrt ∆ π . Since q ̸ ∈ P ∪ no-change ∆ , we can apply the induction hypothesis to h 1 . It shows that there exists q ′ 1 and q ′′ 1 such that µ 1 = (q ′ 1 , P ) and</p><p>In this case, we can apply the induction hypothesis to (q ′ 1 , P ) h2 -→ µ wrt ∆ π showing the existence of q ′ such that µ = (q ′ , P ) and ∃q ′′ . q ′ 1 h2 -→ q ′′ ∧ (q ′ = q ′′ ∨ q ′ , q ′′ ∈ P ).</p><p>Hence ∃q ′′ . q h -→ q ′′ wrt ∆ ∧ (q ′ = q ′′ ∨ q ′ , q ′′ ∈ P ), so the claim holds.</p><p>Subsubcase q ′ 1 ∈ P ∪ no-change ∆ . Claim 5.2b applied to (q ′ 1 , P ) h2 -→ µ wrt ∆ π shows that µ = (q ′ 1 , P ). Subcase q ′ 1 , q ′′ 1 ∈ P . Recall that (q ′′ 1 , P )</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Subhedge projection for stepwise hedge automata</title>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Al</forename><surname>Serhali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Longer version with appendix of the present paper published at FCT [4</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Benchmark Collection of Deterministic Automata for XPath Queries</title>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Al</forename><surname>Serhali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">XML Prague 2022</title>
		<meeting><address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2022-06">June 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Earliest query answering for deterministic stepwise hedge automata</title>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Al</forename><surname>Serhali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Implementation and Application of Automata -27th International Conference, CIAA 2023</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Nagy</surname></persName>
		</editor>
		<meeting><address><addrLine>Famagusta, North Cyprus</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2023">September 19-22, 2023. 2023</date>
			<biblScope unit="volume">14151</biblScope>
			<biblScope unit="page" from="53" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Subhedge projection for stepwise hedge automata</title>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Al</forename><surname>Serhali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fundamentals of Computation Theory -24th International Symposium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Fernau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Jansen</surname></persName>
		</editor>
		<meeting><address><addrLine>FCT; Trier, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2023-09-18">2023. September 18-21, 2023. 2023</date>
			<biblScope unit="volume">14292</biblScope>
			<biblScope unit="page" from="16" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Tree automata techniques and applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://tata.gforge.inria.fr" />
		<imprint>
			<date type="published" when="1997">1997. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Early nested word automata for XPath query answering on XML streams</title>
		<author>
			<persName><forename type="first">D</forename><surname>Debarbieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zergaoui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">578</biblScope>
			<biblScope unit="page" from="100" to="125" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Franceschet</surname></persName>
		</author>
		<ptr target="https://users.dimi.uniud.it/~massimo.franceschet/xpathmark/PTbench.html" />
		<title level="m">Xpathmark performance test</title>
		<imprint>
			<date type="published" when="2020-10-25">2020-10-25</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Regular tree language recognition with static information</title>
		<author>
			<persName><forename type="first">A</forename><surname>Frisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Frontiers of Theoretical Informatics, IFIP 18th World Computer Congress, TCS 3rd International Conference on Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="661" to="674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Streaming tree automata</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Roos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="13" to="17" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Earliest query answering for deterministic nested word automata</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th International Symposium on Fundamentals of Computer Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5699</biblScope>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The saxon xslt and xquery processor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kay</surname></persName>
		</author>
		<ptr target="https://www.saxonica.com" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Visibly pushdown automata for streaming XML</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th international conference on World Wide Web</title>
		<imprint>
			<publisher>ACM-Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1053" to="1062" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Query automata for nested words</title>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">34th International Symposium on Mathematical Foundations of Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5734</biblScope>
			<biblScope unit="page" from="561" to="573" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">XPath whole query optimization</title>
		<author>
			<persName><forename type="first">S</forename><surname>Maneth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLPB Journal</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="882" to="893" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Projecting XML documents</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Siméon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="213" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">High-performance complex event processing over XML streams</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Candan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Fuxman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Candan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Fuxman</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="253" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Locating matches of tree patterns in forests</title>
		<author>
			<persName><forename type="first">A</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Technology and Theoretical Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1530</biblScope>
			<biblScope unit="page" from="134" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Locating matches of tree patterns in forests</title>
		<author>
			<persName><forename type="first">A</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th Conference on Foundations of Software Technology and Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Determinization and minimization of automata for nested words revisited</title>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sakho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">68</biblScope>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Projection for Nested Word Automata Speeds up XPath Evaluation on XML Streams</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM)</title>
		<meeting><address><addrLine>Harrachov, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Characterizing derivation trees of context-free grammars through a generalization of automata theory</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="317" to="322" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
