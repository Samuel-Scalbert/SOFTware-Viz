<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Integrating connection search in graph queries</title>
				<funder ref="#_tsxEjUB">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christos</forename><surname>Angelos</surname></persName>
							<email>angelos.anadiotis@oracle.com</email>
						</author>
						<author>
							<persName><surname>Anadiotis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<email>ioana.manolescu@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Madhulika</forename><surname>Mohanty</surname></persName>
							<email>madhulika.mohanty@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<settlement>Oracle</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Inria and IPP</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Inria and IPP</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Integrating connection search in graph queries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3AF57392A5F46952DCC6362CFC37658C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graph data management and querying has many practical applications. When graphs are very heterogeneous and/or users are unfamiliar with their structure, they may need to find how two or more groups of nodes are connected in a graph, even when users are not able to describe the connections. This is only partially supported by existing query languages, which allow searching for paths, but not for trees connecting three or more node groups. The latter is related to the NP-hard Group Steiner Tree problem, and has been previously considered for keyword search in databases.</p><p>In this work, we formally show how to integrate connecting tree patterns (CTPs, in short) within a graph query language such as SPARQL or Cypher, leading to an Extended Query Language (or EQL, in short). We then study a set of algorithms for evaluating CTPs; we generalize prior keyword search work, most importantly by (ùëñ) considering bidirectional edge traversal and (ùëñùëñ) allowing users to select any score function for ranking CTP results. To cope with very large search spaces, we propose an efficient pruning technique and formally establish a large set of cases where our algorithm, MoLESP, is complete even with pruning. Our experiments validate the performance of our CTP and EQL evaluation algorithms on a large set of synthetic and real-world workloads.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graph databases are increasingly adopted in a wide range of applications spanning from social network analysis to scientific data exploration, the financial industry, and many more. To query RDF graphs, one can use the W3C's standard SPARQL <ref type="bibr" target="#b12">[13]</ref> query language; for property graphs, Cypher <ref type="bibr" target="#b34">[35]</ref> is among the best known. An interesting but challenging query language feature is reachability: a SPARQL 1.1 query can check, e.g., if there are some paths along which Mr. Shady deposits funds into a given bank ABC. Such queries are important in investigative journalism applications <ref type="bibr" target="#b4">[5]</ref>, in the fight against money laundering, etc. SPARQL allows checking for the existence of a path, but does not return the matching paths to users. In contrast, a Cypher query may also return the paths between two given sets of nodes.</p><p>Unfortunately, none of these languages support finding trees, connecting three (or more) sets of nodes, while the latter can be very useful. For instance, when investigating ill-acquired wealth, one may want to find "all connections between Mr. Shady, bank company ABC, and the tax office of the DEF republic": an answer to this query is a tree, connecting three nodes corresponding to the person, bank, and tax office, respectively.</p><p>Searching for connections among ùëö sets of nodes is closely related to the Group Steiner Tree Problem (GSTP), which asks for the least-cost, e.g., fewest-edges, tree; the problem is NP-hard. The database literature has studied many variants of this problem under the * Work done while at Ecole Polytechnique. name of keyword search in databases, for e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b43">44]</ref>. To cope with the high complexity, existing algorithms (ùëñ) consider a fixed cost function and leverage its properties to limit the search, (ùëñùëñ) propose approximate solutions, within a known distance from the optimum, and/or (ùëñùëñùëñ) implement heuristics without guarantees but which have performed well on some problems. Requirements Our recent collaborations with investigative journalists <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> lead to identifying the following set of needs. First, (R1) graph query languages should allow returning trees that connect ùëö node sets, for some integer ùëö ‚â• 2; (R2) it must be possible to search for connecting trees orthogonally to (or, in conjunction with any) score functions used to compare and rank the trees. This is because different graphs and applications are best served by different scores, and when exploring a graph, journalists need to experiment with several before they find interesting patterns. For instance, in the example above, if Mr. Shady is a citizen of DEF and ABC has offices there, the smallest solution connects them through the DEF country node; however, this is not interesting to journalists. Instead, a connection through three ABC accounts, sending money from DEF to Mr. Shady in country GHI, is likely much more interesting. An orthogonal requirement is (R3) to treat graphs as undirected when searching for trees. For instance, the graph may contain "Mr. Shady hasAccount ---------‚Üí acct 1 ", or, just as likely, "acct 1 belongsTo --------‚Üí Mr. Shady". We cannot afford to miss a connecting tree because we "expected" an edge in a direction and it happens to be in the opposite direction. Further, (R4) all answers need to be found (within a time and/or space budget) for several reasons: (ùëñ) continuity with the semantics of standard graph query languages, that also return all results (unless users explicitly LIMIT the result size); (ùëñùëñ) to remain independent of, and thus orthogonal to, the cost function (recall (R2)); and, (ùëñùëñùëñ) for practical reasons, given the problem complexity, which is further exacerbated by (R3), and renders complete search on large graphs unfeasible. Finally, (R5) the extended queries should be efficiently executed, even when graphs are highly heterogeneous, as in investigative journalism scenarios, where text, structured, and/or semistructured sources are integrated together. Contributions To address the above requirements, we make the following contributions:</p><p>(1) We formally define an Extended Query Language (EQL, in short), which combines together Basic Graph Pattern (or conjunctive) queries at the core of both SPARQL and Cypher, and Connecting Tree Patterns (CTPs, in short). A CTP allows searching for trees that connect ùëö groups of nodes, for ùëö ‚â• 2. BGPs and CTPs can be freely joined. This addresses requirements (R1), (R2), and also (R3), since our CTP semantics returns trees regardless of the edge directions (Section 2).</p><p>(2) We provide a scalable EQL query evaluation strategy, which leverages existing algorithms for the well-studied problem of evaluating conjunctive queries, contributing to (R5) (Section 3).  (3) For CTP evaluation, we study a set of baseline algorithms, and explain that their performance suffers due to repeated (wasted) work and/or the need to minimize the trees they find; GAM <ref type="bibr" target="#b5">[6]</ref> algorithm is more efficient, but it does not scale in all cases. We introduce a powerful Edge Set Pruning (ESP) technique, which significantly speeds up the execution, but can lead to incompleteness. We then bring two orthogonal modifications which, combined, lead to our MoLESP algorithm, for which we formally establish completeness for ùëö ‚àà {2, 3}, which are most frequent, as well as for a large class of results for arbitrarily large ùëö. This addresses requirement (R4) and contributes to (R5) (Section 4).</p><p>(4) We experimentally show that: (ùëñ) baseline algorithms inspired from breadth-first search are unfeasible even for small graphs; (ùëñùëñ) the optimizations we bring here over the GAM algorithm <ref type="bibr" target="#b5">[6]</ref> strongly reduce the search time; (ùëñùëñùëñ) integrating our MoLESP algorithm with a simple conjunctive graph query engine allows to efficiently evaluate queries in our extended language (Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">EXTENDED QUERY LANGUAGE (EQL)</head><p>Definition 2.1 (Graph). A graph G(N, E) consists of a set of nodes N and a set of edges E ‚äÜ N √ó N. Each node ùëõ ‚àà N carries a label ùëô (ùëõ) from a label set L, which includes the empty label ùúñ. Similarly, each edge ùëí ‚àà E has a label ùëô (ùëí) ‚àà L.</p><p>The two main graph data models are RDF graphs, and property graphs (PGs). To illustrate, in the following, we will rely on RDF graphs; our work can be transposed with only surface changes to PGs. Figure <ref type="figure" target="#fig_0">1</ref> introduces a sample graph, assigning an integer ID and label to each node and edge. We will refer to nodes as ùëõ 1 , ùëõ 2 , etc., e.g., ùëõ 1 is the node whose ID is 1 and label is OrgB, and similarly to edges as ùëí 1 , ùëí 2 , etc. Labels of literal nodes, e.g., ùëõ 11 , are enclosed in quotes; the other nodes are URIs. Node and edge properties Graph nodes and edges may have other properties beyond labels; for instance, an RDF node may have 0 or more types. In our example, types are shown in parentheses under the nodes. In a PG, nodes and edges can have multiple properties. We denote by P the set of all properties that nodes and edges may have; each property ùëù ‚àà P is a function ùëù that, given a node ùëõ (or edge ùëí), returns ùëù (ùëõ), the value of property ùëù on node ùëõ (and similarly for ùëí). Without loss of generality, we consider that ùëô:N‚ÜíL belongs to P, that is, the label is a node and/or edge property. Let V be a set of variable names, to be used in queries. Let Œ© = {=, &lt;, ‚â§, ‚àº} be a set of comparison operators, where ‚àº denotes pattern matching such as SQL's like operator. They are used to express predicates over nodes and/or edges, as follows: Definition 2.2 (Predicate). A condition over a variable ùë£ ‚àà V is of the form ùëù (ùë£) ùëúùëù ùëê where ùëù ‚àà P, ùëúùëù ‚àà Œ© and ùëê is a constant such that the operator ùëúùëù is well-defined on any value of property ùëù together with ùëê. A predicate over ùë£ is a conjunction of conditions over ùë£. An empty predicate (no conditions) over ùë£ is simply ùë£.</p><p>A node ùëõ ‚àà N (or edge ùëí ‚àà E) satisfies the predicate if and only if, in every condition of the predicate, replacing ùë£ with ùëõ (respectively, ùëí) and evaluating ùëúùëù yields true. For instance, ùëô (ùë£)‚àº"*lice" ‚àß ùúè (ùë£)=ùúè entrepreneur is a predicate consisting of two conditions, one on the label (which must end in the string "lice") and one on the type, which must be entrepreneur. This predicate is true on the node ùëõ 3 in our example, and false on the other nodes and edges. Any node or edge satisfies the empty predicate. For readability, when a predicate consists of exactly an equality between a node or edge label and a constant, we simply use the constant to denote the predicate, thus, ùëô (ùë£) = "Alice" can be simply written "Alice", when this is unambiguous. However, each predicate always involves exactly one variable (ùë£ in our example), even when the short syntax hides it. We will revert to the longer syntax when we need to make the variable explicit, e.g., use it several times in the query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.3 (Edge Pattern</head><p>). An edge pattern is a triple (ùëù 1 , ùëù 2 , ùëù 3 ) of three predicates: ùëù 1 holds over the source node of an edge, ùëù 2 over the edge itself, and ùëù 3 over the target node.</p><p>For instance, (ùëô (ùë†)="Alice", ùëô (ùëí)="citizenOf", ùëë) states that the source node ùë† is labeled "Alice" and the edge ùëí is labeled "citizenOf". The third predicate is a variable. With the above simplification, we can also write this pattern as ("Alice", "citizenOf", ùëë).</p><p>A core construct of graph query languages is:</p><formula xml:id="formula_0">Definition 2.4 (Basic Graph Pattern). A Basic Graph Pattern (BGP)</formula><p>ùëè is a set of edge patterns that are connected in the following sense.</p><p>If the BGP contains at least 2 edge patterns, each pattern must have a common variable with another edge pattern. A sample BGP ùëè 1 is: {(ùë•, "citizenOf", "USA"), (ùë•, "founded", "OrgB")}. CTPs are used to find connections among nodes, as follows. When replacing each ùëî ùëñ with a graph node, ùë£ ùëö+1 is bound to a subtree of G, having these nodes as leaves (we formalize this below). To visually distinguish BGPs from CTPs, we always underline the last variable of a CTP. Definition 2.6 (Core query). A core query ùëÑ has a head and a body. The body is a set of ùëò BGPs, ùëò ‚â• 0, and ùëô CTPs, ùëô ‚â• 0, such that ùëò + ùëô &gt; 0, and each underlined (last) variable from a CTP appears exactly once in ùëÑ. The head is a subset of the body variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.5 (CT Pattern</head><p>An example core query, ùëÑ 1 , consists of 3 BGPs and a CTP: (ùë•, ùë¶, ùëß, ùë§):-(ùúè (ùë•) = ùúè entrepreneur , "citizenOf", "USA") ùëÑ 1 (ùúè (ùë¶) = ùúè entrepreneur , "citizenOf", "France"), (ùúè (ùëß) = ùúè politician , "citizenOf", "France"), (ùë•, ùë¶, ùëß, ùë§) ùëÑ 1 asks: "What are the connections ùë§ between some American entrepreneur ùë•, some French entrepreneur ùë¶, and some French politician ùëß?" We denote the CTP of this query by ùëî 1 . To define core query semantics, our first notion is: Definition 2.7 (BGP embedding). Given a BGP ùëè = {ùë° 1 , . . . , ùë° ùëò }, an embedding of ùëè into G is a function ùúô, associating to each variable ùë£ in ùëè, a node ùëõ ‚àà N or an edge ùëí ‚àà E, such that (ùëñ) ùúô (ùë£) satisfies all the predicates on ùë£ in ùëè; and (ùëñùëñ) for every edge pattern (ùë†, ùëí, ùëë) in ùëè, the edge ùúô (ùëí) ‚àà E goes from ùúô (ùë†) to ùúô (ùëë).</p><p>A sample embedding ùúô for the first BGP of ùëÑ 1 maps ùë• to ùëõ 4 , "USA" to ùëõ 10 , "citizenOf" to ùëí 6 , etc.</p><p>Next, we define: The above definition allows arbitrary seed sets, in particular, an ùëÜ ùëñ can be N, the set of all graph nodes. We adjust Def. 2.8 to allow a connecting tree to have any number of nodes from those seed sets equal to N (otherwise, only 1-node trees would appear in results).</p><formula xml:id="formula_1">Definition 2.</formula><p>Difference wrt path-based semantics Consider a simple CTP ùëî ‚Ä≤ = (ùë£ 1 , ùë£ 2 , ùë£ 3 ) and two seed sets ùëÜ 1 , ùëÜ 2 . ùëî ‚Ä≤ (ùëÜ 1 , ùëÜ 2 ) may differ from the set of all paths between an ùëÜ 1 node and an ùëÜ 2 node: for instance, a path going from ùë† 1 ‚àà ùëÜ 1 through ùë† ‚Ä≤ 1 ‚àà ùëÜ 1 to ùë† 2 ‚àà ùëÜ 2 cannot appear in ùëî ‚Ä≤ (ùëÜ 1 , ùëÜ 2 ), because of our minimality condition (ùëñùëñ), requiring direct connections between seeds from different sets. Further, consider a CTP ùëî ‚Ä≤‚Ä≤ = (ùë£ 1 , ùë£ 2 , ùë£ 3 , ùë£ 4 ) and some seed sets ùëÜ 1 , ùëÜ 2 , ùëÜ 3 . One may try to compute ùëî ‚Ä≤‚Ä≤ (ùëÜ 1 , ùëÜ 2 , ùëÜ 3 ) by a three-way join of the paths from a common root node ùëü , to a node from ùëÜ 1 , one from ùëÜ 2 and one from ùëÜ 3 ; we call this approach path stitching. The results may differ even more: (ùëñ) for each tree of ùëõ nodes that appears in ùëî ‚Ä≤‚Ä≤ (ùëÜ 1 , ùëÜ 2 , ùëÜ 3 ), the three-way join produces ùëõ results, that need deduplication; (ùëñùëñ) if a path from ùëü to ùë† 1 has common nodes or even common edges with a path from ùëü to ùë† 2 and/or the one from ùëü to ùë† 3 , the join of these paths is not a tree, thus it cannot appear in a CTP result. This is why in this work, we compute CTP results directly (not via stitching).</p><p>Note that a CTP can have a very large number of results, as illustrated by the graph in Figure <ref type="figure" target="#fig_1">2</ref>. A CTP (1, ùëÅ + 1, ùë£ 3 ), asking for all the connections between the end nodes, has 2 ùëÅ solutions, or 2 |ùê∏ |/2 , which grows exponentially in |ùê∏|, the number of graph edges. This is why complete CTP result computation may be unfeasible in some cases, and we will include in our language CTP filters for limiting the CTP result computation effort. We call simple variable in a query a variable that does not occur in the last position in a CTP. For a core query ùëÑ, we define: Definition 2.9 (Simple embedding). A simple embedding of ùëÑ in G is a function ùúô mapping each simple variable into a G node or edge, such that:</p><p>(  CTP filters A set of orthogonal language extensions, which allow to filter (restrict) set based CTP results, are also provided.</p><formula xml:id="formula_2">ùëÑ (G) = ùúã ùë¢ 1 ,...,ùë¢ ùëõ (Œ¶ ‚ä≤‚ä≥ ùëî 1 (ùëÜ</formula><p>The keyword UNI after a CTP indicates that only unidirectional trees are sought, that is: a tree ùë°, as in Def. 2.8, must have a root node, from which a directed path goes to each seed node in ùë°.</p><p>Adding LABEL and a set of labels {ùëô 1 , ùëô 2 , . . . , ùëô ùëò } after a CTP indicates that the edges in any result of that CTP must have labels from the given set.</p><p>Adding MAX ùëõ after a CTP indicates that only trees of at most ùëõ edges are sought.</p><p>A score function ùúé can be used to assign to each tree in a CTP result a real number ùúé (ùë°) (the higher, the better). Specifying (for a given CTP or for the whole query) SCORE ùúé [TOP ùëò] means that the results of each CTPs must be scored using ùúé, and the scores included in the query result. The optional TOP ùëò allows to restrict the CTP result to those having the ùëò-highest ùúé scores.</p><p>Finally, a practical way to limit the evaluation of a CTP (recall the example on Figure <ref type="figure" target="#fig_1">2</ref>) is to specify a timeout ùëá (maximum allowed evaluation time); for simplicity, we consider the same ùëá is allotted to each CTP in a query. Definition 2.11 (Query). A query consists of a core query, together with 0 or more filters for each CTP.</p><p>The semantics of a query is easily derived from that of a core query (Def. 2.10), by filtering set-based CTP results accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">QUERY EVALUATION STRATEGY</head><p>An EQL query consists of a set of BGPs and a set of CTPs. Our evaluation strategy consists of the following steps: (A) Evaluate each BGP ùëè ùëñ , that is, compute all embeddings of its variables, and materialize them in a (C) Compute the query result as a projection on the head variables, over the natural join of the ùêµ ùëñ and ùê∂ùëá ùëÉ ùëó tables.</p><p>All the above steps but (B) can be implemented by leveraging an existing conjunctive graph query engine. Thus, in the sequel, we focus on efficiently computing set-based CTP results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">COMPUTING SET-BASED CTP RESULTS</head><p>To compute ùëî(ùëÜ 1 , . . . , ùëÜ ùëö , ùêπ ), we must find all the minimal subtrees of G = (N, E) containing exactly one node (or seed) from each ùëÜ ùëñ , also taking into account the filters ùêπ . Since ùêπ is optional, we first discuss how to compute CTP results without any filter (Section 4.1 to 4.7), before discussing pushing filters (Section 4.8). Observation 1. Let us call leaf any node in a tree that is adjacent to exactly one edge. It is easy to see that in each CTP result, every leaf node is a seed. (Otherwise, the leaf could be removed while still preserving an answer, which contradicts the minimality of the result.) Clearly, the converse does not hold: in a result, some seeds may be internal nodes. We denote by sat(ùë°) the node sets from which ùë° has a seed. Observation 2. As stated in Section 2, we may be only computing partial CTP results. In such cases, it is reasonable to return at least the smallest-size results, given that tree size (smaller is better) is an ingredient of many score functions (see Section 6), and small results are easy to understand. However, we do not assume "smaller is always better": that is for the score function ùúé to decide. Nor do we require users to specify a maximum result size, which may be hard for them to guess. Rather, we consider algorithms that find as many results as possible, as fast as possible, also taking into account the CTP filters, which may limit the search. Seed set size Most of our discussion assumes that no seed set is N, and that they all fit easily in memory. We briefly discuss how the contrary situations could be handled, in Section 4.9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Simple Breadth-First algorithm (BFT)</head><p>The first algorithm we consider finds the tree results in breadth-first fashion, thus we call it BFT. It starts by creating a first generation of trees ùëá 0 , containing a one-node tree, denoted Init (ùëõ), for each seed node ùëõ ‚àà ùëÜ 1 ‚à™ . . . ‚à™ ùëÜ ùëö . Then, from each generation ùëá ùëñ , it builds the trees ùëá ùëñ+1 , by "growing" each tree ùë° in ùëá ùëñ , successively, with every edge (ùëõ, ùëõ ‚Ä≤ ) adjacent to one of its nodes ùëõ ‚àà ùë°, such that:</p><p>‚Ä¢ (Grow1): ùëõ ‚Ä≤ is not already in ùë°, and ‚Ä¢ (Grow2): ùëõ ‚Ä≤ is not a seed from a set ùëÜ ùëó ‚àà sat(ùë°). Condition (Grow1) ensures we only build trees. (Grow2) enforces the CTP result minimality condition (ùëñùëñ) (Def. 2.8). As trees grow from their original seed, they can include more seeds. When a tree has a seed from each set, it must be minimized, by removing all edges that do not lead to a seed, before reporting it in the result. For instance, with the seed sets {ùëõ 2 } and {ùëõ 4 } on the graph in Figure <ref type="figure" target="#fig_0">1</ref>, starting from ùëõ 2 , BFT may build {ùëí 5 , ùëí 4 }, then {ùëí 5 , ùëí 4 , ùëí 6 } before realizing that ùëí 4 is useless, and removing it through minimization. Minimization slows BFT down, as we experimentally show in Section 5.4.1. BFT can build a tree in multiple ways; to avoid duplicate work, any tree built during the search must be stored, and each new tree is checked against this memory of the search.</p><p>It is easy to see that BFT is complete, i.e., given enough time and memory, it finds all CTP results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">GAM algorithm</head><p>The GAM (Grow and Aggressive Merge) algorithm has been introduced recently <ref type="bibr" target="#b5">[6]</ref>, reusing some ideas from <ref type="bibr" target="#b15">[16]</ref>. Unlike BFT that views a tree as a set of edges, GAM distinguishes one root node in each tree it builds. The algorithm uses a priority queue where Grow opportunities are inserted, as (tree, edge) pairs such that the tree could grow from its root with that edge.</p><p>GAM also starts from the set of Init trees built from the seed sets. Next, it inserts in the priority queue all (ùë°, ùëí) pairs for some Init tree ùë° and edge ùëí adjacent to the root (only node) of ùë°, satisfying the conditions (Grow1) and (Grow2) introduced in Section 4.1. GAM then repeats the following, until no new trees can be built, or a time-out is reached:</p><p>(1) (Grow): Pop a highest-priority (ùë°, ùëí) pair from the priority queue, where ùëí = (ùë° .ùëüùëúùëúùë°, ùëõ ‚Ä≤ ), and build the tree ùë° ùëñ having all edges of ùë° as well as ùëí, and rooted in ùëõ ‚Ä≤ . (2) (Merge): For any tree ùë° ùëñùëñ already built, such that:</p><p>‚Ä¢ (Merge1): ùë° ùëñùëñ has the same root as ùë° ùëñ , and no other node in common with ùë° ùëñ ; and ‚Ä¢ (Merge2): sat(ùë° ùëñ ) ‚à© sat(ùë° ùëñùëñ )= ‚àÖ, take the following steps: (a) Create ùë° ùëñùëñùëñ , a tree having the edges of ùë° ùëñ and those of ùë° ùëñùëñ , and the same root as ùë° ùëñ and ùë° ùëñùëñ ; (b) Immediately Merge ùë° ùëñùëñùëñ with all qualifying trees (see conditions Merge1, Merge2), and again merge the resulting trees etc., until no more Merge are possible; (3) For each tree ùë° ùëñùë£ created via Grow or Merge as above: (ùëñ) if ùë° ùëñùë£ has a seed from each set, report it as a result; (ùëñùëñ) otherwise, push in the priority queue all (ùë° ùëñùë£ , ùëí ùëñùë£ ) pairs such that ùëí ùëñùë£ is adjacent to the (only) root node of ùë° ùëñùë£ , satisfying the conditions (Grow1) and (Grow2).</p><p>Property 1 (GAM completeness). The GAM algorithm is complete.</p><p>Property 2 (GAM result minimality). By construction, each result tree built by GAM is minimal (in the sense of Def. 2.8). Thus, GAM does not need to minimize the results it finds.</p><p>Search space exploration order Unlike BFT, GAM does not build trees in the strictly increasing order of their size; Merge may build quite large trees before some other, smaller trees. The order in which GAM enumerates trees is determined, first, by the priority of the queue which holds (ùë°, ùëí) entries, and second, by the available Merge opportunities. In this work, to remain compatible with any score function, we study search algorithms regardless of (orthogonally to) the search order.</p><p>Like BFT, GAM may also build a tree in multiple ways. Formally: Definition 4.1 (Tree with provenance). A tree with provenance (or provenance, in short) is a formula of one of the forms shown below, together with one node called the provenance root:</p><p>(1) Init (ùëõ) where ùëõ is a seed; the root of such a provenance is ùëõ itself; (2) Grow (ùë°, ùëí) where ùë° is a provenance, its root is ùëõ 0 , ùëí is an edge going from ùëõ 0 to ùëõ 1 and ùëõ 1 does not appear in ùë°; in this case, ùëõ 1 is the root of the Grow provenance; (3) Merge (ùë° 1 , ùë° 2 ), where ùë° 1 and ùë° 2 are provenances, rooted in ùëõ 1 =ùëõ 2 ; in this case, ùëõ 1 is the root of the Merge provenance.</p><p>We call rooted tree a set of edges that, together, form a tree, together with one distinguished root node. GAM may build several provenances for the same rooted tree, e.g., Merge (Merge (ùë° 1 , ùë° 2 ),ùë° 3 ) and Merge (ùë° 2 ,Merge (ùë° 1 , ùë° 3 )), for some trees ùë° 1 , ùë° 2 , ùë° 3 . The interest of a tree as part of a possible result does not depend on its provenance. Therefore, GAM discards all but the first provenance built for a given rooted tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">BFT variants with Merge</head><p>The Merge operation can also be injected in the BFT algorithm to allow it to build some larger trees before all the smaller trees have been enumerated. We study two variants: BFT-M merges each new tree resulting from Grow with all its compatible partners (Step (2a) in Section 4.2), but does not apply Merge on top of these Merge results; in contrast, BFT-AM applies both Step (2a) and Step (2b) to aggressively merge. BFT-M and BFT-AM are obviously complete. Like BFT, they still need to minimize a potential result before reporting it. This is because BFT algorithms grow trees from any of their nodes, thus may add edges on one side of one seed node, which later turn to be useless. GAM avoids this by growing only from the root.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Edge set pruning and ESP algorithm</head><p>GAM may build several rooted trees for the same set of edges. For example, on the graph in Figure <ref type="figure" target="#fig_2">3</ref> with the seeds {ùêµ}, {ùê∂}, denoting a rooted tree by its edges and underlining the root, successive Grow from B lead to B-3-C, successive Grow from C lead to B-3-C, and Merge of two Grow provenances yields B-3-C. However, the root is meaningless in a CTP result, which is simply a set of edges. We introduce: Definition 4.2 (Edge set). An edge set is a set of edges that, together, form a tree such that at most 1 leaf is not a seed. A result is a particular case of edge set, where all leaves are seeds (recall Observation 1).</p><p>As GAM builds several rooted trees for an edge set, it repeats some effort: we only need to find each result once. This leads to the following pruning idea: Definition 4.3 (Edge-set pruning (ESP)). The ESP pruning technique during GAM consists of discarding any provenance ùë° 1 whose edge set is non-empty, such that another provenance ùë° 0 , corresponding to the same edge set, had been created previously.</p><p>We will call ESP, in short, the GAM algorithm (Section 4.2) enhanced with ESP. As we will show, ESP significantly speeds up GAM execution. However, ESP compromises completeness for some graphs, seed sets, and execution orders. That is: depending on the order in which various trees are built, the first (and only, due to ESP) provenance for a given edge set may prevent the algorithm from finding some results.</p><p>For instance, consider the graph in Figure <ref type="figure" target="#fig_2">3</ref>, and the seed sets ‚Ä¢ By a similar reasoning, when B-3-C is built, it is discarded by ESP, preventing the construction of of A-1-2-B-3-C. Thus, no result is found. Note that with a favorable execution order, the CTP result would be found. For instance, from A, B, C, ESP could build:</p><formula xml:id="formula_3">ùëÜ 1 = {ùê¥}, ùëÜ 2 = {ùêµ}, ùëÜ 3 = {ùê∂}. A possible execution of GAM is: (1) Initial trees: A, B, C.<label>(2)</label></formula><p>(1) Through successive Grow:</p><formula xml:id="formula_4">A-1, A-1-2, A-1-2-B, C-3, C-3-B (2) Then, Merge (A-1-2-B, C-3-B</formula><p>) is a provenance for the result. This raises the question: can we pick a GAM execution order that would ensure completeness, even when using ESP? Intuitively, the order should ensure that for each result ùëü , there exists a provenance ùëù ùëü for ùëü which is certainly built, which requires that at every subexpression ùëí of ùëù ùëü , over an edge set ùëíùë†, the first provenance ùëù ùëíùë† we find for ùëíùë† happens to be rooted in a node that allows to build on ùëí until ùëù ùëü . Thus, the decisions made up to building ùëù ùëíùë† would need to have a "look-ahead" knowledge of the future of the search, which is clearly not possible. In the above example the "bad" order builds A-1-2-B first, whereas it would be more favorable to build A-1-2-B. However, when exploring these three edges, the future of the exploration is not known; thus, we cannot "pre-determine" the best provenance for ùëíùë†. Recall also from Section 4.2 that different orders may be suited for partial exploration with different score functions. In a conservative way, we consider an algorithm incomplete when for some "bad" execution order it may miss results.</p><p>We show that ESP finds some answers for any execution order: Property 3 (2-seed sets ESP completeness). Let ùë° be a result of a CTP with 2 seed sets. Then, ùë° is guaranteed to be found by ESP.</p><p>Here and throughout this paper, guaranteed to be found, for a rooted tree or an edge set, means that at least one provenance for it is built; ESP cannot prune the one built first.</p><p>For 1 seed set, Property 3 is trivially shown, thus we focus on ùëö = 2 (two seed sets). In this case, any result is path of 0 or more edges. We introduce: Definition 4.4 ((ùëõ, ùë†)-rooted path). Given a CTP and its seed sets ùëÜ 1 , ùëÜ 2 , . . . , ùëÜ ùëö , an (ùëõ, ùë†)-rooted path is a rooted path from a seed ùë† to a root node ùëõ, such that the only seed in the path is ùë†.</p><p>Lemma 4.1. Any (ùëõ, ùë†)-rooted path is guaranteed to be found by GAM with ESP.</p><p>Proof. We prove this by exhibiting a provenance for it. First, for each seed ùë† ‚àà ùëÜ 1 ‚à™ . . . ‚à™ ùëÜ ùëö , Init (ùë†) is guaranteed to be built. ESP pruning does not apply. Then, any provenance applying only Grow steps on an Init provenance, is guaranteed to be built by GAM. Such a provenance is not pruned by ESP, because it is the only provenance that could lead to its edge set. Thus, successive Grow on top of any seed ùë† is guaranteed to build up to ùëõ, leading to the (ùëõ, ùë†)-rooted path. ‚ñ° Based on the above lemma, we prove Property 3:</p><p>Proof. If the result ùë° is a node (ùë† 1 = ùë† 2 ), the property is trivial. If the result is a path of 1 edge, there are two provenances of the form Grow (Init); the first is already a result. Now, assume ùë° has at least two edges. For any internal node ùëõ in ùë°, the (ùëõ, ùë† ùëñ )-rooted paths from both the (seed) leaves ùë† 1 , ùë† 2 of ùë° are guaranteed to be found, by Lemma 4.1. Then, one of two cases may occur: (1) For some internal node ùëõ 0 , both rooted paths (ùëõ 0 , ùë† 1 ) and (ùëõ 0 , ùë† 2 ) are created before a sequence of Grow gets from Init (ùë† 1 ) to ùë† 2 , and before the opposite sequence of Grow is built from Init (ùë† 2 ), to ùë† 1 . Without loss of generality, let ùëõ 0 denote the first internal node for which these two rooted paths are created. Immediately, Merge on these creates a provenance of ùë°. By the way we chose ùëõ 0 , this is the first provenance for this edge set, thus not pruned. (2) On the contrary, assume that successive Grow get from one end of the path to another, before two rooted paths meet in any internal node. Assume without loss of generality that Grow (Grow (. . . Init (ùë† 1 ). . . )) is the first one to reach ùë† 2 . Again, by design, this is the first provenance for ùë°, thus not pruned. ‚ñ° CTP with two seed sets (path queries) are frequent in practice; on these, GAM <ref type="bibr" target="#b5">[6]</ref> and ESP are comparable, and we experimentally show the latter is much more efficient. Next, we add more algorithmic refinements to significantly extend our completeness guarantees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">MoESP algorithm</head><p>We now introduce an algorithmic variant called Merge-oriented ESP, or MoESP, which finds many (but not all) CTP results for arbitrary numbers of seed sets.</p><p>MoESP works like ESP, but it creates more trees. Specifically, whenever Grow or Merge produces a provenance ùë° having strictly more seeds than any of its (one or two) children, the algorithm builds from ùë° all the so-called MoESP trees ùë° ‚Ä≤ such that:</p><p>‚Ä¢ ùë° ‚Ä≤ has the same edges (and nodes) as ùë°, but ‚Ä¢ ùë° ‚Ä≤ is rooted in a seed node, distinct from the root of ùë°. The provenance of any such ùë° ‚Ä≤ is denoted Mo (ùë°, ùëü ) where Mo is special symbol and ùëü is the root of ùë° ‚Ä≤ . Within MoESP, Merge is allowed on MoESP trees, but not Grow. More generally, Grow is disabled on any tree whose provenance includes Mo.</p><p>Clearly, MoESP builds a strict superset of the rooted trees created by ESP (thus, it finds all results of ESP). It also finds the result in Figure <ref type="figure" target="#fig_2">3</ref>. Namely, after creating A, B, C:</p><p>(1) Grow leads to the trees: A-1, B-2, B-3, C-3.</p><p>( 2) where each leaf is a seed and no internal (non-leaf) node is a seed. A simple edge set is ùëù-simple, for some integer ùëù, if its number of leaves is at most ùëù.</p><p>For instance, consider the sample graph in Figure <ref type="figure" target="#fig_4">4</ref>, and the 6 seed sets {ùê¥}, {ùêµ}, {ùê∂}, {ùê∑ }, {ùê∏}, {ùêπ }. The edge set A-4-D, shown in red, is 2-simple, and so are: A-1-2-B, shown in blue; B-8-F, etc. Definition 4.6 (Simple tree decomposition of a solution). Let ùë° be a CTP result. A simple tree decomposition of ùë°, denoted ùúÉ (ùë°), is a set of simple edge sets which (ùëñ) are a partition of the edges of ùë° and (ùëñùëñ) may share (leaf) nodes with each other.</p><p>For instance, in Figure <ref type="figure" target="#fig_4">4</ref>, the red, blue, and violet edges, together, form a result for the 6-seed sets CTP. A simple tree decomposition of this solution is: {A-4-D, A-1-2-B, B-7-E, B-8-F, B-3-C}. It is easy to see that a tree ùë° has a unique simple tree decomposition ùúÉ (ùë°). Definition 4.7 (ùëù-piecewise simple solution). A result ùë° is ùëù-piecewise simple (ùëùps, in short), for some integer ùëù, if every edge set in the simple tree decomposition ùúÉ (ùë°) is ùëù-simple (Def. 4.5).</p><p>The sample result above in Figure <ref type="figure" target="#fig_4">4</ref> is 2ps, since its simple tree decomposition only contains 2-simple edge sets. The following important MoESP property guarantees it is found: Property 4 (MoESP finds 2-piecewise simple solutions). For any number of seed sets ùëö, MoESP is guaranteed to find any 2-piecewise simple result.</p><p>Proof. Let ùë° be a 2-piecewise simple solution and ùúÉ (ùë°) = {ùë° 1 , . . . , ùë° ùëü } be its simple tree decomposition. It is easy to see that each ùë° ùëñ , 1 ‚â§ ùëñ ‚â§ ùëü , is a path of the form ùëõ ùëñ 1 , . . . , ùëõ ùëñ ùëö such that ùëõ ùëñ 1 and ùëõ ùëñ ùëö are seeds, while no other intermediary node is a seed. Lemma 4.1, which still holds for MoESP, guarantees that rooted paths are built starting from both ùëõ ùëñ 1 and ùëõ ùëñ ùëö . As soon as these paths meet, a tree over the edges of ùë° ùëñ is created, then thanks to MoESP, one tree rooted in ùëõ ùëñ 1 and another rooted in ùëõ ùëñ ùëö , over the edge set of ùë° ùëñ , are created. Because ùúÉ (ùë°) is a simple tree decomposition of ùë°, if ùëü = 1, the property is proved. If ùëü &gt; 1, each seed-rooted tree based on the edge set of a ùë° ùëñ has its root in common with at least another seed-rooted tree over another edge set(s) from ùúÉ (ùë°). Therefore, aggressive Merge ensures that they are eventually all merged, leading to one provenance for ùë°. ‚ñ°</p><p>For a CTP with any number ùëö of seed sets, a path result is one in which no node has more than two adjacent edges. In a path result, seed and non-seed nodes alternate, with the two ends of the paths being seeds. Thus, any path result is 2ps. It follows then, as a direct consequence of Property 4:</p><p>Property 5 (MoESP finds all path results). For any CTP, MoESP finds all the path results.</p><p>However, outside 2ps results, MoESP may still fail. For instance, consider the graph in Figure <ref type="figure" target="#fig_6">5</ref>, and the seed sets {ùê¥}, {ùêµ}, {ùê∂}. The only result here is 3-simple. A possible MoESP execution order is:</p><p>(1) Starting from A, B, C, Grow produces A-1, B-2, C-3;</p><p>(2) B-2-x, followed by B-2-x-3, which merges with C-3 into B-2-x-3-C, leading also to B-2-x-3-C and B-2-x-3-C. (3) B-2-x-1 which merges with A-1, leading to B-2-x-1-A and similar trees rooted in B and A. (4) Grow produces A-1-x. ESP discards the Merge of A-1-x with B-2-x, due to the rooted tree built at step (3), over the same set of edges. (5) A-1-x-3 is built, then Merge with C-3 creates A-1-x-3-C, and similar trees rooted in A and C. ( <ref type="formula">6</ref>) Grow produces C-3-x. ESP discards the merges of C-3-x with A-1-x due to the 3-rooted tree built at step (5) and with B-2-x due to the 3-rooted tree built at step (2). ( <ref type="formula">7</ref>) At this point, we have trees with two seeds, rooted in 1, 3, A, B and C. Grow on any of them is impossible, because they already contain all the edges adjacent to their roots. There are no Merge possibilities on their roots, either. Thus, the search fails to find a result. At steps ( <ref type="formula">4</ref>) and ( <ref type="formula">6</ref>), ESP is "short-sighted": it prevents the construction of some trees, necessary for finding the result. Next, we present another optimization which prevents such errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">LESP algorithm</head><p>The Limited Edge-Set Pruning (LESP), in short, works like ESP (Section 4.4), but it limits edge-set pruning, as follows.</p><p>‚Ä¢ We assign to each node ùëõ, and maintain throughout LESP execution, a seed signature ùë†ùë† ùëõ , indicating the seed sets ùëÜ ùëñ , 1 ‚â§ ùëñ ‚â§ ùëö, such that a (ùëõ, ùë† ùëñ )-rooted path (Def. 4.4) has been built from a seed ùë† ùëñ ‚àà ùëÜ ùëñ , to ùëõ, since execution started. For any seed ùë† ‚àà ùëÜ ùëñ , the signature ùë†ùë† ùë† is initialized to 0 . . . 1 . . . 0 (a single 1 in the ùëñ-th position). For a non-seed ùëõ, initially ùë†ùë† ùëõ =0; the ùëñ-th bit is set to 1 when node ùëõ is reached by the first rooted path from a seed in ùëÜ ùëñ . ‚Ä¢ Prevent ESP from discarding a Merge tree rooted in ùëõ such that: (ùëñ) (ùë†ùë† ùëõ ) ‚â• 3, that is, there are at least 3 bits set to 1 in the signature ùë†ùë† ùëõ ; and (ùëñùëñ) ùëõ has at least 3 adjacent edges in G. Intuitively, the condition on ùë†ùë† ùëõ encourages merging on nodes already well-connected to seeds. We denote by ùëë ùëõ the number of G edges adjacent to ùëõ; it can be computed and stored before evaluating any query. The condition on ùëë ùëõ focuses the "protection against ESP" to Merge trees rooted in nodes where such protection is likely to be most useful: specifically, those where 3 or more rooted paths can meet (see Lemma 4.2 below). Grow and Merge apply on trees "spared" in this way with no restriction.</p><p>Clearly, LESP creates all the trees built by ESP, and may create more. In particular, reconsider the graph in Figure <ref type="figure" target="#fig_6">5</ref>, the associated seed sets, and the execution steps we traced in Section 4.5. At step (2), ùë†ùë† ùë• is initialized with 010 (there is a path from B to x). At step (4), when A-1-x is built, ùë†ùë† ùë• becomes 110; since (ùë†ùë† ùë• ) = 2, the tree A-1-x-2-B is pruned. However, at step ( <ref type="formula">6</ref>), when C-3-x is built, ùë†ùë† ùë• becomes 111, which, together with ùëë ùë• = 3, spares its Merge result A-1-x-3-C (despite the presence of several trees with the same edges). In turn, this merges immediately with B-2-x into a result.</p><p>We formalize the guarantees of LESP as follows.</p><p>Definition 4.8 ((ùë¢, ùëõ) rooted merge). For an integer ùë¢ ‚â• 3 and nonseed node ùëõ, the (ùë¢, ùëõ) rooted merge is the rooted tree resulting from merging a set of ùë¢ (ùëõ, ùë† ùëñ ) rooted paths, for some seeds ùë† 1 , . . . , ùë† ùë¢ .</p><p>It follows from the (Merge2) pre-condition (Section 4.2) that in an (ùë¢, ùëõ) rooted merge, each ùë† ùëñ belongs to a different seed set. Further, it follows from the definition of an (ùëõ, ùë† ùëñ )-rooted path, that in a (ùë¢, ùëõ) rooted merge, all seeds are on leaves. In other words, a (ùë¢, ùëõ) rooted merge is a ùë¢-simple edge set. Lemma 4.2. Any (3, ùëõ) rooted merge is guaranteed to be found by LESP.</p><p>Proof. For any non-seed node ùëõ, Lemma 4.1 (which also holds for LESP) ensures that any (ùëõ, ùë† ùëñ )-rooted path is found. As soon as the third one is built, (ùë†ùë† ùëõ ) becomes 3. This, and the hypothesis ùëë ùëõ ‚â• 3, ensure that the Merge of the three is not pruned. ‚ñ° Property 6. For any integer ùë¢ ‚â• 3 and non-seed node ùëõ, any (ùë¢, ùëõ) rooted merge is guaranteed to be found by LESP.</p><p>Proof. For ùë¢ = 3 this is established by Lemma 4.2. Once the first (3, ùëõ) rooted merge has been built and kept, this ensures both that ùëë ùëõ ‚â• 3 and (ùë†ùë† ùëõ ) ‚â• 3. Then, whenever a new (ùëõ, ùë† ùëñ ) rooted path, satisfying the Merge pre-conditions, is built, it is aggressively merged with the first (3, ùëõ) rooted path, and the result is protected from pruning by LESP's special provision. The same holds during all subsequent merges with other (ùëõ, ùë† ùëó ) rooted paths. ‚ñ° For 4 or more seed sets, LESP may miss results that are not (ùë¢, ùëõ) rooted merges. For instance, consider the following order of execution for ùëÜ = ({ùê¥}, {ùêµ}, {ùê∂}, {ùê∑ }) on the graph in Figure <ref type="figure">6</ref>:</p><p>(1) From A, B, C, D, Grow builds: A-1, B-2, C-3, D-4.</p><p>(2) Grow builds B-2-1 which merges with A-1 into A-1-2-B.  <ref type="formula">8</ref>) Progressing similarly, we can only merge at most 3 rooted paths, in nodes 2, x or 3. We cannot merge with a path leading to the 4th seed, because the trees with the edge sets A-1-2-B and C-3-4-D, built at (2), (3) above, are not rooted in 2 nor 3, respectively, and these are the only nodes satisfying the LESP condition that "spares" some Merge trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">MoLESP algorithm</head><p>Our last algorithm, called MoLESP, is a GAM variant with ESP and both the modifications of MoESP (which injects more trees) and LESP (which avoids ESP pruning for some Merge trees). Clearly, MoLESP finds all the trees found by MoESP and LESP. Further:</p><p>Property 7 (MoLESP finds all 3ps results). MoLESP is guaranteed to find all the 3-piecewise simple results.</p><p>Proof. Let ùë° be a 3ps result. If ùë° was 2ps, MoESP finds it (Property 4), thus MoLESP also does. Now consider that ùúÉ (ùë°) has some 3-simple edge sets that are not 2-simple (thus, ùëö ‚â• 3). We show that for any 3-simple edge set in ùúÉ (ùë°), one provenance is built. Let ùë° 3 be such an edge set: its three leaves, denoted ùëõ 1 , ùëõ 2 , ùëõ 3 , are seeds, and no internal node is a seed. Let ùëê denote the central node in ùë° 3 (connected to ùëõ 1 , ùëõ 2 , ùëõ 3 by pairwise disjoint paths). ùë° 3 is a (3, ùëê) rooted merge (recall Def. 4.8) and one provenance for it is built (Lemma 4.2).</p><p>The rest of the proof follows the idea in the proof of Property 4. The MoESP aspect of MoLESP guarantees that for each edge set in ùúÉ (ùë°), one tree rooted in each seed is built and not pruned; eventually, aggressive Merge of these trees builds a provenance for ùë°. ‚ñ°</p><p>As an important consequence:</p><p>Property 8. MoLESP is complete for ùëö ‚â§ 3 seed sets. Proof. Consider the possible result shapes: (ùëñ) a single node ùë† 1 = ùë† 2 = ùë† 3 : no ESP applies, thus it is found; (ùëñùëñ) a path going from ùë† 1 = ùë† 2 to ùë† 3 ; such a result is 2-simple; (ùëñùëñùëñ) a path going from ùë† 1 to ùë† 2 and then to ùë† 3 , for some pairwise distinct ùë† 1 , ùë† 2 , ùë† 3 ; such a result is 2ps; (ùëñùë£) a tree with three distinct leaves ùë† 1 , ùë† 2 , ùë† 3 , which is 3-simple. In cases (ùëñùëñ), (ùëñùëñùëñ), (ùëñùë£), Property 7 ensures the result is found. ‚ñ° Our strongest completeness result is: Property 9 (Restricted MoLESP completeness). For any CTP of ùëö ‚â• 1 seeds, MoLESP finds any result ùë°, such that: each edge set ùëíùë† ‚àà ùúÉ (ùë°) is a (ùë¢, ùëõ)-rooted merge (Def. 4.8), for some integer 1 ‚â§ ùë¢ ‚â§ ùëö and non-seed node ùëõ in ùëíùë†. Proof. Let ùë° be a result, and assume it is ùë£-piecewise simple, for some integer ùë£. If ùë£ ‚àà {2, 3}, Property 7 ensures MoLESP finds it.</p><p>On the contrary, assume ùë£ ‚â• 4 and let ùë° 4 ‚àà ùúÉ (ùë°) be a (ùë£, ùëõ)-rooted merge for some non-seed node ùëõ, thus, also ùë£-simple. Property 6, which also holds during MoLESP, guarantees that one provenance for ùë° 4 is built. The end of our proof leverages the MoESP aspect of the algorithm: for each such edge set in ùúÉ (ùë°), one tree rooted in each seed is built and not pruned; eventually, aggressive Merge of these trees builds a provenance for ùë°.</p><p>‚ñ° For example, in Figure <ref type="figure">7</ref>, with the six seeds ùê¥ to ùêπ , the result is guaranteed to be found by MoLESP. Depending on the exploration order, MoESP and LESP may not find it.</p><p>MoLESP algorithm Algorithms 1 to 5, together, implement MoLESP. They share a set of global variables whose names start with an uppercase letter: Res, PrioQ, Hist (the search history), and TreesRootedIn (to store the trees by their roots); the latter is needed to find Merge candidates fast. Variables with lowercase names are local to each algorithm. processTree feeds the priority queue with (tree, edge) pairs at line 10. recordForMerging injects the extra MoESP trees (Section 4.5) at lines 2 to 4. isNew implements limited edge-set pruning based on the history, and the two conditions that can "spare" a tree from pruning (Section 4.6). mergeAll implements aggressive merging; by calling processTree on each new Merge result, through recordForMerging, the result is available in the future iterations of mergeAll, thus ensuring all the desired Merge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">CTP evaluation in the presence of filters</head><p>We now briefly explain how various CTP filters (Section 2) can be inserted within the above algorithms. UNI-directional search is enforced by adding pre-conditions to Grow and Merge, to ensure we only create the desired provenances. LABEL {ùëô 1 , ùëô 2 , . . . , ùëô ùëò } is enforced by restricting the Grow edges to only those carrying one of these labels; in GAM and its variants, we only add in the queue (line 10 in processTree), (tree, edge) pairs where the edge has an allowed label. MAX ùëõ prevents Grow and Merge from creating a tree of more than ùëõ edges. timeout ùëá is checked after each newly found rooted tree and within each algorithm's main loop.</p><p>For SCORE ùúé [TOP ùëò], the simplest implementation calls ùúé on each new result; a vast majority of the proposed score functions can score each result independently. If the score of a result can only be computed once all the results are found, e.g. <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref>, the results need to be accumulated. For any given score ùúé, a smarter implementation may favor (with guarantees, or just heuristically) the early production of higher-score results, by appropriately chosing the priority queue order; this allows search to finish faster. Any order can be chosen in conjunction with MoLESP, since its completeness guarantees are independent of the exploration order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.9">Handling very large seed sets</head><p>Our CTP evaluation algorithms build Init trees for each seed. This has two risks: (ùëñ) when one or more seed sets are N (all graph nodes), exploring them all may be unfeasible; (ùëñùëñ) one or more seed sets may be subsets of N, yet still much larger, e.g., one or more orders of magnitude, than the other seed sets. To handle (ùëñ), assuming other seed sets are smaller, we only start exploring (Init, Grow etc.) from the other seed sets, and simplify accordingly the algorithms, since any encountered node is acceptable as a match for the N seed set(s). To handle (ùëñùëñ), borrowing ideas from prior work <ref type="bibr" target="#b25">[26]</ref>, we use multiple priority queues, one for each subset of the seed sets, and Grow at any point from the queue having the fewest (tree, edge) pairs. Thus, exploration initially focuses on the neighborhood of the smaller seed sets, and hopefully encounters Init trees from the large seed sets, leading to results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTAL EVALUATION</head><p>We compare CTP evaluation algorithms, then consider systems capable, to some extent, to evaluate the language we introduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Software and hardware setup</head><p>We implemented a parser and a query compiler for our language (Section 2) as an extension of SPARQL, and all the CTP evaluation algorithms from Section 4, in Java 11. Our graphs are stored in a simple table graph(id,source, edgeLabel, target) within PostgreSQL 12.4; unless otherwise specified, we delegate to Postgres the BGP evaluation, and joining their results with CTP ones (Section 3). When comparing CTP evaluation algorithms with in-memory competitors, we load the graph in memory prior to evaluating CTPs.</p><p>We executed our experiments on a server equipped with 2x10core Intel Xeon E5-2640 CPUs @ 2.4GHz, with 128-GB DRAM. Every execution point is averaged over 3 executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Baselines</head><p>CTP evaluation (keyword search) algorithms Our focus is on algorithms that search for connecting trees (ùëñ) traversing edges in both directions, (ùëñùëñ) orthogonally wrt the score function, (ùëñùëñùëñ) exhaustively, at least up to ùëö=3 seed sets, (ùëñùë£) capable of returning as many solutions as requested, if given enough time and memory, and (ùë£) applicable to arbitrary graphs, i.e., not requiring a regular graph structure. In the literature, only the GAM algorithm <ref type="bibr" target="#b5">[6]</ref> (Section 4.2) fits the bill. The BFT, BFT-M, BFT-AM algorithms (Section 4.1 and 4.3) also satisfy these conditions, and are thus natural comparison baselines; like virtually all algorithms from the literature, they start from the seeds and move gradually away looking for results.</p><p>QGSTP <ref type="bibr" target="#b38">[39]</ref> and LANCET <ref type="bibr" target="#b39">[40]</ref> are the most recent GSTP approximation algorithms, for specific cost functions based on node and edge (LANCET) weights. LANCET relies on DPBF <ref type="bibr" target="#b15">[16]</ref> to find an initial result, which it then improves. Since QGSTP has shown strong advantage over DPBF <ref type="bibr" target="#b38">[39]</ref>, we select QGSTP as a baseline. QGSTP runs in polynomial time in the size of the graph, and by design, returns only one result; we used the authors' code. Graph query engines Our first two baselines only support checking, but not returning unbounded-length, unidirectional paths whose edge labels match a regular expression that users must provide, that is: one cannot ask for "any path". Specifically, we use Virtuoso OpenSource v7.2.6 to evaluate SPARQL 1.1 queries that come as close as possible to the semantics of our language. Internally, Virtuoso translates an incoming SPARQL query into an SQL dialect<ref type="foot" target="#foot_0">1</ref>  before executing it. Our second baseline, named Virtuoso-SQL, consists of editing these SQL-like queries to remove label constraints and thus query the graph for connectivity between nodes. However, Virtuoso's SQL dialect prevented us from returning the nodes and edge labels along the found paths (whereas standard recursive SQL allows it).</p><p>Our next three baselines support checking and returning paths. JEDI <ref type="bibr" target="#b1">[2]</ref> returns all the data paths matching a SPARQL property path; we use the authors' code. Neo4j supports Cypher queries asking for all directed or undirected paths between two sets of nodes. Finally, we used recursive queries in Postgres v12.4 to return the label on paths between node pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Datasets and queries</head><p>We experiment with both synthetic and real-world RDF graphs. To compare CTP evaluation algorithms, we generate three sets of parameterized graphs and associated CTPs (Figure <ref type="figure" target="#fig_10">8</ref>). The seeds are labeled ùê¥, ùêµ, . . . , ùêª , non-seed nodes are labeled 1, 2 etc.; each seed set is of size 1. Line(ùëö, ùëõùêø) contains ùëö seeds, each connected to the next/previous seed by ùëõùêø intermediary nodes, using ùë†ùêø=ùëõùêø+1 edges. Comb(ùëõùê¥, ùëõùëÜ, ùë†ùêø, ùëëùêµùê¥) consists of a line, from which a lateral segment (called bristle) exits each seed. There are ùëõùê¥ bristles, each made of ùëõùëÜ segments (a segment ends in another seed); each bristle segment has ùë†ùêø triples, and there are ùëëùêµùê¥ nodes in the main line between two successive bristles. The number of seeds is ùëö=ùëõùê¥‚Ä¢(ùëõùëÜ+1). Star(ùëö, ùë†ùêø) has a central node connected to each of the ùëö seeds by a line of ùë†ùêø edges.</p><p>On each Line, Comb, and Star graph, we run a CTP defined by the ùëö seeds, having 1 result. For instance, on the Star in Figure <ref type="figure" target="#fig_10">8</ref>, the seed sets are {ùê¥}, {ùêµ}, {ùê∂}, {ùê∑ }. On Line and Comb, the result is 2ps (Def. 4.7), while on Star, it is a (ùë¢, ùëõ) rooted merge (Def. 4.8). Thus, by Property 9, MoLESP is guaranteed to find them. The topology of Line graphs minimizes the number of subtrees for a given number of edges and seeds; specifically, there are ùëÇ ((ùëö‚Ä¢ùëõùêø) 2 ) subtrees, while the number of rooted trees is in ùëÇ ((ùëö‚Ä¢ùëõùêø) 3 ). On the contrary, the Star topology raises the number of subtrees to ùëÇ (2 ùëö ‚Ä¢ùë†ùêø 2 ), while its number of rooted trees is in ùëÇ (2 ùëö ‚Ä¢ùë†ùêø 3 ). In Comb and Line graphs, MoESP trees (Section 4.5) are part of results.</p><p>To study the evaluation of our extended query language, we generate parameterized Connected Dense Forest (CDF) graphs (see Figure <ref type="figure" target="#fig_11">9</ref>). Each graph contains a top forest, and a bottom forest; each of these is a set of ùëÅ ùëá disjoint, complete binary trees of depth 3. Links connect leaves from the top and bottom forests. We generate CDFs for ùëö‚àà{2,3}: when ùëö=2, chains of triples connect a top leaf to a bottom one; when ùëö=3, a Y-shaped connection goes from a top-forest leaf, to two bottom-forest ones. A CDF graph contains ùëÅ ùêø links, each made of ùëÜ ùêø triples. Only top leaves that are targets of "c" edges can participate to links, and we concentrate the links on 50% of them (the others have no links). When ùëö=2, only 50% of the  On CDF graphs with ùëö=2, we run the query (ùë£,ùë°ùëô,ùëô) :-(ùë•,"c",ùë°ùëô), (ùë£, "g",ùëèùëô), (ùëèùëô,ùë°ùëô,ùëô) whose two BGPs bind ùë°ùëô, respectively, ùëèùëô to leaves from the top and bottom forest, while its CTP asks for all the paths between each pair of such leaves. On graphs with ùëö=3, we run (ùë£,ùë°ùëô,ùëô):-(ùë•, "c", ùë°ùëô), (ùë£, "g",ùëèùëô 1 ), (ùë£, "h",ùëèùëô 2 ),(ùë°ùëô, ùëèùëô 1 , ùëèùëô 2 , ùëô), requiring connecting trees between ùë°ùëô, ùëèùëô 1 and ùëèùëô 2 . Each CDF query has ùëÅ ùêø answers, one for each link.</p><p>Real-world graphs To compare with JEDI <ref type="bibr" target="#b1">[2]</ref> and QGSTP <ref type="bibr" target="#b38">[39]</ref>, we reused their datasets (a 6M triples subset of YAGO3, and a 18M triples subset of DBPedia), as well as their queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">CTP evaluation algorithms</head><p>5.4.1 Complete (baseline) algorithms. We start by comparing the algorithms without any pruning: BFT (Section 4.1), GAM (Section 4.2), and the BFT variants BFT-M and BFT-AM (Section 4.2), on synthetic Line, Comb and Star graphs of increasing size. We used a timeout ùëá of 10 minutes. In all experiments with GAM and all its variants, our exploration order (queue priority) favors the smallest trees, and breaks ties arbitrarily. Figure <ref type="figure" target="#fig_0">10</ref> depicts the algorithm running time; the color indicates the number of seed sets (3, 5 or 10), while the line pattern indicates the algorithm. Missing points (or curves) denote algorithms that did not complete by the timeout. Note the logarithmic ùë¶ axes.</p><p>Across these plots, BFT-M performs worse than BFT-AM. On Line graphs, the difference is a factor 2√ó for ùëö = 3 and up to 100√ó for ùëö = 10. On the Comb and Star graphs, BFT-M times out on the larger graphs and queries. BFT-AM takes even more than BFT-M, by a factor of 15√ó, thus more executions timed out. GAM is much faster and completes execution in all cases. The reason, as explained in Section 4.1, is that breadth-first algorithms waste effort by minimizing results, and may find a tree in even more different ways than GAM, since they grow from any node. Thus, we exclude breadth-first algorithms from the subsequent comparisons. 5.4.2 GAM algorithm variants. On the same graphs, we compare GAM (Section 4.2), ESP (Section 4.4), MoESP (Section 4.5), LESP (Section 4.6) and MoLESP (Section 4.7) with the same timeout. Figure <ref type="figure" target="#fig_0">11</ref> shows the algorithm running time as well as the number of provenances they built. In all graphs but Figure <ref type="figure" target="#fig_0">11a</ref>, the ùë¶ axis is Distance between the seeds, sL  The plots show, first, that edge set pruning significantly reduces the running time: MoLESP is faster than GAM by a factor ranging from 1.3√ó (Line graphs) to 15√ó (Comb graphs, ùëõùê¥=6, ùëö=18). Second, on the Star graphs, where the limited edge-set pruning (Section 4.6) applies, the performance difference between MoESP and MoLESP is small. This shows that the extra cost incurred by LESP and MoLESP, which limit or compensate for edgeset pruning (by injecting more trees), is worth paying for the completeness guarantees of MoLESP. Overall, the algorithm running times closely track the numbers of built provenances, further highlighting the interest of controlling the latter through pruning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.4.3</head><p>Comparison with QGSTP on real-world data. We now compare the winner of the above comparisons, namely MoLESP, with QGSTP <ref type="bibr" target="#b38">[39]</ref> on the 18M edges DBPedia dataset and 312 CTPs used in their evaluation. Among these, 83 CTPs (respectively, 98, 85, 38, 8) have 2 (respectively, 3, 4, 5, 6) seed sets. To align with QGSTP, we added a UNI filter (unidirectional exploration only), and LIMIT 1 to stop after the first result. Each QGSTP returned result is such that Property 9 ensures MoLESP finds it. Figure <ref type="figure" target="#fig_1">12</ref> shows the average runtimes grouped by ùëö. GAM is faster than QGSTP for ùëö‚â§5, but timed-out for the 8 CTPs with ùëö=6. MoLESP is about 6-7√ó faster than QGSTP for all ùëö values, and scales well as ùëö increases. Thus, MoLESP is competitive also on large real-world graphs and queries.</p><p>5.5 Extended query evaluation 5.5.1 Synthetic queries on CDF benchmark. We now compare our EQL query evaluation system with the graph query baselines, on our CDF graphs (Section 5.3) generated with ùëö‚àà{2,3}, ùëÜ ùêø ‚àà{3,6}, 18K to 2.4M edges, leading to 2K up to 200K results (ùëÅ ùêø ), respectively. We used ùëá =15 minutes. As explained in Section 2, the paths returned by the baselines, which we "stitch" for ùëö=3, semantically differ from CTP results; the baselines' reported time do not include the time to minimize nor deduplicate their results.</p><p>For ùëö=2, Figure <ref type="figure" target="#fig_2">13</ref> shows that all systems scale linearly in the input size (note the logarithmic time axis). For each system, the lower curve is on graphs with ùëÜ ùêø =3, while the upper curve is on graphs with ùëÜ ùêø =6 (these graphs are larger, thus curves go farther at right). All missing points correspond to time-out. JEDI succeeded only on the smallest graph, Neo4j timed-out on all. Virtuoso-SPARQL is the fastest, closely followed by Virtuoso-SQL; they are both unidirectional, require the edge labels, and do not return paths. Unidirectional MoLESP, which we included to compare with unidirectional baselines, is slower by approximately 3√ó only. JEDI is slower than MoLESP by 10 2 √ó on the smallest graph, and timed-out on the others. Postgres is faster than JEDI, yet at least 10√ó slower than MoLESP. MoLESP is the only feasible bidirectional algorithm; it runs in under 2 minutes on the largest graph with 2.4M edges.</p><p>Figure <ref type="figure" target="#fig_4">14</ref> shows similar results for ùëö=3. Postgres timed-out in all cases. Virtuoso-SPARQL is 7√ó faster than Virtuoso-SQL; both return non-minimal, duplicate results. UNI-MoLESP outperforms every system, while also returning connecting trees. Note that the bidirectional MoLESP found about 7√ó more results than the ùëÅ ùêø expected ones, by also connecting bottom leaves without a common parent through their grandparent node; these results are filtered by the join between the BGPs and the CTP (Section 3). Despite the much larger search space due to bidirectionality, MoLESP scales well with the size of the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.5.2</head><p>Comparison with JEDI on real-world data. JEDI <ref type="bibr" target="#b1">[2]</ref> used a set of (unidirectional, label-constrained) SPARQL 1.1 queries over YAGO3. with JEDI, Virtuoso and Neo4j (Postgres timed-out on all). Query ùêΩ 2 has one very large seed set, while query ùêΩ 3 has a N seed set.</p><p>On queries ùêΩ 2 and ùêΩ 3 , MoLESP timed out. Thus, we applied the optimizations described in Section 4.9, which enabled it to perform as shown. Virtuoso-SPARQL completed query ùêΩ 1 , then ran out of memory. Compared with JEDI, our query evaluation engine is 2√ó faster on ùêΩ 1 , close on ùêΩ 2 , and around 3√ó slower on ùêΩ 3 . MoLESP took around 30% of the total time, the rest being spent by Postgres in the BGP evaluation and final joins. This shows that the optimizations described in Section 4.9 make MoLESP robust also to large seed sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK AND PERSPECTIVES</head><p>We focused on extending a graph query language, such as SPARQL <ref type="bibr" target="#b12">[13]</ref>, Cypher <ref type="bibr" target="#b34">[35]</ref> or GraphQL <ref type="bibr" target="#b17">[18]</ref>, with connecting tree patterns (CTPs) that they currently do not support (our requirement (R1) from Section 1). Specifically, SPARQL 1.1 property paths (ùëñ) allow to check that some paths connect two nodes, not to return the path(s); (ùëñùëñ) do not allow searching for arbitrary paths (users have to specify a regular expression); (ùëñùëñùëñ) are restricted to unidirectional paths only. Some PG query languages such as Neo4j's Cypher lift these restrictions, however, its implementation does not scale (Section 5.5.1) <ref type="bibr" target="#b10">[11]</ref>. RPQProv <ref type="bibr" target="#b14">[15]</ref> uses recursive SQL to return path labels; JEDI <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> builds over SPARQL 1.1 by returning all unidirectional paths. Many works focus on finding label-constrained paths between nodes <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b44">45]</ref>, typically by using precomputed indexes or sketches. In our CTP evaluation algorithm, an index could be integrated by "reading from it" paths (or subtrees) on which to Grow and Merge. Our CTPs extend finding paths, to finding trees that connect an arbitrary number of seed sets (ùëö‚â•3), traversing edges in any direction by default; we guarantee completeness for ùëö‚â§3 and finding a large set of results for arbitrary ùëö. As we explained (Section 2), path stitching leads to different results, which may require deduplication and minimization.</p><p>The CTP evaluation problem is directly related to keyword search in (semi-)structured data, addressed in many algorithms, some of which are surveyed in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b43">44]</ref>. These prior studies differ from ours as follows: (ùëñ) <ref type="bibr">[4, 14, 21, 23-25, 27, 32, 33, 41]</ref> are schemadependent; (ùëñùëñ) <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b40">41]</ref> assume available a compact summary of the graph; (ùëñùëñùëñ) <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b30">31]</ref> depend heavily on their score functions for pruning the search, particularly to approximate the best result <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b30">31]</ref> or return only top-ùëò results <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b45">46]</ref>; (ùëñùë£) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24]</ref> are only unidirectional. For these reasons, they fail to meet our requirements (R2) to (R5) as outlined in Section 1.</p><p>The Java-based GAM algorithm used in this work <ref type="bibr" target="#b5">[6]</ref> was sped up by up to 100√ó in a multi-threaded, C++ version <ref type="bibr" target="#b4">[5]</ref>. MoLESP brings new, orthogonal, optimizations, and novel guarantees.</p><p>Our future work includes developing adaptive EQL optimization and execution strategies and applying it to graph exploration for investigative journalism.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Sample data graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Sample "chain" graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>ESP incompleteness example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>A set of Grow lead to these trees: A-1, B-2, B-3, C-3. (3) B-3 and C-3 merge into B-3-C. (4) Grow on A-1 leads to A-1-2, which immediately merges with B-2, forming A-1-2-B. (5) After this point: ‚Ä¢ If the tree A-1-2-B is built, for instance by Grow on A-1-2, ESP discards it since A-1-2-B was found in step (4). Lacking A-1-2-B, we cannot Grow over it to build the result provenance A-1-2-B-3-C. Nor can we build the result provenance Merge (A-1-2-B, B-3-C).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Sample graph for MoESP discussion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>) B-3 and C-3 merge into B-3-C. MoESP trees are added at this point: B-3-C and B-3-C. (3) Grow on A-1 leads to A-1-2, which merges with B-2, forming A-1-2-B. Similarly, A-1-2-B and A-1-2-B are added. (4) A-1-2-B merges with B-3-C, leading to the result. We now generalize the example by establishing completeness guarantees for MoESP.Definition 4.5 (Simple and ùëù-simple edge set). A simple edge set is an edge set (Def. 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>MoESP incompleteness example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :( 3 )</head><label>63</label><figDesc>Figure 6: LESP incompleteness example with 4 seed sets. (3) Grow builds C-3-4 which merges with D-4 into C-3-4-D. (4) Grow builds: A-1-2; B-2-x which cannot merge with B-2 as A-1-2-B exists, and (ùë†ùë† 2 ) = 2; D-4-3 which cannot merge with C-3 as C-3-4-D exists, and (ùë†ùë† 3 ) = 2. (5) C-3-x merges with B-2-x to build B-2-x-3-C. (6) C-3-x-2 merges with: A-1-2, leading to C-3-x-2-1-A; and B-2, leading to C-3-x-2-B. (7) Similarly, B-2-x-3, aggressively merges with C-3, leading to B-2-x-3-C, and D-4-3, leading to B-2-x-3-4-D. (8) Progressing similarly, we can only merge at most 3 rooted paths, in nodes 2, x or 3. We cannot merge with a path leading to the 4th seed, because the trees with the edge sets A-1-2-B and C-3-4-D, built at (2), (3) above, are not rooted in 2 nor 3, respectively, and these are the only nodes satisfying the LESP condition that "spares" some Merge trees.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>6 Figure 7 : 9 (Algorithm 2 : 8 if 3 : 3 Copy 4 Add</head><label>67928334</label><figDesc>MoLESP completeness example. Algorithm 1: MoLESP(graph G, seed sets (ùëÜ 1 . . . , ùëÜ ùëö )) Output: Set of results, Res 1 Priority queue PrioQ ‚Üê new priority queue; 2 History Hist ‚Üê new set of edge sets; 3 foreach ùëÜ ùëñ , 1 ‚â§ ùëñ ‚â§ ùëö do PrioQ is not empty do ùë°, ùëí) ‚Üê ùëùùëúùëôùëô (PrioQ); ùë° ‚Ä≤ ‚Üê Grow (ùë°, ùëí); 10 Update ùë†ùë† ùëüùëúùëúùë° (ùë° ‚Ä≤ ) ; processTree(ùë° ‚Ä≤ ); 11 end Procedure processTree(provenance ùë°) 1 if isNew(ùë°) then 2 Add ùë° to Hist ; 3 if isResult(ùë°) then 4 Add ùë° to Res; ùë° is not a MoESP tree then 9 for edge ùëí ‚àà adjacentEdges(ùë° .ùëüùëúùëúùë°) do 10 if ‚Ñéùëéùë†ùëÅùëúùë°ùêµùëíùëíùëõùêºùëõùëÑùë¢ùëíùë¢ùëí (ùë°, ùëí) then 11 Add (ùë°, ùëí) to PrioQ; Procedure recordForMerging(tree ùë°) 1 Add ùë° to TreesRootedIn[ùë° .ùëüùëúùëúùë°]; 2 for ùëõ ‚àà (ùëõùëúùëëùëíùë† (ùë°) ‚à© ‚à™ ùëñ (ùëÜ ùëñ )) do ùë° into a new tree ùë° ‚Ä≤ , rooted at ùëõ, with provenance Mo(ùë°, ùëõ); ùë° ‚Ä≤ to TreesRootedIn[ùëõ]; 5 MergeAll(ùë° ‚Ä≤ ); 6 end</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Algorithm 4 :Algorithm 5 :</head><label>45</label><figDesc>Procedure isNew(tree ùë°) 1 if ùë° ‚àâ Hist then 2 return ùë°ùëüùë¢ùëí; 3 end 4 if Œ£(ùë†ùë† ùë° .ùëüùëúùëúùë° ) ‚â• 3 and ùëë ùë° .ùëüùëúùëúùë° ‚â• 3 then 5 if ùë° ‚àâ TreesRootedIn[ùë° .ùëüùëúùëúùë°] Procedure MergeAll(tree ùë°) 1 toBeMerged ‚Üê {ùë° }; 2 while toBeMerged ‚â† ‚àÖ do 3 currentTrees ‚Üê toBeMerged; toBeMerged ‚Üê ‚àÖ; 4 for ùë° ‚Ä≤ ‚àà currentTrees do 5 mergePartners ‚Üê TreesRootedIn[ùë° ‚Ä≤ .ùëüùëúùëúùë°]; 6 for ùë° ùëù ‚àà mergePartners do 7 if sat(ùë° ‚Ä≤ ) ‚à© sat(ùë° ùëù ) = ‚àÖ and ùë° ‚Ä≤ ‚à© ùë° ùëù = {ùë° ‚Ä≤ .ùëüùëúùëúùë° } then 8 ùë° ‚Ä≤‚Ä≤ ‚Üê Merge (ùë° ‚Ä≤ , ùë° ùëù ); 9 if isNew(ùë° ‚Ä≤‚Ä≤ ) then 10 Add ùë° ‚Ä≤‚Ä≤ to toBeMerged; 11 processTree(ùë° ‚Ä≤‚Ä≤ );</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Synthetic graphs: Comb(3, 1, 2, 3) at the top left, Star(4, 2) at the top right, and Line(3, 1) at the bottom.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: CDF graphs generated with ùëö=2, ùëÜ ùêø =2 (left), and with ùëö=3, ùëÜ ùêø = 3 (right). bottom forest leaves that are targets of "g" edges can participate; when ùëö=3, 50% of all the bottom forest leaf can participate. The links are uniformly distributed across the eligible leaves. A CDF has 12‚Ä¢ùëÅ ùëá +ùëÅ ùêø ‚Ä¢ùëÜ ùêø edges; it has 14‚Ä¢ùëÅ ùëá +ùëÅ ùêø ‚Ä¢(ùëÜ ùêø -1) nodes if ùëö=2, and 14‚Ä¢ùëÅ ùëá +ùëÅ ùêø ‚Ä¢ùëÜ ùêø if ùëö=3.On CDF graphs with ùëö=2, we run the query (ùë£,ùë°ùëô,ùëô) :-(ùë•,"c",ùë°ùëô), (ùë£, "g",ùëèùëô), (ùëèùëô,ùë°ùëô,ùëô) whose two BGPs bind ùë°ùëô, respectively, ùëèùëô to leaves from the top and bottom forest, while its CTP asks for all the paths between each pair of such leaves. On graphs with ùëö=3, we run (ùë£,ùë°ùëô,ùëô):-(ùë•, "c", ùë°ùëô), (ùë£, "g",ùëèùëô 1 ), (ùë£, "h",ùëèùëô 2 ),(ùë°ùëô, ùëèùëô 1 , ùëèùëô 2 , ùëô), requiring connecting trees between ùë°ùëô, ùëèùëô 1 and ùëèùëô 2 . Each CDF query has ùëÅ ùêø answers, one for each link.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>Figure 10: Comparison of complete CTP evaluation baselines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 12 :Figure 13 :Figure 14 :</head><label>121314</label><figDesc>Figure12: GAM and MoLESP vs. QGSTP<ref type="bibr" target="#b38">[39]</ref> on DBPedia.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>8 (Set-based CTP result). Let ùëî = (ùëî 1 , . . . , ùëî ùëö , ùë£ ùëö+1 ) be a CTP pattern and ùëÜ 1 , . . . , ùëÜ ùëö be sets of G nodes, called seed sets, such that every node in ùëÜ ùëñ satisfies ùëî ùëñ , for 1‚â§ùëñ‚â§ùëö. The result of ùëî based on ùëÜ 1 , . . . , ùëÜ ùëö , denoted ùëî(ùëÜ 1 , . . . , ùëÜ ùëö ), is the set of all (ùë† 1 , . . . , ùë† ùëö , ùë°) tuples such that ùë† 1 ‚àà ùëÜ 1 , . . ., ùë† ùëö ‚àà ùëÜ ùëö and ùë° is a minimal subtree of G containing the nodes ùë† 1 , . . . , ùë† ùëö . By minimal, we mean that (ùëñ) removing any edge from ùë° disconnects it and/or removes some ùë† ùëñ from ùë°, and (ùëñùëñ) ùë° contains only one node from each ùëÜ ùëñ . In our sample graph, let ùëÜ 1 = {ùëõ 2 , ùëõ 4 } (US entrepreneurs), ùëÜ 2 = {ùëõ 3 , ùëõ 6 } (French entrepreneurs), and ùëÜ 3 = {ùëõ 9 } (French politicians). Then, ùëî 1 (ùëÜ 1 , ùëÜ 2 , ùëÜ 3 ) includes (ùëõ 4 , ùëõ 6 , ùëõ 9 , ùë° ùõº ) where the tree ùë° ùõº consists of the edges ùëõ 4 ùëõ 9 , also denoted by {ùëí 10 , ùëí 9 , ùëí 11 } for brevity. Another result of this CTP is (ùëõ 2 , ùëõ 3 , ùëõ 9 , ùë° ùõΩ ), with ùë° ùõΩ = {ùëí 1 , ùëí 2 , ùëí 17 , ùëí 16 }. This result is only possible because Def. 2.8 allows trees to span over G edges regardless of the edge direction. Had it required directed trees, ùë° ùõΩ would not qualify, since none of its nodes can reach the others through unidirectional paths.</figDesc><table><row><cell>ùëí 10 --‚Üí ùëõ 7</cell><cell>ùëí 9 ‚Üê --ùëõ 6</cell><cell>ùëí 11 ‚Üê --</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1) The restriction of ùúô to each BGP pattern ùëè of ùëÑ is an embedding of ùëè into G (Def. 2.7); (2) For each query CTP of the form ùëî = (ùëî 1 , . . . , ùëî ùëö , ùë£ ùëö+1 ), such that the simple variable in the predicate ùëî ùëñ , for 1‚â§ùëñ‚â§ùëö, is ùë£ ùëñ , ùúô maps each ùë£ ùëñ into a G node satisfying ùëî ùëñ . Definition 2.10 (Core query result). Let ùëÑ be a core query having the head variables ùë¢ 1 , . . . , ùë¢ ùëõ , and the simple variables ùë£ 1 , . . . , ùë£ ùëù . Let Œ¶ be the set of all (ùúô (ùë£ 1 ), . . . , ùúô (ùë£ ùëù )) tuples for any simple embedding ùúô of ùëÑ in G. For each CTP ùëî ùëó in ùëÑ of the form (ùëî 1 , . . . , ùëî ùëö , ùë£ ùëö+1 ),</figDesc><table><row><cell>let ùë£</cell><cell cols="5">ùëó ùëñ be the simple variable in ùëî ùëñ , 1‚â§ùëñ‚â§ùëö. We define the ùëñ-th seed</cell></row><row><cell cols="2">set of ùëî ùëó , denoted ùëÜ</cell><cell>ùëó ùëñ , as ùúã</cell><cell>ùëñ ùë£ ùëó</cell><cell>(Œ¶), that is: all the nodes to which ùë£</cell><cell>ùëó ùëñ is</cell></row><row><cell cols="5">bound in Œ¶. The result of ùëÑ is:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>1 1 , . . . , ùëÜ 1 ùëö 1 ) ‚ä≤‚ä≥ . . . ‚ä≤‚ä≥ ùëî ùëô (ùëÜ ùëô 1 , . . . , ùëÜ ùëô ùëö ùëô )) where ùëî 1 , . . . , ùëî ùëô are the CTPs of ùëÑ, having respectively ùëö ùëó simple variables, 1‚â§ ùëó ‚â§ùëô, ùëî ùëó (ùëÜ</figDesc><table><row><cell>ùëó 1 , . . . , ùëÜ ùëö ùëó ) is the set-based CTP result of ùëî ùëó ùëó (Def. 2.8) on its seed sets derived from Œ¶, and ‚ä≤‚ä≥ denotes the natural</cell></row><row><cell>join on all the simple variables.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>table ùêµ ùëñ .(B) For each CTP ùëî ùëó of the query, of the form (ùëî For 1 ‚â§ ùëñ ‚â§ ùëö ùëó , where ùë£ ùëó ùëñ appears also in one of the ùêµ ùëñ , take ùëÜ Compute ùêπ ùëó (ùëî ùëó (ùëÜ ùëó )), where ùêπ ùëó (‚Ä¢) applies all the CTP filters that may be attached to ùëî ùëó . In practice, we actually push the filters in the CTP evaluation. Thus, we use the notation ùëî ùëó (ùëÜ ùëó , ùêπ ùëó ) to denote the set-based result of ùëî ùëó given its seed sets and filters, and store it in a table ùê∂ùëá ùëÉ ùëó .</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">ùëó 1 , . . . , ùëî ùëö ùëó , ùë£ ùëó</cell><cell>ùëó ùëö ùëó +1 ):</cell></row><row><cell cols="5">(1) ùëó ùëñ is the variable in ùëî ùëñ , compute the ùëó</cell></row><row><cell>seed set ùëÜ</cell><cell>ùëó ùëñ as follows.</cell><cell></cell><cell></cell></row><row><cell>‚Ä¢ If ùë£</cell><cell></cell><cell></cell><cell></cell><cell>ùëó ùëñ to be ùúã</cell><cell>ùëñ ùë£ ùëó</cell><cell>(ùêµ ùëñ )</cell></row><row><cell cols="3">(all the nodes to which ùë£</cell><cell cols="2">ùëó ùëñ has been bound). Further, if</cell></row><row><cell cols="4">ùëî ùëñ is not an empty predicate, restrict ùëÜ ùëó</cell><cell>ùëó ùëñ to only those</cell></row><row><cell cols="4">nodes that also satisfy ùëî ùëñ . ùëó</cell></row><row><cell cols="2">‚Ä¢ Otherwise, we obtain ùëÜ</cell><cell cols="3">ùëó ùëñ by restricting N (the graph's</cell></row><row><cell cols="4">nodes set) to those that match ùëî ùëñ . ùëó</cell></row><row><cell>(2)</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>ùëó 1 , . . . , ùëÜ ùëó ùëö ùëó 1 , . . . , ùëÜ ùëó ùëö</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>). bottom forest leaves that are targets of "g" edges can participate; when ùëö=3, 50% of all the bottom forest leaf can participate. The links are uniformly distributed across the eligible leaves. A CDF has 12‚Ä¢ùëÅ ùëá +ùëÅ ùêø ‚Ä¢ùëÜ ùêø edges; it has 14‚Ä¢ùëÅ ùëá +ùëÅ ùêø ‚Ä¢(ùëÜ ùêø -1) nodes if ùëö=2, and 14‚Ä¢ùëÅ ùëá +ùëÅ ùêø ‚Ä¢ùëÜ ùêø if ùëö=3.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 1 :</head><label>1</label><figDesc>Table1shows the queries' characteristics. We compare MoLESP similarly constrained (UNI and LABEL), on these queries, Query evaluation times (seconds) on YAGO3 dataset.</figDesc><table><row><cell>Query</cell><cell cols="3">JEDI MoLESP Virtuoso</cell><cell>Neo4j</cell></row><row><cell>ùêΩ 1 : 3 BGPs, 2 CTPs</cell><cell>3.9</cell><cell>1.9</cell><cell cols="2">0.2 TimeOut</cell></row><row><cell>ùêΩ 2 : 2 BGPs, 1 CTP, large seed set</cell><cell>0.9</cell><cell>1</cell><cell cols="2">OOM TimeOut</cell></row><row><cell>ùêΩ 3 : 1 CTP, N seed set</cell><cell>0.75</cell><cell>2.3</cell><cell>OOM</cell><cell>1.27</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Accessible using the built-in function sparql_to_sql_text().</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments. This work is funded by <rs type="projectName">AI Chair SourcesSay</rs> project (<rs type="grantNumber">ANR-20-CHIA-0015-01</rs>) grant.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_tsxEjUB">
					<idno type="grant-number">ANR-20-CHIA-0015-01</idno>
					<orgName type="project" subtype="full">AI Chair SourcesSay</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">BANKS: Browsing and Keyword Searching in Relational Databases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Aditya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumen</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charuta</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parag</surname></persName>
		</author>
		<author>
			<persName><surname>Sudarshan</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-155860869-6/50114-1</idno>
		<ptr target="https://doi.org/10.1016/B978-155860869-6/50114-1" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 28th International Conference on Very Large Data Bases, VLDB 2002</title>
		<meeting>28th International Conference on Very Large Data Bases, VLDB 2002<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08-20">2002. August 20-23, 2002</date>
			<biblScope unit="page" from="1083" to="1086" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Discovering Diversified Paths in Knowledge Bases</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Aebeloe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriela</forename><surname>Montoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vinay</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katja</forename><surname>Hose</surname></persName>
		</author>
		<idno type="DOI">10.14778/3229863.3236245</idno>
		<ptr target="http://qweb.cs.aau.dk/jedi/" />
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="2002" to="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Top-K Diversification for Path Queries in Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Aebeloe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vinay</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriela</forename><surname>Montoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katja</forename><surname>Hose</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-2180/paper-01.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ISWC 2018 Posters &amp; Demonstrations, Industry and Blue Sky Ideas Tracks co-located with 17th International Semantic Web Conference (ISWC 2018)</title>
		<editor>
			<persName><forename type="first">Medha</forename><surname>Marieke Van Erp</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vanessa</forename><surname>Atre</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kavitha</forename><surname>L√≥pez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Carolina</forename><surname>Srinivas</surname></persName>
		</editor>
		<editor>
			<persName><surname>Fortuna</surname></persName>
		</editor>
		<meeting>the ISWC 2018 Posters &amp; Demonstrations, Industry and Blue Sky Ideas Tracks co-located with 17th International Semantic Web Conference (ISWC 2018)<address><addrLine>Monterey, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-10-08">2018. October 8th -to -12th, 2018</date>
			<biblScope unit="volume">2180</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings)</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">DBXplorer: A System for Keyword-Based Search over Relational Databases</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Das</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2002.994693</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2002.994693" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Data Engineering</title>
		<editor>
			<persName><forename type="first">Rakesh</forename><surname>Agrawal</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Klaus</forename><forename type="middle">R</forename><surname>Dittrich</surname></persName>
		</editor>
		<meeting>the 18th International Conference on Data Engineering<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002-02-26">2002. February 26 -March 1, 2002</date>
			<biblScope unit="page" from="5" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Empowering Investigative Journalism with Graph-based Heterogeneous Data Management</title>
		<author>
			<persName><forename type="first">Angelos-Christos</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oana</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Th√©o</forename><surname>Bouganim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Chimienti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helena</forename><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yamen</forename><surname>Mhd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">St√©phane</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Horel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Youssr</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><surname>Youssef</surname></persName>
		</author>
		<ptr target="https://hal.archives-ouvertes.fr/hal-03337650" />
		<imprint>
			<date type="published" when="2021-09">2021. Sept. 2021</date>
		</imprint>
	</monogr>
	<note type="report_type">Bulletin of the Technical Committee on Data Engineering</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Graph integration of structured, semistructured and unstructured data for data journalism</title>
		<author>
			<persName><forename type="first">Christos</forename><forename type="middle">G</forename><surname>Angelos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oana</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catarina</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helena</forename><surname>Concei√ß√£o</surname></persName>
		</author>
		<author>
			<persName><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yamen</forename><surname>Mhd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tayeb</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingmao</forename><surname>Merabti</surname></persName>
		</author>
		<author>
			<persName><surname>You</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.is.2021.101846</idno>
		<ptr target="https://doi.org/10.1016/j.is.2021.101846" />
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="page">101846</biblScope>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">SPARQ2L: towards support for subgraph extraction queries in rdf databases</title>
		<author>
			<persName><forename type="first">Kemafor</forename><surname>Anyanwu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Maduko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><forename type="middle">P</forename><surname>Sheth</surname></persName>
		</author>
		<idno type="DOI">10.1145/1242572.1242680</idno>
		<ptr target="https://doi.org/10.1145/1242572.1242680" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on World Wide Web, WWW 2007</title>
		<meeting>the 16th International Conference on World Wide Web, WWW 2007<address><addrLine>Banff, Alberta, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05-08">2007. May 8-12, 2007</date>
			<biblScope unit="page" from="797" to="806" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Time-and Space-Efficient Regular Path Queries on Graphs</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Arroyuelo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gonzalo</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javiel</forename><surname>Rojas-Ledesma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Objec-tRank: Authority-Based Keyword Search in Databases</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Balmin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-012088469-8.50051-6</idno>
		<ptr target="https://doi.org/10.1016/B978-012088469-8.50051-6" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth International Conference on Very Large Data Bases, VLDB 2004</title>
		<meeting>the Thirtieth International Conference on Very Large Data Bases, VLDB 2004<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-08-31">2004. August 31 -September 3 2004</date>
			<biblScope unit="page" from="564" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Keyword Searching and Browsing in Databases using BANKS</title>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charuta</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumen</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2002.994756</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2002.994756" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Data Engineering</title>
		<meeting>the 18th International Conference on Data Engineering<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-02-26">2002. February 26 -March 1, 2002</date>
			<biblScope unit="page" from="431" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Tuning Cypher queries by understanding cardinality</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Bowman</surname></persName>
		</author>
		<ptr target="https://neo4j.com/developer/kb/understanding-cypher-cardinality/#_distinct_nodes_from_variable_length_paths" />
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Empirical Performance Evaluation of Relational Keyword Search Techniques</title>
		<author>
			<persName><forename type="first">Joel</forename><surname>Coffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfred</forename><forename type="middle">C</forename><surname>Weaver</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2012.228</idno>
		<ptr target="https://doi.org/10.1109/TKDE.2012.228" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">SPARQL 1</title>
		<idno>.1</idno>
		<ptr target="https://www.w3.org/TR/sparql11-overview/" />
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
		<respStmt>
			<orgName>WWW Consortium</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Match-Based Candidate Network Generation for Keyword Queries over Relational Databases</title>
		<author>
			<persName><forename type="first">Altigran</forename><forename type="middle">S</forename><surname>Pericles De Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edleno</forename><surname>Da Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rosiane</forename><surname>Silva De Moura</surname></persName>
		</author>
		<author>
			<persName><surname>Rodrigues</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2018.00146</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2018.00146" />
	</analytic>
	<monogr>
		<title level="m">34th IEEE International Conference on Data Engineering, ICDE 2018</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-04-16">2018. April 16-19, 2018</date>
			<biblScope unit="page" from="1344" to="1347" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On implementing provenance-aware regular path queries with relational query engines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Saumen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V√≠ctor</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Cuevas-Vicentt√≠n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>K√∂hler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Gribkoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bertram</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><surname>Lud√§scher</surname></persName>
		</author>
		<idno type="DOI">10.1145/2457317.2457353</idno>
		<ptr target="https://doi.org/10.1145/2457317.2457353" />
	</analytic>
	<monogr>
		<title level="m">Joint 2013 EDBT/ICDT Conferences, EDBT/ICDT &apos;13</title>
		<title level="s">Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">Giovanna</forename><surname>Guerrini</surname></persName>
		</editor>
		<meeting><address><addrLine>Genoa, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013-03-22">2013. March 22, 2013</date>
			<biblScope unit="page" from="214" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Finding Top-k Min-Cost Connected Trees in Databases</title>
		<author>
			<persName><forename type="first">Bolin</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2007.367929</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2007.367929" />
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="836" to="845" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient regular path query evaluation using path indexes</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeroen</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName><surname>Poulovassilis</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2016.67</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2016.67" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Extending Database Technology, EDBT 2016</title>
		<editor>
			<persName><forename type="first">Evaggelia</forename><surname>Pitoura</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sofian</forename><surname>Maabout</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Georgia</forename><surname>Koutrika</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Am√©lie</forename><surname>Marian</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Letizia</forename><surname>Tanca</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kostas</forename><surname>Stefanidis</surname></persName>
		</editor>
		<meeting>the 19th International Conference on Extending Database Technology, EDBT 2016<address><addrLine>Bordeaux, France; Bordeaux, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-03-15">2016. March 15-16, 2016. March 15-16, 2016</date>
			<biblScope unit="page" from="636" to="639" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">GraphQL</title>
		<ptr target="https://graphql.org/" />
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
			<publisher>The GraphQL Foundation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sparqling kleene: fast property paths in RDF-3X</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srikanta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Bedathur</surname></persName>
		</author>
		<author>
			<persName><surname>Seufert</surname></persName>
		</author>
		<idno type="DOI">10.1145/2484425.2484443</idno>
		<ptr target="https://doi.org/10.1145/2484425.2484443" />
	</analytic>
	<monogr>
		<title level="m">First International Workshop on Graph Data Management Experiences and Systems, GRADES 2013, co-located with SIG-MOD/PODS 2013</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-06-24">2013. June 24, 2013. 14</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Path Query Processing on Very Large RDF Graphs</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
		<ptr target="http://webdb2011.rutgers.edu/papers/Paper21/pathwebdb.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Workshop on the Web and Databases 2011</title>
		<meeting>the 14th International Workshop on the Web and Databases 2011<address><addrLine>WebDB; Athens, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-06-12">2011. 2011. June 12, 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">XRANK: Ranked Keyword Search over XML Documents</title>
		<author>
			<persName><forename type="first">Lin</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chavdar</forename><surname>Botev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jayavel</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<idno type="DOI">10.1145/872757.872762</idno>
		<ptr target="https://doi.org/10.1145/872757.872762" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2003 ACM SIGMOD International Conference on Management of Data<address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06-09">2003. June 9-12, 2003</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">BLINKS: ranked keyword searches on graphs</title>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Hao He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><surname>Yu</surname></persName>
		</author>
		<idno type="DOI">10.1145/1247480.1247516</idno>
		<ptr target="https://doi.org/10.1145/1247480.1247516" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06-12">2007. June 12-14, 2007</date>
			<biblScope unit="page" from="305" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient IR-Style Keyword Search over Relational Databases</title>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-012722442-8/50080-X</idno>
		<ptr target="https://doi.org/10.1016/B978-012722442-8/50080-X" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 29th International Conference on Very Large Data Bases, VLDB 2003</title>
		<meeting>29th International Conference on Very Large Data Bases, VLDB 2003<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-09-09">2003. September 9-12, 2003</date>
			<biblScope unit="page" from="850" to="861" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">DISCOVER: Keyword Search in Relational Databases</title>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/2002/S19P02.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Keyword Proximity Search on XML Graphs</title>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Balmin</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2003.1260806</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2003.1260806" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Data Engineering</title>
		<meeting>the 19th International Conference on Data Engineering<address><addrLine>Bangalore, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03-05">2003. March 5-8, 2003</date>
			<biblScope unit="page" from="367" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Bidirectional Expansion For Keyword Search on Graph Databases</title>
		<author>
			<persName><forename type="first">Varun</forename><surname>Kacholia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shashank</forename><surname>Pandit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumen</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rushi</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hrishikesh</forename><surname>Karambelkar</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/archives/website/2005/program/paper/wed/p505-kacholia.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Very Large Data Bases</title>
		<meeting>the 31st International Conference on Very Large Data Bases<address><addrLine>Trondheim, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-08-30">2005. August 30 -September 2, 2005</date>
			<biblScope unit="page" from="505" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">STAR: Steiner-Tree Approximation in Relationship Graphs</title>
		<author>
			<persName><forename type="first">Gjergji</forename><surname>Kasneci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maya</forename><surname>Ramanath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauro</forename><surname>Sozio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2009.64</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2009.64" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Data Engineering, ICDE 2009</title>
		<meeting>the 25th International Conference on Data Engineering, ICDE 2009<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-03-29">2009. March 29 2009 -April 2 2009</date>
			<biblScope unit="page" from="868" to="879" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Path Indexing in the Cypher Query Pipeline</title>
		<author>
			<persName><forename type="first">Jochem</forename><surname>Kuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2021.68</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2021.68" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on Extending Database Technology, EDBT 2021</title>
		<meeting>the 24th International Conference on Extending Database Technology, EDBT 2021<address><addrLine>Nicosia, Cyprus</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021-03-23">2021. March 23 -26, 2021</date>
			<biblScope unit="page" from="582" to="587" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Scalable Keyword Search on Large RDF Data</title>
		<author>
			<persName><forename type="first">Wangchao</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feifei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Songyun</forename><surname>Duan</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2014.2302294</idno>
		<ptr target="https://doi.org/10.1109/TKDE.2014.2302294" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2774" to="2788" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">EASE: an effective 3-in-1 keyword search method for unstructured, semistructured and structured data</title>
		<author>
			<persName><forename type="first">Guoliang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Beng</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Chin</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianhua</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianyong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizhu</forename><surname>Zhou</surname></persName>
		</author>
		<idno type="DOI">10.1145/1376616.1376706</idno>
		<ptr target="https://doi.org/10.1145/1376616.1376706" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2008</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data, SIGMOD 2008<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06-10">2008. June 10-12, 2008</date>
			<biblScope unit="page" from="903" to="914" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Efficient and Progressive Group Steiner Tree Search</title>
		<author>
			<persName><forename type="first">Rong-Hua</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rui</forename><surname>Mao</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2915217</idno>
		<ptr target="https://doi.org/10.1145/2882903.2915217" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, SIGMOD Conference 2016</title>
		<meeting>the 2016 International Conference on Management of Data, SIGMOD Conference 2016<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06-26">2016. June 26 -July 01, 2016</date>
			<biblScope unit="page" from="91" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Spark: top-k keyword query in relational databases</title>
		<author>
			<persName><forename type="first">Yi</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaofang</forename><surname>Zhou</surname></persName>
		</author>
		<idno type="DOI">10.1145/1247480.1247495</idno>
		<ptr target="https://doi.org/10.1145/1247480.1247495" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06-12">2007. June 12-14, 2007</date>
			<biblScope unit="page" from="115" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">SPARK2: Top-k Keyword Query in Relational Databases</title>
		<author>
			<persName><forename type="first">Yi</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaofang</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianmin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keqiu</forename><surname>Li</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2011.60</idno>
		<ptr target="https://doi.org/10.1109/TKDE.2011.60" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1763" to="1780" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Regular Path Query Evaluation Sharing a Reduced Transitive Closure Based on Graph Reduction</title>
		<author>
			<persName><forename type="first">Inju</forename><surname>Na</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilyeop</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyu-Young</forename><surname>Whang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang-Sae</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soon</forename><forename type="middle">J</forename><surname>Hyun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Cypher Query Language</title>
		<author>
			<persName><surname>Inc</surname></persName>
		</author>
		<idno>. Neo4j</idno>
		<ptr target="https://neo4j.com/developer/cypher/" />
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Answering reachability and K-reach queries on large graphs with label constraints</title>
		<author>
			<persName><forename type="first">You</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ying</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenjie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00778-021-00695-0</idno>
		<ptr target="https://doi.org/10.1007/s00778-021-00695-0" />
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="101" to="127" />
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Root Rank: A Relational Operator for KWS Result Ranking</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Vinay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jayant</surname></persName>
		</author>
		<author>
			<persName><surname>Haritsa</surname></persName>
		</author>
		<idno type="DOI">10.1145/3297001.3297014</idno>
		<ptr target="https://doi.org/10.1145/3297001.3297014" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM India Joint International Conference on Data Science and Management of Data, COMAD/CODS 2019</title>
		<meeting>the ACM India Joint International Conference on Data Science and Management of Data, COMAD/CODS 2019<address><addrLine>Kolkata, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-01-03">2019. January 3-5, 2019</date>
			<biblScope unit="page" from="103" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Operator implementation of Result Set Dependent KWS scoring functions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Vinay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jayant</surname></persName>
		</author>
		<author>
			<persName><surname>Haritsa</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.is.2019.101465</idno>
		<ptr target="https://doi.org/10.1016/j.is.2019.101465" />
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page">101465</biblScope>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Efficient Computation of Semantically Cohesive Subgraphs for Keyword-Based Knowledge Graph Exploration</title>
		<author>
			<persName><forename type="first">Yuxuan</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gong</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trung-Kien</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evgeny</forename><surname>Kharlamov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yulin</forename><surname>Shen</surname></persName>
		</author>
		<idno type="DOI">10.1145/3442381.3449900</idno>
		<ptr target="https://github.com/nju-websoft/QGSTP" />
	</analytic>
	<monogr>
		<title level="m">WWW &apos;21: The Web Conference 2021</title>
		<editor>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marko</forename><surname>Grobelnik</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Najork</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jie</forename><surname>Tang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Leila</forename><surname>Zia</surname></persName>
		</editor>
		<meeting><address><addrLine>Virtual Event / Ljubljana, Slovenia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021-04-19">2021. April 19-23, 2021</date>
			<biblScope unit="page" from="1410" to="1421" />
		</imprint>
	</monogr>
	<note>ACM / IW3C2</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Finding Group Steiner Trees in Graphs with both Vertex and Edge Weights</title>
		<author>
			<persName><forename type="first">Yahui</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaokui</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Saman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Theodoros</forename><surname>Halgamuge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Lappas</surname></persName>
		</author>
		<author>
			<persName><surname>Luo</surname></persName>
		</author>
		<idno type="DOI">10.14778/3450980.3450982</idno>
		<ptr target="https://doi.org/10.14778/3450980.3450982" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1137" to="1149" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Topk Exploration of Query Candidates for Efficient Keyword Search on Graph-Shaped (RDF) Data</title>
		<author>
			<persName><forename type="first">Thanh</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haofen</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Cimiano</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2009.119</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2009.119" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Data Engineering, ICDE 2009</title>
		<meeting>the 25th International Conference on Data Engineering, ICDE 2009<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-03-29">2009. March 29 2009 -April 2 2009</date>
			<biblScope unit="page" from="405" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Landmark Indexing for Evaluation of Label-Constrained Reachability Queries</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Lucien</surname></persName>
		</author>
		<author>
			<persName><surname>Valstar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuichi</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><surname>Yoshida</surname></persName>
		</author>
		<idno type="DOI">10.1145/3035918.3035955</idno>
		<ptr target="https://doi.org/10.1145/3035918.3035955" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data, SIGMOD Conference 2017</title>
		<meeting>the 2017 ACM International Conference on Management of Data, SIGMOD Conference 2017<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-05-14">2017. May 14-19, 2017</date>
			<biblScope unit="page" from="345" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Efficiently Answering Regular Simple Path Queries on Large Labeled Networks</title>
		<author>
			<persName><forename type="first">Sarisht</forename><surname>Wadhwa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anagh</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sayan</forename><surname>Ranu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amitabha</forename><surname>Bagchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srikanta</forename><surname>Bedathur</surname></persName>
		</author>
		<idno type="DOI">10.1145/3299869.3319882</idno>
		<ptr target="https://doi.org/10.1145/3299869.3319882" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data, SIGMOD Conference 2019</title>
		<meeting>the 2019 International Conference on Management of Data, SIGMOD Conference 2019<address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-06-30">2019. June 30 -July 5, 2019</date>
			<biblScope unit="page" from="1463" to="1480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A Survey of Algorithms for Keyword Search on Graph Data</title>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charu</forename><forename type="middle">C</forename><surname>Aggarwal</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4419-6045-0_8</idno>
		<ptr target="https://doi.org/10.1007/978-1-4419-6045-0_8" />
	</analytic>
	<monogr>
		<title level="m">Managing and Mining Graph Data</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Charu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Haixun</forename><surname>Aggarwal</surname></persName>
		</editor>
		<editor>
			<persName><surname>Wang</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="249" to="273" />
		</imprint>
	</monogr>
	<note>Advances in Database Systems</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Query Planning for Evaluating SPARQL Property Paths</title>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parke</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jarek</forename><surname>Gryz</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2882944</idno>
		<ptr target="https://doi.org/10.1145/2882903.2882944" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, SIGMOD Conference 2016</title>
		<meeting>the 2016 International Conference on Management of Data, SIGMOD Conference 2016<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06-26">2016. June 26 -July 01, 2016</date>
			<biblScope unit="page" from="1875" to="1889" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">An Efficient Parallel Keyword Search Engine on Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Yueji</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divyakant</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Anthony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuang</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2019.00038</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2019.00038" />
	</analytic>
	<monogr>
		<title level="m">35th IEEE International Conference on Data Engineering, ICDE 2019</title>
		<meeting><address><addrLine>Macao, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-04-08">2019. April 8-11, 2019</date>
			<biblScope unit="page" from="338" to="349" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
