<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Provenance-Aware Querying of Graph Databases with Datalog</title>
				<funder>
					<orgName type="full">French government</orgName>
				</funder>
				<funder ref="#_96DHa9g">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_MkbB59A">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<affiliation key="aff0">
								<orgName type="department">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">PSL University</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Inria Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<address>
									<settlement>Paris</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Provenance-Aware Querying of Graph Databases with Datalog</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">42BE211DCE6B3EDC0CCC4C8508DAA317</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Information systems â†’ Data provenance;</term>
					<term>Theory of computation â†’ Data provenance Datalog</term>
					<term>Provenance</term>
					<term>Semirings</term>
					<term>Graph Databases</term>
					<term>Dynamic Programming</term>
					<term>Transportation Networks</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We establish a translation between a formalism for dynamic programming over hypergraphs and the computation of semiringbased provenance for Datalog programs. The benefit of this translation is a new method for computing the provenance of Datalog programs for specific classes of semirings, which we apply to provenance-aware querying of graph databases. Theoretical results and practical optimizations lead to an efficient implementation using SoufflÃ©, a state-of-the-art Datalog interpreter. Experimental results on real-world data suggest this approach to be efficient in practical contexts, competing with dedicated solutions for graphs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Data provenance <ref type="bibr" target="#b2">[3]</ref> is meta-information that is kept along and tracked about data throughout its life cycle, and which is propagated to query results during query evaluation; applications of such information include traceability, explainability, or uncertainty management <ref type="bibr" target="#b20">[21]</ref>. A notion of provenance for Datalog queries was introduced by Green, Karvounarakis, and Tannen <ref type="bibr" target="#b8">[9]</ref>. Based on the algebraic structure of semirings to encode additional metainformation about query results, it extends the notion of semiring provenance for the positive fragment of the relational algebra, also introduced in <ref type="bibr" target="#b8">[9]</ref>. The full provenance of a Datalog program (i.e., the provenance associated to each derived tuple) is expressed as a system of equations over an ğœ”-continuous semiring. This forms a "computational" notion of provenance, where operations (and queries) over provenance values are permitted.</p><p>A recent line of work has adapted this provenance model for simple navigational queries (regular path queries <ref type="bibr" target="#b1">[2]</ref> or RPQs) over graph databases <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. Several provenance-aware algorithms have been proposed, and a taxonomy of semiring classes, based on their properties, has been established in <ref type="bibr" target="#b18">[19]</ref>. Those works aim at identifying, for a set of important semiring classes, the most appropriate algorithm for provenance-aware querying, enabling real-world applications.</p><p>The aim of the current work is to extend these approaches to queries that go beyond the simple class of RPQs, relying on the rich literature around Datalog provenance to provide better solutions for provenance computations over graph databases. Our objective is to obtain new effective solutions to practical scenarios (i.e., real transportation networks over large areas). In the process, we generalize the methods for provenance computation over graph databases of <ref type="bibr" target="#b18">[19]</ref> to Datalog. Our main motivation is thus is to allow new opportunities for querying graph databases in the presence of provenance information, as Datalog is significantly more expressive than RPQs. Given the fact that RPQs are expressible in Datalog, we can therefore either compose or take the union of several RPQs. Whereas RPQs only select pair of vertices, with Datalog we can go beyond binary output relations; this allows to retrieve, for instance, paths that are restricted to pass through another node.</p><p>Our contributions can be organized into three parts. We first establish a correspondence between dynamic programming over hypergraphs (as introduced in <ref type="bibr" target="#b9">[10]</ref> under the name of weighted hypergraphs) and the proof-theoretic definition of the provenance for Datalog programs. We provide both-way translations and characterize for which class of semirings the best-weight derivation in the hypergraph corresponds to the provenance of the initial Datalog program.</p><p>The translation we thus introduced permits us to obtain a version of Knuth's generalization of Dijkstra's algorithm to the grammar problem <ref type="bibr" target="#b12">[13]</ref>, adapted to the case of Datalog provenance computation. In the special setting where all hyperedges are of arity 1, we obtain the classical notion of semiring-based provenance for graph databases <ref type="bibr" target="#b17">[18]</ref>. In the general setting, the algorithm steadily generalizes to Datalog the adapted Dijkstra's algorithm from <ref type="bibr" target="#b17">[18]</ref>, under the same assumptions on the properties of the underlying semiring. Such algorithm is unlikely to be efficient as-is in practical contexts. The main issue is closely related to the inefficiency of basic Datalog evaluation: many computations of facts (provenance values) have already been deduced, leading to redundant computations. Nevertheless, we show that the semi-naÃ¯ve evaluation strategy for Datalog is also applicable in our setting. An added advantage is that it facilitates extending existing Datalog solvers to provenance annotations and their computation.</p><p>We implement our strategy by extending SoufflÃ© <ref type="bibr" target="#b10">[11]</ref>, a state-ofthe-art Datalog interpreter. We apply our solution to the computation of the provenance of various graph queries (translated into Datalog programs) on several real-world graph datasets. Experiments witness that the performance of the implementation competes with previous dedicated solutions specific to graph databases, while allowing much more expressive queries than the works of <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>: RPQs only select pairs of vertices joinable by a path whose label belongs to a given regular language. We focus our experiments on graph patterns that are combinations and/or unions of RPQs, using the expressive power of Datalog. We show that for this wider class of navigational queries, our method performs well in practice. Notably, the ratio between the running time of our approach compared to plain Datalog evaluation (not tracking the provenance) is experimentally bounded by a small constant factor. Moreover, in case of large output DB size, the average number of output tuples processed by seconds is up to a million, permitting a reasonable running time in practice for large datasets.</p><p>The paper is organized as follows. We start by introducing in Section 2 basic concepts on semirings and we recall the definition of provenance for Datalog programs. We formulate and prove in Section 3 the correspondence between weighted hypergraphs and semiring-based provenance for Datalog programs. In Section 4, we present the adapted version of Knuth's algorithm for the grammar problem and discuss theoretical aspects of its optimization. We then dive into the practical aspects of its implementation using SoufflÃ©, and present in Section 5 experimental results witnessing the efficiency of our approach for practical scenarios. We finally discuss in Section 6 the related work. For space reasons, proofs are deported to an appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>In the following, we recall basic concepts of semiring theory underlying the optimization techniques we provide in this paper. For more background on the theory and applications of semirings, examples of relevant semirings, as well as references to the literature on advanced notions of semiring theory, see <ref type="bibr" target="#b18">[19]</ref>. We mostly follow the definitions from <ref type="bibr" target="#b18">[19]</ref> and also highlight notions that occur under different names depending on the application domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Semiring).</head><p>A semiring is an algebraic structure (ğ‘†, âŠ•, âŠ—, 0, 1) where ğ‘† is some set, âŠ• and âŠ— are binary operators over ğ‘†, and 0 and 1 are elements of ğ‘†, satisfying the following axioms:</p><p>â€¢ (ğ‘†, âŠ•, 0) is a commutative monoid:</p><formula xml:id="formula_0">(ğ‘ âŠ• ğ‘) âŠ• ğ‘ = ğ‘ âŠ• (ğ‘ âŠ• ğ‘), ğ‘ âŠ• ğ‘ = ğ‘ âŠ• ğ‘, ğ‘ âŠ• 0 = 0 âŠ• ğ‘ = ğ‘; â€¢ (ğ‘†, âŠ—, 1) is a monoid: (ğ‘ âŠ—ğ‘) âŠ—ğ‘ = ğ‘ âŠ— (ğ‘ âŠ—ğ‘), 1âŠ—ğ‘ = ğ‘ âŠ— 1 = ğ‘; â€¢ âŠ— distributes over âŠ•: ğ‘ âŠ— (ğ‘ âŠ• ğ‘) = (ğ‘ âŠ— ğ‘) âŠ• (ğ‘ âŠ— ğ‘); â€¢ 0 is an annihilator for âŠ—: 0 âŠ— ğ‘ = ğ‘ âŠ— 0 = 0. A semiring is commutative if for all ğ‘, ğ‘ âˆˆ ğ‘†, ğ‘ âŠ— ğ‘ = ğ‘ âŠ— ğ‘. A semiring is idempotent if for all ğ‘ âˆˆ ğ‘†, ğ‘ âŠ• ğ‘ = ğ‘.</formula><p>For an idempotent semiring we can introduce the natural order defined by ğ‘ â©½ ğ‘ iff ğ‘ âŠ• ğ‘ = ğ‘. 1 Note that this order is compatible with the two binary operations of the semiring: for all ğ‘, ğ‘, ğ‘ âˆˆ ğ‘†, ğ‘ â©½ ğ‘ implies ğ‘ âŠ• ğ‘ â©½ ğ‘ âŠ• ğ‘ and ğ‘ âŠ— ğ‘ â©½ ğ‘ âŠ— ğ‘. This is also called the monotonicity property.</p><p>An important property is that of k-closedness <ref type="bibr" target="#b16">[17]</ref>, i.e., a semiring is ğ‘˜-closed if: âˆ€ğ‘ âˆˆ ğ‘†, ğ‘˜+1 ğ‘–=0 ğ‘ ğ‘– = ğ‘˜ ğ‘–=0 ğ‘ ğ‘– . Here, by ğ‘ ğ‘– we denote the repeated application of the âŠ— operation ğ‘– times, i.e., ğ‘ ğ‘– = ğ‘ âŠ— ğ‘ âŠ— â€¢ â€¢ â€¢ âŠ— ğ‘ ğ‘– . 0-closed semirings (i.e., those in which âˆ€ğ‘ âˆˆ 1 There are unfortunately two definitions of natural order commonly found in the literature; we use here that found in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b16">17]</ref> which matches the standard order on the tropical semiring; other works <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b18">19]</ref> define it as the reverse order. Our choice obviously has some impacts: in particular, when defining Datalog provenance, we need greatest fixpoints in lieu of the least fixpoints used in <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b14">15]</ref>. ğ‘†, 1 âŠ• ğ‘ = 1) have also been called absorptive, bounded, or simple depending on the literature. Note that any 0-closed semiring is idempotent (indeed, ğ‘ âŠ• ğ‘ = ğ‘ âŠ— ( 1 âŠ• 1) = ğ‘ âŠ— 1 = ğ‘) and therefore admits a natural order.</p><p>Huang <ref type="bibr" target="#b9">[10]</ref> introduces the notion of superiority of a semiring ğ‘† with respect to a partial order â©½, defined by: âˆ€ğ‘, ğ‘ âˆˆ ğ‘† ğ‘ â©½ ğ‘ âŠ—ğ‘, ğ‘ â©½ ğ‘ âŠ— ğ‘. The natural order satisfies this notion for 0-closed semirings: Lemma 2. Let ğ‘† be an idempotent semiring and â©½ the natural order over ğ‘†. Then ğ‘† is superior with respect to â©½ if and only if ğ‘† is 0-closed.</p><p>An easier way of understanding natural order in 0-closed semirings is to note that for any idempotent semiring ğ‘†, 0 is the greatest element (âˆ€ğ‘ âˆˆ ğ‘†, ğ‘ âŠ•0 = ğ‘ â©½ 0) while, if the semiring is also 0-closed (i.e., bounded), 1 is the smallest (âˆ€ğ‘ âˆˆ ğ‘†, 1 âŠ• ğ‘ = 1 so 1 â©½ ğ‘). Thus a bounded semiring ğ‘† verifies 1 â©½ ğ‘ â©½ 0 for all ğ‘ âˆˆ ğ‘†.</p><p>Definition 3 (ğœ”-Continuous semiring). An idempotent semiring (ğ‘†, âŠ•, âŠ—, 0, 1) is ğœ”-continuous if:</p><p>(1) (ğ‘†, â©¾) is an ğœ”-complete partial order, i.e., the infimum inf</p><formula xml:id="formula_1">ğ‘– âˆˆN</formula><p>ğ‘ ğ‘– of any infinite chain ğ‘ 0 â©¾ ğ‘ 1 â©¾ . . . exists in ğ‘†.</p><p>(2) both addition and multiplication are ğœ”-continuous in both arguments, i.e., for all ğ‘ âˆˆ ğ‘† and infinite chain</p><formula xml:id="formula_2">ğ‘ 0 â©¾ ğ‘ 1 â©¾ . . . , (ğ‘ âŠ• inf ğ‘– âˆˆN ğ‘ ğ‘– ) = inf ğ‘– âˆˆN (ğ‘ âŠ• ğ‘ ğ‘– ), (ğ‘ âŠ— inf ğ‘– âˆˆN ğ‘ ğ‘– ) = inf ğ‘– âˆˆN (ğ‘ âŠ— ğ‘ ğ‘– ), ( inf ğ‘– âˆˆN ğ‘ ğ‘– ) âŠ— ğ‘ = inf ğ‘– âˆˆN (ğ‘ ğ‘– âŠ— ğ‘).</formula><p>In such semirings we can define countable sums:</p><formula xml:id="formula_3">ğ‘› âˆˆN ğ‘ ğ‘› = inf ğ‘š âˆˆN ğ‘š ğ‘–=0 ğ‘ ğ‘– .</formula><p>A system of fixpoint equations over an ğœ”-continuous semiring ğ‘† is a finite set of equations: ğ‘‹ 1 = ğ‘“ 1 (ğ‘‹ 1 , ğ‘‹ 2 , . . . , ğ‘‹ ğ‘› ), . . . , ğ‘‹ ğ‘› = ğ‘“ ğ‘› (ğ‘‹ 1 , ğ‘‹ 2 , . . . , ğ‘‹ ğ‘› ), where ğ‘‹ 1 , . . . , ğ‘‹ ğ‘› are variables and ğ‘“ 1 , . . . ğ‘“ ğ‘› are polynomials with coefficients in ğ‘†. We extend the notion of natural order from semiring elements to tuples of semiring elements by simply considering the product order. We then have the following on solutions of a system of equations over an ğœ”-continuous semiring: Theorem 4 (Theorem 3.1 of <ref type="bibr" target="#b14">[15]</ref>). Every system of fixpoint equations X = ğ‘“ (X) over a commutative ğœ”-continuous semiring has a greatest solution gfp(ğ‘“ ) w.r.t. â©½, and gfp(ğ‘“ ) is equal to the infimum of the Kleene sequence:</p><formula xml:id="formula_4">gfp(ğ‘“ ) = inf ğ‘š âˆˆN ğ‘“ ğ‘š ( 0).</formula><p>We now recall some basics about the Datalog query language and refer to <ref type="bibr" target="#b0">[1]</ref> for more details. A Datalog rule is of the form ğ‘…( Ã¬ ğ‘¥) :-ğ‘… 1 ( Ã¬ ğ‘¥ 1 ), . . . , ğ‘… ğ‘› ( Ã¬ ğ‘¥ ğ‘› ) with ğ‘…'s representing relations of a given arity and the Ã¬ ğ‘¥'s tuples of variables of corresponding arities. Variables occurring on the left-hand side, the head of the rule, are required to occur in at least one of the atoms on the righthand side, the body of the rule. A Datalog program is a finite set of Datalog rules. We call fact a rule with an empty body and variables replaced by constants. We divide relations into extensional ones (which can only occur as head of a fact, or in rule bodies) and intensional ones (which may occur as heads of a non-fact rule). The set of extensional facts is called the extensional database (EDB). We distinguish one particular relation occurring in the head of a rule, the output predicate of the Datalog program. We refer to <ref type="bibr" target="#b0">[1]</ref> for the semantics of such a program and the notion of derivation tree. There are two ways of defining the provenance of a Datalog program ğ‘ with output predicate ğº over an ğœ”-continuous semiring. We can first base this definition on the proof-theoretic definition of standard Datalog: Definition 5 (Proof-theoretic definition for Datalog provenance <ref type="bibr" target="#b8">[9]</ref>). Let (ğ‘†, âŠ•, âŠ—, 0, 1) be a commutative ğœ”-continuous semiring and ğ‘ a Datalog program with output predicate ğ‘† and such that all extensional facts ğ‘…(ğ‘¡ â€² ) are annotated with an element of ğ‘†, denoted as prov ğ‘ ğ‘… (ğ‘¡ â€² ). Then the provenance of ğº (ğ‘¡) for ğ‘, where ğº (ğ‘¡) is in the output of ğ‘, is defined as:</p><formula xml:id="formula_5">prov ğ‘ ğº (ğ‘¡) = ğœ yields ğ‘¡ ğ‘¡ â€² âˆˆ leaves(ğœ) prov ğ‘ ğ‘… (ğ‘¡ â€² ) .</formula><p>The first sum ranges over all the derivation trees of the fact ğ‘¡ (see Figure <ref type="figure">1</ref> for examples of derivation trees), the second sum ranges over all leaves of the tree (extensional facts). This definition describes how the provenance propagates across the deduction process given an initial assignment of provenance weights to the extensional relations of ğ‘, prov ğ‘ ğ‘… . Example 6. The tropical semiring is (R + âˆª {âˆ}, min, +, âˆ, 0). It is a 0-closed (and thus idempotent) ğœ”-continuous semiring. We show in Figure <ref type="figure">1</ref> an example Datalog program (bottom right) with tropical semiring annotations on extensional edge facts, as well as the (only) two derivation trees of the fact path(Paris, London) along their weight. This witnesses that the provenance of path(Paris, London)</p><formula xml:id="formula_6">is min(1 + 0, 3) = 1.</formula><p>Since some tuples can have infinitely many derivations, the Datalog semantics of Definition 5 cannot be used as an algorithm. As pointed out in <ref type="bibr" target="#b8">[9]</ref>, it is possible instead to use a fixpoint-theoretic definition of the provenance of a Datalog query ğ‘: introduce a fresh variable for every possible intensional tuple (i.e., every possible ground atom), and produce for this variable an equation that reflects the immediate consequence operator T ğ‘ -extensional facts appearing as their semiring annotations in these equations. This yields a system of fixpoint equation ğ‘“ ğ‘ . The provenance of ğº (ğ‘¡) for ğ‘ is now simply the value of the variable corresponding to ğº (ğ‘¡) in gfp(ğ‘“ ğ‘ ).</p><p>The fixpoint-theoretic definition directly yields an algorithm, albeit a very inefficient one because of the need of generating a rule for every intensional tuple.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DATALOG PROVENANCE AND DYNAMIC PROGRAMMING OVER HYPERGRAPHS</head><p>We now show how to convert a Datalog program into a weighted hypergraph (as introduced in <ref type="bibr" target="#b9">[10]</ref>) and characterize the semirings where the best-weight derivation in the hypergraph corresponds to the provenance for the initial Datalog program, mimicking the proof-theoretic definition. We first recall basic definitions and notation related to hypergraphs.</p><p>Definition 7 (Weighted hypergraph <ref type="bibr" target="#b9">[10]</ref>). Given a semiring ğ‘†, a weighted hypergraph on ğ‘† is a pair ğ» = âŸ¨ğ‘‰ , ğ¸âŸ©, where ğ‘‰ is a finite set of vertices and ğ¸ is a finite set of hyperedges, and each element ğ‘’ âˆˆ ğ¸ is a triple ğ‘’ = âŸ¨â„(ğ‘’), T(ğ‘’), ğ‘“ ğ‘’ âŸ© with â„(ğ‘’) âˆˆ ğ‘‰ its head vertex, T(ğ‘’) âˆˆ ğ‘‰ an ordered list of tail vertices and ğ‘“ ğ‘’ a weight function from ğ‘† |T(ğ‘’) | to ğ‘†.</p><p>We note |ğ‘’ | = |T(ğ‘’)| the arity of a hyperedge. If |ğ‘’ | = 0, we say ğ‘’ is nullary and then ğ‘“ ğ‘’ () is a constant, an element of the semiring; we assume there exists at most one nullary edge for a given vertex. In that case, ğ‘£ = â„(ğ‘’) is called a source vertex and we note ğ‘“ ğ‘’ () as ğ‘“ ğ‘£ . The arity of a hypergraph is the maximum arity of any hyperedge.</p><p>The backward-star BS(ğ‘£) of a vertex ğ‘£ is the set of incoming hyperedges The notion of derivations is the hypergraph counterpart to paths in graph. We recall the definition of derivations and we define it in a way that is reminiscent of Datalog-related notions.</p><formula xml:id="formula_7">{ğ‘’ âˆˆ ğ¸ | â„(ğ‘’) = ğ‘£ }. The graph projection of a hypergraph ğ» = âŸ¨ğ‘‰ , ğ¸âŸ© is a directed graph ğº = (ğ‘‰ , ğ¸ â€² ) where ğ¸ â€² = {(ğ‘¢, ğ‘£) | âˆƒğ‘’ âˆˆ BS(ğ‘£), ğ‘¢ âˆˆ T(ğ‘’)}. A hypergraph ğ» is acyclic if its graph</formula><p>Definition 9 (Derivation in hypergraph <ref type="bibr" target="#b9">[10]</ref>). We recursively define a derivation ğ· of a vertex ğ‘£ in a hypergraph ğ» (as a pair formed of a hyperedge and a list of derivations), its size |ğ· | (a natural integer) and its weight ğ‘¤ (ğ·) (a semiring element) as follows:</p><formula xml:id="formula_8">â€¢ If ğ‘’ âˆˆ BS(ğ‘£) with |ğ‘’ | = 0, then ğ· = âŸ¨ğ‘’, âŸ¨âŸ©âŸ© is a derivation of ğ‘£, |ğ· | = 1, and ğ‘¤ (ğ·) = ğ‘“ ğ‘’ (). â€¢ If ğ‘’ âˆˆ BS(ğ‘£) with |ğ‘’ | â©¾ 0, ğ· ğ‘– is a derivation of ğ‘‡ ğ‘– (ğ‘’) for ğ‘– = 1 . . . |ğ‘’ |, then ğ· = âŸ¨ğ‘’, âŸ¨ğ· 1 â€¢ â€¢ â€¢ ğ· |ğ‘’ | âŸ©âŸ© is a derivation of ğ‘£, |ğ· | = 1 + |ğ‘’ | ğ‘–=1 |ğ· ğ‘– |, ğ‘¤ (ğ·) = ğ‘“ ğ‘’ (ğ‘¤ (ğ· 1 ), . . . , ğ‘¤ (ğ· |ğ‘’ | )</formula><p>). We note D ğ» (ğ‘£) the set of derivations of ğ‘£ in ğ» .</p><p>When modeling Datalog provenance in a semiring ğ‘† as weighted hypergraphs on ğ‘†, all non-source weight functions are bound to the âŠ— operation of the semiring. Note that, if ğ‘† is idempotent, the natural order on ğ‘† induces an ordering on derivations: ğ· â©½ ğ· â€² if ğ‘¤ (ğ·) â©½ ğ‘¤ (ğ· â€² ).</p><p>We now show that in this formalism, the Datalog provenance of an output predicate can be understood as the best-weight for the corresponding vertex in the hypergraph.</p><p>Definition 10 (Best-weight <ref type="bibr" target="#b9">[10]</ref>). The best-weight ğ›¿ ğ» (ğ‘£) of a vertex ğ‘£ of a hypergraph ğ» on a semiring (ğ‘†, âŠ•, âŠ—, 0, 1) is the weight of the best derivation of ğ‘£:</p><formula xml:id="formula_9">ğ›¿ ğ» (ğ‘£) = ğ‘“ ğ‘£ if v is a source vertex;</formula><p>ğ· âˆˆ D ğ» (ğ‘£) ğ‘¤ (ğ·) otherwise. The best-weight generally requires additional properties of either the hypergraph or the semiring to be well-defined. Acyclicity for the hypergraph is a sufficient condition. Existence of an infinitary summation operator in the semiring extending âŠ•, guaranteed in ğœ”-continuous semirings, is also a sufficient condition. To guarantee semantics compatible with the intuitive meaning of provenance, a more restrictive sufficient condition is for the semiring to be a ğ‘-complete star-semiring <ref type="bibr" target="#b13">[14]</ref>, see <ref type="bibr" target="#b18">[19]</ref> for details.</p><p>We can now show that Datalog provenance can be computed through the formalism of weighted hypergraphs. Let us start with a lemma exhibiting a one-to-one mapping between derivations in the hypergraph and proofs in Datalog. Lemma 11. For any Datalog query ğ‘ and grounding of an atom ğ‘£ of ğ‘, there is a bijection between D ğ»ğ‘ (ğ‘£) and {ğœ | ğœ yields ğ‘£ }.</p><p>We then show that the weight of each derivation of a tuple is equal to the corresponding proof tree weight in Datalog. Lemma 12. For any Datalog query ğ‘ and grounding of an atom ğ‘£ of ğ‘, for any derivation ğ· of ğ‘£ in ğ» ğ‘ we have</p><formula xml:id="formula_10">ğ‘¤ (ğ·) = ğ‘¡ â€² âˆˆ ğ‘™ğ‘’ğ‘ğ‘£ğ‘’ğ‘  (ğœ ğ· ) prov ğ‘ ğ‘… (ğ‘¡ â€² )</formula><p>where ğœ ğ· is the proof tree corresponding to ğ· in the bijection given by Lemma 11.</p><p>Finally, we obtain: Theorem 13. Let ğ‘¡ be a tuple of a Datalog program ğ‘ with output predicate ğº and ğ» ğ‘ its hypergraph representation, then prov ğ‘ ğº (ğ‘¡) = ğ›¿ ğ» ğ‘ (ğº (ğ‘¡)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BEST-FIRST METHOD</head><p>Knuth <ref type="bibr" target="#b12">[13]</ref> generalized the Dijkstra algorithm to what he calls the grammar problem (i.e., finding the best-weight derivation from a given non-terminal, where each terminal has a specific weight and each rule comes with an associated weight function). This has been identified as corresponding to the search problem in a monotonic superior hypergraph -i.e., for each ğ‘’ âˆˆ ğ» , ğ‘“ ğ‘’ is monotone and superior in each argument (see Table <ref type="table">3</ref> in <ref type="bibr" target="#b9">[10]</ref>). We showed in Lemma 2 that superiority corresponds to 0-closedness in semirings with natural orders. The definition of the grammar problem assumes a total order on weights as the weights are real numbers. In the special case where all hyperedges are of arity 1 (and all weight functions bound to âŠ—), we obtain the classical notion of semiringbased provenance for graph databases <ref type="bibr" target="#b17">[18]</ref>. Thus, Knuth's algorithm can be seen as a generalization to hypergraphs (and therefore, by the results of the previous section, to Datalog provenance computation) of the modified Dijkstra algorithm from <ref type="bibr" target="#b17">[18]</ref>, working on 0-closed totally-ordered semirings, which are generalizations of the tropical semiring.</p><p>Optimized version of Best-First method. In the original paper of Knuth <ref type="bibr" target="#b12">[13]</ref>, the question of efficient construction of the set of candidate facts for the extraction of the minimal-valued fact is not dealt with. A lot of redundant work may be carried out if the implementation is not carefully designed.</p><p>In the following, we show how to obtain a ready-to-be-implemented version incorporating ideas from the semi-naÃ¯ve evaluation of Datalog programs. Semi-naÃ¯ve evaluation of Datalog, as described in [1, <ref type="bibr">Chapter 13</ref>] introduces a number of ideas aiming at improving the efficiency of the naÃ¯ve Datalog evaluation method; we show how to leverage them in our setting.</p><p>The naÃ¯ve evaluation of a Datalog program ğ‘ processes iteratively, applying at each step the consequence operator T ğ‘ . Many redundant derivations are computed, leading to practical inefficiency. The semi-naÃ¯ve evaluation addresses this problem by considering only facts derived using at least one new fact found at the previous step. Note, however, that while many new facts can be found at one step of the semi-naÃ¯ve evaluation, only one is to be added by the Best-First method to respect the â©½-minimality ordering of added facts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Basic semi-naÃ¯ve version of Best-First method for Datalog provenance</head><p>Require: Datalog query ğ‘, EDB ğ· with provenance indications over a 0-closed totally-ordered semiring ğ‘†. Ensure: full Datalog provenance for the IDB of ğ‘.</p><p>1: function Relax(ğ‘Ÿ 0 ( Ã¬ ğ‘¥ 0 ), ğ‘†)</p><formula xml:id="formula_11">2:</formula><p>for each instantiation of a rule Relax(ğ‘Ÿ ( Ã¬ ğ‘¥), ğ¼ \ ğ‘Ÿ ( Ã¬ ğ‘¥)) 13: return ğœˆ This algorithm starts by initializing the priority queue with IDB facts that are derivable from EDB facts. Then, at each step, the minimum valued-fact is added, and only derivations using this new fact are computed to update the value of the facts in ğ¼ . This algorithm stops whenever: 1. the maximal value is reached for a candidate fact, or 2. the list is empty -the minimal value of the list is by default the maximal value of the semiring. Theorem 14. Algorithm 1 computes the full Datalog provenance for 0-closed totally-ordered semirings.</p><formula xml:id="formula_12">ğ‘Ÿ ( Ã¬ ğ‘¥) â† ğ‘Ÿ 1 ( Ã¬<label>ğ‘¥</label></formula><p>Precedence graph. The structure of the Datalog program can be analysed to provide clues about the predicates to focus on. Following <ref type="bibr" target="#b0">[1]</ref>, we introduce the notion of precedence graph ğº ğ‘ƒ of a Datalog program ğ‘ƒ. The nodes are the IDB predicates and the edges are pairs of IDB predicates (ğ‘…, ğ‘… â€² ) where ğ‘… â€² occurs at the head of a rule of ğ‘ƒ with ğ‘… belonging to the tail. ğ‘ƒ is a recursive program if ğº ğ‘ƒ has a directed cycle. Two predicates ğ‘… and ğ‘… â€² are mutually recursive if ğ‘… = ğ‘… â€² or ğ‘… and ğ‘… â€² participate in the same cycle of ğº ğ‘ƒ . This defines equivalence classes. Following a topological ordering on the equivalence classes, Algorithm 1 is sequentially applied to compute the IDB predicates in the current equivalence class, considering previous equivalence classes as EDB predicates. SoufflÃ© natively supports this optimization.</p><p>Generalization to distributive lattices. In <ref type="bibr" target="#b18">[19]</ref>, a new algorithm was introduced for single-source provenance in graph databases over 0-closed multiplicatively idempotent semirings (equivalent to distributive lattices). That method is relevant for semirings that are 0-closed but for which Dijkstra's algorithm is not directly applicable as the semiring is not totally ordered. A similar gap also appears when we consider provenance over Datalog queries (see <ref type="bibr">Section 6)</ref>. Thus, we show how to apply the method from <ref type="bibr" target="#b18">[19]</ref> for computing provenance for Datalog queries over distributive lattices. We provide a brief review of the key ideas presented in <ref type="bibr" target="#b18">[19]</ref>. Any element of a distributive lattice is decomposable into a product of join-irreducible elements of the lattice, and there exists an embedding of the distributive lattice into a chain decomposition of its join-irreducible elements. This ensures we can 1) work on a totally ordered environment and apply algorithms that require total ordering over the elements, 2) independently compute partial provenance annotations for each dimension to form the final provenance annotation. Given ğ‘š the number of dimensions in the decomposition, our solution (described in Algorithm 2) performs ğ‘š launches of the Best-First method and thus, roughly has a cost increased by a factor ğ‘š.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION AND EXPERIMENTS</head><p>In numerous application domains, Datalog is used as a domain specific language (DSL) to express logical specifications for static program analysis. A formal specification, written as a declarative Datalog program is usually translated into an efficient imperative implementation by a synthesizer. This process simplifies the development of program analysis compared to hand-crafted solutions (highly optimized C++ applications specialized in enforcing a fixed set of specifications). SoufflÃ© <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b19">20]</ref> has been introduced to provide efficient synthesis of Datalog specifications to executable C++ programs, competing with state-of-the-art handcrafted code for program analysis. The inner workings of SoufflÃ© were of interest to our work; the algorithm implementations are similar to the evaluation strategy followed by the Best-First method we introduced here. We present a brief overview of the architecture of SoufflÃ© and discuss how we extended it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Architecture and implementation.</head><p>Following what is described in <ref type="bibr" target="#b10">[11]</ref>, an input datalog program ğ‘ goes through a staged specialization hierarchy. After parsing, the first stage of SoufflÃ© specializes the semi-naÃ¯ve evaluation strategy applied to ğ‘, yielding a relational algebra machine program (RAM). Such a program consists in basic relational algebra operations enriched with I/O operators and fix-point computations. As a final step, the RAM program is finally either interpreted or compiled into an executable. For this work, we have only used the interpreter. Our code was inserted in two different stages of SoufflÃ©: a new translation strategy from the parsed program to the RAM program, a priority queue, replacing the code in charge of adding at run-time the tuples to the relations. .decl edge(s:number, t:number[, @prov:semiring value]) 2: .decl path(s:number, t:number[, @prov:semiring value]) 3: .input edge .output path 4: path(x, y) :-edge(x, y). 5: path(x, y) :-path(x, z), edge(z, y). We showcase the result of our translation strategy in Algorithms 4 and 5 for a Datalog query computing the transitive closure of a graph; this program is given in Algorithm 3 in its SoufflÃ© syntax. Algorithm 4 presents the corresponding SoufflÃ© RAM program resulting from applying the semi-naÃ¯ve evaluation strategy and Algorithm 5 our modification to the RAM program to provide provenance annotation via the Best-First strategy and use the priority queue pq for provenance computation. The âŠ¥ notation corresponds to a wildcard. Importantly, modifying directly at the RAM level of SoufflÃ© allows us to benefit of all implemented optimizations.   for t0 in edge: update (t0.0, t0.1, t0.prov) in path 3:</p><p>for t0 in path: add (t0.0, t0.1, t0.prov) in ğ›¿path if pq is empty then exit Experiments. Our implementation was tested on an Intel Xeon E5-2650 computer with 176 GB of RAM. The source code will be made available once anonymity requirements are removed.</p><p>To translate querying over graphs into Datalog query evaluation, the graph structure has been encoded into an EDB with one binary predicate edge encoding the edges, and with edge notations depending on the provenance semiring we chose. We run the transitive closure Datalog program outlined in Algorithm 3. We use the same datasets as those used in <ref type="bibr" target="#b18">[19]</ref>, see <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19]</ref> for their description and where to download them. We provide in Figure <ref type="figure" target="#fig_1">2</ref> a comparison between the Best-First method introduced here (SoufflÃ©-prov), the plain SoufflÃ© without provenance computation, and a previous provenance computation algorithm from <ref type="bibr" target="#b18">[19]</ref> computing all-pairs shortest-distances over graph databases (the NodeElimination algorithm, with a choice of node to eliminate based on its id or its degree), in the tropical semiring. Similarly, in Figure <ref type="figure" target="#fig_2">3</ref>, we compare with previous solutions for single-source shortest-distances, in the same semiring, in particular the adaptation of the Dijkstra algorithm of <ref type="bibr" target="#b18">[19]</ref>, and, for comparison purposes, a bread-first-search (Bfs) algorithm that simply navigates the graph from the source node but does not compute provenance.</p><p>The main focus of this work was to provide an effective Datalog based solution for all-pairs provenance in graph databases. For the all-pairs problem, depending on the dataset, (see, e.g., Yeast), SoufflÃ©-Prov is significantly faster than the previous best known algorithm, NodeElimination. Unsurprisingly, BFS and Dijkstra perform respectively better than SoufflÃ© and SoufflÃ©-prov in the single-source context. What favors both graph algorithms strongly is the fact that they reduce redundant computation: the algorithms abort whenever the target vertex has been reached. SoufflÃ©-prov performs between 1 and 2 orders of magnitude faster than Mohri <ref type="bibr" target="#b16">[17]</ref> -an algorithm designed for single-source provenance on ğ‘˜closed semirings. This fact highlights the potential of adapting the best-first method to also handle ğ‘˜-closed semirings.</p><p>Previous work <ref type="bibr" target="#b18">[19]</ref> addressing provenance computation for graph databases was restricted to RPQs. We now turn to evaluating this approach for more intricate graph patterns. Patterns considered are combinations and/or unions of RPQs. The output is moreover not restricted to pairs, but can be of any arbitrary arity. For instance, this allows retrieval of intermediate nodes on a path when computing graph reachability. On the same datasets, we label their edges with two distinct labels, ğ‘ and ğ‘, in an uniform random manner. After this process, some edges have disappeared (neither labeled with ğ‘ nor ğ‘), some appear two times (labeled with ğ‘ and ğ‘, with different weights), or are only associated to one label. The final size of the modified datasets did not change significantly. Table <ref type="table" target="#tab_3">1</ref> provides a summary of the experiments we conducted over three distinct patterns ğ‘ 1 , ğ‘ 2 , and ğ‘ 3 , described in the following. Pattern ğ‘ 1 (ğ‘¥, ğ‘¦, ğ‘§) :-ğ‘… ğ‘ (ğ‘¥, ğ‘¦), ğ‘… ğ‘ + (ğ‘¦, ğ‘§), ğ‘… ğ‘ (ğ‘§, ğ‘¥) selects triplets of vertices that are triangles in the graph, with one side being a ğ‘ path of arbitrary length. Pattern ğ‘ 2 (ğ‘¤, ğ‘¥, ğ‘¦, ğ‘§) :-ğ‘… ğ‘ + (ğ‘¤, ğ‘¥), ğ‘… ğ‘ + (ğ‘¥, ğ‘¦), ğ‘… ğ‘ + (ğ‘¦, ğ‘§) selects quadruplets of vertices with two hops, and pattern ğ‘ 3 (ğ‘¤, ğ‘¥, ğ‘¦, ğ‘§) :-ğ‘… ğ‘ + (ğ‘¤, ğ‘¥), ğ‘… ğ‘ (ğ‘¥, ğ‘¦), ğ‘… ğ‘ + (ğ‘¦, ğ‘§) is a slight variation of ğ‘ 2 . We perform the same experiments as for the reachability queries before, and we indicate the ratio between computation time with or without provenance tracking. The results show that the overhead induced by our provenance approach stays within a constant factor, roughly between 2 and 4, depending on the dataset and pattern. Finally, as observed in the Yeast dataset, the chosen pattern can strongly impact the output DB size: almost negligible having around 100 tuples for pattern ğ‘ 1 , or extremely large having 19 million tuples for pattern ğ‘ 2 . In order to provide a meaningful comparison, we also measure the throughput, consisting in the average number of output tuples processed per second. For smaller output DB sizes, this measure is less relevant, as the fixed costs of running SoufflÃ©prov dominate the overall running time. Overall, these results are promising, as our method has the potential to process 1M tuples per second when the query output is large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK</head><p>With respect to Datalog provenance, it has been shown in <ref type="bibr" target="#b5">[6]</ref> that, for a Datalog program having ğ‘› candidate IDB tuples, a circuit for representing Datalog provenance in the semiring Sorp(ğ‘‹ ) (the most general absorptive semiring) only needs ğ‘› + 1 layers. For binary relations, e.g., representing the edge relation of a graph, this construction is at least quadratic in the number of vertices, thus not practically applicable for the graphs we analyzed in our experiments. Similarly, in <ref type="bibr" target="#b6">[7]</ref>, absorptive semirings (i.e., 0-closed semirings) have the property that derivation trees of size â©¾ ğ‘› are "pumpable" (they do not contribute to the final result). A concrete implementation <ref type="bibr" target="#b7">[8]</ref> computes the provenance for commutative and idempotent semirings using ğ‘› Newton iterations.</p><p>Fairly recently, <ref type="bibr" target="#b11">[12]</ref> introduced POPS (Partially Ordered, Pre-Semiring), a structure decoupling the order on which the fixed-point is computed from the semiring structure. Complex and recursive computations over vectors, matrices, tensors are now expressible using this framework. The study also generalized the semi-naÃ¯ve method from plain Datalog evaluation to idempotent semirings (aka dioids). In comparison, our method is restricted to semirings that are totally ordered (a subclass of distributive dioids<ref type="foot" target="#foot_0">2</ref> ), leveraging the invariant that once a fact is first labeled with a provenance value, we are certain it is the correct one.</p><p>In cases where keeping the full provenance of a program (howprovenance) is still prohibitively large, <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> propose to select only a relevant subset of such trees using selection criteria based on tree patterns and ranking over rules and facts occurring in the derivation. First, given a Datalog program ğ‘ƒ and a pattern ğ‘, an offline instrumentation is performed, leading to an instrumented program ğ‘ƒ ğ‘ . Then, given any database ğ·, an efficient algorithm can be used to retrieve only the top-ğ‘˜ best derivation trees for ğ‘ƒ ğ‘ (ğ·). The top-1 algorithm of the study is closely related to our solution, but does not mention the use of a priority queue nor does it take into account the optimization provided by the semi-naÃ¯ve evaluation strategy we describe in Section 4.</p><p>Our solution can be seen as a hybrid of the ideas introduced in <ref type="bibr" target="#b11">[12]</ref> and <ref type="bibr" target="#b4">[5]</ref>. We generalize the semi-naÃ¯ve evaluation to a specific class of semirings in order to achieve a more efficient algorithm, one that can be used in practical real-world scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>In this work, we developed a novel method for Datalog provenance computation based on the link between dynamic programming over hypergraphs and the proof structure of provenance of Datalog programs. We introduced Knuth's algorithm for computing the provenance, and optimized it for practical use. We showed its feasibility by providing an implementation on top of SoufflÃ© and tested it on several graph databases and matching patterns.</p><p>We proved in this paper that optimization methods for graph provenance naturally extend to Datalog provenance, for certain classes of semirings playing a major role in practical applications. The previous work targeting provenance computations for graph databases in the framework of <ref type="bibr" target="#b17">[18]</ref> and <ref type="bibr" target="#b18">[19]</ref> only considered RPQs, which are a strict subset of the expressive capabilities of Datalog. We thus have extended the supported set of queries for provenanceaware interrogation of graph databases, maintaining the practical efficiency of the approach. The theoretical complexity of the introduced method is not fully understood yet; we plan to address this in future work.</p><p>The internals of SoufflÃ©, targeting the inflationary computation of the fixed-point operator lack support for updating tuples. We conjecture we could mitigate the overhead induced by provenance computations within SoufflÃ©-prov by adding primitives in their data structures. What remains to be established is to what extent these data structures <ref type="bibr" target="#b10">[11]</ref> could be extended to handle updates, without reducing the efficiency of SoufflÃ©'s current set of operators.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 Figure 1 :</head><label>21</label><figDesc>Figure 1: Derivation trees along their weights for the fact path(Paris, London) using the transitive closure Datalog program over the tropical semiring with an EDB containing 3 facts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 2</head><label>2</label><figDesc>Generalized Best-first method for Datalog provenance Require: ğ‘ a Datalog query with provenance indication over a 0-closed multiplicatively idempotent semiring ğ‘†. Ensure: full Datalog provenance for the IDB of ğ‘. 1: for each EDB fact ğ‘… ( Ã¬ ğ‘¥): Decompose(ğ‘… ( Ã¬ ğ‘¥)) 2: for each dimension ğ‘– : ğœˆ ğ‘– â† Best-first(ğ‘, ğ‘–) 3: return Recompose(ğœˆ 1 , . . . , ğœˆ ğ‘› )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 3</head><label>3</label><figDesc>Input Datalog program computing the transitive closure (SoufflÃ© syntax) 1:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 4 1 :</head><label>41</label><figDesc>Corresponding SoufflÃ© RAM program for Algorithm 3 if Â¬(edge = âˆ…) then 2: for t0 in edge do 3: add (t0.0, t0.1) in path 4: add (t0.0, t0.1) in ğ›¿path 5: loop 6: if Â¬(ğ›¿path = âˆ…) âˆ§ Â¬(edge = âˆ…) then 7: for t0 in ğ›¿path do 8: for t1 in edge on index t1.0 = t0.1 do 9: if Â¬(t0.0, t0.1) âˆˆ path then 10: add (t0.0, t0.1) in path' 11: if path' = âˆ… then exit 12: for t0 in path': add (t0.0, t0.1) in path 13: swap ğ›¿path with path' 14:clear path</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Comparison between algorithms for single-source shortest-distances (tropical semiring).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>4 : loop 5 : 6 :t0 in ğ›¿path do 7 :</head><label>4567</label><figDesc>if Â¬(ğ›¿path = âˆ…) âˆ§ Â¬(edge = âˆ…) then for for t1 in edge on index t1.0 = t0.1 do 8:if Â¬(t0.0, t1.1, âŠ¥) âˆˆ path then 9: update (t0.0, t0.1, t0.prov âŠ— t1.prov) in pq 10:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>projection ğº is acyclic; then a topological ordering of ğ» is an ordering of ğ‘‰ that is a topological ordering of ğº.Definition 8 (Hypergraph representation of a Datalog program).Given a Datalog program ğ‘ described with a set of rules {ğ‘ 1 , . . . , ğ‘ ğ‘› } and the semiring ğ‘† used for annotations, we define the weighted hypergraph representation of ğ‘ as ğ» ğ‘ = âŸ¨ğ‘‰ ğ‘ , ğ¸ ğ‘ âŸ© with ğ‘‰ ğ‘ being all ground atoms and, for each instantiation of a rule ğ‘¡ ( Ã¬ ğ‘¥) â† ğ‘Ÿ</figDesc><table><row><cell>With these definitions in place, we can encode a Datalog pro-</cell></row><row><cell>gram with semiring annotations as a weighted hypergraph in a</cell></row><row><cell>straightforward manner:</cell></row></table><note><p>1 ( Ã¬ ğ‘¥ 1 ), . . . , ğ‘Ÿ ğ‘› ( Ã¬ ğ‘¥ ğ‘› ), a corresponding edge âŸ¨ğ‘¡ ( Ã¬ ğ‘¥), (ğ‘Ÿ 1 ( Ã¬ ğ‘¥ 1 ), . . . , ğ‘Ÿ ğ‘› ( Ã¬ ğ‘¥ ğ‘› )), âŠ—âŸ©. For a fact ğ‘…( Ã¬ ğ‘¥) âˆˆ EDB(ğ‘) we add a nullary edge ğ‘’ with â„(ğ‘’) = ğ‘…( Ã¬ ğ‘¥) and ğ‘“ ğ‘’ = prov ğ‘ ğ‘… ( Ã¬ ğ‘¥).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Computation times (in seconds), provenance overhead ratio, size of the output DB (million tuples), and throughput (million tuples/second), for a selection of graph patterns.</figDesc><table><row><cell></cell><cell></cell><cell cols="2">SoufflÃ©</cell><cell></cell><cell></cell><cell cols="2">SoufflÃ©-prov</cell><cell></cell><cell></cell><cell></cell><cell>Ratio</cell><cell></cell><cell></cell><cell cols="2">Output DB size</cell><cell></cell><cell></cell><cell cols="2">Throughput</cell><cell></cell></row><row><cell>Dataset</cell><cell>ğ‘Ÿ</cell><cell>ğ‘ 1</cell><cell>ğ‘ 2</cell><cell>ğ‘</cell><cell>ğ‘Ÿ</cell><cell>ğ‘ 1</cell><cell>ğ‘ 2</cell><cell>ğ‘ 3</cell><cell>ğ‘Ÿ</cell><cell>ğ‘ 1</cell><cell>ğ‘ 2</cell><cell>ğ‘ 3</cell><cell>ğ‘Ÿ</cell><cell>ğ‘ 1</cell><cell>ğ‘ 2</cell><cell>ğ‘ 3</cell><cell>ğ‘Ÿ</cell><cell>ğ‘ 1</cell><cell>ğ‘ 2</cell><cell>ğ‘ 3</cell></row><row><cell>Rome99</cell><cell cols="2">14.2 .068</cell><cell>6.45</cell><cell>.556</cell><cell>52.2</cell><cell>.134</cell><cell>20.1</cell><cell>1.82</cell><cell cols="12">3.68 1.97 3.11 3.26 1.12 .005 16.5 1.31 .792 .047 .820 .718</cell></row><row><cell cols="3">PowerGrid .079 .011</cell><cell>.028</cell><cell>.021</cell><cell>.202</cell><cell>.019</cell><cell>.050</cell><cell>.035</cell><cell cols="5">2.56 1.45 1.78 1.67 .044</cell><cell>0</cell><cell cols="6">.006 .004 .556 n/a .130 .119</cell></row><row><cell>Yeast</cell><cell cols="2">.577 .131</cell><cell>7.65</cell><cell>1.30</cell><cell>1.88</cell><cell>.264</cell><cell>25.2</cell><cell>3.73</cell><cell cols="5">3.26 2.02 3.56 2.87 .487</cell><cell>ğœ–</cell><cell cols="6">19.9 3.02 .844 n/a .789 .808</cell></row><row><cell>Stif</cell><cell>491</cell><cell cols="4">50.6 oom oom 2081</cell><cell>141</cell><cell cols="5">oom oom 4.24 2.79 n/a</cell><cell>n/a</cell><cell>313</cell><cell cols="2">.068 n/a</cell><cell cols="2">n/a .151</cell><cell>ğœ–</cell><cell>n/a</cell><cell>n/a</cell></row><row><cell cols="10">Algorithm 5 Modification of RAM program of Algorithm 4 to</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">implement Best-First strategy</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">1: if Â¬(edge = âˆ…) then</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>2:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>12 :</head><label>12</label><figDesc>add pq.top() in pq.top().relation and in pq.top().ğ›¿relation</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Distributive dioids are POPS structures over a distributive lattice being the natural order of the dioid.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This work has been funded by the <rs type="funder">French government</rs> under management of <rs type="funder">Agence Nationale de la Recherche</rs> as part of the "<rs type="programName">Investissements d'avenir" program</rs>, reference <rs type="grantNumber">ANR-19-P3IA-0001</rs> (<rs type="grantNumber">PR-AIRIE 3IA</rs> <rs type="projectName">Institute</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_96DHa9g">
					<idno type="grant-number">ANR-19-P3IA-0001</idno>
					<orgName type="program" subtype="full">Investissements d&apos;avenir&quot; program</orgName>
				</org>
				<org type="funded-project" xml:id="_MkbB59A">
					<idno type="grant-number">PR-AIRIE 3IA</idno>
					<orgName type="project" subtype="full">Institute</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A PROOFS FOR SECTION 2 (BACKGROUND)</head><p>Lemma 2. Let ğ‘† be an idempotent semiring and â©½ the natural order over ğ‘†. Then ğ‘† is superior with respect to â©½ if and only if ğ‘† is 0-closed.</p><p>Proof. First assume ğ‘† superior with respect to â©½. Then for any ğ‘, 1 â©½ 1 âŠ— ğ‘ = ğ‘, which means that 1 + ğ‘ = 1, i.e., ğ‘† is 0-closed. Now assume ğ‘† 0-closed. Since ğ‘ âŠ• ğ‘ âŠ—ğ‘ = ğ‘ âŠ— ( 1 âŠ• ğ‘) = ğ‘, we have: ğ‘ â©½ ğ‘ âŠ— ğ‘, and similarly for ğ‘ â©½ ğ‘ âŠ— ğ‘. Thus ğ‘† is superior with respect to â©½. â–¡ B PROOFS FOR SECTION 3 (DATALOG PROVENANCE AND DYNAMIC PROGRAMMING OVER HYPERGRAPHS)</p><p>Lemma 11. For any Datalog query ğ‘ and grounding of an atom ğ‘£ of ğ‘, there is a bijection between D ğ»ğ‘ (ğ‘£) and {ğœ | ğœ yields ğ‘£ }.</p><p>Proof. By definition of ğ» ğ‘ each instantiation of a rule corresponds to a unique hyperedge. Then, we can inductively construct for a given derivation ğ· its associated (unique) Datalog proof tree ğœ ğ· :</p><p>â€¢ </p><p>where ğœ ğ· is the proof tree corresponding to ğ· in the bijection given by Lemma 11.</p><p>Proof. By induction on the size of the derivation ğ·: Proof. We show the algorithm verifies the following invariant: whenever a tuple is added to ğ¼ in Line 11, it has optimal value. This implies that ğ¼ is populated in increasing order: each new derivation computed in the Relax() procedure only updates the priority queues with values greater than the value of the tuple relaxed (by superiority of âŠ—).</p><p>Assume by contradiction that some output tuples are not correctly labeled and take such a minimal tuple ğœˆ = ğ‘Ÿ ( Ã¬ ğ‘¥). At the moment where ğœˆ is extracted with value ğ‘› let us consider an optimal derivation path of ğœˆ that leads to the optimum value ğ‘œğ‘ğ‘¡ &lt; ğ‘›. By superiority each tuple occurring in the tail of the rule has value less than ğ‘œğ‘ğ‘¡. Thus a tuple occurring in the tail is either wrong-valued or not present in ğ¼ at the moment where ğœˆ is found. In both cases and because tuples are added to ğ¼ in increasing order we obtain a new minimal tuple incorrectly labeled by the algorithm, contradicting the hypothesis. â–¡</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Querying graph databases</title>
		<author>
			<persName><forename type="first">Pablo</forename><surname>BarcelÃ³</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Provenance in databases: Why, how, and where. Found</title>
		<author>
			<persName><forename type="first">James</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laura</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Chiew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tan</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends Databases</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="379" to="474" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">selP: selective tracking and presentation of data provenance</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Gilad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Moskovitch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1484" to="1487" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient provenance tracking for datalog using top-k queries</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Gilad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuval</forename><surname>Moskovitch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="245" to="269" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Circuits for Datalog Provenance</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="201" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Solving fixed-point equations by derivation tree analysis</title>
		<author>
			<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Luttenberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CALCO</title>
		<imprint>
			<biblScope unit="page" from="19" to="35" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fpsolve: A generic solver for fixpoint equations over semirings</title>
		<author>
			<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Luttenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maximilian</forename><surname>Schlund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIAA</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grigoris</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>PODS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Advanced dynamic programming in semiring and hypergraph frameworks</title>
		<author>
			<persName><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COLING</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SoufflÃ©: On synthesis of program analyzers</title>
		<author>
			<persName><forename type="first">Herbert</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernhard</forename><surname>Scholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavle</forename><surname>SubotiÄ‡</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="422" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Convergence of datalog over (pre-) semirings</title>
		<author>
			<persName><forename type="first">Mahmoud</forename><surname>Abo Khamis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hung</forename><forename type="middle">Q</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yisu</forename><surname>Remy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename></persName>
		</author>
		<idno>CoRR, abs/2105.14435</idno>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A generalization of Dijkstra&apos;s algorithm</title>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Monoides et semi-anneaux complets</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Krob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semigroup Forum</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="323" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Semirings and formal power series: Their relevance to formal languages and automata</title>
		<author>
			<persName><forename type="first">Werner</forename><surname>Kuich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Formal Languages</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="609" to="677" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An Experimental Study of the Treewidth of Real-World Graph Data</title>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suraj</forename><surname>Jog</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Semiring frameworks and algorithms for shortest-distance problems</title>
		<author>
			<persName><forename type="first">Mehryar</forename><surname>Mohri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Lang. Comb</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="321" to="350" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Semiring provenance over graph databases</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TaPP</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Provenance-based algorithms for rich queries over graph databases</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="73" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On fast large-scale program analysis in datalog</title>
		<author>
			<persName><forename type="first">Bernhard</forename><surname>Scholz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Herbert</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavle</forename><surname>SubotiÄ‡</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Till</forename><surname>Westmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CC</title>
		<imprint>
			<biblScope unit="page" from="196" to="206" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Provenance in databases: Principles and applications</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reasoning Web</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="104" to="109" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
