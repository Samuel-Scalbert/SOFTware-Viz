<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Revisiting Semiring Provenance for Datalog</title>
				<funder ref="#_VYVpUmp">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
							<email>camille.bourgaux@ens.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
							<email>pierre.bourhis@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">CRIStAL</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">University of Lille</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Liat</forename><surname>Peterfreund</surname></persName>
							<email>liat.peterfreund@univ-eiffel.fr</email>
							<affiliation key="aff2">
								<orgName type="laboratory">LIGM</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">Université Gustave Eiffel</orgName>
								<orgName type="institution" key="instit3">ENPC</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
							<email>michael.thomazo@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Revisiting Semiring Provenance for Datalog</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">12FF0757D2D4AFFDF623D83952B8E372</idno>
					<idno type="DOI">10.24963/kr.2022/10</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Data provenance consists in bookkeeping meta information during query evaluation, in order to enrich query results with their trust level, likelihood, evaluation cost, and more. The framework of semiring provenance abstracts from the specific kind of meta information that annotates the data. While the definition of semiring provenance is uncontroversial for unions of conjunctive queries, the picture is less clear for Datalog. Indeed, the original definition might include infinite computations, and is not consistent with other proposals for Datalog semantics over annotated data. In this work, we propose and investigate several provenance semantics, based on different approaches for defining classical Datalog semantics. We study the relationship between these semantics, and introduce properties that allow us to analyze and compare them.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Datalog is a rule language widely studied both in the database community, where it is seen as a query language, and in the KR community, as an ontology language.</p><p>In relational databases, the framework of semiring provenance was introduced to generalize computations over annotated databases, e.g., the semantics of probabilistic databases <ref type="bibr" target="#b22">(Senellart 2017)</ref>, the bag semantics, lineage or why-provenance <ref type="bibr" target="#b8">(Cheney, Chiticariu, and Tan 2009)</ref>. In this framework, the semantics of positive relational algebra queries over databases annotated with elements of any commutative semiring is inductively defined on the structure of the query <ref type="bibr" target="#b15">(Green, Karvounarakis, and Tannen 2007;</ref><ref type="bibr" target="#b14">Green and Tannen 2017)</ref>. Provenance semirings are expressions (such as polynomials) built from variables associated to each tuple of the database <ref type="bibr" target="#b16">(Green 2009)</ref>. A provenance expression provides a general representation of how tuples have been used to derive a query result, and can be faithfully evaluated in any semiring in which the considered provenance semiring can be homomorphically embedded.</p><p>Semiring provenance has also been studied for Datalog queries, for which it was defined based on the set of all derivation trees for the query <ref type="bibr" target="#b15">(Green, Karvounarakis, and Tannen 2007;</ref><ref type="bibr" target="#b11">Deutch et al. 2014;</ref><ref type="bibr" target="#b12">Deutch, Gilad, and Moskovitch 2018)</ref>. However, this definition seems less axiomatic than in the case of relational databases. Indeed, there may be infinitely many derivation trees, leading to infinite provenance expressions, while Datalog programs have finite models that can be computed efficiently <ref type="bibr" target="#b0">(Abiteboul, Hull, and Vianu 1995)</ref>. A consequence is that this definition is valid only for a restricted class of semirings, namely ω-continuous. Recently, <ref type="bibr" target="#b10">Dannert et al. (2021)</ref> restrict the semiring even further by considering fully-chain complete semirings in order to extend provenance definition to logical languages featuring negation and fixed-point. Even if numerous useful semirings are ω-continuous, or can be extended to a such semiring, infinite provenance expressions may be considered unintuitive in some cases. Consider, for example, the counting semiring (i.e., natural numbers with standard operations) for which provenance of positive relational algebra queries corresponds to their bag semantics. This semiring can be extended to an ω-continuous one by adding ∞ to the natural numbers, hence providing a way to capture the bag semantics for Datalog queries <ref type="bibr" target="#b18">(Mumick, Pirahesh, and Ramakrishnan 1990;</ref><ref type="bibr" target="#b15">Green, Karvounarakis, and Tannen 2007)</ref>. However, query answers having infinite multiplicities may not seem very natural or informative. Moreover, alternative bag semantics for languages close to Datalog have been defined, and would not lead to such infinite multiplicities when applied to Datalog. This is in particular the case of the bag semantics for ontology-based data access <ref type="bibr" target="#b20">(Nikolaou et al. 2017;</ref><ref type="bibr" target="#b21">Nikolaou et al. 2019)</ref>, which corresponds to one of the two semantics proposed for source-to-target tuple generating dependencies in the context of data exchange <ref type="bibr" target="#b17">(Hernich and Kolaitis 2017)</ref>. Interestingly, these bag semantics are not based on derivation trees but are model-theoretic semantics: they define annotated interpretations, and conditions for rules satisfaction over such interpretations. Such model-theoretic semantics have also been used in other contexts to evaluate Datalog and variants over annotated databases, such as fuzzy Datalog <ref type="bibr" target="#b1">(Achs and Kiss 1995)</ref> or description logic knowledge bases annotated with provenance tokens <ref type="bibr" target="#b5">(Calvanese et al. 2019;</ref><ref type="bibr" target="#b3">Bourgaux et al. 2020)</ref>. Finally, yet other semantics definitions have been proposed for some use cases. For instance, <ref type="bibr" target="#b25">Zhao, Subotic, and Scholz (2020)</ref> consider minimal depth proof trees, which correspond to a Datalog evaluation algorithm, with the intended use of understanding the computation of the result, and guiding debugging.</p><p>The fact that the above semantics are not encompassed by the definition of semiring provenance for Datalog, along with the need of handling infinite computations which are entailed by this definition, motivate us to investigate alterna-tive natural semantics that might be a better fit in different contexts.</p><p>In this paper we introduce several natural provenance semantics for Datalog over annotated data. Our definitions are based on different classical approaches: model-theoretic, execution-based and proof tree-based. They capture the semantics mentioned previously, and are inspired by practical needs. For instance, our semantics definition based on minimal depth derivation trees capture the behavior of Datalog engines, such as Soufflé <ref type="bibr" target="#b23">(Soufflé 2020)</ref>, that store only minimal depth derivation trees instead of storing them all (which might be impossible in case there are infinitely many); Our semantics based on non-recursive derivation trees (in which a fact is not derived from itself) resembles the approach taken by some graph query languages, e.g., SPARQL and Cypher, to handle queries with possibly infinite outputs by allowing to explicitly restrict the output to include only simple paths. In addition, some of the semantics suggested in the paper are closely related to paradigms for weighted reasoning in the context of words and trees <ref type="bibr" target="#b13">(Esparza and Luttenberger 2011;</ref><ref type="bibr" target="#b24">Stüber and Vogler 2008)</ref>.</p><p>After defining these different semantics, we study under which conditions they coincide and investigate their connections. We then provide a general framework for defining such provenance semantics, and present several properties relevant for provenance semantics that allow us to compare them. We briefly discuss some complexity issues in conclusion. Proofs and additional discussion are available in the appendix of <ref type="bibr" target="#b4">(Bourgaux et al. 2022</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Datalog</head><p>We use the standard Datalog settings (cf. <ref type="bibr" target="#b0">(Abiteboul, Hull, and Vianu 1995)</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>part D).</head><p>Syntax Let P, C, and V be mutually disjoint, possibly infinite sets of predicates, constants, and variables respectively. Elements of C ∪ V are called terms. An atom has the form p(t 1 , . . . , t n ) where p ∈ P is an n-ary predicate, and t i 's are terms. A fact (or ground atom) is a variable-free atom. A (Datalog) rule is an expression: ∀ x∀ y(φ( x, y) → ψ( x)) where x and y are tuples of variables and φ( x, y) and ψ( x) are conjunctions of atoms whose variables are x ∪ y and x respectively. We call φ( x, y) and ψ( x) the body and head of the rule, respectively. From now on, we assume that rules are in normalized form, i.e., the head consists of a single atom H( x), and quantifiers are implicit. The domain D(A) of a set A of atoms is the set of terms that appear in its atoms.</p><p>A database D is a finite set of facts, and a Datalog program (or ontology) Σ is a finite set of Datalog rules. The schema of D (resp. Σ) denoted S(D) (resp. S(Σ)) is the set of predicates that appear in its atoms. <ref type="foot" target="#foot_0">1</ref>Semantics The semantics of Datalog can classically be defined in three ways: through models, fixpoints or derivation trees. All three definitions rely on the notion of ho-momorphism: a homomorphism from a set A of atoms to a set B of atoms is a function h : D(A) → D(B) such that h(t) = t for all t ∈ C, and p(t 1 , . . . , t An equivalent way to define the entailment of a fact α by D and Σ is to check if there is a homomorphism from α to a specific model, defined as the least fixpoint containing D of the immediate consequence operator: An immediate consequence for D and Σ is either α ∈ D, or α such that there exists a rule r := φ( x, y) → ψ( x) and a homomorphism h from φ( x, y) to D such that h(ψ( x)) = α.</p><formula xml:id="formula_0">n ) ∈ A implies h(p(t 1 , • • • , t n )) := p(h(t 1 ), . . . , h(t n )) ∈ B. We denote by h(A) the set {h(p(t 1 , . . . , t n )) | p(t 1 , . . . , t n ) ∈ A}.</formula><p>Finally, a third definition relies on derivation trees. Definition 1 (Derivation Tree). A derivation tree t of a fact α w.r.t. a database D and a program Σ is a finite tree whose leaves are labeled by facts from D and non-leaf nodes are labeled by triples (p(t 1 , . . . , t m ), r, h) where • p(t 1 , . . . , t m ) is a fact over the schema S(Σ); • r is a rule from Σ of the form φ( x, y) → p( x); • h is a homomorphism from φ( x, y) to the facts of the labels of the node children, such that h(p( x)) = p(t 1 , . . . , t m ); • there is a bijection f between the node children and the atoms of φ( x, y), such that for every q( z) ∈ φ( x, y), f (q( z)) is of the form (h(q( z)), r , h ) or is a leaf labeled by h(q( z)). </p><formula xml:id="formula_1">Moreover, if (p(t 1 , • • • , t m ), r, h) or p(t 1 , • • • , t m ) is the root of t, then p(t 1 , • • • , t m ) = α. Example 2. Let Σ contain r 1 := R(x, y) → H(x, x), r 2 := R(x, y) → H(x, y) and r 3 := S(x, y, z) ∧ S(x, z, y) → H(x, x). If D = {R(a,</formula><formula xml:id="formula_2">(α, r 1 , h) R(a, a) (α, r 2 , h) R(a, a) (α, r 3 , h 3 ) S(a, b, c)S(a, c, b) (α, r 3 , h 3 ) S(a, c, b)S(a, b, c) where h(x) = h(y) = a, h 3 (x) = a, h 3 (y) = b, h 3 (z) = c and h 3 (x) = a, h 3 (y) = c, h 3 (z) = b.</formula><p>Note that when the program at hand is recursive (i.e., the dependency graph of its predicates contains cycles) a fact may have infinitely many derivation trees. Figure <ref type="figure" target="#fig_2">1</ref> depicts some of the infinitely many derivation trees of A(a) from Example 1. In this example, and from this point on, we omit rules and homomorphisms from trees when there is no ambiguity. Queries A conjunctive query (CQ) is an existentially quantified formula ∃ y φ( x, y) where φ( x, y) is a conjunction of atoms with variables in x ∪ y; a union of conjunctive queries (UCQ) is a disjunction of CQs (over the same free variables). A query is Boolean if it has no free-variables. A set of facts I satisfies a Boolean CQ (BCQ) q := ∃ y φ( y), written I |= q, if and only if there is a homomorphism from φ( y) to I. A BCQ q is entailed by a Datalog program Σ and database D, written Σ, D |= q, if and only if I |= q for every model I of Σ and D. Note that Σ, D |= q if and only if Σ ∪ {φ( y) → goal}, D |= goal, where goal is a nullary predicate such that goal / ∈ S(Σ) ∪ S(D). A tuple of constants a is an answer to a CQ q( x) := ∃ y φ( x, y) over Σ and D if a and x have the same arity and Σ, D |= q( a) where q( a) is the BCQ obtained by replacing the variables from x with the corresponding constants from a. When Σ = ∅, it amounts to the existence of a homomorphism from q( a) to D, which corresponds to the semantics of CQs over relational databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Annotated Databases</head><p>To equip databases with extra information, their facts might be annotated with, e.g., trust levels, clearance degree required to access them, or identifiers to track how they are used.</p><p>In the framework of semiring provenance, annotations are elements of algebraic structures known as commutative semirings. A semiring K = (K, + K , × K , 0 K , 1 K ) is a set K with distinguished elements 0 K and 1 K , equipped with two binary operators: + K , called the addition, which is an associative and commutative operator with identity 0 K , and × K , called the multiplication, which is an associative operator with identity 1 K . It also holds that × K distributes over + K , and 0 K is annihilating for × K . When multiplication is commutative, the semiring is said to be commutative. We use the convention according to which multiplication is applied before addition to omit parentheses. We omit the subscript of operators and distinguished elements when there is no ambiguity. Definition 2. An annotated database is a triple</p><formula xml:id="formula_3">(D, K, λ) where D is a database, K = (K, + K , × K , 0 K , 1 K ) is a semir- ing, and λ : D → K \ {0 K } maps facts into semiring ele- ments different from 0 K . Example 3 (Ex. 1 cont'd).</formula><p>The semiring N = (N, +, ×, 0, 1) of the natural numbers equipped with the usual operations is used for bag semantics. The tropical semiring</p><formula xml:id="formula_4">T = (R ∞ + , min, +, ∞, 0) is used to compute minimal-cost paths. We define λ N : D → N \ {0} by λ N (B(a)) = 3, λ N (B(b)) = 1, λ N (R(a, b)) = 2, λ N (R(b, a)) = 1; And λ T : D → R + by λ T (B(a)) = 10, λ T (B(b)) = 1, λ T (R(a, b)) = 5, λ T (R(b, a)) = 2.</formula><p>We next list some possible properties of semirings. A semiring is</p><formula xml:id="formula_5">+ -idempotent (resp. ×-idempotent) if for every a ∈ K, a + a = a (resp. a × a = a). It is absorptive if for every a, b ∈ K, a × b + a = a. It is positive if for every a, b ∈ K, a × b = 0 if</formula><p>and only if (a = 0 or b = 0), and a + b = 0 if and only if a = b = 0. Finally, an important class is that of ω-continuous commutative semirings in which infinite sums are well-defined. Given a semiring, we define the binary relation such that a b if and only if there exists c ∈ K such that a + c = b. A commutative semiring is ω-continuous if is a partial order, every (infinite) ω-chain a 0 a 1 a 2 . . . has a least upper bound sup((a i ) i∈N ), and for every a, a + sup((</p><formula xml:id="formula_6">a i ) i∈N ) = sup((a + a i ) i∈N ) and a × sup((a i ) i∈N ) = sup((a × a i ) i∈N ).</formula><p>The semantics of queries from the positive relational algebra, and in particular of UCQs, over annotated databases is defined inductively on the structure of the query <ref type="bibr" target="#b15">(Green, Karvounarakis, and Tannen 2007)</ref>. Intuitively, joint use of data (conjunction) corresponds to multiplication, and alternative use of data (union or projection) corresponds to addition. Example 4</p><formula xml:id="formula_7">(Ex. 3 cont'd). The BCQ ∃xy (R(x, y) ∧ B(y)) is entailed from (D, N, λ N ) with multiplicity λ N (R(a, b)) × λ N (B(b)) + λ N (R(b, a)) × λ N (B(a)) = 5, and from (D, T, λ T ) with minimal cost min(λ T (R(a, b)) + λ T (B(b)), λ T (R(b, a)) + λ T (B(a))) = 6.</formula><p>A semantics of Datalog over annotated databases has been defined by <ref type="bibr" target="#b15">Green, Karvounarakis, and Tannen (2007)</ref> using derivation trees, that we shall name the all-tree semantics. It associates to each fact α entailed by Σ and D the following sum, where T Σ D (α) is the set of all derivation trees for α w.r.t. Σ and D and Λ(t) := v is a leaf of t λ(v) is the Kannotation of the derivation tree t (since K is commutative, the result of the product is well-defined).</p><formula xml:id="formula_8">P AT (Σ, D, K, λ, α) := t∈T Σ D (α) Λ(t).</formula><p>Since T Σ D (α) may be infinite, P AT is well-defined for all Σ, (D, K, λ) and α only in the case where K is ω-continuous. Example 5 (Ex. 3 cont'd). The fact α := A(a) is entailed with minimal cost:</p><formula xml:id="formula_9">P AT (Σ, D, T, λ T , α) = min t∈T Σ D (α) Σ v is a leaf of t λ T (v) = 3. Since N is not ω- continuous, P AT (Σ, D, N, λ N , α) is not defined.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Provenance Semirings</head><p>Provenance semirings have been introduced to abstract from a particular semiring by associating a unique provenance token to each fact of the database, and building expressions that trace their use. Given a set X of variables that annotate the database, a provenance semiring Prov (X) is a semiring over a space of provenance expressions with variables from X.</p><p>Various such semirings were introduced in the context of relational databases <ref type="bibr" target="#b16">(Green 2009</ref>): The most expressive annotations are provided by the provenance polynomials semiring N[X] := (N[X], +, ×, 0, 1) of polynomials with coefficients from N and variables from X, and the usual operations. Less general provenance semirings include, for example, the semiring B[X] := (B[X], +, ×, 0, 1) of polynomials with Boolean coefficients, and the semiring PosBool (X) := (PosBool (X), ∨, ∧, false, true) of positive Boolean expressions.</p><p>In the Datalog context, it is important to allow for infinite provenance expressions, as there can be infinitely many derivation trees. A formal power series with variables from X and coefficients from K is a mapping that associates to each monomial over X a coefficient in K. A formal power series S can be written as a possibly infinite sum S = Σ m∈mon(X) S(m)m where mon(X) is the set of monomials over X and S(m) is the coefficient of the monomial m. The set of formal power series with variables from X and coefficients from K is denoted K X . <ref type="bibr" target="#b15">Green, Karvounarakis, and Tannen (2007)</ref> define the Datalog provenance semiring as the semiring N ∞ X of formal power series with coefficients from</p><formula xml:id="formula_10">N ∞ = N ∪ {∞}. A semiring homomorphism from K = (K, + K , × K , 0 K , 1 K ) to K = (K , + K , × K , 0 K , 1 K ) is a mapping h : K → K such that h(0 K ) = 0 K , h(1 K ) = 1 K , and for all a, b ∈ K, h(a + K b) = h(a) + K h(b) and h(a × K b) = h(a) × K h(b). A semiring homomorphism be- tween ω-continuous semirings is ω-continuous if it preserves least upper bounds: h(sup((a i ) i∈N )) = sup((h(a i )) i∈N ).</formula><p>Following <ref type="bibr" target="#b11">Deutch et al. (2014)</ref>, we say that a provenance semiring Prov (X) specializes correctly to a semiring K, if any valuation ν : X → K extends uniquely to a (ωcontinuous if Prov (X) and K are ω-continuous) semiring homomorphism h : Prov (X) → K, allowing the computations for K to factor through the computations for Prov (X). A provenance semiring Prov (X) is universal for a set of semirings if it specializes correctly to each semiring of this set. <ref type="bibr" target="#b15">Green, Karvounarakis, and Tannen (2007)</ref> showed that N[X] is universal for commutative semirings, and N ∞ X is universal for commutative ω-continuous semirings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Alternative Semantics</head><p>In this section we propose several natural ways of defining the semantics of Datalog over annotated databases, and investigate their connections. We have seen that the semantics of Datalog can equivalently be defined through models, fixpoints or derivation trees. The semantics we propose also fall into these three approaches. For presentation purposes, we see each semantics as a partial function P that associates to a Datalog program Σ, annotated database (D, K, λ), and fact α, a semiring element P(Σ, D, K, λ, α).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Model-Based Semantics</head><p>We first investigate two provenance semantics based on Datalog's model-theoretic semantics. In both cases, we will define interpretations (I, µ I ) where I is a set of facts and µ I is a function that annotates facts of I, and formulate requirements for them to be models of Σ and (D, K, λ), extending standard models of Σ and D with fact annotations.</p><p>Annotated Model-based Hernich and Kolaitis (2017) define two bag semantics in the context of data exchange: the incognizant and cognizant semantics. The difference between them arise from the two different semantics of bag union: the incognizant semantics uses the maximum-based union, while the cognizant semantics uses the sum-based union.</p><p>In more details, both semantics are based on the following semantics for source-to-target tuple generating dependencies (s-t tgds): a pair (I, J) of source and target instances satisfies an s-t tgd q 1 ( x) → q 2 ( x) if for every answer a to q 1 over I, a is an answer to q 2 over J with at least the same multiplicity. Given a set of s-t tgds Σ and a source I, a target J is an incognizant solution for I w.r.t. Σ if (I, J) satisfies every s-t tgd in Σ. It is a cognizant solution if for every r ∈ Σ, there is a target instance J r such that (I, J r ) satisfies r and J r ⊆ J, where denotes the sum-union of bags (i.e., the multiplicity of each element of the sum-union is equal to the sum of its multiplicities). The incognizant (resp. cognizant) certain answers to a query q w.r.t. Σ on I are defined using bag intersection of the answers over the incognizant (resp. cognizant) solutions for I w.r.t. Σ, i.e., the multiplicity of an answer is the minimum of its multiplicities over the solutions. Note that for BCQs, the only possible certain answer is the empty tuple.</p><p>For example, consider Σ = {B(x) → A(x), C(x) → A(x)} and D = {(B(a), 1), (C(a), 1)}. Under the incognizant semantics, the multiplicity of the certain answer of the Boolean query A(a) w.r.t. Σ and D is 1 while under the cognizant semantics it is 2. Indeed, J = {(A(a), 1)} is an incognizant solution for D w.r.t. Σ as it satisfies both s-t tgds, but is not a cognizant solution as the sum of multiplicities that arise from the two rules is 2.</p><p>It is easy to show that the cognizant semantics is equivalent to P AT on the counting semiring N = (N, +, ×, 0, 1), and thus coincides with the classical bag semantics for Datalog. However, we have seen that the incognizant and cognizant semantics differ. Moreover, note that in the field of ontologybased data access, the bag semantics defined by Nikolaou et al. for DL-Lite R (2017; 2019) coincides with the incognizant semantics, thus disagrees with the classical Datalog bag semantics <ref type="bibr" target="#b18">(Mumick, Pirahesh, and Ramakrishnan 1990;</ref><ref type="bibr" target="#b15">Green, Karvounarakis, and Tannen 2007)</ref>.</p><p>We hence define a provenance semantics that coincides with these semantics when used with the counting semiring. Since it is based on greatest lower bounds, it is defined on a restricted class of semirings.</p><p>Let K = (K, +, ×, 0, 1) be a commutative ω-continuous semiring such that for every K ⊆ K, the greatest lower bound inf(K ) of K is well defined (i.e., there exists a unique z ∈ K such that z x for every x ∈ K and every z such that z</p><p>x for every x ∈ K is such that z z), Σ be a Datalog program, and (D, K, λ) be an annotated database. We define K-annotated interpretations as pairs (I, µ I ) where I is a set of facts, and µ I is a function from I to K. We say that a K-annotated interpretation (I, µ I ) is a model of Σ and (D, K, λ), denoted by (I, µ I ) |= (Σ, D, K, λ), if 1. D ⊆ I, and for every α ∈ D, λ(α) µ I (α); 2. for every φ( x, y) → H( x) in Σ, whenever there is a homomorphism h : φ( x, y) → I, then h(H( x)) ∈ I and</p><formula xml:id="formula_11">h :φ( x, y) →I,h ( x)=h( x) β∈h (φ( x, y)) µ I (β) µ I (h(H( x))).</formula><p>The annotated model-based provenance semantics P AM is defined by</p><formula xml:id="formula_12">P AM (Σ, D, K, λ, α) := inf({µ I (α)|(I, µ I )|=(Σ, D, K, λ)}).</formula><p>Proposition 1. If the Datalog rules in Σ are (1) s-t tgds, or (2) formulated in DL-Lite R , then for every BCQ q, P AM (Σ ∪ {q → goal}, D, N, λ N , goal) is equal to the multiplicity of the empty tuple in (1) the incognizant certain answers or (2) the bag certain answers to q w.r.t. Σ and (D, N, λ N ).</p><p>Set-Annotated Model-based We adapt the work on provenance for the description logics DL-Lite R and ELH r (Calvanese et al. 2019; <ref type="bibr" target="#b3">Bourgaux et al. 2020)</ref>, where the semiring is assumed to be a ×-idempotent provenance semiring Prov (X) and rules are also annotated. Annotated models of annotated knowledge bases are defined as set of facts annotated with sets of monomials from Prov (X). Given a fact α and a monomial m over X, (Σ, D, Prov (X), λ X ) |= (α, m) holds when m belongs to the annotation set of α in every models of Σ and (D, Prov (X), λ X ).</p><p>To obtain an analog provenance semantics for Datalog, we define interpretations which associate facts with (possibly infinite) sets of annotations, and formulate the requirements for them to be models of Σ and (D, K, λ).</p><p>Let K = (K, +, ×, 0, 1) be a commutative ω-continuous semiring, Σ be a Datalog program, and (D, K, λ) be an annotated database. We define K-set-annotated interpretations as pairs (I, µ I ) where I is a set of facts, and µ I is a function from I to the power-set of K. We say that a K-set-annotated interpretation (I, µ I ) is a model of Σ and (D, K, λ), denoted by (I, µ I ) |= (Σ, D, K, λ), if 1. D ⊆ I, and for every α ∈ D, λ(α) ∈ µ I (α); 2. for every φ( x, y) → H( x) in Σ, whenever there is a homomorphism h : φ( x, y) → I, then h(H( x)) ∈ I and if</p><formula xml:id="formula_13">h(φ( x, y)) = β 1 ∧ • • • ∧ β n , {Π n i=1 k i | (k 1 , . . . , k n ) ∈ µ I (β 1 ) × • • • × µ I (β n )} ⊆ µ I (h(H( x))).</formula><p>The set-annotated model-based provenance semantics P SAM is defined by</p><formula xml:id="formula_14">P SAM (Σ, D, K, λ, α) := k∈ (I,µ I )|=(Σ,D,K,λ) µ I (α) k.</formula><p>Connections between semantics Let be the binary relation between provenance semantics such that P P if and only if P(Σ, D, K, λ, α) P (Σ, D, K, λ, α) for every Σ, (D, K, λ) and α on which P and P are well-defined.</p><p>Proposition 2. The following holds:</p><formula xml:id="formula_15">P AM P AT and P SAM P AT .</formula><p>Next examples show that P AM and P SAM are incomparable. Annotated models of Σ and (D, N, λ N ) are such that µ I (goal) ≥ 3, so P AM (Σ, D, N, λ N , goal) = 3.</p><p>Set-annotated models of Σ and (D, N, λ N ) are such that {2, 3} ⊆ µ I (goal), so P SAM (Σ, D, N, λ N , goal) = 5.</p><p>Hence P AM (Σ, D, N, λ N , goal)&lt;P SAM (Σ, D, N, λ N , goal).</p><formula xml:id="formula_16">Example 7. Let Σ = {R(x, y) → goal}, D = {R(a, b), R(a, c)}, λ N (R(a, b)) = 2 and λ N (R(a, c)) = 2.</formula><p>Annotated models of Σ and (D, N, λ N ) are such that µ I (goal) ≥ 4, so P AM (Σ, D, N, λ N , goal) = 4.</p><p>Set-annotated models of Σ and (D, N, λ N ) are such that {2} ⊆ µ I (goal), so P SAM (Σ, D, N, λ N , goal) = 2.</p><p>Hence P AM (Σ, D, N, λ N , goal)&gt;P SAM (Σ, D, N, λ N , goal).</p><p>Despite of their inherently different approaches, P AM , P SAM and P AT coincide on a large class of semirings. Proposition 3. If K is a commutative + -idempotent ω-continuous semiring, then for every Σ, (D, K, λ), and α, P AM (Σ, D, K, λ, α) = P SAM (Σ, D, K, λ, α) = P AT (Σ, D, K, λ, α).</p><p>Additional insights on the connection between definitions can be gained by considering the provenance semiring N ∞ X : the monomials with non-zero coefficients are the same with all semantics but their coefficients may differ (P AT leading to the highest coefficients by Proposition 2). Proposition 4. Let λ X be an injective function from D to X.</p><formula xml:id="formula_17">• A monomial occurs in P AT (Σ, D, N ∞ X , λ X , α) if and only if it occurs in P AM (Σ, D, N ∞ X , λ X , α). • P SAM (Σ, D, N ∞ X , λ X , α) is obtained by setting all non- zero coefficients to 1 in P AT (Σ, D, N ∞ X , λ X , α).</formula><p>An example where P AT and P AM or</p><formula xml:id="formula_18">P SAM differ on N ∞ X is the following: Let Σ contain A(x) → B(x), B(x) → A(x), D = {A(a)} and λ X (A(a)) = x.</formula><p>Since there are infinitely many derivation trees for A(a), P AT (Σ, D, K, λ X , A(a)) = ∞x while for P ∈ {P AM , P SAM }, P(Σ, D, N ∞ X , λ X , A(a)) = x, as {A(a), B(a)} with both facts annotated with x (resp. {x}) is a (resp. set-)annotated model for Σ and (D, N ∞ X , λ X ).</p><p>Note that P AM and P SAM can still lead to infinite provenance expressions: Let Σ = {A(x) ∧ B(x) → A(x)}, D = {A(a), B(a)}, λ X (A(a)) = x and λ X (B(a)) = y. For P ∈ {P AM , P SAM }, P(Σ, D, N ∞ X , λ X , A(a)) = x + xy + xy 2 + xy 3 + . . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Execution-and Tree-Based Semantics</head><p>We saw that when annotations are present there is more than one way to define a model-based semantics for Datalog and that it differs from the all-tree semantics. We now investigate definitions based on classical Datalog evaluation algorithms.</p><p>We extend the notion of immediate consequence operator describing the application of rules onto facts, with the computation of annotation. To this end, we introduce the annotation aware immediate consequence operator T Σ . Applying T Σ on a set of annotated facts (I, K, λ) results in (I TΣ , K, λ TΣ ) where I TΣ is the result of applying the immediate consequence operator to Σ and I, and λ TΣ annotates facts in I TΣ with the relational provenance (over (I, K, λ)) of the UCQ formed by the bodies of the rules that create them. Formally,</p><formula xml:id="formula_19">I TΣ := {H( a) | I |= ∃ y φ( a, y) , φ( x, y) → H( x) ∈ Σ} λ TΣ (H( a)) := h( x)= a, I|=h(φ( x, y)) φ( x, y)→H( x)∈Σ β∈h(φ( x, y)) λ(β)</formula><p>We define a union operator for annotated databases (over the same semiring): (I, K, λ) ∪ (I , K, λ ) := (I ∪ I , K, λ ) where λ (α) := λ(α) + λ (α) where we slightly abuse notation by setting λ(α) = 0 if α / ∈ I, and λ (α) = 0 if α / ∈ I .</p><p>Naive Evaluation / All Trees In the naive evaluation algorithm, all rules are applied in parallel until a fixpoint is reached. The 'annotation aware' version of it is as follows:</p><p>We set I 0 n (Σ, D, K, λ) := (D, K, λ), and define inductively</p><formula xml:id="formula_20">I i+1 n (Σ, D, K, λ) := T Σ (I i n (Σ, D, K, λ)) ∪ (D, K, λ).</formula><p>Note that the subscript n of I n is an abbreviation for 'naive', and the superscript i indicates how many times T Σ was applied.</p><p>Let</p><formula xml:id="formula_21">(I i n , K, λ i n ) denote I i n (Σ, D, K, λ).</formula><p>We say that I i n (Σ, D, K, λ) converges if there is some k such that I n = I k n for every ≥ k, and sup(λ i n (α)) exists for every α ∈ I k n . Proposition 5. For every Σ, D, K, λ, if K is ω-continuous then I i n (Σ, D, K, λ) converges. In this case, we define I ∞ n := I k n and λ ∞ n := sup i→∞ λ i n . The naive execution provenance semantics P NE is defined by</p><formula xml:id="formula_22">P NE (Σ, D, K, λ, α) := λ ∞ n (α) α ∈ I ∞ n 0 otherwise</formula><p>and is equivalent to the all-tree semantics. Proposition 6. It holds that P NE = P AT .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimized Naive Evaluation / Minimal Depth Trees</head><p>We consider an optimized version of the naive algorithm that stops as soon as the desired fact is derived. We define the 'annotation aware' version of this algorithm by</p><formula xml:id="formula_23">I 0 o,α (Σ, D, K, λ) := (D, K, λ),<label>and</label></formula><formula xml:id="formula_24">I i+1 o,α (Σ, D, K, λ) := T Σ (I i o,α (Σ, D, K, λ)) ∪ (D, K, λ) α / ∈ I i o,α I i o,α (Σ, D, K, λ) otherwise where I i o,α is such that I i o,α (Σ, D, K, λ) := (I i o,α , K, λ i o,α</formula><p>). Proposition 7. For every Σ, D, K, λ, and α such that Σ, D |= α , there exists k ≥ 0 such that</p><formula xml:id="formula_25">I k o,α (Σ, D, K, λ) = I o,α (Σ, D, K, λ) for every ≥ k.</formula><p>With k as provided by Proposition 7, we define the optimized execution provenance semantics P OE by:</p><formula xml:id="formula_26">P OE (Σ, D, K, λ, α) := λ k o,α (α) α ∈ I k o,α 0 otherwise</formula><p>We show that an equivalent tree-based semantics can be obtained by considering only minimal depth trees for the desired fact. This approach has been considered useful, for example to present a 'small proof' for debugging <ref type="bibr" target="#b25">(Zhao, Subotic, and Scholz 2020)</ref>. Formally, let depth(t) denote the depth of tree t. We say that t ∈ T Σ D (α) is of minimal depth if for every t ∈ T Σ D (α) it holds that depth(t) ≤ depth(t ). The minimal depth tree provenance semantics P MDT is defined by</p><formula xml:id="formula_27">P MDT (Σ, D, K, λ, α) := t∈T Σ D (α) is of minimal depth Λ(t)</formula><p>and is equivalent to the optimized naive execution. Proposition 8. It holds that P OE = P MDT .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Seminaive Evaluation / Hereditary Minimal Depth Trees</head><p>In the seminaive evaluation algorithm, facts are derived only once. We introduce a new consequence operator ∆ Σ that derives only new facts and is defined as follows: ∆ Σ (I, K, λ) := (I ∆Σ , K, λ ∆Σ ) where T Σ (I, K, λ) := (I TΣ , K, λ TΣ ), I ∆Σ := I TΣ \ I, and λ ∆Σ is the restriction of λ TΣ to I ∆Σ . We can now define the annotation aware version of the seminaive evaluation: I 0 sn (Σ, D, K, λ) := (D, K, λ) and I i+1 sn (Σ, D, K, λ) := I i sn (Σ, D, K, λ) ∪ ∆ Σ (I i sn (Σ, D, K, λ)). Proposition 9. For every Σ, D, K, λ, there exists k ≥ 0 such that I k sn (Σ, D, K, λ) = I sn (Σ, D, K, λ) for every ≥ k. Note that, unlike in Proposition 5, we do not require K to be ω-continuous. With k provided by Proposition 9, the seminaive execution provenance semantics P SNE is defined by</p><formula xml:id="formula_28">P SNE (Σ, D, K, λ, α) := λ k sn α ∈ I k sn 0 otherwise</formula><p>To capture this with the tree-based approach we need to further restrict all subtrees to be of minimal depth. Formally, a derivation tree t ∈ T Σ D (α) is a hereditary minimal-depth (derivation) tree if for every node n of t labeled by (β, r, h), the subtree t β with root n is a minimal-depth derivation tree for β. The hereditary minimal depth tree provenance semantics P HMDT is defined by</p><formula xml:id="formula_29">P HMDT (Σ, D, K, λ, α) := t∈T Σ D (α) is hereditary minimal-depth Λ(t)</formula><p>and is equivalent to the seminaive execution. Proposition 10. It holds that P SNE = P HMDT .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Non-Recursive Tree-Based Semantics</head><p>Both execution-based semantics P OE and P SNE take into account finite subsets of derivation trees (and hence converge). Is there a more informative tree-based semantics (i.e., one that takes into account a bigger subset of derivation trees) that still converges? We present such a semantics based on the intuition that deriving a fact from itself is redundant.</p><p>Formally, a non-recursive (derivation) tree is a derivation tree that does not contain two nodes labeled with the same fact and such that one is the descendant of the other. The non-recursive tree provenance semantics P NRT is defined by</p><formula xml:id="formula_30">P NRT (Σ, D, K, λ, α) := t∈T Σ D (α) is non-recursive Λ(t).</formula><p>Connections between semantics Next proposition follows from the fact that hereditary minimal-depth trees are of minimal-depth and non recursive. The sets of minimal depth trees and non-recursive trees are incomparable, so that P NRT P MDT and P MDT P NRT .</p><p>Proposition 11. The following hold: P HMDT P NRT P AT and P HMDT P MDT P AT Moreover P NRT and P AT coincide on specific semirings.</p><p>Proposition 12. For every Σ, D, K, λ and α, if K is a commutative absorptive ω-continuous semiring, then P NRT (Σ, D, K, λ, α) = P AT (Σ, D, K, λ, α).</p><p>If K is not absorptive, there exists Σ, (D, K, λ) and α such that P NRT (Σ, D, K, λ, α) = P AT (Σ, D, K, λ, α), even in the case where K is + -idempotent and ×-idempotent:</p><formula xml:id="formula_31">Let Σ consist of the rule A(x) ∧ B(x) → A(x) and D = {A(a), B(a)}. Then P NRT (Σ, D, K, λ, A(a)) = λ(A(a)) while P AT (Σ, D, K, λ, A(a)) = λ(A(a)) + λ(A(a)) × λ(B(a)).</formula><p>The other semantics differ even under strong restrictions. Example 8. This example shows that P NRT , P MDT and P HMDT differ even if K is + and ×-idempotent and absorptive. </p><formula xml:id="formula_32">Let Σ ={B(x) ∧ C(x) → A(x), D(x) → B(x), E(x) → C(x), F (x) → E(x)} D ={C(a)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Basics Properties</head><p>In this section, we provide a framework allowing to compare the provenance semantics presented in the previous section. It is clear that they all fulfill the following definition. Definition 3 (Provenance semantics). A provenance semantics is a partial function that assigns to a Datalog program Σ, annotated database (D, K, λ) and fact α, an element</p><formula xml:id="formula_33">P(Σ, D, K, λ, α) in K such that: 1. Σ, D |= α implies P(Σ, D, K, λ, α) = 0 K . 2. If K is positive, P(Σ, D, K, λ, α) = 0 K implies Σ, D |= α.</formula><p>We call the semiring domain of P the maximal set S of semirings such that P(Σ, D, K, λ, α) is defined for every K ∈ S, and every Σ, (D, K, λ) and α.</p><p>Intuitively, Definition 3 means that the semantics reflects fact (non)-entailment. It is extremely permissive: We could define such a semantics that associates to each entailed fact a random semiring element different from zero, and does not bring any information beyond facts entailment. In the sequel, we state and discuss a number of properties that may be expected to be satisfied by a provenance semantics.</p><p>Throughout this section, when not stated otherwise, P, Σ, D, K, λ and α denote respectively an arbitrary provenance semantics, Datalog program, database, commutative semiring (K, +, ×, 0, 1), function from D to K \ {0}, and fact. We phrase properties as conditions, and say that P satisfies a property if it satisfies the condition. We also denote by λ X an injective function λ X : D → X.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Compatibility with Classical Notions</head><p>Property 1 is a sanity check: if a Datalog program amounts to a UCQ, the provenance should be the same as the one defined for relational databases <ref type="bibr" target="#b15">(Green, Karvounarakis, and Tannen 2007)</ref>. A Datalog program Σ is UCQ-defined if its rules are of the form φ( x, y) → H( x) where H is a predicate that does not occur in the body of any rule. In this case, the equivalent UCQ Q Σ of Σ is φ( x, y)→H( x)∈Σ ∃ yφ( x, y). Property 1 (Algebra Consistency). If Σ is UCQ-defined with rule head H( x) and H / ∈ S(D), then for every tuple a of same arity as x, the relational provenance of Q Σ ( a) is equal to P(Σ, D, K, λ, H( a)).</p><p>While Property 1 considers the behavior of a provenance semantics on a restricted class of queries, we can alternatively consider its behavior on a specific semiring. Boolean provenance has a very natural definition, based on the database subsets that entail the query, and is widely used, notably for probabilistic databases <ref type="bibr" target="#b22">(Senellart 2017)</ref>, but also for ontologymediated query explanation (e.g., in Datalog +/-or description logics <ref type="bibr" target="#b6">(Ceylan et al. 2019;</ref><ref type="bibr" target="#b7">Ceylan et al. 2020)</ref>). It is formalized with the semiring PosBool (X). Property 2 (Boolean Compatibility).</p><formula xml:id="formula_34">P(Σ, D, PosBool (X), λ X , α) = D ⊆D Σ,D |=α β∈D λ X (β)</formula><p>Property 2 expresses 'insensibility' to syntax, that is, every provenance semantics that satisfies Property 2 agrees on equivalent programs (i.e., those that have the same models) for the semiring PosBool (X). This is related to ideas from <ref type="bibr" target="#b16">(Green 2009)</ref> on the provenance of equivalent UCQs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Compatibility with Specialization</head><p>Semiring provenance has been introduced to abstract from the particular semiring at hand, and factor the computations in some provenance semiring which specializes correctly to any semiring of interest. The next property allows one to do so, and is thus highly desirable <ref type="bibr" target="#b4">(Bourgaux et al. 2022)</ref>. Property 3 (Commutation with Homomorphisms). If there is a semiring homomorphism h from</p><formula xml:id="formula_35">K 1 to K 2 , then h(P(Σ, D, K 1 , λ, α)) = P(Σ, D, K 2 , h • λ, α).</formula><p>We call Property 3 restricted to ω-continuous homomorphisms Commutation with ω-Continuous Homomorphisms.</p><p>Specializing correctly is all the more useful when P is welldefined for a lot of semirings, in particular on all commutative or at least all commutative ω-continuous semirings. Property 4 (Any (ω-Continuous) Semiring). P satisfies the Any Semiring Property (resp. Any ω-Continuous Semiring Property) if the semiring domain of P contains the set of all commutative (resp. commutative ω-continuous) semirings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Joint and Alternative Use of the Data</head><p>How is the actual usage of the data reflected in the provenance semantics? The next property formalizes that multiplication reflects joint use of the data, and addition alternative use. For the rest of this section, we set goal to be a nullary predicate not in S(Σ) ∪ S(D). Property 5 (Joint and Alternative Use). For all tuples of facts (α</p><formula xml:id="formula_36">1 1 , • • • , α 1 n1 ), . . . , (α m 1 , • • • , α m nm ), it holds that P(Σ , D, K, λ, goal) = Σ m i=1 Π ni j=1 P(Σ, D, K, λ, α i j ) where Σ = Σ ∪ { ni j=1 α i j → goal | 1 ≤ i ≤ m}.</formula><p>We weaken the above by referring to each mode separately: Property 6 (Joint Use). For all facts α 1 , • • • , α n ,</p><formula xml:id="formula_37">P(Σ , D, K, λ, goal) = Π n j=1 P(Σ, D, K, λ, α j ) where Σ = Σ ∪ { n j=1 α j → goal}. Property 7 (Alternative Use). For all facts α 1 , • • • , α m , P(Σ , D, K, λ, goal) = Σ m i=1 P(Σ, D, K, λ, α i ) where Σ = Σ ∪ {α i → goal | 1 ≤ i ≤ m}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Fact Roles in Entailment</head><p>After considering how facts can be combined or used alternatively to entail a result, we ponder their possible roles w.r.t. the entailment. Property 8 asserts that the original annotation of a fact takes part in the provenance of its entailment. Property 8 (Self). If α ∈ D, then λ(α) P(Σ, D, K, λ, α).</p><p>Moreover, if a database fact cannot be alternatively derived using the rules, then its provenance should be exactly its original annotation. To phrase this property we use the grounding Σ D of Σ w. Parsimony Property together with other constraints guarantee Algebra Consistency Property. Proposition 13. If P satisfies Properties 5 (Joint and Alternative Use) and 9 (Parsimony), and is such that for every Σ, D, K, λ, α, P(Σ, D, K, λ, α) = P(Σ D , D, K, λ, α), then it satisfies Property 1 (Algebra Consistency).</p><p>Property 10 states that P reflects the necessity of a fact for the entailment. We say that β ∈ D is necessary to Σ, D |= α if Σ, D \ {β} |= α, and denote by Nec the set of such facts. Property 10 (Necessary Facts). There exists e ∈ K such that P(Σ, D, K, λ, α) = Π β∈Nec λ(β) × e.</p><p>A fact is usable to Σ, D |= α if it occurs in some derivation tree in T Σ D (α). Usable facts are related to the notion of lineage <ref type="bibr" target="#b9">(Cui, Widom, and Wiener 2000)</ref> and can be defined without resorting to derivation trees <ref type="bibr" target="#b4">(Bourgaux et al. 2022)</ref>. Intuitively, if a fact is not usable to derive another fact, it should not have any influence on its provenance. Property 11 (Non-Usable Facts). For every λ that differs from λ only on facts that are not usable to Σ, D |= α, it holds that P(Σ, D, K, λ, α) = P(Σ, D, K, λ , α).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Data Modification</head><p>The last two properties indicate how provenance is impacted when facts are inserted or deleted. Property 12 (Insertion). For every (D , K, λ ) such that D ∩ D = ∅, P(Σ, D, K, λ, α) + P(Σ, D , K, λ , α)</p><formula xml:id="formula_38">P(Σ, D ∪ D , K, λ ∪ λ , α).</formula><p>Maintaining provenance upon fact deletion is very useful in practice. We formalize this using a provenance semiring, which allows us to keep track of the facts. A partial evaluation of a provenance expression p(X) over variables X is an expression obtained from p(X) by replacing some of the variables by a given value. Property 13 (Deletion). For every provenance semiring Prov (X) and D ⊆ D, if λ is the restriction of λ X to D and ∆ = D \ D , then P(Σ, D , Prov (X), λ , α) is equal to the partial evaluation of P(Σ, D, Prov (X), λ X , α) obtained by setting the annotations of facts in ∆ to 0:</p><formula xml:id="formula_39">P(Σ, D, Prov (X), λ X , α)[{λ X (x) = 0} x∈∆ ].</formula><p>5 Semantics Analysis w.r.t. Properties</p><p>In this section, we analyze the semantics proposed in Section 3 w.r.t. the properties introduced in Section 4. The properties each semantics satisfies are summarized in Table <ref type="table" target="#tab_1">1</ref>. Proofs of the positive cases are given in the appendix of <ref type="bibr" target="#b4">(Bourgaux et al. 2022</ref>) and we discuss the negative cases, which may be more characteristic, in the sequel. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Tree-and Execution-Based Semantics Cases</head><p>We first discuss P MDT and P HMDT , which have not been much investigated and stand out compared to P AT and P NRT . The next example shows that they do not satisfy the Boolean Compatibility, Joint and Alternative Use, Alternative Use, Insertion and Deletion Properties.</p><p>Example 9. Consider Σ and (D, Prov (X), λ X ) as follows.</p><formula xml:id="formula_40">Σ ={A(x) → goal, B(x) → goal, C(x) → B(x)} D ={A(a), C(a)} with λ X (A(a)) = a, λ X (C(a)) = c</formula><p>It holds that both P MDT (Σ, D, Prov (X), λ X , goal) and P HMDT (Σ, D, Prov (X), λ X , goal) are equal to a. For P ∈ {P MDT , P HMDT } we then have the following: (i) The Boolean provenance of goal is a ∨ c, hence P does not satisfy the Boolean Compatibility Property.</p><p>(ii) Since P(∅, D, Prov (X), λ X , A(a)) = a and P(∅, D, Prov (X), λ X , C(a)) = c, P does not satisfy the Alternative Use, nor the Joint and Alternative Use Property. (iii) Let D = {goal} and λ (goal) = g. It holds that P(Σ, D ∪ D , Prov (X), λ X ∪ λ X , goal) = g, which is different from P(Σ, D, Prov (X), λ X , goal) + P(Σ, D , Prov (X), λ X , goal) + e for every e ∈ Prov (X). Hence P does not satisfy the Insertion Property. (iv) Let D = D \{A(a)} = {C(a)}. The partial evaluation of P(Σ, D, Prov (X), λ X , goal) where a is set to 0 is equal to 0 while P(Σ, D , Prov (X), λ X , goal) = c. Hence P does not satisfy the Deletion Property.</p><p>We now illustrate the difference between P HMDT and P MDT : P HMDT satisfies the Joint Use Property while P MDT does not. We conclude this discussion with the remark that P AT satisfies the Commutation with ω-Continuous Homomorphisms but not the Commutation with Homomorphisms Property. Example 11. Consider the semiring N ∞ with the classical operations, and define N ∞,∞ as its extension by an element ∞ such that for every n ∈ N ∪ {∞}, n + ∞ = ∞ , and n × ∞ = ∞ if n = 0, and 0 otherwise. Both semirings are ω-continuous and h : N ∞ → N ∞,∞ defined by h(n) = n for every n ∈ N, h(∞) = ∞ is a semiring homomorphism (which is not ω-continuous). Assume that P AT (Σ, D, N ∞ , λ, goal) = Σ i∈N 1 = ∞. Then h(P AT (Σ, D, N ∞ , λ, goal)) = ∞ is different from</p><formula xml:id="formula_41">P AT (Σ, D, N ∞,∞ , h • λ, goal) = Σ i∈N h(1) = ∞.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Model-Based Semantics Cases</head><p>On + -idempotent semirings, P AM and P SAM coincide with P AT so verify the same properties, and the semiring B X of formal power series with Boolean coefficients can be used to compute them in any + -idempotent semiring <ref type="bibr" target="#b4">(Bourgaux et al. 2022)</ref>. However, on non-idempotent semirings, they do not satisfy several properties, and in particular the Commutation with (ω-Continuous) Homomorphisms Properties. Example 12. Let Σ = {A(x) → goal, B(x) → goal} and D = {A(a), B(a)} and consider the provenance semiring N ∞ X with λ X (A(a)) = x and λ X (B(a)) = y.</p><p>It holds that both P AM (Σ, D, N ∞ X , λ X , goal) and P SAM (Σ, D, N ∞ X , λ X , goal) are equal to x + y.</p><p>Consider now the semiring N ∞ , λ N (A(a)) = 2 and λ N (B(a)) = 2. Both P AM (Σ, D, N ∞ , λ N , goal) and P SAM (Σ, D, N ∞ , λ N , goal) are equal to 2.</p><p>For P ∈ {P AM , P SAM } we then have the following: (i) Let h be a ω-continuous homomorphism from N ∞ X to N ∞ such that h(x) = 2 and h(y) = 2. Since h(x + y) = h(x) + h(y) = 4, P does not satisfy the Commutation with ω-Continuous Homomorphisms Property.</p><p>(ii) The relational provenance of Q Σ () w.r.t. N ∞ and λ N is 4 so P does not satisfy the Algebra Consistency Property. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Both</head><p>P SAM (Σ, D, N ∞ X , λ X , g 1 ) and P SAM (Σ, D, N ∞ X , λ X , g 2 ) are equal to x + y but P SAM (Σ ∪ {g 1 ∧ g 2 → goal}, D, N ∞ X , λ X , goal) = x 2 + y 2 + xy = (x + y) 2 .</p><p>We show that P AM does not satisfy the Necessary Facts Property in the appendix of <ref type="bibr" target="#b4">(Bourgaux et al. 2022</ref>) because we needed to craft a specific semiring to get a counterexample.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Complexity Considerations and Conclusion</head><p>In this paper, we present alternative provenance semantics for Datalog based on models, execution algorithms and derivation trees, and compare them through the lens of different properties. P NRT is the only one that satisfies all the studied properties but does not coincide with an execution based semantics contrary to the other tree-based semantics P AT , P MDT , and P HMDT . The equivalence between the tree-based P AT , P NRT and model-based P AM and P SAM definitions on absorptive semirings may also indicates a robust provenance on this restricted setting.</p><p>One of the main complexity sources of Datalog provenance stems from its infinite representation. <ref type="bibr" target="#b11">Deutch et al. (2014)</ref> studied semirings for which the provenance expressions given by P AT are finite, and showed that they can be represented by polynomial size circuits. We show that the annotations produced at each iteration of our execution algorithms can be represented by arithmetic circuits of polynomial size in the data <ref type="bibr" target="#b4">(Bourgaux et al. 2022)</ref>. Consequently, both P MDT and P HMDT can be represented by polynomial size circuits regardless of the semiring. On the contrary, we show that (assuming P = NP) there is no polynomially computable circuit that computes P NRT on N ∞ X , by a reduction from a result by <ref type="bibr" target="#b2">Arenas, Conca, and Pérez (2012)</ref>. Whether it is possible to polynomially compute circuits for P NRT on provenance semirings less expressive than N ∞ X but nonabsorptive remains open.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>The homomorphism definition is extended to conjunctions of atoms by viewing them as the sets of atoms they contain.A set I of facts is a model of a rule r := φ( x, y) → ψ( x), denoted by I |= r, if every homomorphism h from φ( x, y) to I is also a homomorphism from ψ( x) to I; it is a model of a Datalog program Σ if I |= r for every r ∈ Σ; it is a model of a database D if D ⊆ I. A fact α is entailed by D and Σ, denoted Σ, D |= α, if α ∈ I for every model I of Σ and D. Example 1. Let Σ contain the rules B(x) → A(x), R(x, y) ∧ A(y) → B(x), and R(x, y) → R(y, x), and D := {B(a), B(b), R(a, b), R(b, a)}. Each model of D and Σ contains all facts in D as well as A(a) and A(b), which are thus entailed by Σ, D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>a), S(a, b, c), S(a, c, b)}, then the fact α := H(a, a) has the following derivation trees</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Some derivation trees of A(a) in Example 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 6 .</head><label>6</label><figDesc>Let Σ = {A(x) → goal, B(x) → goal}, D = {A(a), B(a)}, λ N (A(a)) = 2 and λ N (B(a)) = 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>, D(a), E(a), F (a)} The three derivation trees of A(a) w.r.t. Σ and D are nonrecursive, but only the first two are of minimal depth and only the first one is a hereditary minimal-depth tree. (D, K, λ) is such that λ(C(a)) = c, λ(D(a)) = d, λ(E(a)) = e, and λ(F (a)) = f then P NRT (Σ, D, K, λ, A(a)) =c × d + d × e + d × f P MDT (Σ, D, K, λ, A(a)) =c × d + d × e P HMDT (Σ, D, K, λ, A(a)) =c × d</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>r.t. D, defined by Σ D = {h(φ( x, y)) → h(H( x)) | φ( x, y) → H( x) ∈ Σ, h : x ∪ y → D(D)}. It holds that Σ, D |= α if and only if Σ D , D |= α. Property 9 (Parsimony). If α ∈ D does not occur in any rule head in Σ D then P(Σ, D, K, λ, α) = λ(α).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Example 10. Let Σ = {C(x) → B(x), D(x) → A(x)}, D = {B(a), C(a), D(a)} and λ(B(a)) = b, λ(C(a)) = c, λ(D(a)) = d, and consider Σ = Σ ∪ {A(a) ∧ B(a) → goal}. P MDT (Σ , D, K, λ, goal) = b × d + c × d while P MDT (Σ, D, K, λ, A(a)) = d and P MDT (Σ, D, K, λ, B(a)) = b. Hence P MDT does not satisfy the Joint Use Property.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(iii) P(∅, D, N ∞ , λ N , A(a)) + P(∅, D, N ∞ , λ N , B(a)) = 4 so P does not satisfy the Alternative Use nor the Joint and Alternative Use Property. (iv) Since P(Σ, {A(a)}, N ∞ , λ N , goal) + P(Σ, {B(a)}, N ∞ , λ N , goal) = 4 is strictly greater than P(Σ, D, N ∞ , λ N , goal), P does not satisfy the Insertion Property.Moreover, P SAM does not satisfy the Joint Use Property. Example 13. LetΣ = {A(x) → g 1 , A(x) → g 2 , B(x) → g 1 , B(x) → g 2 } D = {A(a), B(a)} with λ X (A(a)) = x, λ X (B(a)) = y.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>P</head><label></label><figDesc>AT P NRT P MDT P HMDT P AM P SAM</figDesc><table><row><cell>Algebra Consistency</cell></row><row><cell>Boolean Compat.</cell></row><row><cell>Com. with Hom.</cell></row><row><cell>Com. with ω-Cont.</cell></row><row><cell>Any Semiring</cell></row><row><cell>Any ω-Cont. Sem.</cell></row><row><cell>Joint and Alt. Use</cell></row><row><cell>Joint Use</cell></row><row><cell>Alternative Use</cell></row><row><cell>Self</cell></row><row><cell>Parsimony</cell></row><row><cell>Necessary Facts</cell></row><row><cell>Non-Usable Facts</cell></row><row><cell>Insertion</cell></row><row><cell>Deletion</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Does a property hold for a provenance semantics?</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that we do not require the set of predicates of atoms appearing in heads of rules to be disjoint from S(D); naturally, all of our results are valid under this assumption as well.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>This work is supported by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_VYVpUmp">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Fuzzy extension of datalog</title>
		<author>
			<persName><forename type="first">Á</forename><surname>Achs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Cybern</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="153" to="166" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Counting beyond a yottabyte, or how SPARQL 1.1 property paths will prevent adoption of the standard</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Conca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st World Wide Web Conference 2012</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Mille</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Misselis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rabinovich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Staab</surname></persName>
		</editor>
		<meeting>the 21st World Wide Web Conference 2012<address><addrLine>WWW; Lyon, France</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012-04-16">2012. 2012. April 16-20, 2012</date>
			<biblScope unit="page" from="629" to="638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Provenance for the description logic elhr</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ozaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Peñaloza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Predoiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI 2020</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Bessiere</surname></persName>
		</editor>
		<meeting>the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI 2020</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1862" to="1869" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Revisiting semiring provenance for Datalog</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Peterfreund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
		<idno>arxiv.org/abs/2202.10766</idno>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Enriching ontology-based data access with provenance</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ozaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Peñaloza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJ-CAI 2019</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kraus</surname></persName>
		</editor>
		<meeting>the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJ-CAI 2019<address><addrLine>Macao, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08-10">2019. August 10-16, 2019</date>
			<biblScope unit="page" from="1616" to="1623" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Explanations for query answers under existential rules</title>
		<author>
			<persName><forename type="first">İ</forename><forename type="middle">İ</forename><surname>Ceylan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Malizia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vaicenavicius</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJ-CAI 2019</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kraus</surname></persName>
		</editor>
		<meeting>the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJ-CAI 2019<address><addrLine>Macao, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08-10">2019. August 10-16, 2019</date>
			<biblScope unit="page" from="1639" to="1646" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Explanations for ontology-mediated query answering in description logics</title>
		<author>
			<persName><forename type="first">İ</forename><forename type="middle">İ</forename><surname>Ceylan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Malizia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Vaicenavicius</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECAI 2020 -24th European Conference on Artificial Intelligence</title>
		<title level="s">Frontiers in Artificial Intelligence and Applications</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Catalá</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Dilkina</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Milano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Barro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Bugarín</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</editor>
		<meeting><address><addrLine>Santiago de Compostela, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2020-08-29">2020. 29 August-8 September 2020</date>
			<biblScope unit="volume">325</biblScope>
			<biblScope unit="page" from="672" to="679" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Provenance in databases: Why, how, and where. Found</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends Databases</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="379" to="474" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Tracing the lineage of view data in a warehousing environment</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Wiener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="227" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Semiring provenance for fixed-point logic</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">M</forename><surname>Dannert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Grädel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Naaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th EACSL Annual Conference on Computer Science Logic, CSL 2021</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Baier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Goubault-Larrecq</surname></persName>
		</editor>
		<meeting><address><addrLine>Ljubljana, Slovenia (Virtual Conference</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2021-01-25">2021. January 25-28, 2021</date>
			<biblScope unit="volume">183</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Circuits for datalog provenance</title>
		<author>
			<persName><forename type="first">D</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th International Conference on Database Theory (ICDT)</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Schweikardt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Christophides</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Leroy</surname></persName>
		</editor>
		<meeting>17th International Conference on Database Theory (ICDT)<address><addrLine>Athens, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-03-24">2014. March 24-28, 2014</date>
			<biblScope unit="page" from="201" to="212" />
		</imprint>
	</monogr>
	<note>OpenProceedings.org</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient provenance tracking for datalog using top-k queries</title>
		<author>
			<persName><forename type="first">D</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gilad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Moskovitch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="245" to="269" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Solving fixedpoint equations by derivation tree analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luttenberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebra and Coalgebra in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Corradini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Klin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Cîrstea</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The semiring framework for database provenance</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Sallinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">V</forename><surname>Den Bussche</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Geerts</surname></persName>
		</editor>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017-05-14">2017. May 14-19, 2017</date>
			<biblScope unit="page" from="93" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</editor>
		<meeting>the Twenty-Sixth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007-06-11">2007. June 11-13, 2007</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Containment of conjunctive queries on annotated relations</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Database Theory -ICDT 2009, 12th International Conference</title>
		<title level="s">ACM International Conference Proceeding Series</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</editor>
		<meeting><address><addrLine>St. Petersburg, Russia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009-03-23">2009. March 23-25, 2009</date>
			<biblScope unit="volume">361</biblScope>
			<biblScope unit="page" from="296" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Foundations of information integration under bag semantics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hernich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">32nd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2017</title>
		<meeting><address><addrLine>Reykjavik, Iceland</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017-06-20">2017. June 20-23, 2017</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The magic of duplicates and aggregates</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Mumick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">16th International Conference on Very Large Data Bases</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Mcleod</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Sacks-Davis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Schek</surname></persName>
		</editor>
		<meeting><address><addrLine>Brisbane, Queensland, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-08-13">1990. August 13-16, 1990</date>
			<biblScope unit="page" from="264" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Morgan</forename><surname>Kaufmann</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The bag semantics of ontology-based data access</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nikolaou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Sierra</surname></persName>
		</editor>
		<meeting>the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-08-19">2017. August 19-25, 2017</date>
			<biblScope unit="page" from="1224" to="1230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Foundations of ontology-based data access under bag semantics</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nikolaou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">274</biblScope>
			<biblScope unit="page" from="91" to="132" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Provenance and probabilities in relational databases</title>
		<author>
			<persName><forename type="first">P</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="5" to="15" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<author>
			<persName><surname>Soufflé</surname></persName>
		</author>
		<ptr target="https://souffle-lang.github.io/index.html" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Weighted monadic datalog</title>
		<author>
			<persName><forename type="first">T</forename><surname>Stüber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Vogler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">403</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="221" to="238" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Debugging largescale datalog: A scalable provenance evaluation strategy</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Subotic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Scholz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
