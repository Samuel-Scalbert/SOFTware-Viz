<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Inference of Shape Graphs for Graph Databases</title>
				<funder ref="#_Px7jfuH">
					<orgName type="full">Polish National Science Center</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Benoît</forename><surname>Groz</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Aurélien</forename><surname>Lemay</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sławek</forename><surname>Staworko</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Piotr</forename><surname>Wieczorek</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University Paris Sud</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Lille</orgName>
								<address>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University of Lille</orgName>
								<address>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Wrocław</orgName>
								<address>
									<settlement>Wrocław</settlement>
									<country key="PL">Poland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department" key="dep1">Leibniz International Proceedings</orgName>
								<orgName type="department" key="dep2">Informatics Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
								<orgName type="department" key="dep3">Dagstuhl Publishing</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Inference of Shape Graphs for Graph Databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C309DEA3518D40ED49D2861893E17FCD</idno>
					<idno type="DOI">10.4230/LIPIcs.ICDT.2022.7</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>2012 ACM Subject Classification Information systems → Graph-based database models Keywords and phrases RDF</term>
					<term>Schema</term>
					<term>Inference</term>
					<term>Learning</term>
					<term>Fitting</term>
					<term>Minimality</term>
					<term>Containment. Digital Object Identifier 10.4230/LIPIcs.ICDT.2022.7</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We investigate the problem of constructing a shape graph that describes the structure of a given graph database. We employ the framework of grammatical inference, where the objective is to find an inference algorithm that is both sound, i.e., always producing a schema that validates the input graph, and complete, i.e., able to produce any schema, within a given class of schemas, provided that a sufficiently informative input graph is presented. We identify a number of fundamental limitations that preclude feasible inference. We present inference algorithms based on natural approaches that allow to infer schemas that we argue to be of practical importance.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Traditionally, in relational databases, defining the schema is the mandatory first step before a database can even be populated with data. However, novel database models, such as graph databases, quite intentionally allow to store and process data without declaring any schema. This facilitates the evolution of the structure of a database while the applications around it are being developed. In fact, often a suitable schema formalism is proposed after a particular database model has established its place in practice. In those circumstances a natural problem of schema inference arises: given a schema-less database construct a schema that captures the structure of the database. This problem has been identified as an important research direction <ref type="bibr" target="#b0">[1]</ref> and is well motivated since the knowledge of database structure is instrumental in any meaningful data processing task such as querying or transformation.</p><p>In the present paper, we present a principled approach to the problem of schema inference for graph databases. We consider RDF graphs and Shape Expression Schemas (ShEx) <ref type="bibr" target="#b54">[55,</ref><ref type="bibr" target="#b46">47]</ref>. ShEx builds on the success of XML Schema and allows to describe the structure of an RDF graph by defining patterns of arrangement of RDF nodes. More precisely, ShEx specifies a collection of node types, each type defined by a regular expression that constrains the types of the outbound neighborhood of a node. Take for instance the RDF graph storing bug reports, presented in Figure <ref type="figure">1</ref> together with its shape expression schema. The schema requires a bug report to have a description and a user who submitted it. Optionally, a bug report may have an employee who verified it. Also, a bug report can have a number of related bug reports. A user has a name and an optional email address while an employee has a name and a mandatory email address. We point out that just like with XML Schema the Bug → descr : str, submittedBy : User, verifiedBy : Employee?, related : Bug* User → name : str, email : str? Employee → name : str, email : str Figure <ref type="figure">1</ref> An RDF graph with bug reports (top right) together with a shape expression schema (bottom) and the corresponding shape graph (top left). str is a built-in type for literal string nodes.</p><p>nodes of the RDF graph need not be typed and it is the task of a validation algorithm to find a valid node typing <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b46">47]</ref>. Furthermore, some nodes may need to be assigned more than one type, for instance the node emp 1 needs to satisfy the types User and Employee.</p><p>We focus our investigation on a practical subclass ShEx 0 that defines types with collections of atoms with arities ranging over 1, ?, +, and *. This fragment does not allow disjunction or union types but can adequately approximate schemas with those features. ShEx 0 is particularly suited to capture the topology of RDF graphs obtained by exporting relational databases in a number of formalisms proposed for this task, such as R2RML, Direct Mapping, and YARRRML <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b12">13]</ref>. More importantly, the class ShEx 0 enjoys a sought-after feature of an equivalent graphical representation in the form of a shape graph whose nodes are types and edges are labeled by a symbol and a multiplicity (see Figure <ref type="figure">1</ref>).</p><p>We present a principled approach to the problem of graph database schema inference, where we start with the fundamental question: What is an inference algorithm?. We answer it using the framework of grammatical inference <ref type="bibr" target="#b27">[28]</ref>, which in recent years has been successfully applied to a number of database formalisms ranging from queries <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b47">48]</ref> to schemas <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b21">22]</ref> and transformations <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b35">36]</ref>. In essence, an inference algorithm needs to be both sound, i.e., produce a schema that validates the input graph, and complete, i.e., able to infer any goal schema with a sufficiently informative input graph. This formal framework allows us to tackle another fundamental question: When is inference feasible? Indeed, we identify classes of schemas that are not learnable, which reveals two principal challenges in schema inference: 1) distinguishing unbounded arities * and + from bounded ones 1 and ?, and 2) distinguishing recursive types from their finite non-recursive unravelings.</p><p>A suitable ShEx 0 inference algorithm needs to identify the types and their definitions. ShEx 0 assigns to every node of a graph a set of types by using the notion of embedding, which is an extension of the standard graph simulation. Consequently, our first attempt is to use graph simulation to identify sets of nodes whose outbound neighborhood shares structural similarity, and therefore, should have the same type. Interestingly, this approach yields a very reasonable inference algorithm that generalizes the structural information of the input graph, and in particular, easily introduces recursion in the constructed schema. The generalization is however very eager, and in particular, the algorithm clumps together any two types that are related by subtype relation such as Employee ⊆ User where every node of type Employee has also type User. Indeed, this inference algorithm produces a shape that is singular, having no two types that cannot be distinguished with the help of simulation, and consequently it prohibits schemas with subtypes like the schema in Figure <ref type="figure">1</ref>.</p><p>To address this shortcoming we investigate using the context in which nodes are used: their inbound neighborhood. Indeed, the nodes of type User and the nodes of type Employee are used in different contexts, although their use may partially overlap e.g., the node emp 1 is used both as an employee and as a user. An inference algorithm based on using context information constructs a schema that belongs to the class of deterministic shape graph, which permits every edge label to be present at most once in a type definition. This class of schemas is incomparable with singular shape graph. For instance, the schema in Figure <ref type="figure">1</ref> is deterministic but is not singular. We find, however, that an indiscriminate use of the context information leads to overfitting, and in particular, it may fail to introduce recursion and may produce voluminous schemas. It appears that an inference algorithm must choose carefully the information to identify the set of types. We propose, as a proof of concept, a hybrid inference algorithm that extends the simulation-based approach with a modest amount of context information that consists of a single incoming edge. This algorithm produces schemas that are context-singular, a generalization of singular schemas that allows subtyping between types used in different contexts.</p><p>Finally, we survey a number of graph databases and inspect their schemas. Our analysis shows that ShEx 0 and the proposed subclasses lack certain features present in real-world schemas, most notably union types, but we can approximate them very well. This makes our algorithms an excellent solution for preparing the first draft of a schema to be refined by a knowledgeable architect.</p><p>Organization. The paper is organized as follows. In Section 2 we present basic notions, including shape graphs and their embeddings. In Section 3 we formally state the problem of inference. In Section 4 we present a simulation-based inference algorithm for the class of singular shape graphs. In Section 5 we present negative implications of unrestrained use of context information in inference. In Section 6 we propose a hybrid approach combining the simulation-based approach with elements of context information. In Section 7 we present an analysis of schemas of a number of graph databases. We discuss related work in Section 8. We summarize our findings and outline future research directions in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Basic notions</head><p>Throughout this paper we apply a functional notation to relations, and conversely, often view functions as relations. For instance, for a binary relation</p><formula xml:id="formula_0">R ⊆ A × B we set dom(R) = {a ∈ A | ∃b ∈ B. (a, b) ∈ R}, ran(R) = {b ∈ B | ∃a ∈ A. (a, b) ∈ R}, R(a) = {b ∈ B | (a, b) ∈ R} for a ∈ A, and R -1 (b) = {a ∈ A | (a, b) ∈ R} for b ∈ B.</formula><p>Intervals. We use the standard notation [i; j] for 0 ≤ i ≤ j ≤ ∞ to denote intervals that represent nonempty sets of consecutive natural numbers. By I 0 we denote the set of all intervals. Our schema formalisms use only four basic intervals (M 0 ) given with their shorthand notation: Graphs and schemas. We employ a generic model of a graph that we use to model both RDF and the subclass ShEx 0 that allows type definitions consisting of collections of atoms using basic intervals <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b48">49]</ref>. Our methods do not inspect data values of literal nodes, and consequently, we will abstract them using their type alone but this requires us to record the number of some types of edges as illustrated in Figure <ref type="figure" target="#fig_8">2a</ref>.  When drawing graphs we typically omit the label 1 and simple intervals are denoted with natural numbers e.g., 2 stands for [2; 2] which indicates two identical edges. We point out a dichotomy of node kinds and their types: literal nodes can only have literal types and non-literal nodes can only have non-literal types. While it might be tempting to remove literal types from consideration and focus on data-free graphs, we keep literal types and nodes because without them it is difficult to define reasonable schema families without subtypes.</p><formula xml:id="formula_1">1 is [1; 1], ? is [0; 1], + is [1; ∞] and * is [0; ∞]. A simple interval has the form [i; i] for 0 ≤ i &lt; ∞,</formula><p>We assume a finite set Σ of edge labels and an enumerable set of node identifiers N = U ∪L, where U is an infinite set of identifiers used to represent both URIs and blank nodes, and L is a finite set of types of literal nodes e.g., str representing strings. We assume that U ∩ L = ∅.</p><formula xml:id="formula_2">Definition 1. A graph G is a triple (N G , E G , arity G ), where N G ⊆ N is a finite set of nodes, E G ⊆ (N G ∩ U) × Σ × N G</formula><p>is a set of labeled oriented edges, and arity G maps every edge to an interval. A shape graph is a graph that uses only basic intervals and by ShEx 0 we denote the set of all shape graphs. A simple graph is a graph that assigns to every edge a simple interval and this simple interval is 1 unless the edge leads to a node in L. By G 0 we denote the set of simple graphs. A simple graph G is data-free if N G ∩ L = ∅.</p><p>In Figure <ref type="figure" target="#fig_8">2b</ref> we present a more concise version of the graphs from Figure <ref type="figure">1</ref> adapted to our graph model. For M ⊆ M 0 , we write ShEx 0 (M ) to restrict the choice of arities to M . For an edge e = (n, p, m) we let source(e) = n, lab(e) = p, and target(e) = m. For a given node n of G we identify its outbound neighborhood out G (n) = {e ∈ E G | source(e) = n}. Given two graphs G 1 and G 2 by G 1 G 2 we denote their disjoint union. In the sequel, we often refer to shape graphs as schemas and their nodes as types. We also abuse the standard tree terminology and say that nodes n and n are siblings if there is a node m that has outgoing edges to n and to n .</p><p>Embeddings. We recall next, and illustrate in Figure <ref type="figure" target="#fig_8">2b</ref>, the notion of embedding that allows to define the semantics of shape graphs as schemas <ref type="bibr" target="#b48">[49]</ref> and is instrumental in our inference methods. Here, by id A we denote the identity relation on a given set A.</p><p>Definition 2 (Embedding). <ref type="bibr" target="#b48">[49]</ref> An </p><formula xml:id="formula_3">embedding of a graph G in a graph H is a binary relation R ⊆ (N G × N H ) ∩ (U × U ∪ id L ) such that for any (n, m) ∈ R</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>for every e ∈ out G (n) we have that (target(e), target(λ(e))) ∈ R. The embedding R is total if dom(R) = N G . We write G H if there exists a total embedding of G in H. An autoembedding of G is an embedding of G in itself. Figure <ref type="figure" target="#fig_8">2b</ref> presents an example of the embedding between the concise versions of RDF graph and the shape graph in Figure <ref type="figure">1</ref>. It is known that there exists exactly one maximal embedding between two graphs <ref type="bibr" target="#b46">[47]</ref> (since the union of embeddings is also an embedding), and constructing maximal embeddings between pairs of shape graphs and between simple graphs and shape graphs is in P <ref type="bibr" target="#b48">[49]</ref>. In the sequel, by G:H we denote the maximal embedding of G in H, by G the maximal autoembedding of G, and we use both relation symbols using infix notation. The language of a shape graph H is L(H) = {G ∈ G 0 | G H}. We recall from <ref type="bibr" target="#b48">[49]</ref>, that embeddings can be composed, and in particular, G H implies L(G) ⊆ L(H), but the converse does not necessarily hold as illustrated in Figure <ref type="figure" target="#fig_3">3</ref>.  Throughout the paper we use the following terminology. A simple graph G satisfies a shape graph H, and H recognizes G, iff G ∈ L(H). Two shape graphs H and K are equivalent, in symbols</p><formula xml:id="formula_4">H ≡ K, iff L(H) = L(K). A node n of a simple graph G has type t of a shape graph H iff n G:H t. Given two types t 1 and t 2 of a shape graph H, a type t 1 is a subtype of t 2 , in symbols t 1 ⊆ H t 2 , iff ∀G ∈ L(H). ∀n ∈ N G . n G:H t 1 ⇒ n G:H t 2 . Finally, a type t of H is recursive iff it is part of a loop in H.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Inference of shape graphs</head><p>In this section we introduce the framework of grammatical inference, present a number of limit point arguments that help to identify main challenges in inferring shape graphs, and finally, we present the construction of graph aggregation that we use to infer shape graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Grammatical inference</head><p>In this paper we investigate the problem of shape graph inference, which consists of constructing a shape graph for a given input simple graph. To this end we adopt the framework of grammatical inference <ref type="bibr" target="#b27">[28]</ref>, which has originally been proposed for word languages and has been successfully applied to a number of database formalisms ranging from queries <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b47">48]</ref> to schemas <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b21">22]</ref> to transformations <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b35">36]</ref>. In essence, the framework requires the inference algorithm to be capable of inferring any goal schema given a sufficiently informative input. We are interested in inference from positive data: the input consists of a graph that belongs to the goal language. To prevent collusion, namely a solution where a characteristic input graph encodes the goal schema using an elaborate scheme, the inference algorithm is required to be robust under extension: it must infer the goal schema even if the characteristic graph is accompanied by other potentially less informative graphs that satisfy the schema. Formally, G extends G consistently with schema</p><formula xml:id="formula_5">H iff there is G such that G = G G and G, G , G ∈ L(H).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. A class of shape graphs C is learnable from a class of graphs G iff there is an inference algorithm learner such that Soundness For every input graph G ∈ G the inference algorithm returns a schema learner(G) = H such that H ∈ C and G ∈ L(H). Completeness For every goal schema H ∈ C there exists a characteristic graph G H ∈ L(H)</head><p>such that for any G that extends G H consistently with H we have learner(G) ≡ H. Furthermore, we say that C is learnable in polynomial time if the inference algorithm works in polynomial time. We also say that C is learnable in polynomial data if there exists a polynomial that bounds the size of the characteristic graph as a function of the size of the goal schema.</p><p>As an illustrative example of grammatical inference consider the problem of inferring basic intervals M 0 from a given sample of its members {i 1 , . . . , i k }. Take the function fit M0 that returns the smallest basic interval that contains all the elements given on the input. Naturally, fit M0 is a sound inference algorithm since it returns an interval that contains all the elements given on the input. It is also a complete inference algorithm because we can construct characteristic samples for every element of M 0 . For instance, for the goal interval</p><formula xml:id="formula_6">+ = [1; ∞] a characteristic sample is {1, 2}. Indeed, fit M0 ({1, 2}) = + but more importantly fit M0 (X) = + for any X subset of [1; ∞] that includes {1, 2}.</formula><p>Now, consider the full class of intervals I 0 and take the function fit I0 as a inference algorithm. It is naturally sound since fit I0 (X) = [min(X); max(X)] but it is not complete since it cannot infer an unbounded interval [i 0 ; ∞] from a finite input set. In fact, I 0 is not learnable because one can show that there is no sound and complete inference algorithm for I 0 (from positive samples alone). Next, we present a general characterization of classes of languages that are not learnable. We will use it as a tool for identifying key challenges in schema inference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Limit point</head><p>We recall that a class of languages C has the limit point property iff C contains an ascending chain of languages L 1 L 2 . . . whose limit point L ∞ = i L i also belongs to C. It is a folklore result that the limit point property precludes learnability (from positive examples) <ref type="bibr" target="#b1">[2]</ref>: essentially, no finite amount of examples from the goal language allows to distinguish between the limit point L ∞ and some language L i in the ascending chain. We formally show that it also holds for the framework we adopt in this paper. Proposition 4. No class of shape graphs with the limit point property is learnable from simple graphs.</p><p>The limit point argument allows us to identify a number of limitations of inference of shape expressions schemas. Lemma 5. For any M ⊆ {1, ?, *, +} with at least two elements the class ShEx 0 (M ) has the limit point property.</p><p>Proof sketch. It suffices to consider sets of 2 multiplicities and in Figure <ref type="figure" target="#fig_5">5</ref> we present three cases. The limit point arguments for all remaining cases are constructed very similarly to  ShEx(?, *) in Figure <ref type="figure" target="#fig_5">5a</ref> (details in appendix).</p><formula xml:id="formula_7">L 0 : L 1 : a?</formula><p>Consequently, we obtain the following corollary.</p><p>Corollary 6. ShEx 0 is not learnable from simple graphs.</p><p>A closer look at the limit point arguments offers an insight into the reasons why inferring ShEx 0 is not feasible. Firstly, we observe in Figure <ref type="figure" target="#fig_5">5a</ref> that one of the challenges in distinguishing between L i and L ∞ is in deciding based on finite input example when to use unbound arity * as opposed to ? (similar argument holds for + and ?, etc.). Secondly, in Figures <ref type="figure" target="#fig_5">5b</ref> and<ref type="figure" target="#fig_5">5c</ref> we observe an analogous difficulty in deciding between other pairs of arities, but more importantly, we also observe a different difficulty: whether to choose a simple recursive type (L ∞ ) or allow some arbitrary non-recursive unfolding of it (L i ). To summarize, the constructions in Figure <ref type="figure" target="#fig_5">5</ref> point to two key challenges of inferring shape schemas for graph databases: 1) distinguishing between bounded and unbounded arities, and 2) introducing recursive types especially from a possibly acyclic input example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Graph aggregate</head><p>The inference algorithms that we propose in this paper construct schemas with an operation that generalizes the standard graph quotient. Recall that the graph quotient operation essentially reduces to a single node every set of nodes that are equivalent w.r.t. a given equivalence relation. In the context of schema inference, we are interested in grouping together nodes that we deem to have the same type but we point out that the underlying relation "n and m are deemed to have the same type" needs not be transitive in general. In fact, we do not even assume that this relation is reflexive because we may wish to intentionally ignore nodes of the input graph that we do not find informative enough. </p><formula xml:id="formula_8">Definition 7. A node grouping of a simple graph G = (N G , E G , arity G ) is a collection P ⊆ 2 N G of sets of nodes of G such that any N ∈ P with N ∩ L = ∅ is a singleton. Given</formula><formula xml:id="formula_9">N H = P, E H = {(N, a, N ) ∈ P × Σ × P | ∃(n, a, n ) ∈ E G , n ∈ N ∧ n ∈ N }, arity H (N, a, N ) = fit M {arity G (n, a, n ) | n ∈ N , (n, a, n ) ∈ E G } | n ∈ N .</formula><p>The requirement N ∩ L = ∅ follows from the dichotomy of node kinds and their types. To ensure that the aggregate is technically a (shape) graph, we assume that any subset of N is also a node identifier and for any ∈ L we interpret { } as . In the sequel, when the set of intervals M is known from the context, we omit it in the aggregate and simply write G ÷ P .</p><p>In essence, for a given input graph G, our inference algorithms explore the lattice (P G , ) of all node groupings P G of G from</p><formula xml:id="formula_10">P ⊥ = {{n} | n ∈ N G } to P = {N G \ L}∪{{ } | ∈ N G ∩L}.</formula><p>The structure of this lattice is consistent with the containment relation:</p><formula xml:id="formula_11">P 1 P 2 iff G ÷ P 1 ⊆ G ÷ P 2 .</formula><p>This connection to containment is essential for guiding inference algorithms with characteristic graphs. When the goal schema is G ÷ P for a node grouping P then for every relevant P P the characteristic graph needs to contain an example showing G ÷ P ⊇ G ÷ P .</p><p>Example 8. Consider G 0 and H 0 in Figure <ref type="figure" target="#fig_8">2b</ref>, and take the node grouping that corresponds to the typing of G 0 w.r.t.</p><formula xml:id="formula_12">H 0 : P = {{b 1 , b 2 , b 3 , b 4 }, {u 1 , u 2 , e 1 }, {e 1 }, {str}}. The aggregate G 0 ÷ M0 P is in fact (equivalent to) H 0 .</formula><p>The above example shows that G 0 carries sufficient information that with the right partition allows to infer the goal schema H 0 .</p><p>The task is to identify a method that allows to group nodes of the input graph that are deemed to have the same type and at the same time can introduce unbounded arities and recursion in type definitions. A natural attempt at grouping nodes of a graph would be to use bisimulation. But as we illustrate in Figure <ref type="figure" target="#fig_4">4</ref> this fails to introduce unbounded arities and recursive types. In fact, it has been studied in the literature <ref type="bibr" target="#b26">[27]</ref> and found to fail to generalize appropriately the input graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Singular shape graphs</head><p>In this section we address the two key challenges of inference by grouping nodes with the help of graph simulation relation. This yields an inference algorithm for a subclass of singular shape graphs. The inference algorithm allows to infer unbounded arities and recursive types even from acyclic input graph. The price is the ability to distinguish types from their subtypes. Shape graphs assign types to nodes using an embedding, which is an adaptation of the standard notion of graph simulation. Consequently, we explore an approach of grouping together nodes that are comparable with the simulation relation. To that effect, for a given simple graph G we construct the graph G* by changing the arity of every edge to *, and then, any autoembedding of G* is a simulation relation on G and vice versa. Hence, we use the maximal autoembedding G* to assess the relative amount of schema information that a node supplies: if m G* n, we consider m to provide no more schema information than n does. We introduce useful short-hands. We say that n sim-dominates m iff m G* n and m = n. Also, n properly sim-dominates m is n sim-dominates m and n G* m. We say that n and m are sim-equivalent if m G* n and n G* m. Finally, a node is sim-maximal if it is sim-dominated only by sim-equivalent nodes.</p><p>Using simulation to group nodes has an important drawback: the inability to distinguish types from their subtypes. Indeed, if t 1 ⊆ t 2 , then any node that has type t 1 is simulated by nodes of type t 2 that characterize the type t 2 . We return to this problem in Section 6 where we show how to handle inference of restricted cases of subtypes. We point out that permitting arbitrary subtypes allows to construct ascending chains, which can be then easily used in limit point arguments, as evidenced for instance in Figure <ref type="figure" target="#fig_5">5b</ref>. This allows us to conclude that inferring subtypes is inherently problematic. Furthermore, we show that even forbidding subtypes does not suffice to guarantee learnability. Proposition 9. Let FlatShEx 0 be the subclass of shape graphs where no two different types are comparable by the containment relation. For any subset M ⊆ M 0 with at least two elements FlatShEx 0 (M ) is not learnable.</p><p>Consequently, stronger restrictions are needed and we propose the class of singular schemas whose types can all be distinguished with the graph simulation relation. Definition 10. A type t of a shape graph H is singular iff t is not sim-dominated by any type in H. A shape graph is singular iff it has only singular types and by SinShEx 0 we denote the set of all singular shape graphs.</p><p>Intuitively, singularity ensures that for any two types t 1 and t 2 , there exist nodes of type t 1 that can be distinguished from all nodes of type t 2 with the help of simulation. In the following example we show that simulation needs to be used carefully when identifying groups of nodes of the same type.</p><p>Example 11. To keep the example simple, we limit the intervals used in shape graphs to {1, ?, *}. In figures we use a dotted green arrow n m to indicate that n simdominates m. Take the graph G 2 in Figure <ref type="figure" target="#fig_6">6</ref>, identify its sim-maximal nodes Max = {n 0 , n 1 , n 2 , str}, and consider the node grouping P 0 = {{n 0 }, {n 1 }, {n 2 }, {str}}. This grouping is too sparse: the aggregate G 2 ÷ P 0 does not recognize G 2 . Consider then the grouping where every sim-maximal node is accompanied by all sim-dominated nodes: The node grouping P max is not a good starting point for an inference algorithm because it might be overly eager as we illustrate next. Consider the graph G 3 in Figure <ref type="figure">7</ref>. The node m 2 is sim-dominated by m 1 and m 3 . The grouping P max = {{m 0 }, {m 1 , m 2 }, {m 2 , m 3 , m 4 }, {str}} forces * on the edge from {m 0 } to {m 1 , m 2 }. It is, however, not necessary to add m 2 to any group: P 1 = {{m 0 }, {m 1 }, {m 3 , m 4 }, {str}} already yields H 3 that is singular, recognizes G 3 , and is a tighter fit than G 3 ÷ P max . merge S and T in P 10: return G ÷ M P end only groupings where every sim-maximal node n belongs to precisely one node group, which can be accessed with a lookup operation P [n]. The algorithm begins by identifying all sim-maximal nodes (line 1) and grouping together all sim-equivalent nodes (lines 2-4). Next, as long as the aggregate G ÷ M P does not recognize the input graph, the algorithm iteratively identifies a node m that is absorbed by a node group P [n] such that m ∈ P [n] (lines 5-7). Among all eligible pairs of m and P [n] we choose one according to the following order Φ: 1. siblings first any m that has a sibling n ∈ Max such that P [n] contains all siblings of m that sim-dominate it. Finally, the algorithm merges any node groups that prevent the shape graph G ÷ M P from being singular (lines 8-10). We point out that the preference order Φ may indicate multiple equally preferred pairs and the algorithm may choose an arbitrary one: regardless of the choice the output always recognizes the input graph and when the input contains a characteristic graph, the algorithm will always converge on the goal schema. Φ prevents the algorithm sim-learner from performing unnecessary generalization: when executed on the graph G 3 in Figure <ref type="figure">7</ref> it returns the schema H 3 . Furthermore, when run on G 2 in Figure <ref type="figure" target="#fig_6">6</ref> the algorithm returns the schema H 2 , which illustrates that it is capable of inferring recursive types even from acyclic input graphs.</p><formula xml:id="formula_13">P max = {{n 0 }, {n 1 , n 3 }, {n 2 , n 4 }, {str}}. While G 2 ÷ P max recognizes G 2 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I C D</head><p>In general the algorithm is sound for SinShEx 0 , but here we only claim that sim-learner 1,* is sound and complete for the shape graphs using 1 and *. Theorem 12. SinShEx 0 (1, *) is learnable in polynomial time and data from simple graphs.</p><p>In Section 6.2 we take advantage of Φ to show completeness for a larger class but it remains an open question if the full class of singular shape graphs is learnable in polynomial time and data (but the existing evidence suggests it is unlikely <ref type="bibr" target="#b48">[49]</ref>). The full class is however learnable with an algorithm that exhaustively explores the exponential space of possible singular shape graphs and uses an exponentially-large characteristic graph to help navigate this space.</p><p>Theorem 13. SinShEx 0 is learnable from simple graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Deterministic shape graphs</head><p>In this section we investigate the potential ramifications of attempting to improve the process of identifying the set of types by exploiting the context in which nodes are used in the graph. More precisely, two nodes n and n are used in the same context of node m and label a if there are two edges (m, a, n) and (m, a, n ), and in that case the nodes n and n should have the same type. Such premise leads us to the class of deterministic shape expressions schemas that allow at most one type to be used in a given context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 14.</head><p>A type t of a shape graph H is deterministic iff for every label a ∈ Σ the type t has at most one outgoing edge with label a. A deterministic shape graph has only deterministic types and by DetShEx 0 we denote the set of all deterministic shape graphs.</p><p>Interestingly, the powerset method for determinization of finite automata can be adopted for inference of DetShEx 0 . We illustrate this algorithm in Figure <ref type="figure" target="#fig_9">8</ref> but refrain from formally introducing it because we do not wish to promote it in this paper. Later in this section we provide its alternative semantic characterization that will allow us to identify the pitfalls of an indiscriminate use of context information for shape graph inference. Some caveats follow. Firstly, not every simple graph can be recognized by a deterministic shape graph. For instance, the graph G 1 in Figure <ref type="figure" target="#fig_8">2a</ref> satisfies no deterministic schema because G 1 has a node with two outgoing b-edges, one of which leads to a literal node and the other to a non-literal node. Consequently, we limit the inputs to data-free graphs, simple graphs with no literal nodes. Secondly, the limit point in Figure <ref type="figure" target="#fig_5">5b</ref> shows that DetShEx 0 is not learnable, and thus, we recall from <ref type="bibr" target="#b48">[49]</ref> a subclass DetShEx - 0 that we show learnable with the determinization algorithm. Formally, a reference to a type t ∈ N H is any edge e ∈ E H that leads to t i.e. target H (e) = t. A reference e is *-closed if arity H (e) = * or all references to source H (e) are *-closed. DetShEx - 0 is the class of deterministic shape graphs that do not use + and any type using ? is referenced at least once and all references to it are *-closed. Theorem 15. DetShEx 0 is not learnable from data-free graphs. DetShEx - 0 is learnable from data-free graphs in polynomial data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I C D T 2 0 2 2 7:12</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inference of Shape Graphs for Graph Databases</head><p>It can be proved (see appendix) that the determinization algorithm outputs the containmentminimal shape graph in DetShEx - 0 that satisfies the input data-free graph G. This makes the determinization algorithm an embodiment of the minicon principle which postulates for constructing the minimal consistent schema. This principle has a negative ramifications. Proposition 16. For any n there exists a graph G n of size quadratic in n such that the containment-minimal shape graph in DetShEx - 0 that validates G is of size exponential in n. We conclude that an indiscriminate use of the context information has negative impact on inference of shape graphs: the obtained schemas risk being too verbose and overfitted. Also, nontrivial classes of shape graphs are too rich to benefit from blindly following the minicon principle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Hybrid approach</head><p>In this section we pursue a hybrid approach that extends the simulation-based approach with a limited amount of context information to enable inference of shape graphs with subtypes.</p><p>We then identify the subclass that our hybrid algorithm is able to infer among shape graphs using arbitrary basic intervals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Context-singular shape graphs</head><p>We extend the simulation-based approach with context information limited to the labels of incoming edges. This allows to infer subtypes as long as they are used in different contexts.</p><p>For instance, this extension can infer the schema in Figure <ref type="figure">1</ref>, where Employee ⊆ User but Employee is used in the context of verifiedBy and User is used only in the context submittedBy.</p><p>Here, the contexts in which a type t is used in a shape graph H are described by the labels of incoming edges: ctx-lab H (t) = {a ∈ Σ | ∃s ∈ N H . (s, a, t) ∈ E H }. Singularity of shape graph requires that no type is sim-dominated by another type. We relax this by allowing a sim-dominated type as long as it is used in at least one context where none of its sim-dominating types are.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 17. Given a shape graph H, a type t of H is context-singular if and only if ctx-lab</head><formula xml:id="formula_14">H (t) ⊆ {ctx-lab H (t ) | t ∈ N H , t H* t , t = t }. H is context-singular if it</formula><p>has only context-singular types. CtxSinShEx 0 is the set of all context-singular shape graphs.</p><p>To adapt sim-learner to inference of context-singular shape graphs we introduce an uncoupling operation that for a given graph creates a distinct clone of a node for every of its incoming edges, so that all incoming edges of a node have the same label. Formally, the uncoupling of a graph G is Ḡ = (N Ḡ, E Ḡ, arity Ḡ), where</p><formula xml:id="formula_15">N Ḡ = {uncouple(n) | n ∈ N G }, uncouple(n) =        {n} if n ∈ L, {(⊥, n)} if ctx-lab G (n) = ∅, {(a, n) | a ∈ ctx-lab G (n)} otherwise, E Ḡ = {(η, a, trg(a, m)) | (n, a, m) ∈ E G , η ∈ uncouple(n)} trg(a, m) = m if m ∈ L, (a, m) otherwise, arity Ḡ(η, a, trg(a, m)) = arity G (n, a, m) for (n, a, m) ∈ E G and η ∈ uncouple(n).</formula><p>B. Groz, A. Lemay, S. Staworko, and P. Wieczorek</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:13</head><p>When each node has incoming edges with the same label, using the context information is simpler. For instance, a type t of an uncoupled shape graph H is context-singular iff there is no type t such that t H* t and ctx-lab H (t) ⊆ ctx-lab H (t ). Consequently, for uncoupled graphs we define a contextualized variant of the autoembedding relation:</p><formula xml:id="formula_16">n ctx K m iff n K m and ctx-lab K (n) ⊆ ctx-lab K (m).</formula><p>We adapt terminology and say that n ctxdominates m iff m ctx K n and n = m. Also, n is ctx-maximal if any node that ctx-dominates n is also ctx-dominated by n. Now, the inference algorithm hybrid-learner is a modification of sim-learner where we replace every occurrence of G by Ḡ and every occurrence of by ctx . We illustrate hybrid-learner on an example.</p><p>Example 18. We run hybrid-learner in Figure <ref type="figure" target="#fig_10">9</ref> on the graph G 0 introduced in Figure <ref type="figure" target="#fig_2">2</ref>. In the uncoupling of G 0 we indicate with m n that m ctx G0* n. In this example we use the complete set of basic intervals M 0 = {1, ?, +, *}. The algorithm begins with the node grouping P 0 = {{(r, b 1 )}, {(v, e 1 )}, {(s, e 1 ), (s, u 2 )}, {str}} obtained from the ctx-maximal nodes in G 0 . Because G 0 ÷ P 0 does not recognize G 0 , the algorithm uses Φ to identify nodes that can be absorbed: (r, b 4 ) can be absorbed in P 0 [(r, b 1 )] only. After this operation the node grouping P 1 still does not yield a shape graph that recognizes G 0 . In the next step, (r, b 3 ) being ctx-dominated by its sibling (r, b 4 ) is absorbed in P 1 [(r, b 1 )]. The resulting node grouping P 2 again fails to recognize G 0 . Finally, the node (s, u 1 ) is absorbed in P 2 [(s, e 1 )] and the resulting node grouping P 3 yields G 0 ÷ P 3 ≡ H 0 which recognizes G 0 .</p><formula xml:id="formula_17">Uncoupling G0 of G0 (r, b3)<label>(r, b1) (s, u1) (v, e1) (s, e1) (r, b4) (⊥, b2) (s, u2) str r</label></formula><p>The algorithm hybrid-learner is a sound inference algorithm for CtxSinShEx 0 and analogously to sim-learner it is also complete for CtxSinShEx 0 (1, *). The full class of context-singular shape graphs is learnable with an exhaustive exploration of the exponential search space with exponentially large characteristic graphs. Theorem 19. CtxSinShEx 0 (1, *) is learnable in polynomial time and data from simple graphs. CtxSinShEx 0 is learnable from simple graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Absorption-protected shape graphs</head><p>In this section we characterize the subclass of CtxSinShEx 0 , using all basic intervals M 0 = {1, ?, +, *}, for which hybrid-learner is sound and complete. To do that we first identify the information that needs to be contained in the input graph for hybrid-learner to infer the right arity on the edge of a the goal shape graph.</p><p>Let us fix a goal shape graph H and an edge (t, a, s) ∈ E H . For hybrid-learner to output H, it must be able to construct from a characteristic graph G two groups of nodes P t and I C D T 2 0 2 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:14</head><p>Inference of Shape Graphs for Graph Databases P s that characterize the interval arity H (t, a, s). In particular, they must contain sufficient information to indicate whether the interval is unbounded (+ and *) and whether it is nullable (? and *).</p><p>Characterizing an unbounded interval is relatively simple. It suffices to introduce in G a ctx-maximal node n t of type t that has at least two outgoing a-edges to nodes n s and m s of type s, one of which, say n s should also be ctx-maximal. Naturally, the nodes n t and n s will be put by hybrid-learner in the groups P t and P s respectively. Because of the first rule of the preference order Φ, the node m s will also be added to P m .</p><p>Characterizing a nullable interval is more challenging since it requires making sure that P t and P s absorb information that is more volatile. Namely, we need to make sure that G has a ctx-maximal node n t and a node m t of type t without any a-edge to a node of type s. Since n t is ctx-maximal, it will be absorbed in P t but since m t is not a ctx-maximal node, G must protect it from being absorbed by any group other than P t . The node m t can be absorbed into a group P s , representing a type s , if s dominates a version η of the type t from which we remove the edge (t, a, s). Naturally, m t is protected if no such node exists, and then the second rule of Φ ensures that m t ends up in P t . Otherwise, the type t allows protection from an absorption if t has an incoming edge with unbounded arity and none of the siblings of t dominate η. Then m t also ends up in P t because of the first rule of Φ for same reasons as explained for unbounded intervals.</p><p>To characterize the classes of schemas that allow protection from absorption we need to introduce a construction of the type η. Formally, let H be a shape graph H, η ∈ N \ N H a fresh node identifier, and e ∈ E H an edge from t to s with unbounded arity. The absorption-protection test graph APT * (H, e, η) is a shape graph H defined as:</p><formula xml:id="formula_18">N H = N H ∪{η}, E H = E H ∪{(η, a, s )|(t, a, s ) ∈ out H (t) \{e}}, arity H (f ) = * for f ∈ E H .</formula><p>Essentially, we add the type η, for every outgoing edge e from t other than e, we add an outgoing edge with the same label as e from η to the same node as the endpoint of e , and we set arities of all edges to *. Next, we formally characterize the class of shape graphs that hybrid-learner is capable of identifying (we use sim-domination because η in APT * (H, e, η) does not have any incoming edges). Definition 20. A type t of a shape graph H is absorption-protected iff for every edge e ∈ out H (t) with nullable arity one of the following conditions holds: 1. t is the only node that sim-dominates η in APT * (H, e, η) or, 2. t has an incoming edge with unbounded arity and t is the only node among its siblings that sim-dominates η in APT * (H, e, η). An absorption-protected shape graph is a context-singular shape graph that has only absorptionprotected types. By AbsShEx 0 we denote the set of all absorption-protected shape graphs.</p><p>We illustrate absorption protection in the following example.</p><p>Example 21. In Figure <ref type="figure">10</ref>, H 1 is not absorption-protected because of the edge e = (t 1 , a?, str). The copy η of t 1 without the edge e is sim-dominated by the type t 2 of H 1 . H 2 is absorption-protected. Even if for the type s 1 we create a copy η without the edge (s 1 , a?, str) and find it is sim-dominated by s 2 , the type s 1 has an incoming unbounded r-edge and the type s 2 is not a sibling of s 1 .</p><p>We point out that the shape graph in Figure <ref type="figure">1</ref> is absorption protected, which explains why in Example 18 the algorithm correctly infers the schema H 0 . We finish by formally stating the learnability result. Theorem 22. AbsShEx 0 is learnable in polynomial time and data from simple graphs. APT * (H1, e, η) where e = (t1, a?, str) H2 Figure <ref type="figure">10</ref> Two shape graphs, H1 is not absorption-protected because t1 is not, but H2 is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Schemas of existing graph databases</head><p>In this section we present an analysis (Table <ref type="table" target="#tab_5">1</ref>) of a number of graph databases in order to find out to what extent their schemas can be captured with shape graphs and the subclasses that we propose, and consequently, to assess the usefulness of the proposed inference algorithms.</p><p>We have analyzed: the Berlin SPARQL Benchmark <ref type="bibr" target="#b9">[10]</ref>, the Tpc-h benchmark converted to RDF with Direct Mapping <ref type="bibr" target="#b50">[51,</ref><ref type="bibr" target="#b53">54]</ref>, the Nobel Prize database <ref type="bibr" target="#b3">[4]</ref>, an RDF serialization of the Dblp database (retrieved from https://www.rdfhdt.org/datasets/ on 14.01.2021), the Springer Nature knowledge graph SciGraph <ref type="bibr" target="#b31">[32]</ref>, the Covid19 knowledge graph <ref type="bibr" target="#b42">[43]</ref>, and SHACL constraints in the version 4 of Yago knowledge base <ref type="bibr" target="#b49">[50]</ref>. For each database we have defined appropriate schemas using ShEx, which is a fully fledged schema language and properly contains ShEx 0 (cf. <ref type="bibr" target="#b46">[47]</ref>). Complete schemas and more details can be found in the appendix. We have found that the ShEx schemas for the above databases require the use of disjunction and union types, features that are absent in ShEx 0 <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b54">55]</ref>. We illustrate them on the following example inspired by DBLP. It states that a book has either creators (authors) or editors but never both, has a single title, and references an arbitrary number of articles and books. We say that this base type definition has 3 clauses, one uses disjunction, and one uses a union type. Union types are trivial when used only under * since a : (t 1 ∪ t 2 )* is equivalent to a : t 1 *, a : t 2 *. For every schema we have measured the quantities of the following objects: nontrivial (and trivial) union types, clauses, clauses with disjunction, clauses with nontrivial (and trivial) use of a union type.</p><p>To help assessing the usefulness of the proposed inference algorithms, for every ShEx schema we have constructed its straightforward ShEx 0 -approximation as illustrated on the Then in each ShEx 0 we have measured the number of all (base) types, those that are singular (Sin), context-singular (CtxSin), and absorption-protected (Abs). Additionally, we have counted the number of types that are signature-independent (σ-ind): types whose set of labels of outgoing edges is incomparable with others.</p><p>We first analyze our findings for the graph databases and knowledge graphs (first 6 rows). We observe that the numbers of nontrivial union types and disjunctions are relatively small. Also, deterministic types are relatively low in some databases because of use of union types: even trivial use of union types in a type definition precludes determinism. We point to the differences in signature-independent and singular types, on average 69% vs. 79% resp., which indicates that using simulation to identify types has advantages over an approach that reduces a type to the labels of its outgoing types. While the numbers of singular types are relatively large, 79% on average, the numbers of context-singular types, 94% on average, are even more impressive, and the significant improvement validates our approach of incorporating the context information in the inference process.</p><p>For the knowledge base Yago the results indicate that our algorithms would offer little improvement over simpler approaches (σ-ind) that attempt to identify types by using the labels of their outgoing edges. We attribute this to the use of rich hierarchies of classes which introduce many subtype relationships between types. We point out, however, that those class hierarchies are defined with ontologies that specify rules that allow to type the graph. Our methods do not take advantage of this typing information, and therefore, are not geared towards inference for knowledge bases. Alternative tools for inference from typed graphs should be used (see our preliminary results on the topic in <ref type="bibr" target="#b29">[30]</ref>).</p><p>We conclude that inference algorithms for the proposed classes CtxSinShEx 0 and AbsShEx 0 are an attractive choice for the first draft of the schema for (untyped) graph databases and knowledge graphs to be later on improved by a data specialist, especially when the type hierarchy is relatively flat.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related work</head><p>Several approaches have been investigated in the late 90's to summarize graph data, defining schema models, and algorithms to infer schemas from graph data, then viewed as semi-structured data <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b39">40]</ref>. A large part of the literature focuses on graph summarization <ref type="bibr" target="#b13">[14]</ref>, where the purpose is to obtain a concise representation of an input graph that can be used to formulate queries against the data. Our approach takes a different perspective of the same problem, where the input data is considered as evidence from which we must infer an unknown target schema. Using the grammatical inference framework enables us to offer strong guarantees, and lay the ground for a principled fundamental approach. To the best of our knowledge this is a first, and this complements the traditional approach in the literature that consists in evaluating algorithms empirically on real-life graph data to measure the tradeoff between compactness and the accuracy of the description.</p><p>A Dataguide <ref type="bibr" target="#b28">[29]</ref> of a graph represents as a DFA all the paths that can be navigated from a root node in the graph. Dataguides are thus similar in spirit to our determinization procedure, but do not represent the arity of paths and assume that specific entry points have been specified; the root nodes. This approach, like determinization, can identify subtypes, and cycles (provided the cycles are presented in the input data). Several approaches have been proposed to infer schemas for tree-structured data <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9]</ref> or JSON data <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. The schemas inferred include DTDs, tree automata, and XML Schema, and thus are expressive enough to represent the arity of edges. However, these approaches focus on tree-structure and do not consider cycles (as expressed via mechanisms such as ID/REF). The tree structure means that the schema can be inferred recursively, and thus the task is essentially about inferring efficiently a regular expression representing for the children of each tree node.</p><p>More recently, the inference of schemas for graphs has focused on RDF and property graphs <ref type="bibr" target="#b33">[34]</ref>. Several applications <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b51">52]</ref> rely on graph (bi)simulation to build a quotient graph w.r.t. an equivalence relation. The quotient graph merges all nodes that belong to the same equivalence class. Those proposals generally do not assign arities to the edges with a few exceptions such as <ref type="bibr" target="#b52">[53]</ref>. Variants <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b51">52]</ref> consider both forward and backward bisimilarity, which means that types can be defined based on both the incoming and outgoing edges. Full bisimulation is rather rare in heterogenous graphs and even limiting it to the 1-hop neighbourhood does not help <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b26">27]</ref>, so the authors introduce weak and strong equivalence relations that relax rather aggressively the bisimulation relation through transitive co-occurrence of edge labels, to achieve more compact graph summaries. Type hierarchies essentially collapse in summaries built on weak or strong equivalence whenever they would collapse for hybrid-learner. Actually, weak equivalence systematically collapses hierarchies (except for nodes without outgoing edges). Even these summaries may become large for big, encyclopedic graphs, such as DBPedia or YAGO. One solution they suggest is to use methods based on mining frequent patterns <ref type="bibr" target="#b18">[19]</ref>. An alternative approach to such problematic graphs is to use semi automatic methods where the construction of schema is interactively guided by domain experts <ref type="bibr" target="#b11">[12]</ref>.</p><p>Other ideas include clustering nodes according to thresholds on the number of shared edge labels <ref type="bibr" target="#b52">[53]</ref>. In <ref type="bibr" target="#b2">[3]</ref> integer linear programming is used to optimize the tradeoff between the number of partitions and how well each partition fits to the schema, however, the fitness is defined using outbound neighborhood, and not the context. Finally, some approaches complement the structural information with types that may be already present in graphs <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b26">27]</ref> or, in the case of property graphs, by inferring the typing from node labels <ref type="bibr" target="#b36">[37]</ref>.</p><p>Among results on grammatical inference, <ref type="bibr" target="#b30">[31]</ref> shows that a family of well-behaved inference algorithms can be interpreted as constructing a least upper bound for the input in the lattice of languages from the class, where the order is defined as the containment of languages. Our inference algorithm follows a similar approach. It does not compute a least upper bound among the whole class of graph schemas, but rather inside the lattice of the graph aggregates of the input graph (see Section 3.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusions and future work</head><p>We have presented a principled approach to the problem of inference of shape graphs, which are a subclass of shape expression schemas for graph databases. We have employed the framework of grammatical inference to identify key challenges: identifying arities on edges and identifying recursive types. To confront these challenges we have explored an approach of inferring shape graphs using simulation relation on the nodes of the input graph. This approach addresses well the identified challenges at the price of identifying subtypes, which we argue to be a fundamental limitation. To overcome it we extend the simulation based approach with a modest amount of context information. The resulting inference algorithm allows to infer a rich class of schemas, which we argue to be of practical importance with an empirical study of real-life schemas of graph databases. Future research directions include exploring techniques for inference of disjunctions <ref type="bibr" target="#b10">[11]</ref> and adapting the proposed methods to the emerging standard for Property Graph Schemas. We also plan to pursue the question of inference of shape graphs from typed graphs, our preliminary results are very promising <ref type="bibr" target="#b29">[30]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>An RDF graph (above) and its abstraction as a simple graph (below) An embedding G0 H0 (concise versions of graphs from Figure1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2</head><label>2</label><figDesc>Figure 2 Graphs and embeddings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3</head><label>3</label><figDesc>Figure 3 Containment does not imply an embedding: K0 and K1 are equivalent but K1 K0 and K0 K1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4</head><label>4</label><figDesc>Figure 4 Aggregate of G0 by grouping P0 induced by the bisimulation relation of G0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5</head><label>5</label><figDesc>Figure 5 Limit points for various subclasses of ShEx0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6</head><label>6</label><figDesc>Figure 6Example of inference using graph simulation. G2 ÷ P0 does not recognize G2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 Algorithm 1 1 : 6 : 7 :</head><label>71167</label><figDesc>Figure 7 Example of inference using graph simulation. G3 ÷ Pmax is overgeneralized.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>2 .</head><label>2</label><figDesc>single choice any m and n ∈ Max such that all nodes that sim-dominate m are in P [n]. 3. all else any n ∈ Max and m ∈ N G such that m ∈ N G \ P [n] and n sim-dominates m.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8</head><label>8</label><figDesc>Figure 8 Determinization of a graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9</head><label>9</label><figDesc>Figure 9 Execution of hybrid-learner on G0. m n means that n sim-dominates m.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Book → (creator : Person+ | editor : Person+), title : Literal, ref : (Article ∪ Book)*.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Graphs for Graph Databases example for the above type definition of Book Book → creator : Person*, editor : Person*, title : Literal, ref : Article*, ref : Book*.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>D T 2 0 2 2 7:4 Inference of Shape Graphs for Graph Databases</head><label></label><figDesc></figDesc><table /><note><p><p><p><p>and often we use i for [i; i]. Throughout this paper, we employ the point-wise addition operation [i</p>1 ; j 1 ] ⊕ [i 2 ; j 2 ] = [i 1 + i 2 ; j 1 + i 2 ]. A set of intervals M is proper if any interval is contained in an interval in M .</p>For a proper M we define the function fit M that maps any finite nonempty set of natural numbers (occurrences) into a smallest interval in M containing it.</p>I C</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>there exists a witness of embedding of n in m w.r.t. R, i.e., a function λ : out G (n) → out H (m) such that 1. for every e ∈ out G (n) we have that lab(e) = lab(λ(e)),</figDesc><table><row><cell>2. for every f ∈ out H (m) we have that</cell><cell>{arity G (e) | λ(e) = f } ⊆ arity H (f ), where</cell></row><row><cell cols="2">stands for the point-wise sum of all the intervals.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>2 0 2 2 7:8 Inference of Shape Graphs for Graph Databases shape</head><label></label><figDesc>graph H = (N H , E H , arity H ), where</figDesc><table /><note><p>a proper set of intervals M , the aggregate of G by P w.r.t. M , in symbols G ÷ M P , is the I C D T</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>it is not singular because {n 0 } G2÷Pmax* {n 2 , n 4 }. Although originally n 0 was sim-maximal, afterwards it became subsumed by the group {n 2 , n 4 }. It is then absorbed by {n 2 , n 4 } and we get the node grouping P + max = {{n 1 , n 3 }, {n 0 , n 2 , n 4 }, {str}}, which yields the singular shape graph H 2 that recognizes G 2 .</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1</head><label>1</label><figDesc>Analysis of schemas for a number of graph databases.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">Base types</cell><cell></cell><cell></cell><cell>Union</cell><cell></cell><cell>Clauses</cell><cell></cell></row><row><cell></cell><cell cols="6">total Det σ-ind Sin CtxSin Abs</cell><cell>types</cell><cell>total</cell><cell>union</cell><cell>disj.</cell></row><row><cell>Dblp</cell><cell>11</cell><cell>5</cell><cell>6</cell><cell>8</cell><cell>10</cell><cell>7</cell><cell>2 (3)</cell><cell>135</cell><cell>2 (9)</cell><cell>1</cell></row><row><cell>Berlin</cell><cell>8</cell><cell>8</cell><cell>5</cell><cell>5</cell><cell>8</cell><cell>7</cell><cell>0 (0)</cell><cell>47</cell><cell>0 (0)</cell><cell>0</cell></row><row><cell>Tpc-h (dm)</cell><cell>8</cell><cell>8</cell><cell>8</cell><cell>8</cell><cell>8</cell><cell>8</cell><cell>0 (0)</cell><cell>67</cell><cell>0 (0)</cell><cell>0</cell></row><row><cell>Nobel</cell><cell>11</cell><cell>8</cell><cell>7</cell><cell>7</cell><cell>10</cell><cell>8</cell><cell>1 (0)</cell><cell>66</cell><cell>2 (0)</cell><cell>1</cell></row><row><cell>SciGraph</cell><cell>18</cell><cell>10</cell><cell>16</cell><cell>17</cell><cell>18</cell><cell>16</cell><cell>1 (2)</cell><cell>162</cell><cell>1 (7)</cell><cell>1</cell></row><row><cell>Covid19</cell><cell>22</cell><cell>11</cell><cell>11</cell><cell>19</cell><cell>19</cell><cell>19</cell><cell>2 (0)</cell><cell>295</cell><cell>3 (0)</cell><cell>0</cell></row><row><cell>Yago</cell><cell>49</cell><cell>14</cell><cell>28</cell><cell>28</cell><cell>30</cell><cell>21</cell><cell>2 (13)</cell><cell cols="2">1174 4 (490)</cell><cell>0</cell></row></table></figure>
		</body>
		<back>

			<div type="funding">
<div><p>This author has been partially supported by <rs type="funder">Polish National Science Center</rs> grant <rs type="grantNumber">NCN 2016/23/B/ST6/01438</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_Px7jfuH">
					<idno type="grant-number">NCN 2016/23/B/ST6/01438</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Research directions for principles of data management (Dagstuhl Perspectives Workshop 16151)</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Hüllermeier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Murlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schwentick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Stoyanovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dagstuhl Manifestos</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Inductive inference of formal languages from positive data</title>
		<author>
			<persName><forename type="first">D</forename><surname>Angluin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="117" to="135" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A principled approach to bridging the gap between graph data and their schemas</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">I</forename><surname>Diaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fokoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Srinivas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="601" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Enhancing the Nobel Prize schema</title>
		<author>
			<persName><forename type="first">R</forename><surname>Asif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Qadir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Communication, Computing and Digital Systems (C-CODE)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="193" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Schema inference for massive JSON datasets</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Baazizi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ben Lahmar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Colazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ghelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sartiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Extending Database Technology (EDBT)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Parametric schema inference for massive JSON datasets</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Baazizi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Colazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ghelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sartiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="497" to="521" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Learning deterministic regular expressions for the inference of schemas from XML data</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Bex</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Gelade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vansummeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on the Web</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="32" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Inference of concise DTDs from XML data</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Bex</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schwentick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tuyls</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Databases (VLDB)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="115" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Inferring XML schema definitions from XML data</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Bex</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vansummeren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Databases (VLDB)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="998" to="1009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Berlin SPARQL benchmark</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schultz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Semantic Web and Information Systems</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Schemas for unordered XML on a DIME</title>
		<author>
			<persName><forename type="first">I</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ciucanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Semi automatic construction of shex and SHACL schemas</title>
		<author>
			<persName><forename type="first">I</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dusart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fernández-Álvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Labra</surname></persName>
		</author>
		<author>
			<persName><surname>Gayo</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1907.10603</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Relational to RDF data exchange in presence of a shape expression schema</title>
		<author>
			<persName><forename type="first">I</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lozano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Alberto Mendelzon International Workshop on Foundations of Data Management</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Graph summarization</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dumbrava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2004.14794</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Adding structure to unstructured data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Database Theory (ICDT)</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="336" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficiency and precision trade-offs in graph summary algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Campinas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Delbru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tummarello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Database Engineering &amp; Applications Symposium (IDEAS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="38" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive learning of node selecting tree transducers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Carme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="33" to="67" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Compact summaries of rich heterogeneous graphs</title>
		<author>
			<persName><forename type="first">Š</forename><surname>Čebirić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<idno>RR-8920</idno>
		<imprint>
			<date type="published" when="2018">1, 2018</date>
		</imprint>
		<respStmt>
			<orgName>INRIA Saclay ; Université Rennes</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Summarizing semantic graphs: a survey</title>
		<author>
			<persName><forename type="first">Š</forename><surname>Čebirić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Troullinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zneika</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="295" to="327" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A framework for efficient representative summarization of RDF graphs</title>
		<author>
			<persName><forename type="first">Š</forename><surname>Čebirić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference (ISWC)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Schema extraction from XML: A grammatical inference approach</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chidlovskii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Knowledge Representation Meets Databases (KRDB)</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning schemas for unordered XML</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ciucanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Database Programming Languages (DBPL)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Query preserving graph compression</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="157" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Optimizing regular path expressions using graph schemas</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Data Engineering (ICDE)</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">XTRACT: learning document type descriptors from XML document collections</title>
		<author>
			<persName><forename type="first">M</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="23" to="56" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Incremental structural summarization of RDF graphs</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Extending Database Technology (EDBT)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">RDF graph summarization for first-sight structure discovery</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1191" to="1218" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Complexity of automaton identification from given data</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Gold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="302" to="320" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Dataguides: Enabling query formulation and optimization in semistructured databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Very Large Data Bases (VLDB)</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="436" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Inference of shape expression schemas typed RDF graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Groz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wieczorek</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2107.04891</idno>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Learning in the limit with lattice-structured hypothesis spaces</title>
		<author>
			<persName><forename type="first">J</forename><surname>Heinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kasprzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kötzing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">457</biblScope>
			<biblScope unit="page" from="111" to="127" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Building a conference recommender system based on SciGraph and WikiCFP</title>
		<author>
			<persName><forename type="first">A</forename><surname>Iana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Naeser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Birukou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hertling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Paulheim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantic Systems. The Power of AI and Knowledge Graphs</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="117" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">ExpLOD: Summary-based exploration of interlinking and RDF usage in the linked open data cloud</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khatchadourian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Consens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Extended Semantic Web Conference (ESWC)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="272" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">RDF graph summarization: principles, techniques and applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Extending Database Technology (EDBT)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="433" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Validating and describing linked data portals using RDF Shape Expressions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Labra Gayo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prud'hommeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Solbrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Alvarez Rodriguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Linked Data Quality</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Learning sequential tree-to-word transducers</title>
		<author>
			<persName><forename type="first">G</forename><surname>Laurence</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tommasi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Language and Automata Theory and Applications (LATA)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="490" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Schema inference for property graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lbath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Extending Database Technology (EDBT)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="499" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A learning algorithm for top-down XML transformations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maneth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="285" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Efficient extraction of schemas for XML documents</title>
		<author>
			<persName><forename type="first">J.-K</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-Y</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Chung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="12" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Extracting schema from semistructured data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nestorov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="295" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Representative objects: Concise representations of semistructured, hierarchial data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nestorov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Wiener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Chawathe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Data Engineering (ICDE)</title>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="79" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Shape Expressions: An RDF validation and transformation language</title>
		<author>
			<persName><forename type="first">E</forename><surname>Prud'hommeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Labra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Gayo</surname></persName>
		</author>
		<author>
			<persName><surname>Solbrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Semantic Systems</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">KG-COVID-19: A framework to produce customized knowledge graphs for COVID-19 response</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Reese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Unni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cappelletti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ravanmehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Carbon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Shefchek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">M</forename><surname>Good</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Balhoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Fontana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Blau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Matentzoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">L</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Munoz-Torres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Haendel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">N</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Joachimiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Mungall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Patterns</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">100155</biblScope>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Large-scale bisimulation of RDF graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schätzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Neu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Przyjaciel-Zablocki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Semantic Web Information Management (SWIM)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Survey of directly mapping SQL databases to the Semantic Web</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Tirmizi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ó</forename><surname>Corcho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Miranker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge Engineering Review</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="445" to="486" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">On directly mapping relational databases to RDF and OWL</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Miranker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on World Wide Web (WWW)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="649" to="658" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Complexity and expressiveness of ShEx for RDF</title>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Labra Gayo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hym</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">G</forename><surname>Prud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Solbrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Database Theory (ICDT)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="195" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Learning twig and path queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wieczorek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Database Theory (ICDT)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="140" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Containment of shape expression schemas for RDF</title>
		<author>
			<persName><forename type="first">S</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Wieczorek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="303" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Yago: A core of semantic knowledge</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kasneci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on World Wide Web (WWW)</title>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="697" to="0706" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<ptr target="http://www.tpc.org/" />
		<title level="m">TPC benchmarks</title>
		<imprint>
			<publisher>TPC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Managing structured and semistructured RDF data using structure indexes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ladwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2076" to="2089" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">An algorithm for extracting shape expression schemas from graphs</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tsuboi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Suzuki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Document Engineering (DocEng)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">A direct mapping of relational data to RDF</title>
		<author>
			<persName><surname>W3c</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/rdb-direct-mapping/" />
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Shape expressions schemas</title>
		<author>
			<persName><surname>W3c</surname></persName>
		</author>
		<ptr target="http://www.w3.org/2013/ShEx/Primer" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Assg: adaptive structural summary for RDF graph data</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference (ISWC) Posters &amp; Demonstrations Track</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="233" to="236" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
