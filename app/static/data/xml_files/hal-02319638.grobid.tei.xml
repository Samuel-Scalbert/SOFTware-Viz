<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Evolutionary Approach to Class Disjointness Axiom Discovery</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thu</forename><forename type="middle">Huong</forename><surname>Nguyen</surname></persName>
							<email>thu-huong.nguyen@univ-cotedazur.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univesit√© C√¥te d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<region>I3S</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrea</forename><forename type="middle">G B</forename><surname>Tettamanzi</surname></persName>
							<email>andrea.tettamanzi@univ-cotedazur.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Univesit√© C√¥te d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<region>I3S</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Evolutionary Approach to Class Disjointness Axiom Discovery</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">07BC9C660867F85AAF0F3C3D766FD32A</idno>
					<idno type="DOI">10.1145/3350546.3352502</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Computing methodologies Ontology engineering</term>
					<term>Machine learning algorithms</term>
					<term>Instance-based learning</term>
					<term>Evolutionary algorithms</term>
					<term>Grammatical Evolution, Ontology Learning, OWL Axioms</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Axiom learning is an essential task in enhancing the quality of an ontology, a task that sometimes goes under the name of ontology enrichment. To overcome some limitations of recent work and to contribute to the growing library of ontology learning algorithms, we propose an evolutionary approach to automatically discover axioms from the abundant RDF data resource of the Semantic Web. We describe a method applying an instance of an Evolutionary Algorithm, namely Grammatical Evolution, to the acquisition of OWL class disjointness axioms, one important type of OWL axioms which makes it possible to detect logical inconsistencies and infer implicit information from a knowledge base. The proposed method uses an axiom scoring function based on possibility theory and is evaluated against a Gold Standard, manually constructed by knowledge engineers. Experimental results show that the given method possesses high accuracy and good coverage.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>provide a major support to modeling and sharing knowledge among various applications in a specific domain. However, ontology construction is limited by the obstacle known as "knowledge acquisition bottleneck". This can arise from the requirement of involving domain experts and knowledge engineers, which is highly expensive and time-consuming. This problem may be tackled by the set of methods and techniques that go under the name of ontology learning <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b18">19]</ref>. These methods, by adopting learning algorithms from several existing knowledge and information sources, can help alleviate the overall cost of ontology construction by reducing or eliminating altogether the need of domain experts. Ontology learning may be viewed as a special case of knowledge discovery from data (KDD) or data mining, where the data are in a special format (assertions) and knowledge takes the form of axioms of an ontology. At the starting point of ontology learning, two fundamental aspects have to be defined: the types of input data sources from which the system exploits ontological knowledge and the ontological elements which need to be learned.</p><p>The growth of the Web of data, also called the Semantic Web, where the Linked Open Data (LOD) is a prominent representative opens up exciting opportunities for learning new knowledge in the context of an open world. The LOD can be considered as a huge real-world knowledge base for learning ontologies. Specifically, ontology learning on the Semantic Web involves handling the enormous and diverse amount of data in the Web and thus enhancing existing approaches for knowledge acquisition instead of only focusing on mostly small and uniform data collections.</p><p>The elements of the ontology to be learned, usually axioms formalized in the form of logical assertions, can then be used to enhance and constrain the information contained in the ontology and to check its correctness or deduce new information <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">19]</ref>. As a consequence, learning axioms is a crucial task in ontology learning to discover implicit axioms from existing ontologies or instance data, i.e. prior knowledge or knowledge base (KB). In particular, class disjointness axioms are useful for checking the logical consistency and detecting undesired usage patterns or incorrect assertions. As for the definition of disjointness <ref type="bibr" target="#b20">[21]</ref>, two classes are disjoint if they do not possess any common individual according to their intended interpretation, i.e., the intersection of these classes is empty in a particular KB. A simple example can demonstrate the potential advantages obtained by the addition of this kind of axioms to an ontology. A knowledge base defining terms of classes like Mother, Man and asserting that individual Tyler is both a Mother and a Man would be logically consistent, without any errors being recognized by a reasoner. However, if a constraint of disjointness between classes Mother and Man is added, the reasoner will be able to reveal an error in the modeling of such a knowledge base. As a consequence, logical inconsistencies of facts can be detected and excluded-thus enhancing the quality of ontologies. As a matter of fact, very few DisjointClasses axioms are currently found in existing ontologies. For example, in the DBpedia ontology, the query SELECT ?x ?y { ?x owl:disjointWith ?y } executed on May 11, 2019 returned only 25 solutions, whereas the realistic number of class disjointness axioms generated from hundreds of classes in DBpedia (738 classes in DBpedia version 2015-04, 760 classes in DBpedia version 2016-04) <ref type="foot" target="#foot_0">1</ref> where ?subject a owl:Class. is expected to be much larger, in the order of the thousands or tens of thousands. Hence, learning implicit knowledge in terms of axioms from a LOD repository in the context of the Semantic Web has been the object of research in several different approaches.</p><p>Among the early approaches to ontology development, we summarize top-down and bottom-up techniques. In the case of axiom learning, i.e., learning class disjointness axioms, recent methods <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b21">22]</ref> apply top-down or intensional approaches to learning disjointness which relies on schemalevel information, i.e., logical and lexical descriptions of the classes. The contributions based on bottom-up or extensional approaches <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21]</ref>, on the other hand, require the instances in the dataset to induce instance-driven patterns to suggest axioms, e.g., disjointness class axioms.</p><p>Along the lines of extensional (i.e., instance-based) methods, we propose an evolutionary approach, based on grammatical evolution, for mining implicit axioms from RDF datasets. The goal is to derive potential class disjointness axioms of more complex types, i.e., defined with the help of relational operators of intersection and union; in other words, axioms like Dis(ùê∂1, ùê∂2), where ùê∂1 and ùê∂2 are complex class expressions including ‚äì and ‚äî operators. Also, an evaluation method based on possibility theory is adopted to assess the certainty level of induced axioms.</p><p>The rest of the paper is organized as follows. Section 2 describes briefly some related works. In Section 3, some foundations are introduced. Section 4 sketches a GE approach for learning OWL classes disjointness axioms. An axiom evaluation method based on possibility theory is also presented in this section. Section 5 provides experimental evaluation and comparison. Section 6 concludes the paper with the final remarks and the directions for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>The most prominent related work relevant to learning disjointness axioms consists of the contributions by Johanna V√∂lker and her collaborators <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref>. In early work, V√∂lker developed supervised classifiers from LOD incorporated in the LeDA tool <ref type="bibr" target="#b21">[22]</ref>. However, the learning algorithms need a set of labeled data for training that may demand expensive work by domain experts. In contrast to LeDA, statistical schema induction via association rule mining <ref type="bibr" target="#b20">[21]</ref> was given in the tool GoldMiner, where association rules are representations of implicit patterns extracted from large amount of data and no training data is required. Association rules are compiled based on statistical analysis of a transaction table, which is built from the results of SPARQL queries. That research only focused on generating axioms involving atomic classes, i.e., classes that do not consist of logical expressions, but only of a single class identifier.</p><p>Another relevant research is the one by Lorenz B√ºhmann and Jens Lehmann, whose proposed methodology is implemented in the DL-Learner system <ref type="bibr" target="#b10">[11]</ref> for learning general class descriptions (including disjointness) from training data. Their work relies on the capabilities of a reasoning component, but suffers from scalability problems for the application to large datasets like LOD. In <ref type="bibr" target="#b0">[1]</ref>, they tried to overcome these obstacles by obtaining predefined data queries, i.e., SPARQL queries to detect specific axioms hidden within relevant data in datasets for the purpose of ontology enrichment. B√ºhmann and Lehmann also developed methods for generating more complex axiom types <ref type="bibr" target="#b1">[2]</ref> by using frequent terminological axiom patterns from several data repositories. One important limitation of their method is the time-consuming and computationally expensive process of learning frequent axioms patterns and converting them into SPARQL queries before generating actual axioms from instance data. Also, the most frequent patterns refer to inclusion and equivalence axioms like ùê¥ ‚â° ùêµ ‚äì ‚àÉùëü.ùê∂ or ùê¥ ‚äë ùêµ ‚äì ‚àÉùëü.ùê∂.</p><p>Here, we extend and enhance our recent proposal <ref type="bibr" target="#b13">[14]</ref> of an approach to generate class disjointness axioms from an existing RDF repository using Grammatical Evolution (GE). On the one hand, the enhancement concerns the fitness function used to score axioms, where we now include an improved measure of generality and we removed the necessity measure, which, as we will explain below, does not carry any useful information when dealing with this type of axioms. On the other hand, we greatly extend the experimental validation, by systematically exploring a variety of parameter settings. Along the lines of extensional (i.e., instance-based) methods, we propose a number of improvements as well as more extensive experiments for mining implicit axioms from RDF datasets in an evolutionary approach, based on grammatical evolution to investigate its potential and suggest future extensions. The goal is to derive potential class disjointness axioms of more complex types, i.e., defined with the help of relational operators of intersection and union.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FOUNDATIONS 3.1 The Semantic Web and Related Concepts</head><p>The Semantic Web 2 (SW) which is an extension of the World Wide Web (WWW) can be considered as the movement from the Web of documents to the Web of data. In this, semantic information containing the machine-processable information called metadata-a fundamental component of the SW-is embedded within Web content. Among the metadata, IRIs (International Resource Identifiers) are used to identify abstract or physical resources. The Resource Description Framework (RDF)<ref type="foot" target="#foot_2">3</ref>  <ref type="bibr" target="#b16">[17]</ref> is mainly a data model of SW for describing machine processable semantics of data. RDF uses as statements triples of the form &lt;Subject, Predicate, Object&gt;. Each part of the triples can be described in the form of IRIs and in the shorter representation associated with the prefix aliases <ref type="foot" target="#foot_3">4</ref> . The query language for RDF is SPARQL. <ref type="foot" target="#foot_4">5</ref>Linked Open Data<ref type="foot" target="#foot_5">6</ref> (LOD) is an association of Linked Data <ref type="foot" target="#foot_6">7</ref> and Open Data where data can be linked while being freely available for sharing and reuse. One of the prominent representatives of the LOD is DBpedia, <ref type="foot" target="#foot_7">8</ref> which comprises a rather rich collection of facts extracted from the Wikipedia.</p><p>OWL<ref type="foot" target="#foot_8">9</ref> (Web Ontology Language) is one of the data modeling languages for describing RDF data. OWL is much more expressive not only to describe classes and properties but also to use in data modeling and reasoning. OWL contains the constructors of complex class descriptions such as owl:UnionOf, owl:IntersectionOf, owl:Complementary and express relations between class descriptions by means of class axioms such as owl:disjointWith.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Grammatical Evolution</head><p>GE is a grammar-based form of GP <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. It is a relatively new evolutionary computation technique pioneered by Michael O'Neill and his collaborators <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b17">18]</ref>. By the tradition of evolutionary algorithm (EA), a population of individuals, i.e., potential solutions, is maintained by the GE algorithm and iteratively refined to find the best solution. At each iteration, known as a generation, the fitness of individuals in the population are evaluated. According to these levels of fitness, the process of selecting individuals called parents selection is performed to create a list of better qualified parents as input for generating a new set of candidate solutions, i.e. offspring, in the next generation. The offspring of each generation is bred by applying genetic operators on the selected parents.</p><p>As in <ref type="bibr" target="#b3">[4]</ref> and unlike GP, GE has a clear distinction in representation between the search space and the solution space. Programs known as phenotypic solutions or phenotypes are formed from the variable length binary strings, i.e., genotypic individuals or genotypes through the transformation called mapping process. Among them, the variable length binary string genomes, i.e., chromosomes, are used in the form of consecutive groups of 8 bits called codon representing an integer value. Meanwhile, the genotype-phenotype mapping process requires a set of production rules expressed in the form of formal grammar, namely a Backus-Naur form (BNF) grammar which specifies the syntax of desired programs. BNF grammar is a context-free grammar consisting of terminals and non-terminals. A grammar can be represented in the form of the tuple {ùëÅ, ùëá, ùëÉ, ùëÜ}, where ùëÅ is the sets of nonterminals, which can be extended into one or more terminals; ùëá is the set of terminals which are items in the language; ùëÉ is the set of the production rules that map ùëÅ to ùëá ; ùëÜ is the start symbol and a member of ùëÅ . In the mapping process, codons are used consecutively to choose production rules from ùëÉ in the BNF grammar according to the function:</p><p>(1)</p><p>Codons can be reused two or more times (called wrapping technique) <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b14">15]</ref>. In the advantageous cases, programs are generated before the end of the genome is reached; otherwise, a wrapping operator is applied and the reading of codons will continue from the beginning of the chromosome, until the maximum allowed number of wrapping events is reached. An unsuccessful mapping will happen if the threshold on the number of wrapping events is reached but the individual is still not completely mapped; in this case, the individual is assigned the lowest possible fitness.</p><p>Although GE uses the standard genetic operators of crossover and mutation in the Evolutionary Algorithms (EA) <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16]</ref>, GE applies these operators on variable-length binary strings, i.e., genotypes, instead of the actual programs, i.e., phenotypes. In this, a standard single point crossover is employed whereby two crossover points are chosen randomly, one on each individual and the two sets of codons following these points exchanged, i.e. the right part of each individual are swapped. Also, a selected individual goes through with single point mutation, i.e. a codon selected at random, and this codon is replaced with a new randomly generated codon.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Possibility Theory</head><p>Possibility theory <ref type="bibr" target="#b22">[23]</ref> is a mathematical theory of epistemic uncertainty. Given a finite universe of discourse ‚Ñ¶, whose elements ùúî ‚àà ‚Ñ¶ may be regarded as outcomes of an experiment, values of a variable, possible worlds, or states of affairs, a possibility distribution is a mapping ùúã : ‚Ñ¶ ‚Üí [0, 1], which assigns to each ùúî a degree of possibility ranging from 0 (impossible, excluded) to 1 (completely possible, normal). A possibility distribution ùúã for which there exists a completely possible state of affairs (‚àÉùúî ‚àà ‚Ñ¶ : ùúã(ùúî) = 1) is said to be normalized.</p><p>A possibility distribution ùúã induces a possibility measure and its dual necessity measure, denoted by Œ† and ùëÅ respectively. Both measures apply to a set ùê¥ ‚äÜ ‚Ñ¶ (or to a formula ùúë, by way of the set of its models, ùê¥ = {ùúî : ùúî |= ùúë}), and are usually defined as follows:</p><formula xml:id="formula_0">Œ†(ùê¥) = max ùúî‚ààùê¥ ùúã(ùúî);</formula><p>(2)</p><formula xml:id="formula_1">ùëÅ (ùê¥) = 1 -Œ†( ƒÄ) = min ùúî‚àà ƒÄ{1 -ùúã(ùúî)}.<label>(3)</label></formula><p>In other words, the possibility measure of ùê¥ corresponds to the greatest of the possibilities associated to its elements; conversely, the necessity measure of ùê¥ is equivalent to the impossibility of its complement ƒÄ.</p><p>A generalization of the above definition can be obtained by replacing the min and the max operators with any dual pair of triangular norm and co-norm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">METHOD FOR LEARNING CLASS DISJOINTNESS AXIOMS</head><p>We apply the GE approach introduced in Sec. 3.2 to learn class disjointness axioms from instance data acquired from an RDF repository, e.g., DBpedia. The workflow of such GE approach is shown in Fig. <ref type="figure" target="#fig_2">1</ref>. In the context of axiom discovery, the definition of "programs" or "phenotypic solutions" in GE are class disjointness axioms whose syntax is described by a BNF grammar. Therefore, the first important task is to design the grammar used for generating well-formed class disjointness axioms. Afterwards, in the beginning of the evolutionary process, we randomly generate a population of axioms in genotypic representation, i.e., candidate genotypic axioms, which are encoded as variable-length integer strings, i.e., numerical chromosomes. According to the built grammar and the principles of the mapping process, we are able to decode these chromosomes into class disjointness axioms in the form of logical expressions, i.e., candidate phenotypic axioms. The set of candidate axioms is maintained by the GE algorithm and iteratively refined to find axioms that are both general and credible (two key quality measures for discovered knowledge). The quality of the generated axioms can be improved gradually during the evolutionary process by applying genetic operators (crossover and mutation) on genotypic axioms. In this section, we first briefly describe the process of grammar construction and give a specific example of the decoding phase to well-formed class disjointness axioms. After that, possibilistic evaluation of generated axioms is presented in detailed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Structure of the BNF Grammar</head><p>We use the functional-style grammar in the extended BNF notation used by the W3C to design the grammar for generating OWL class disjointness axioms <ref type="foot" target="#foot_9">10</ref> . The production rules are adapted from the complete normative grammar of OWL <ref type="foot" target="#foot_10">11</ref> . The noteworthy thing is that the use of a BNF grammar here does not focus on defining what a well-formed axiom may be, but on generating well-formed axioms which may express the facts contained in a given RDF triple store. Hence, only resources of the language that actually occur in the RDF dataset should be generated. The BNF grammar is organized in two main parts (namely static and dynamic) as follows:</p><p>‚Ä¢ The static part contains production rules defining the structure of the axioms, loaded from a hand-crafted text file. Different grammars will generate different kinds of axioms. ‚Ä¢ The dynamic part contains production rules for the low-level non-terminals, which we can call the primitives. These production rules are automatically built at runtime by querying the SPARQL endpoint of the RDF repository at hand.</p><p>This approach to organizing the structure of a BNF grammar ensures that changes in the contents of RDF repositories will not require the grammar to be rewritten.</p><p>In the functional-style syntax of OWL <ref type="foot" target="#foot_11">12</ref> , class disjointness axioms have the form DisjointClasses(ùê∂1, ùê∂2, ..., ùê∂ùëõ). Without loss of generality, we focus on generating binary axioms such as DisjointClasses(ùê∂1, ùê∂2), where ùê∂1 and ùê∂2 can be atomic expressions like in DisjointClasses(dbo : Film, dbo : WrittenWork) or complex expressions involving relational operators like intersection and union, like in DisjointClasses(dbo : Film, ObjectIntersectionOf (dbo : Book, ObjectUnionOf (dbo : Comics, dbo : MusicalWork))) 13 .</p><p>The pattern of the grammar structured for generating class disjointness axioms is built as follows: The production rule of the primitive Class will be filled by using a SPARQL query of the form SELECT ?class WHERE { ?instance a ?class. } to extract classes (represented by their IRI) from the RDF dataset.</p><formula xml:id="formula_2">% Static part</formula><p>An example representing a small excerpt of an RDF triple repository is the following:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Mapping Process</head><p>In this section, we illustrate the transformation of an integer chromosome into an OWL class disjointness axiom in functional-style syntax through an example. Let the chromosome be (253, 213, 397, 387, 268, 342, 321, 408, 182, 132) and let the BNF grammar and the RDF store be as in Sec. 4.1. We apply Eq. 1 in Sec. 3.2 to choose production rules from the grammar. Table <ref type="table" target="#tab_0">1</ref> illustrates the steps of the mapping to a class disjointness axiom expression relevant to the considered example.</p><p>There is only one production for non-terminals Axiom, ClassAxiom, DisjointClasses, ObjectIntersectionOf, and ObjectUnionOf as it can be seen from Rules 1-3, 5, and 6. In these cases, we skip using any codons for mapping and concentrate on reading codons for non-terminals having more than one production, like in Rules 4 and 7. We begin by decoding the first codon, i.e. 253, by Eq. 1. The result, i.e 253 modulo 3 = 1, is used to determine which production is chosen to replace the leftmost non-terminal (ClassExpression) from its relevant rule (Rule 4). In this case, the leftmost ClassExpression will be replaced by the value of ObjectUnionOf. The mapping goes on like this until eventually there is no non-terminal left in the expression. Not all codons were required and extra codons have been simply ignored in this case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Axiom Evaluation</head><p>Some facts (instances) in the RDF repository may be missing or erroneous as a result of the heterogeneous and collaborative character of the LOD. This incompleteness and noise determines a sort of epistemic uncertainty in the evaluation of the quality of a candidate axiom. In order to properly capture this type of uncertainty, typical of an open world, which contrasts with the ontic uncertainty typical of random processes, we follow <ref type="bibr" target="#b13">[14]</ref> in adopting an axiom scoring heuristics based on possibility theory (cf. Section 3.3), which is well-suited to incomplete knowledge. This appears to be a justified choice for assessing knowledge extracted from an RDF repository. We now summarize this scoring heuristics which was applied in <ref type="bibr" target="#b13">[14]</ref> and we point out how our definition of the fitness function differs from <ref type="bibr" target="#b13">[14]</ref>.</p><p>In the case of possibilistic axiom scoring, the basic principle for establishing the possibility of a formula ùúë should be that the absence of counterexamples to ùúë in the RDF repository means Œ†([ùúë]) = 1, i.e., that ùúë is completely possible. Let ùúë be an axiom that we wish to evaluate (i.e., a theory). The content of an axiom ùúë that we wish to evaluate is defined as a finite set of logical consequences content(ùúë) = {ùúì : ùúë |= ùúì},</p><p>obtained through the instantiation of ùúë to the vocabulary of the RDF repository; every formula ùúì ‚àà content(ùúë) may be readily tested by means of a SPARQL ASK query. Let us define ùë¢ ùúë = ‚Äñcontent(ùúë)‚Äñ as the support of ùúë. Let then ùë¢ + ùúë be the number of confirmations (basic statements ùúì that are satisfied by the RDF repository) and ùë¢ - ùúë the number of counterexamples (basic statements ùúì that are falsified by the RDF repository).</p><p>The possibility measure Œ†(ùúë) and the necessity measure ùëÅ (ùúë) of an axiom have been defined as follows in <ref type="bibr" target="#b19">[20]</ref>: for</p><formula xml:id="formula_4">ùë¢ ùúë &gt; 0, Œ†(ùúë) = 1 - ‚éØ ‚é∏ ‚é∏ ‚é∑ 1 - (Ô∏É ùë¢ ùúë -ùë¢ - ùúë ùë¢ ùúë</formula><p>)Ô∏É 2 ;</p><p>(5)</p><formula xml:id="formula_5">ùëÅ (ùúë) = ‚éØ ‚é∏ ‚é∏ ‚é∑ 1 - (Ô∏É ùë¢ ùúë -ùë¢ + ùúë ùë¢ ùúë )Ô∏É 2 , if Œ†(ùúë) = 1, 0 otherwise. (<label>6</label></formula><formula xml:id="formula_6">)</formula><p>The cardinality of the sets of the facts in the RDF repository reflects the support of each axiom. An axiom is all the more necessary as it is explicitly supported by facts, i.e., confirmations, and not contradicted by any fact, i.e., counterexamples, while it is the more possible as it is not contradicted by any fact. In principle, the fitness of axiom ùúë should be directly proportional to its necessity ùëÅ (ùúë) and to its possibility Œ†(ùúë).</p><p>In addition, what we are looking for is not only credible axioms, but also general ones. As suggested in <ref type="bibr" target="#b13">[14]</ref>, the generality of an axiom may be defined as the cardinality of its support, ùë¢ ùúë . In other words, an axiom is more general as the extension of its components contains more facts. In case one of the components of an axiom is not supported by any fact, its generality will be zero. A definition of the fitness function that satisfies all the above requirements is</p><formula xml:id="formula_7">ùëì (ùúë) = ùë¢ ùúë ‚Ä¢ Œ†(ùúë) + ùëÅ (ùúë) 2 ,<label>(7)</label></formula><p>which was adopted by <ref type="bibr" target="#b13">[14]</ref>. However, it should be noticed that negation is not supported by the syntax of RDF. Negated assertions can of course be expressed using the vocabulary of OWL, but then the services of an OWL reasoner would have to be used to infer the negation of an assertion thus expressed; however, that would be way more expensive than using SPARQL to query the dataset and also of little use, since very few or no negated assertions at all do occur in real-world RDF datasets. As a result, an RDF dataset will naturally provide counterexamples for the disjointness axioms (e.g., an individual that is asserted to belong in the two supposedly disjoint classes). On the other hand, confirmations, which should take the form of negated assertions, like "such individual, which belongs to either of the supposedly disjoint classes, does not belong in the other", will be completely missing. The simple solution of taking the absence of a counterexample as a confirmation (i.e., letting ùë¢ + ùúë = ùë¢ ùúë -ùë¢ - ùúë ) would betray the open-world hypothesis that underlies the SW and is, therefore, not satisfactory. However, this problem can be overcome by actually scoring axioms based on counterexamples only, which is, after all, much in agreement with the falsificationist approach that underlies the current practice in Science (to corroborate a hypothesis, one should not look for easy confirmations, but should rather try hard to find counterexamples). Since the number of confirmations ùë¢ + ùúë only appears in the definition of ùëÅ (ùúë), we can safely drop ùëÅ (ùúë) from Equation <ref type="formula" target="#formula_7">7</ref>.</p><p>A second refinement of the definition of fitness stems from the observation that, for a disjointness axiom of the form Dis(ùê∂, ùê∑), a better measure of its generality would be given by the minimum of the cardinalities of the extensions of the two classes involved, ùê∂ and ùê∑, in the RDF dataset, whereas ùë¢ Dis(ùê∂,ùê∑) is the cardinality of the extension of ùê∂ ‚äî ùê∑. Let us denote by [ùê∂] the extension of class ùê∂ in the RDF dataset at hand: this is the set of instances of ùê∂ returned by a SPARQL query of the form SELECT DISTINCT ?x WHERE { ?x a ùê∂ . } Then we define the generality of axiom Dis(ùê∂, ùê∑) as</p><formula xml:id="formula_8">ùëî Dis(ùê∂,ùê∑) = min{‚Äñ[ùê∂]‚Äñ, ‚Äñ[ùê∑]‚Äñ}<label>(8)</label></formula><p>and use it instead of ùë¢ ùúë in Equation <ref type="formula" target="#formula_7">7</ref>. This yields the following improved definition of the fitness function,</p><formula xml:id="formula_9">ùëì (ùúë) = ùëî ùúë ‚Ä¢ Œ†(ùúë),<label>(9)</label></formula><p>which is the one used in our method.</p><p>In order to measure the fitness of class disjointness axioms Dis(ùê∂, ùê∑), with ùê∂ and ùê∑ class expressions, the numbers of the confirmations, the counterexamples and the support are counted by executing the corresponding SPARQL queries via an accessible SPARQL endpoint. Such SPARQL queries are based on graph patterns that are a direct translation of the expression of the OWL2 axiom considered. A graph pattern here is a mapping ùëÑ(E, ?x) from OWL2 expressions to SPARQL graph patterns where E is an OWL 2 class expression, x is a variable such that the query SELECT DISTINCT ?x WHERE {ùëÑ(E, ?x) } returns all individuals that are instances of E. We define ùëÑ(E, ?x) when</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>‚Ä¢ E is an atomic class expression of an entity</head><formula xml:id="formula_10">A ùëÑ(A, ?x) = ?x ùëé A. (<label>10</label></formula><formula xml:id="formula_11">)</formula><p>where A is a valid IRI. ‚Ä¢ E is an complex class expression involving relational operators, i.e., intersection and union. In this case, Q can be inductively extended to complex expressions:</p><p>if E is an intersection of classes ùê∂ùëñ : ùê∂1 ‚äì ... ‚äì ùê∂ùëõ, ùëÑ(ùê∂1 ‚äì ... ‚äì ùê∂ùëõ, ?x) = ùëÑ(ùê∂1, ?x)...ùëÑ(ùê∂ùëõ, ?</p><formula xml:id="formula_12">-if E is a union of classes ùê∂ùëñ : ùê∂1 ‚äî ... ‚äî ùê∂ùëõ, ùëÑ(ùê∂1‚äî. . .‚äîùê∂ùëõ, ?x, ?y) = {ùëÑ(ùê∂1, ?x)} UNION ‚Ä¢ ‚Ä¢ ‚Ä¢ UNION {ùëÑ(ùê∂ùëõ, ?x)}.<label>x) (11)</label></formula><p>The support ùë¢ Dis(ùê∂,ùê∑) can thus be computed with the following SPARQL query:</p><formula xml:id="formula_14">SELECT( count (DISTINCT ?x) ùê¥ùëÜ ?u) WHERE {ùëÑ(C, ?x) UNION ùëÑ(D, ?x)}<label>(13)</label></formula><p>The generality ùëî Dis(ùê∂,ùê∑) can be obtained by computing the min value in the supports of axiom components ùëîùê∂ , ùëîùê∑ with the following SPARQL queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SELECT( count (DISTINCT</head><formula xml:id="formula_15">?x) ùê¥ùëÜ ?u C)WHERE {ùëÑ(C, ?x)} SELECT( count (DISTINCT ?x) ùê¥ùëÜ ?u D)WHERE {ùëÑ(D, ?x)}<label>(14)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Gold Standard Construction</head><p>In order to evaluate the effectiveness of our method in discovering disjointness class axioms, we use a manually created benchmark of class disjointness axioms, which we call the Gold Standard.</p><p>The process of creating the Gold Standard was carried out by knowledge engineers and consisted of two phases illustrated in Fig. <ref type="figure" target="#fig_3">2</ref>. In the first phase, the disjointness of the top-most classes to their siblings was assessed manually. Therefrom, two sibling classes being disjoint will automatically imply the disjointness of their corresponding pair of subclasses. This process was repeated in the same way on the next level of concepts. The second phase consisted in manually annotating the disjointness for the not yet assessed pairs of classes which did not belong to the cases given in the previous phase. The result of the completion of the Gold Standard is a matrix representing the disjointness evaluation between pairs of distinct atomic class expressions. We first constructed the (62 √ó 62) matrix 14 of class disjointness axioms relevant to the Work topic of DBpedia 2015-04. This matrix contains (0 and 1) values representing the disjointness evaluation between 3,844 pairs of classes relevant to the topic, with 1,891 pairs of distinct asymmetric classes.</p><p>In compliance with the Gold Standard thus constructed, we can measure the quality of class disjointness axioms involving both atomic and more complex types, i.e. involving the intersection and union operators. Algorithm 1 describes in detail how a complex axiom is assessed using the Gold Standard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sibling class pairs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Assess the disjointness of sibling classes</head><p>The disjointness information of sibling classes + The disjointness information of their subclasses</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Disjointness state</head><p>Check and annotate the disjointness or the nondisjointness</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Non-disjointness state</head><p>The annotation information of pairs of class</p><p>The not yet noted pairs of class</p><p>The non-disjointness information of sibling classes II I Matrix of the annotation between pairs of class containing a set of values 0, i.e. non-disjoint and 1, i.e. disjoint. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Gold Standard</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTS &amp; RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Protocol</head><p>We applied the proposed approach, introduced in Section 4, to mining class disjointness axioms from DBpedia, a large real-world RDF dataset.</p><p>The axioms involving both atomic and complex classes relevant to topic Work are systematically generated and evaluated on DBpedia version 2015-04 in English as the reference We use the BNF grammar of disjointness axioms shown in Section 4.1. However, to increase the success of the mapping to complex axiom expressions, we double the appearance probability of non-terminal ClassExpression. Rule (r4) in the grammar is thus modified to</p><formula xml:id="formula_16">(r4) ClassExpression := Class (0) | Class (1) | ObjectUnionOf (2) | ObjectIntersectionOf (3)</formula><p>Although the main purpose of our research is to focus on exploring complex disjointness axioms involving intersection and union, we also performed experiments to generate axioms involving atomic classes only, for comparison purpose. In that case, Rule (r4) is simplified to only one option ClassExpression := Class .</p><p>We also increase the length of chromosomes initlenChrom (in the case of complex axioms) to 30 instead of 20 in <ref type="bibr" target="#b13">[14]</ref>.</p><p>The algorithm parameters, summarized in Table <ref type="table" target="#tab_2">2</ref>, were empirically determined by performing a systematic exploration of a grid of possible settings. A prototype system of the proposed method was developed in Java, using Apache Jena to interface with SPARQL endpoints and GEVA v.2.0 15 , a Java implementation of GE. To avoid overloading DBpedia's SPARQL endpoint, we set up a local mirror 16 using the Virtuoso Universal Server.</p><p>All the experiments have been performed on a HP ZBook 15 G3 Mobile Workstation equipped with an eight-core Intel i7 CPU 6820HQ processor at 2.7GHz clock speed, with 32 GB RAM, 1 TB of disk space under the Ubuntu 16.04 LTS 64-bit operating system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Results</head><p>In order to measure the effectiveness of the method, we ran it 3 times with the parameters shown in Table <ref type="table" target="#tab_2">2</ref> on either version of the BNF grammar of axioms, involving atomic and complex expressions: the results are available on line. 17 . We also carried out a comparison of our results with <ref type="bibr" target="#b13">[14]</ref> and GoldMiner <ref type="bibr" target="#b20">[21]</ref>. Precision and recall are computed against a publicly available Gold Standard 18 of class disjointness axioms introduced in sec. 4.4.</p><p>The results, shown in Table <ref type="table" target="#tab_3">3</ref>, confirm that the accuracy and the coverage of our approach in extracting atomic axioms are higher than the results of <ref type="bibr" target="#b13">[14]</ref> and GoldMiner. In terms of generating complex axioms, we witness a quite higher accuracy than in <ref type="bibr" target="#b13">[14]</ref> and a superiority of our method compared with GoldMiner. In the recall comparison for the case of atomic axioms, we can also observe that the coverage of the set of generated atomic axiom in each run is much higher than the result in <ref type="bibr" target="#b13">[14]</ref>. The recall value in GoldMiner is constant, namely 0.38, because that algorithm is deterministic, 15 http://ncra.ucd.ie/Site/GEVA.html 16 https://joernhees.de/blog/2015/11/23/setting-up-a-linked-data-mirrorfrom-rdf-dumps-dbpedia-2015-04-freebase-wikidata-linkedgeodata-withvirtuoso-7-2-1-and-docker-optional/ </p><formula xml:id="formula_17">(1) ‚Üê ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ) ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (1) ‚Üê ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö) R ‚Üê CheckDisjointAtomicClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 [1],ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 [1])</formula><p>CheckDisjointAtomicClasses(classexpr1,classexpr2 ) scans in the matrix G and returns 0, i.e. non-disjoint or 1, i.e disjoint. else if ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ) is a complex expression containing union operator "ObjectUnionOf" R ‚Üê CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 <ref type="bibr" target="#b0">[1]</ref>,ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö)) + CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ -1),ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö)) if ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ) is a complex expression containing union operator "ObjectIntersectionOf" R ‚Üê CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 <ref type="bibr" target="#b0">[1]</ref>,ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö)) * CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ -1),ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö)) if ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö) is a complex expression containing union operator "ObjectUnionOf" R ‚Üê CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ),ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 <ref type="bibr" target="#b0">[1]</ref>) + CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ),ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö -1)) if ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö) is a complex expression containing union operator "ObjectIntersectionOf" R ‚Üê CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ),ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 <ref type="bibr" target="#b0">[1]</ref>) * CheckDisjointClasses(ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ),ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 2 (ùëö -1)) 2: return R while ours is stochastic. Therefore, the comparison in this case is unnecessary. Also, the overall recall value gets much higher, namely 0.323 over 3 runs, and would easily overtake the results of GoldMiner and <ref type="bibr" target="#b13">[14]</ref> simply by executing more runs. We do not present the recall for complex axioms, because it is not clear how the cardinality of the set of all true complex axioms should be computed; under the most general assumptions, this set is infinite, although enumerable. Fig. <ref type="figure" target="#fig_5">3</ref> plots the generality of discovered axioms against their possibility degree. Most discovered axioms are highly possible (Œ†(ùúë) close to 1) and most are supported by a large number of facts (instances) both in the atomic and complex case. In terms of generality, some discovered axioms have a particularly high generality, i.e. true axioms, such as Disjoint-Classes(dbo:Article dbo:Image) (ùëî ùúë = 2, 220, 106) or Disjoint-Classes(dbo:Image ObjectUnionOf(ObjectUnionOf( dbo:Album dbo:TelevisionShow) dbo:Website)) (ùëî ùúë = 190, 783). This can be explained by the existence of classes supported by a huge number of instances (like dbo:Article or dbo:Image) in the content of the generated axioms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We have proposed an improved fitness function for a method using GE to learn OWL class disjointness axioms from RDF datasets. We have thoroughly tested the proposed method on a subset of DBpedia through extensive experiments with different parameter settings, to investigate the effectiveness of the method.</p><p>The results support the effectiveness of the proposed method to generate atomic axioms with high accuracy and coverage and suggest further improvements in the case of complex axioms. The results also shed more light on the use of GE to learn axioms. Based on their analysis, some promising research directions clearly emerge:</p><p>(1) tune the fitness function to better suit complex axioms;</p><p>(2) implement the method on parallel hardware to carry out a more ambitious experimental validation using bigger datasets.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>r1) Axiom := ClassAxiom (r2) ClassAxiom := DisjointClasses (r3) DisjointClasses := 'DisjointClasses' '(' ClassExpression ' 'ClassExpression 'ObjectUnionOf := 'ObjectUnionOf' '(' ClassExpression ' ' ClassExpression ')' (r6) ObjectIntersectionOf := 'ObjectIntersectionOf' '(' ClassExpression ' ' Class-Expression ')' % Dynamic part -Primitives (r.7) Class := % production rules are constructed by using SPARQL queries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>PREFIX dbr: http://dbpedia.org/resource/ PREFIX dbo: http://dbpedia.org/ontology/ PREFIX rdf: http://www.w3.org/1999/02/22\-rdf-syntax-ns\# dbr:Quiet_City_(film) (comics) rdf:type dbo:Comic and options for the Class non-terminal are represented as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Workflow of class disjointness axioms learning from an RDF repository using GE.</figDesc><graphic coords="6,104.24,83.69,403.53,141.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The process of Gold Standard creation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>14 https://bitbucket.org/RDFMiner/disjointnessclassaxiomge/src/master/GoldStandard.csv RDF fact repository. Of 62 classes about the Work topic in DBpedia 2015-04, 53 classes with 5,195,019 instances are relevant to our experiments. All data used in this experiment are represented by RDF triples, as in the examples of Section 4.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Possibility and generality distribution of the discovered axioms.</figDesc><graphic coords="10,104.24,175.94,403.48,122.03" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>An illustration of mapping process to an expression of class disjointness axiom</figDesc><table><row><cell>Codon</cell><cell>Rule</cell><cell>Option</cell><cell>Mapped Expression</cell></row><row><cell>-</cell><cell>(r.1)</cell><cell>-</cell><cell>ClassAxiom</cell></row><row><cell>-</cell><cell>(r.2)</cell><cell>-</cell><cell>DisjointClasses</cell></row><row><cell>-</cell><cell>(r.3)</cell><cell>-</cell><cell>'DisjointClasses''('ClassExpression' ' ClassExpression')'</cell></row><row><cell>253</cell><cell>(r.4)</cell><cell>(1)</cell><cell>'DisjointClasses' (ObjectUnionOf' 'ClassExpression')'</cell></row><row><cell>-</cell><cell>(r.5)</cell><cell>-</cell><cell>'DisjointClasses''(''ObjectUnionOf''('ClassExpression' 'ClassExpression')'ClassExpression')'</cell></row><row><cell>213</cell><cell>(r.4)</cell><cell>(0)</cell><cell>'DisjointClasses''(''ObjectUnionOf''('Class' 'ClassExpression')' 'ClassExpression')'</cell></row><row><cell>397</cell><cell>(r.7)</cell><cell>(2)</cell><cell>'DisjointClasses'"(''ObjectUnionOf''('dbo:WrittenWork' 'ClassExpression')' 'ClassExpression')'</cell></row><row><cell>387</cell><cell>(r.4)</cell><cell>(0)</cell><cell>'DisjointClasses''(''ObjectUnionOf''('dbo:WrittenWork' 'Class')'ClassExpression')'</cell></row><row><cell>268</cell><cell>(r.7)</cell><cell>(3)</cell><cell>'DisjointClasses''(''ObjectUnionOf''('dbo:WrittenWork' 'dbo:Book')'ClassExpression')'</cell></row><row><cell>342</cell><cell>(r.4)</cell><cell>(0)</cell><cell>'DisjointClasses''(''ObjectUnionOf''('dbo:WrittenWork' 'dbo:Book')'Class')'</cell></row><row><cell>321</cell><cell>(r.7)</cell><cell>(1)</cell><cell>'DisjointClasses''(''ObjectUnionOf''('dbo:WrittenWork' 'dbo:Book')'dbo:MusicalWork')'</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>17 https://bitbucket.org/RDFMiner/classdisjointnessaxioms/src/master/Results/ 18 https://bitbucket.org/RDFMiner/classdisjointnessaxioms/src/master/Results/GoldStanda class expressions being arguments in axiom, n,m: the numbers of the classes contained in the class expressions; G: matrix of Gold Standard Output: R: Results of disjointness -returns to a non-negative integer value if the return value is greater 0, classexpr1(n) and classexpr2(m) are disjoint if the return value equals 0, classexpr1(n) and classexpr2(m) are non-disjoint 1: if both ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1 (ùëõ) and ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü( 2 (ùëö) are atomic expressions ùëêùëôùëéùë†ùë†ùëíùë•ùëùùëü 1</figDesc><table><row><cell>Algorithm1 -CheckDisjointClasses(classexpr1(n), classexpr2(m))</cell></row><row><cell>Input: classexpr1(n), classexpr2(m):</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Parameter values for the GE</figDesc><table><row><cell>Parameter</cell><cell>Atomic Axioms</cell><cell>Complex Axioms</cell></row><row><cell>initLenChrom</cell><cell>5</cell><cell>30</cell></row><row><cell>maxWrap</cell><cell>2</cell><cell>2</cell></row><row><cell>pCross</cell><cell>80%</cell><cell>80%</cell></row><row><cell>pMut</cell><cell>1%</cell><cell>1%</cell></row><row><cell>popSize</cell><cell>2,000</cell><cell>2,000</cell></row><row><cell>nGenerations</cell><cell>25</cell><cell>5</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Experimental results</figDesc><table><row><cell></cell><cell>Our approach</cell><cell></cell><cell>Results in [14]</cell><cell></cell><cell>GoldMiner</cell></row><row><cell></cell><cell>Atomic</cell><cell>Complex</cell><cell>Atomic</cell><cell>Complex</cell><cell>Atomic</cell></row><row><cell></cell><cell>axioms</cell><cell>axioms</cell><cell>axioms</cell><cell>axioms</cell><cell>axioms</cell></row><row><cell>Precision</cell><cell>0.958 ¬± 0.011</cell><cell>0.876 ¬± 0.01</cell><cell>0.95 ¬± 0.02</cell><cell>0.867 ¬± 0.03</cell><cell>0.95</cell></row><row><cell>Recall (per run)</cell><cell>0.247 ¬± 0.01</cell><cell>N/A</cell><cell>0.15 ¬± 0.017</cell><cell>N/A</cell><cell>N/A</cell></row><row><cell>Recall (overall)</cell><cell>0.323 (over 3 runs)</cell><cell>N/A</cell><cell>0.69 (over 20 runs)</cell><cell>N/A</cell><cell>0.38</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>These figures can be obtained by executing the querry " SELECT (COUNT( DISTINCT ?subject) as ?numberClasses" on http://dbpedia.org/sparql</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://www.w3.org/standards/semanticweb/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>https://www.w3.org/RDF/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>https://docs.microsoft.com/en-us/windows/desktop/winrm/uriprefixes</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p><ref type="bibr" target="#b4">5</ref> https://www.w3.org/TR/rdf-sparql-</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>query/ 6 https://lod-</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>cloud.net/ 7 http://</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>linkeddata.org/ 8 https://</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>wiki.dbpedia.org/ 9 https://www.w3.org/TR/owl-ref/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>https://www.w3.org/TR/owl2-syntax/#Disjoint Classes</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>https://www.w3.org/TR/owl2-syntax/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>https://www.w3.org/TR/owl2-syntax/#Functional-Style Syntax</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Universal OWL Axiom Enrichment for Large Knowledge Bases</title>
		<author>
			<persName><forename type="first">Lorenz</forename><surname>B√ºhmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Lehmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EKAW</title>
		<title level="s">Lecture Notes in Computer Science)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7603</biblScope>
			<biblScope unit="page" from="57" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Pattern Based Knowledge Base Enrichment</title>
		<author>
			<persName><forename type="first">Lorenz</forename><surname>B√ºhmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Lehmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<title level="s">Lecture Notes in Computer Science)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8218</biblScope>
			<biblScope unit="page" from="33" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Positional Effect of Crossover and Mutation in Grammatical Evolution</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>Castle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><forename type="middle">G</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroGP</title>
		<title level="s">Lecture Notes in Computer Science)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">6021</biblScope>
			<biblScope unit="page" from="26" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Foundations in Grammatical Evolution for Dynamic Environments -Chapter 2 Grammatical Evolution</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Dempsey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O'</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Neill</surname></persName>
		</author>
		<author>
			<persName><surname>Brabazon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Studies in Computational Intelligence</title>
		<imprint>
			<biblScope unit="volume">194</biblScope>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Inductive Learning of Disjointness Axioms</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Fleischhacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johanna</forename><surname>V√∂lker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OTM Conferences</title>
		<title level="s">Lecture Notes in Computer Science)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="680" to="697" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Toward principles for the design of ontologies used for knowledge sharing?</title>
		<author>
			<persName><forename type="first">R</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><surname>Gruber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Hum.-Comput. Stud</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="907" to="928" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">What Is an Ontology? Handbook on Ontologies</title>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Guarino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Oberle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steffen</forename><surname>Staab</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Article: A Survey of Ontology Learning Approaches</title>
		<author>
			<persName><forename type="first">Maryam</forename><surname>Hazman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Samhaa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>El-Beltagy</surname></persName>
		</author>
		<author>
			<persName><surname>Rafea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Applications</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="36" to="43" />
			<date type="published" when="2011-05">2011. May 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Genetic programming -on the programming of computers by means of natural selection</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Genetic Programming: An Introduction and Tutorial, with a Survey of Techniques and Applications</title>
		<author>
			<persName><forename type="first">B</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Langdon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Poli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">R</forename><surname>Freitag Mcphee</surname></persName>
		</author>
		<author>
			<persName><surname>Koza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Intelligence: A Compendium (Studies in Computational Intelligence)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="927" to="1028" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">DL-Learner: Learning Concepts in Description Logics</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Lehmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="2639" to="2642" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Perspectives on Ontology Learning</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johanna</forename><surname>V√∂lker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Studies on the Semantic Web</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="2014">2014</date>
			<publisher>IOS Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Ontology learning for the Semantic Web</title>
		<author>
			<persName><forename type="first">A</forename><surname>Maedche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intelligent Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="72" to="79" />
			<date type="published" when="2001-03">2001. March 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Learning Class Disjointness Axioms Using Grammatical Evolution</title>
		<author>
			<persName><forename type="first">Thu</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Huong</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><forename type="middle">G B</forename><surname>Tettamanzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eu-roGP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">11451</biblScope>
			<biblScope unit="page" from="278" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Grammatical Evolution</title>
		<author>
			<persName><forename type="first">M</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ryan</surname></persName>
		</author>
		<idno type="DOI">10.1109/4235.942529</idno>
		<ptr target="https://doi.org/10.1109/4235.942529" />
	</analytic>
	<monogr>
		<title level="j">Trans. Evol. Comp</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="349" to="358" />
			<date type="published" when="2001-08">2001. Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Crossover in Grammatical Evolution</title>
		<author>
			<persName><forename type="first">O'</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Conor</forename><surname>Neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maarten</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Keijzer</surname></persName>
		</author>
		<author>
			<persName><surname>Cattolico</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetic Programming and Evolvable Machines</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="67" to="93" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Layering the Semantic Web: Problems and Directions</title>
		<author>
			<persName><forename type="first">F</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dieter</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><surname>Fensel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2342</biblScope>
			<biblScope unit="page" from="16" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Grammatical Evolution: Evolving Programs for an Arbitrary Language</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Conor Ryan</surname></persName>
		</author>
		<author>
			<persName><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O'</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Neill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroGP</title>
		<title level="s">Lecture Notes in Computer Science)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1391</biblScope>
			<biblScope unit="page" from="83" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The state of the art in ontology learning: a framework for comparison</title>
		<author>
			<persName><forename type="first">Mehrnoush</forename><surname>Shamsfard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahmad</forename><surname>Abdollahzadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barforoush</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge Eng. Review</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="293" to="316" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Testing OWL Axioms against RDF Facts: A Possibilistic Approach</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">B</forename><surname>Andrea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catherine</forename><surname>Tettamanzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabien</forename><forename type="middle">L</forename><surname>Faron-Zucker</surname></persName>
		</author>
		<author>
			<persName><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EKAW</title>
		<title level="s">Lecture Notes in Computer Science)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8876</biblScope>
			<biblScope unit="page" from="519" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Automatic acquisition of class disjointness</title>
		<author>
			<persName><forename type="first">Johanna</forename><surname>V√∂lker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Fleischhacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiner</forename><surname>Stuckenschmidt</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.websem.2015.07.001</idno>
		<ptr target="https://doi.org/10.1016/j.websem.2015.07.001" />
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="124" to="139" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning Disjointness</title>
		<author>
			<persName><forename type="first">Johanna</forename><surname>V√∂lker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denny</forename><surname>Vrandecic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">York</forename><surname>Sure</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Hotho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<title level="s">Lecture Notes in Computer Science)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4519</biblScope>
			<biblScope unit="page" from="175" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fuzzy Sets as a Basis for a Theory of Possibility</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Zadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fuzzy Sets and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="3" to="28" />
			<date type="published" when="1978">1978. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
