<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>FRANC ¸OIS GOASDOU É, PAWE L GUZEWICZ</roleName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
						</author>
						<title level="a" type="main">RDF GRAPH SUMMARIZATION FOR FIRST-SIGHT STRUCTURE DISCOVERY</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">281233985D2B275371F21FD845A1CA1D</idno>
					<idno type="DOI">10.1007/s00778-020-00611-y</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>To help users get familiar with large RDF graphs, RDF summarization techniques can be used. In this work, we study quotient summaries of RDF graphs, that is: graph summaries derived from a notion of equivalence among RDF graph nodes. We make the following contributions: (i) four novel summaries which are often small and easy-to-comprehend, in the style of E-R diagrams; (ii) efficient (amortized linear-time) algorithms for computing these summaries either from scratch, or incrementally, reflecting additions to the graph; (iii) the first formal study of the interplay between RDF graph saturation in the presence of an RDFS ontology, and summarization; we provide a sufficient condition for a highly efficient shortcut method to build the quotient summary of a graph without saturating it; (iv) formal results establishing the shortcut conditions for some of our summaries and others from the literature; (v) experimental validations of our claim within a tool available online.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The Resource Description Framework (RDF) is the data model recommended by the W3C for data publishing and sharing data. An RDF graph typically consists of data triples, stating that a subject has a property with a certain value, called object. An RDF graph may also contain type triples, stating that some resource has the W3C standard rdf:type property (type for short) whose value is a certain type (or, equivalently, class). Finally, an RDF graph may also contain an ontology, describing relationships that hold between the properties and classes present in the graph. For instance, u 1 hasName "Julie", u 1 worksFor "ACME" describe a resource whose identifier (URI) is u 1 , while u 1 type Person assigns it a type; we use quote-enclosed strings to denote constants (also called literals). An ontology associated to this sample dataset may state e.g., that worksFor rdfs:domain Employee: this means "anyone who works for something is of Date: Accepted on April 1, 2020 for publication in VLDB Journal.</p><p>type Employee". As a consequence, u 1 type Employee also holds in the above graph, although it is not explicitly written there. Such a triple is called implicit (or inferred, or entailed).</p><p>RDF graphs enable describing large and heterogeneous data sets, which may be hard to understand by human users, and to analyze by machines. To help address this difficulty, many RDF summarization techniques have been proposed in the literature <ref type="bibr" target="#b6">[7]</ref>, some of which draw upon graph summarization techniques <ref type="bibr" target="#b28">[29]</ref> proposed independently of RDF. As stated in <ref type="bibr" target="#b6">[7]</ref>, RDF summarization techniques fall into four classes: (i) structural methods are built considering first and foremost the graph structure, respectively the paths and subgraphs present in the graph; (ii) pattern mining methods apply mining techniques to discover patterns in the data and use the patterns as a summary (synthesis) of the graph; (iii) statistical methods aim at extracting from the graph a set of quantitative measures or statistics; finally (iv) hybrid methods combine elements from more than one of the previous classes. For what concerns summary applications, these range from (RDF) graph indexing, query cardinality estimation, to helping users formulate graph queries, graph visualization and exploration.</p><p>A large and useful class of structural graph summaries are based on defining an equivalence relation among graph nodes, and creating one summary node for each equivalence class (set of nodes equivalent to each other in the original graph). Then, for every edge labeled p which goes from s to o in the graph, the summary has an edge labeled p from the summary node corresponding to the equivalence class of s, to the node corresponding to the equivalence class of p. Such summaries, also called quotient summaries, have many good properties, mainly due to the existence of a graph homomorphism from the original graph into its summary. Quotient summaries proposed for general graphs include <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>Summarizing RDF graphs raises two new questions w.r.t. to prior (non-RDF) graph summarization setting: (i) how to take into account the types that may be attached to the nodes (knowing that a node may have no type, or one type, or several)? On one hand, types bring an opportunity to define node equivalence, since, intuitively, two nodes having the same type(s) are likely similar in sole way. On the other hand, they cannot be solely relied upon, because many RDF graphs lack types for many (or all) of their nodes; prior RDF summary quotients <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b4">5]</ref> answer this question in different ways; (ii) how should a summary reflect the implicit triples that may hold in the graph due to the presence of an ontology? Our prior poster paper <ref type="bibr" target="#b7">[8]</ref> is the only work to have addressed this so far.</p><p>In this work, we make several theoretical and practical contributions to the area of quotient RDF graph summarization. Specifically: <ref type="bibr" target="#b0">(1)</ref> We formalize an RDF quotient summarization framework, taking into account RDFspecific concepts such as ontologies. <ref type="bibr" target="#b1">(2)</ref> We introduce two novel equivalence relations between RDF nodes, which rely on the transitive co-occurrence of properties on graph nodes. Based on them we define two novel summaries called Weak and Strong respectively, as well as two versions thereof which give priorities to types (for those nodes that have type information); we call these summaries Typed Weak and Typed Strong, respectively. The interest of these new equivalence relations is that they lead to summaries that are much more compact (fewer nodes and edges) than quotient summaries previously studied in the literature <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b4">5]</ref>. This compactness comes at the price of some loss of accuracy. Nevertheless, they do preserve a significant amount of information from the input graph. In particular, for domain-specific graphs, describing applications from a specific area, our summaries are very convenient data discovery tools: a simple summary visualization helps learn a lot about the graph structure. This is why our work's main target are domain-specific graphs. For encyclopedic graphs, such as DBPedia or YAGO, our quotients are very likely to be more compact than some studied in prior work, but still too large for human comprehension; non-quotient summaries, e.g., based on pattern mining <ref type="bibr" target="#b6">[7]</ref>, are more appropriate for such graphs. <ref type="bibr" target="#b2">(3)</ref> We are the first to show that for a large set of RDF equivalence relations, one can build the quotient summary of an RDF graph including its implicit triples, without materializing them. Based on our framework, we provide a novel sufficient condition for an RDF equivalence relation, which enables building this through our so-called shortcut method; its advantage is to reduce very significantly the summarization time.</p><p>We prove that our Weak and Strong summaries satisfy this condition, whereas the Typed Weak and Typed Strong ones do not; we provide a set of similar results also on previously studied equivalence relations.</p><p>(4) Our fourth contribution is a set of novel algorithms for computing our summaries, including incremental ones which are able to reflect the addition of triples to the graph, without re-traversing the rest of the graph. All our algorithms have amortized linear complexity in the size of the graph. <ref type="bibr" target="#b4">(5)</ref> We have implemented these algorithms and summary visualizations in a system called RDFQuotient, available online in open source <ref type="foot" target="#foot_0">1</ref> . Sample summary visualization Below, we show an example where our summarization techniques compress an RDF graph structure by many orders of magnitude, while still supporting an informative visualization.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows the summary of a WatDiv <ref type="bibr" target="#b1">[2]</ref> benchmark graph of approximately 11 millions of triples. This visualization reflects the complete structure of the graph, using only 8 nodes and 24 edges, comparable to a simple Entity-Relationship diagram. This summary reads as follows. (i) Nonleaf graph nodes belong to one of the eight disjoint entities, each represented by a summary node (box in Figure <ref type="figure" target="#fig_0">1</ref>) labeled N 1 to N 8. The number of graph nodes in each entity appears in parenthesis after the label N i of their representative, e.g., 25000 for N 8. (ii) Each entity represents either graph nodes with types or without types. In the first case, the most general types of the graph nodes, according to which they have been grouped in the entity, are given in bold underneath the entity label; these coincide with the original graph node types when an ontology is not present. For instance, all the 25000 graph nodes represented by N 8 are (implicitly) of type ProductCategory due to the ontology at hand; their distribution according to their original typing is also shown, e.g., 807 are of type ProductCategory0. An entity that does not show types represents untyped graph nodes which have been grouped according to the relationships they have with others, using a novel transitive relation of co-occurrence of their properties, which we introduce in this paper. For instance, N 4 represents both the web pages of the products of N 8 and these of the persons of N 7, because these web pages can be home pages for both: there are homepage edges from both N 8 to N 4 and from N 7 to N 4. (iii) Graph nodes from an entity may have outgoing properties whose values are leaf nodes in the graph; the set of all such properties appears in the corresponding summary node box, one property per line. For each property, e.g., nationality for N 7, the summary node specifies how many graph nodes represented by this entity have it (19924 in this case), and how many distinct leaf nodes are target of these edges (25 in this case). (iv) Graph nodes from an entity may have outgoing properties whose values are non-leaf nodes in the graph. For each graph edge n 1 a -→ n 2 , where n 1 , n 2 are non-leaf graph nodes and a is the property (edge label), an a-labeled edge in the summary goes from the representative of n 1 to that of n 2 . Next to a, that summary edge is also labeled with the number of graph edges to which it corresponds. (v) Properties from a small, fixed vocabulary are considered metadata (as opposed to data) and therefore are not used to split graph nodes in entities, e.g., rdf-schema#comment and rdf-schema#label in Figure <ref type="figure" target="#fig_0">1</ref>. More such visualization summaries can be found online 1 ; an example leading from an RDF graph to its summary and then such a visualization is worked out in the paper. Most of the material presented here is new. The exceptions are: Theorem 2 appeared without proof in the poster <ref type="bibr" target="#b7">[8]</ref>; our algorithms were outlined in the demonstration <ref type="bibr" target="#b14">[15]</ref>.</p><p>Below, Section 2 recalls useful preliminaries, then Section 3 introduces the novel notions of property cliques, based on which we define our summaries. Section 4, respectively, 5 extend this to graphs comprising type triples, respectively, ontologies. In Section 6 we discuss summary visualization. Section 7 describes our summarization algorithms and Section 8 presents our experiments. We then survey related work and conclude. Proofs of the technical results of this paper can be found in the Appendix. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>We recall here the starting points of our work: RDF graphs (Section 2.1) and graph quotients (Section 2.2).</p><p>2.1. Data graphs. An RDF graph is a set of triples of the form s p o. A triple states that its subject s has the property p, and the value of that property is the object o. We consider only wellformed triples, as per the RDF specification <ref type="bibr" target="#b37">[38]</ref>, using uniform resource identifiers (URIs), typed or untyped literals (constants) and blank nodes (unknown URIs or literals). Blank nodes are essential features of RDF allowing to support unknown URI/literal tokens. These are conceptually similar to the labeled nulls or variables used in incomplete relational databases <ref type="bibr" target="#b0">[1]</ref>, as shown in <ref type="bibr" target="#b15">[16]</ref>.</p><p>As our running example, Figure <ref type="figure" target="#fig_1">2</ref> shows a sample RDF graph G describing a university department, including professors, graduate students, articles they wrote, and courses they teach and/or take. Here and in the sequel, nodes shown in gray are classes (or types). Further, nodes whose labels appear enclosed in quotes, e.g., "d1", are literals, while the others are URIs. RDFS ontology. One can enhance the resource descriptions comprised in an RDF graph by declaring ontological constraints between the classes and the properties they use. For instance, one may add to the graph in Figure <ref type="figure" target="#fig_1">2</ref>  From ontological constraints and explicit triples, implicit triples may be derived. For instance, from G and O, it follows that p 1 is of type Instructor, which is modeled by the implicit triple p 1 type Instructor; we say this triple holds in G, even though it is not explicitly part of it. Other implicit triples obtained from this ontology based on G are: p 2 type Instructor, p 2 type Student, and p 1 knows p 2 . Given a graph G (which may include a set of ontological constraints, denoted O), the saturation of G, is obtained by adding to G: (i) all the implicit triples derived from G and O, then (ii) all the implicit triples derived from those of step (i) and O, and so on, until a fixpoint, denoted G ∞ , is reached. These triples are added based on RDF entailment rules from the RDF standard. In this work, we consider the widely-used RDFS entailment rules. They exploit the simple RDFS ontology language, based on the four standard properties illustrated above, which we denote subClass, subProperty, domain and range, to add new ontological constraints or facts. The saturation G ∞ of any graph G comprising RDFS ontological constraints is finite, unique, and can be computed in polynomial time, e.g., by leveraging a database management system <ref type="bibr" target="#b15">[16]</ref>. Crucially, G ∞ materializes the semantics of G. Terminology and notations. We call the triples from G whose property is (rdf:)type type triples, those whose property is among the standard four RDFS ones schema triples, and we call all the other data triples. We say a node is typed in G if the node is the subject of at least one type triple in G. In the graph shown in Figure <ref type="figure" target="#fig_1">2</ref>, p1 type Professor is a type triple, hence the node p1 is typed, p1 advises p2 is a data triple, while Professor rdfs:subClassOf Instructor may be a schema triple. Further, we say a URI from G is a class node if (i) it appears as subject or object of a subClass triple, or an object of range or domain triple; or (ii) it appears as the object of a type triple; or (iii) it appears as a subject of a type triple with object rdfs:Class. We call property node, a URI appearing (i) as subject or object in subProperty triple, or as a subject of domain or range triple; or (ii) as a subject of rdf:type triple with object rdf:Property. Together, the class and property nodes are the schema nodes; all nonschema nodes are data nodes. In Figure <ref type="figure" target="#fig_1">2</ref>, Professor and GradStudent are class nodes. If we consider the aforementioned ontology O, takes, advises and knows are property nodes. Finally, the a's, p's, c's and d's nodes are data nodes.</p><p>It is important to stress that not all nodes in an RDF graph are typed, e.g., this is only true for p 1 and p 2 in Figure <ref type="figure" target="#fig_1">2</ref>. Further, some nodes may have several types, in particular due to saturation (e.g., p 2 is of types GradStudent and Instructor) but not only, e.g., p 1 could also be of type ForeignStudent etc.</p><p>2.2. Quotient RDF summaries. We recall here quotient RDF summaries as defined in prior work, outline existing work in this area, and discuss their limitations.</p><p>Given an RDF graph G and an equivalence relation 2 ≡ over the nodes of G, the quotient of G by ≡, denoted G /≡ , is the graph having (i) a node for each equivalence class of ≡ (thus, for each set of equivalent G nodes); and (ii) for each edge n 1 G node, its representative in G /≡ is a homomorphism from G into its summary: any subgraph of G is "projected" by f into a subgraph of its quotient.</p><formula xml:id="formula_0">a -→ n 2 in G, an edge m 1 a -→ m 2 ,</formula><p>Quotient graph summaries include e.g., <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b12">13]</ref>; RDF quotient summaries are described in <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b4">5]</ref>. Bisimilarity is behind most equivalence relations used in these works. Two nodes n 1 , n 2 are forward bisimilar <ref type="bibr" target="#b20">[21]</ref> (denoted ≡ fw ) iff (i) for every G edge n 1 a -→ m 1 , G also comprises an edge n 2 a -→ m 2 , such that m 1 and m 2 are also (forward) bisimilar and (ii) a similar statement holds, replacing n 1 , m 1 with n 2 , m 2 and vice-versa. While forward bisimilarity focuses on outgoing edges only, two nodes can also be bisimilar w.r.t. their incoming edges, i.e., backward bisimilar (denoted ≡ bw ). Backward similarity of two nodes n 1 , n 2 is recursively defined similarly as above when considering G edges m 1 a -→ n 1 and m 2 a -→ n 2 . Finally, two nodes can be bisimilar based on both their incoming and outgoing edges, i.e., forward and backward bisimilar (denoted ≡ fb ), when they are both forward bisimilar and backward bisimilar. We denote the bisimulation based summaries G /fw (forward), G /bw (backward) and G /fb (forward and backward), respectively. They have been studied, in particular for indexing and query processing, in <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b34">35]</ref>. Leaf (resp. root) collapse An issue encountered when summarizing only according to the properties outgoing a node, e.g., ≡ fw , is that the summary considers equivalent (thus, collapses) all nodes lacking outgoing edges, that is, all the leaves of G. Such leaf nodes may have very little to do with each other. For instance, on the WatDiv graph summarized in Figure <ref type="figure" target="#fig_0">1</ref>, all the values of award, numberOfPages, keywords, email, faxNumber would be summarized together, even though they are very different. We call this situation leaf collapse through summarization. symmetrically, a summary whose relation only depends on nodes' incoming properties, e.g., ≡ bw , automatically summarizes together all nodes with no incoming edges, although again they may represent very different things; we call this root collapse. We argue that a good summary should not systematically collapse leaves (respectively, roots), but do so only when they really are similar to each other.</p><p>Bisimulation summaries tend to be large, because bisimilarity is rare in heterogeneous graphs. For instance, in Figure <ref type="figure" target="#fig_1">2</ref>, none of p 1 , p 2 , . . . p 5 is bisimilar to the other, due to slight differences in their properties; similarly, the courses c 1 , c 2 and c 3 are not bisimilar, because c 3 lacks a description, c 2 is the only one target of a "takes" triple etc. Our experiments in Section 8 confirm this on many graphs. Bounded bisimilarity To mitigate this problem, k-bisimilarity was introduced <ref type="bibr" target="#b22">[23]</ref>. For some integer  k, nodes are k-forward (and/or backward) bisimilar iff they are bisimilar within their k-bound neighborhoods. One drawback of k-bisimilarity is that it requires users to guess the k value leading to the best compromise between compactness (favored by a low k, e.g., if k = 0, all the graph nodes are equivalent, and the summary has a single node) and structural information in the summary (high k). RDF quotients based on k-bisimilarity are studied in <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b4">5]</ref>.</p><p>It turns out that even 1-bisimilarity is rare in heterogeneous graphs. For instance, Figure <ref type="figure" target="#fig_2">3</ref> shows the 1fb summary of the sample graph in Figure <ref type="figure" target="#fig_1">2</ref> 3 . Here and throughout this paper, summary nodes are shown in rectangles and are labeled N 1 , N 2 etc.; we abridge property names to use w for wrote, a for advises, te for teaches, ta for takes and cd for coursedescr. Nodes N 3 , N 4 and N 8 represent, respectively, p 1 , p 2 , p 3 ; the three courses are represented by N 1 and N 6 . This summary is almost as complex as the input graph. Figure <ref type="figure" target="#fig_3">4</ref> shows the 1fw summary of our sample G: it is smaller (only 5 nodes and 10 edges, whereas the 1fb one has 8 nodes and 12 edges). However, as our experiments show, 1fw summaries are still too large to be useful for visualization. The 1fw summary, denoted ∼ a in <ref type="bibr" target="#b4">[5]</ref>, is also very similar to grouping nodes into "characteristic sets" <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b31">32]</ref>; they all suffer from the leaf collapse issue described above. For instance, they summarize together all articles and course descriptions (N 2 in Figure <ref type="figure" target="#fig_3">4</ref>).</p><p>To avoid too many characteristic sets (or, equivalently, to reduce the number of summary nodes), <ref type="bibr" target="#b31">[32]</ref> proposes a cardinality-based heuristic method which merges them into maximum r sets, for a userspecified threshold r. We do not burden the user with choosing such a threshold; as our experiments show, some graphs are much more complex than 3 The summaries shown in the Figures <ref type="figure" target="#fig_11">3,</ref><ref type="figure" target="#fig_3">4</ref>   others, thus it is not easy to set r, especially for users not yet acquainted with the data, such as the ones we target.</p><p>In <ref type="bibr" target="#b4">[5]</ref>, any RDF equivalence relation (thus, any RDF quotient) considers all the leaf nodes, whether URIs or literals, as equivalent, and represents them by a single summary node denoted [0]. Thus, all their summaries automatically suffer from the leaf collapse issue. For instance, their 1fb equivalence (denoted ∼ ioa ) leads to the summary shown in Figure <ref type="figure" target="#fig_5">5</ref>. This may significantly reduce the number of summary nodes, since only one of them is a leaf. However, as reported in <ref type="bibr" target="#b4">[5]</ref> and verified in our experiments, their bisimilarity-based summaries are still too large for visualization. Type-driven summarization The remaining equivalence relations used in the literature to summarize RDF graphs are (also) based on RDF types.</p><p>In <ref type="bibr" target="#b4">[5]</ref>, two nodes are ∼ t -equivalent if they have exactly the same types. This collapses all untyped nodes in a single summary node, e.g., all but p 1 and p 2 in Figure <ref type="figure" target="#fig_1">2</ref>, and five out of the eight nodes in Figure <ref type="figure" target="#fig_0">1</ref> (N 2 , N 3 , N 4 , N 5 and N 6 ), even though they are unrelated.</p><p>[5] also introduces ∼ ioat , which considers two nodes equivalent iff they are 1fb equivalent and they have exactly the same types. Thus, a ∼ ioat summary has at least as many nodes and edges as the ∼ ioa one; our experiments confirm it is too large to be used for first-sight visualization.</p><p>To conclude, the equivalence relations used in prior RDF quotient summaries are based on:</p><p>(1) Bisimilarity (possibly bounded to a maximum distance k), which leads to complex summaries with very high numbers of nodes and edges, unsuited for first-sight discovery. (2) Uni-directional bisimilarity (i.e., ≡ fw , ≡ bw and their bounded variants), which suffer from leaf or root collapse; (3) Types alone: this collapses all untyped nodes, even when their data properties have nothing to do with each other; (4) Bisimilarity and having the same types; this leads to summaries at least as large as those based on bisimilarity alone.</p><p>Leaf collapse is also present in all the equivalences of <ref type="bibr" target="#b4">[5]</ref>. Another limitation of prior work is not considering how summarization interacts with saturation, and instead simply assuming that G is already saturated. When this is not the case, obtaining the summary of G ∞ requires first computing this saturation, which may be costly in terms of computation time and storage space.</p><formula xml:id="formula_1">G</formula><p>To go beyond these limitations, in the sequel, we introduce our novel equivalence relations, leading to compact and informative quotient summaries of RDF graphs, whether they are fully typed, have no types at all, or are anywhere in between. Further, we provide novel, advanced techniques for summarizing a graph's saturation without saturating it; this can lead to speed-ups of orders of magnitude. The notations we use in this work are compiled in Table <ref type="table" target="#tab_2">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Data graph summarization</head><p>We first consider graphs made of data triples only. We define the novel notion of property cliques in Section 3.1; building on them, we devise new graph node equivalence relations and corresponding graph summaries in Section 3.2. Summarization will be generalized to handle also type triples in Section 4.</p><p>3.1. Data property cliques. Let us consider the ways in which data properties (edge labels) are organized in a graph. The simplest relation is cooccurrence, when a node is the source (or target) of two edges carrying the two labels. However, as illustrated in Figure <ref type="figure" target="#fig_1">2</ref>, two properties, such as wrote and Table <ref type="table">2</ref>. Source and target cliques of G nodes (Figure <ref type="figure" target="#fig_1">2</ref>). advises, may co-occur on one node, while another one may have wrote and teaches. The main intuition of our work is to consider all these properties (wrote, advises, teaches) related, as they directly or transitively co-occur on some nodes. Formally: Definition 1. (Property relations and cliques) Let p 1 , p 2 be two data properties in G:</p><p>(1) p 1 , p 2 ∈ G are source-related iff either: (i) a data node in G is the subject of both p 1 and p 2 , or (ii) G holds a data node that is the subject of p 1 and of a data property p 3 , with p 3 and p 2 being source-related.</p><formula xml:id="formula_2">(2) p 1 , p 2 ∈ G are target-related iff either: (i) a</formula><p>data node in G is the object of both p 1 and p 2 , or (ii) G holds a data node that is the object of p 1 and of a data property p 3 , with p 3 and p 2 being target-related. A maximal set of data properties in G which are pairwise source-related (respectively, target-related) is called a source (respectively, target) property clique.</p><p>In the graph in Figure <ref type="figure" target="#fig_1">2</ref>, properties advises and teaches are source-related due to p 4 (condition (i) in the definition). Similarly, advises and wrote are source-related due to p 1 ; consequently, teaches and wrote are source-related (condition (ii)). Further, the graduate student p 2 teaches a course and takes another, thus teaches, advises, wrote and takes are all part of the same source clique. Table <ref type="table">2</ref> shows the target and source cliques of all data nodes from Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>It is easy to see that the set of non-empty source (or target) property cliques is a partition over the data properties of G. Further, if a node n ∈ G is a source of some data properties, they are all in the same source clique; similarly, all the properties of which n is a target are in the same target clique.   Strongly equivalent nodes have the same structure of incoming and outgoing edges. In Figure <ref type="figure" target="#fig_1">2</ref>, nodes p 1 , p 3 and p 4 are strongly equivalent to each other. Among these, note that p 1 and p 3 may seem very dissimilar: p 1 has the properties {wrote, ad-vises} while p 3 has only {teaches}. These nodes are strongly equivalent due to the node p 4 which has a common outgoing property with p 1 , and one with p 3 . Similarly, p 2 , p 5 are strongly equivalent, and so are c 1 , c 2 and c 3 etc. The transitivity built in strong equivalence through the use of cliques allows to recognize all these publication nodes as equivalent, and avoid separating them (as ≡ fb and ≡ fw do, recall Figures <ref type="figure" target="#fig_11">3,</ref><ref type="figure" target="#fig_3">4</ref> in Section 2.2). Thus, cliquebased equivalence avoids the pitfall of leading to too many nodes for a readable visualization.</p><p>A second, weaker notion of node equivalence requests only that equivalent nodes share the same incoming or outgoing structure, i.e., they share the same source clique or the same target clique. Formally: Definition 3. (Weak equivalence) Two data nodes n 1 , n 2 are weakly equivalent, denoted n 1 ≡ W n 2 , iff: (i) they have the same non-empty source or non-empty target clique, or (ii) they both have empty source and empty target cliques, or (iii) they are both weakly equivalent to another node of G.</p><p>It is easy to see that ≡ W and ≡ S are equivalence relations and that strong equivalence implies weak equivalence, noted ≡ S ⇒≡ W .</p><p>In Figure <ref type="figure" target="#fig_1">2</ref>, p 1 , . . . , p 5 are weakly equivalent to each other due to their common source clique SC 1 ; a 1 , a 2 are weakly equivalent due to their common target clique etc.</p><p>From the definitions above and the equivalence notions recalled in Section 2.2, it follows that ≡ 1fb is more restrictive than ≡ S (≡ 1fb ⇒≡ S ⇒≡ W ). However, ≡ S and ≡ W , which reflect outgoing and incoming properties, are in general incomparable with ≡ 1fw and ≡ 1bw , which only outgoing, respectively, incoming properties. The transitive aspect of property cliques is a radical departure from previously considered equivalence relations (Section 2). It gives ≡ S and ≡ W the flexibility to accept as equivalent structurally heterogeneous nodes, leading to summaries which are both meaningful and compact. Property nodes equivalence We make an important addition to the clique-based equivalences introduced above. A property node (Section 2.1), that is, a node (subject or object) labeled by an URI which also appears as a property of a data node, is only ≡ W and ≡ S to itself. Property nodes are pretty rare, but they do occur in some RDF graphs; an example would be the subject of a triple such as takes definedBy studentOfficerX, where takes appears as a data property in Figure <ref type="figure" target="#fig_1">2</ref>. A triple comprising a property node can be seen as a form of metadata, which helps interpret/understand the graph's data triples. Thus, we consider that a property node is only equivalent to itself. The weak summary of the graph in Figure <ref type="figure" target="#fig_1">2</ref> is depicted in Figure <ref type="figure" target="#fig_8">6</ref>. N 1 represents all the people (p 1 to p 5 ), N 2 represents the courses, N 3 the articles and N 4 the course descriptions. Note the self-loop from N 1 to itself; it denotes that some nodes represented by N 1 advise some nodes represented by N 1 . This summary has only 4 nodes and 5 edges; it is smaller (at most half as many edges) and much easier to grasp than the 1fb, 1fw and ∼ ioa ones, shown in Section 2. At the same time, it conveys the essential information that some nodes advise, write, also they teach and take something that has course descriptions.</p><p>Generally speaking, node N i in the weak summary G /W of a graph G represents all the G nodes whose outgoing (respectively, incoming) properties are a subset of the outgoing (resp., incoming) properties of N i .</p><p>The weak summary has the following important property:</p><formula xml:id="formula_3">Proposition 1. (Unique data properties) Each G data property appears exactly once in G /W .</formula><p>We exploit this to efficiently build weak graph summaries (Section 7).</p><p>We remark that the weak summary G /W of a graph G has minimal size (in the number of edges) among all the quotient summaries of G: every property labeling a G edge appears exactly once in G /W , while, by definition, it appears at least once in any quotient summary (Section 2.2). Our experiments show that |G /W | is typically 3 to 6 orders of magnitude smaller than |G|. The strong summary of the graph of Figure <ref type="figure" target="#fig_1">2</ref> is shown in Figure <ref type="figure" target="#fig_10">7</ref>. Similarly to the weak summary (Figure <ref type="figure" target="#fig_8">6</ref>), the strong one groups all courses together, and all articles together. However, it separates the person node in two: those represented by N 1 advise those represented by N 2 . This is because the target clique of p 1 , p 3 and p 4 is empty, while the target clique of p 2 and p 5 is {advises} (Table <ref type="table">2</ref>). Due to this finer granularity, in G /S , several edges may have the same label, e.g., there are two teaches and two wrote edges in Figure <ref type="figure" target="#fig_10">7</ref>, whereas in G /W , as stated in Proposition 1, this is not possible. Our experiments (Section 8) show that while G /S is often somehow larger than G /W , it still remains many orders of magnitude smaller than the original graph.</p><p>By definition of ≡ S , equivalent nodes have the same source clique and the same target clique. This leads directly to the next result, exploited by our algorithms for building strong summaries (Section 7): From the strong to the weak summary. Because strong equivalence implies weak equivalence, it follows that (G /S ) /W = G /W . For instance, the nodes N 1 and N 2 in Figure <ref type="figure" target="#fig_10">7</ref> have the same source clique, thus the weak summary of the graph in Figure <ref type="figure" target="#fig_10">7</ref> is exactly the one in Figure <ref type="figure" target="#fig_8">6</ref>. Hence, one can get both G /W and G /S by building G /S and then weakly summarizing it to also get G /W . This is (much) faster than re-summarizing G, mainly because G /S is much smaller than G. Another consequence is that G /W , intuitively, compresses more (is more imprecise) than G /S 4 ; we demonstrate this also through experiments (Table <ref type="table" target="#tab_10">6</ref> in Section 8). Property node representation. Since property nodes represent a form of metadata about the data graph, we decide that in all our quotient summaries they are always represented by themselves, i.e., a node labeled with the same URI. SameAs and generic properties. Some special properties frequently used in RDF deserve a special 4 One example among many: the W summary of a BSBM treatment. First, the standard owl:sameAs property is used to denote that two URIs should be considered as being "the same"; in particular, the incoming/outgoing edges of one should also be considered as belonging to the other. To reflect this special semantics, we extend our notion of clique to treat the properties incoming/outgoing two nodes connected by sameAs (directly or indirectly) as if they occurred on the same node. This ensures that any two nodes connected by sameAs have the same source and target clique, thus they are weakly and strongly equivalent. Second, some generic properties such as rdfs:label are sometimes used to annotate RDF nodes with very different meaning. Building cliques based on the co-occurrence of such generic properties may consider too many nodes equivalent. To avoid this, we build our cliques ignoring the triples whose properties are generic, construct G /W or G /S accordingly, then, for each triple of the form n 1 rdfs:label t (where t is some text), we add an edge N 1 rdfs:label N 2 to the weak or strong summary, where N 1 is the representative of n 1 , and N 2 is a new summary node, representing t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Typed data graph summarization</head><p>We now discuss the summarization of graphs with data and type triples. Types represent domain knowledge that the data producers found meaningful to describe it. However, some or all nodes of a graph may lack types.</p><p>Only a few RDF graph summarization works explicitly considered type triples. The equivalence relation ∼ t introduced in <ref type="bibr" target="#b4">[5]</ref> follows an approach we call type-only: nodes are equivalent if they have exactly the same types. This approach groups together all untyped nodes, which is problematic in graphs such as the one summarized in Figure <ref type="figure" target="#fig_0">1</ref>. The same approach is taken in <ref type="bibr" target="#b26">[27]</ref> which further assumes that all non-leaf nodes are typed, a supposition not borne out in practice (see again Figure <ref type="figure" target="#fig_0">1</ref>). A different approach we term data-and-type is taken in <ref type="bibr" target="#b4">[5]</ref>: for two nodes to be equivalent, they should both be equivalent according to a relation that only reflects their data properties, and have the same types. For instance, ∼ ioat is based both on having the same input and output properties (∼ ioa ), and the same types. As explained in Section 2, this splits graph nodes into many equivalence classes (summary nodes), which is not desirable for first-sight visualization.</p><p>A better approach introduced in <ref type="bibr" target="#b4">[5]</ref> to reflect types in a quotient summary built from an equivalence relation ≡ is as follows: first, summarize G ignoring type triples, and second, for each triple n type C in G, add to G /≡ a triple N type C, where N represents n in G /≡ . We call this quotient summarization approach data-then-type. It does not suffer from the disadvantages of type-only nor data-andtype. Instead, it allows to identify meaningful node groups even in graphs where some or all the nodes lack types.</p><p>Below, we start by formalizing the special treatment we argue should be given to class and property nodes in any RDF quotient summary. Based on this, we extend the data-then-type approach to our clique-based equivalence relations (Section 4.1), then present another novel approach which we call type-then-data. It gives priority to types when available, while still avoiding the pitfalls of type-only and data-and-type summarization (Section 4.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Class node equivalence and representation.</head><p>To ensure quotient summaries preserve the application knowledge encoded within the classes, properties and ontology of a graph, we decide that in any equivalence relation ≡, any class node is only equivalent to itself, and any class node is represented by itself, and similarly for property nodes. Hence, a typed data graph has the same class nodes, and the same property nodes (Section 3), as its summary.</p><p>4.1. Data-then-type summarization. We extend the W, respectively S summaries to type triples, by stating that they follow the data-then-type approach.</p><p>Figure <ref type="figure" target="#fig_14">8</ref> illustrates this for G /W ; note that N 1 is attached both Professor and GradStudent types. Generally, a typed node N i in a typed weak summary represents all the G nodes whose incoming/outgoing properties are included in those of N i , some of which may also have some of the types of N i ; the G nodes represented by an untyped node N j are the same as in a weak summary.</p><p>Figure <ref type="figure" target="#fig_15">9</ref> shows the strong summary of our sample graph when type triples are considered. Note that the Professor type is attached to N 1 , the representative of p 1 , p 3 and p 4 (those who advise someone), while GradStudent is attached to N 5 , representing the advisees (p 2 and p 5 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2.</head><p>Type-then-data summarization. This approach is novel. In contrast with data-then-types, it considers that node types are more important when deciding whether nodes are equivalent, however, it still relies on data properties to summarize untyped nodes. Thus, from an equivalence relation ≡ (based on data properties alone), we derive a novel typed  • both are typed, and they have the same set of types; • or, both are untyped, and they are equivalent according to ≡. For weak summarization, this approach leads to: Definition 6. (Typed weak summary) Let ≡ TW (typed weak equivalence) be an equivalence relation that holds between two data nodes n 1 , n 2 iff (i) n 1 , n 2 have no types in G and n 1 ≡ W n 2 ; or (ii) n 1 , n 2 have the same non-empty set of types in G. The typed weak summary G /TW of a graph G is denoted G /TW .</p><p>Figure <ref type="figure" target="#fig_16">10</ref> shows the typed weak summary of our sample RDF graph. Unlike G /W (Figure <ref type="figure" target="#fig_8">6</ref>), G /TW represents p 1 by N 1 , separately from p 3 , because p 3 is of type Person, while p 3 is untyped.</p><p>In a similar manner, we define typed strong equivalence, denoted ≡ TS , as in Definition 6 by replacing ≡ W with ≡ S , and denoting by G /TS the typed strong summary of a graph G. In our example, G /TS coincides with G /TW .</p><p>From the typed strong to typed weak summary. It is easy to see that if n 1 ≡ TS n 2 , then also n 1 ≡ TW n 2 , therefore (G /TS ) /TW = G /TW . This also allows building G /TS and G /TW for almost the cost of building G /TS alone, as this summary is small and thus summarized quickly. Summary equality. We now consider when two of our summaries may coincide for a given graph G, i.e., they are the same up to their data node labels N 1 , N 2 etc. To formalize this, we define:</p><formula xml:id="formula_4">Definition 7. (Strong isomorphism ) A strong isomorphism between two RDF graphs G 1 , G 2 , noted G 1 G 2 ,</formula><p>is an isomorphism which is the identity for the class and property nodes.</p><p>We remark that for visualization purposes, strongly isomorphic summaries can be seen as identical, as they describe exactly the same structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Summarization of graphs with RDFS ontologies</head><p>We now turn to the general case of an RDF graph with an RDFS ontology.</p><p>First, observe that any summary of an RDF graph has the same RDFS ontology as this graph. This is because: (i) every property node is only represented by itself (Section 3.2), (ii) every class node is represented by itself (Section 3.3), and (iii) by definition of an RDF quotient, any ontology triple, which only connects two class or property nodes, is "copied" in the summary. We view ontology preservation as a desirable feature, since the ontology has crucial information about the meaning of the data 5 .</p><p>Second, we identify two ways in which an ontology can impact summarization:</p><p>Through type generalization:: Typethen-data summarization (Section 4.2) groups nodes by their sets of types. If the ontology features triples of the form c 1 sc c 2 , it can be argued that c 2 can be used instead of c 1 to summarize a resource having the type c 1 . We study this in Section 5.1. Through implicit triples:: As we explained in Section 2, the semantics of an RDF graph G includes its explicit triples, but also its implicit triples which are not in G, but hold in G ∞ due to ontological constraints (such as the triples p 2 type Instructor, p 2 type Student, and p 1 knows p 2 in Section 2.1). An interesting question, then, is to determine the interplay between saturation and summarization: how is the summary of G ∞ related to that of G, first, in general (for any quotient summary), and then, for the four summaries we introduced? The rest of the section is devoted to this topic. 5.1. Type-then-data summarization using most general types. The most commonly used feature of RDFS ontologies is the subClass relationship, stating that any resource of a type c 1 is also of the type c 2 ; "subtype" and "supertype" are commonly used to denote c 1 and c 2 in such settings. The subgraph consisting of the subClass triples of a graph is typically acyclic (if a loop existed, all the types involved in the loop would be equivalent for 5 While we consider the ontology very important, our goal is to bring the much more numerous data and type (nonontology) triples to a visually comprehensible size through summarization. When present, the ontology may help visualize the data; the ontology itself may be summarized etc.</p><p>all practical purposes and could be replaced with any among them); we assume below that this is the case, thus the types present in G can be organized in a directed acyclic graph (DAG). While class nodes are very often much fewer than data nodes, they can still be too numerous for a small visualization to include or reflect all of them. For instance, there are more than 500 product types labeled Product-Type1, ProductType2 etc. in a BSBM benchmark graph of 100M triples, a WatDiv benchmark graph of 10M triple comprises 14 product category types, or the real-life DBLP dataset includes a dozen types of scientific publications. Applying type-then-data summarization to such a graph would lead to a high number of nodes, one for each type; this appears shortsighted, given that in these examples, a natural common supertype can be found, e.g., Product-Type, ProductCategory, and Publication, respectively.</p><p>To obtain compact type-then-data summaries even in the presence of such ontologies, we adopt the following practical solution:</p><p>• For each typed data node x ∈ G, let τ (x) be the set of all types associated to x in G, and τ (x) the set comprising the most general supertypes of the types in τ (x) <ref type="foot" target="#foot_1">6</ref> , which can be easily computed based on the subClass triples. • Then, type-then-data summarization based on most general types uses τ (x) instead of τ (x). This is how we obtained the graph in Figure <ref type="figure" target="#fig_0">1</ref>: there, N1 represents all the nodes whose most general type set comprises exactly http://db.uwaterloo. ca/ ~galuc/wsdbm/Genre, and similarly for N8 and the type http://db.uwaterloo. ca/ ~galuc/wsdbm/ProductCategory.</p><p>This technique can be applied to both typed weak and typed strong summarization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Interactions between summarization and saturation.</head><p>First, does saturation commute with summarization? In other words, is (G ∞ ) /≡ strongly isomorphic (Definition 7) to (G /≡ ) ∞ ? Figure <ref type="figure" target="#fig_24">11</ref> shows that this is not always the case; sp denotes the standard property RDFS rdfs:subPropertyOf (Section 2.1). For a given graph G, the figure shows its weak summary G /W and its saturation (G /W ) ∞ , as well as G ∞ and its summary (G ∞ ) /W . Here, saturation leads to b edges outgoing both r 1 and r 2 which makes them equivalent in G ∞ . In contrast, summarization before saturation represents them separately; saturating the summary cannot unify them rdfs:Resource in RDF Schema or OWL:Thing, from the supertype hierarchy, as these would not bring useful information to summary users.  as in (G ∞ ) /W (recall from Section 2.1 that saturation can only add edges in a graph). While (G ∞ ) /≡ and (G /≡ ) ∞ are not strongly isomorphic in general, we establish that they always relate as follows (see the diagram in Figure <ref type="figure" target="#fig_18">12</ref>): Theorem 1. (Summarization homomorphism) Let G be an RDF graph, G /≡ its summary and f the corresponding representation function from G nodes to G /≡ nodes. Then f defines a homomorphism from</p><formula xml:id="formula_5">y 2 y 1 r 1 r 2 z x b 2 c a b 1 b 1 b 2 b sp sp G a b 1 G /W b 2 c b 1 b 2 b sp sp a b 1 b (G /W ) ∞ b 2 c b 1 b 2 b sp sp b r 1 x y 1 a b 1 b G ∞ r 2 y 2 z b 2 c b 1 b 2 b sp sp b b (G ∞ ) /W</formula><formula xml:id="formula_6">(G ∞ )/ ≡ G ∞ f 1 ((G/ ≡ ) ∞ )/ ≡ by Theorem 2 (G/ ≡ ) ∞ f 2 f homomorph. by Theorem 1 G G/ ≡ f repr. fn. of summarizing G ∞ ∞</formula><formula xml:id="formula_7">G ∞ to (G /≡ ) ∞ . Since (G /≡ ) ∞ is homomorphic to G ∞ ,</formula><p>would their summaries coincide, i.e., be strongly isomorphic? It turns out that this may hold or not depending on the RDF equivalence relation under consideration. When it holds, we call shortcut the following three-step transformation aiming at obtaining a summary strongly isomorphic to (G ∞ ) /≡ , instead of (G ∞ ) /≡ itself: first summarize G; then saturate its summary; finally, summarize it again in order to build ((G /≡ ) ∞ ) /≡ : Definition 8. (Shortcut) We say the shortcut holds for a given RDF node equivalence relation ≡ iff for any G, (G ∞ ) /≡ and ((G /≡ ) ∞ ) /≡ are strongly isomorphic.</p><p>Note that from a practical viewpoint, hence for visualization, (G ∞ ) /≡ and ((G /≡ ) ∞ ) /≡ are equivalent as they differ just in their data node IDs (e.g., N1, N2 etc. in Figure <ref type="figure" target="#fig_0">1</ref>), which carry no particular meaning.</p><p>Next, we establish one of our main contributions: a sufficient condition under which for any quotient summary based on an equivalence relation ≡ as discussed above (where class and property nodes are preserved by summarization), the shortcut holds. In particular, as we will demonstrate (Section 8), the existence of the shortcut can lead to computing (G ∞ ) /≡ substantially faster by actually computing ((G /≡ ) ∞ ) /≡ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. (Sufficient shortcut condition)</head><p>Let G /≡ be a summary of G through ≡ and f the corresponding representation function from G nodes to G /≡ nodes (see Figure <ref type="figure" target="#fig_18">12</ref>).</p><p>If ≡ satisfies: for any RDF graph G and any pair</p><formula xml:id="formula_8">(n 1 , n 2 ) of G nodes, n 1 ≡ n 2 in G ∞ iff f (n 1 ) ≡ f (n 2 ) in (G /≡ ) ∞ ,</formula><p>then the shortcut holds for ≡.</p><p>Figure <ref type="figure" target="#fig_18">12</ref> depicts the relationships between an RDF graph G, its saturation G ∞ and summarization (G ∞ ) /≡ thereof, and the RDF graphs that appear at each step of the shortcut computation. The intuition for the sufficient condition is the following. On any path in Figure <ref type="figure" target="#fig_18">12</ref>, saturation adds edges to its input graph, while summarization "fuses" nodes into common representatives. On the regular path from G to (G ∞ ) /≡ , edges are added in the first step, and nodes are fused in the second. On the shortcut (green) path, edges are added in the second step, while nodes are fused in the first and third steps. The two paths starting from G can reach results only if G nodes fused on the shortcut path are also fused (when summarizing G ∞ ) on the standard path. In particular, the first summarization along the shortcut path should not make wrong node fusions, that is, fusions not made when considering the full G ∞ : such a "hasty" fusion can never be corrected later on along the shortcut path, as neither summarization nor saturation split nodes. Thus, an erroneous fusion made in the first summarization step irreversibly prevents the end of the shortcut path from being to (G /≡ ) ∞ .</p><p>When the condition is met, summarizing G, then saturating its summary, then summarizing the graph thus obtained leads to (G ∞ ) /≡ (up to data node labels) without the need to saturate G. The shortcut can be faster than saturating G then summarizing the result, because the shortcut avoids the cost to find, store, and summarize the implicit triples derived from G; it only deals with the implicit triples derived from G /≡ , which (depending on ≡) may be much smaller than G.</p><formula xml:id="formula_9">C 1 : {a, b 1 } C 2 : {b 2 , c} {b} C + 2 C + 1 C ∞ Figure 13</formula><p>. Two source cliques from the graph in Figure <ref type="figure" target="#fig_24">11</ref>, their saturations, and their enclosing clique C ∞ in G ∞ . 5.3. Shortcut results. In order to establish shortcut results for our summaries, we start by investigating how property cliques are impacted by saturation.</p><p>In G ∞ , every G node has all the data properties it had in G, therefore two data properties belonging to a G clique are also in the same clique of G ∞ . Further, if the schema of G comprises subProperty constraints, a node may have in G ∞ a data property that it did not have in G. As a consequence, each G ∞ clique includes one or several cliques from G, which may "fuse" by acquiring more properties due to saturation with subProperty constraints. An example is given in Figure <ref type="figure" target="#fig_24">13</ref>, where C + 1 and C + 2 are the saturations of the source cliques C 1 , C 2 , while <ref type="figure" target="#fig_24">11</ref>).</p><formula xml:id="formula_10">C ∞ = {a, b 1 , b, b 2 , c} is a source clique of the graph G ∞ (also in Figure</formula><p>Based on Theorem 2 and the above observations, we show: Theorem 3. (W shortcut) The shortcut holds for ≡ W .</p><p>For instance, on the graph in Figure <ref type="figure" target="#fig_24">11</ref>, it is easy to check that applying summarization on (G /W ) ∞ (as prescribed by the shortcut) leads exactly to a graph strongly isomorphic to (G ∞ ) /W . Showing Theorem 3 is rather involved; we do it in several steps. First, based on a technical Lemma (see Appendix E) , we show: We prove this based on counterparts of statements established for G /W . First we show: We prove this by exhibiting in Figure <ref type="figure" target="#fig_20">14</ref> a counter-example. In G and G /TW , all data nodes are untyped; only after saturation a node gains the type C. Thus, in G /TW , one (untyped) node represents all data property subjects; this is exactly a "hasty fusion" as discussed below Theorem 2. In (G /TW ) ∞ , this node gains a type, and in ((G /TW ) ∞ ) /TW , it is represented by a single node. In contrast, in G ∞ , r 1 is typed and r 2 isn't, leading to two distinct nodes in (G ∞ ) /TW . This is not strongly isomorphic with (G /TW ) ∞ which, in this example, is strongly isomorphic to ((G /TW ) ∞ ) /TW . Thus, the shortcut does not hold for ≡ TW . Theorem 6. (No shortcut for ≡ TS ) The shortcut does not hold for ≡ TS .</p><formula xml:id="formula_11">y 2 y 1 x r 1 a b r 2 b a C domain G N 1 N 2 N 3 a b G /TW a C domain N 1 N 2 N 3 a b C type (G /TW ) ∞ , ((G /TW ) ∞ ) /TW a domain r 1 x y 1 a b C type G ∞</formula><p>The graph in Figure <ref type="figure" target="#fig_20">14</ref> is also a shortcut counterexample for TS.</p><p>Based on Theorem 2, we have also established:</p><p>Theorem 7. (Bisimilarity shortcut) The shortcut holds for the forward (≡ fw ), backward (≡ bw ), and forward-and-backward (≡ fb ) bisimilarity equivalence relations (recalled in Section 2.2).  <ref type="figure" target="#fig_24">15</ref> summarizes the main relationships between G, G ∞ , our summaries and bisimilarity-based ones.</p><formula xml:id="formula_12">G /fb G /S G /W (G /fb ) ∞ (G /S ) ∞ (G /W ) ∞ ∞ ∞ ∞ /W /S G /fb /S /W (G ∞ ) /W (G ∞ ) /S (G ∞ ) /fb G ∞ ∞ /fb /S</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">From summaries to visualizations</head><p>We now describe how to go from a quotient summary to a graphical visualization such as the one illustrated in the Introduction.</p><p>6.1. Leaf and type inlining. For structurally simple graphs like our sample G shown in Figure <ref type="figure" target="#fig_1">2</ref>, quotient summaries have very few nodes and edges, and any node-link visualization method can be used. We explain here how we obtained our visualizations, illustrated in our online gallery 1 .</p><p>To further simplify summaries, we apply leaf and type inlining, as follows. We remove type edges; instead, each type attached to a node in the summary is shown in the box corresponding to the node, after the node ID. Similarly, for each edge n a -→ m where m is a leaf, we include a as an "attribute" of n, and do not render m (we say it has been "inlined" within n). A sizable part of an RDF graph's nodes are leaves; as we will show, inlining them into their parent nodes greatly simplifies the visualization.</p><p>Figure <ref type="figure" target="#fig_21">16</ref> illustrates inlining for the S summary (Figure <ref type="figure" target="#fig_15">9</ref>) of our sample graph. This summary is extremely compact, yet rich with information; professors, students, and courses are visible at a glance. Articles have been inlined within their authors as they were leaves in G /S . This simplification can also be seen as a small loss of information: Figure <ref type="figure" target="#fig_21">16</ref> does not immediately suggest that Professors may have written articles together with GradStudents. However, (i) only leaf nodes are folded and (ii) after a first glance, users may pursue exploration by other means (e.g., queries to check for such joint articles). Thus, we consider that inlining is overall beneficial, and systematically apply it on summaries before visualization.</p><p>If type-then-data summarization is used based on the most general types (Section 5.1), the most general types are shown at the top of each typed summary node (immediately under the node ID), then the actual types of the graph nodes represented by the summary node are shown one per line, under the most general types. N1, N7 and N8 in Figure <ref type="figure" target="#fig_0">1</ref> illustrate this. 6.2. Summary statistics. If users are interested (also) in a quantitative view of an RDF graph, our summaries can also plot a set of statistics. We describe them below and illustrate them based on Figure <ref type="figure" target="#fig_0">1</ref>. For each summary node N i , we display:</p><p>• The number of G nodes represented by N i , in parenthesis after "N i " in the corresponding box, e.g., "N8 (25000)"; • For each type c such that x τ c for some x represented by N i , the number of G nodes represented by N i which are of type c, e.g., http://db.uwaterloo.ca/ ~galuc/ wsdbm/ProductCategory0:807 • For each data property p such that (i) x p y for some x represented by N i and (ii) all the objects of p triples whose subjects are represented by N i are leaves in G, the number of such p triples, and the number of distinct targets of such triples. For instance, within N8, "bookedition (847 → 6)" denotes that there are 847 bookedition triples whose subjects are represented by N8, and they reach a total of 6 distinct objects (which are leaf nodes).</p><p>For each summary edge N i a -→ N j where a is a data property, the number of x a y triples in G such that x is represented by N i and y is represented by N j . The label "hasGenre (58787)" on the edge from N8 to N1 is an example of such an edge statistic.</p><p>All these statistics can be gathered by our summary construction algorithms (Section 7), at no extra computational cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.3.</head><p>Visualizing very large summaries. For a very complex (e.g., encyclopedic) dataset, even the graph obtained from inlining may have too many nodes and edges for an effective visualization. If it has several connected components (one per domain), each of them can be viewed separately. Otherwise, it can be split into several, possibly overlapping subgraphs, using any graph decomposition strategy (for instance, minimize the number of times the representatives of two nodes connected in G appear in different summary subgraphs etc.) Information discovery in such graphs requires more computational and cognitive effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Summarization algorithms</head><p>We now present summarization algorithms which, given as input a graph G, construct G /W , G /S , G /TW and G /TS . All our algorithms have an amortized linear complexity in the size of G: they can be built in just one or two passes over the data. Our incremental algorithms, capable of reflecting additions to G, into its previously computed summaries, are the most involved.</p><p>7.1. Global data graph summarization. The first algorithms we present summarize only the data triples through two graph traversals: one to learn the equivalence relation 7 and create the summary nodes, the second to determine the representative of each G node and, as a consequence, add triples to the summary. We start with our global W summarization algorithm (Algorithm 1). It exploits Proposition 1, which guarantees that any data property occurs only once in the summary. To each data property p encountered, it associates a summary node (integer) s p which will be the (unique) source of p in the summary, and similarly a node t p target of p; these are initially unknown, and evolve as G is traversed. Further, it uses two maps op and ip that associate to each data node n, the set of its outgoing, resp. incoming data properties. These are filled during the first traversal of G (step 1.) Steps 2. to 2.5 ensure that for each node n having outgoing properties and possibly incoming ones, s p for all the outgoing ones are equal, and equal also to t p for all the incoming ones. This is performed using a function fuse which, given a set of summary nodes, picks one that will replace all of them. In our implementation, summary nodes are assigned integer IDs, and fuse is simply min; we just need fuse to be distributive over ∪, i.e., fuse(A, (B ∪ C)) = fuse(fuse(A, B), fuse(A, C)). Symmetrically, step 3. ensures that the incoming properties of nodes lacking outgoing properties (thus, absent from op) also have the same target. In Step 4., we represent s and o based on the source/target of the property p connecting them. 7 Our equivalence relations are defined based on the triples of a given graph G, thus when summarization starts, we do not know whether any two nodes are equivalent; the full equivalence relation is known only after inspecting all G triples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>global-W(G)</head><p>1. For each s p o ∈ G, add p to op(s) and to ip(o).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>For each node n ∈ op:</p><formula xml:id="formula_13">2.1. Let X ← fuse{s p | p ∈ op(n)}. If X is undefined, let X ←nextNode(); 2.2. Let Y ← fuse{t p | p ∈ ip(n)}. If Y is undefined, let Y ←nextNode(); 2.3. Let Z ← fuse(X, Y ); 2.4.</formula><p>For each p ∈ ip(n), let s p ← Z; 2.5.</p><p>For each p ∈ op(n), let t p ← Z; 3. Repeat 2 to 2.5 swapping ip with op and t p with s p ; 4. For each</p><formula xml:id="formula_14">s p o ∈ G: let f W (s) ← s p , f W (o) ← t p ; Add f W (s) p f W (o) to G /W . Algorithm 1: Global W summarization of a graph</formula><p>The fuse operations in 2. and 3. have ensured that, while traversing G triples in 4., any data node n is always represented by the same summary node f W (n). Our global S summarization algorithm (Algorithm 2) uses two maps sc and tc which store for each data node n, its source clique sc(n), and its target clique tc(n), and for each data property p, its source clique src p and target clique trg p . Further, for each (source clique, target clique) pair encountered during summarization, we store the (unique) corresponding summary node. Steps 1.-1.2. build the source and property cliques present in and associate them to every subject and object node (in sc and tc), as well as to any data property (in src p and trg p ). For instance, on the sample graph in Figure <ref type="figure" target="#fig_1">2</ref>, these steps build the cliques in Table <ref type="table">2</ref>. Steps 2-2.2. represent the nodes and edges of G.</p><p>The correctness of algorithms global-W and global-S follows quite easily from their descriptions and the summary definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Incremental data graph summarization.</head><p>These algorithms are particularly suited for incremental summary maintenance: if new triples ∆ + G are added to G, it suffices to summarize only ∆ + G , based on G /≡ and its representation function f ≡ , in order to obtain (G∪∆ + G ) /≡ . Incremental algorithms are considerably more complex, since various decisions (assigning sources/targets to properties in W, source/target cliques in S, node representatives in both) must be repeatedly revisited to reflect newly acquired information about G triples, as we shall see. Each incremental summarization algorithm consists of an incremental update method, called for every data triple, which adjusts the summary's data structures, so that at any point, the summary reflects exactly the graph triples visited until then.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>global-S(G)</head><p>1. For each s p o ∈ G:  <ref type="figure" target="#fig_1">2</ref> starting with: p 1 advises p 2 , then p 1 wrote a 1 , then p 4 teaches c 2 . When we summarize this third triple, we do not know yet that p 1 is equivalent to p 4 , because no common source of teaches and advises (e.g., p 3 or p 4 ) has been seen so far. Thus, p 4 is found not equivalent to any node visited so far, and represented separately from p 1 . Now assume the fourth triple traversed is p 4 advises p 5 : at this point, we know that advises, wrote and teaches are in the same source clique, thus p 1 ≡ W p 4 , and their representatives (highlighted in yellow) must be fused in the summary (Step 3.) More generally, it can be shown that ≡ W only grows as more triples are visited, in other words: if in a subset G of G's triples, two nodes n 1 , n 2 are weakly equivalent, then this holds in any G with G ⊆ G ⊆ G. Summary node fusion dominates the algorithm's complexity. Let N 1 , N 2 be two sets of G nodes, represented at a certain point by the distinct summary nodes m 1 , m 2 . When fusing them in a single m, we must also record that all the nodes in N 1 ∪ N 2 are now represented by m. A naïve implementation leads to O(N 2 ) complexity, where N is the number of data nodes, since each new node may lead to a fusion whose cost is O(N ); in the worst case N could be proportional to |G|, the number of triples in G, leading to an overall complexity of O(|G| 2 ) for the incremental weak summarization.</p><p>Instead, we rely on a Union-Find <ref type="bibr" target="#b13">[14]</ref> (aka Disjoint Sets) data structure, with the path compression and union by size optimizations, which guarantee an overall quasi-linear worst-case complexity to our incremental weak summarization algorithm. The exact complexity is O(N α(N )) where α(N ), the inverse Ackermann's function, is smaller than 5 for any machine-representable input N . Assimilating this to linear-time, the algorithm's complexity class is in O(|G|), which is also optimal, as summarization must fully traverse G.</p><p>Algorithm 4 outlines the incremental update of the S summary due to the traversal of the triple s p o. Conceptually, the algorithm is symmetric for the source (s) and target (o) of the edge, we only discuss the source side below. Steps 1. and 2. start by determining the source clique of s, based on its previously known source clique (if any) and the previously known target clique of p (if any); after step 2., s's source (and target) clique reflecting also the newly seen triple s p o are completely known. Determining them may have involved fusing some previously separate cliques. For instance, on the graph in Figure <ref type="figure" target="#fig_1">2</ref>, assume we first traverse the triple p1 advises p 2 , then p 4 teaches c 2 ; so far we have the source cliques {advises}, {teaches} and ∅. If the next traversed triple is p 4 advises p 5 , we fuse the source cliques (step 3.1) {advises} and {teaches} into {advises, teaches}. This requires fusing the summary node whose (source, target) cliques were ({advises}, ∅) with the one which had ({teaches}, ∅) (Step 3.2).</p><p>The last intricacy of incremental strong summarization is due to the fact that unlike ≡ W , ≡ S may grow and shrink during summarization. For instance, assume incremental strong summarization of the graph in Figure <ref type="figure" target="#fig_1">2</ref>  to the summary with counter equal to 1. Procedure 5: Splitting summary node s on source is {wrote, takes} and their target clique is ∅. Assume the next triple traversed is p 3 advises p 2 : at this point, p 1 is not ≡ S to p 2 any more, because p 2 's target clique is now {advises} instead of the empty ∅. Thus, p 2 splits from p 1 , that is, it needs to be represented by a new summary node (shown in yellow below), distinct from the representative of p 1 . Further, note that the representative of p 1 and p 2 (at left above) had one takes edge (highlighted in red) which was solely due to p 2 's outgoing takes edge. By definition of a quotient summary (Section 2.2), that edge moves from the old to the new representative of p 2 (the yellow node). If, above at left, p 1 had also had an outgoing edge labeled takes, at right, both nodes in the top row would have had an outgoing takes edge. It can be shown that splits only occur in such cases, i.e., o whose target clique becomes non-empty (respectively, s whose source clique becomes non-empty, and the node was previously represented together with other nodes; if it was represented alone, we just update the respective clique of its representative).</p><p>The procedure split-source(s) (Procedure 5) represents s separately, to reflect it no longer has an empty target clique, and, for each outgoing edge of s: adds a corresponding edge to the new representative of s; and checks if, as a consequence, an edge needs to be removed from its previous representative. We establish: Proposition 5. (Algorithm correctness) Applying algorithm increm-W (resp., increm-S) successively on each triple of G, in any order, builds G /W (resp., G /S ).</p><p>Splitting requires inspecting the data edges attached to the node, in order to add edges to its new representative (such as p 2 ta c 2 above). We make the hypothesis, denoted ( ), that the average number of edges incoming/outgoing a data node is small (and basically constant) compared to the size of G; this was the case in the graphs we have experimented with. Under the ( ) hypothesis, using the above data structures (including Union-Find), the complexity of incremental strong summarization is amortized constant per added triple.</p><p>All our algorithms require O(|G|) space to store the summary, the representation function, and their other data structures. Encoding all graph and summary nodes as integers, however, reduces the actual memory needs significantly. 7.3. Incremental summarization of typed graphs. We now explain how to extend our incremental data triple summarization algorithms to type triples.</p><p>To extend W, respectively, S summarization to type triples in "data-then-type" fashion (Section 4.1), we run W, resp. S summarization first, over the data triples only, as described in the preceding two sections. This assigns their (final) representatives to all data nodes. Then, for each s type C triple, we simply add to the summary the edge f W (s) type C (resp. f S (s) type C); recall from Section 4 that any class node C is represented by itself.</p><p>For "type-then-data" summarization (Section 4.2), we first traverse the type triples only, compute all the class sets, and assign to each typed data node a representative based on its class set. Then, we run a type-aware variant of a W (resp. S) algorithm, either global or incremental. The differences are: (i) In TW summarization, a data property p may lack an untyped source (and/or target), if p has only typed subjects (resp. objects), e.g., property e in the two-triples graph n 1 type C, n 1 e a 1 . Similarly, in TS summarization, a property like e will lack a source clique, if it does not have an untyped source. Whenever a clique-based representative for a property's source and target is missing, the algorithms will instead use the type-based representative, e.g., the representative of n 1 in n 1 e a 1 will be the one for the type set {C}. (ii) Summarizing the data triple s p o does not fuse nor split the representative of s (resp. o) if s (resp. o) is typed; the representatives of typed nodes never change. We establish: Proposition 6. (Algorithm correctness) Applying global-W (respectively global-S) on G, or applying increm-W (resp., increm-S) on each triple of G, extended as described above for data-then-type or type-then-data summarization leads, resp., to G /W , G /S , G /TW and G /TS . These algorithms need to work with the data and type triples separately. Fortunately, most popular RDF stores allow such direct access. The space needed to also represent type triples remains linear in |G|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Experimental study</head><p>Algorithms compared. We have implemented in a Java 1.8 tool available online 1 :</p><p>• Our global and incremental algorithms for building G /W , G /S , G /TW , G /TS (a total of eight); • An algorithm which computes the fb (full bisimilarity) summary of an RDF graph, used in many prior works, e.g., <ref type="bibr" target="#b21">[22]</ref>. The summary called ∼ b in <ref type="bibr" target="#b4">[5]</ref> is obtained from fb by collapsing all leaves together; as explained in Section 2, this leaf collapse introduces a loss of information, thus we do not adopt it. • Algorithms to build the k-bounded bisimilarity summaries for k = 1, denoted 1fw, 1bw and 1fb <ref type="bibr" target="#b22">[23]</ref> (1fw also corresponds to the characteristic sets of <ref type="bibr" target="#b31">[32]</ref>). We do not use higher k values because, as we will show, even at this smallest k, bisimilarity summaries are too large for visualization; higher k would only increase the number of nodes and edges. The ∼ ioa summary of <ref type="bibr" target="#b4">[5]</ref> is obtained from 1fb by collapsing all leaves. Table <ref type="table">3</ref>. Datasets used in experiments.</p><p>• The best algorithms from <ref type="bibr" target="#b4">[5]</ref> building the ∼ t and ∼ ioat summaries, but without their leaf collapse.</p><p>Settings. All experiments ran on a Linux server with an Intel Xeon CPU E5-2640 v4 @2.40GHz and 124 GB RAM. We used PostgreSQL v9.6 to store RDF triples in an integer-encoded triple table, indexed by s, p and o; the server had 30 GB of shared buffers and 640 MB working memory. The JVM had 90 GB of RAM. Datasets. We have experimented with real and synthetic graphs of up to 36.5 GB. Table <ref type="table">3</ref> shows for each graph its number of triples |G|, the number of triples in its saturation |G ∞ |, the percentage of untyped nodes in the graph u%, and the number of distinct data properties #p and classes #C. Each graph has at least 30% untyped nodes; these form a strong majority in all but the LUBM graphs. Note that in BSBM graphs, the number of classes grows with the data size. Summary size. Table <ref type="table" target="#tab_8">4</ref> reports the node and edge counts, denoted (n|e), for the compared summaries, both directly, and after applying inlining (Section 6, denoted with the in superscript). We report only the data edges in the summaries, and omit (i) schema triples, or (ii) metadata triples, e.g., C dc:publisher a 1 states that a 1 published class C etc. These omitted triples are the same for all summaries <ref type="foot" target="#foot_2">8</ref> . For space reasons, we delegate the 1bw and 1fb numbers to <ref type="bibr" target="#b5">[6]</ref>; they are slightly worse (i.e., more nodes and edges) than those of 1fw. We also delegate to <ref type="bibr" target="#b5">[6]</ref> the TW results, which are often identical to those for TS. Numbers are missing (-|-) when algorithms ran out of memory or longer than 3 hours. fb summarization failed to complete within 3 hours, on all but the smallest graphs (Springer, Nobel Prizes and BSBM 1M). This is partially due to our simple, single-computer implementation, but computing fb is also intrinsically hard, as it requires many iterations. More efficient methods to build the fb summary are parallel <ref type="bibr" target="#b25">[26]</ref>; existing algorithms to build the ∼ t and ∼ ioat summaries are based on MapReduce <ref type="bibr" target="#b4">[5]</ref>. Here, we study the size, precision, as well as qualitative properties (see Section 2.2) of prior-work summaries, based on simple (if not the most efficient) centralized implementations. The fb results we obtained confirm the observation in Section 2.2 that such summaries are much too complex to be used for a first visualization.</p><p>Among the other summaries, before inlining, as theoretically expected (Proposition 1), G /W always has the fewest edges; G /S is close. In contrast, summaries that group nodes (also) by the types, such as G /TS , G /t and G /ioat are much larger. This is particularly visible for larger BSBM datasets: as the schema complexity grows, these summaries have tens of thousands of edges. G /ioat remains too complex even for the simpler-schema graphs (excluding BSBM), with hundreds or thousands of edges, whereas G /W and G /S only have a few dozen edges. G /1fw is always smaller than G /ioat (this can be shown theoretically based on their definitions), but it remains much larger (by a factor of 2 in the case of Springer, up to 122 in the case of Foodista) than G /S . Among the graphs other than BSBM, G /t has less edges than G /S on the DBpedia Person graph, and less nodes on the Springer graph; on all the others, G /t is several times larger than G /S . Further, G /t has the qualitative drawback of considering all untyped nodes equivalent; none of our summaries has this problem.</p><p>After inlining, G in /W and G in /S are reduced to very few (1 to 21) nodes and 2 to 36 edges. In contrast, G in /t has significantly more edges than G in /S (up to 11× for BSBM10 or DBLP); it is smaller than G in /S (by a small margin) only on DBPedia Person and Nobel. The summaries G in /1fw , G in /ioat still remain very large, thus, not useful for first-sight visualization. Summarization time. The times to build our summaries using the global and the incremental algorithms are plotted as a function of |G| in Figure <ref type="figure" target="#fig_24">17</ref>; both axes are in log scale. For each summary type, the summarization time is roughly linear in the size of G, confirming the expectations stated in Section 7. Increm-W is the fastest overall; it traverses G only once, thus it is faster than global-W which performs several passes. S, TW and TS, in this order, are more expensive, and finally incremental S which, as we explained, is quite complex. Since increm-S is rather expensive per-triple, it is more efficient to first summarize a graph using global-S, and call increm-S only to maintain Summary precision. We now attempt to quantify the loss of precision of our structural summaries. A simple measure is the fraction of summary subgraphs having no isomorphic counterpart in the data; intuitively, summary users may believe G exhibits such structures, while this is not true. For instance, node N1 in Figure <ref type="figure" target="#fig_8">6</ref> has, among others, two outgoing edges labeled a and ta, whereas such a node does not exist in the original graph (Figure <ref type="figure" target="#fig_1">2</ref>). We define the precision loss at l, or P L l as the fraction of connected l-edges subgraphs of the summary G /≡ without a counterpart in G. Table <ref type="table" target="#tab_10">6</ref> shows P L 2 scores for our datasets. By definition, fb, 1fb and ioat have P L 2 = 0 for any graph, since they reflect completely node neighborhoods at distance 1. In contrast, G /W has the highest precision loss; G /TS is the most precise, much better than ∼ t which blindly collapses untyped nodes. 1fw is quite imprecise in some cases, since it ignores incoming edges.</p><formula xml:id="formula_15">G G /W G in /W G /S G in /S G /TS G in /TS G /1fw G in /1fw G /∼t G in /∼t G /∼ioat G in /∼ioat G /fb G in /fb BSBM1 179|38 1|7 184|57 5|9 281|1951 7|10 208|1017 48|573 264|2046 102|485 312|4477 61|617 279999|999436 -|- BSBM10 613|38 1|7 618|68 5|11 1131|10274 7|10 642|1023 48|579 1114|10785 518|749 719|10320 86|740 -|- -|- BSBM100 2039|38 1|7 2044|70 5|11 3325|25639 7|10 2068|1023 48|579 3308|26918 -|-2149|34503 105|895 -|- -|- BSBM138 2441|38 1|7 2446|71 5|11 3983|30759 -|-2470|1023 -|-3966|32294 -|-2556|41963 110|892 -|- -|- DBLP 23|26 2|8 30|66 7|17 38|196 14|66 267|4344 62|938 55|237 13|188 439|8390 -|- -|- -|- DB. Person 4|9 1|2 6|21 2|4 5|11 1|2 67|377 65|83 3|11 1|2 135|1651 112|91 -|- -|- Foodista 11|13 3|6 12|16 3|6 17|33 6|13 72|1959 25|975 12|36 6|33 191|4518 169|934 -|- -|- LUBM1 82|18 3|12 86|43 7|27 95|94 16|58 89|81 14|75 92|94 16|58 103|173 24|111 -|- -|- LUBM10 82|18 3|12 86|44 7|28 95|94 16|58 89|83 14|77 92|94 16|58 101|163 22|100 -|- -|- LUBM100 82|18 3|12 86|44 7|27 95|94 16|58 89|83 14|77 92|94 16|58 101|167 22|104 -|- -|- Nobel 97|59 9|18 110|110 21|36 105|85 16|33 117|555 48|434 83|82 14|65 164|697 70|316 22640|83206 10765|32671 Springer 49|24 4|2 49|24 4|2 49|24 4|2 40|51 8|9 37|24 4|2 73|90 8|9 65297|139566 15530|30028</formula><p>Experiment conclusion. Our four summaries can be built efficiently in linear time. They strongly reduce graph sizes and, through inlining, they lead to compact, understandable graphs which fit human comprehension capacity at first sight. If all non-leaf G nodes are typed, G /TS (or, equivalently, G /TW ), with type generalization, are the most informative and most precise, given that type information specified by humans carries precious information about the graphs. Otherwise, G /S strikes the best balance between concision and informative content, while G /W loses more precision. The shortcut speeds up W and S summarization of G ∞ by 39% to 94%. Thus, we find the strong summary the safest and most interesting choice: it can be built efficiently and is most likely to lead to informative yet understandable RDF graph summaries. More generally, the data publisher can build them all (first build G /S and G /TS , then G /W from G /S and G /TW from G /TS ) and select the one(s) to share with potential data users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Related Work and Conclusion</head><p>As discussed in the Introduction and in Section 2.2, summarization is a well-studied notion for general graphs <ref type="bibr" target="#b28">[29]</ref> and RDF ones in particular <ref type="bibr" target="#b6">[7]</ref>. Our work pertains to the family of quotient summaries of RDF graphs, and most directly compares to bisimilarity-based quotients as well as the more RDF-specific ones. In this comparison, our summaries, and among them the strong summary which we find generally the best, has the advantages of being (i) compact and easy to understand for domainspecific graphs, (ii) efficiently computed in lineartime, and (iii) benefiting from the original shortcut procedure we introduced. None of our summaries has the drawback of collapsing all leaves, all roots, or all untyped nodes. In contrast, more complex summaries such as 1fb and ∼ ioat are better suited for indexing, but not as a first interface to show users.</p><p>Many non-quotient RDF graph summaries exist, see, e.g., <ref type="bibr" target="#b6">[7]</ref>. <ref type="bibr" target="#b12">[13]</ref> builds answer-preserving summaries for reachability and graph pattern queries. However, these summaries do not preserve query structure (i.e., joins), which quotient summaries do preserve.</p><p>Other graph summaries compress graphs with bounded "error" (number of edges to be added as "corrections" after decompression, to retrieve the original graph) <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b23">24]</ref>. Nodes and edges are summarized according to their frequencies and/or based on ontology patterns in <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b32">33]</ref>. Summaries where nodes are grouped by graph clustering <ref type="bibr" target="#b19">[20]</ref>, user-defined aggregation rules <ref type="bibr" target="#b33">[34]</ref>, mining <ref type="bibr" target="#b8">[9]</ref>, and identification of frequent subtrees <ref type="bibr" target="#b38">[39]</ref> do not reflect the complete structure, and/or require user input. With different objectives, these summaries may omit part of the graph structure, or be much too large for visualization.</p><p>Work on fitting XML data into relational stores <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b3">4]</ref> also aimed at finding "homogeneous" node groups; "inlining" there meant storing in the relation of node n, its properties which occur at most once. Our inlining (Section 6) pushes leaf nodes within their parents, regardless of their number of occurrences.</p><p>Quality metrics for RDF graph summaries have been proposed in <ref type="bibr" target="#b39">[40]</ref>. Along these metrics, our summaries score high for preserving all classes and properties from G; the price they pay for compactness is to sometimes show instances that do not exist in G (as our precision loss experiments show).</p><p>We currently work on using summaries to automatically identify interesting analytical queries in large RDF graphs and to speed up RDF keyword search. is in G. Further, by the definition of our quotientbased summaries, n is in</p><formula xml:id="formula_16">G iff f ≡ (n) is in G /≡ . Fi- nally, again by the definition of saturation, f ≡ (n) is in G /≡ iff f ≡ (n) is in (G /≡ ) ∞ . Therefore, every G ∞ node n maps the f ≡ (n) (G /≡ ) ∞ node (*).</formula><p>Next, we show that there is a one-to-one mapping between G ∞ edges and those of (G /≡ ) ∞ .</p><p>If n 1 p n 2 is an edge in G ∞ , at least one of the following two situations holds: </p><formula xml:id="formula_17">• n 1 p n 2 is an edge in G. This holds iff f ≡ (n 1 ) p f ≡ (n 2 ) is an edge in G /≡ , by def- inition of an RDF summary. Finally, if f ≡ (n 1 ) p f ≡ (n 2 ) is an edge in G /≡ , then f ≡ (n 1 ) p f ≡ (n 2 ) is also an edge in (G /≡ ) ∞ . • n 1 p n 2 is</formula><formula xml:id="formula_18">≡ (n 1 ) p f ≡ (n 2 ) is an edge in (G /≡ ) ∞ , hence f ≡ (n 1 ) p f ≡ (n 2 )</formula><p>is also an edge added to (G /≡ ) ∞ by saturation, since (G /≡ ) ∞ and G ∞ have the same (saturated) schema triples (Section 5).</p><p>If n 1 type c is an edge in G ∞ , at least one of the following two situations holds:</p><p>• n 1 type c is an edge in G. This holds iff f ≡ (n 1 ) type c is an edge in G /≡ , by definition of an RDF summary (recall that f ≡ (c) = c for classes). Finally, if f ≡ (n 1 ) type c is an edge in G /≡ , then f ≡ (n 1 ) type c is also an edge in (G /≡ ) ∞ . • n 1 p n 2 is an edge in G and p domain c (or p range c) belongs to schema triples of the saturated graph, thus n 1 type c is produced by saturation in G ∞ . In this case, we show similarly as above that f ≡ (n 1 ) p f ≡ (n 2 ) is an edge in (G /≡ ) ∞ , hence f ≡ (n 1 ) type c is also an edge added to (G /≡ ) ∞ by saturation, since (G /≡ ) ∞ and G ∞ have the same (saturated) schema triples (Section 5).</p><p>Therefore, every</p><formula xml:id="formula_19">G ∞ edge n 1 p n 2 (resp. n 1 type c) maps into the (G /≡ ) ∞ edge f ≡ (n 1 ) p f ≡ (n 2 ) (resp. f ≡ (n 1 ) type c) (**).</formula><p>From (*) and (**), it follows that f is an homomorphism from G ∞ to (G /≡ ) ∞ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix D. Proof of Theorem 2</head><p>Proof. We start by introducing some notations (see Figure <ref type="figure" target="#fig_24">18</ref>). Let f 1 be the representation function from G ∞ into (G ∞ ) /≡ , and f 2 be the representation function from (G /≡ ) ∞ into ((G /≡ ) ∞ ) /≡ .</p><p>Let the function ϕ be a function from the (G ∞ ) /≡ nodes to the ((G /≡ ) ∞ ) /≡ nodes defined as:</p><formula xml:id="formula_20">ϕ(f 1 (n)) = f 2 (f (n)) for n any G ∞ node. f 1 (n 1 ) p f 1 (n 2 ) ∈ (G ∞ )/ ≡ n 1 p n 2 ∈ G ∞ f 1 f 2 (f (n 1 )) p f 2 (f (n 2 )) ∈ ((G/ ≡ ) ∞ )/ ≡ φ f (n 1 ) p f (n 2 ) ∈ (G/ ≡ ) ∞ f 2 f Figure 18. Diagram illustrating Theorem 2.</formula><p>Suppose that for every pair (n 1 , n 2 ) of G nodes,</p><formula xml:id="formula_21">n 1 ≡ n 2 in G ∞ iff f (n 1 ) ≡ f (n 2 ) in (G /≡ ) ∞ holds.</formula><p>Let us show that this condition suffices to ensure (G ∞ ) /≡ ≡ ((G /≡ ) ∞ ) /≡ holds, i.e., the ϕ function defines an isomorphism from (G ∞ ) /≡ to ((G /≡ ) ∞ ) /≡ .</p><p>First, let us show that ϕ is a bijection from all the (G ∞ ) /≡ nodes to all the ((G /≡ ) ∞ ) /≡ nodes. Since for every pair n</p><formula xml:id="formula_22">1 , n 2 of G ∞ nodes, n 1 ≡ n 2 iff f (n 1 ) ≡ f (n 2 ) in (G /≡ ) ∞ , it follows that (G ∞ ) /≡ and ((G /≡ ) ∞ ) /≡ have the same number of nodes (*). Further, a given node n in (G ∞ ) /≡ represents a set of equivalent nodes n 1 , . . . , n k from G ∞ . By hypothesis, n 1 ≡ • • • ≡ n k in G ∞ iff f (n 1 ) ≡ • • • ≡ f (n k ) in G ∞ /≡ holds. Hence, every node n = f 1 (n 1 ) = • • • = f 1 (n k ) of (G ∞ ) /≡ maps to a distinct node n = f 2 (f (n 1 )) = • • • = f 2 (f (n k )) in ((G /≡ ) ∞ ) /≡ (**).</formula><p>Similarly, a given node n in ((G /≡ ) ∞ ) /≡ represents a set of equivalent nodes n</p><formula xml:id="formula_23">1 = f (n 1 ), . . . , n k = f (n k ) in (G /≡ ) ∞ . By hypothesis, f (n 1 ) ≡ • • • ≡ f (n k ) in G ∞ /≡ iff n 1 ≡ • • • ≡ n k in G ∞ holds. Hence, every node n = f 2 (f (n 1 )) = • • • = f 2 (f (n k )) in ((G /≡ ) ∞ ) /≡ maps to a distinct node n = f 1 (n 1 ) = • • • = f 1 (n k ) of (G ∞ ) /≡ (***).</formula><p>From (*), (**) and (***), it follows that ϕ is a bijective function from all the (G ∞ ) /≡ nodes to all the ((G /≡ ) ∞ ) /≡ nodes. Now, let us show that ϕ defines an isomorphism from (G ∞ ) /≡ to ((G /≡ ) ∞ ) /≡ .</p><p>For every edge n 1 p n 2 in (G ∞ ) /≡ , by definition of an RDF summary, there exists an edge</p><formula xml:id="formula_24">n 1 p n 2 in G ∞ such that n 1 p n 2 = f 1 (n 1 ) p f 1 (n 2 ). Figure 18 illustrates the discussion. Further, if n 1 p n 2 is in G ∞ , then f (n 1 ) p f (n 2 ) is in (G /≡ ) ∞ (Theorem 1), hence f 2 (f (n 1 )) p f 2 (f (n 2 )) is in ((G /≡ ) ∞ ) /≡ . Therefore, • since for every f 1 (n 1 ) p f 1 (n 2 ) edge in (G ∞ ) /≡ , there is an edge f 2 (f (n 1 )) p f 2 (f (n 2 )) in ((G /≡ ) ∞ ) /≡ , and • since ϕ(f 1 (n)) = f 2 (f (n)), for n any G ∞ node, is a bijective function from all (G ∞ ) /≡ nodes to all ((G /≡ ) ∞ ) /≡ nodes, • it follows that ((G /≡ ) ∞ ) /≡ contains the im- age of all (G ∞ ) /≡ f 1 (n 1 ) p f 1 (n 2 ) triples through ϕ (*).</formula><p>the properties p i , for some 1 ≤ i ≤ k, that is, p ∈ C i , and accordingly, p ∈ C + i due to p sp p.</p><p>Thus, any data property p ∈ C ∞ is part of some C + i . We must still show that the saturated cliques intersect. If k = 1 the statement is trivially true. Suppose k ≥ 2 and the statement is false. Let C denote the set {C 1 , . . . , C m }; the cliques in C are pairwise disjoint by definition. Let I ⊆ C be a maximal subset of C cliques such that the saturations of I cliques all intersect (directly or indirectly). Let J = C \ I be the complement of I; if the last part of 4. is false, J is not empty. We denote I + , respectively J + , the set of the saturated cliques from I, resp. J .</p><p>No data property p i from I + can be source-related in G ∞ to any data property p j from J + . This is because sourcerelatedness requires a resource r having in G ∞ both p i and a property p source-related to p j . If such a property p existed, it would belong both to I + (since p has a common source with p i ) and to J + (since p is sourcerelated to p j ); or, I + and J + have no property in common.</p><p>The lack of source-relatedness in G ∞ between p i and p j chosen as above contradicts the hypothesis that they are part of the same source clique of G ∞ , namely C ∞ . (4) The statement follows quite directly as a consequence of the previous one, concluding our proof.</p><formula xml:id="formula_25">T C ∞ W,1 f (n 1 ) (G /W ) ∞ r 1 SC ∞ W,1 r 2 T C ∞ W,2 r 3 . . . r 2m+1 SC ∞ W,m f (n 2 ) R 1 R 2 R 3 R 2m+1 G G Figure 19</formula><p>. Sketch for the sufficient condition for the weak summary to enjoy the shortcut property.</p><p>By Theorem 1, f is also a homomorphism from G ∞ to (G /W ) ∞ , therefore any incoming (outgoing) edge into (from) a node n j of G ∞ is also incoming (resp. outgoing) into (from) the respective node f (n j ) of (G /W ) ∞ . As a consequence, we can reproduce the alternating clique structure into (G /W ) ∞ , which suffices to make f (n 1 ) and f</p><formula xml:id="formula_26">(n 2k ) weakly equivalent in (G /W ) ∞ . "If": f (n 1 ) ≡ W f (n 2 ) in (G /W</formula><p>) ∞ iff they are connected by an alternating chain of source and target cliques in (G /W ) ∞ . Assume w.l.o.g. that the chain is as shown in Figure <ref type="figure" target="#fig_24">19</ref>, that is, of the form:</p><p>•</p><formula xml:id="formula_27">f (n 1 ) shares a target clique T C ∞ W,1 with r 1 • r 1 (T C ∞ W,1 , SC ∞ W,1 ) • r 2 (T C ∞ W,2 , SC ∞ W,1 ), . . ., • r 2m+1 (T C ∞ W,m-1 , SC ∞ W,m</formula><p>), and f (n 2 ) has the source clique SC ∞</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>W,m</head><p>The alternating chain starts with a target clique and ends with a source clique (of course three other combinations are possible). In the chain, each resource is either:</p><p>• r 2i+1 (T C ∞ W,i+1 , SC ∞ W,i+1 ) or • r 2i+2 (T C ∞ W,i+2 , SC ∞ W,i+1 ) for some 0 ≤ i &lt; m. Every r 2i+1 and r 2i+2 resource is a node from (G /W ) ∞ , thus a node from G /W (because saturating G /W does not create nodes). For a given r j , let R j be the set of weakly-equivalent G resources from which r j was created; all resources in R j are by definition weakly equivalent in G, and this also holds in G ∞ .</p><p>By Proposition 3, T C ∞ W,1 is also a target clique of G ∞ , and it must be the target clique of n 1 in G ∞ (because of the f homomorphism from G ∞ into (G /W ) ∞ ensured by Theorem 1). Similarly, SC ∞ W,m must be a source clique in G ∞ and in particular the source clique of n 2 .</p><p>In G ∞ , n 1 shares its target clique T C ∞ W,1 with the nodes in R 1 , thus n 1 is weakly-equivalent to any node from R 1 .</p><p>Further, by Proposition 3, if the node r 1 has the target clique T C ∞ W,1 and the source clique SC ∞ W,1 in (G /W ) ∞ , then the G ∞ node whose target clique is T C ∞ W,1 must also have the source clique SC ∞ W,1 in G ∞ . (Proposition 3 also ensures that a node in G ∞ has SC ∞ W,1 as its source clique.) If the alternating chain is long enough to comprise r 2 (that is: if the chain does not degenerate in a single node), that corresponds to the set R 2 of G nodes which, in G ∞ , have the source clique SC ∞ W,1 , therefore they are weakly equivalent to all nodes from R 1 which have the same source clique. Thus, n 1 is weakly equivalent in G ∞ to the nodes from R 1 and R 2 .</p><p>The above reasoning can be applied on each edge in the alternating chain, extending weak equivalence from n 1 through all the R j sets until n 2 .</p><p>after applying increm-W on k data triples, the following invariants are preserved:</p><p>(1) The source and target src p and trg p of any property p present in these k triples are known. (2) For any summarized triple s p o, we have f W (s) = src p and f W (o) = trg p ; further, the summary contains the edge f W (s) p f W (o).</p><p>The preservation of these invariants is shown by considering all the cases which may occur for a given summarized triple s p o: the subject s may have already been seen (in which case this triple may lead to a fusion), or not (in which case we create the new representative of s), and similarly for o. For p there are also two cases (depending on whether we had already encountered it or not, we may create src p and trg p , or just fuse them with pre-existing representatives of s and o). There are 8 cases overall. The replacements and fusions detailed in Algorithm 3 guarantee these invariants. While, for simplicity of presentation, Algorithm increm-W considers the possible fusions due to s and o separately, in reality, given that they may impact the same node(s) (e.g., if f W (s) = f W (o)), all the replacements are first computed, then reconciled into a list of summary node substitutions, applied in all the data structures. For instance, suppose we need to replace summary node 3 with 1 because of a fusion on the subject side, and also summary node 5 with 3 because of a fusion on the object side. In this case, the algorithm will replace 5 and 3 directly with 1. If the replacements were applied sequentially, e.g., first 3 with 1, the second replacement would leave 3 (not 1) instead of 5, which would be an error.</p><p>Similarly, the correctness of incremental S summarization on data triples follows from the fact that Algorithm increm-S preserves the following invariants after having been called on k successive data triples, with 1 ≤ k ≤ |G|: (6) For any (subject, property) combination occurring in the summarized triples, the count (sp) is exactly the number of times this occurred in the triples. Similarly, for any (property, object) combination appearing in the summarized triples, the count (po) is exactly the number of times it appeared.</p><p>Like for increm-W, there are eight cases depending on whether s, p and o have been previously seen. Further, in the four cases where s has been seen, we may need to split s's representative, or not, and similarly for o; thus, the six cases original cases where at least one of them had been seen lead to 12 cases (to which we add the remaining two, where neither s nor o had been seen), for a total of 14 cases.</p><p>Items 4, 5 and 6 are ensured during: the addition of an edge to the summary (this sets e to 1 or increases it); the assignment of representatives to nodes (this sets m to 1 or increments it); the edge repartition during split (this subtracts from one edges e exactly the count that it adds to another new edge); and node replacements (which, when replacing u with v, either carry u into v , if v did not exist in the summary previously, or add u to v if it did). Together, 4, 5 and 6 ensure the correctness of the split algorithm (explained in Section 7.1).</p><p>The previous items are ensured by the creation of summary nodes (at most one exists at any time for a given source and target clique), fusing cliques (this guarantees each property is in the right clique, and remove cliques input to the fusion), and replacing / fusing summary nodes, as well as from the correctness of the split procedure.</p><p>Appendix N. Proof of Proposition 6</p><p>Proof. First, recall that TW and TS summarization start with the type triples, which means all type nodes are detected and represented according to their class sets, before the data triples are summarized. This entails that among the cases which occur for W and S summarization (8, respectively, 14, see discussion in the proof of Proposition 5), those in which the subject, respectively, the object was already represented are further divided in two, depending on whether the subject, respectively, object was a typed node.</p><p>This shows that incremental TW summarization handles a superset of the cases handled by the W one, and similarly for TS and TS. Thus, increm-TW, respectively, increm-TS preserve all the invariants of increm-W, respectively, increm-S<ref type="foot" target="#foot_3">9</ref> , with some additions, which we highlight in italics below. Additions of TW summarization w.r.t. W:</p><p>(1) The source and target src p and trg p of any property p present with an untyped source, respectively, an untyped target in the summarized triples are known. (2) For any summarized triple s p o, we have f W (s) = src p if s is untyped and f W (o) = trg p if o is untyped; further, the summary contains the edge f W (s) p f W (o). Additions of TS summarization w.r.t. S:</p><p>(1) The source and target clique sc(p) and tc(p) of any property p present in these k triples with an untyped source, respectively, with an untyped target are known, and they contain p.</p><p>(2) For any summarized triple s p o, we have f S (s) = sc(p) if s is untyped, and f S (o) = tc(p) if o is untyped; further, the summary contains the edge f S (s) p f S (o). Further, they also preserve: <ref type="bibr" target="#b6">(7)</ref> The summary contains one node for each set of classes belonging to some resource in the input. (8) For any node n with a non empty class set, f TW (n) (respectively, f TS (n)) is the node corresponding to the class set of n. These invariants are ensured by the way in which we collect all class sets during the initial traversal of type triples (common to the TW and TS algorithms). Further, during the TW and TS summarization, as said in Section 7.3, the representatives of typed nodes never fuse, and never split.</p><p>The 6 invariants from the proof of Prop. 5 ensure the correct summarization of data triples when s and o are untyped. Together with the two above, they also ensure the correct summarization of triples having a typed s and/or o.</p><p>(F. Goasdoué) Univ. Rennes, Inria, CNRS, IRISA, France Email address, F. Goasdoué: fg@irisa.fr (P. Guzewicz) Institut Polytechnique de Paris, Inria, France</p><p>Email address, P. Guzewicz: pawel.guzewicz@inria.fr (I. Manolescu) Inria and Institut Polytechnique de Paris, France</p><p>Email address, I. Manolescu: ioana.manolescu@inria.fr</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. ER-style visualization built from one of our summaries.</figDesc><graphic coords="4,302.62,399.62,221.78,83.27" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Sample RDF graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. 1fb summary of the RDF graph in Figure 2.</figDesc><graphic coords="6,323.14,70.87,177.43,62.95" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. 1fw summary of the RDF graph in Figure 2.</figDesc><graphic coords="6,344.89,181.53,133.92,57.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>and 5 ignore the type triples of G for readability and because they were not used for summarization in the referenced works.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. ∼ ioa summary [5] of the RDF graph in Figure 2.</figDesc><graphic coords="7,91.38,70.87,177.43,73.86" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Source clique and nodes having this source clique: SC 1 {advises, takes, teaches, wrote}: p 1 , p 2 , p 3 , p 4 , p 5 SC 2 {coursedescr }: c 1 , c 2 , c 3 SC 3 ∅: a 1 , a 2 Target clique and nodes having this target clique: T C 1 {advises}: p 2 , p 5 T C 2 {teaches, takes}: c 1 , c 2 , c 3 T C 3 {coursedescr }: d 1 , d 2 T C 4 {wrote}: a 1 , a 2 T C 5 ∅: p 1 , p 3 , p 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>3. 2 .</head><label>2</label><figDesc>Strong and weak node equivalences. Building on property cliques, we define two node equivalence relations among the data nodes of a graph G: Definition 2. (Strong equivalence) Two data nodes n 1 , n 2 of G are strongly equivalent, denoted</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Weak summary of the RDF graph in Figure 2 (type triples excluded).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>n 1 ≡</head><label>1</label><figDesc>S n 2 , iff they have the same source and target cliques.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Strong summary of the RDF graph in Figure 2 (type triples excluded).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>3. 3 .</head><label>3</label><figDesc>Weak and strong summarization. Weak summarization. The first summary we define is based on weak equivalence: Definition 4. (Weak summary) The weak summary of a data graph G, denoted G /W , is its quotient graph w.r.t. the weak equivalence relation ≡ W .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Strong summarization. Next, we introduce: Definition 5. (Strong summary) The strong summary of the graph G, denoted G /S , is its quotient graph w.r.t. the strong equivalence relation ≡ S .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Proposition 2 .</head><label>2</label><figDesc>(Strong summary nodes and G cliques) G /S has exactly one node for each source clique and target clique of a same G data node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Weak summary of the graph in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Strong summary of the graph in Figure 2.</figDesc><graphic coords="11,71.13,178.66,217.94,71.23" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Typed weak summary of the graph in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>2 Figure 11 .</head><label>211</label><figDesc>Figure 11. Saturation and summarization example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. Illustration for Theorem 1 and Theorem 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Lemma 1 .</head><label>1</label><figDesc>(Property relatedness in W summaries) Data properties are target-related (resp. source-related) in (G /W ) ∞ iff they are target-related (resp. source-related) in G ∞ . Based on the above Lemma and Theorem 1, we establish the next result from which Theorem 3 directly follows: Proposition 3. (Same cliques-W) G ∞ and (G /W ) ∞ have identical source clique sets, and identical target cliques sets. Further, a node n ∈ G ∞ has exactly the same source and target clique as f W (n) in (G /W ) ∞ . Theorem 4. (S shortcut) The shortcut holds for ≡ S .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Shortcut counter-example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 16 .</head><label>16</label><figDesc>Figure 16. Visualization resulting from leaf and type inlining on the sample Strong summary from Figure 9.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>( 1 )</head><label>1</label><figDesc>The source and target clique sc(p) and tc(p) of any property p present in these k triples are known, and they contain p. (2) For any summarized triple s p o, we have f S (s) = sc(p) and f S (o) = tc(p); further, the summary contains the edge f S (s) p f S (o). (3) For any source clique sc and target clique tc of a node n appearing in the summarized triple, the summary contains exactly one node. (4) For any summary node m, the count m is exactly the cardinality of the set {n ∈ G | f S (n) = m}. (5) For any summary edge m p -→ m , the count e is exactly the cardinality of the set {n p -→ n edge of G f S (n) = m and f S (n ) = m }.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>the ontology O consisting of the triples GradStud rdfs:subClassOf Instructor takes rdfs:range Course Professor rdfs:subClassOf Instructor takes rdfs:domain Student advises rdfs:subPropertyOf knows to state that graduate students, respectively professors, are instructors, that anyone who takes a course is a Student, what can be taken is a course, and that advising someone entails knowing him or her.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>where m 1 , m 2 are the quotient nodes corresponding to the equivalence classes of n 1 , n 2 respectively. Quotients have several desirable properties from a summarization perspective:</figDesc><table><row><cell>Size Property completeness:: Every property</cell></row><row><cell>(edge label) from G is present on some sum-</cell></row><row><cell>mary edges. This gives first-time users of</cell></row><row><cell>the dataset a chance to decide, based on</cell></row><row><cell>their interest and envisioned application, if</cell></row><row><cell>it is worth further investigation. In some</cell></row><row><cell>applications, e.g., when data journalists ex-</cell></row><row><cell>plore open data, or physicians look for a</cell></row><row><cell>rare diagnosis, it is important not to miss a</cell></row><row><cell>"weak signal", encoded in RDF as a set of</cell></row><row><cell>triples using infrequent properties.</cell></row></table><note><p><p><p><p><p>guarantees:: By definition, G /≡ is guaranteed to have at most as many nodes and edges as G. Some non-quotient summaries, e.g., Dataguides</p><ref type="bibr" target="#b16">[17]</ref></p>, cannot guarantee this. Structural homomorphism:: It is easy to see that the function f associating to any</p>2 </p>An equivalence relation ≡ is a binary relation that is reflexive, i.e., x ≡ x, symmetric, i.e., x ≡ y ⇒ y ≡ x, and transitive, i.e., x ≡ y and y ≡ z implies x ≡ z for any x, y, z.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Summary of the notations used in the article.</figDesc><table><row><cell></cell><cell cols="2">RDF graph</cell><cell></cell><cell></cell></row><row><cell>G ∞</cell><cell cols="4">the result of saturating G (Sec-</cell></row><row><cell></cell><cell>tion 2.1)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>type</cell><cell cols="3">rdf:type (Section 2.1)</cell><cell></cell></row><row><cell>sc, sp</cell><cell cols="2">rdfs:subClassOf,</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="4">rdfs:subPropertyOf (Section 2.1)</cell></row><row><cell cols="3">domain, range rdfs:domain,</cell><cell>rdfs:range</cell><cell>(Sec-</cell></row><row><cell></cell><cell>tion 2.1)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>≡ S</cell><cell cols="4">strong equivalence (Definition 2)</cell></row><row><cell>≡ W</cell><cell cols="4">weak equivalence (Definition 3)</cell></row><row><cell>G /S</cell><cell cols="4">strong summary of G (Definition 5)</cell></row><row><cell>G /W</cell><cell cols="4">weak summary of G (Definition 4)</cell></row><row><cell>≡ TW</cell><cell cols="4">typed weak equivalence (Sec-</cell></row><row><cell></cell><cell>tion 4.2)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>≡ TS</cell><cell cols="4">typed strong equivalence (Sec-</cell></row><row><cell></cell><cell>tion 4.2)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>G /TW</cell><cell>typed</cell><cell>weak</cell><cell>summary</cell><cell>of</cell></row><row><cell></cell><cell cols="2">G(Definition 6)</cell><cell></cell><cell></cell></row><row><cell>G /TS</cell><cell cols="4">typed strong summary of G (Sec-</cell></row><row><cell></cell><cell>tion 4.2)</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="4">strong homomorphism (Defini-</cell></row><row><cell></cell><cell>tion 7)</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Relationships between summaries. From the definition of weak and strong equivalence, it is easy to show that (G /S ) /W = G /W , i.e., one could compute G /W by first summarizing G into G /S , and then applying weak summarization on this (typically much smaller) graph; similarly, (G /TS ) /TW = G /TW .</figDesc><table><row><cell>/TW</cell><cell>G /TW</cell><cell>/TW</cell><cell>/TW</cell><cell>(G ∞ ) /TW</cell></row><row><cell>G /TS</cell><cell>/TS</cell><cell>/W</cell><cell>/TS</cell><cell>(G ∞ ) /TS</cell></row><row><cell>/TS</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>/W</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>/S</cell><cell>/fb</cell><cell></cell></row><row><cell></cell><cell cols="4">Figure 15. Relations between</cell></row><row><cell></cell><cell cols="2">quotient summaries.</cell><cell></cell><cell></cell></row><row><cell>5.4.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>It is also the case that (G /W ) /S = G /W , i.e., strong summarization cannot compress a weak summary further, and similarly (G /TW ) /TS = G /TW . Figure</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>1.1. Check if src p , trg p , sc(s) and tc(o) are known; those not known are initialized with {p}; 1.2. If sc(s) = src p , fuse them into new clique src p = sc(s) ∪ src p ; similarly, if tc(o) = trg p , fuse them into trg p = tc(o) ∪ trg p . 2.</figDesc><table><row><cell></cell><cell>For</cell></row><row><cell cols="2">each s p o ∈ G:</cell></row><row><cell cols="2">2.1. f S (s) ← the (unique) summary node</cell></row><row><cell cols="2">corresponding to the cliques (sc(s), tc(s));</cell></row><row><cell cols="2">similarly, f S (o) ← the node corresponding to</cell></row><row><cell cols="2">(sc(o), tc(o)) (create the nodes if needed).</cell></row><row><cell>2.2</cell><cell>Add f S (s) p f S (o) to G /S .</cell></row><row><cell cols="2">Algorithm 2: Global S summarization of a</cell></row><row><cell>graph</cell><cell></cell></row><row><cell cols="2">increm-W(s p o)</cell></row><row><cell cols="2">1. Check if s Algorithm 3: Incremental W summarization of</cell></row><row><cell>one triple</cell><cell></cell></row><row><cell cols="2">Algorithm 3 outlines incremental W summariza-</cell></row><row><cell cols="2">tion. For example (see the figure below), let's as-</cell></row><row><cell cols="2">sume the algorithm traverses the graph G in Figure</cell></row></table><note><p>p and o p are known: either both are known (if a triple with property p has already been traversed), or none; 2. Check if f W (s) and f W (o) are known; none, one, or both may be, depending on whether s, respectively o have been previously encountered; 3. Fuse s p with f W (s) (if one is unknown, assign it the value of the other), and o p with f W (o); 4. Update f W (s) and f W (o), if needed; 5. Add the edge f W (s) p f W (o) to G /W .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>starts with p 1 wrote a 1 , p 2 wrote a 2 , p 2 takes c 2 (see the figure below). After these, we know p 1 ≡ S p 2 ; their source clique increm-S(s p o) 1. Check if we already know a source clique src p (resp. target clique trg p ). Either both are known (if a p triple has already been traversed), or none. Those not known are initialized with {p}; 2. Check if sc(s) (resp. tc(o)) are known; those unknown are initialized with {p}; 3. If sc(s) = src p , fuse them into new clique src p = sc(s) ∪ src p , using Union-Find; similarly, if tc(o) = trg p , fuse them into trg p = tc(o) ∪ trg p , and: 3.1 Replace sc(s) and src p with src p throughout the summary (respectively, replace tc(o) and trg p with trg p ); 3.2 The above may entail summary node fusions; in this case, update f S (use Union-Find) and the summary edges to reflect it; 4. If before seeing s p o s had been already represented and it had an empty source clique, then s needs to split, i.e., be represented separately from the nodes to which it was ≡</figDesc><table /><note><p>S previously; call split-source(s). (Symmetric discussion for o, call split-target(o)). 5. Update f S (s) and f S (o), if needed; 6. Add the edge f S (s) p f S (o) to G /S . Algorithm 4: Incremental S summarization of one triple split-source(s) 1. Collect all G edges adjacent to s into transf er set. 2. For each s p o ∈ transf er, decrement by 1 the counter for f S (s) p f S (o) in the summary. 3. Update f S (s). 4. For each s p o ∈ transf er, if such edge already exists in the summary, then increment its counter by 1, otherwise add f S (s) p f S (o)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 .</head><label>4</label><figDesc>Summary sizes: direct and after inlining.</figDesc><table><row><cell>)</cell></row></table><note><p>Figure 17. Summarization time (s) vs. graph size |G|. Dataset dt W (s) st W (s) x W (%) dt S (s) st S (s) x S (%</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 5 .</head><label>5</label><figDesc>Shortcut experiments. Table5shows the time to build (G ∞ ) /≡ in two ways: (i) direct, i.e., saturate G then summarize, denoted dt ≡ , and (ii) shortcut (Section 5.3), summarize G, then saturate the summary and summarize again, denoted st ≡ . It also shows the shortcut speed-up x ≡ for ≡∈ {W, S} defined as (dt ≡ -st ≡ )/dt ≡ . The speed-up ranges between 39% and 94% in all cases, a direct consequence of ≡ W and ≡ S compression. Indeed, dt ≡ includes the time to summarize G ∞ , while st ≡ includes the time to summarize (G /≡ ) ∞ ; the smaller this is, the higher x ≡ .</figDesc><table><row><cell>it later. This is significantly faster: for instance,</cell></row><row><cell>global-S on BSBM138M takes only 11.85 minutes,</cell></row><row><cell>while increm-S takes 34.5. Increm-TS is often faster</cell></row><row><cell>than increm-S because typed nodes do not lead to</cell></row><row><cell>splits during TS summarization.</cell></row><row><cell>Shortcut speed-up.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 6 .</head><label>6</label><figDesc>Precision loss experiments.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>an edge in G, and p sc p belongs to schema triples of the saturated graph, thus n 1 p n 2 is produced by saturation in G ∞ . In this case, we show similarly to the preceding item that f</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://rdfquotient.inria.fr</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_1"><p>We exclude a few "standard" root types, such as</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_2"><p>In details, for the graphs in Table4, we omitted: 1008,</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_3"><p>Note that in the particular case of triples connecting untyped nodes, the algorithms coincide.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments Šejla Čebirić has contributed to discussions on early versions of this work.</p></div>
			</div>			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>We include here the proofs of all the statements made in the paper. The main ones are for the general shortcut Theorems 1 and 2, the W and S shortcuts (Theorems 3 and 4), and the correctness of our incremental algorithms (Propositions 5 and 6). The others serve as ingredients for these main proofs.</p><p>Appendix A. Proof of Proposition 1</p><p>Proof. First, note that any two weak summary nodes n 1 , n 2 cannot be targets of the same data property. Indeed, if such a data property p existed, let T C be the target clique it belongs to. By the definition of the weak summary, n 1 corresponds to a set of (disjoint) target cliques ST C 1 , which includes T C, and a set of disjoint source cliques SSC 1 . Similarly, n 2 corresponds to a set of (disjoint) target cliques ST C 2 , which includes T C, and a set of disjoint source cliques SSC 2 . The presence of T C in ST C 1 and ST C 2 contradicts the fact that different equivalence classes of G nodes correspond to disjoint sets of target cliques. The same holds for the sets of properties of which weak summary nodes are sources. Thus, any data property has at most one source and at most one target in G /W . Further, by the definition of the summary as a quotient, every data property present in G also appears in the summary. Thus, there is exactly one p-labeled edge in G /W for every data property in G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B. Proof of Proposition 2</head><p>Proof. If two G /S distinct nodes had the same source and the same target clique, they would be strongly equivalent. This cannot be the case in a quotient summary obtained through ≡ S , since by definition, such a summary has one node for each ≡ S equivalence class. Thus, any two distinct G /S have distinct source cliques and/or distinct target cliques. Now, let m be a G /S node, and S m = f -1 S (m) be the set of all G nodes represented by m. By the definition of a quotient summary, m must be the target (resp. the source) of an edge carrying each of the labels on the edges entering (resp. going out of) any node n ∈ S m . Thus, m is source of all the properties in the source clique shared by the nodes in S m , and is target of all the properties in the target clique shared by the nodes in S m . Thus, m has the source and target clique of any node from S m ; this concludes our proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix C. Proof of Theorem 1</head><p>Proof. We first show that an homomorphism can be established from the node sets of G ∞ to that of (G /≡ ) ∞ .</p><p>Observe that RDF saturation with RDFS constraints only adds edges between graph nodes, but does not add nodes. Thus, a node n is in G ∞ iff n Now, for every edge n 1 p n 2 in ((G /≡ ) ∞ ) /≡ , by definition of an RDF summary, there exists an edge n 1 p n 2 in (G /≡ ) ∞ such that n 1 p n 2 = f 2 (n 1 ) p f 2 (n 2 ). Hence, by Theorem 1, there exists an edge</p><p>Similarly, for every edge n 1 type c in (G ∞ ) /≡ , by definition of an RDF summary, there exists an edge</p><p>• since for every f 1 (n 1 ) type c edge in (G ∞ ) /≡ , there is an edge f 2 (f (n 1 )) type c in ((G /≡ ) ∞ ) /≡ , and</p><p>) type c triples through ϕ (*'). Now, for every edge n 1 type c in ((G /≡ ) ∞ ) /≡ , by definition of an RDF summary, there exists an edge n 1 type c in (G /≡ ) ∞ such that n 1 type c = f 2 (n 1 ) type c. Hence, by Theorem 1, there exists an edge</p><p>From (*) and (**), and, (*') and (**'), it follows that ϕ defines an isomorphism from (G ∞ ) /≡ to ((G /≡ ) ∞ ) /≡ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix E. Saturation and property cliques</head><p>The next Lemma describes the relationships between a clique C of G, its saturated version C + , and the cliques of G ∞ : Lemma 3. (Saturation vs. property cliques) Let C, C 1 , C 2 be non-empty source (or target) cliques of G.</p><p>(1) There exists exactly one source (resp. tar-</p><p>where each C i is a non-empty source (resp. target) clique of G, and for any C i , C j where 1 ≤ i, j ≤ k with i = j, there exist some cliques </p><p>Proof. We prove the lemma only for source cliques; the proof for the target cliques is very similar.</p><p>(1) Any resource r ∈ G having two data properties also has them in G ∞ ; thus, any data properties in the same source clique in G are also in the same source clique in G ∞ . The unicity of C ∞ is ensured by the fact that the source cliques of G ∞ are by definition disjoint. (2) C + 1 and C + 2 intersect on property p iff there exist some p 1 ∈ C 1 and p 2 ∈ C 2 which are specializations of the same p (one, but not both, may also be p itself). Independently, we know that there exist r 1 , r 2 ∈ G such that r 1 has p 1 and r 2 has p 2 ; in G ∞ , r 1 has p 1 and p, thus these two properties are in the same G ∞ clique. Similarly, r 2 has p 2 and p, which ensures that p is also in the same G ∞ source clique.</p><p>(3) Let {p 1 , . . . , p k } be the data properties that appear both in G and in C ∞ ; it follows from the saturation rules and the definition of cliques, that k &gt; 0. For 1</p><p>be a data property, then there exists a resource r having p in G ∞ . Then, in G, r has a property p which is either p, or is such that p sp p in G ∞ . Then, in G ∞ , r has both p and p , which entails that p ∈ C ∞ . Therefore, p is a data property occurring both in C ∞ and in G, therefore p is one of Appendix F. Proof of Lemma 1</p><p>Proof. We prove the lemma for target-related properties.</p><p>"Only if": If data properties are target-related in (G /W ) ∞ , then they belong to the same target clique</p><p>-T C j W is the target clique of a G /W node n j ; n j represents a set of weaklyequivalent G resources, which are targets only of properties in T C j W . Thus, the properties in T C j W are target-related in G.</p><p>-Thus, in G ∞ , also, the properties in T C j W are target-related.</p><p>-From this and the definition of a saturated graph and of a saturated target clique, it follows that the properties from (T C j W ) + are target-related in G ∞ .</p><p>• Further, still by Lemma 3, point 4, each (T C j W ) + intersects at least another (T C l W ) + for 1 ≤ l = j &lt; m, thus the target properties in all the (T C j W ) + for 1 ≤ j ≤ m, and in particular p, are target-related to each other in G ∞ . Thus, p is target-related in G ∞ to all properties from T C ∞ W . "If": if data properties are target-related in G ∞ , then they belong to the same target clique T C ∞ in G ∞ . Let n 1 , . . . , n k be the set of all G resources which are values of some properties in T C ∞ . By definition of an RDF summary and Theorem 1, each summary representative f (n i ) of n i , for 1 ≤ i ≤ k, is at least the object of the same properties as n i , hence all the properties of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix G. Proof of Proposition 3</head><p>Proof. Recall from Lemma 3 that: </p><p>they are connected by an alternating chain of source and target cliques of G ∞ (as shown in Figure <ref type="figure">19</ref>); to reuse that figure for the current proof, let us use n 2k to denote the n 2 of the current lemma statement. Note that G ∞ only adds triples not nodes, thus all the nodes shown in the figure also exist in G. Now, let us consider the G /W nodes f (n 1 ), f (n 2 ), . . . , f (n 2k ) obtained by applying the representation function f on n 1 , . . . , n 2k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix I. Proof of Lemma 2</head><p>Proof. "If": if data properties are target-related in G ∞ , then they belong to the same target clique T C ∞ in G ∞ . Let n 1 , . . . , n k be the set of all G resources which are values of some properties in T C ∞ . By definition of an RDF summary and Theorem 1, each image f S (n i ) of n i , for 1 ≤ i ≤ k is at least the object of the same properties as n i , hence all the properties of T C ∞ in G ∞ are target-related in (G /S ) ∞ .</p><p>"Only If": if two data properties p 1 and p 2 are target-related in (G /S ) ∞ , then they belong to the same target clique T C S,∞ , in which they are at distance n ≥ 0, i.e., they are target-related because of a set n i=0 {r i+1 } of nodes which all have the target clique T C S,∞ . In G /S , each such r i+1 has a target clique T C S i ⊆ T C S,∞ , moreover each r i+1 results from a set of G nodes n j i+1 , j ≥ 1, which by definition of a strong RDF summary, have all the source clique T C S i . Hence, every such n j i+1 node has target clique T C S,∞ in G ∞ (since G and G /S have the same schema), in which p 1 and p 2 are target related.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix J. Proof of Proposition 4</head><p>Proof. Recall from Lemma 3 that:</p><p>for some S G source cliques SC 1 S , . . . , SC m S and target cliques T C 1 S , . . . , T C n S . Lemma 2 ensures that the data properties in (SC 1 S ) + ∪. . .∪(SC m S ) + are related in G ∞ , and those of (T C 1 S ) + ∪ . . . ∪ (T C n S ) + are related in G ∞ . Moreover, n S was created in S G from a set of strongly-equivalent G nodes all sharing a source clique SC i S , for 1 ≤ i ≤ m, and all sharing a target clique T C j S , for some 1 ≤ j ≤ n. Thus, in G ∞ , these nodes connect the data properties of SC ∞ S with those of T C ∞ S .</p><p>Appendix K. Proof of Theorem 4</p><p>Proof. "Only if" follows directly from Theorem 1.</p><p>To prove "if", note that f (n 1 ) ≡ S f (n 2 ) in (S G ) ∞ iff they have the same source clique SC ∞ S and the same target clique T C ∞ S in (S G ) ∞ . By Proposition 4, T C ∞ S is also a target clique of G ∞ , and it must be the target clique of n 1 and n 2 in G ∞ (because of the f homomorphism from G ∞ into (S G ) ∞ ensured by Theorem 1). Similarly, SC ∞ S is a source clique in G ∞ , and in particular the source clique of n 1 and n 2 .</p><p>Thus,</p><p>Appendix L. Proof of Theorem 7</p><p>Proof. We first prove the claim for ≡ fw .</p><p>We show this result using the sufficient condition stated in Theorem 2. That is,</p><p>This holds for class nodes and for property nodes since, by definition, they are only equivalent to themselves through some RDF node equivalence relation. Now, consider two data nodes</p><p>If n 1 ≡ fw n 2 holds in G ∞ , then for every triple n 1 p m 1 there exists a triple n 2 p m 2 such that m 1 ≡ fw m 2 holds, and conversely for every triple n 2 p m 2 there exists a triple n 1 p m 1 such that m 1 ≡ fw m 2 holds.</p><p>Let P ∞ n1,n2→m1,m2 be the set of outgoing properties from n 1 to m 1 and from n 2 to m 2 in G ∞ .</p><p>In G, the set of outgoing properties from n 1 to m 1 , denoted P n1→m1 is a subset of P ∞ n1,n2→m1,m2 , since by definition the saturation of a graph only adds edges; similarly, in G, the set of outgoing properties from n 2 to m 2 , denoted P n2→m2 is a subset of P ∞ n1,n2→m1,m2 , which may be different from P n1→m1 .</p><p>By definition of a ≡ fw -summary, the set of outgoing properties from f (n 1 ) to f (m 1 ) in G /fw is exactly P n1→m1 and similarly the set of outgoing properties from f (n 2 ) to f (m 2 ) in G /fw is exactly P n2→m2 .</p><p>Since G and G /fw have the same schema (Section 5), it follows that in (G /fw ) ∞ , the set of outgoing properties from f (n 1 ) to f (m 1 ), and from f (n 2 ) to f (m 2 ), is exactly P ∞ n1,n2→m1,m2 (data edges can only be added through subProperty constraints).</p><p>Since the above holds for any pair of data nodes n 1 , n 2 such that n 1 ≡ fw n 2 in G ∞ , and for any of their G ∞ outgoing edges n 1 p m 1 and n 2 p m 2 , hence</p><p>If f (n 1 ) ≡ fw f (n 2 ) holds in (G /fw ) ∞ , then for every triple f (n 1 ) p f (m 1 ) there exists a triple f (n 2 ) p f (m 2 ) such that f (m 1 ) ≡ fw f (m 2 ) holds, and conversely for every triple f (n 2 ) p f (m 2 ) there exists a triple f (n 1 ) p f (m 1 ) such that f (m 1 ) ≡ fw f (m 2 ) holds.</p><p>Let P ∞ f (n1),f (n2)→f (m1),f (m2) be the set of outgoing properties from f (n 1 ) to f (m 1 ) and from f (n 2 ) to f (m 2 ) in (G /fw ) ∞ .</p><p>In G /fw , the set of outgoing properties from f (n 1 ) to f (m 1 ), denoted P f (n1)→f (m1) is a subset of P ∞ f n1),f (n2)→f (m1),f (m2) , since by definition the saturation of a graph only adds edges; similarly, in G /fw , the set of outgoing properties from</p><p>By definition of a ≡ fw -summary, the set of outgoing properties from n 1 to m 1 in G is exactly P f (n1)→f (m1) and similarly the set of outgoing properties from n 2 to m 2 in G is exactly P f (n2)→f (m2) .</p><p>Since G and G /fw have the same schema (Section 5), it follows that in G ∞ , the set of outgoing properties from n 1 to m 1 , and from n 2 to m 2 , is exactly P ∞ f (n1),f (n2)→f (m1),f (m2) (data edges can only be added through subProperty constraints).</p><p>Since the above holds for any pair of data nodes f (n 1 ), f (n 2 ) such that f (n 1 ) ≡ fw f (n 2 ) in (G /fw ) ∞ , and for any of their (G /fw ) ∞ outgoing edges f (n 1 ) p f (m 1 ) and f (n 2 ) p f (m 2 ), hence n 1 ≡ fw n 2 in G ∞ holds.</p><p>The proof for ≡ bw directly derives from the above one by considering incoming edges instead of outgoing ones; the proof for ≡ fb then derives from those of ≡ fw and ≡ bw by considering both incoming and outgoing edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix M. Proof of Proposition 5</head><p>Proof. All our algorithms (global or incremental) start by identifying the class and property nodes: this is done retrieving all the subjects and objects from schema triples, and also all the objects of type triples. As previously stated, triple stores routinely support such retrieval efficiently. Our algorithms start by representing these special schema nodes exactly by themselves, and copying in the summary all the schema triples. This exploits the observation made in Section 5 (G and G /≡ have the same schema triples).</p><p>Below, we show the correctness of incremental W and S summarization on data triples. The proof of Proposition 6 (below) extends this also to type triples.</p><p>The correctness of incremental W summarization on data triples follows from the fact that Algorithm increm-W preserves a set of invariants. Let G k be the first k triples of G, in the order in which they are traversed by the algorithm. For any 1 ≤ k ≤ |G|,</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<title level="m">Foundations of Databases</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Diversified stress testing of RDF data management systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Aluç</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Özsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Daudjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="197" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Berlin SPARQL Benchmark</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schultz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Semantic Web Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">From XML schema to relations: A cost-based approach to XML storage</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Siméon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficiency and precision trade-offs in graph summary algorithms</title>
		<author>
			<persName><forename type="first">S</forename><surname>Campinas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Delbru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Tummarello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IDEAS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Compact Summaries of Rich Heterogeneous Graphs</title>
		<author>
			<persName><forename type="first">Š</forename><surname>Čebirić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<idno>RR-8920</idno>
		<ptr target="https://hal.inria.fr/hal-01325900v6.alsopreviousversion(v5" />
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
		<respStmt>
			<orgName>INRIA and U. Rennes</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Summarizing Semantic Graphs: A Survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cebiric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Troullinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zneika</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-01925496" />
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A framework for efficient representative summarization of RDF graphs</title>
		<author>
			<persName><forename type="first">Š</forename><surname>Čebirić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>ISWC (poster</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mining graph patterns efficiently via randomized summaries</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fredrikson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Christodorescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">D(K)-index: An adaptive structural summary for graph-structured data</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">W</forename><surname>Ong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exploring XML web collections with DescribeX</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Consens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rizzolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Vaisman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TWEB</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Storing semistructured data with STORED</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Fernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Query preserving graph compression</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Data structures and algorithms for disjoint set union problems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Galil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="319" to="344" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Incremental structural summarization of RDF graphs</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-01978784" />
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<meeting><address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficient query answering against dynamic RDF databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roatiş</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dataguides: Enabling query formulation and optimization in semistructured databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Exploiting the query structure for efficient join ordering in SPARQL queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="439" to="450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">LUBM: A benchmark for OWL knowledge base systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heflin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Sem</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using graph summarization for join-ahead pruning in a distributed RDF engine</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gurajada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seufert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Miliaraki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Theobald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SWIM Workshop</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Computing simulations on finite and infinite graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Kopke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Covering indexes for branching path queries</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Korth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Exploiting local similarity for indexing paths in graphstructured data</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shenoy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gudes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Set-based approximate approach for lossless graph summarization</title>
		<author>
			<persName><forename type="first">K</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Nawaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1185" to="1207" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">ExpLOD: Summary-based exploration of interlinking and RDF usage in the linked open data cloud</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khatchadourian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Consens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Constructing bisimulation summaries on a multi-core graph processing framework</title>
		<author>
			<persName><forename type="first">S</forename><surname>Khatchadourian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Consens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GRADES Workshop</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Scalable keyword search on large RDF data</title>
		<author>
			<persName><forename type="first">W</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Duan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">GraSS: Graph structure summarization</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lefevre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Terzi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>SDM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Graph summarization methods and applications: A survey</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Safavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Dighe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Koutra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Index structures for path expressions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Graph summarization with bounded error</title>
		<author>
			<persName><forename type="first">S</forename><surname>Navlakha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shrivastava</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Characteristic sets: Accurate cardinality estimation for RDF queries with multiple joins</title>
		<author>
			<persName><forename type="first">T</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Moerkotte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">ABSTAT 1.0: Compute, manage and share semantic profiles of RDF knowledge graphs</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A A</forename><surname>Principe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Spahiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Palmonari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rula</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">D</forename><surname>Paoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Maurino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">SynopSys: large graph analytics in the SAP HANA database through summarization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rudolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paradies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bornhövd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lehner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">GRADES</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Large-scale bisimulation of RDF graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schätzle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Neu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Przyjaciel-Zablocki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SWIM Workshop</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Efficient aggregation for graph summarization</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Hankins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD. ACM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Managing structured and semistructured RDF data using structure indexes</title>
		<author>
			<persName><forename type="first">T</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ladwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<ptr target="http://www.w3.org/RDF/" />
		<title level="m">W3C: Resource description framework</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Graph indexing: Tree + delta &gt;= graph</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Quality metrics for RDF graph summarization</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zneika</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vodislav</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
