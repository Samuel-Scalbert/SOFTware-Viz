<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dealing with Unreliable Agents in Dynamic Gossip</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Line</forename><surname>Van Den Berg</surname></persName>
							<email>line.van-den-berg@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Malvin</forename><surname>Gattinger</surname></persName>
							<email>malvin@w4eg.eu</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Groningen</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dealing with Unreliable Agents in Dynamic Gossip</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">474513A2F52BDD65A2D5B506E55480B6</idno>
					<idno type="DOI">10.1007/978-3-030-65840-3_4</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Gossip describes the spread of information throughout a network of agents. It investigates how agents, each starting with a unique secret, can efficiently make peer-to-peer calls so that ultimately everyone knows all secrets. In Dynamic Gossip, agents share phone numbers in addition to secrets, which allows the network to grow at run-time. Most gossip protocols assume that all agents are reliable, but this is not given for many practical applications. We drop this assumption and study Dynamic Gossip with unreliable agents. The aim is then for agents to learn all secrets of the reliable agents and to identify the unreliable agents. We show that with unreliable agents classic results on Dynamic Gossip no longer hold. Specifically, the Learn New Secrets protocol is no longer characterised by the same class of graphs, so-called sun graphs. In addition, we show that unreliable agents that do not initiate communication are harder to identify than agents that do. This has paradoxical consequences for measures against unreliability, for example to combat the spread of fake news in social networks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The internet has led to great changes in the distribution of news. Recently, 'fake news' received attention, possibly having influenced the 2016 US presidential election <ref type="bibr" target="#b0">[1]</ref>. Besides the challenge to identify fake news, a question is how to treat it: should false information be removed or is marking it as false sufficient?</p><p>Dynamic Gossip is a formal model how information can spread throughout a changing network of agents. It investigates how agents, each with a unique secret, decide, based on their own knowledge about the network, what calls to make so that ultimately everyone knows all the secrets. A gossip protocol can help agents to decide on a call sequence to perform. Examples from the literature are ANY ("call any agent"), CMO ("call me once") and LNS ("learn new secrets") <ref type="bibr" target="#b6">[7]</ref>. In a dynamic setting, additional to secrets, agents share phone numbers, allowing the network to grow at run-time.</p><p>Traditionally these systems assume that everybody is reliable, but this assumption is not justified for many practical applications. Therefore, we adapt Dynamic Gossip to account for unreliable agents. Of course, the possibilities for agents to be unreliable are numerous: agents can lie about their own secret or about secrets of others, agents can have a memory of whom they have lied to or not, agents can always lie or with a certain probability, and agents can lie merely about secrets or also about phone numbers, etc. With any such form of unreliability, the aim of the reliable agents should still be to learn all the secrets (of the reliable agents) and, in addition, to identify the unreliable agents.</p><p>We show that, already with relatively simple unreliable agent a known result in Dynamic Gossip from <ref type="bibr" target="#b6">[7]</ref> breaks down. Specifically, the Learn New Secrets protocol is no longer characterised by sun graphs. This emphasises the need to discard the assumption that everyone is reliable for any practical application. In addition, we show that unreliable agents that do not initiate communication are harder to identify than those that do. This has seemingly paradoxical consequences for security measures taken against unreliable agents: blocking as a measure against false information has the adverse effect of securing the anonymity of the unreliable agents. New protocols are needed to properly cope with unreliable agents in Dynamic Gossip.</p><p>Our article is structured as follows. We give a short summary of related work in Section 2. In Section 3 we recall the definitions of Dynamic Gossip. We then define Unreliable Gossip and unreliable agents in Section 4 and 5, respectively. The new setting then motivates a new notion of success which we define and examine in Section 6. We conclude with future work ideas and a discussion the relevance of Unreliable Gossip for social networks in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Gossip has first been studied in combinatorics and graph-theory <ref type="bibr" target="#b10">[11]</ref>. The classical question, also known as the "telephone problem" is: Given n agents who each start with a unique secret, how many phone calls are needed to spread all secrets? For n &gt; 3 agents that all have the phone number of all other agents, 2n -4 calls are necessary and sufficient to make everyone learn all secrets <ref type="bibr" target="#b14">[15]</ref>. For networks in which not every agent has the phone number of all other agents, these numbers are naturally higher <ref type="bibr" target="#b9">[10]</ref>. Besides communication networks, gossip has also been used for the study of epidemics <ref type="bibr" target="#b8">[9]</ref>, power grids <ref type="bibr" target="#b16">[17]</ref> and neural networks <ref type="bibr" target="#b16">[17]</ref>.</p><p>Most results on classical gossip assume a central and all-knowing scheduler deciding who should call whom and when. This is not realistic for practical applications in which agents have to decide autonomously what (communication) action to take. Hence, distributed gossip has been studied in which agents decide autonomously, on their own, whom to call using epistemic protocols <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">3]</ref>.</p><p>More recently, another assumption has been lifted, namely the assumption that the graph representing who can call whom is constant, i.e. agents have a static phone book or contact list. In dynamic gossip agents also exchange phone numbers, adding edges in the reachability graph <ref type="bibr" target="#b6">[7]</ref>. This means that the network may grow at run-time. This is the setting which we use and extend here.</p><p>Most work on the classical telephone problem and on Dynamic Gossip assumes that all agents are reliable and follow the same protocol. However, gossip with unreliability has been studied extensively in other areas. One direction of research is about settings where communication links are unreliable, as studied in <ref type="bibr" target="#b13">[14]</ref> and <ref type="bibr" target="#b15">[16]</ref>. In contrast, here we assume that communication works perfectly but that agents are unreliable. Our setting is thus more comparable to having faulty or malicious agents, as in distributed storage <ref type="bibr" target="#b5">[6]</ref> or consensus protocols <ref type="bibr" target="#b3">[4]</ref>.</p><p>Similar to our work is also the proposal of 'corrected gossip' in <ref type="bibr" target="#b11">[12]</ref>. The authors study failing nodes and define a gossip protocol which tries to reduce latency of the total group communication. A big difference to our setting is that their networks are static and no links are added at run-time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Dynamic Gossip</head><p>We now give a short introduction to Dynamic Gossip, following <ref type="bibr" target="#b6">[7]</ref>. We assume a finite set of agents, A. Initially, each agent knows only their own secret and some set of phone numbers including their own. If an agent a has the phone number of an agent b, then the phone call ab can take place. During a call, the two agents exchange secrets and phone numbers -including those they learned in previous calls. One might wonder what else agents learn in such a call, but for all results we discuss here higher-order knowledge such as "a knows that b knows the secret of c" is irrelevant, hence we will not model it and refer to <ref type="bibr" target="#b7">[8]</ref>. We formally define gossip graphs, calls and sequences as follows.</p><p>Definition 1 (Gossip Graph). For any set A, let</p><formula xml:id="formula_0">I A := {(a, a) | a ∈ A}. A gossip graph is a triple G = (A, N, S) where A is a finite set of agents, N ⊆ A × A and S ⊆ A × A such that I A ⊆ N and I A ⊆ S. Given any G, let S a := {b ∈ A | (a, b) ∈ S} and N a := {b ∈ A | (a, b) ∈ N }. A graph is initial iff S = I A . A graph is complete iff S = A × A. An agent a is an expert iff S a = A. An agent a is terminal iff N a = {a}.</formula><p>We say that "agent a knows the number of agent b" iff (a, b) ∈ N . Similarly, we say "agent a knows the secret of agent b" iff (a, b) ∈ S.</p><p>We now define calls ab, in which agent a and b share all their information. A call sequence σ is a sequence of calls. We use the following notation: is the empty sequence and σ; τ is the concatenation of two sequences σ and τ ; Moreover, σ τ denotes that σ is a prefix of τ . We say that call ab is possible on a graph G = (A, N, S) iff (a, b) ∈ N . The call sequence is possible on any graph, and a call sequence ab; σ is possible on G iff the call ab is possible on G and σ is possible on G ab . If a call sequence σ is possible on a graph G, then G σ is defined by: G := G and G ab;σ := (G ab ) σ .</p><p>It is an easy exercise to show by induction on σ that "if a knows the secret of b, then a also knows the number of b" is an invariant when making calls.</p><p>Lemma 1. For any initial graph G = (A, N, S) and any call sequence σ that is possible on G, we have in the resulting graph G σ = (A, N σ , S σ ) that S σ ⊆ N σ .</p><p>A protocol for Dynamic Gossip is a rule how agents decide whom they should call. The goal of a gossip protocol is to reach a complete graph, where everybody knows all secrets. Moreover, good protocols will use fewer calls and avoid superfluous or redundant calls. Here we will focus on the LNS protocol from <ref type="bibr" target="#b6">[7]</ref>. For a general definition of protocols in a formal language, see <ref type="bibr" target="#b7">[8]</ref>. We now define when a protocol is successful on a graph. Intuitively, this means all possible executions of the protocol lead to a complete graph.</p><p>Definition 5 (Success). Let P G bet the set of all call sequences possible on G and permitted by protocol P . We also call such call sequences P -permitted.</p><p>Let a graph G = (A, N, S) and a protocol P be given. A finite call sequence σ ∈ P G is successful iff G σ is complete. A sequence σ is P -maximal on G iff σ is P -permitted on G and there is no call P -permitted on G σ , i.e. no call ab can be added to σ such that σ; ab is still P -permitted.</p><p>-P is strongly successful on G if all P -maximal σ ∈ P G are successful.</p><p>-P is weakly successful on G if there is a σ ∈ P G that is successful.</p><formula xml:id="formula_1">-P is unsuccessful on G if there is no σ ∈ P G that is successful.</formula><p>Given a certain class G of networks (graphs) and a protocol P , we can ask the question: is P (strongly, weakly, un-) successful on G. That is, does P lead to a complete network? This question, the gossip problem, is used to characterise networks both by their graph-theoretical properties and by the protocols that are (strongly, weakly, un-) successful on them.</p><p>It is easy to see that on any graph that consists of disconnected parts no protocol is successful. Hence, graphs need to be weakly connected to allow any of the protocols to be successful <ref type="bibr" target="#b6">[7]</ref>. Definition 6. A graph G = (A, N, S) is weakly connected iff for all agents a, b ∈ A there is a undirected N -path between a and b. We say that G is strongly connected iff for all agents a, b ∈ A there is an N -path from a to b.</p><p>A graph G = (A, N, S) is a sun graph iff N is strongly connected on s(G), where s(G) is the result of removing all terminal agents from G.</p><p>Informally, one can think of sun graphs as 'almost' strongly connected graphs.</p><p>Example 2. The following graph is a sun graph: if we remove the only terminal agent a, then we obtain a strongly connected graph (consisting of b and c).</p><formula xml:id="formula_2">a b c</formula><p>Theorem 1 (Theorem 13 in <ref type="bibr" target="#b6">[7]</ref>). Suppose G is an initial gossip graph. Then LNS is strongly successful on G iff G is a sun graph.</p><p>Considering the notion of weak success instead of strong success, the authors of <ref type="bibr" target="#b6">[7]</ref> also show the following result.</p><p>Theorem 2 (Theorem 33 in <ref type="bibr" target="#b6">[7]</ref>). Suppose G is an initial weakly-connected gossip graph. Then LNS is weakly successful on G iff G is neither a bush nor a double bush.</p><p>Combining the two theorems we can see that LNS is weakly but not strongly successful exactly on those graphs which are neither bush nor double bush and not sun graphs. A smallest example of such a graph is the following.</p><p>Example 3. The following graph is not a bush, not a double bush and not a sun graph. Note that the only difference to Example 2 is that we now have an edge</p><formula xml:id="formula_3">a → b instead of b → a. a b c</formula><p>The five maximal LN S call sequences here are the following, of which the first three are successful and the other two are unsuccessful.</p><p>ab; ac; bc successful ab; bc; ac successful ab; cb; ac successful bc; ab unsuccessful cb; ab unsuccessful</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Unreliable Gossip</head><p>It is easy to define reliable agents: they do exactly what they are expected to do. In particular, reliable agents communicate truthfully about their own secret, about secrets of others and share all the phone numbers they have. However, when unreliability is allowed, there are numerous different options. There may be noise on the communication channel causing the communication between agents to fail; agents may (intentionally or unintentionally) follow a different protocol; agents may actively spread lies, either about their own secret, about other agents' secrets or both; agents may sabotage connections between other agents; unreliable agents may form coalitions to manipulate the network; the degree of unreliability may evolve over time, via peer pressure or other mechanisms; unreliable agents might have a memory of whom they have lied to; etc. This gives rise to many different types of unreliable behaviour.</p><p>In this article we only consider a basic form of unreliability: unreliability in the form of unintended random memoryless noise. A real-world example for this kind of unreliability could be a network of sensors that communicate with each other, but where one or more of the sensors are faulty. We therefore assume:</p><p>-Agents all follow the same protocol; -Unreliable agents only lie about their own secret; -Connections are not sabotaged; -Unreliability does not evolve; -Unreliable agents do not remember to whom they lied; -Agents consider all new information as true until proven otherwise.</p><p>In the standard model of (dynamic) gossip, an agent either knows a secret or not. For settings with unreliable agents we need more: agents can also have obtained a wrong secret and thus have a false belief.</p><p>To model this, we let secrets be bits and replace the former set of secrets S a with two sets: X a for agents of which a received secret 1, and Y a for agents of which a received secret 0. When an agent is in either X a or Y a , then a considers that agent to be reliable. But when an agent is both in X a and Y a , then a will consider that agent unreliable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7 (UG Graph).</head><p>A gossip graph with unreliable agents, short Unreliable Gossip graph or UG graph, is a quadruple G = (A, R, N, S) where A is a finite set of agents, R ⊆ A is the set of reliable agents, N ⊆ A × A is the network relation and S : A → P(A) × P(A) assigns to each agent a ∈ A a pair (X a , Y a ). We say that a has a positive secret of b iff b ∈ X a , that a has a negative secret of b iff b ∈ Y a , and that a knows that b is unreliable iff b ∈ X a ∩ Y a .</p><p>We also write S a for X a ∪ Y a , which intuitively is the set of all agents of which a knows any secret. When all agents are reliable (R = A), a UG graph can be identified with a gossip graph by setting S a := X a ∪ Y a for each a ∈ A.</p><formula xml:id="formula_4">Definition 8 (Initial UG Graph). A UG graph G = (A, R, N, S) is initial iff for all a ∈ A we have X a ∪ Y a = {a}.</formula><p>In a regular call ab, where both agents speak the truth, information is shared as follows. This means that both agents update their contact lists (N a and N b , respectively) and update their sets X, Y by taking unions. In particular, if before the call agent a had a positive and secret agent b had a negative secret of some agent c, then after the call both a and b know that agent c is unreliable. Definition 9 (UG Call between reliable agents). Let G = (A, R, N, S) be a UG Graph and let a, b ∈ A such that (a, b) ∈ N . The call ab maps G to G ab = (A, R, N ab , S ab ) where N ab is as in Definition 2 and</p><formula xml:id="formula_5">S ab c := (X a ∪ X b , Y a ∪ Y b ) if c ∈ {a, b} (X c , Y c ) otherwise</formula><p>Analogous to Definition 3 we write G σ for the result of executing a sequence of calls σ on a UG graph G.</p><p>Note that in the definition of a call, agents are naive: they consider all new information completely trustworthy and update their knowledge accordingly. In other settings where unreliable agents may lie about secrets of other agents, one can imagine that agents would adopt a more sceptic approach or prefer first hand information (an agent sharing their own secret) over second hand information (and agent sharing a secret of another agent).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Unreliable Agents</head><p>We now formally define unreliable agents that satisfy the constraints given in Section 4. An unreliable agent may report a wrong value of their own secret in a call. We do not assume any rules about when and how often an unreliable agent reports the wrong value of their secret, only that the probability to lie is non-zero (for when the probability is zero, it is a reliable agent).</p><p>In addition to the call ab from Definition 9, we now define three calls Ab, aB or AB in which respectively a, b or both agents report the wrong value of their own secret. That is, the agents denoted with a capital letter are lying about their own secrets in this call. For example, in a call Ab all secrets are shared normally, apart from agent a's secret. More specifically, if a ∈ X a then the new set of secrets for b is not given by merging X a with X b , and Y a with Y b , but by merging X a \ {a} with X b , and Y a ∪ {a} with Y b . The lying of agent a is thus represented by acting as if her own secret was in Y a and not in X a (or vice versa).</p><p>Note that Ab, Ba and AB can only occur if, respectively, a, b or both agents do not belong to the set of reliable agents R. On the other hand, note that in the call Ab agent b does not necessarily belong to R, but might still be unreliable and just happen to speak the truth in this call.  </p><formula xml:id="formula_6">S Ab a := (X a ∪ X b , Y a ∪ Y b )<label>(1)</label></formula><formula xml:id="formula_7">S Ab b :=      ((X a \ {a}) ∪ X b , Y a ∪ {a} ∪ Y b ) if a ∈ X a \ Y a (X a ∪ {a} ∪ X b , (Y a \ {a}) ∪ Y b ) if a ∈ Y a \ X a (X a ∪ X b , Y a ∪ Y b ) if a ∈ X a ∩ Y a<label>(2</label></formula><formula xml:id="formula_8">S AB a :=      (X a ∪ (X b \ {b}), Y a ∪ Y b ∪ {b}) if b ∈ X b \ Y b (X a ∪ X b ∪ {b}, Y a ∪ (Y b \ {b})) if b ∈ Y b \ X b (X a ∪ X b , Y a ∪ Y b ) if b ∈ X b ∩ Y b<label>(3)</label></formula><formula xml:id="formula_9">S AB b :=      ((X a \ {a}) ∪ X b , Y a ∪ {a} ∪ Y b ) if a ∈ X a \ Y a (X a ∪ {a} ∪ X b , (Y a \ {a}) ∪ Y b ) if a ∈ Y a \ X a (X a ∪ X b , Y a ∪ Y b ) if a ∈ X a ∩ Y a<label>(4)</label></formula><p>and S AB c := (X c , Y c ) for all other agents c / ∈ {a, b}.</p><p>Analogous to Definition 3 we write G σ for the result of executing a sequence of reliable or unreliable calls σ on a UG graph G.</p><p>We stress that an unreliable agent will not always report the wrong value. In fact, then it would be the same as a reliable agent with the opposite secret value, and the other agents would never find out that the unreliable agent is lying.</p><p>To illustrate the different types of calls, consider the following example. </p><formula xml:id="formula_10">(X a , Y a ) (X b , Y b ) (X c , Y c ) (X d , Y d ) ({a}, ∅) ({b}, ∅) ({c}, ∅) ({d}, ∅) AB → ({a}, {b}) ({b}, {a}) ({c}, ∅) ({d}, ∅) ac → ({a, c}, {b}) ({b}, {a}) ({a, c}, {b}) ({d}, ∅) Ad → ({a, c, d}, {b}) ({b}, {a}) ({a, c}, {b}) ({c, d}, {a, b}) cd → ({a, c, d}, {b}) ({b}, {a}) ({a, c, d}, {a, b}) ({a, c, d}, {a, b}) bc → ({a, c, d}, {b}) ({a, b, c, d}, {a, b}) ({a, b, c, d}, {a, b}) ({a, c, d}, {a, b})</formula><p>In particular, after the fourth call cd the agents c and d learn that a is unreliable. However, even after the last call, agent d does not know this about b and no more call is permitted according to the LNS protocol.</p><p>Interestingly, a consequence of Definition 10 is that agents may find out themselves that they are unreliable. This is what happens after the call bc in Example 4 for agent b: after this call, b ∈ X b ∩ Y b , hence she considers herself unreliable. But this also informs her that she is uncovered by agent c, who learns the same information about the unreliability of b. If now another agent e enters the network and the call be (or Be) takes place, e will be informed by agent b of her own unreliability. This results from Definition 10: the last clauses of equations 2, 3 and 4 enforce that, in a call between a and b, whenever a is uncovered, i.e. a ∈ X a ∩Y a , the sets X a and X b and Y a and Y b are merged without adjustments. Hence afterwards a ∈ X b ∩ Y b , i.e. b learns that a is unreliable.</p><p>In our setting where unreliability is unintended random memoryless noise this definition is not problematic, but in fact can help the network to perform better. In a network of sensors for instance, the unreliable sensor could then give a signal that it needs to be fixed.</p><p>If agents are intentionally unreliable, it might be more realistic to change their behavior once they learn they are uncovered. To model this we could easily change the last clauses of equations 2, 3 and 4 in Definition 10 to</p><formula xml:id="formula_11">(X a ∪ X b , Y a \ {a} ∪ Y b ) (2') (X a ∪ X b , Y a \ {a} ∪ Y b ) (3') (X a ∪ X b , Y a ∪ Y b \ {b})<label>(4')</label></formula><p>respectively. Similarly, we could do the same but remove a (resp. b) from X a (resp. X b ) instead of Y a (resp. Y b ), but the effect would be analogous. In that situation, an uncovered agent will only continue to communicate one value of her secret (here X a ). In other words, once uncovered she will change her behavior.</p><p>A simple example of an unreliable agent is an alternating bluffer that "lies" in every second call. It provides a first approach to random unintended noise, but it is deterministic and thus easier to simulate and reason about. We note that agent a in Example 4 behaves as an alternating bluffer.</p><p>In our model there is no "curing" or "going back" from unreliability. Once an agent is unreliable and consequently (possibly) uncovered, there is no way for agents to change their behavior. This is sufficient to introduce unreliability into Dynamic Gossip and explore whether the known results continue to hold. But of course, for practical applications, it would be desirable to enable agents to be cured. For example for the application of this framework to the spread of diseases <ref type="bibr" target="#b8">[9]</ref>. An important question is then how agents can convince others that they have improved their behavior, from unreliable to reliable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Unreliable Success</head><p>We now define what it means to be successful in Unreliable Gossip. Completeness on UG graphs is reached when all agents know all secrets, now in the sense that each agent knows at least one secret of each other agent. We note that this is equivalent to completeness on gossip graphs as defined in Definition 1 with S a = X a ∪ Y a . Definition 11. A UG graph G = (A, R, N, S) is complete iff for all agents a ∈ A we have X a ∪ Y a = A.</p><p>However, for Unreliable Gossip this kind of completeness and success according to Definition 5 is not a useful goal. Instead, the aim of the reliable agents should be to reach completeness among themselves and to identify all unreliable agents. We now define reliable completeness formally and argue that it is a more intuitive goal in the setting of Unreliable Gossip than (mere) completeness.</p><formula xml:id="formula_12">Definition 12. A UG graph G = (A, R, N, S) is reliably complete iff for all a ∈ R we have (i) X a ∪ Y a \ (X a ∩ Y a ) = R, and (ii) X a ∩ Y a = A \ R.</formula><p>That is, a graph is reliably complete iff each reliable agent (i) knows the secrets of all reliable agents and (ii) knows for all unreliable agents that they are unreliable. We note that in the presence of (ii) the condition (i) is equivalent to X a ∪ Y a = A. To make it easier to refer to the second condition we also say that an agent a identifies the unreliable agents iff X a ∩ Y a = A \ R.</p><p>Note that reliably complete does not imply complete, because in a reliably complete graph the unreliable agents do not have to know all secrets. Reliable agents should learn all secrets and identify all unreliable agents, but we do not care at all about what unreliable agents learn. Also vice versa, completeness does not imply reliable completeness, because completeness says nothing about knowing which other agents are unreliable.</p><p>In order to compare completeness on unreliable networks to completeness on normal networks, we define reliable counter-graphs and reliable subgraphs. A sanity check shows that indeed both G * and G| R are gossip graphs. Definition 13 allows us to rephrase the definition of reliable completeness: a graph G is reliably complete if and only if the reliable subgraph of G is complete and all reliable agents identify the unreliable agents.</p><p>To conclude this section, we define success for Unreliable Gossip, both for the original notion of completeness and reliable completeness. Definition 14. Suppose we have a UG graph G and a call sequence σ which can be executed on G. We say that σ is successful on G iff G σ is complete and we say that σ is reliably successful on G iff G σ is reliably complete.</p><p>A protocol is (reliably) weakly / strongly / un-successful on a graph G iff all / some / no sequences permitted by the protocol and executable on G are (reliably) successful on G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">LNS is not strongly reliably successful on sun graphs</head><p>Here we show that, already with a small amount of unreliability, for example in the form of the alternating bluffer, a known result about LNS <ref type="bibr" target="#b6">[7]</ref> fails to hold. Specifically, we show that on UG graphs that are sun graphs with only terminal unreliable agents, LNS fails to identify the unreliable agents in the sense that it is not reliably successful as defined in the previous section. Before the general result we give an example where the classification of LNS fails to hold.</p><p>Example 5. Consider again the sun graph from Example 2 and suppose a is unreliable. Now consider the sequence bc; ba; cA. This is an LNS sequence resulting in a complete graph. However, if a is an alternating bluffer, then b will learn one value of the secret of a and c the other. Formally, in the resulting graph G bc;ba;cA we have a ∈ X c \ Y c and a ∈ Y b \ X b . Unfortunately, LNS allows no further calls. Hence b and c may no longer communicate and will not notice that a is unreliable.</p><p>Consider ba; Ac; bc. This is also an LNS sequence which can be executed on the graph above. But in this case b and c talk to each other after having learned different values from a and will thus find out that a is unreliable. Formally, in the resulting graph G ba;Ac;bc we have a ∈</p><formula xml:id="formula_13">(X b ∩ Y b ) and a ∈ (Z c ∩ Y c ).</formula><p>Hence, whether b and c find out that a is unreliable depends on the sequence.</p><p>Example 5 already suffices to show that LNS is not reliably successful on all sun graphs when we have unreliable agents. However, we now prove something slightly stronger, namely that for all graphs of a similar shape there is a maximal sequence which is not successful.</p><p>Theorem 3. Consider any initial UG graph with at least one unreliable agent. If all unreliable agents are terminal then LNS is not reliably strongly successful.</p><p>Intuitively, Theorem 3 holds because there are call sequences in which the unreliable agents are called too late, so that the reliable agents cannot verify the secrets of these unreliable agents with each other. This is the case in Example 5: the reliable agents b and c first learn each others' secrets before calling the unreliable agent a. But then b and c cannot call each other again in LNS and hence cannot verify the secret of a with each other. That is why they fail to identify c as unreliable.</p><p>We now first prove a lemma.</p><p>Lemma 2. Suppose G = (A, R, N, S) is an initial UG graph with at least one unreliable agent. Moreover, suppose that all unreliable agents in G are terminal.</p><p>Then for any LNS-permitted call sequence σ we have: if there is a prefix τ σ such that G τ | R is complete but G τ is not reliably complete, then also G σ is not reliably complete and thus σ is not reliably successful on G.</p><p>Lemma 2 states that any LNS sequence cannot become reliably successful any more as soon as it reaches a complete reliable subgraph. Intuitively, once the reliable subgraph becomes complete, the reliable agents can no longer call each other to compare secrets they received from the unreliable agents.</p><p>Proof (of Lemma 2). Let G be an initial UG graph with at least one unreliable agent and where all unreliable agents are terminal. Let σ be an LNS-permitted call sequence with a prefix τ σ such that G τ | R is complete. Then ∀r ∈ R : X τ r ∪ Y τ r ⊇ R and therefore also ∀r ∈ R : X σ r ∪ Y σ r ⊇ R because no contradictory information can be learned about reliable agents. Now note that after the call sequence τ no more calls from an unreliable agent to a reliable agent can take place: just after τ the unreliable agents are still terminal, and in all later calls where they learn the number of a reliable agent they will also learn the secret of that same agent (because G τ | R is complete). Moreover, we can ignore calls between unreliable agents because they do not affect reliable completeness.</p><p>Hence, let ab be the last call to take place in σ from a reliable agent a to an unreliable agent b. Let σ \ ab denote the sequence without this last call. That means before the call a knew no secret of b,</p><formula xml:id="formula_14">i.e. b / ∈ X σ\ab a ∪ Y σ\ab a</formula><p>. But then, because a will not be involved in any later calls, we have that b ∈ X σ a ∪ Y σ a . Hence agent b will not be identified by agent a and σ is not reliably successful on G.</p><p>Proof (of Theorem 3). Let G = (A, R, N, S) be an initial UG graph that is a sun graph where all unreliable agents are terminal. Because all unreliable agents are terminal, the reliable subgraph G| R of G must be a sun graph too. By Theorem 1, any maximal LNS-permitted call sequence τ consisting of calls ab with a, b ∈ R will complete G| R , i.e. G τ | R is complete. Now by Lemma 2, any LNS-permitted call sequence σ extending τ will fail to identify all unreliable agents and hence fail to reliably complete the network. Thus, we cannot extend the sun graph characterisation of LNS to Unreliable Gossip. This already holds for a small amount of unreliability: one terminal alternating bluffer. Of course, this is because we now also demand that reliable agents identify the unreliable agents. If we only care about completeness in the original sense, then LNS is still strongly successful on UG graphs with respect to the reliable agents. In particular, even if unreliable agents are involved in earlier calls (i.e. if there is no τ as in the proof above), the reliable subgraph will still be completed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">LNS is not weakly reliably successful on non-bushes</head><p>We now look at the second characterization result about LNS that was shown in <ref type="bibr" target="#b6">[7]</ref>. For this, consider again Example 3, and suppose that agent c is unreliable. We also saw in the example that the only successful LNS call sequences end are those where C is involved in both last calls. Hence, if now c behaves as an alternating bluffer then a and b will learn different values of the secret of c. Because LNS allows no more calls it is impossible for a and b to learn that c is unreliable.</p><p>TODO: show the results after the five sequences with alternating C</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Blocking unreliable agents hides and helps them</head><p>How can we "repair" LNS to deal with unreliable agents? Intuitively, blocking unreliable agents seems a good measure against the spread of false information in networks because it would prevent unreliable agents from spreading their false information. This would mean that, when an unreliable agent performs a call to another agent, her call will be rejected. By blocking unreliable agents, their communicative power is restricted: they will not be able to initiate calls -whenever they do, they are rejected. Of course, conceptually, there is a difference between blocked agents and agents that are not able to initiate communication. The latter may rather occur whenever their communicating device is broken. Yet, mathematically, these situations are analogous: in both situations, the unreliable agents cannot successfully make a call to another agent. Therefore we evaluate the following protocol that limits the unreliable agents in their ability to make calls to discuss whether blocking unreliable agents is indeed a good measure.</p><formula xml:id="formula_15">Definition 15 (Protocol LNSR). A call ab is LNSR-permitted iff (a, b) ∈ N , a ∈ R and (a, b) ∈ S.</formula><p>But, against the intuition, the protocol LNSR does not only prevent false information from spreading, it might also prevent unreliable agents from being detected by the reliable agents. Specifically, we prove that unreliable agents that are not allowed to initiate any form of communication are harder to identify than unreliable agents that are. In other words, unreliability can be easier detected when it is spread more. Therefore the restriction to disable, via blocking, the unreliable agents from initiating calls is not desirable. Theorem 4. LNSR is a proper strengthening of LNS in the following sense:</p><p>(i) For any UG graph G we have: If LNSR is (reliably) weakly successful on G, then also LNS is (reliably) weakly successful on G. (ii) There is a UG graph G where LNSR is not reliably weakly unsuccessful, but where LNS is reliably weakly successful.</p><p>Proof. (i) Note that any LNSR-permitted call sequence σ is also LNS-permitted.</p><p>If LNSR is (reliably) weakly successful on some UG graph G, then there is an LNSR-permitted call sequence σ such that G σ is (reliably) complete. But then σ is also LNS-permitted, and hence LNS is also (reliably) weakly successful on G. Then the following are all the LNS-permitted call sequences on G. For each sequence we list four variants, depending on where c is lying. It is crucial in part (ii) of Theorem 4 that reliable agents are the last to communicate in order to identify the unreliable agent as such. Thus the success of the protocol is dependent on the call sequence, and in particular on the position of calls between reliable agents: they need to verify the secrets of the unreliable agents. But, agents do not know which agents are the unreliable agents (this is the goal of the protocol), hence they do not know which secrets need to be verified nor with whom to verify this. This problem of verification is similar to the Byzantine Generals Problem <ref type="bibr" target="#b12">[13]</ref> developed to describe a situation in which agents must agree on a joint strategy to avoid catastrophic failure of the system, but where some of the agents or some are unreliable. In a simple form, multiple generals are threatened by a common enemy and they each have to decide whether to attack or to retreat with a preferred outcome of a coordinated attack or coordinated retreat. A good solution to the problem is an algorithm that can both guarantee that all reliable generals decide upon the same plan and that a small number of unreliable generals cannot cause the reliable generals to adopt a bad strategy. Such solutions have been studied in the literature under the name of Byzantine Fault Tolerance, starting with <ref type="bibr" target="#b5">[6]</ref> and more recently including <ref type="bibr" target="#b3">[4]</ref>.</p><p>Theorem 4 illustrates that there are networks on which unreliable agents remain unidentified when they are not allowed to initiate calls, but can be identified when they do initiate calls. This has direct consequences for the security measure to block unreliable agents and raises questions about their effectiveness for real-life applications and gossip-like settings. For example, a faulty sensor should not be shut down immediately but continue to communicate such that it will be identified as faulty by a larger number of other sensors. As another example, fake news articles shared in social networks will be easier to uncover and identify if they are not removed or blocked, but instead marked as fake and continued to be actively shared.</p><p>Formally, we define the ideas of blocking and deleting as follows. Deleting means that an agent removes those agents she knows to be unreliable from her own phone book. Blocking means that, in addition to deleting, the agent removes her own number from the phone book of agents she knows to be unreliable. Definition 16 (Delete and Block). Let G = (A, R, N, S) be a UG graph and let a ∈ A. The delete action λ a maps G to G λa = (A, R, N λa , S) and the block action µ a maps G to G µa = (A, R, N µa , S), which are defined by</p><formula xml:id="formula_16">N λa c := N c if c = a N c \ (X c ∩ Y c ) if c = a N µa c =      N c if c = a and c / ∈ X a ∩ Y a N c \ {a} if c = a and c ∈ X a ∩ Y a N c \ (X c ∩ Y c ) if c = a</formula><p>As Theorem 4 shows, blocking unreliable agents, though seemingly a good approach to prevent the spread of false information, comes at a cost. Blocking unreliable agents seems analogous to restricting their communicative power because the effects are the same: unreliable agents will not be able to initiate communication. This is exactly what has been shown to help them remain unidentified.</p><p>However, in contrast to LNSR, let us now assume that agents only block other agents once they have identified them as unreliable. They will then be able to forward the information that agents are unreliable to others. The following example illustrates how this can prevent the unwanted effect of hiding unreliable agents. Suppose that the reliable agents block the unreliable agents as soon as they identify them. Consider the LNS-permitted call sequence ab; cB; ac; cd. After the subsequence ab; cB; ac the agents a and c will identify agent b as unreliable and this will then be communicated to agent d in the final call cd. Hence also agent d will block b after this and the whole sequence is reliably successful.</p><p>A disadvantage of both LNSR and blocking known-to-be-unreliable agents is that it might exclude other reliable agents "behind" unreliable ones. Whenever there is a reliable agent a that is only able to communicate with an unreliable agent, blocking this unreliable agent also prevents agent a to contact the rest of the network. She is therefore excluded from the rest of the network. Consider the following example.</p><p>Example 7. Let G = (A, R, N, S) be the network drawn below where R = A \ {b} and A \ {a, b} forms a complete cluster, i.e. ∀r ∈ A \ {a, b}: X r ∪ Y r = A \ {b}. Suppose further that all agents in the cluster consider b unreliable, i.e. ∀r ∈ A \ {a, b} : b ∈ X r ∩ Y r , and have no information about a, that b has all the information about A \ {a} and that a only has the phone number of b, as drawn below. Then blocking agent b effectively blocks agent a and the network will not be reliably completed. We argue that this is a realistic scenario for LNS: the call ab might come too late in the call sequence. Then, because the other reliable agents block agent b, agent a is also blocked indirectly.</p><p>A \ {a, b} b a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion and Conclusion</head><p>We extended the formal model of Dynamic Gossip from <ref type="bibr" target="#b6">[7]</ref> to include unreliable agents. To better capture success in Dynamic Gossip with unreliable agents we defined the notion of reliable success: all reliable agents should learn all secrets and they should identify the unreliable agents. We have then shown that, already with a single unreliable agent, we cannot extend the results about the success of the LNS protocol: LNS is successful in the old sense, but not reliably successful on sun graphs with unreliable terminal agents. This shows that the assumption that everybody is reliable is crucial for the success of LNS and that LNS should be adapted for practical applications where agents might fail.</p><p>We then examined a way to counter the spread of false information, namely to restrict communication of unreliable agents. It turns out that unreliable information that is not actively spread is harder to identify than unreliable information that is actively spread. This has seemingly paradoxical consequences for measures against unreliable agents: blocking can have a contrary effect and help unreliable agents to remain unidentified. Thus, there is a pay-off between identifying and containing false information.</p><p>Our framework and in particular the alternating bluffer are of course simplistic and there are many ways to extend this work: agents can also be unreliable or (with intent) lie about other agents' secrets, about phone numbers, about their own knowledge, etc. Yet, we see this work as a starting point for the discussion of reliability and unreliability in dynamic gossip and its real life applications. We thus end this article with the following open questions.</p><p>-What is the class of unreliable gossip graphs characterized by LNS? -Is there any limitation on the position of unreliable agents in this class? -Is there an LNS weakening or strengthening (in the sense of <ref type="bibr" target="#b7">[8]</ref>) that performs better in situations with unreliability?</p><p>Further research will show how Dynamic Gossip protocols can be adapted to deal with other forms of unreliability. Finally, we want to stress that this work is not purely theoretical: social media and the spread of fake news can be seen as an instance of gossip with unreliable agents. Some social networks already use hybrid strategies where false information is not blocked but just marked as such.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 1 .</head><label>1</label><figDesc>Suppose agent a knows the number of b, and agents b and c know each other's number and no other numbers are known. We draw this situation below. Note that we use dashed arrows for the binary relation of knowing the number of someone (N ). Now if a calls b then a and b learn each other's secret, which we draw with solid arrows (S). We also add another dashed arrow: in the call ab agent a also learns the number of c.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 2 (</head><label>2</label><figDesc>Call). Suppose G = (A, N, S), a, b ∈ A and (a, b) ∈ N . The call ab maps G to G ab := (A, N ab , S ab ) where N ab c := N a ∪ N b if c ∈ {a, b} N c otherwise and S ab c := S a ∪ S b if c ∈ {a, b} S c otherwise Definition 3 (Call sequences).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 4 (</head><label>4</label><figDesc>LNS Protocol). A call ab is LNS-permitted iff (a, b) ∈ N and (a, b) ∈ S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 10 (</head><label>10</label><figDesc>UG Call with unreliable agents). Let G = (A, R, N, S) be a UG Graph and let a, b ∈ A such that (a, b) ∈ N . We define four calls. ab ab ab The call ab maps G to G ab = (A, R, N ab , S ab ) from Definition 2. Ab Ab Ab Suppose a ∈ R. The call Ab maps G to G Ab = (A, R, N Ab , S Ab ) where N Ab := N ab from Definition 2, and for agents a and b:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>) and S Ab c := (X c , Y c ) for all other agents c / ∈ {a, b}. aB aB aB Vice versa, suppose b ∈ R. The call aB maps G to G aB which is defined symmetrically, i.e. the same as G Ba . AB AB AB Finally, suppose a ∈ R and b ∈ R. The call AB maps G to G AB = (A, R, N AB , S AB ) where N AB := N ab from Definition 2 and for a and b:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Example 4 .</head><label>4</label><figDesc>Consider the UG graph G = (A, R, N, S) where A = {a, b, c, d}, R = {c, d}, N = A × A and S x = (X x , Y x ) = ({x}, ∅) for each x ∈ A. The (LNS-permitted) call sequence AB; ac; Ad; cd; bc changes G as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Definition 13 .</head><label>13</label><figDesc>Let G = (A, R, N, S) be a UG Graph. Then we define its reliable counter-graph G * := (A, N, S * ) where S * a := (X a ∪ Y a ) \ (X a ∩ Y a ). And we define its reliable subgraph G| R := (A| R , N | R , S| R ) where A| R := R, N | R := N ∩(R×R) and (S| R ) a := (X a ∪ Y a ) ∩ R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(ii) Consider the UG graph G = (A, R, N, S) below with A = {a, b, c}, R = {a, b}, N = {(b, a), (b, c)} and S x = ({x}, ∅) for all x ∈ A. a b c</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Example 6 .</head><label>6</label><figDesc>Consider the following network of four agents with one unreliable agent, agent b, i.e. A = {a, b, c, d} and R = {a, c, d}:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Only the call sequences under 1 and 2 are LNSR-permitted. But only the sequence marked with * reliably completes the network: first the agents a and b need to learn different values from agent c and after that they should communicate with each other to learn that c is unreliable. None of the other sequences reliably complete the network and in particular no LNSR-permitted call sequence reliably completes G. Hence LN S is reliably weakly successful on G, but LN SR is not.</figDesc><table><row><cell>1. ba; ac; bc or ba; aC; bc or ba; ac; bC or ba; aC; bC</cell></row><row><cell>2. ba; bc; ac or ba; bC; ac or ba; bc; aC or ba; bC; aC</cell></row><row><cell>3. bc; ca; ba or bC; ca; ba ( * ) or bc; Ca; ba or bC; Ca; ba</cell></row><row><cell>4. bc; ba; ca or bC; ba; ca or bc; ba; Ca or bC; ba; Ca</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements. This work is based on the master's thesis of the first author [5], supervised by <rs type="person">Jan van Eijck</rs>. We thank <rs type="person">Hans van Ditmarsch</rs> and the anonymous reviewers at the DaLí workshop for helpful feedback.</p></div>
			</div>			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Social media and fake news in the 2016 election</title>
		<author>
			<persName><forename type="first">H</forename><surname>Allcott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gentzkow</surname></persName>
		</author>
		<idno type="DOI">10.1257/jep.31.2.211</idno>
		<ptr target="https://doi.org/10.1257/jep.31.2.211" />
	</analytic>
	<monogr>
		<title level="j">Journal of Economic Perspectives</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="211" to="268" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Epistemic protocols for distributed gossiping</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Van Der Hoek</surname></persName>
		</author>
		<idno type="DOI">10.4204/EPTCS.215.5</idno>
		<ptr target="https://doi.org/10.4204/EPTCS.215" />
	</analytic>
	<monogr>
		<title level="m">Proceedings TARK 2015. EPTCS</title>
		<meeting>TARK 2015. EPTCS</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="51" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Knowledge and gossip</title>
		<author>
			<persName><forename type="first">M</forename><surname>Attamah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Van Ditmarsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Van Der Hoek</surname></persName>
		</author>
		<idno type="DOI">10.3233/978-1-61499-419-0-21</idno>
		<ptr target="https://doi.org/10.3233/978-1-61499-419-0-21" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-first European Conference on Artificial Intelligence</title>
		<meeting>the Twenty-first European Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="21" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Baird</surname></persName>
		</author>
		<ptr target="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" />
		<title level="m">The swirlds hashgraph consensus algorithm: Fair, fast, byzantine fault tolerance</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Van Den Berg</surname></persName>
		</author>
		<ptr target="https://eprints.illc.uva.nl/1597/,Master&apos;sThesis" />
		<title level="m">Unreliable gossip</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
		<respStmt>
			<orgName>University of Amsterdam</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Practical byzantine fault tolerance</title>
		<author>
			<persName><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/legacy/events/osdi99/castro.html" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Symposium on Operating Systems Design and Implementation -OSDI 99</title>
		<meeting>the Third Symposium on Operating Systems Design and Implementation -OSDI 99</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="173" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Dynamic gossip</title>
		<author>
			<persName><forename type="first">H</forename><surname>Van Ditmarsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Eijck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramezanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Schwarzentruber</surname></persName>
		</author>
		<idno type="DOI">10.1007/s41980-018-0160-4</idno>
		<ptr target="https://doi.org/10.1007/s41980-018-0160-4" />
	</analytic>
	<monogr>
		<title level="j">Bulletin of the Iranian Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="701" to="728" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Strengthening gossip protocols using protocol-dependent knowledge</title>
		<author>
			<persName><forename type="first">H</forename><surname>Van Ditmarsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gattinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">B</forename><surname>Kuijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pardo</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1907.12321" />
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Logics -IfCoLog Journal of Logics and their Applications</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Epidemic information dissemination in distributed systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Kermarrec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Massoulié</surname></persName>
		</author>
		<idno type="DOI">10.1109/MC.2004.1297243</idno>
		<ptr target="https://doi.org/10.1109/MC.2004.1297243" />
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="60" to="67" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The communication problem on graphs and digraphs</title>
		<author>
			<persName><forename type="first">F</forename><surname>Harary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Schwenk</surname></persName>
		</author>
		<idno type="DOI">10.1016/0016-0032(74)90126-4</idno>
		<ptr target="https://doi.org/10.1016/0016-0032(74)90126-4" />
	</analytic>
	<monogr>
		<title level="j">Journal of the Franklin Institute</title>
		<imprint>
			<biblScope unit="volume">297</biblScope>
			<biblScope unit="page" from="491" to="495" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A survey of gossiping and broadcasting in communication networks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Hedetniemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Hedetniemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L</forename><surname>Liestman</surname></persName>
		</author>
		<idno type="DOI">10.1002/net.3230180406</idno>
		<ptr target="https://doi.org/10.1002/net.3230180406" />
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="319" to="349" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Corrected gossip algorithms for fast reliable broadcast on unreliable systems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hoefler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Shiloh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Drezner</surname></persName>
		</author>
		<idno type="DOI">10.1109/IPDPS.2017.36</idno>
		<ptr target="https://doi.org/10.1109/IPDPS.2017.36" />
	</analytic>
	<monogr>
		<title level="m">2017 IEEE International Parallel and Distributed Processing Symposium (IPDPS)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="357" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The byzantine generals problem</title>
		<author>
			<persName><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Shostak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
		<idno type="DOI">10.1145/3335772.3335936</idno>
		<ptr target="https://doi.org/10.1145/3335772.3335936" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="382" to="401" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Randomized gossiping with unreliable communication: Dependent or independent node updates</title>
		<author>
			<persName><forename type="first">G</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Johansson</surname></persName>
		</author>
		<idno type="DOI">10.1109/CDC.2012.6426729</idno>
		<ptr target="https://doi.org/10.1109/CDC.2012.6426729" />
	</analytic>
	<monogr>
		<title level="m">2012 IEEE 51st IEEE Conference on Decision and Control (CDC)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="4846" to="4851" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On a telephone problem</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tijdeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nieuw Archief voor Wiskunde</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">19</biblScope>
			<biblScope unit="page" from="188" to="192" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Distributed parameter estimation in unreliable sensor networks via broadcast gossip algorithms</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.neunet.2015.09.008</idno>
		<ptr target="https://doi.org/10.1016/j.neunet.2015.09.008" />
	</analytic>
	<monogr>
		<title level="j">Neural Networks</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Collective dynamics of &apos;small-world&apos; networks</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Watts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Strogatz</surname></persName>
		</author>
		<idno type="DOI">10.1038/30918</idno>
		<ptr target="https://doi.org/10.1038/30918" />
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">393</biblScope>
			<biblScope unit="issue">6684</biblScope>
			<biblScope unit="page" from="440" to="442" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
