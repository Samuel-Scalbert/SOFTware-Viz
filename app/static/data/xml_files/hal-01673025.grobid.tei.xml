<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Optimization of Recursive Relational Queries: Application to Graph Queries</title>
				<funder ref="#_yuea8wj">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Louis</forename><forename type="middle">Jachiet</forename><surname>Ltci</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Genevès</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nils</forename><surname>Gesbert</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Nabil</forename><surname>Layaïda</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Télécom Paris</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Tyrex team</orgName>
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Grenoble INP</orgName>
								<orgName type="institution" key="instit2">LIG</orgName>
								<address>
									<postCode>38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Optimization of Recursive Relational Queries: Application to Graph Queries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EA5004765C12D3793B5330677B3186D0</idno>
					<idno type="DOI">10.1145/3318464.3380567</idno>
					<note type="submission">been partially supported by the ANR contribution was authored or co-authored by an employee, contractor or affiliate of a national government. As such, the Government retains a nonexclusive, royalty-free right to publish or reproduce this article, or to allow others to do so, for Government purposes only. SIGMOD&apos;20, June 14</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Graph databases have received a lot of attention as they are particularly useful in many applications such as social networks, life sciences and the semantic web. Various languages have emerged to query graph databases, many of which embed forms of recursion which reveal essential for navigating in graphs. The relational model has benefited from a huge body of research in the last half century and that is why many graph databases rely on techniques of relational query engines. Since its introduction, the relational model has seen various attempts to extend it with recursion and it is now possible to use recursion in several SQL or Datalog based database systems. The optimization of recursive queries remains, however, a challenge. We propose µ-RA, a variation of the Relational Algebra equipped with a fixpoint operator for expressing recursive relational queries. µ-RA can notably express unions of conjunctive regular path queries. Leveraging the fact that this fixpoint operator makes recursive terms more amenable to algebraic transformations, we propose new rewrite rules. These rules makes it possible to generate new query execution plans, that cannot be obtained with previous approaches. We present the syntax and semantics of µ-RA, and the rewriting rules that we specifically devised to tackle the optimization of recursive queries. We report on practical experiments that show that the newly generated plans can provide significant performance improvements for evaluating recursive queries over graphs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The expressive power of query languages has been greatly improved with the introduction of recursion. Recursive queries are, for instance, very useful in data integration since expressive ontologies use recursion <ref type="bibr" target="#b28">[29]</ref>. Graph databases are another example where recursion is particularly useful for expressing navigation along paths connecting nodes in the graph. For this purpose, graph query languages often include constructs such as Regular Path Queries (RPQs) <ref type="bibr" target="#b26">[27]</ref>, and various extensions such as Conjunctions of them (CR-PQs) and Union of CRPQs (UCRPQs) <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b49">50]</ref>. For instance, the query language SPARQL 1.1 <ref type="bibr" target="#b42">[43]</ref> introduced Property Paths, and language proposals such as OpenCypher <ref type="bibr" target="#b33">[34,</ref><ref type="bibr">55]</ref> and G-core <ref type="bibr" target="#b10">[11]</ref> also include the possibility of expressing recursive paths. SPARQL's Property Paths revealed crucial for extracting information from RDF data structures such as those found in social networks, life sciences and transportation networks. However, recursive path queries are notoriously known to be much harder to optimize and evaluate than non-recursive ones <ref type="bibr" target="#b53">[54,</ref><ref type="bibr" target="#b69">71]</ref>. In practice, even with datasets of modest sizes, the benchmarking work found in <ref type="bibr" target="#b14">[15]</ref> notices that "all tested systems either failed on the majority of these [recursive] queries or had to be manually terminated after unexpectedly long running times." A major difficulty is to find an appropriate way to execute the query, a task frequently referred to in the literature as finding an appropriate Query Execution Plan (QEP). For example, let us consider the following query:</p><formula xml:id="formula_0">?x isLocatedIn+ ?y Emmy_Noether worksAt ?x Q e x</formula><p>In a graph, this query retrieves all pairs of nodes ?x, ?y such that Emmy Noether worked for ?x and ?x is located in ?y, or is located in a place that is located in ?y, etc.. Formally, isLocatedIn+ indicates that it is the transitive closure of isLocatedIn. Different QEPs exist for executing Q ex . For instance:</p><p>• A first QEP, named P 1 , corresponds to computing first the transitive closure of isLocatedIn and then joining it with the ?x solution of Emmy_Noether worksAt ?x. • Another QEP, noted P 2 , would rather start by computing the set of solutions for Emmy_Noether worksAt ?x. Then, these results are joined with the set of pairs ?x,?y solutions of ?x isLocatedIn ?y. The resulting pairs of nodes are all solutions of Q ex . Finally, iteratively, for each pair ?x,?y in the set of solutions one can find the ?y' such that ?y isLocatedIn ?y' and add ?x,?y' to the set of solutions.</p><p>The QEP P 2 is generally more efficient than P 1 . Each pair of nodes (?x,?y) processed in P 2 is a solution of Q ex . Therefore the total running time of P 2 is linear in the number of solutions multiplied by the maximal degree of nodes in the graph. In contrast, in P 1 , the transitive closure of isLocatedIn always needs to be fully computed. This closure can contain, in the worst case, a number of elements which is quadratic in the number of isLocatedIn-labeled edges; and even in the best case, the transitive closure contains at least all the isLocatedIn-labeled edges. In the yago dataset <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b62">64]</ref>, that contains millions of entities and facts extracted from Wikipedia, there are only 16 solutions for Q ex whereas there are millions of isLocatedIn-labeled edges. P 2 is thus by far more efficient than P 1 .</p><p>Let us now consider a slightly more sophisticated example with the following query (taken from <ref type="bibr" target="#b4">[5]</ref>), still intended to be executed against the yago dataset: ?x hasChild/livesIn/isLocatedIn+/dealsWith+ Japan Q 2</p><p>The variable ?x denotes any graph node representing a person. Q 2 retrieves all such nodes that are connected to a particular node labeled "Japan" through a path which must satisfy a regular path expression over edge labels in the graph. The regular path expression is recursive because it includes the subexpression R=isLocatedIn+/dealsWith+ in which the operator "+" stands for the transitive closure. Again, there are several ways to evaluate Q 2 for retrieving all possible values for ?x. In particular, there exists different QEPs for R corresponding to radically different manners of executing Q 2 . We briefly describe below three QEPs: P 3 , P 4 , P 5 that we will use as examples:</p><p>• Plan P 3 consists in first computing the two transitive closures isLocatedIn+ and dealsWith+ of the relations isLocatedIn and dealsWith, respectively, and then joining the results. One pitfall of this execution plan is that the sets to be joined might be very large (due to e.g. numerous locations in the database and the large size of the set of pairs connected by "isLocatedIn+"), even though the overall query finally retrieves only few results. • Early works on recursive query optimization <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref> already proposed how to push filters (and projections) as close to the sources as possible, even through recursive terms. Plan P 3 can be optimized using this technique: the constant "Japan" can be "pushed inside the computation of dealsWith+". This corresponds to plan P 4 where the evaluation starts from ?t dealsWith Japan, then iteratively adds dealsWith steps on the left. Once this computation is finished, the results are joined with isLocatedIn and then, once again, iterative isLocatedIn steps are performed on the left. One advantage of P 4 compared to P 3 is that P 4 processes each node at most twice while the whole transitive closures of dealsWith and isLocatedIn can be considerably larger (quadratic in the worst case). • Another completely different way to evaluate R, noted plan P 5 , consists in not computing any transitive closure but, instead, computing first the composed relation "isLocatedIn/dealsWith" and then recursively navigating in the graph either hopping on the left with isLocatedIn or hopping on the right by dealsWith to retrieve nodes. Notice that this slightly more general form of recursion is not a transitive closure of any relation.</p><p>The plan P 3 will generally be slower than P 4 or P 5 , even when using smart algorithms for computing transitive closures <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b59">61]</ref>. On some instances P 4 will be much more efficient (if, for instance, ?x dealsWith+ Japan has few solutions) and on some other instances P 5 will be faster (if, for instance, there are few solutions of dealsWith/isLocatedIn). This is the case when evaluating Q 2 over the yago graph (that has more than 62 million of edges): P 5 is faster by a factor of more than 200x compared to other plans.</p><p>We investigate the problem of computing such query execution plans automatically.</p><p>Contribution. We introduce a theory, which is an extension of Codd's classical relational algebra, for the purpose of automatically obtaining efficient QEPs for recursive queries. Specifically, we introduce a fixpoint operator "µ" in the relational algebra for denoting recursive terms in an algebraic manner. This fixpoint operator can express transitive closures as well as slightly more general forms of recursion. It makes recursive terms more amenable to transformations. We take advantage of this for introducing five new rewriting optimization rules. These rules allow generating new execution plans for recursive queries, that are beyond reach using previous approaches. We demonstrate empirically with a prototype implementation that these new plans can provide significant performance gains in recursive graph query evaluation compared to previous approaches.</p><p>Outline. We first review related works on the topic in § 2. Then in § 3, we introduce the syntax and semantics of µ-RA: a variation of the relational algebra (RA) equipped with a fixpoint operator. § 4 describes properties of µ-RA and demonstrates that our fixpoint can be rewritten (to push filters, projections and joins inside of the fixpoints) and that two (or more) fixpoints can sometimes be merged into a unique fixpoint. We also explain why our approach is able to generate efficient plans that were beyond reach. As an application, we present how recursive graph queries translate into µ-RA in § 5. We then report on practical experiments in § 6, in which we benchmark a prototype implementation with state-of-the-art systems for evaluating recursive graph queries. For reading purposes, we present only proof sketches of our main theorems; the full proofs being available in <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>We first present the main approaches that have been proposed to evaluate recursive queries, and we explain why our approach can be more efficient, in particular for the specific kind of recursive queries expressed as UCRPQs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The relational model</head><p>The relational model <ref type="bibr" target="#b24">[25]</ref> introduced by Codd in 1970 has become the de facto paradigm for querying data banks. The design of the prevailing database query language SQL has been heavily influenced by the Relational Algebra (RA).</p><p>One of the main interest of the RA (and of SQL) is that it allows programmers to express the data they are interested in without specifying the way to retrieve it <ref type="bibr" target="#b50">[51]</ref>, instead they rely on a relational query engine to find an efficient way to process queries. Most relational query engines thus rely on a optimization process where the query to be processed is translated into an algebraic term. Then, this term is rewritten into a set of semantically equivalent terms (by e.g. pushing selections, or projections as close as possible to the sources). These different terms can be used to generate different QEPs. For a given query, the set of QEPs is called a Plan Space. The plan space depends on the set of equivalent terms that we can generate from the initial query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Recursive queries &amp; expressive power</head><p>Soon after the introduction of RA, the work found in <ref type="bibr" target="#b7">[8]</ref> noticed that the RA lacks the possibility of expressing recursive queries. Several formalisms have been introduced as attempts to fill this gap. We now briefly review the most closely related of these various formalisms (see e.g. <ref type="bibr">[2,</ref><ref type="bibr" target="#b17">18]</ref> for complete surveys).</p><p>The α-extended RA <ref type="bibr" target="#b6">[7]</ref> extends the RA with a recursive facility noted α. The operator α is a transitive closure operator; given an α-extended RA term R defining a binary relation R, α (R) represents its transitive closure, R + . In terms of expressive power over graphs, this corresponds to UCRPQs. It is for instance not capable of querying the path expression a n /b n which queries paths whose labels are first as then bs with exactly the same number of a and b.</p><p>A more powerful way of extending the RA is the LFP-RA. LFP-RA is the RA extended with a "least fixpoint" construct. Given a LFP-RA term R parametric in a relation X , the least fixpoint of R over X , noted µ (X = R), is obtained as the limit of a sequence (X i ) i ∈N where X 0 = ∅ and X i+1 is computed by adding to X i the results of evaluating R when the relation X is filled with X i .</p><p>This LFP-RA formalism has the same expressive power and the same data complexity as Datalog with stratified negation, for which evaluation is known to lie in PTime.</p><p>Because LFP-RA terms can be computationally hard to evaluate, several syntactic fragments of LFP-RA have been studied. A well-studied fragment of this LFP-RA corresponds to limiting fixpoints so that all recursions are "linear" (in a sense that we will define in Definition 6). This restriction makes the expressive power drop to linear Datalog <ref type="bibr" target="#b5">[6]</ref>, which is strictly between the expressive power of α-extended RA and the expressive power of Datalog. For instance, all UCR-PQs as well as the non-regular path expression a n /b n are expressible in linear Datalog; however, the path expression asking for all paths containing exactly as many a labels as b labels in any order is not. The µ-RA that we use in this paper is a variant of this restricted LFP-RA and it has the same expressive power as linear Datalog.</p><p>Another way of extending the RA is the WHILE language (see <ref type="bibr">[2]</ref>). This language is known to be at least as expressive as LFP-RA and the inclusion is strict (unless PTime=PSpace).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Optimization of recursive RA</head><p>In 1979, a first line of work <ref type="bibr" target="#b7">[8]</ref> proposed a restricted LFP-RA. The authors showed that some optimizations can be performed on fixpoints, such as pushing selections into these fixpoints (similar to our rule RW1). One drawback of their method is that it has more restrictions on fixpoints than µ-RA. Being too restricted makes <ref type="bibr" target="#b7">[8]</ref> unable to express some of our rewritten terms, e.g. merged fixpoints (see § 4.1.3). Furthermore, even if the authors note that it is sometimes possible to push projections (similar to our rule RW5) they do not provide an effective criterion for this.</p><p>Using the (unrestricted) LFP-RA, other authors <ref type="bibr" target="#b45">[46]</ref> provided in 1990 a general framework for optimization. Their method works on so-called system graphs and computes a fixpoint of filters that is safe to apply recursively. Their work also provides an effective criterion to push projections. We believe our approach is more straightforward. In addition, they do not deal with conjunctions (our rules RW3 and RW4) and thus cannot find plan P 2 for Q ex nor find plan P 5 for Q 2 , for instance. Finally, compared to unrestricted LFP-RA, µ-RA comes with restrictions on fixpoints that are needed for the validity of the rewrite rules we propose in § 4.1: the optimisations we present would not be correct on the unrestricted LFP-RA (as explained in § 3.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Datalog</head><p>The term Datalog has been coined at the end of the 70s to designate the fragment of logic programming restrained to data. Datalog is a language supporting recursive queries. Many Datalog-based query evaluators exist <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b66">68]</ref> including recent fully-fledged commercial systems <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Magic Sets.</head><p>A well-known Datalog optimization technique is the "Magic Sets" algorithm (see <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b56">58]</ref>). The syntax of Datalog vastly differs from the RA, but the effect of Magic Sets algorithm is very similar to pushing some type of selections and projections. The idea of the magic set is to compute, for each datalog relation, the set of "contexts" where this term will be evaluated. For instance, in the translation of ?a dealsWith+ Japan, the magic set method can sometimes detect that, on the recursive use of dealsWith, the right side is always Japan, and it will not compute the full transitive closure dealsWith+.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Right and left linear programs.</head><p>There are many different ways to translate transitive closures in Datalog. For the transitive closure R + , one translation would use that R + is either a path composed of a single R or the concatenation of a path R and a path R + . Such a translation is called right linear because R + is computed by adding R paths on the left. Another translation would be left-linear: R + is then either a path R or the concatenation of R + with R. As noticed before <ref type="bibr" target="#b52">[53]</ref>, given a Datalog term t computing a binary relation P (x, y), the Magic Set algorithm is able to push filters on the right side (the y) only if t is a right-linear program; and conversely, it can only push filters on the left side (the x) when t is left-linear. The authors of <ref type="bibr" target="#b52">[53]</ref> thus proposed an automated way to "reverse" right-linear programs into left-linear (and vice-versa). This reversal can then be used by a query optimizer in combination with the Magic Set algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.3">Demand Transformation.</head><p>The Demand-driven Transformation, or Demand Transformation, is a recent improvement <ref type="bibr" target="#b63">[65]</ref> over the Magic Sets. The idea is similar to the Magic Set: it pushes filters to avoid computing some "useless" facts. It has been proved that Demand Transformation always beats Magic Sets; however, it still suffers from some of the problems of Magic Sets. In particular, Demand Transformation is also sensitive to whether programs are left or right linear; and on examples containing the concatenation of two transitive closures (such as isLocatedIn + /dealsWith + in Q 2 ), the query execution plan computing first the concatenation isLocatedIn/dealsWith and then recursively adding isLocatedIn on the left or dealsWith on the right will not be found by the Datalog engine, even after Demand Transformation and program reversals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.4">Overall Comparison. Datalog engines do not explore</head><p>Plan Spaces but use heuristics to find a good plan to evaluate queries. Depending on which combination of Magic Sets, Demand Transformation and Reversals it uses, a Datalog engine might be able to find a plan similar to P 2 for Q ex , and to plan P 4 for Q 2 . Since none of these optimizations can "merge" recursive terms, they do not allow to find a plan similar to P 5 for Q 2 , which is -by an order of magnitudethe fastest plan for Q 2 on yago.</p><p>In a Datalog program corresponding to the optimized translation of A+/B+ at least one of the two transitive closures will be fully materialized (even if there are 0 solutions to A+/B+).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">SQL</head><p>Since its 1999 version, the SQL standard supports recursive queries. SQL is more expressive than our µ-RA as it allows, e.g., arithmetic and aggregation, but if we restrict SQL to its core our proposed µ-RA is not very different from SQL with recursion. However, a restriction in SQL (the recursion variable cannot appear more than once in the recursive part of the query) forbids what would be the literal translation of some µ-RA terms; in particular, we cannot translate the merged fixpoint of rule RW4 into standard SQL. Furthermore, recursive queries in SQL are not supported by all vendors and those who do support them tend to consider them as optimization barriers. There are exceptions (such as DB2) but these vendors use a technique inspired by the Magic Set technique invented for Datalog.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Ad-hoc evaluation of UCRPQs</head><p>Up to now, we have only compared systems operating on languages strictly more expressive than UCRPQs. If we are only interested in UCRPQs or RPQs there are others systems and we now present the main ones.</p><p>2.6.1 Automata. One way to evaluate UCRPQ is to translate individual RPQs to automata, run them, and then unionjoin the individual results. This automata-based method is clearly not optimal for UCRPQs as the various RPQs are considered individually and therefore the constraints on one RPQ cannot be used on the others but the automata is sometimes not optimal even on a single RPQ. Indeed, let us suppose that we are considering the regular expression (a/b/c) + , the automata approach starts by computing the solution to the path a, then to the path a/b, then a/b/c and recursively restarts (i.e. in a computational form we have R i+1 = ((R i /a)/b)/c). This method forces the associativity of the computation <ref type="bibr" target="#b68">[70]</ref> and does not test some associations such as computing R i+1 = (R i /a)/(b/c) in which we precompute paths matching (b/c) and which can, in some cases, be much more efficient, when e.g. there are only a handful of solutions to the path b/c. 2.6.2 α-extended RA. The translation of the RPQ (a/b/c/) + in the α-extended RA includes a term α (t ) where t contains (a/b/c). Therefore the relation (a/b/c) will first be fully computed, and then its transitive closure. This is not always optimal, as it suffers from the same drawbacks as the previous approach.</p><p>2.6.3 Waveguide. The Waveguide paper <ref type="bibr" target="#b68">[70]</ref> introduced a new technique to evaluate RPQs that mixes ideas from automata and from the α-extended RA. Their idea is that the "interesting" plans to evaluate one RPQ can either start on the left of the RPQ and try to match the right part, or do the opposite (start on the right part and match the left one) or start in the middle and go both ways. For instance on Q 2 they will try all the plans that we express. However, since they focus on a single RPQ, for a conjunction of RPQs such as Q ex Waveguide will not take advantage of the constraint on ?x and will materialize the full relation owns+. Moreover, on a query ?a dealsWith+ ?b, ?b isLocatedIn+ ?c, our approach will have a single fixpoint in which the number of mappings treated is exactly the number of solutions, while their approach will compute and then join the full transitive closures dealsWith+ and isLocatedIn+.</p><p>The authors of Waveguide extended their work in two short papers. The first one describes Tasweet, a system focusing on disjunction of RPQs and the second one presents Wireframe, a tool focusing on conjunctions of RPQs. Wireframe computes a "query spanning tree" to decide in which order the RPQs should be evaluated, and then ot relies on Waveguide for individual RPQs. Tasweet improves on Waveguide by noticing that given a set of disjunctive RPQs, some computations can be shared. Both of these works suffer from the limitations of Waveguide. For instance, in Wireframe the constraints on one node can be used for the evaluation of other RPQs but the evaluation of various RPQs cannot be interleaved. Furthermore, these tools are limited to conjunctions or unions of RPQs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">THE µ-EXTENDED REL. ALGEBRA</head><p>We now present the µ-extended relational algebra, or µ-RA, which is our variation of the domain-independent relational algebra, equipped with a fixpoint. We first recall some usual definitions, and then present its syntax, types and semantics.</p><p>The formalism introduced in this section is classical (but included for self-completeness) except for the anti-projection and the fixpoint operator. Anti-projection replaces the more common projection operator. Anti-projections and the restrictions on fixpoints will allow us to introduce powerful rewrite rules in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data model</head><p>Our data model is the same as for the classical relational algebra: we consider relations which are sets of mappings (also called tuples, or lines) which associate column names to values. Formally, we assume the following constants:</p><p>• V an infinite set of values;</p><p>• C an infinite set of column names;</p><p>• R an infinite set of relation names.</p><formula xml:id="formula_1">Definition 1. A mapping or tuple is a partial function m : C → V whose domain is finite. If dom(m) = {c 1 , . . . , c n }, m can also be seen as the set {c 1 → m(c 1 ), . . . , c n → m(c n )}. Definition 2. Two mappings m 1 and m 2 are compatible, noted m 1 ∼ m 2 , when ∀c ∈ dom(m 1 ) ∩ dom(m 2 ), m 1 (c) = m 2 (c). If m 1 and m 2 are compatible, we define m 1 + m 2 : dom(m 1 ) ∪ dom(m 2 ) → V by: (m 1 + m 2 )(c) =      m 1 (c) if c ∈ dom(m 1 ) m 2 (c) if c ∈ dom(m 2 )</formula><p>If we see mappings as sets, this corresponds to their union. Definition 3. A relation is a finite set of mappings which share the same domain. We call this common domain the type of the relation. We do not consider datatypes (all values are in the single domain V): for simplicity, a type is just a set of column names. The empty relation is considered compatible with all types.</p><p>Relations represent data. A relational database is a finite set of named relations (also called tables). We represent such a database as a triple (R, Γ, D) where: R ⊂ R is the set of relation names; Γ, the database schema, associates relation names to relation types; and D, the database body, associates relation names to actual relations. The body must be consistent with the schema: for any R ∈ R, D (R) has type Γ(R).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Syntax of µ-RA terms</head><p>Our algebra µ-RA is mainly a variation of the relational algebra, with the addition of a fixpoint operator µ ; it operates on relations. The terms represent queries and are built from</p><formula xml:id="formula_2">φ 1 ▷◁ φ 2 V = {m 1 + m 2 | m 1 ∈ φ 1 V ∧ m 2 ∈ φ 2 V ∧ m 1 ∼ m 2 } φ 1 ∪ φ 2 V = φ 1 V ∪ φ 2 V φ 1 ▷ φ 2 V = {m ∈ φ 1 V | ∀m ′ ∈ φ 2 V ¬(m ′ ∼ m)} |c → v | V = {{c → v}} π a (φ) V = {c → v ∈ m | c a} m ∈ φ V X V = V (X ) ρ b a (φ) V = {c → v ∈ m | c a} ∪ {b → v | a → v ∈ m} m ∈ φ V σ f (φ) V = {m | m ∈ φ V ∧ f(m) = ⊤} µ (X = φ) V = X V [X /U ∞ ] where U 0 = ∅, U i+1 = U i ∪ φ V [X /U i ] ,</formula><p>and </p><formula xml:id="formula_3">U ∞ = n ∈N U i Figure 1: Semantics of µ-RA φ ::= term X relation variable | |c → v | constant | φ 1 ∪ φ 2 union | φ 1 ▷◁ φ 2 join | φ 1 ▷ φ 2 antijoin | σ f (φ) filtering | ρ b a (φ) renaming | π a (φ) anti-projection | µ (X = φ) fixpoint</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Filters.</head><p>The standard selection operation σ f , which operates on a relation by keeping only a subset of its mappings, depends on a filter f indicating which mappings are to be kept. This filter can be seen as a function from mappings to booleans. To keep things focused, we do not detail here a syntax for filters, but we assume that for any filter f we can compute a set FC (f) of column names such that the result of f(m) depends only on {c → m(c) | c ∈ FC (f)}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Terms.</head><p>The core syntax of terms is defined in Fig. <ref type="figure" target="#fig_0">2</ref>. The base terms are relation variables X and constants |c → v | (representing a single mapping with a singleton domain). Two relations can be combined with the classical relational operators ∪, ▷◁ and ▷. One relation can be filtered using the classical selection operation σ f where f is a filter. The rename operator ρ b a (•) renames the column a into b. Less classically, the anti-projection π a (•) (or column dropping) removes column a. The projection operator π p 1 , ...,p n (φ) can be expressed in terms of π (•) provided we know the type of φ: if φ has type t = {p 1 , . . . , p n , a 1 , . . . , a k } we have π p 1 , ...,p n (φ) equivalent to π a 1 (. . . π a k (φ)). Our choice of anti-projection will allow us to extend the domains of subterms without changing the projections, as in π a (φ) ▷◁ ψ → π a (φ ▷◁ ψ ) when a is not in the type of ψ .</p><p>Finally, we introduce the fixpoint term µ (X = φ) representing a recursive query. In this term, there are some additional restrictions on φ, which will be detailed in § 3.4. The result R of this operation is a fixpoint in the sense that evaluating φ with X bound to R must yield R again. The restrictions we add ensure that this fixpoint exists and can be computed iteratively. We consider µ as a variable binder, yielding the standard notions of free and bound variable occurrences: Definition 4. In a term φ, all occurrences of a variable X which appear in a subterm of the form µ (X = ψ ) are bound. All other occurrences of X are free.</p><p>As will be clear from the semantics, bound variables can be renamed, as usual, without changing the meanings of the terms. We can thus assume for simplicity that all bound variables are different from each other and from free variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Semantics</head><p>In µ-RA, relation variables X are used to denote both references to a database relation and a recursive relation. In a full query, the two are distinguished by the fact that database references appear as free variables, whereas recursion variables are bound by µ; but in a subterm, we do not need to distinguish the two. In all cases, the semantics of a term φ depends on an environment V which maps all free variables of φ to relations.</p><p>The semantics is defined in Fig. <ref type="figure">1</ref>, where φ V designates the result of evaluating φ in the environment V . This result is defined recursively from the results of evaluating the subterms. The initial environment for evaluating the whole term is a database body D, but in evaluating µ (X = φ), the recursive calls use different environments where the recursion variable X is given a value: the notation V [X /S] represents the environment V altered by mapping X to S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Restrictions on fixpoints</head><p>Our syntax for the µ-RA is very general and comprises some counter-intuitive fixpoints and some types of fixpoints that are hard to optimize (e.g. non linear &amp; mutually recursive). We present restrictions on fixpoints that are needed for the validity of our rewrite rules and of most of our propositions and theorems.</p><p>In the sequel, we suppose that all fixpoints abide the restrictions that we present here. This does not mean, however, that our method can not be applied on general terms: given a general term φ that contains a subterm ψ , if ψ abides the restrictions then we can apply our rewrite rules on ψ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Properties of fixpoints.</head><p>Definition 5. Given a term φ, we say that φ is constant in X when X is not a free variable of φ. Definition 6. A fixpoint term µ (X = φ) is said:</p><p>• positive when for all subterms φ 1 ▷φ 2 of φ, φ 2 is constant in X ; • linear when for all subterms of φ of the form φ 1 ▷◁ φ 2 or φ 1 ▷ φ 2 , either φ 1 or φ 2 is constant in X ; • mutually recursive when there exists a subterm µ (Y = ψ ) of φ with X free in ψ .</p><p>Proposition 1. If µ (X = φ) is linear, positive and non mutually recursive then the function</p><formula xml:id="formula_4">f (S ) = φ V [X /S ] is such that: f (S ) = f (∅) ∪ x ∈S f ({x })</formula><p>and thus f has a fixpoint with µ (X = φ) V = f ∞ (∅).</p><p>Proof sketch. We prove by induction on the subterms ξ of φ where X is free in ξ that ξ</p><formula xml:id="formula_5">V [X /S ] = ξ V [X /∅] ∪ x ∈S ξ V [X / {x }] .</formula><p>By linearity, such a ξ can only be combined with a constant term and by positivity, it cannot be negated. □ 3.4.2 Expressivity of restricted fixpoints. These restrictions do have an effect on the expressivity of our language. We can show that µ-RA has, at least, the expressive power of inflationary-Datalog ¬ (Datalog with inflationary semantics and negation). When we restrict fixpoints to be positive and non mutually recursive then our language has exactly the expressive power of stratified-Datalog ¬ . Finally with all our restrictions, our language has exactly the expressive power of linear datalog (see § 2.2). This fragment is expressive enough to capture a lot of interesting queries. For instance, the next section presents how to translate UCRPQs into µ-RA (with the restrictions).</p><p>As mentioned previously, our method can be applied on general terms but, for the sake of simplicity, in the sequel we will only consider the fragment rest-µ-RA of µ-RA containing only terms where all the fixpoints are linear, positive and non mutually recursive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Decomposed fixpoints</head><p>Once our terms are restricted, we see that fixpoints can actually be decomposed into a strictly recursive part and a constant part. This decomposition will be later useful for expressing some of our rewrite rules. Definition 7. Given a term φ linear and positive in X , we say that φ is recursive in X when rec (φ, X ) = ⊤ with rec defined as:</p><formula xml:id="formula_6">rec (φ 1 ∪ φ 2 , X ) = rec (φ 1 , X ) ∧ rec (φ 2 , X ) rec (φ 1 ▷◁ φ 2 , X ) = rec (φ 1 , X ) ∨ rec (φ 2 , X ) rec (φ 1 ▷ φ 2 , X ) = rec (φ 1 , X ) rec (σ f (φ), X ) = rec (φ, X ) rec ( π a (φ), X ) = rec (φ, X ) rec (ρ b a (φ), X ) = rec (φ, X ) rec (µ (Y = φ), X ) = ⊥ rec (X , Y ) = X = Y rec (|c → v |, X ) = ⊥</formula><p>Being recursive or constant (def. 5) are syntactical properties. However the two following propositions give a semantic interpretation of those syntactical properties. Lemma 1. Let φ be a term.</p><formula xml:id="formula_7">• If φ is recursive in X then for all V , φ V [X /∅] = ∅. • If φ is constant in X , then φ does not depend on X , i.e. for all S and V , φ V [X /S ] = φ V [X /∅] .</formula><p>Definition 8. A fixpoint term µ (X = κ ∪ ψ ) is said decomposed when κ is constant in X and ψ is recursive in X .</p><p>Example 1. Let us suppose that we want to compute the transitive closure of a binary relation R. We assume R is represented as a two-column table of type {src, trg}. The closure is captured by the term µ (X = R ∪ π m (ρ m trg (R) ▷◁ ρ m src (X ))). This term is a decomposed fixpoint: R is constant and</p><formula xml:id="formula_8">π m (ρ m trg (R) ▷◁ ρ m src (X )) is recursive in X .</formula><p>Proposition 2. A fixpoint term µ (X = φ), linear, positive and non mutually recursive can be rewritten to either: an empty term, a term φ with one less fixpoint or a decomposed fixpoint.</p><p>In the following, we assume that fixpoints are always decomposed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Type System</head><p>Given a schema Γ for a set of relation variables R, we can infer types for terms whose free variables are in R. The typing judgement Γ ⊢ φ : t means that when evaluated in an environment conforming to the schema Γ, φ will yield a relation of type t. Our type system is defined by the rules on Fig. <ref type="figure">3</ref>; it is quite straightforward. The rule for typing fixpoints uses the fact that fixpoints are decomposed to infer first the type of the constant part and then use that information to typecheck the recursive part. Given a database schema Γ, we write F [Γ] for the set of well-typed terms in Γ (i. e. the terms φ such that Γ ⊢ φ : t holds for some t). </p><formula xml:id="formula_9">(X = R ∪ π m (ρ m trg (R) ▷◁ ρ m src (X ))).</formula><p>Assuming R is of type {src, trg}, we can conclude the whole term is also of type {src, trg}.</p><p>Indeed, the fixpoint should have the type of its constant part, which is R. Then we can check the type of the recursive part: ρ m trg (R) has type {src, m} and is joined with ρ m src (X ) of type {trg, m}. The result has type {src, trg, m} but the m column is discarded by the π m (. . . ); thus the whole term is well typed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">GENERATING NEW QUERY PLANS</head><p>The traditional RA has rewrite rules and the optimization of relational queries is usually done by rewriting to a (estimated) more efficient term using rewrite rules. For instance the rule:</p><formula xml:id="formula_10">σ f (φ ▷◁ ψ ) → σ f (φ) ▷◁ ψ</formula><p>describes that a filter can be pushed inside a join. This rule applies whenever FC (f) ⊆ t where t is the type of φ.</p><p>In this section, we discuss properties of rest-µ-RA which allow us to introduce new rewrite rules for recursive terms. These rules extend the set of RA classical rewrite rules, which remain valid on rest-µ-RA. We first describe the new rules informally and briefly explain how they can lead to terms that are more efficiently evaluated. Then in § 4.2 we introduce the "set of derivations" for a term which allows us to describe when the two first rules are correct. Finally, in § 4.3 we introduce "addable columns" which allow us to introduce the conditions for three other rewrite rules to apply. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The new rewrite rules</head><formula xml:id="formula_11">σ f (µ (X = φ)) → µ (X = σ f (φ)) (RW1) µ (X = φ) ▷ ψ → µ (X = φ ▷ ψ ) (RW2)</formula><p>This always reduces the amount of mappings manipulated by the fixpoint. For example, on the RPQ ?x isLocatedIn+ Japan, the first rule permits to only compute the ?x where ?x isLocatedIn+ Japan, instead of computing the whole transitive closure isLocatedIn+ and then filtering out the pairs not in Japan.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Pushing joins into fixpoints:</head><formula xml:id="formula_12">µ (X = φ) ▷◁ ψ → µ (X = φ ▷◁ ψ ) (RW3)</formula><p>This can also decrease the number of mappings solutions of the fixpoint. This rewrite rule can typically be used on RPQs such as Q ex . In this query, there is no need to compute the whole set of pairs (?x,?y) such that ?x isLocatedIn+ ?y, as only the ?x such that Emmy_Noether worksAt ?x are of interest to us. Rule RW3 can be used here to push Emmy_Noether worksAt ?x into the fixpoint of ?x isLocatedIn+ ?y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Merging fixpoints:</head><formula xml:id="formula_13">µ (X = κ ∪ ψ ) ▷◁ µ (X = κ ′ ∪ ψ ′ ) → µ (X = κ ▷◁ κ ′ ∪ ψ ∪ ψ ′ ) (RW4)</formula><p>This reduces the number of fixpoints and the number of mappings. For instance, on Q 2 : instead of computing isLocatedIn+ and dealsWith+ separately and then joining them, rule RW4 permits to first compute isLocatedIn/dealsWith and then to add steps isLocatedIn on the left or steps dealsWith on the right.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.4">Pushing antiprojections into fixpoints:</head><formula xml:id="formula_14">π p (µ (X = φ)) → µ (X = π p (φ)) (RW5)</formula><p>This can also reduce the number of mappings: the value of the removed column being ignored, several mappings might get merged (due to set semantics). This is typically useful for RPQs in which a fixpoint is joined or filtered and the value of the join or filter variable is discarded.</p><p>We now discuss formally the conditions which allow these rewritings. All the proofs are in <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Set of derivations of a term</head><p>In general, we do not have σ f (µ (X = φ)) ≡ µ (X = σ f (φ)). Indeed, it is possible that some mappings solution of µ (X = φ) do not pass the filter but are still useful to create mappings (with the fixpoint iteration) which do pass the filter.</p><p>To rule out this possibility, we can use the following criterion: if the filter depends only on columns which are untouched by the fixpoint iteration, then applying the filter before or after the iteration is equivalent. To check this cri-Γ ⊢ π a (φ) : t \ {a}</p><formula xml:id="formula_15">Γ ⊢ κ : t Γ ∪ {X → t } ⊢ ψ : t Γ ⊢ µ (X = κ ∪ ψ ) : t Figure 3: Typing rules for µ-RA d (φ 1 ∪ φ 2 , X ) = d (φ 1 , X ) ∪ d (φ 2 , X ) d (φ 1 ▷ φ 2 , X ) = d (φ 1 , X ) d (φ 1 ▷◁ φ 2 , X ) = d (φ 1 , X ) ∪ d (φ 2 , X ) d (ρ b a (φ), X ) = {p • (b → a, a → ⊥)| p ∈ d (φ, X )} d ( π a (φ), X ) = {p • (a → ⊥) | p ∈ d (φ, X )} d (σ f (φ), X ) = d (φ, X ) d (µ (Y = φ), X ) = ∅ d (X , X ) = {()} (a singleton identity) d (R, X ) = ∅ d (|c → v |, X ) = ∅</formula><p>Where • represents the composition and (a 1 → b 1 , . . . , a n → b n ) represents the function that maps each a i to its b i and every other column name to itself. Note that this definition manipulates functions with an infinite domain but the domain where they do not coincide with the identity is finite and they are thus computable.</p><p>Example 1 followup. In our previous example, X appears only once and thus there is only one derivation that maps src → ⊥, m → ⊥ and everything else to itself. In particular trд is mapped to itself. Lemma 2. Let w be a mapping and φ a term linear, positive and non mutually recursive in X . For all m ∈ φ V [X / {w }] either m ∈ φ V [X /∅] or there exists p ∈ d (φ, X ) such that for all c ∈ dom(w ):</p><formula xml:id="formula_16">p(c) = ⊥ ∨ p(c) dom(w ) ∨ m(c) = w p(c)</formula><p>Definition 10. Given a term φ linear and positive in a variable X , we define the stabilizer of X in φ as the following set of column names:</p><formula xml:id="formula_17">stab (φ, X ) = {c ∈ C | ∀p ∈ d (φ, X ) p(c) = c} Lemma 3. Given a fixpoint term µ (X = φ) ∈ F [Γ]</formula><p>of type t and a mapping w of type t, w ∈ µ (X = φ) V if and only if there exists a lineage for w, that is, a finite sequence w 0 , . . . , w n such that:</p><formula xml:id="formula_18">w 0 ∈ φ V [X /∅] , w i+1 ∈ φ V [X / {w i }]</formula><p>, and w n = w.</p><p>Furthermore, for all lineages w 0 , . . . , w n and all c ∈ t ∩ stab (φ, X ), we have for all i, w 0 (c) = w i (c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Application to rewrite rules RW1 and RW2.</head><p>Theorem 1 (Pushing filters). Let µ (X = κ ∪ ψ ) be a decomposed fixpoint term, V an environment and f a filter condition with FC (f) ⊆ stab (ψ , X ). Then we have σ</p><formula xml:id="formula_19">f (µ (X = κ ∪ ψ )) V = µ (X = σ f (κ) ∪ ψ ) V .</formula><p>Proof sketch. This is a consequence of lemma 3: we can filter the lineage on w or on w 0 but they have equal values on FC (f) and by definition of FC, eval (f, w 0 ) = eval (f, w ). □ Example 1 followup. In our previous example, trд was in the stabilizer and src was not. Indeed the term µ</p><formula xml:id="formula_20">(X = R ∪ π m (ρ m trg (R) ▷◁ ρ m src (X )</formula><p>)) computes the pairs (src, trд) in the transitive closure of R by taking a pair (src, trд) already in the closure then finding a link (src ′ , src) in R and finally adding (src ′ , trд) to the set of solutions.</p><p>On this term, pushing a filter on trд is possible but not on src: a solution (src, trд) might not pass the filter but be useful to discover a solution (src ′ , trд) passing the filter.</p><p>Theorem 2 (Pushing anti-joins). Let µ (X = κ ∪ ψ ) be a decomposed fixpoint term, V an environment and ξ a term of type t ⊆ stab (ψ , X ) (we suppose that X is not a free variable of ξ ). Then we have µ</p><formula xml:id="formula_21">(X = κ ∪ ψ ) ▷ ξ V = µ (X = (κ ▷ ξ ) ∪ ψ ) V .</formula><p>Proof sketch. The anti join will act in a very similar way to a filter since ξ is constant in X . Lineages w 0 . . . w n will preserve the property to be compatible with one of the elements of ξ V . □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Addable columns to a fixpoint</head><p>Let us assume a fixpoint φ = µ (X = κ ∪ ψ ) such that Γ ⊢ φ : t. t is thus the type of κ. Suppose we change the constant part κ in such a way that it has now type t ′ t. We want to ensure that the columns that t ′ adds or removes with respect to t play no role in the recursive computation ψ . For this, we introduce the predicate add (ψ , X , c) which checks syntactically that ψ does not depend on X having a column named c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Logical framework.</head><p>Definition 11. We say that a column c ∈ C can be added to or removed from a term ψ ∈ F [Γ] recursive in X when add (ψ , X , c) = ⊤ holds, with add defined as:</p><formula xml:id="formula_22">add (φ 1 ∪ φ 2 , X , c) = add (φ 1 , X , c) ∧ add (φ 2 , X , c) add (φ 1 ▷◁ φ 2 , X , c) = add (φ 1 , X , c) ∧ add (φ 2 , X , c) add (φ 1 ▷ φ 2 , X , c) = add (φ 1 , X , c) ∧ add (φ 2 , X , c) add (ρ b a (φ), X , c) = add (φ, X , c) ∧ c {a, b} add ( π a (φ), X , c) = add (φ, X , c) when c a add ( π c (φ), X , c) = X free(φ) add (σ f (φ), X , c) = add (φ, X , c) ∧ c FC (f) add (µ (Y = φ), X , c) = add (φ, X , c) add (R, X , c) = c Γ(R) when X R add (X , X , c) = ⊤ add (|c ′ → v |, X , c) = c c ′ Lemma 4. Let µ (X = κ ∪ ψ ) ∈ F [Γ] be a decomposed fix- point of type t, let c ∈ (C \ t )</formula><p>that can be added to ψ , and w a mapping of type t. We note w (v) = w ∪ {c → v}.</p><p>If ∀R ∈ R, c Γ(R), then we have:</p><formula xml:id="formula_23">• c ∈ stab (ψ , X ) • Γ ∪ {X → t ∪ {c}} ⊢ ψ : t ∪ {c} • ψ ▷◁ |c → v | V [X / {w }] = ψ V [X / {w (v ) }]</formula><p>Proof sketch. The first point can be proved inductively by definition of stab and add. The second point is a consequence of the first. The third point can be proved by induction on the size of ψ . □ 4.3.2 Application to rewrite rules RW3, RW4 and RW5.</p><p>Theorem 3 (Pushing joins). Let µ (X = κ ∪ ψ ) ∈ F [Γ] be a decomposed fixpoint of type t κ and φ ∈ F [Γ] (with X f ree (φ)) a term of type t φ such that:</p><formula xml:id="formula_24">(1) t φ ⊆ stab (ψ , X ) (2) ∀c ∈ t φ \ t κ add (ψ , X , c) Then we have Γ ⊢ µ (X = κ ▷◁ φ ∪ ψ ) : t φ ∪ t κ with for all V compatible with Γ: φ ▷◁ µ (X = κ ∪ ψ ) V = µ (X = κ ▷◁ φ ∪ ψ ) V Proof sketch. First we prove that ψ ∈ F [Γ ∪ {X → t κ ∪ t φ }]</formula><p>by iterating Lemma 4.1. Then for each lineage w 0 , . . . , w n of µ (X = κ ∪ ψ ) V and each v compatible with w 0 we can build a lineage (w 0 +v), . . . , (w n +v) (by iteration on Lemma 4), which proves</p><formula xml:id="formula_25">w + v ∈ µ (X = φ ▷◁ κ ∪ ψ ) V .</formula><p>The reverse direction is proved similarly. □ Theorem 4 (Merging fixpoints). Given two decomposed fixpoints µ (X = κ 1 ∪ ψ 1 ) and µ (X = κ 2 ∪ ψ 2 ) of types t 1 and t 2 such that:</p><formula xml:id="formula_26">(1) t 1 ∩ t 2 ⊆ stab (ψ 2 , X , C 2 ) ∩ stab (ψ 1 , X , C 1 ) (2) ∀c ∈ t 1 \ t 2 add (ψ 2 , X , c) (3) ∀c ∈ t 2 \ t 1 add (ψ 1 , X , c) then we have: µ (X = κ 1 ∪ ψ 1 ) ▷◁ µ (X = κ 2 ∪ ψ 2 ) V = µ (X = κ 1 ▷◁ κ 2 ∪ ψ 1 ∪ ψ 2 ) V .</formula><p>Proof sketch. The forward direction is easy: given two lineages w 1 0 , . . . , w 1 n and w 2 0 , . . . , w 1 m (for both µ (X = κ i ∪ ψ i ) V ) we can build a lineage (w 1 0 + w 2 0 ) . . . (w 1 0 + w 2 m ) . . . (w 1 n + w 2 m ). The converse direction is more difficult but we can deinterlace the lineages and create two lineages, one for each</p><formula xml:id="formula_27">µ (X = κ i ∪ ψ i ) V □ Example 3. If we want to compute R + 1 (x, y) ∧ R + 2 (y, z)</formula><p>, the naive translation would compute both R + 1 and R + 2 . But our approach also considers the plan where we start from x, y, z such that R 2 (y, z)∧R 1 (x, y) and then will discover new x or new z by a fixpoint:</p><formula xml:id="formula_28">µ (X = R 1 ▷◁ R 2 ∪ ψ ) with ψ = π c (ρ c x (X ) ▷◁ ρ c y (R 1 )) ∪ π c (ρ c z (X ) ▷◁ ρ c y (R 2 )). Theorem 5 (Pushing antiprojections). Let µ (X = κ ∪ ψ ) ∈ F [Γ] be a decomposed fixpoint of type t κ . Let b ∈ C be such that add (ψ , X , b). Then: π b (µ (X = κ ∪ ψ )) V = µ (X = π b (κ) ∪ ψ ) V</formula><p>Proof sketch. This property can be proved via lineages similarly to the proofs of the other theorems. □</p><p>Example 1 followup. In our running example, trд is a an addable column. This means that, if we are interested in</p><formula xml:id="formula_29">π t r д (µ (X = R ∪ π m (ρ m trg (R) ▷◁ ρ m src (X )))) we can push the π t r д (.) and obtain µ (X = π t r д (R ∪ π m (ρ m trg (R) ▷◁ ρ m src (X )))</formula><p>). Pushing π t r д (.) will reduce drastically the number of solutions. We cannot push π sr c (.) as the column src is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">GRAPH QUERY TRANSLATIONS</head><p>µ-RA can be used to model queries over directed graphs with labeled edges. We assume that the set of values V gathers both vertices and edge labels. The graph can then be represented as a pair (V, E) with V ⊂ V denoting the set of vertices and E ⊂ V × V × V denoting the set of edges. This can be modeled as a relational database with two relations V and E representing these two sets, with the schema Γ = {V → {src}, E → {src, l, trg}} where src, l, trg stand respectively for source, label, target.</p><p>Regular path queries (RPQs) <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b51">52</ref>] provide a basic construct used in graph query languages. An RPQ makes it possible to express a path connecting graph nodes by the means of regular expressions over edge labels. We consider a set W of query variables, and a set K ⊆ V of vertex labels (constants). The general syntax of an RPQ is r (x, y) where x ∈ W ∪ K is connected to y ∈ W ∪ K by the regular path expression r defined as follows:</p><formula xml:id="formula_30">r ::= v a single edge label | r 1 /r 2 concatenation | r 1 |r 2 alternative | r -1 reverse | r + transitive closure</formula><p>For example, the sample query Q 2 given in the introduction is an RPQ. The basic component for translating graph queries into µ-RA is the translation of the regular path expressions r . We translate any r into a set of µ-RA terms ϕ, representing one or more alternative translations, in such a way that the result of evaluating any of those ϕ on the graph database is the set of all mappings {src → v 1 , trg → v 2 } such that the sequence of labels in the path from v 1 to v 2 matches r . For this purpose, we define a translation function • that compiles any r into µ-RA, as follows:</p><formula xml:id="formula_31">v = π l (σ l=v (E)) r 1 /r 2 = π m (ρ m trg (ϕ 1 ) ▷◁ ρ m src (ϕ 2 )) | ϕ 1 ∈ r 1 ∧ ϕ 2 ∈ r 2 r 1 |r 2 = ϕ 1 ∪ ϕ 2 | ϕ 1 ∈ r 1 ∧ ϕ 2 ∈ r 2 r -1 = ρ src m (ρ trg src (ρ m trg (ϕ))) | ϕ ∈ r r + = µ (X = ϕ ∪ π m (ρ m trg (ϕ) ▷◁ ρ m src (X ))) | ϕ ∈ r ∪ µ (X = ϕ ∪ π m (ρ m src (ϕ) ▷◁ ρ m trg (X ))) | ϕ ∈ r</formula><p>Notice that for r + we have two equivalent translated terms. This is because we can choose to rename src to m either in r or in X (and correspondingly trg to m in the other), depending on the direction we want to follow when recursively navigating the graph. We want to keep track of both translations, as this has impact on the plan space generation 1 . This is the reason why r returns a set of terms and not a single term. This translation of regular path expressions constitutes the main component used for translating graph query languages such as UCRPQs.</p><p>A CRPQ is of the form H ← C, where the query head H is a non-empty set of vertex variables to be extracted by the query, and C is a conjunction of RPQs that describes how those vertex variables are connected to other vertex variables or to constants. More formally:</p><p>• H is of the form (z 1 , ..., z m ) with arity m &gt; 0 (we do not consider boolean queries) • C is a conjunction of the form r 1 (x 1 , y 1 ), ..., r n (x n , y n )</p><p>where:</p><formula xml:id="formula_32">-x 1 , y 1 , ...x n , y n ∈ W ∪ K -each r i is an RPQ (as defined previously) -for each 0 &lt; k ≤ m we have z k ∈ {x 1 , y 1 , ...x n , y n } \ K.</formula><p>UCRPQs extend CRPQs with union at top level. They have the syntax H ← C 1 ∪ ... ∪ C n in which each disjunct C i is a conjunction as defined previously. We translate a UCRPQ into µ-RA as follows:</p><formula xml:id="formula_33">H ← C 1 ∪ C 2 ... ∪ C n = C 1 H ∪ C 2 H ... ∪ C n H with:</formula><p>1 This is because rewrite rules presented in § 4 apply differently over each initial translation, generating two different plan spaces, and we want to explore the union of the two.</p><formula xml:id="formula_34">C H = ϕ 1 ▷◁ ϕ 2 ▷◁ ... ▷◁ ϕ n | (φ 1 , φ 2 , ..., φ n ) ∈ combine (C) H combine (r 1 (x 1 , y 1 ), ..., r n (x n , y n )) H = r 1 (x 1 , y 1 ) H × ... × r n (x n , y n ) H r (x, y) H = Π θ x src θ y trg (φ) H | φ ∈ r θ x c (φ) = ρ x c (φ) for x ∈ W σ c=x (φ) for x ∈ K in which Π (φ) H = π x 1 ( π x 2 ... ( π x n (φ)</formula><p>)) where x 1 , x 2 , ..., x n occur in φ but not in H (we keep only columns corresponding to selected variables).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS 6.1 Prototype</head><p>For shedding light on the practical interest of computing richer plan spaces, we experimentally compared the performance of graph query evaluation with and without our novel rewriting rules. To test these rules, we implemented a prototype executor for UCRPQs as follows. First, queries are translated into µ-RA terms. Then, we enumerate equivalent terms using a Volcano-style strategy <ref type="bibr" target="#b36">[37]</ref>. We then pick one of the equivalent terms, translate it into SQL, and send it to PostgreSQL. Physical plan selection and evaluation are left to the PostgreSQL engine; however, depending on the µ-RA term we pick, this engine will not be able to access the same plan space.</p><p>The key point is the set of fixpoint subterms in the query. Each of those will always be computed in full into a temporary table by the engine, since it has no internal rules to move other operations in or out of the recursion block. Based on this observation, we estimate a cost for each µ-RA term and pick one of the terms with the minimal estimated cost (see below).</p><p>We have two possible translations for fixpoint terms. When a fixpoint µ (X = κ ∪ ψ ) is such that X appears exactly once in ψ , which is always the case for terms generated by translating a UCRPQ, this fixpoint can be translated into a CREATE RECURSIVE VIEW statement, which is purely declarative so that the engine can freely decide how to compute it. This allows us to test PostgreSQL on the initial translated query without restricting its plan space (this test is what we call 'System P' below). However, the rewriting rule for merging fixpoints generates terms where X appears twice; these terms cannot be translated into pure SQL. In that case, we resort to procedural language (PL/pgSQL) and a WHILE loop which computes a temporary table containing the result of the fixpoint term.</p><p>Cost estimation. We use a simple cost estimation based on <ref type="bibr" target="#b58">[60]</ref>, extended to deal with fixpoint terms. It uses a few parameters: number of tuples in each relation in the database, number of distinct values for each column, and histogram values for selectivity <ref type="bibr" target="#b41">[42]</ref>. These parameters are available from the PostgreSQL server where the data is stored. For a fixpoint term µ (X = κ ∪ ψ ), we assume that the number of new tuples generated is reduced, at each iteration, by a factor s which we compute from selectivity values and the operations in ψ . As the iteration stops when no new tuples are generated, we estimate the number of steps as log s (K ) where K is the estimated number of tuples in κ. This estimated number of steps allows us to estimate, in turn, the number of tuples in µ (X = κ ∪ ψ ) and the CPU time required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Methodology</head><p>6.2.1 Queries. Our methodology is twofold: first, we tested a set of realistic queries evaluated over a real-world dataset; and we also used the gMark benchmark <ref type="bibr" target="#b14">[15]</ref> to randomly generate UCRPQs with corresponding synthetic datasets.</p><p>Queries over the yago dataset. We use a cleaned version of the real world dataset yago2s <ref type="bibr" target="#b32">[33]</ref>, that we have preprocessed in order to remove duplicate triples and keep only triples with existing and valid identifiers. After preprocessing, we obtain a table of yago facts with 83 predicates and 62,643,951 rows (graph edges). We collected third-party queries previously considered against this popular dataset: we collected 7 RPQs from <ref type="bibr" target="#b4">[5]</ref>, 2 from <ref type="bibr" target="#b68">[70]</ref> and 2 from <ref type="bibr" target="#b40">[41]</ref>. Since all of them are RPQs, we supplemented them with additional CRPQs to illustrate more complex forms of recursion. Fig. <ref type="figure" target="#fig_3">4</ref> presents the 20 queries tested with the yago dataset.  a Q 1 ... Q 7 are taken from <ref type="bibr" target="#b4">[5]</ref>, Q 8 , Q 9 from <ref type="bibr" target="#b68">[70]</ref>, and Q 10 , Q 11 from <ref type="bibr" target="#b40">[41]</ref>.</p><p>"isL" stands for "IsLocatedIn", "dw" for "dealsWith", "haa" for "hasAcademicAdvisor", "USA" for "United_States", "wce" for "wikicategory_Capitals_in_Europe", "typ" for "rdf:type" and "sc" for "rdfs:subClassOf".</p><p>Generated queries over synthetic datasets, using gMark. We gathered queries generated by gMark <ref type="bibr" target="#b14">[15]</ref>, which are available on the gMark open source repository <ref type="bibr" target="#b15">[16]</ref>. We filtered them to retain only queries in which at least one recursion was present. For queries generated with an empty head, we replaced the empty head by a head containing all the variables occurring in the body (so as to test a more complex polyadic variant of the query instead of its simple boolean counterpart). This provided us with 12 recursive queries for the "UniProt" gMark scenario, that we evaluated on a gMark-generated graph instance having 76,707 edges. We also carried out similar tests with the "Shop" gMark scenario for which we report on the evaluation of 14 queries over a synthesized graph instance with 209,789 edges. 6.2.2 Tested Systems. We compared the query evaluation performance of the newly obtained recursive query plans with state-of-the-art systems implementing previously known approaches for recursive queries, namely:</p><p>• system P: the popular PostgreSQL open-source relational database <ref type="bibr" target="#b54">[56,</ref><ref type="bibr" target="#b61">63]</ref> implementing SQL with recursive views.</p><p>• system P': our prototype extending the PostgreSQL system with our optimizations; • system V: the Virtuoso graph column store <ref type="bibr" target="#b29">[30]</ref> which is backed by a relational database, and that implements the SPARQL 1.1 language <ref type="bibr" target="#b42">[43]</ref> (with property paths); • system L: a modern engine implementing Datalog <ref type="bibr" target="#b64">[66]</ref>;</p><p>• system N: the Neo4j native graph database implementing the openCypher graph query language [40, 55].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Experimental setup</head><p>Set semantics. Most systems implement both bag and set semantics, and use bag semantics by default. However, their implementation of recursion differs significantly, which causes some systems to retrieve more or less duplicates when compared to others. Therefore, we use set semantics. Timeout. For each tested system, we set a maximum time of 30 min of computation for each query (after 30 min, we stop the computations and consider that this particular query evaluation is not feasible with the given system) 2 . Specific limitations. Some systems have inherent limitations or require specific configuration. System N supports recursion only around atomic patterns (e.g. isLocatedIn+ is supported but (actedIn/-actedIn)+ is not) so it can evaluate only a limited number of the considered queries. Initial comparison baseline for system P. A given graph query translates into several possible µ-RA forms, even before applying our rewrite rules (see § 5). For a fair comparison with system P, we use the internal cost estimation of P to discriminate them 3 . Thus, for a given query, the time reported for system P is the elapsed time for evaluating the query translation that P has itself chosen among other equivalent initial translations.</p><p>Reported metrics. We report on query evaluation performance, excluding (i) time spent for data preparation (e.g. for loading or computing indexes) and (ii) for query optimization (e.g. for generating the plan space -a task which can benefit from extensive research and various techniques found in the literature <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b60">62]</ref>, and which is beyond the scope of this paper). We thus mainly concentrate on query evaluation times. We also report on the number of query answers returned by each system using set semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Results</head><p>6.4.1 Queries over the yago dataset. Fig. <ref type="figure" target="#fig_4">5</ref> shows the time spent with each system for evaluating each query of Fig. <ref type="figure" target="#fig_3">4</ref>. The time scale is logarithmic. Whenever no time is reported for a given query and system, this means that either the system crashed (or answered wrongly) within the first 30 minutes of computation for that query, or the computations were stopped after 30 minutes. In both cases, the evaluation of the query is considered unfeasible with that system.</p><p>Coverage. First, we observe significant discrepancies between the number of queries that each system has been able to answer. Systems N and V answered only 4 queries out of 20. In comparison, system P answered many more queries: all but one; and System P' answered all of them. Table <ref type="table">2</ref> summarizes the number of feasible queries for each system. Fig. <ref type="figure" target="#fig_5">6</ref> presents the number of retrieved results (in logarithmic scale) for each query and each system. All the systems agree on the number of query results (using set semantics), except V which did not retrieve the correct results in some cases (typically terminating within the allowed timeframe but incorrectly returning no result). In those cases, we consider that it could not answer the query, and no time is reported. hard disk drives (SAS, RAID 5), running Ubuntu 16.04 LTS, Docker 18.09.7, and the latest public Docker images for each tested system. 3 Specifically, for each initial translation, we get the 'total cost' value returned by a call to the "EXPLAIN" statement of system P. We then retain the translation of minimum estimated cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N V L P P'</head><p>Feasible queries 4 4 17 <ref type="bibr">19 20</ref> Unfeasible queries 16 16 3 1 0</p><p>Table <ref type="table">2</ref>: yago queries treated by each system.</p><p>Performance for feasible queries. We observe that P' always performed more efficiently than P, in several cases by an order of magnitude. This suggests that the new plans computed by our approach sometimes represent much more efficient alternatives. In the case of query 9, the new plan selected even makes query answering possible whereas it is unfeasible with other systems. Table <ref type="table" target="#tab_3">3</ref> summarizes the gains brought by P', in terms of feasibility and performance, in comparison to other systems.  a A speedup x &gt; 1 means query evaluation is x times faster, x &lt; 1 means slower, x = 1 means no speedup, and ∞ denotes cases where a formerly unfeasible query becomes feasible.</p><formula xml:id="formula_35">P N V L Q 1 131 34.6 ∞ 88.6 Q 2 211 ∞ ∞ 143 Q 3 198 44.8 ∞ 132 Q 4 2.1 ∞ ∞ 1.4 Q 5 198 ∞ ∞ 136 Q 6 171 ∞ ∞ 115 Q 7 346 ∞ ∞ 367 Q 8 1.0 ∞ ∞ 0.7 Q 9 ∞ ∞ ∞ ∞ Q 10 2.2 ∞ ∞ ∞ P N V L Q 11 4.</formula><p>6.4.2 Generated queries over synthetic datasets. Fig. <ref type="figure" target="#fig_6">7</ref> and<ref type="figure" target="#fig_7">8</ref> show the times spent in evaluating recursive queries of the "UniProt" and the "Shop" gMark scenarios <ref type="bibr" target="#b14">[15]</ref>, respectively. No results are reported for system N because it supports none of the randomly generated queries (each one contains at least one form of recursion such as (a/b)+ which is not supported by N). Results show that in the majority of cases, P' outperforms the other systems, either in terms of feasibility or in terms of performance. A few cases clearly illustrate the interest of the rich plan space explored by system P'. For instance with UniProt queries 3, 5, 6, 8, 12, and with Shop queries 2, 5, 6, 8, 9, 10, 13, system P' performs much more efficiently thanks to the selected plan which was not present in the plan space of system P. Some cases also illustrate that there is still room for improvement of the approach, in particular for the cost estimation function in charge of picking the best estimated plan in the search space. This is the case for UniProt query 1 and Shop query 4 for instance, where the plan picked by system P' reveals less efficient than    Overall, experiments suggest that the new plans computed by our approach can offer significant gains in computation time when evaluating recursive queries over graphs. They also suggest that some of the newly computed plans can allow to realize certain query evaluations which used to be unfeasible. This illustrates the benefits of the exploration of richer plan spaces made possible by µ-RA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>We propose a variation of the classical relational algebra extended with a fixpoint operator, which is useful for capturing recursive terms and for facilitating their transformations. We propose new rewriting rules for recursive terms. These new rules are compatible and compositional with existing rules for optimizing the core of the relational algebra. The extended set of optimization rules makes it possible to compute new query execution plans beyond reach with previous approaches. Our approach can be used within any mainstream database management system that implements SQL with recursion, either by adding the new rules inside the query optimizer, or as a preprocessing stage not requiring to modify the system's internals. Experiments with a prototype implementing such a preprocessing phase for the PostgreSQL system suggest that the new query plans can be useful for evaluating much more efficiently recursive queries over graphs. These works open many interesting perspectives for future work, including more precise cardinality estimations for term selection, and the study of further algebraic extensions with aggregation and user-defined functions in particular.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Grammar of µ-RA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Proposition 3 .Example 2 .</head><label>32</label><figDesc>Given a database (R, Γ, D) and φ ∈ F [Γ], if Γ ⊢ φ : t then the relation φ D has type t. Consider again the term of Example 1: µ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>4. 1 . 1</head><label>11</label><figDesc>Pushing filters and anti-join into fixpoints:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Queries for the yago dataset a .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Elapsed time for evaluating queries of Fig. 4 over the yago real-world dataset.</figDesc><graphic coords="15,56.32,201.29,499.34,50.25" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Number of results retrieved (with set semantics) by each query of Fig. 4 on the yago dataset.</figDesc><graphic coords="15,65.06,287.41,481.86,62.18" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Time spent for evaluating recursive queries of the synthetic "UniProt" gMark scenario.</figDesc><graphic coords="15,65.06,385.45,481.86,64.67" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Time spent for evaluating recursive queries of the synthetic "Shop" gMark scenario.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Table 1 presents the sizes of the considered datasets. Dataset Statistics.</figDesc><table><row><cell cols="2">Dataset Origin Predicates</cell><cell>Edges</cell><cell>Nodes</cell></row><row><cell>yago 2.5 (cleaned) [33]</cell><cell cols="3">83 62,643,951 42,832,856</cell></row><row><cell>gMark-Shop [15]</cell><cell>81</cell><cell>209,789</cell><cell>135,737</cell></row><row><cell>gMark-Uniprot [15]</cell><cell>7</cell><cell>76,707</cell><cell>21,130</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>Speedup with P' for yago queries a .</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>terion syntactically, we introduce the notion of derivation, which describes which columns in the result tuples depend on which columns in the initial ones. This then allows us to define the stabilizer of a fixpoint, the set of columns which are untouched during the iteration.4.2.1 Logical framework.Definition 9. The set of derivations d (φ, X ) is:Γ ⊢ |c → v | : c Γ(X ) = t Γ ⊢ X : t Γ ⊢ φ 1 : t Γ ⊢ φ 2 : t Γ ⊢ φ 1 ∪ φ 2 : t Γ ⊢ φ 1 : t 1 Γ ⊢ φ 2 : t 2 Γ ⊢ φ 1 ▷◁ φ 2 : t 1 ∪ t 2 Γ ⊢ φ 1 : t 1 Γ ⊢ φ 2 : _ Γ ⊢ φ 1 ▷ φ 2 : t 1 Γ ⊢ φ : t FC (f) ⊆ t Γ ⊢ σ f (φ) : t Γ ⊢ φ : t a ∈ t b t Γ ⊢ ρ b a (φ) : (t \ {a}) ∪ {b} Γ ⊢ φ : t a ∈ t</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Experiments have been conducted on a server with 128 GB of RAM, 2 Intel Xeon E5-2630 v4 CPUs (2.20 GHz, 20 cores each) and 66 TB of 7200 RPM</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>project <rs type="projectName">CLEAR</rs> (<rs type="grantNumber">ANR-16-CE25-0010</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_yuea8wj">
					<idno type="grant-number">ANR-16-CE25-0010</idno>
					<orgName type="project" subtype="full">CLEAR</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A PROOFS FOR SECTION 3 (THE µ-EXTENDED REL. ALGEBRA)</p><p>Proposition <ref type="bibr" target="#b0">(1)</ref>. If µ (X = φ) is linear, positive and non mutually recursive then the function f (S ) = φ V [X /S ] is such that:</p><p>and thus f has a fixpoint with µ (X = φ) V = f ∞ (∅).</p><p>Proof. We will first prove by induction on the size of terms the following property: given a valid term φ, for all S ∅ we have ∀m ∈ φ V [X /S ] ∃w m ∈ S m ∈ φ V [X / {w m }] .</p><p>• Using lemma 1 the property is clearly true for terms φ such that X is not free in φ. And the only relation variable where X appears free is X . For X the property trivially holds (with w m = m). • For unary operators φ ∈ {ρ b a (φ 1 ), π a (φ 1 ) we have m ∈ φ V [X /S ] implies the existence of m ′ ∈ φ 1 V [X /S ] such that m is the image of m ′ through this operator. By the induction hypothesis, for m ′ there is w such that m ′ ∈ φ 1 V [X / {w m ′ }] and thus m ∈ φ V [X / {w m ′ }] • For a join operator φ = φ 1 ▷◁ φ 2 we have by linearity that φ is constant in X for some i (let us note ī = 3i). If φī is also constant in X then φ is constant in X so we can refer to the first item.</p><p>Otherwise, m ∈ φī V [X /S ] implies the existence of m 1 ∈ φ 1 V [X /S ] and m 2 ∈ φ 2 V [X /S ] such that m = m 1 + m 2 . By induction, there exists w m ī such that mī ∈ φī V [X / {w m ī }] . For i we have</p><p>• For the term φ = φ 1 ▷ φ 2 with any mapping m ∈ φ V [X /S ] is built using at least one mapping m 1 from</p><p>constant in X and thus the result by lemma 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>□</head><p>Lemma <ref type="bibr" target="#b0">(1)</ref>. Let φ be a term.</p><p>• If φ is constant in X , then φ does not depend on X , i.e. for all S and V , φ</p><p>Proof. For the constant part the result is trivial by induction.</p><p>For the recursive part, we also work by induction. It is true for base relations (constants cannot be recursive) but we need to be careful because the subterms of a recursive term can be non-recursive. By the definition of rec this can only happen for φ 1 ▷◁ φ 2 , but one of the φ i has to be recursive and since the join with an empty set leads to an empty set the result holds by induction. □ Proposition <ref type="bibr">(2)</ref>. A fixpoint term µ (X = φ), linear, positive and non mutually recursive can be rewritten to either: an empty term, a term φ with one less fixpoint or a decomposed fixpoint.</p><p>Proof. Given a fixpoint µ (X = φ) we can always decompose φ into a Constant part C and a Recursive part R (possibly empty).</p><p>The idea is to prove by induction on φ that it is true for φ where X is linear, positive and non-mutually recursive:</p><p>• For a join φ 1 ▷◁ φ 2 , let us suppose by symmetry that φ 2 is constant in X ; then φ 1 can be decomposed into R, C and the result is R ▷◁ φ, C ▷◁ φ. • For an antijoin, the same argument as the one for joins works.</p><p>• For unions the results for subterms can be merged.</p><p>• Fixpoints are constant in X by the non mutual recursion hypothesis. □ Proposition (3). Given a database (R, Γ, D) and φ ∈ F [Γ], if Γ ⊢ φ : t then the relation φ D has type t.</p><p>Proof. Let Γ be compatible with V . The property is thus true for relation variables; it is also true for constants and by induction unions, joins, antijoins, filters, duplication or removal of columns. This leaves us with fixpoints.</p><p>Suppose Γ ⊢ µ (X = φ) : t. The empty set of mappings is compatible with t, thus φ V [X /∅] is compatible with t by induction, and thus by further induction we have µ (X = φ) V compatible with t. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B DATALOG &amp; µ-RA EXPRESSIVE POWERS</head><p>In this section we present how to translate various Datalog into µ-RA. The results presented here are not at the heart of our work and most of them are already known in the literature (with very similar statements and with similar proofs, see e.g. <ref type="bibr">[4]</ref> or <ref type="bibr">[2]</ref> regarding Datalog and the while + language). The only novelty of this proof relies in the proof that the linearity of rest-µ-RA actually reduces the expressive power. However to understand why we need to present a translation from Datalog to µ-RA and back. We will therefore not rely on formal proofs but we will build some intuition and provide examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1 Datalog with only one IBD</head><p>We recall in this section that datalog programs can always be transformed to programs that have only one recursive rule and one output rule (this is exercise 14.17 of the alice book <ref type="bibr">[2]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1.1</head><p>Step 1: the n-aryfication. Given a Datalog program P, we can always modify P so that all rules in P are n-ary for some n.</p><p>To do that we simply take n to be the maximal arity over all the rules and extend all the rules with a constant c to match this arity.</p><p>For instance: Path(1,2). Access <ref type="bibr" target="#b0">(1)</ref>. Access(X) :-Access(Y), Path(X,Y) can be made 3-ary in the following way:</p><p>Step 2: one rule datalog. Given a Datalog program P, we can always modify P so that there is only one recursive rule and one "output" rule in P. The idea is to first convert P into a n-ary program P ′ (for some n) then creates a unique n + 1 rules that takes as its first argument the name of the rule. For instance, our running example becomes: <ref type="figure">,</ref><ref type="figure">X,</ref><ref type="figure">c,</ref><ref type="figure">Y,</ref><ref type="figure">c,</ref><ref type="figure">c),</ref><ref type="figure">Rec(path,</ref><ref type="figure">X,</ref><ref type="figure">Y,</ref><ref type="figure">c</ref>). Output(X) :-Rec(access,X,c,c).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 From a derivation rule to µ-RA</head><p>It is a well-known fact that non-recursive datalog and the relational algebra coincide (see e.g. chapter 14 of the alice book <ref type="bibr">[2]</ref>). Given a production head ( Ȳ ) : -body 1 ( X1 ), . . . , body k ( Xk ) we can translate body 1 ( X1 ), . . . , body k ( Xk ) using k -1 joins between each body i , renames to rename arguments of body i , antiprojections to remove existential variables, and filters for constants. Finally we use joins with constants for the constants of the head and renames for the variables.</p><p>For instance, if we translate the Datalog IBD Rec into a term Rec that has 4 columns (a 1 , a 2 , a 3 and a 4 ) the translation of the body Rec(access,X,c,c) :-Rec(access,Y,c,c), Rec(path,X,Y,c).</p><p>)) The whole translation is (using body to denote the above term):</p><p>Given an inflationary-Datalog ¬ program P that, w.l.o.g., has recursive rule Rec and one output rule Output we can translate Rec to a fixpoint of the form µ (Rec = φ 1 ∪ . . . φ k ) where each φ i corresponds to one derivation of the rule Rec. Finally we translate each production of Output into a term ψ (where Rec is replaced by the fixpoint above) and we generate a term that is the union of all these ψ . Given our initial example we have the term O (here we cut the translation to ease the reading):</p><p>The semantics does coincide with inflationary-Datalog ¬ because the formula B 1 ∪B 2 ∪B 3 captures the "immediate consequence" of the Datalog program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.4 From stratified Datalog to µ-RA</head><p>In a stratified Datalog program, each rule can be indexed with an integer n such that a negation of a rule indexed by k can only appear in the production rule of a term indexed with k ′ &gt; k.</p><p>In the case of a stratified Datalog program, merging all the rules into one will break the stratification. The trick here is to operate stratum by stratum and translate the stratum i into a rule Rec i . The resulting program will have one rule per stratum.</p><p>Just like in the inflationary case, each stratum i can be translated into a unique fixpoint µ (X i = φ i ). The production rules of the stratum i can only reference to a Rec j where j ≤ i. We translate Rec i into X i and the Rec j into µ (X j = φ j ). Note that each φ i can contain several occurrences of Rec j with j &lt; i and that makes the translation exponential but all the fixpoints do are non mutually recursive and positive.</p><p>Let us consider the following example (already stratified): Path(...) an EDB Access_1(0). Access_1(X) :-Access_1(Y),Path(Y,X)</p><p>We translate Path into a term µ (X 0 = φ 0 ) (despite the fixpoint φ 0 is actually not recursive as Path is an EDB). Then we translate Access 1 :</p><p>Then we translate Access 2 (using Access 1 to denote the term above) :</p><p>B.5 From linear Datalog to rest-µ-RA Given a linear Datalog program, we can use the stratified translation. In the resulting term each φ i is composed of ψ 1 ∪ . . . ψ k where each of the ψ j corresponds to a linear production rule and thus contains at most one occurrence of X i therefore our µ-RA term is also linear (in addition to be recursive and positive as proved by the stratified translation). All in all, our term does belong to rest-µ-RA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.6 From rest-µ-RA to linear Datalog</head><p>This direction is actually very simple once we know how to translate a term to a Datalog program, we just need to check that the resulting term is actually linear. To translate terms into Datalog, we work bottom-up associating each subterm φ to a Datalog rule. Datalog rules have columns that are indexed (there is a first column, a second, a third, etc.) while µ-RA has column names. To handle this discrepancy, we suppose that we have calculated the type of each term (i.e. we compute a set of column names), then we order column names (any total order on the column names can be used).</p><p>The only difficulty here is the language of filters, in rest-µ-RA we actually impose no restriction on the filter conditions; for the translation we suppose that only the equality is used.</p><p>We thus recursively create production rules for each Datalog predicate s φ ( T ) corresponding the each term φ s φ ( T ) (where T is the ordered set of columns of the type of φ).</p><p>• For φ = φ 1 ▷◁ φ 2 we create a rule for the join: s φ ( T ) ← s 1 ( T1 ), s 2 ( T2 ).</p><p>• For φ = φ 1 ∪ φ 2 we have two production rules, one for each φ i : s φ ( T ) ← s φ i ( Ti ).</p><p>• For φ = φ 1 ▷ φ 2 we create the rule s φ ← s φ 1 ( T1 ), ¬s φ 2 ( T2 ).</p><p>• For φ = σ a=b (φ ′ ) we create the rule s φ ( T1 , b, T2 ) ← s φ ′ ( T1 , b, T2 ) if we suppose that the ordered type of φ ′ is T1 , a, T2</p><p>• For φ = π p (φ ′ ) we create the rule s φ ( Tφ</p><p>where T ′ is Tφ ′ where we inserted a a in the place of where b will be stored.</p><p>Since the rest-µ-RA term is linear we can see that each production rule contain at most one subgoal that is recursive with the head.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C PROOFS FOR SECTION 4 (GENERATING NEW QUERY PLANS)</head><p>Lemma <ref type="bibr">(2)</ref>. Let w be a mapping and φ a term linear, positive and non mutually recursive in X . For all m ∈ φ V [X / {w }] either m ∈ φ V [X /∅] or there exists p ∈ d (φ, X ) such that for all c ∈ dom(w ):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By induction:</head><p>• Since m exists, X can only be free in φ (no |c → v |, no Y X , no fixpoints).</p><p>• For a relation X , the result is clear.</p><p>• For a union we have i such that m ∈ φ i V [X / {w }] and thus the result.</p><p>• For a join φ 1 ▷◁ φ 2 let us suppose by symmetry that φ 1 is not constant in X and that φ 2 is. We have</p><p>For each c ∈ dom(w ) we either have</p><p>Note that m 2 (c) might or might not be defined but if (d 1 (c) ⊥) ∧ (p(c) ∈ dom(w )) then m 1 (c) is also defined and m(c) = m 1 (c). • For an antijoin or a filter the result is clear.</p><p>• For a column rename or removal, the definition of d makes it work. Let us note λ(φ) the term, we have</p><p>of type t and a mapping w of type t, w ∈ µ (X = φ) V if and only if there exists a lineage for w, that is, a finite sequence w 0 , . . . , w n such that:</p><p>, and w n = w.</p><p>Furthermore, for all lineages w 0 , . . . , w n and all c ∈ t ∩ stab (φ, X ), we have for all i, w 0 (c) = w i (c).</p><p>Proof. Let w ∈ µ (X = φ) V and let n minimal such that w ∈ U n (as defined by the semantic). By iterating proposition 1 we find w 0 , . . . , w n = w as expected.</p><p>Conversely if we have such w 0 , . . . , w n = w then clearly w ∈ µ (X = φ) V . Now, by Lemma 2, for each 0 ≤ i ≤ n -1, the mappings w i and w i+1 there is p ∈ d (φ, X ) such that for all c ∈ stab (φ, X ) ∩ t, w i+1 = w i (p(c) = w i (c). By iteration so does w 0 and w. □</p><p>Theorem (1 Pushing filters). Let µ (X = κ ∪ ψ ) be a decomposed fixpoint term, V an environment and f a filter condition with FC (f) ⊆ stab (ψ , X ). Then we have σ</p><p>Let w 0 , . . . , w n be a lineage of w: w passes the filter and by Lemma 3, w has the same values as all the w i on FC (f); therefore w 0 also passes the filter: we have w 0 ∈ σ f (κ) V . Thus w 0 , . . . , w n is also a lineage of</p><p>Conversely, if w ∈ µ (X = σ f (κ) ∪ ψ ) V , let w 0 , . . . , w n be a lineage of w; we have w 0 ∈ σ f (κ) V , thus w 0 passes the filter and by the same argument as above, so must w. □ Theorem (2 Pushing anti-joins). Let µ (X = κ ∪ ψ ) be a decomposed fixpoint term, V an environment and ξ a term of type t ⊆ stab (ψ , X ) (we suppose that X is not a free variable of ξ ). Then we have µ</p><p>Lemma <ref type="bibr">(4)</ref>. Let µ (X = κ ∪ ψ ) ∈ F [Γ] be a decomposed fixpoint of type t, let c ∈ (C \ t ) that can be added to ψ , and w a mapping of type t. We note w (v) = w ∪ {c → v}.</p><p>If ∀R ∈ R, c Γ(R), then we have:</p><p>Proof. We will prove the result ψ w (v ) = ψ ▷◁ |c → v | w inductively on the size of ψ a term recursive in X . Note that when a subformula ξ of ψ is constant in X we have that ξ</p><p>by lemma 1 and we also have that c is not in the type of this ξ (since ∀R, c ΓR and the definition of add forbids to rename a column into c). Note also that subformula that are fixpoints or constants are necessarily constant in X .</p><p>Let us explore the various cases. For the simplicity of proofs, we use ▷◁ and ▷ directly with sets of mappings (e.g.</p><p>• For the formula X , the result is trivial and it is the only base case (constants and other variables cannot be recursive in X ). • For φ 1 ▷◁ φ 2 , one of φ 1 , φ 2 has to be constant, the other recursive. By symmetry, we suppose that φ 1 is recursive and φ 2 constant. We have</p><p>and the last line that uses the commutativity of ▷ over ▷◁ is only true because c cannot be in the type of φ 2 .</p><p>• For σ f (φ ′ ), π a (φ ′ ) and ρ b a (φ) the result comes easily as c {a, b} ∪ FC ( f ). □ Theorem (3 Pushing joins). Let µ (X = κ ∪ ψ ) ∈ F [Γ] be a decomposed fixpoint of type t κ and φ ∈ F [Γ] (with X f ree (φ)) a term of type t φ such that:</p><p>(1)</p><p>Then if we take a lineage w 0 . . . w n of µ (X = κ ∪ ψ ) V and there exists u ∈ φ V compatible with w n then t φ ⊆ stab (ψ , X ) ensures us that u is compatible with all w i .</p><p>Then by iterating Lemma 4, for each i and for each c ∈ t φ \ t κ , we have that w 0 (u), . . . , w n (u) is a valid lineage of µ (X = κ ▷◁ φ ∪ ψ ) V and reciprocally. □ Theorem (4 Merging fixpoints). Given two decomposed fixpoints µ (X = κ 1 ∪ ψ 1 ) and µ (X = κ 2 ∪ ψ 2 ) of types t 1 and t 2 such that:</p><p>(1)</p><p>) ∀c ∈ t 2 \ t 1 add (ψ 1 , X , c) then we have:</p><p>Proof. For i ∈ {1, 2}, let w 0 , . . . , w n i be a lineage of µ (X = κ i ∪ ψ i ) V with w n 1 compatible with w n 2 ; we can easily construct a lineage of size n 1 + n 2 of the form (w 1 0 + w 2 0 ) . . . (w 1 n 1 + w 2 0 ) . . . (w 1 n 1 + w 2 n 2 ) and for the same reason as the last theorem, it holds. Now let us take a lineage w 0 , . . . , w n of µ (X = κ 1 ▷◁ κ 2 ∪ ψ 1 ∪ ψ 2 ) V . We decompose w i into w 1 i + w 2 i where w j i is the restriction of w i to the type of κ j . Those w j i are not necessarily forming a lineage but we consider the subsequence containing w i 0 and for each i &gt; 0 w i j when w j i ∈ ψ i V [X / {w j i -1 }] . Then by the theorem condition when w j i ∈ ψ i V [X / {w j i -1 }] we have w j i = w j i-1 . The two resulting sequences are thus lineages and we have the expected theorem. □ Theorem (5 Pushing antiprojections). Let µ (X = κ ∪ ψ ) ∈ F [Γ] be a decomposed fixpoint of type t κ . Let b ∈ C be such that add (ψ , X , b). Then:</p><p>Proof. This is a conclusion of lemma 4. Let w 0 , . . . , w n be a lineage of µ (X = π c (κ) ∪ ψ ) V there exists v such that w 0 (v) ∈ κ V [X /∅] and if we have w i (v) we can find w i+1 (v) ∈ ψ V [X / {w i (v ) }] by lemma 4. In the end we have a lineage for w (v) ∈ µ (X = κ ∪ ψ ) V and which means w ∈ π c (µ (X = κ ∪ ψ )).</p><p>Notice that lemma 4 gives an equality therefore this is a bijection between lineage and also proves the converse way. □</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">Andrejs</forename><surname>Abele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">P</forename><surname>Mccrae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Buitelaar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anja</forename><surname>Jentzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Cyganiak</surname></persName>
		</author>
		<ptr target="http://lod-cloud.net/" />
		<title level="m">Linking Open Data cloud diagram</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Foundations of Databases: The Logical Level</title>
		<editor>Serge Abiteboul, Richard Hull, and Victor Vianu</editor>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<pubPlace>Boston, MA, USA</pubPlace>
		</imprint>
	</monogr>
	<note>1st ed.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Lorel Query Language for Semistructured Data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Quass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mchugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wiener</surname></persName>
		</author>
		<ptr target="http://ilpubs.stanford.edu:8090/162/" />
	</analytic>
	<monogr>
		<title level="j">Journal on Digital Libraries</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1996">1996. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Datalog Extensions for Database Queries and Updates</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(91)90032-Z</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(91)90032-Z" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="62" to="124" />
			<date type="published" when="1991-08">1991. Aug. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">TASWEET: Optimizing Disjunctive Path Queries in Graph Databases</title>
		<author>
			<persName><forename type="first">Zahid</forename><surname>Abul-Basher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parke</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shadi</forename><surname>Ghajar-Khosravi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">H</forename><surname>Chignell</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2017.47</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2017.47" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Extending Database Technology, EDBT 2017</title>
		<meeting>the 20th International Conference on Extending Database Technology, EDBT 2017<address><addrLine>Venice, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-03-21">2017. March 21-24, 2017</date>
			<biblScope unit="page" from="470" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Linearisability on datalog programs</title>
		<author>
			<persName><forename type="first">Foto</forename><surname>Afrati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Manolis</forename><surname>Gergatsoulis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesca</forename><surname>Toni</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0304-3975(02)00730-2</idno>
		<ptr target="https://doi.org/10.1016/S0304-3975(02)00730-2" />
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">308</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="199" to="226" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Alpha: an extension of relational algebra to express a class of recursive queries</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<idno type="DOI">10.1109/32.42731</idno>
		<ptr target="https://doi.org/10.1109/32.42731" />
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="879" to="885" />
			<date type="published" when="1988-07">1988. July 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Universality of Data Retrieval Languages</title>
		<author>
			<persName><forename type="first">Alfred</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<idno type="DOI">10.1145/567752.567763</idno>
		<ptr target="https://doi.org/10.1145/567752.567763" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages</title>
		<meeting>the 6th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages<address><addrLine>San Antonio, Texas; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="110" to="119" />
		</imprint>
	</monogr>
	<note>POPL &apos;79)</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Representations and Optimizations for Embedded Parallel Dataflow Languages</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Alexandrov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georgi</forename><surname>Krastev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Volker</forename><surname>Markl</surname></persName>
		</author>
		<idno type="DOI">10.1145/3281629</idno>
		<ptr target="https://doi.org/10.1145/3281629" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">44</biblScope>
			<date type="published" when="2019-01">2019. Jan. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Constrained regular expressions for answering RDF-path queries modulo RDFS</title>
		<author>
			<persName><forename type="first">Faisal</forename><surname>Alkhateeb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jérôme</forename><surname>Euzenat</surname></persName>
		</author>
		<idno type="DOI">10.1108/IJWIS-05-2013-0013</idno>
		<ptr target="https://doi.org/10.1108/IJWIS-05-2013-0013" />
	</analytic>
	<monogr>
		<title level="j">IJWIS</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="24" to="50" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">G-CORE: A Core for Future Graph Query Languages</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barcelo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Gutierrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcus</forename><surname>Paradies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oskar</forename><surname>Van Rest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Voigt</surname></persName>
		</author>
		<idno type="DOI">10.1145/3183713.3190654</idno>
		<ptr target="https://doi.org/10.1145/3183713.3190654" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data</title>
		<meeting>the 2018 International Conference on Management of Data<address><addrLine>Houston, TX, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1421" to="1432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName><surname>Anonymous</surname></persName>
		</author>
		<ptr target="https://github.com/asigmod/SIGMOD2020submission48" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note>Full proofs for SIGMOD2020 submission 48</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design and Implementation of the LogicBlox System</title>
		<author>
			<persName><forename type="first">Molham</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Balder Ten Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emir</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">L</forename><surname>Pasalic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Veldhuizen</surname></persName>
		</author>
		<author>
			<persName><surname>Washburn</surname></persName>
		</author>
		<idno type="DOI">10.1145/2723372.2742796</idno>
		<ptr target="https://doi.org/10.1145/2723372.2742796" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2015 ACM SIGMOD International Conference on Management of Data<address><addrLine>Melbourne, Victoria, Australia; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1371" to="1382" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;15)</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Counting Beyond a Yottabyte, or How SPARQL 1.1 Property Paths Will Prevent Adoption of the Standard</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastián</forename><surname>Conca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Pérez</surname></persName>
		</author>
		<idno type="DOI">10.1145/2187836.2187922</idno>
		<ptr target="https://doi.org/10.1145/2187836.2187922" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on World Wide Web (WWW &apos;12)</title>
		<meeting>the 21st International Conference on World Wide Web (WWW &apos;12)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="629" to="638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">gMark: Schema-Driven Generation of Graphs and Queries</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radu</forename><surname>Ciucanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aurélien</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicky</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><surname>Advokaat</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2016.2633993</idno>
		<ptr target="https://doi.org/10.1109/TKDE.2016.2633993" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="856" to="869" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radu</forename><surname>Ciucanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aurélien</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicky</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><surname>Advokaat</surname></persName>
		</author>
		<ptr target="https://github.com/graphMark/gmark" />
		<title level="m">gMark: a domain and query language independent framework</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Magic Sets and Other Strange Ways to Implement Logic Programs (Extended Abstract)</title>
		<author>
			<persName><forename type="first">Francois</forename><surname>Bancilhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehoshua</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<idno type="DOI">10.1145/6012.15399</idno>
		<ptr target="https://doi.org/10.1145/6012.15399" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems</title>
		<meeting>the Fifth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems<address><addrLine>Cambridge, Massachusetts, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
	<note>) (PODS &apos;86)</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An amateur&apos;s introduction to recursive query processing strategies</title>
		<author>
			<persName><forename type="first">Francois</forename><surname>Bancilhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Readings in Artificial Intelligence and Databases</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="376" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Graph Logics with Rational Relations and the Generalized Intersection Problem</title>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barcelo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Figueira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS.2012.23</idno>
		<ptr target="https://doi.org/10.1109/LICS.2012.23" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 27th Annual IEEE/ACM Symposium on Logic in Computer Science</title>
		<meeting>the 2012 27th Annual IEEE/ACM Symposium on Logic in Computer Science<address><addrLine>New Orleans, Louisiana; Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="115" to="124" />
		</imprint>
	</monogr>
	<note>LICS &apos;12)</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Expressive Languages for Path Queries over Graph-Structured Data</title>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><forename type="middle">W</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1145/2389241.2389250</idno>
		<ptr target="https://doi.org/10.1145/2389241.2389250" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">46</biblScope>
			<date type="published" when="2012-12">2012. Dec. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Querying Graphs</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
			<publisher>Morgan and Claypool publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An Analytical Study of Large SPARQL Query Logs</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Timm</surname></persName>
		</author>
		<idno type="DOI">10.14778/3149193.3149196</idno>
		<ptr target="https://doi.org/10.14778/3149193.3149196" />
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="161" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A Query Language and Optimization Techniques for Unstructured Data</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerd</forename><surname>Hillebrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1145/235968.233368</idno>
		<ptr target="https://doi.org/10.1145/235968.233368" />
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="505" to="516" />
			<date type="published" when="1996-06">1996. June 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Programming Primitives for Database Languages</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ashok</surname></persName>
		</author>
		<author>
			<persName><surname>Chandra</surname></persName>
		</author>
		<idno type="DOI">10.1145/567532.567537</idno>
		<ptr target="https://doi.org/10.1145/567532.567537" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 8th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages<address><addrLine>Williamsburg, Virginia; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="50" to="62" />
		</imprint>
	</monogr>
	<note>POPL &apos;81)</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A relational model of data for large shared data banks</title>
		<author>
			<persName><surname>Edgar F Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="377" to="387" />
			<date type="published" when="1970">1970. 1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">GraphLog: A Visual Formalism for Real Life Recursion</title>
		<author>
			<persName><forename type="first">Mariano</forename><forename type="middle">P</forename><surname>Consens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<idno type="DOI">10.1145/298514.298591</idno>
		<ptr target="https://doi.org/10.1145/298514.298591" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</title>
		<meeting>the Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems<address><addrLine>Nashville, Tennessee, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="404" to="416" />
		</imprint>
	</monogr>
	<note>) (PODS &apos;90)</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Graphical Query Language Supporting Recursion</title>
		<author>
			<persName><forename type="first">Isabel</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1145/38713.38749</idno>
		<ptr target="https://doi.org/10.1145/38713.38749" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 1987 ACM SIGMOD International Conference on Management of Data<address><addrLine>San Francisco, California, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;87)</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<ptr target="http://www.dlvsystem.com/dlv/" />
		<title level="m">The DLV deductive database system</title>
		<imprint>
			<publisher>DLV Systems</publisher>
			<date type="published" when="2012-10">2012. october 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Recursive query plans for data integration</title>
		<author>
			<persName><surname>Oliver M Duschka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon Y</forename><surname>Michael R Genesereth</surname></persName>
		</author>
		<author>
			<persName><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="73" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Virtuoso, a Hybrid RDBMS/Graph Column Store</title>
		<author>
			<persName><forename type="first">Orri</forename><surname>Erling</surname></persName>
		</author>
		<ptr target="http://sites.computer.org/debull/A12mar/vicol.pdf" />
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="8" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Optimizing regular path expressions using graph schemas</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.1998.655753</idno>
		<ptr target="https://doi.org/10.1109/ICDE.1998.655753" />
	</analytic>
	<monogr>
		<title level="m">Proceedings 14th International Conference on Data Engineering</title>
		<meeting>14th International Conference on Data Engineering</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Database Techniques for the World-Wide Web: A Survey</title>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Mendelzon</surname></persName>
		</author>
		<idno type="DOI">10.1145/290593.290605</idno>
		<ptr target="https://doi.org/10.1145/290593.290605" />
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="59" to="74" />
			<date type="published" when="1998-09">1998. Sept. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<ptr target="https://www.mpi-inf.mpg.de/yago-naga/yago/" />
		<title level="m">YAGO: A high-quality knowledge base</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
		<respStmt>
			<orgName>Max Planck Institute for Informatics and Telecom ParisTech University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Cypher: An Evolving Query Language for Property Graphs</title>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Rydberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrés</forename><surname>Taylor</surname></persName>
		</author>
		<idno type="DOI">10.1145/3183713.3190657</idno>
		<ptr target="https://doi.org/10.1145/3183713.3190657" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data</title>
		<meeting>the 2018 International Conference on Management of Data<address><addrLine>Houston, TX, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1433" to="1445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Cypher: An Evolving Query Language for Property Graphs</title>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Rydberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrés</forename><surname>Taylor</surname></persName>
		</author>
		<idno type="DOI">10.1145/3183713.3190657</idno>
		<ptr target="https://doi.org/10.1145/3183713.3190657" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Conference on Management of Data</title>
		<meeting>the 2018 International Conference on Management of Data<address><addrLine>Houston, TX, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1433" to="1445" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;18)</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Evaluation of Database Recursive Logic Programs As Recurrent Function Series</title>
		<author>
			<persName><forename type="first">Georges</forename><surname>Gardarin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christophe</forename><surname>De Maindreville</surname></persName>
		</author>
		<idno type="DOI">10.1145/16894.16872</idno>
		<ptr target="https://doi.org/10.1145/16894.16872" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data (SIGMOD &apos;86)</title>
		<meeting>the 1986 ACM SIGMOD International Conference on Management of Data (SIGMOD &apos;86)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="177" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Volcano -An Extensible and Parallel Query Evaluation System</title>
		<author>
			<persName><forename type="first">Goetz</forename><surname>Graefe</surname></persName>
		</author>
		<idno type="DOI">10.1109/69.273032</idno>
		<ptr target="https://doi.org/10.1109/69.273032" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="120" to="135" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The Cascades Framework for Query Optimization</title>
		<author>
			<persName><forename type="first">Goetz</forename><surname>Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Engineering Bulletin</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The Volcano Optimizer Generator: Extensibility and Efficient Search</title>
		<author>
			<persName><forename type="first">Goetz</forename><surname>Graefe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">J</forename><surname>Mckenna</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=645478.757691" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Conference on Data Engineering</title>
		<meeting>the Ninth International Conference on Data Engineering<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">openCypher: New Directions in Property Graph Querying</title>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Junghanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Max</forename><surname>Kießling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2018.62</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2018.62" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21th International Conference on Extending Database Technology, EDBT 2018</title>
		<meeting>the 21th International Conference on Extending Database Technology, EDBT 2018<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-03-26">2018. March 26-29, 2018</date>
			<biblScope unit="page" from="520" to="523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Sparqling Kleene: Fast Property Paths in RDF-3X</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srikanta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Bedathur</surname></persName>
		</author>
		<author>
			<persName><surname>Seufert</surname></persName>
		</author>
		<idno type="DOI">10.1145/2484425.2484443</idno>
		<ptr target="https://doi.org/10.1145/2484425.2484443" />
	</analytic>
	<monogr>
		<title level="m">First International Workshop on Graph Data Management Experiences and Systems</title>
		<meeting><address><addrLine>New York, New York; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
	<note>GRADES &apos;13. Article 14</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Selectivity and Cost Estimation for Joins Based on Random Sampling</title>
		<author>
			<persName><forename type="first">J</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">F</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arun</forename><forename type="middle">N</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName><surname>Swami</surname></persName>
		</author>
		<idno type="DOI">10.1006/jcss.1996.0041</idno>
		<ptr target="https://doi.org/10.1006/jcss.1996.0041" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="550" to="569" />
			<date type="published" when="1996-06">1996. June 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName><forename type="first">Steve</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Seaborne</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/sparql11-query/" />
		<title level="m">SPARQL 1.1 Query Language, W3C Recommendation</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">SPARQL with property paths on the Web</title>
		<author>
			<persName><forename type="first">Olaf</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>Pirrò</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-160237</idno>
		<ptr target="https://doi.org/10.3233/SW-160237" />
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="773" to="795" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Algebraic optimization of recursive queries</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter Mg Apers</forename><surname>Houtsma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data &amp; Knowledge Engineering</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="325" />
			<date type="published" when="1992">1992. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">On Compile-time Query Optimization in Deductive Databases by Means of Static Filtering</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Eliezer</surname></persName>
		</author>
		<author>
			<persName><surname>Lozinskii</surname></persName>
		</author>
		<idno type="DOI">10.1145/88636.87121</idno>
		<ptr target="https://doi.org/10.1145/88636.87121" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="426" />
			<date type="published" when="1990-09">1990. Sept. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Iterative Dynamic Programming: A New Class of Query Optimization Algorithms</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Kossmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konrad</forename><surname>Stocker</surname></persName>
		</author>
		<idno type="DOI">10.1145/352958.352982</idno>
		<ptr target="https://doi.org/10.1145/352958.352982" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="43" to="82" />
			<date type="published" when="2000-03">2000. March 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Results on the Propositional mu-Calculus</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(82)90125-6</idno>
		<ptr target="https://doi.org/10.1016/0304-3975(82)90125-6" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="333" to="354" />
			<date type="published" when="1983">1983. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The DLV System for Knowledge Representation and Reasoning</title>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Pfeifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Faber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simona</forename><surname>Perri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Scarcello</surname></persName>
		</author>
		<idno type="DOI">10.1145/1149114.1149117</idno>
		<ptr target="https://doi.org/10.1145/1149114.1149117" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Logic</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="499" to="562" />
			<date type="published" when="2006-07">2006. July 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Querying Graphs with Data</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoč</surname></persName>
		</author>
		<idno type="DOI">10.1145/2850413</idno>
		<ptr target="https://doi.org/10.1145/2850413" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">53</biblScope>
			<date type="published" when="2016-03">2016. March 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">A co-relational model of data for large shared data banks</title>
		<author>
			<persName><forename type="first">Erik</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gavin</forename><forename type="middle">M</forename><surname>Bierman</surname></persName>
		</author>
		<idno type="DOI">10.1145/1924421.1924436</idno>
		<ptr target="https://doi.org/10.1145/1924421.1924436" />
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="49" to="58" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Finding Regular Simple Paths in Graph Databases</title>
		<author>
			<persName><forename type="first">Alberto</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1137/S009753979122370X</idno>
		<ptr target="https://doi.org/10.1137/S009753979122370X" />
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1235" to="1258" />
			<date type="published" when="1995-12">1995. Dec. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Efficient Evaluation of Right-, Left-, and Multi-linear Rules</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<idno type="DOI">10.1145/67544.66948</idno>
		<ptr target="https://doi.org/10.1145/67544.66948" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1989 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 1989 ACM SIGMOD International Conference on Management of Data<address><addrLine>Portland, Oregon, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="235" to="242" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;89)</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Estimating the Evaluation Cost of Regular Path Queries on Large Graphs</title>
		<author>
			<persName><forename type="first">Van-Quyet</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyungbaek</forename><surname>Kim</surname></persName>
		</author>
		<idno type="DOI">10.1145/3155133.3155160</idno>
		<ptr target="https://doi.org/10.1145/3155133.3155160" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth International Symposium on Information and Communication Technology</title>
		<meeting>the Eighth International Symposium on Information and Communication Technology<address><addrLine>Nha Trang City, Viet Nam; SoICT; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017. 2017</date>
			<biblScope unit="page" from="92" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<author>
			<persName><surname>Online</surname></persName>
		</author>
		<ptr target="http://www.postgresql.org" />
		<title level="m">The PostgreSQL system</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">D</forename><surname>Ramsdell</surname></persName>
		</author>
		<ptr target="http://www.ccs.neu.edu/home/ramsdell/tools/datalog/datalog.html" />
		<title level="m">Datalog version 2.2, a lightweight deductive database system</title>
		<imprint>
			<date type="published" when="2004-10">2004. october 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">On the Implementation of a Simple Class of Logic Queries for Databases</title>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Saccà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
		<idno type="DOI">10.1145/6012.6013</idno>
		<ptr target="https://doi.org/10.1145/6012.6013" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems</title>
		<meeting>the Fifth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems<address><addrLine>Cambridge, Massachusetts, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="16" to="23" />
		</imprint>
	</monogr>
	<note>) (PODS &apos;86)</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Foundations of SPARQL Query Optimization</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Lausen</surname></persName>
		</author>
		<idno type="DOI">10.1145/1804669.1804675</idno>
		<ptr target="https://doi.org/10.1145/1804669.1804675" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Database Theory (ICDT &apos;10)</title>
		<meeting>the 13th International Conference on Database Theory (ICDT &apos;10)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="4" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Access Path Selection in a Relational Database Management System</title>
		<author>
			<persName><forename type="first">Patricia</forename><forename type="middle">G</forename><surname>Selinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Morton</forename><forename type="middle">M</forename><surname>Astrahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><forename type="middle">D</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raymond</forename><forename type="middle">A</forename><surname>Lorie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">G</forename><surname>Price</surname></persName>
		</author>
		<idno type="DOI">10.1145/582095.582099</idno>
		<ptr target="https://doi.org/10.1145/582095.582099" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1979 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 1979 ACM SIGMOD International Conference on Management of Data<address><addrLine>Boston, Massachusetts, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1979-05-30">1979. May 30 -June 1. 23-34</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Big Data Analytics with Datalog Queries on Spark</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Shkapsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohan</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matteo</forename><surname>Interlandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hsuan</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tyson</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2915229</idno>
		<ptr target="https://doi.org/10.1145/2882903.2915229" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data (SIGMOD &apos;16)</title>
		<meeting>the 2016 International Conference on Management of Data (SIGMOD &apos;16)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1135" to="1149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Genetic Programming in Database Query Optimization</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stillger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Myra</forename><surname>Spiliopoulou</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=1595536.1595591" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st Annual Conference on Genetic Programming</title>
		<meeting>the 1st Annual Conference on Genetic Programming<address><addrLine>Stanford, California; Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="388" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">The implementation of POSTGRES</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lawrence</forename><forename type="middle">A</forename><surname>Rowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Hirohama</surname></persName>
		</author>
		<idno type="DOI">10.1145/3226595.3226639</idno>
		<ptr target="https://doi.org/10.1145/3226595.3226639" />
	</analytic>
	<monogr>
		<title level="m">Making Databases Work: the Pragmatic Wisdom of Michael Stonebraker</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="519" to="559" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Yago: a core of semantic knowledge</title>
		<author>
			<persName><forename type="first">Fabian</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gjergji</forename><surname>Kasneci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
		<idno type="DOI">10.1145/1242572.1242667</idno>
		<ptr target="https://doi.org/10.1145/1242572.1242667" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on World Wide Web, WWW 2007</title>
		<meeting>the 16th International Conference on World Wide Web, WWW 2007<address><addrLine>Banff, Alberta, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05-08">2007. May 8-12, 2007</date>
			<biblScope unit="page" from="697" to="706" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">More efficient datalog queries: subsumptive tabling beats magic sets</title>
		<author>
			<persName><forename type="first">Tekle</forename><surname>Tuncay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanhong</forename><forename type="middle">A</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 ACM SIGMOD International Conference on Management of data</title>
		<meeting>the 2011 ACM SIGMOD International Conference on Management of data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="661" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Principles of Database and Knowledge-base Systems</title>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Computer Science Press, Inc</publisher>
			<biblScope unit="volume">I</biblScope>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Column-Oriented Datalog Materialization for Large Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Ceriel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="258" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">VLog: A Column-Oriented Datalog System for Large Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Ceriel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><surname>Krötzsch</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-1690/paper113.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ISWC 2016 Posters &amp; Demonstrations Track co-located with 15th International Semantic Web Conference (ISWC 2016)</title>
		<meeting>the ISWC 2016 Posters &amp; Demonstrations Track co-located with 15th International Semantic Web Conference (ISWC 2016)<address><addrLine>Kobe, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-10-19">2016. October 19, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title level="m" type="main">Evaluation of SPARQL property paths via recursive SQL</title>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<author>
			<persName><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><surname>Gryz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-01">2013. 01 2013</date>
			<biblScope unit="page">1087</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">WAVEGUIDE: Evaluating SPARQL Property Path Queries</title>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parke</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jarek</forename><surname>Gryz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="525" to="528" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Query Planning for Evaluating SPARQL Property Paths</title>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parke</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jarek</forename><surname>Gryz</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2882944</idno>
		<ptr target="https://doi.org/10.1145/2882903.2882944" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data</title>
		<meeting>the 2016 International Conference on Management of Data<address><addrLine>San Francisco, California, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1875" to="1889" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;16)</note>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Foundations of Databases: The Logical Level</title>
		<editor>Serge Abiteboul, Richard Hull, and Victor Vianu</editor>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<pubPlace>Boston, MA, USA</pubPlace>
		</imprint>
	</monogr>
	<note>1st edition</note>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Datalog extensions for database queries and updates</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="62" to="124" />
			<date type="published" when="1991-08">August 1991</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
