<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Evaluation Artifact Reproducible Energy Büchi Problems</title>
				<funder ref="#_UyKHbW8 #_h8JNGk4">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2022-12-22">22 Dec 2022</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sven</forename><surname>Dziadek</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">EPITA Research Laboratory (LRE)</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">EPITA Research Laboratory (LRE)</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Philipp</forename><surname>Schlehuber-Caissier</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">EPITA Research Laboratory (LRE)</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Evaluation Artifact Reproducible Energy Büchi Problems</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2022-12-22">22 Dec 2022</date>
						</imprint>
					</monogr>
					<idno type="MD5">7F05157B82E3B5E76103A8B4E87451EC</idno>
					<idno type="DOI">10.1007/978-</idno>
					<idno type="arXiv">arXiv:2205.04392v2[cs.LO]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>weighted timed automaton</term>
					<term>weighted automaton</term>
					<term>energy problem</term>
					<term>generalized Büchi acceptance</term>
					<term>energy constraints</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show how to efficiently solve energy Büchi problems in finite weighted automata and in one-clock weighted timed automata. Solving the former problem is our main contribution and is handled by a modified version of Bellman-Ford interleaved with Couvreur's algorithm. The latter problem is handled via a reduction to the former relying on the corner-point abstraction. All our algorithms are freely available and implemented in a tool based on the open-source platforms TChecker and Spot.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Energy problems in weighted (timed) automata pose the question whether there exist infinite runs in which the accumulated weights always stay positive. Since their introduction in <ref type="bibr" target="#b6">[7]</ref>, much research has gone into different variants of these problems, for example energy games <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b26">27]</ref>, energy parity games <ref type="bibr" target="#b10">[11]</ref>, robust energy problems <ref type="bibr" target="#b1">[2]</ref>, etc., and into their application in embedded systems <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref>, satellite control <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b24">25]</ref>, and other areas. Nevertheless, many basic questions remain open and implementations are somewhat lacking.</p><p>The above results discuss looping automata <ref type="bibr" target="#b27">[28]</ref>, i.e., ω-automata in which all states are accepting. In practice, looping automata do not suffice because they cannot express all liveness properties. For model checking, formal properties (e.g., in LTL) are commonly translated into (generalized) Büchi automata <ref type="bibr" target="#b8">[9]</ref> that provide a simple model for the larger class of ω-regular languages.</p><p>In this work, we extend energy problems with transition-based generalized Büchi conditions and treat them for weighted automata as well as weighted timed automata with precisely one clock. On weighted automata we show that they are effectively decidable using a combination of a modified Bellman-Ford algorithm with Couvreur's algorithm. For weighted timed automata we show that one can use the corner-point abstraction to translate the problem to weighted (untimed) automata.</p><p>For looping automata, the above problems have been solved in <ref type="bibr" target="#b6">[7]</ref>. (This paper also treats energy games and so-called universal energy problems, both of which are of no concern to us here.) While we can re-use some of the methods of <ref type="bibr" target="#b6">[7]</ref> for our Büchi-enriched case, our extension is by no means trivial. First, in the setting of <ref type="bibr" target="#b6">[7]</ref> it suffices to find any reachable and energy positive loop; now, our algorithm must consider that such loops might not be accepting in themselves but give access to new parts of the automaton which are. Secondly, <ref type="bibr" target="#b6">[7]</ref> mostly treat the energy problem with unlimited upper bound, whereas we consider that energy has a ("weak") upper bound beyond which it cannot increase. <ref type="bibr" target="#b6">[7]</ref> claim that the weak-upper-bound problem can be solved by slight modifications to their solution of the unbounded problem; but this is not the case. For example, the typical Bellman-Ford detection of positive cycles might not work when the energy levels attained in the previous step are already equal to the upper bound. As a second contribution, we have implemented all of our algorithms in a tool based on the open-source platforms TChecker 1 <ref type="bibr" target="#b21">[22]</ref> and Spot 2 <ref type="bibr" target="#b12">[13]</ref> to solve generalized energy Büchi problems for one-clock weighted timed automata. We first employ TChecker to compute the zone graph and then use this to construct the corner-point abstraction. This in turn is a weighted (untimed) generalized Büchi automaton, in which we also may apply a variant of Alur and Dill's Zeno-exclusion technique <ref type="bibr" target="#b0">[1]</ref>. Finally, our main algorithm to solve generalized energy Büchi problems on weighted finite automata is implemented using a fork of Spot. Our software is available at https://github.com/PhilippSchlehuberCaissier/wspot.</p><p>In our approach to solve the latter problem, we do not fully separate the energy and Büchi conditions (contrary to, for example, <ref type="bibr" target="#b10">[11]</ref> who reduce energy parity games to energy games). We first determine the strongly connected components (SCCs) of the unweighted automaton. Then we degeneralize each Büchi accepting SCC one by one, using the standard counting construction <ref type="bibr" target="#b19">[20]</ref>. Finally, we apply a modified Bellman-Ford algorithm to search for energy feasible lassos that start on the main graph and loop in the SCC traversing the remaining Büchi condition.</p><p>Running example 1. To clarify notation and put the concepts into context, we introduce a small running example. A satellite in low-earth orbit has a rotation time of about 90 minutes, 40% of which are spent in earth shadow. Measuring time in minutes and (electrical) energy in unspecified "energy units", we may thus model its simplified base electrical system as shown in Fig. <ref type="figure" target="#fig_0">1a</ref>.</p><formula xml:id="formula_0">x ≤ 35 -10 x ≤ 55 +40 x = 35 x ← 0 x = 55 x ← 0 x ≤ 5 -20 x ← 0 x = 5 •</formula><p>Fig. <ref type="figure">2</ref>: Weighted timed automaton A 1 for satellite with work module. This is a weighted timed automaton (the formalism will be introduced in Sect. 3) with one clock, x, and two locations. The clock is used to model time, which progresses with a constant rate but can be reset on transitions. The initial location on the left (modeling earth shadow) is only active as long as x ≤ 35, and given that x is initially zero, this means that the model may stay here for at most 35 minutes. Staying in this location consumes 10 energy units per minute, corresponding to the satellite's base consumption.</p><p>After 35 minutes the model transitions to the "sun" location on the right, where it can stay for at most 55 minutes and the solar panels produce 50 energy units per minute, from which the base consumption has to be subtracted. Note that the transitions can only be taken if the clock shows exactly 35 (resp. 55) minutes; the clock is reset to zero after the transition, as denoted by x ← 0. This ensures that the satellite stays exactly 35 minutes in the shadow and 55 minutes in the sun, roughly consistent with the "physical" model.</p><p>Figure <ref type="figure" target="#fig_0">1b</ref> shows a translation of the automaton of Fig. <ref type="figure" target="#fig_0">1a</ref> to a weighted untimed automaton. State 1 corresponds to the "shadow" location, transitions are annotated with the corresponding weights, the rate of the location multiplied by the time spent in it. In Sect. 3 we will show how to obtain a weighted automaton from a weighted timed automaton with precisely one clock.</p><p>One may now pose the following question: for a given battery capacity b and an initial charge c, is it possible for the satellite to function indefinitely without ever running out of energy? It is clear that for c &lt; 350 or b &lt; 350, the answer is no: the satellite will run out of battery before ever leaving Earth's shadow; for b ≥ 350 and c ≥ 350, it will indeed never run out of energy. Now assume that the satellite also has some work to do: once in a while it must, for example, send some collected data to earth. Given that we can only handle weighted automata with precisely one clock (see Sect. 3), we model the combined system as in Fig. <ref type="figure">2</ref>. That is, work (modeled by the leftmost location) takes 5 minutes and costs an extra 10 energy units per minute. The dot on the outgoing transition of the work state marks a (transition-based) Büchi condition which forces us to see the transition infinitely often in order for the run to be accepted. As a consequence, all accepting runs also visit the "work" state indefinitely often, consistent with the demand to send data once in a while. In order to model the system within the constraints of our modeling formalism, we must make two simplifying assumptions, both unrealistic but conservative:</p><p>work occurs during earth shadow; work prolongs earth shadow time.</p><p>The reason for the second property is that the clock x is reset to 0 when entering the work state; otherwise we would not be able to model that it lasts 5 minutes without introducing a second clock. It is clear how further work modules may be added in a similar way, each with their own accepting color.</p><p>We will come back to this example later and, in particular, argue that the above assumptions are indeed conservative in the sense that any behavior admitted in our model is also present in a more realistic model which we will introduce.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Energy Büchi Problems in Finite Weighted Automata</head><p>We now define energy Büchi problems in finite weighted automata and show how they may be solved. The similar setting for weighted timed automata will be introduced in Sect. 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (WBA).</head><p>A weighted (transition-based, generalized) Büchi automaton (WBA) is a structure A = (M, S, s 0 , T ) consisting of a finite set of colors M, a set of states S with initial state s 0 ∈ S, and a set of transitions</p><formula xml:id="formula_1">T ⊆ S × 2 M × R × S.</formula><p>A transition t = (s, M, w, s ) ∈ T in a WBA is thus annotated by a set of colors M and a real weight w, denoted by s w -→ M s ; to save ink, we may omit any or all of w and M from transitions and M from WBAs. The automaton A is finite if S and T ⊆ S × 2 M × Z × S are finite (thus finite implies integer-weighted).</p><p>A run in a WBA is a finite or infinite sequence ρ = s 1 → s 2 → • • • . We write first(ρ) = s 1 for its starting state and, if ρ is finite, last(ρ) for its final state. Concatenation ρ 1 ρ 2 of runs is the usual partial operation defined if ρ 1 is finite and last(ρ 1 ) = first(ρ 2 ). Also iteration ρ n of finite runs is defined as usual, for first(ρ) = last(ρ), and ρ ω = inj lim n→∞ ρ n denotes infinite iteration. A run ρ as above is said to be (c, b)-feasible if weights c↓b (ρ) i ≥ 0 for all indices i, that is, the accumulated weights of all prefixes are non-negative. (This is the case for the example run above.)</p><formula xml:id="formula_2">An infinite run ρ = s 1 → M1 s 2 → M2 • • • is Büchi accepted if all colors in M</formula><p>are seen infinitely often along ρ, that is, for all m ∈ M and any index i ∈ N, there exists j &gt; i such that m ∈ M j .</p><p>We fix a weak upper bound b ∈ N for the rest of the paper and write c-feasible instead of (c, b)-feasible.</p><p>Definition 2. The energy Büchi problem for a finite WBA A and initial credit c ∈ N is to ask whether there exists a Büchi accepted c-feasible run in A.</p><p>Energy problems for finite weighted automata without Büchi conditions, asking for the existence of any c-feasible run, have been introduced in <ref type="bibr" target="#b6">[7]</ref> and extended to multiple weight dimensions in <ref type="bibr" target="#b15">[16]</ref> where they are related to vector addition systems and Petri nets. We extend them to (transition-based generalized) Büchi conditions here but do not consider an extension to multiple weight dimensions.</p><p>Degeneralization As a first step to solving energy problems for finite WBAs, we show that the standard counting construction which transforms generalized Büchi automata into simple Büchi automata with only one color, see for example <ref type="bibr" target="#b19">[20]</ref>, also applies in our weighted setting. To see that, let A = (M, S, s 0 , T ) be a (generalized) WBA, write M = {m 1 , . . . , m k }, and define another WBA Ā = ( M, S, s0 , T ) as follows:</p><formula xml:id="formula_3">M = {m a } S = S × {1, . . . , k} s0 = (s 0 , 1) T = ((s, i), ∅, w, (s , i)) (s, M, w, s ) ∈ T, m i / ∈ M ∪ ((s, i), ∅, w, (s , i + 1)) i = k, (s, M, w, s ) ∈ T, m i ∈ M ∪ ((s, k), {m a }, w, (s , 1)) (s, M, w, s ) ∈ T, m k ∈ M</formula><p>That is, we split the states of A into levels {1, . . . , k}. At level i, the same transitions exist as in A, except those colored with m i ; seeing such a transition puts us into level i + 1, or 1 if i = k. In the latter case, the transition in Ā is colored by its only color m a . Intuitively, this preserves the language as we are sure that all colors of the original automaton A have been seen:</p><p>Lemma 3. For any c ∈ N, A admits a Büchi accepted c-feasible run iff Ā does.</p><p>Reduction to lassos An infinite run ρ in A is a lasso if ρ = γ 1 γ ω 2 for finite runs γ 1 and γ 2 . The following lemma shows that it suffices to search for lassos in order to solve energy Büchi problems. Lemma 4. For any c ∈ N, A admits a Büchi accepted c-feasible infinite run iff it admits a Büchi accepted c-feasible lasso.</p><p>Hence our energy Büchi problem may be solved by searching for Büchi accepted c-feasible lassos. We detail how to do this in Sect. 4, here we just sum up the complexity result which we prove at the end of Sect. 4.</p><p>Theorem 5. Energy Büchi problems for finite WBA are decidable in polynomial time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Energy Büchi Problems for Weighted Timed Automata</head><p>We now extend our setting to weighted timed automata. Let X be a finite set of clocks. We denote by Φ(X) the set of clock constraints ϕ on X, defined by the grammar ϕ :</p><formula xml:id="formula_4">:= x k | ϕ 1 ∧ ϕ 2 with x ∈ X, k ∈ N, and ∈ {≤, &lt;, ≥, &gt;, =}. A clock valuation on X is a function v : X → R ≥0 .</formula><p>The clock valuation v 0 is given by v 0 (x) = 0 for all x ∈ X, and for v :</p><formula xml:id="formula_5">X → R ≥0 , d ∈ R ≥0 , and R : X → (N ∪ {⊥}), we define the delay v + d and reset v[R] by (v + d)(x) = v(x) + d, v[R](x) = v(x) if R(x) = ⊥, R(x) otherwise.</formula><p>Note that in v[R] we allow clocks to be reset to arbitrary non-negative integers instead of only 0 which is assumed in most of the literature. It is known <ref type="bibr" target="#b23">[24]</ref> that this does not change expressivity, but it adds notational convenience. A clock valuation v satisfies clock constraint ϕ, denoted v |= ϕ, if ϕ evaluates to true with x replaced by v(x) for all x ∈ X.</p><p>Definition 6 (WTBA). A weighted timed (transition-based, generalized) Büchi automaton (WTBA) is a structure A = (M, Q, q 0 , X, I, E, r) consisting of a finite set of colors M, a finite set of locations Q with initial location q 0 ∈ Q, a finite set of clocks X, location invariants</p><formula xml:id="formula_6">I : Q → Φ(X), a finite set of edges E ⊆ Q × 2 M × Φ(X) × (N ∪ {⊥}) X × Q, and location weight-rates r : Q → Z.</formula><p>As before, we may omit M from the signature and colors from edges if they are not necessary in the context. Note that the edges carry no weights here, which would correspond to discrete weight updates. In a WTBA, only locations are weighted by a rate. Even without Büchi conditions, the approach laid out here would not work for weighted edges. This was already noted in <ref type="bibr" target="#b6">[7]</ref>; instead it requires different methods which are developed in <ref type="bibr" target="#b5">[6]</ref> (see also <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>). There, one-clock weighted timed automata (with edge weights) are translated to finite automata weighted with so-called energy functions instead of integers. We believe that our extension to Büchi conditions should also work in this extended setting, but leave the details to future work.</p><p>The semantics of a WTBA A as above is the (infinite) WBA A = (M, S, s 0 , T )</p><p>given by</p><formula xml:id="formula_7">S = {(q, v) ∈ Q × R X ≥0 v |= I(q)</formula><p>} and s 0 = (q 0 , v 0 ). Transitions in T are of the following two types:</p><formula xml:id="formula_8">-delays (q, v) w -→ d ∅ (q, v +d) for all (q, v) ∈ S and d ∈ R ≥0 for which v +d |= I(q) for all d ∈ [0, d], with w = r(q)d; 4 -switches (q, v) 0 -→ 0 M (q , v ) for all e = (q, M, g, R, q ) ∈ E for which v |= g, v = v[R] and v |= I(q ). 0 y ≤ 5 -10 y ← 0 y = 5 • (a) x ≤ 35 -10 x ≤ 55 +40 x = 35 x ← 0 x = 55 x ← 0 x ≤ 35 ∧ y ≤ 5 -20 x ≤ 55 ∧ y ≤ 5 +30 x = 35 x ← 0 x = 55 x ← 0 y ← 0 y = 5 • y ← 0 y = 5 • (b) Fig. 3: Satellite example. (a) work module W ; (b) product B 1 = A W</formula><p>Each state in A corresponds to a tuple containing a location in A and a clock valuation X → R ≥0 . This allows to keep track of the discrete state as well as the evolution of the clocks. By abuse of notation, we will sometimes write (q, v) ∈ A instead of (q, v) ∈ S, for S as defined above.</p><p>We may now pose energy Büchi problems also for WTBAs, but we wish to exclude infinite runs in which time is bounded, so-called Zeno runs. Formally an infinite run (q 0 , v 0 )</p><formula xml:id="formula_9">→ d1 (q 1 , v 1 ) → d2 • • • is Zeno if d i is finite:</formula><p>Zeno runs admit infinitely many steps in finite time and are hence considered unrealistic from a modeling point of view <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b20">21]</ref>. Definition 7. The energy Büchi problem for a WTBA A and initial credit c ∈ N is to ask if there exists a Büchi accepted c-feasible non-Zeno run in A . We continue our running example; but to do so properly, we need to introduce products of WTBAs. Let A i = (M i , Q i , q i 0 , X i , I i , E i , r i ), for i ∈ {1, 2}, be WTBAs. Their product is the WTBA A 1 A 2 = (M, Q, q 0 , X, I, E, r) with</p><formula xml:id="formula_10">M = M 1 ∪ M 2 , Q = Q 1 × Q 2 , q 0 = (q 1 0 , q 2 0 ), X = X 1 ∪ X 2 ,</formula><p>I((q 1 , q 2 )) = I(q 1 ) ∧ I(q 2 ), r((q 1 , q 2 )) = r(q 1 ) + r(q 2 ), E = ((q 1 , q 2 ), M, g, R, (q 1 , q 2 )) (q 1 , M, g, R, q 1 ) ∈ E 1 ∪ ((q 1 , q 2 ), M, g, R, (q 1 , q 2 )) (q 2 , M, g, R, q 2 ) ∈ E 2 .</p><p>Running example 3. Let A be the basic WTBA of Fig. <ref type="figure" target="#fig_0">1a</ref> and A 1 the combination of A with the work module of Fig. <ref type="figure">2</ref>. Now, instead of building A 1 as we have done, a principled way of constructing a model for the satellite-with-work-module would be to first model the work module W and then form the product A W . We show such a work module and the resulting product B 1 in Fig. <ref type="figure">3</ref>. As expected, W expresses that work takes 5 minutes and costs 10 energy units per minute, and the Büchi condition enforces that work is executed infinitely often. The product B 1 models the shadow-sun cycle together with the fact that work may be executed at any time, and contrary to our "unrealistic" model A 1 of Fig. <ref type="figure">2</ref>, work does not prolong earth shadow time. Now B 1 has two clocks, and we will see below that our constructions can handle only one. This is the reason for our "unrealistic" model A 1 , and we can now state precisely in which sense it is conservative: if A 1 admits a Büchi accepted c-feasible non-Zeno run, then so does B 1 . For a proof of this fact, one notes that any infinite run ρ in A 1 may be translated to an infinite run ρ in B 1 by adjusting the clock valuation by 5 whenever the work module is visited.</p><p>Bounding Clocks As a first step to solve energy Büchi problems for WTBAs, we show that we may assume that the clocks in any WTBA A are bounded above by some N ∈ N, i.e., such that v(x) ≤ N for all (q, v) ∈ A and x ∈ X. This is shown for reachability in <ref type="bibr" target="#b2">[3]</ref>; the following lemma extends it to Büchi acceptance. Lemma 8. Let A = (M, Q, q 0 , X, I, E, r) be a WTBA and c ∈ N. Let N the maximum constant appearing in any invariant I(q), for q ∈ Q, or in any guard g, for (q, M, g, R, q ) ∈ E. There is a WTBA Ā = (M, Q, q 0 , X, Ī, Ē, r) such that 1. v(x) ≤ N + 2 for all x ∈ X and (q, v) ∈ Ā , and 2. there exists a c-feasible Büchi accepted run in A iff such exists in Ā .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corner-point abstraction</head><p>We now restrict to WTBAs with only one clock and show how to translate these into finite untimed WBAs using the corner-point abstraction. This abstraction may be defined for any number of clocks, but it is shown in <ref type="bibr" target="#b7">[8]</ref> that the energy problem is undecidable for weighted timed automata with four clocks or more; for two or three clocks the problem is open.</p><p>Let A = (M, Q, q 0 , X, I, E, r) be a WTBA with X = {x} a singleton. Using Lemma 8 we may assume that x is bounded by some N ∈ N, i.e., such that v(x) ≤ N for all (q, v) ∈ A . Let C be the set of all constants which occur in invariants I(q) or guards g or resets R of edges (q, M, g, R, q ) in A, and write C ∪ {N } = {a 1 , . . . , a n+1 } with ordering 0 ≤ a 1 &lt; • • • &lt; a n+1 . The corner-point regions <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23]</ref> of A are the subsets {a i }, for i = 1, . . . , n + 1, [a i , a i+1 [, and ]a i , a i+1 ], for i = 1, . . . , n, of R ≥0 ; that is, points, left-open, and right-open intervals on {a 1 , . . . , a n+1 }.</p><p>These are equivalent to clock constraints x = a i , a i ≤ x &lt; a i+1 , and a i &lt; x ≤ a i+1 , respectively, defining a notion of implication r ⇒ ϕ for r a corner-point region and ϕ ∈ Φ({x}).</p><p>The corner-point abstraction of A is the finite WBA cpa(A) = (M ∪ {m z }, S, s 0 , T ), where m z / ∈ M is a new color, S = {(q, r) | q ∈ Q, r corner-point region of A, r ⇒ I(q)}, s 0 = (q 0 , {0}), and transitions in T are of the following types:</p><formula xml:id="formula_11">-delays (q, {a i }) 0 -→ ∅ (q, [a i , a i+1 [), (q, [a i , a i+1 [) w -→ {mz} (q, ]</formula><p>a i , a i+1 ]) with w = r(q)(a i+1 -a i ), and (q, ]a i , a i+1 ]) 0 -→ ∅ (q, a i+1 ); switches (q, r) 0 -→ M (q , r) for e = (q, M, g, (x → ⊥), q ) ∈ E with r ⇒ g and (q, r) 0 -→ M (q , {k}) for e = (q, M, g, (x → k), q ) ∈ E with r ⇒ g. Fig. <ref type="figure" target="#fig_2">4</ref>: Corner-point abstraction of base module of Fig. <ref type="figure" target="#fig_0">1a</ref>.</p><p>The new color m z is used to rule out Zeno runs, see <ref type="bibr" target="#b0">[1]</ref> for a similar construction: any Büchi accepted infinite run in cpa(A) must have infinitely many time-increasing delay transitions (q, [a i , a i+1 [) w -→ {mz} (q, ]a i , a i+1 ]).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 9.</head><p>Let A be a one-clock WTBA and c ∈ N.</p><p>1. If there is a non-Zeno Büchi accepted c-feasible run in A , then there is a Büchi accepted c-feasible run in cpa(A). 2. If there is a Büchi accepted c-feasible run in cpa(A), then there is a non-Zeno Büchi accepted (c + ε)-feasible run in A for any ε &gt; 0.</p><p>The so-called infimum energy condition <ref type="bibr" target="#b6">[7]</ref> in the second part above, replacing c with c + ε, is necessary in the presence of strict constraints x &lt; c or x &gt; c in A. The proof maps runs in A to runs in cpa(A) by pushing delays to endpoints of corner-point regions, ignoring strictness of constraints, and this has to be repaired by introducing the infimum condition. The corner-point abstraction of A now looks as in Fig. <ref type="figure" target="#fig_2">4</ref>, with the states corresponding to the "shadow" location in the top row; the colored transitions correspond to the ones in which time elapses. Note that this WBA is equivalent to the one in Fig. <ref type="figure" target="#fig_0">1b</ref>.</p><p>Using the corner-point abstraction, we may now solve energy Büchi problems for one-clock WTBAs by translating them into finite WBAs and applying the algorithms of Sect. 2 and the forthcoming Sect. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>We now describe our algorithm to solve energy Büchi problems for finite WBA; all of this has been implemented and is available at https://github.com/ PhilippSchlehuberCaissier/wspot.</p><p>We have seen in Sect. 2 that this problem is equivalent to the search for Büchi accepted c-feasible lassos. By definition, a lasso ρ = γ 1 γ ω 2 consists of two parts, return ReportNoLoop() the lasso prefix γ 1 (possibly empty, only traversed once) and the lasso cycle γ 2 (repeated indefinitely). In order for ρ to be Büchi accepted and c-feasible, both the prefix γ 1 and the cycle γ 2 must be c-feasible, however only the cycle needs to be Büchi accepted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding lassos</head><p>The overall procedure to find lassos is described in Alg. 1. It is based on two steps. In step one we compute all energy-optimal paths starting at the initial state of the automaton with initial credit c. This step is done on the original WBA, and we do not take into account the colors. Optimal paths found in this step will serve as lasso prefixes. The second step is done individually for each Büchi accepting SCC. The Couvreur algorithm ignores the weights, and we can use the version distributed by Spot. We then degeneralize the accepting SCCs one by one, as described in Sect. 2; recall that this creates one copy of the SCC, which we call a level, per color. The first level roots the degeneralization in the original automaton; transitions leading back from the last to the first level are called back-edges. These back-edges play a crucial role as they are the only colored transitions in the degeneralized SCC and represent the accepting transitions.</p><p>Hence any Büchi accepting cycle in the degeneralization needs to contain at least one such back-edge, and we can therefore focus our attention on these. We proceed to check for each back-edge whether we can embed it in a c-feasible cycle within the degeneralized SCC. To this end, we compute the energy-optimal paths starting at the destination of the current back-edge (by construction a state in the first level) with an initial credit corresponding to its maximal prefix energy (as found in the first step). By comparing the energy of the source state of the back-edge e while taking into account its weight, one can determine whether there exists a c-feasible cycle containing e. If this is the case, then we have found  a c-feasible lasso cycle, and by concatenating it with the prefix found in the first step, we can construct a lasso. Note that we might have to check the loop a second time (using the energy level calculated in the first iteration as initial credit), see <ref type="bibr">Example 10</ref>. If the answer is negative, we continue with the next back-edge in the SCC or with the next SCC once all back-edges exhausted.</p><p>Example 10. Figure <ref type="figure" target="#fig_4">5a</ref> shows an automaton where we have to compute maximal energy levels twice (lines 11-14 in Alg. 1): with b = 30 and c = 0, the prefix energy of state 1 is 30, while its optimal energy on the cycle is 20, despite it being part of a energy-positive loop. Hence we cannot conclude that we have found an accepting lasso after the first iteration, but need to run the algorithm once more with an initial credit of 20.</p><p>Finding energy optimal paths We now discuss how to find energy optimal paths. The problem is equivalent (but inverse) to finding shortest paths in weighted graphs. This may be done using the well-known Bellman-Ford algorithm <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b17">18]</ref>, which breaks with an error if it finds negative loops. In our inverted problem, we are seeking to maximize energy, so positive loops are accepted and even desired. To take into account this particularity, we modify the Bellman-Ford algorithm to invert the weight handling and to be able to handle positive loops. The modified Bellman-Ford algorithm is given in Alg. 2. The standard algorithm computes shortest paths by relaxing the distance approximation until the solution is found. One round relaxes all edges and the algorithm makes as many rounds as there are nodes. Inverting the algorithm is easy: the relaxation is done if the new weight is higher than the old weight; additionally the new weight has to be higher than 0 and is bounded from above by the weak upper bound.</p><p>The second modification to Bellman-Ford is the handling of positive loops. This part is a bit more involved, especially if one strives for an efficient algorithm. We could run Bellman-Ford until it reaches a fixed point, however this can significantly impact performance as shown in the following example. This means that we need to run (N + 1) • b rounds of Bellman-Ford to reach a fixed point. Ideally we would like the upper bound to have no influence on the runtime. To this end we introduce the function PumpAll, which sets the energy level of all states on positive loops detected by the last round of Bellman-Ford to the achievable maximum. This way, instead of needing b rounds of Bellman-Ford to attain the maximal energy, we only need one plus a call to PumpAll.</p><p>Before continuing, we make the following observation. This stage will be called from Algorithm 1 that recognizes loops necessary to fulfill the Büchi condition. Here, we only need to check reachability. Therefore, the only reason to form a loop is to gain energy, implying that we are only interested in simple energy positive loops, i.e., loops where every state appears at most once. If we set the optimal reachable weight in simple loops, then nested loops are updated by Bellman-Ford in the usual way afterwards.</p><p>To improve the runtime of our algorithm, we exploit that Bellman-Ford can detect positive cycles and handle these cycles specifically. Note however that contrary to a statement in <ref type="bibr" target="#b6">[7]</ref>, we cannot simply set all energy levels on a positive loop to b: in the example of Fig. <ref type="figure" target="#fig_4">5a</ref>, starting in state 2 with an initial credit of 10, the energy level in state 1 will increase with every round of Bellman-Ford but never above 20 = b -10.</p><p>In order to have an algorithm whose complexity is independent of b, we instead compute the fixed point from above. We first make the following observation.</p><p>Lemma 12. In energy positive loops, there exists at least one state on the loop that can attain the maximal energy b.</p><p>Proof. Since the loop is energy positive we can increase the energy level at any specific node by cycling through the loop. This can be repeated until a fixed point is reached. This fixed point is only reached when at one of the states the accumulated weight reaches b (or surpasses b but is restricted to b). As the increase of energy with every cycle is a strictly monotone operation, the fixed point will be reached and no alternation is possible.</p><p>If we knew the precise state that attains maximal energy, we could set its energy to b and loop through the cycle once while propagating the energy, causing every state on the loop to obtain its maximal energy. However, not knowing which state will effectively attain b, we start with any state on the loop, set its energy to b and propagate the energy along the loop until a fixed point is reached. This is the case after traversing the loop at most twice. This is done by the function PumpLoop.</p><p>Lemma 13. PumpLoop calculates the desired fixed point after at most two cycles through the loop.</p><p>Proof. In Alg. 2, lines 9 and 10 ensure that the fixed point check in line 16 does not detect false positives. After setting an arbitrary state's energy to b, the algorithm cycles through the states in the loop in forward order. Consider w.l.o.g. the positive cycle γ</p><formula xml:id="formula_12">= s 1 w1 --→ s 2 w2 --→ • • • w N -1</formula><p>----→ s N with s 1 = s N . By Lemma 12 we know that there exists at least one state s j with 0 ≤ j &lt; N whose maximal energy equals b. Before the first energy propagating traversal of the cycle we set the energy of s 1 to b. Two cases present themselves. If j = 0, then energy is correctly propagated and we reach a fixed point after one traversal. In the second case, the energy attainable by s 1 is strictly smaller than b.</p><p>Propagating from this energy level will over-approximate the energies reached by the states s 0 through s j-1 on the cycle, but only until state s j is reached which actually attains b. As energy is bounded, the energy levels of state s j and its successors s j+1 , . . . , s N are correctly calculated. This means that after traversing the cycle s j wj</p><formula xml:id="formula_13">--→ • • • w N -1 ----→ s N w1 --→ s 2 w2 --→ • • • wj-1</formula><p>---→ s j , all energy levels on the cycle are correctly calculated and this is guaranteed to happen before traversing the original cycle twice.</p><p>The corresponding fixed point condition is detected by line 16 which will stop the iteration. Note that we actually need to check for changes in the energy level on line 16, and not whether some state attained energy b, as we at this point cannot know whether this energy was reached due to over-approximation.</p><p>Note that the pseudocode shown here is a simplification, as our implementation contains some further optimizations. Namely, we implement an early exit in modBF if we detect that a fixed point is reached, and we keep track of states which have seen an update to their energy, as this allows to perform certain operations selectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm Complexity</head><p>We are now able to conclude our discussion from Sect. 2 and show that energy Büchi problems for finite WBA are decidable in polynomial time.</p><p>Proof (of Theorem 5). For our decision procedure, the search for strongly connected components can be done in polynomial time. Our modified Bellman-Ford algorithm also has polynomial complexity. It is called once at the beginning and once for every back-edge of every strongly connected component. Given that the number of such back-edges is bounded by the number of edges, we conclude that our overall algorithm has polynomial complexity. x ← 0, s?</p><p>x = i Fig. <ref type="figure">8</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Benchmarks</head><p>We employ our running example to build a scalable benchmark case. For modeling convenience we use products of WTBAs as introduced above extended with standard sender/receiver synchronization via channels. The additional labels s! and s? are used for synchronization. Edges with s! can always be taken and emit the signal s; edges with s? can only be taken if a signal s is currently emitted. This modeling allows multiple work modules to start working at the same time.</p><p>As before, we use a base circuit with two states, see Fig. <ref type="figure">7</ref>. Work module #i, see Fig. <ref type="figure">8</ref>, uses 10 energy units while working and spends exactly i time units in the work state. We then combine these models with the specification that time must pass and that every work module is activated infinitely often. All the presented instances are schedulable. Table <ref type="table" target="#tab_3">1</ref> presents the results of our benchmark, showing that the presented approach scales fairly well. We note that most of the time for solving the energy Büchi problem (last column) is spent in our Python implementation of our modified Bellman-Ford algorithm. In fact the total runtime is (at least for #mod ≥ 5) directly proportional to the number of times lines 4 to 7 of ModBF in Alg. 2 are executed. Therefore, the implementation could greatly benefit from a direct integration into Spot and using its C ++ engine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have shown how to efficiently solve energy Büchi problems, both in finite weighted (transition-based generalized) Büchi automata and in one-clock weighted timed Büchi automata. We have implemented all our algorithms in a tool based on TChecker and Spot. Solving the latter problem is done by using the corner-point abstraction to translate the weighted timed Büchi automaton to a finite weighted Büchi automaton; the former problem is handled by interleaving a modified version of the Bellman-Ford algorithm with Couvreur's algorithm.</p><p>Our tool is able to handle some interesting examples, but the restriction to one-clock weighted timed Büchi automata without weights on edges does impose some constraints on modeling. We believe that trying to lift the one-clock restriction is unrealistic; but weighted edges (without Büchi conditions) have been treated in <ref type="bibr" target="#b5">[6]</ref>, and we suspect that their approach should also be viable here. (See <ref type="bibr" target="#b9">[10]</ref> for a related approach.) In passing we should like to argue that, as shown by our running example, the modeling constraints imposed by only having one clock may be somewhat circumvented by careful modeling.</p><p>Also adopting our approach to the unlimited energy problem, without weak upper bound, should not pose any problems. In fact, setting b = ∞ will facilitate the algorithm, as maximal energy levels of nodes on positive loops can directly be set to ∞ (making PumpLoop obsolete), and also the second iteration in Alg. 1 can be dropped.</p><p>Further, we strongly believe that our idea of investigating whether a back-edge can be embedded in an energy positive cycle is not restricted to (generalized) Büchi acceptance. In fact, the same methods should be applicable to, for example, parity acceptance conditions without losing the polynomial runtime.</p><p>As a last remark, it is known that multiple clocks, multiple weight dimensions, and even turning the weak upper bound into a strict one which may not be exceeded, rapidly leads to undecidability results, see <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b25">26]</ref>, and we are wondering whether some of these may be sharpened when using Büchi conditions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Satellite example: two representations of the base circuit. (a) as weighted timed automaton A; (b) as a (finite) weighted automaton.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>For</head><label></label><figDesc>c, b ∈ N 3 and a run ρ = s 1 w1 --→ s 2 w2 --→ • • • , the (c, b)-accumulated weights of ρ are the elements of the finite or infinite sequence weights c↓b (ρ) = (e 1 , e 2 , . . . ) defined by e 1 = min(b, c) and e i+1 = min(b, e i + w i ). Hence the transition weights are accumulated, starting with c, but only up to the maximum bound b; increases above b are discarded. We call c the initial credit and b the weak upper bound. Running example 2. In Fig. 1b, and choosing c = 360 and b = 750, we have a single infinite run ρ = 1 → • • • , with weights c↓b (ρ) = (360, 10, 750, 400, 750, . . . ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Running example 4 .</head><label>4</label><figDesc>We construct the corner-point abstraction of the base module A of Fig. 1a. Its constants are {0, 35, 55}, yielding the following corner point regions: {0}, [0, 35[, ]0, 35], {35}, [35, 55[, ]35, 55], {55}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Degeneralizing SCC {1, 2} with level 1 rooted in the original WBA. Back-edges colored red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Left: WBA (also used in Example 10); right: degeneralization of one SCC (states named originalstate, level).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 : 11 Example 11 .</head><label>61111</label><figDesc>Fig. 6: WBA for Example 11</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Fig. 7: Base circuit</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Algorithm 1 Algorithm to find Büchi accepted lassos in WBA</figDesc><table><row><cell cols="3">Input: weak upper bound b</cell></row><row><cell cols="4">1: function BüchiEnergy(graph G, initial credit c) 2: E ← FindMaxE(G, G.initial state, c) // E : S → N, mapping states to energy</cell></row><row><cell>3:</cell><cell cols="2">SCCs ← Couvreur(G)</cell><cell>// Find all SCCs</cell></row><row><cell>4:</cell><cell cols="2">for all scc ∈ SCCs do</cell></row><row><cell>5:</cell><cell cols="2">GS , backedges ← degeneralize(scc)</cell></row><row><cell>6:</cell><cell>for all t = src</cell><cell>w -→ dst ∈ backedges do</cell></row><row><cell>7:</cell><cell cols="2">E ← FindMaxE(GS , dst, E[dst])</cell><cell>// t.dst is in G and GS...</cell></row><row><cell>8:</cell><cell cols="2">e ← min(b, E [src] + w)</cell><cell>// ...(see Fig. 5b)</cell></row><row><cell>9:</cell><cell cols="2">if E[dst] ≤ e then</cell></row><row><cell>10:</cell><cell cols="2">return ReportLoop()</cell></row><row><cell>11:</cell><cell>else</cell><cell></cell><cell>// Second iteration (see Fig. 5a)</cell></row><row><cell>12:</cell><cell cols="2">E ← FindMaxE(GS , dst, e )</cell></row><row><cell>13:</cell><cell cols="2">if e ≤ min(b, E [src] + w) then</cell></row><row><cell>14:</cell><cell cols="2">return ReportLoop()</cell></row><row><cell>15:</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Algorithm 2 Modified Bellman-Ford Loop returns the states on the loop of s ...</figDesc><table><row><cell cols="3">Shared Variables: E, P</cell></row><row><cell></cell><cell cols="2">Modified Bellman-Ford algorithm</cell></row><row><cell cols="3">1: function modBF(weighted graph G)</cell></row><row><cell>2:</cell><cell cols="2">for n ∈ {1, . . . , |S|} do</cell></row><row><cell>3:</cell><cell>for all t = s</cell><cell>w -→ s ∈ T do</cell></row><row><cell>4:</cell><cell cols="2">e ← min(E(s) + w, b)</cell></row><row><cell>5:</cell><cell cols="2">if E[s ] &lt; e and e ≥ 0 then</cell></row><row><cell>6:</cell><cell cols="2">E[s ] ← e</cell></row><row><cell>7:</cell><cell cols="3">P [s ] ← t // P : S → T , mapping states to best incoming transition</cell></row><row><cell></cell><cell cols="3">Helper function assigning the optimal energy to all states on the energy positive</cell></row><row><cell></cell><cell cols="2">loop containing state s</cell></row><row><cell cols="4">8: function PumpLoop(weighted graph G, state s)</cell></row><row><cell cols="3">9: // 10: for all s ∈ Loop(s) do E[s ] ← -1</cell><cell>// Special value to detect fixed point</cell></row><row><cell>11:</cell><cell>E[P [s].src] ← b</cell><cell></cell></row><row><cell>12:</cell><cell>while do</cell><cell></cell><cell>// Loops at most twice</cell></row><row><cell>13:</cell><cell cols="2">for all s ∈ Loop(s) do</cell><cell>// ... in forward order</cell></row><row><cell>14:</cell><cell>t ← P [s ]</cell><cell></cell></row><row><cell>15:</cell><cell cols="2">e ← min(b, E[t.src] + t.w)</cell></row><row><cell>16:</cell><cell cols="2">if e = E[t.dst] then</cell></row><row><cell>17:</cell><cell cols="3">Mark loop (and postfix) as done</cell></row><row><cell>18:</cell><cell cols="2">return</cell><cell>// fixed point reached</cell></row><row><cell>19:</cell><cell cols="2">E[t.dst] ← e</cell></row><row><cell></cell><cell cols="3">Helper function, pumping all energy positive loops induced by P</cell></row><row><cell cols="3">20: function PumpAll(weighted graph G)</cell></row><row><cell>21:</cell><cell cols="3">for all states s that changed their weight do</cell></row><row><cell>22:</cell><cell>t = P [s]</cell><cell></cell></row><row><cell>23:</cell><cell cols="2">if min(b, E[t.src] + t.w) &gt; E[s] then</cell></row><row><cell>24:</cell><cell>s ← s</cell><cell cols="2">// s can be either on the cycle or in a postfix of one</cell></row><row><cell>25:</cell><cell>repeat</cell><cell cols="2">// Go through it backwards to find a state on the cycle</cell></row><row><cell>26:</cell><cell cols="2">s .mark ←</cell></row><row><cell>27:</cell><cell cols="2">s ← t.src</cell></row><row><cell>28:</cell><cell cols="2">until s already marked</cell></row><row><cell>29:</cell><cell cols="2">PumpLoop(G, s )</cell><cell>// Pump it</cell></row><row><cell></cell><cell cols="3">Function computing the optimal energy for each state</cell></row><row><cell cols="4">30: function FindMaxE(graph G, start state s0, initial credit c)</cell></row><row><cell>31:</cell><cell>Init(s0, c)</cell><cell cols="2">// initialize values in E to -∞ and E(s0) = c</cell></row><row><cell>32:</cell><cell cols="3">while not f ixedpoint(E) do // Iteratively search for loops, then pump them</cell></row><row><cell>33:</cell><cell>modBF(G)</cell><cell></cell></row><row><cell>34:</cell><cell cols="2">PumpAll(G)</cell></row><row><cell>35:</cell><cell cols="2">return copyOf(E)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>: Work module #i Benchmark results. From left to right: Number of work modules, Number of states in cpa, time needed to compute cpa, time needed to solve energy Büchi problem.</figDesc><table><row><cell cols="4">#mod #states to cpa [s] sol [s]</cell></row><row><cell>1</cell><cell>25</cell><cell>0.01</cell><cell>0.00</cell></row><row><cell>3</cell><cell>90</cell><cell>0.03</cell><cell>0.02</cell></row><row><cell>5</cell><cell>293</cell><cell>0.06</cell><cell>0.24</cell></row><row><cell>7</cell><cell>1012</cell><cell>0.19</cell><cell>3.24</cell></row><row><cell>9</cell><cell>3759</cell><cell cols="2">0.89 59.52</cell></row><row><cell>10</cell><cell>7377</cell><cell cols="2">1.87 261.38</cell></row><row><cell>11</cell><cell>14582</cell><cell cols="2">4.37 1194.81</cell></row><row><cell cols="4">Benchmarks done on an ASUS G14, Ryzen</cell></row><row><cell cols="3">4800H CPU with 16Gb RAM.</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>Here we annotate transitions with the time d which passes; we only need this to exclude Zeno runs below and will otherwise omit the annotation.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>We are grateful to <rs type="person">Alexandre Duret-Lutz</rs>, <rs type="person">Nicolas Markey</rs> and <rs type="person">Ocan Sankur</rs> for fruitful discussions on the subjects of this paper.</p></div>
			</div>
			<div type="funding">
<div><p>Partially funded by <rs type="projectName">ANR</rs> project <rs type="projectName">Ticktac</rs> (<rs type="grantNumber">ANR-18-CE40-0015</rs>) ://spot.lrde.epita.fr/</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_UyKHbW8">
					<orgName type="project" subtype="full">ANR</orgName>
				</org>
				<org type="funded-project" xml:id="_h8JNGk4">
					<idno type="grant-number">ANR-18-CE40-0015</idno>
					<orgName type="project" subtype="full">Ticktac</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A theory of timed automata</title>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="235" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Optimal and robust controller synthesis using energy timed automata with uncertainty</title>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Bacci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patricia</forename><surname>Bouyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Markey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre-Alain</forename><surname>Reynier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects Comput</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="25" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Minimum-cost reachability for priced timed automata</title>
		<author>
			<persName><forename type="first">Gerd</forename><surname>Behrmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ansgar</forename><surname>Fehnker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Hune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Judi</forename><surname>Romijn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frits</forename><forename type="middle">W</forename><surname>Vaandrager</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Maria</forename><surname>Domenica</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Di</forename><surname>Benedetto</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alberto</forename><forename type="middle">L</forename><surname>Sangiovanni-Vincentelli</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">2034</biblScope>
			<biblScope unit="page" from="147" to="161" />
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On a routing problem</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Bellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Quart. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="87" to="90" />
			<date type="published" when="1958">1958</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Battery-aware scheduling in low orbit: The GomX-3 case</title>
		<author>
			<persName><forename type="first">Morten</forename><surname>Bisgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Gerhardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Holger</forename><surname>Hermanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Krčál</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Nies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marvin</forename><surname>Stenger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">John</forename><forename type="middle">S</forename><surname>Fitzgerald</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Constance</forename><forename type="middle">L</forename><surname>Heitmeyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefania</forename><surname>Gnesi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Anna</forename><surname>Philippou</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="559" to="576" />
			<date type="published" when="2016">9995. 2016</date>
			<publisher>Springer</publisher>
			<pubPlace>FM</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Timed automata with observers under energy constraints</title>
		<author>
			<persName><forename type="first">Patricia</forename><surname>Bouyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Markey</surname></persName>
		</author>
		<editor>Karl Henrik Johansson and Wang Yi</editor>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="61" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Infinite runs in weighted timed automata with energy constraints</title>
		<author>
			<persName><forename type="first">Patricia</forename><surname>Bouyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Markey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiří</forename><surname>Srba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FORMATS</title>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Franck</forename><surname>Cassez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Claude</forename><surname>Jard</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5215</biblScope>
			<biblScope unit="page" from="33" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Lower-bound-constrained runs in weighted timed automata</title>
		<author>
			<persName><forename type="first">Patricia</forename><surname>Bouyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Markey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Perform. Eval</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="91" to="109" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Symposium on decision problems: On a decision method in restricted second order arithmetic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Richard</forename><surname>Büchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic, Methodology and Philosophy of Science</title>
		<title level="s">Studies in Logic and the Foundations of Mathematics</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="1966">1966</date>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">An ω-algebra for real-time energy problems</title>
		<author>
			<persName><forename type="first">David</forename><surname>Cachera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Axel</forename><surname>Legay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logical Meth. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Energy parity games</title>
		<author>
			<persName><forename type="first">Krishnendu</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Doyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">458</biblScope>
			<biblScope unit="page" from="49" to="60" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Generalized mean-payoff and energy games</title>
		<author>
			<persName><forename type="first">Krishnendu</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Doyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-François</forename><surname>Raskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSTTCS</title>
		<editor>
			<persName><forename type="first">Kamal</forename><surname>Lodaya</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Meena</forename><surname>Mahajan</surname></persName>
		</editor>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="505" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Spot 2.0 -A framework for LTL and omegaautomata manipulation</title>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Duret-Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Lewkowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amaury</forename><surname>Fauchille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thibaud</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Renault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Cyrille</forename><surname>Artho</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Axel</forename><surname>Legay</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Doron</forename><surname>Peled</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="122" to="129" />
			<date type="published" when="2016">9938. 2016</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An algebraic approach to energy problems I: * -Continuous Kleene ω-algebras</title>
		<author>
			<persName><forename type="first">Zoltán</forename><surname>Ésik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Axel</forename><surname>Legay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karin</forename><surname>Quaas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Cyb</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="203" to="228" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An algebraic approach to energy problems II: The algebra of energy functions</title>
		<author>
			<persName><forename type="first">Zoltán</forename><surname>Ésik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Axel</forename><surname>Legay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karin</forename><surname>Quaas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Cyb</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="229" to="268" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Energy games in multiweighted automata</title>
		<author>
			<persName><forename type="first">Uli</forename><surname>Fahrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Line</forename><surname>Juhl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiří</forename><surname>Srba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICTAC</title>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Antonio</forename><surname>Cerone</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Pekka</forename><surname>Pihlajasaari</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6916</biblScope>
			<biblScope unit="page" from="95" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Code-level timing analysis of embedded software</title>
		<author>
			<persName><forename type="first">Heiko</forename><surname>Falk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Björn</forename><surname>Lisper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><forename type="middle">M</forename><surname>Petters</surname></persName>
		</author>
		<editor>Ahmed Jerraya, Luca P. Carloni, Florence Maraninchi, and John Regehr</editor>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="163" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Network Flow Theory</title>
		<author>
			<persName><forename type="first">Lester</forename><forename type="middle">R</forename><surname>Ford</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1956">1956</date>
			<publisher>RAND Corporation</publisher>
			<pubPlace>Santa Monica, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Monitoring dynamical signals while testing timed aspects of a system</title>
		<author>
			<persName><forename type="first">Goran</forename><surname>Frehse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marius</forename><surname>Mikučionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Nielsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICTSS</title>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Burkhart</forename><surname>Wolff</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fatiha</forename><surname>Zaïdi</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">7019</biblScope>
			<biblScope unit="page" from="115" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast LTL to Büchi automata translation</title>
		<author>
			<persName><forename type="first">Paul</forename><surname>Gastin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Oddoux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Gérard</forename><surname>Berry</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Hubert</forename><surname>Comon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alain</forename><surname>Finkel</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="53" to="65" />
			<date type="published" when="2001">2102. 2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Coarse abstractions make Zeno behaviours difficult to detect</title>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Herbreteau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Srivathsan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Log. Methods Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Better abstractions for timed automata</title>
		<author>
			<persName><forename type="first">B</forename><surname>Frédéric Herbreteau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Srivathsan</surname></persName>
		</author>
		<author>
			<persName><surname>Walukiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">251</biblScope>
			<biblScope unit="page" from="67" to="90" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Model checking timed automata with one or two clocks</title>
		<author>
			<persName><forename type="first">François</forename><surname>Laroussinie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Markey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Schnoebelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Philippa</forename><surname>Gardner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3170</biblScope>
			<biblScope unit="page" from="387" to="401" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Uppaal in a nutshell</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Tools Techn. Trans</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="134" to="152" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Schedulability analysis using Uppaal: Herschel-Planck case study</title>
		<author>
			<persName><forename type="first">Marius</forename><surname>Mikučionis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Illum Rasmussen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arne</forename><surname>Skou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulrik</forename><surname>Steen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Palm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Poul</forename><surname>Storbank Pedersen</surname></persName>
		</author>
		<author>
			<persName><surname>Hougaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Tiziana</forename><surname>Margaria</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bernhard</forename><surname>Steffen</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6416</biblScope>
			<biblScope unit="page" from="175" to="190" />
			<date type="published" when="2010">2010</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>ISoLA (2</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the interval-bound problem for weighted timed automata</title>
		<author>
			<persName><forename type="first">Karin</forename><surname>Quaas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LATA</title>
		<title level="s">Lect. Notes Comput. Sci.</title>
		<editor>
			<persName><forename type="first">Adrian</forename><surname>Horia Dediu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Shunsuke</forename><surname>Inenaga</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Carlos</forename><surname>Martín-Vide</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">6638</biblScope>
			<biblScope unit="page" from="452" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The complexity of multimean-payoff and multi-energy games</title>
		<author>
			<persName><forename type="first">Yaron</forename><surname>Velner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krishnendu</forename><surname>Chatterjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Doyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Moshe Rabinovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-François</forename><surname>Raskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">241</biblScope>
			<biblScope unit="page" from="177" to="196" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Reasoning about infinite computation paths</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Wolper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Prasad</forename><surname>Sistla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="185" to="194" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
