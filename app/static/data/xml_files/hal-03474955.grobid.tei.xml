<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provenance-aware Discovery of Functional Dependencies on Integrated Views</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ugo</forename><surname>Comignani</surname></persName>
							<email>ugo.comignani@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Laure</forename><surname>Berti-Equille</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Noël</forename><surname>Novelli</surname></persName>
							<email>noel.novelli@lis-lab.fr</email>
						</author>
						<author>
							<persName><forename type="first">Angela</forename><forename type="middle">Bonifati</forename><surname>Lyon</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Tyrex team</orgName>
								<orgName type="institution">Grenoble INP</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">INRIA</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">IRD</orgName>
								<orgName type="institution">ESPACE-DEV Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Aix-Marseille Univ</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">LIS CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">University Lyon</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Provenance-aware Discovery of Functional Dependencies on Integrated Views</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0CAF36E4192285EDB649E8EB06006C0C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The automatic discovery of functional dependencies (FDs) has been widely studied as one of the hardest problems in data profiling. Existing approaches have focused on making the FD computation efficient while inspecting single relations at a time. In this paper, for the first time we address the problem of inferring FDs for multiple relations as they occur in integrated views by solely using the functional dependencies of the base relations of the view itself. To this purpose, we leverage logical inference and selective mining and show that we can discover most of the exact FDs from the base relations and avoid the full computation of the FDs for the integrated view itself, while at the same time preserving the lineage of FDs of base relations. We propose algorithms to speedup the inferred FD discovery process and mine FDs on-the-fly only from necessary data partitions. We present InFine (INferred FunctIoNal dEpendency), an end-to-end solution to discover inferred FDs on integrated views by leveraging provenance information of base relations. Our experiments on a range of real-world and synthetic datasets demonstrate the benefits of our method over existing FD discovery methods that need to rerun the discovery process on the view from scratch and cannot exploit lineage information on the FDs. We show that InFine outperforms traditional methods necessitating the full integrated view computation by one to two order of magnitude in terms of runtime. It is also the most memory efficient method while preserving FD provenance information using mainly inference from base table with negligible execution time.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The automatic discovery of all functional dependencies (FDs) holding in a single relation is amongst the hardest problems in data profiling <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b23">[24]</ref>. Typically, an FD X → Y with attribute sets X and Y in a given table allows to enforce that the combination of values in the set X uniquely determines the values of every attribute in the set Y . Functional dependencies are key ingredients in database design, table decomposition, database normalization, and for several other data management tasks, such as data cleaning <ref type="bibr" target="#b27">[28]</ref> and query optimization <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b25">[26]</ref>. Due to the high complexity of FD discovery <ref type="bibr" target="#b18">[19]</ref> (exponential in the number of attributes and quadratic in the number of records of a relation), a wealth of algorithms have been proposed by relying on aggressive pruning and sophisticated validation. Many of these algorithms <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b24">[25]</ref> have the same theoretical complexity and are able to compute all minimal FDs in less runtime.</p><p>Despite the vast literature on the topic, all existing algorithms focus on the FD discovery problem for one relation at a time and do not explore reuse of computation when dealing with multiple relations. However, relations are oftentimes involved in view computation operations, among which the notable class of SPJ (Select-Project-Join) view operations. In this case, the existing algorithms addressing FD discovery would have to entirely recompute the set of FDs for the obtained integrated view without being able to reuse any of the previous computations on the individual base tables of the view. In this paper, for the first time we tackle the problem of inferring FDs on integrated views (also called Inferred FD discovery problem) by solely relying on the FDs available from the base tables of the views. To do so, we employ the wellknown concept of why-provenance <ref type="bibr" target="#b2">[3]</ref>, which allows us to identify the lineage of the FDs on the integrated view and throughout the view computation operations.</p><p>In our work, we address the Inferred FD discovery problem, which consists of considering a SPJ view on top of a set of base tables and computing the FDs holding on the view by reusing as much as possible the discovered FDs on the base tables, and, in turn, reduce the SPJ view computation with only the needed attributes.</p><p>Explicitly relating the FDs of the base table to the FDs of the view has interest on its own as it allows for instance to understand whether FDs on the base tables are persistent on the view. It can also be beneficial whenever the user needs help while debugging the FDs on the base tables by choosing the most relevant ones if they also apply to the view. Since SPJ views might be obtained as results of data integration and ETL scenarios <ref type="bibr" target="#b9">[10]</ref>, our method allows to understand how constraints (namely the FDs) are actually affected by the integration process. New FDs that hold on the view but not on the base tables may help the user better understand and explain the result of the data integration process.</p><p>Our method allows us to obtain time savings in terms of FD discovery from integrated views. By leveraging logical inference and provenance triples, we can avoid recomputing the FDs holding on the view from scratch and only focus on the new FDs that are not holding on the base tables.</p><p>To address the Inferred FD discovery problem, we use a multi-step pipeline encompassing the discovery of different types of FDs and leveraging logical inference. <ref type="bibr">To</ref>   base tables. Our main contributions are as follows:</p><p>• We propose a provenance-based mechanism capable of generating and exploiting provenance triples in a view specification. In particular, for each FD, we capture the type of the FD and a subquery of the view in which the FD holds. • We design five algorithms to compute the provenance of FDs (from base FDs, inference, or join operations) from the results of the FD discovery on the base tables; these algorithms seamlessly address the case of SPJ views, a significant and representative query fragment. • We propose InFine, a full-fledged system implementing our algorithms. InFine is available online 1 with code, scripts, and datasets for the reproducibility of our experiments; • We gauge the effectiveness of our system through an extensive experimental evaluation. We compare InFine against state-of-the-art FD discovery methods over a rich number of SPJ views on real-world and synthetic datasets. We find that InFine outperforms the competing methods by one order up to two orders of magnitude in terms of execution time for discovering exact FDs while preserving the smallest memory consumption on average. Outline. Section II presents an illustrative example. Section III presents the necessary background and notations. In Section IV, we formalize the Inferred FD discovery problem and provide an overview of InFine. We also present our main contributions and the algorithms at the core of InFine. We describe our performance experiments evaluating the efficiency and accuracy of InFine in Section V. Finally, we discuss related work in Section VI and conclude in Section VII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. MOTIVATING EXAMPLE</head><p>Let us consider a real-world clinical database MIMIC-III 2 <ref type="bibr" target="#b13">[14]</ref>, out of which we extract the PATIENT 1 https://github.com/ucomignani/InFine 2 https://physionet.org/content/mimiciii/1.4/ table containing information about patients: their identifier (subject_id), gender, date of birth (dob), date of death (dod), and a boolean expire_flag indicating whether the patient passed away, and the table ADMISSION containing administrative and clinical information about patients such as the hospital admission time (admittime), the admission location (admission_location), the insurance, the diagnosis, and a boolean h_expire_flag indicating whether the patient died at the hospital. Let us consider V , the SPJ view (illustrated in Fig. <ref type="figure" target="#fig_0">1</ref>) that computes a join between the two above tables: SELECT * FROM PATIENT, ADMISSION WHERE PATIENT.subject_id=ADMISSION.subject_id. We are interested in discovering the set of FDs that hold over the SPJ view by reusing as much as possible the FDs of the base tables PATIENT and ADMISSION. For ease of exposition, we focus on FDs with RHS limited to one single attribute (as it is the case in a canonical cover of FDs). The LHS might consist of multiple attributes as those mined from the join in Fig. <ref type="figure" target="#fig_0">1</ref>. A total of 42 minimal and canonical FDs is considered in this running example thus making the example far from being trivial. These FDs can be obtained by FD discovery methods running on the view. However, their lineage is also important as they carry the information of whether they are valid in the base tables or they solely hold on the view. Precisely, we use color coding to encode the FD provenance in the figure. We can observe that the 9 exact FDs from the base table PATIENT (highlighted in green), as well as 9 (out of the 14) exact FDs from the base table ADMISSION (highlighted in pink) are preserved in the result of the integrated view. Imagine that a data steward would like to investigate why a few valid FDs in the base tables are no longer valid in the integrated view result or, conversely, why some FDs that are not valid in the base tables become valid in the view. Better informed, s/he may change and adapt the constraint (FD) enforcement strategies when curating the data using the FDs. Moreover, 10 FDs (highlighted in blue) from the view result can be obtained by logical inference over the sets of exact FDs discovered from each base table: for instance, diagnosis → dod is obtained from insurance,diagnosis → subject_id and subject_id → insurance in ADMISSION and subject_id → dod in PATIENT. As a side note, we are not addressing here the problem of meaningfulness of the FDs, which is orthogonal and of independent interest. Indeed, a valid FD may not be semantically meaningful and judging whether a valid FD is relevant typically needs human intervention.</p><p>When the two tables are joined, patient #257 is removed due to the absence of the corresponding subject_id value in the other table and approximate FDs (AFD) (such as expire_flag 1 dod in PATIENT) become exact in the SPJ view. These FDs are highlighted in grey in the figure . 
Finally, only 10 exact FDs (highlighted in orange) that hold over the view result have to be discovered from scratch from the view. However, if we partially join the two tables, only with the following combinations of tuples: [(#249,#252) or (#249,#251)] and [(#250,#251) or (#250, #252)], we can obtain the remaining 10 join FDs without having to compute the entire view beforehand.</p><p>This example show that with existing FD discovery approaches, the FDs would have to be computed on both the base tables and the integrated view result to preserve the FD provenance information. Furthermore, to identify the provenance of the FDs, a comparison among the two FD sets would have to be performed. We will show the overhead of this process in our experimental study in Section V.</p><p>Hence, a better understanding of the mechanisms underlying the provenance of FDs from integrated views is highly needed. Based on these observations, in our work, we address the following key questions: How can we preserve the provenance of FDs discovered from integrated views? Instead of executing FD discovery over each base table and a SPJ view result independently, can we infer most of the FDs on the view as well as reuse the FDs from the base tables and achieve a non negligible speedup? We answer these key questions in the rest of the paper and propose an efficient solution for discovering FDs from integrated views.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PRELIMINARIES</head><p>Next, we recall the necessary definitions of FDs and join operators with their application to our problem.</p><p>Definition 1 (Functional dependency satisfaction): Let I be an instance over a relation schema R, and X, Y be two sets of attributes from R. I satisfies a functional dependency d : X → Y , denoted by I |= d if and only if:</p><formula xml:id="formula_0">∀t 1 , t 2 ∈ I, t 1 [X] = t 2 [X] ⇒ t 1 [Y ] = t 2 [Y ].<label>(1)</label></formula><p>Note that the above definition holds regardless of the selected null semantics. This implies that our approach is not depending on the underlying semantics of null values, in line with other approaches in the literature <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b17">[18]</ref>. Following the convention, we use uppercase letters for attribute sets and lowercase letters for single attributes. Moreover, in the rest of the paper we use canonical FDs, i.e., minimal FDs with only one attribute in their right-hand part.We recall that for any set of FDs, it can be computed a logically equivalent set of canonical FDs, thus this is done without loss of generality. We define the SPJ view specification and the set of projected attributes over this view as follows:</p><p>Definition 2 (SPJ view specification): Let R = {R 1 ; . . . ; R n } be a set of relational instances. We define a view specification V R as a relational algebra formula over relations in R and limited to the following set of operators: {π; σ; ; ; ; ; ; }. Definition 3 (Projected attributes set): Let V, V 1 , and V 2 be view specifications. Let R be a relational instance. Let X be a set of attributes. Let ρ be a set of constraints. Let atts(S) denotes the set of attributes over a relational instance S. Let be a join operator in { ; ; ; }. Then the set of projected attributes, denoted by proj() is defined as follows:</p><formula xml:id="formula_1">proj(R) = atts(R) proj(V 1 V 2 ) = proj(V 1 ) proj(π X (V)) = X proj(V 1 V 2 ) = proj(V 2 ) proj(σ ρ (V)) = proj(V) proj(V 1 V 2 ) = proj(V 1 ) ∪ proj(V 2 )</formula><p>Finally, we define the types of FDs and the provenance triples derived in our framework and used to maintain the provenance information of every discovered FD. The base FDs are defined as follows:</p><p>Definition 4 (Base FD): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let V R be a view specification over relations in R. Let f ds(R i ) denotes the set of minimal FDs over the relation R i ∈ R. Let f ds(V R ) denotes the set of minimal FDs over the view specified by</p><formula xml:id="formula_2">V R . An FD d is a base FD if d ∈ f ds(V R ) and ∃R i ∈ R s.t. d ∈ f ds(R i ).</formula><p>We now define the notion of upstaged FD, which can occurs either in the case of a selection or of a join operation:</p><p>Definition 5 (Upstaged FD): Let R 1 , R 2 be two relational instances. Let f ds(R i ) denotes the set of minimal FDs over a relational instance R i . An FD d is an upstaged FD for R 1 if d is defined over attributes from R 1 and:</p><p>• in the case of a selection σ ρ (R 1 ):</p><formula xml:id="formula_3">d ∈ f ds(σ ρ (R 1 )) and d ∈ f ds(R 1 ) • in the case of a join R 1 R 2 : d ∈ f ds(R 1 R 2 ) and d ∈ f ds(R 1 )</formula><p>In the following, we distinguish the upstaged FDs by considering if they come from a selection operation or a join operation.</p><p>We also define two types of FDs that arise specifically after a join operation is performed:</p><formula xml:id="formula_4">Definition 6 (Inferred FD): Let R 1 , R 2 be two relational instances. Let f ds(R i ) denotes the set of minimal FDs over a relational instance R i . Let atts(R i ) denotes the set of attributes of R i . Let d : X → y be a FD such that d ∈ f ds(R R ). Then d is an inferred FD if (X ∪ {y}) ∩ atts(R 1 ) = ∅ ∧ (X ∪ {y}) ∩ atts(R 2 ) = ∅</formula><p>and either:</p><p>• d can be inferred through the use of Armstrong's axioms;</p><p>• ∃d : X → y such that X ⊂ X and d can be inferred through Armstrong's axioms. Definition 7 (Join FD):</p><formula xml:id="formula_5">Let d : X → y be a FD such that d ∈ f ds(R R ). Then d is a join FD if (X ∪ {y}) ∩ atts(R 1 ) = ∅ ∧ (X ∪ {y}) ∩ atts(R 2 ) = ∅</formula><p>and d did not belong to the set of inferred FDs. From these types of FDs, we define the provenance triples as follows:</p><p>Definition 8 (FD Provenance Triple): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let V R be a view specification over relations in R. A provenance triple (d, t, s) for an FD d over the view specified by V R is a triple composed of:</p><p>• the FD d whose provenance is described;</p><p>• the type t of d, taking one of the following values: "base", "upstaged selection", "upstaged lef t", "upstaged right", "inf erred" or "joinF D"; • the first sub-query s over the view specification V R in which d holds during the view computation. We illustrate the provenance triples in the following example:</p><p>Example 1: Following the running example of Figure <ref type="figure" target="#fig_0">1</ref>, the provenance triple for FDs subject_id → dob; expire_flag → dod and gender, h_expire_flag → insurance will be the following:</p><formula xml:id="formula_6">(subject_id → dob, "base", ADMISSION) (expire_flag → dod, "upstaged lef t", PATIENT subject id=subject id , ADMISSION) (gender, h_expire_flag → insurance, "join F D", PATIENT subject id=subject id ADMISSION).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. MINING FDS PROVENANCE TRIPLES OVER VIEWS</head><p>In this section, we describe the workflow of InFine to compute FDs and their provenance information from a view specification and the base relations used in the view specification. In this workflow, after discovering FDs from the base tables, we mine the FDs appearing during the view computation by relying as much as possible on inference methods as well as on efficient methods to discover the remaining FDs that cannot be inferred.</p><p>Problem statement. Let R be a set of base tables; V R be a view specification over R. The Inferred FD discovery problem consists of efficiently inferring functional dependencies over the view specified by V R by reusing functional dependencies from R and annotating each FD with its provenance information under the form of a provenance triple.</p><p>In order to compute the functional dependencies for a given view, one needs to tackle the complexity of the FD mining problem and thus to tame the size of explored FDs lattices.</p><p>In the following theorem, we state that at each computation step of a view without projection, the FDs previously mined , , and with continue to be valid. Conversely, we show that the application of a projection can only lead to the suppression of previously valid FDs, and never to the discovery of new FDs. Theorem 1: Let V, V 1 , and V 2 be view specifications. Let D, D 1 and D 2 be the sets of FDs over views specified by V, V 1 and V 2 , respectively. Let f ds(V ) denotes the set of FDs over a view specified by V . Then:</p><formula xml:id="formula_7">{ ◊ ∈ , L R ◊ L R ◊ π ◊ σ { , , ◊ , , L , ,</formula><formula xml:id="formula_8">f ds(π X (V)) ⊆ D, f ds(σ ρ (V)) ⊇ D,<label>and</label></formula><formula xml:id="formula_9">f ds(V 1 V 2 ) ⊇ D 1 ∪ D 2 ,</formula><p>with ∈ { ; ; ; ; ; }.</p><p>Our Solution. In order to compute the set of FDs over integrated views with their provenance information, we propose the workflow illustrated in Figure <ref type="figure" target="#fig_2">2</ref>. It consists of three main steps as follows: (1) Mining of FDs over the base relations, limited to FDs with attributes projected in the resulting view (InFine step 1); (2) Discovery of approximate single-table FDs that are upstaged and become exact FDs via the selection operations (InFine step 2); (3) Discovery of all FDs that can appear via the join operations (InFine step 3). In other words, Step 2 allows to retrieve FDs that are approximate in the individual base tables but become exact due to the selection operations of the SPJ views, whereas Step 3 retrieves FDs due to join operations between multiple base tables including upstaged, inferred and join FDs.</p><p>These steps and their corresponding algorithms are detailed in the next sections, respectively. Their application is done by InFine main algorithm (Algorithm 1) either during initialisation (lines#1-5 for Step 1) or during the recursive traversal of the view specification tree (Subroutine provFDs for Steps 2-3).  </p><formula xml:id="formula_10">15 case πX (V R ) do 16 return provFDs(R, V R , ED, AV ); 17 case σρ(V R ) do 18 P ← provFDs(R, V R , ED, AV ); 19 return P ∪ selectionFDs(R, V R , P, ρ); 20 case V R V R do 21 Prec ← provFDs(R, V R , ED, AV ); 22 Prec ← provFDs(R, V R , ED, AV );</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Reducing Space of Explored Candidates using Projections</head><p>As our goal is to discover the FDs occurring on top of an integrated view, we focus on mining FDs containing only attributes that are retrieved in the output SPJ view.</p><p>The number of considered attributes greatly influences the size of the explored lattices during FD mining. Thus, we make use of the knowledge of the projected attribute set at the very first step of our framework, in order to efficiently reduce the cost of mining FDs from the base relations. This can be seen in the main algorithm of our framework, Algorithm 1, during the mining of the FDs on the base relations (lines # 3-5). After this step, each following step of our framework relies on the FDs mined at the previous steps. Thus, additionally to reducing the FD discovery complexity over the base relations, removing unwanted FDs at this step also prevents useless computation during the following steps of our framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Mining of FDs Through View Selections</head><p>New FDs may appear due to selections in the view definition. This will occur when the selection operation leads to filter the tuples violating an FD, making this FD valid in the resulting instance. In such a case, our framework aims at producing provenance triples for these new FDs with Algorithm 2. This algorithm checks if the selection operation leads to some tuple filtering (from line #4) to avoid unnecessary mining step if the filter is not applicable. If some tuples are filtered by the selection, then upstaged FDs need to be mined and, to do so, we rely on a level-wise approach for FD mining. The intuition behind such an approach is to explore the possible sets of attributes involved in the candidate FDs, by organizing them into a lattice beginning from an infimum with FDs with singleton as lhs (line #5). Then, FD validity is tested and next level candidates are generated (line #11) while taking into account the FDs discovered at previous levels to prune the candidates FDs (lines #8-9). The algorithm stops when no candidates are left, and then the resulting set of minimal FDs are labelled with their provenance triples, the latter being returned by the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2: selectionFDs</head><p>Input: R: a set of relational instances;</p><p>V R : a view specification over instances in R; ρ: the selection condition; PV : the sets of provenance triples of V R ; AV : the set of projected attributes to explore. Result: upstaged FDs provenance triples over V R 1 P ← ∅; 2 DV ← get the set of FDs in the triples in PV ;  </p><formula xml:id="formula_11">3 V sel ← σρ(V R ); 4 if size(V sel ) &lt; size(V R ) then 5 D cand ←</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Mining of FDs from Joined Tables</head><p>In the next sections, we will show how we can mine the upstaged, inferred and join FDs generated during a join operation. In the next theorem, we state that the join order can only affect the type of upstaged FDs which can switch between left or right upstaged FDs:</p><p>Lemma 1 (FD types preservation though join operations): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let f ds(R i ) denotes the set of minimal FDs over the relational instance R i . Let Σ lef t up , Σ right up , Σ inf and Σ join denote the sets of left upstaged, right upstaged, inferred and join FDs over R 1 • • • R n , respectively. Then, the sets Σ lef t up ∪ Σ right up , Σ inf and Σ join are equal regardless of the join order. At the opposite, equality between sets Σ lef t up and Σ right up cannot be guaranteed.</p><p>Next, we show how upstaged FDs can be mined over joins. 1) Mining of Upstaged FDs from Joined Tables: Upstaged FDs may appear due to the join operations in the SPJ view when tuples from one base relation cannot be joined with their counterpart in the other base relation, i.e., when some join at-tribute values are missing in one of the tables. This mechanism is expressed more formally in the following lemma: </p><formula xml:id="formula_12">D new L = {d | d ∈ D L ∧ (L♦ X=Y (π Y (R)) |= d)} (2) D new R = {d | d ∈ D R ∧ (π X (L)♦ X=Y R) |= d)}<label>(3)</label></formula><p>Example 2: To illustrate the case of upstaged join FDs we use the example in Figure <ref type="figure" target="#fig_0">1</ref> To compute upstaged FDs, we propose Algorithm 3. Lines #2-9 handle the inputs of the SPJ view for each table participating in the join operation. For each side of the join, the subroutine upstagedFDs is executed (lines #3 and 7) and computes partially the join only with the join attributes from the left side table (line #13) to check the assumption of the join value set preservation <ref type="bibr" target="#b8">[9]</ref>. If the assumption is violated (i.e., if some tuples have been deleted through the join operation, as checked at line #14), some upstaged join FDs are produced. The subroutine works analogously to Algorithm 2 to discover the FDs in the input instance by using a level-wise approach where the previously discovered FDs are used to improves the pruning of candidates (lines # <ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref>.</p><p>In this algorithm, the computation is performed over upstaged FDs only. Next, we discover the inferred FDs by relying on the characteristics of the join and on the FDs discovered previously.</p><p>2) Mining of Inferred FDs from Joined Tables: We will now show how the inferred FDs can be deduced from the sets of FDs discovered from the tables involved in the join operation. In the next lemma, we show that if the right-hand side (rhs) of an FD is not functionally defined by the set of join attributes, then this FD cannot be an inferred FD in a join result. This property of the join operation is formally defined as follow:</p><p>Lemma 3: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). For all A ⊆ atts(L) \ X and</p><formula xml:id="formula_13">B ⊆ atts(R) \ Y : if L♦ X=Y R |= X → B then L♦ X=Y R |= A → B</formula><p>Example 3: To illustrate the property proved in Lemma 3, we observe that the diagnosis is not determined by the patient identifier in Figure <ref type="figure" target="#fig_0">1</ref>, for example patient #249 has been admitted three times for a different pathology each time, i.e., PATIENT subject_id ADMISSION |= subject_id → diagnosis. From Lemma 3, we know that diagnosis in the join result PATIENT subject_id ADMISSION cannot be determined by any set of attributes coming from PATIENT table. Such similar inferences may be trivial for the user, but they usually require the knowledge of the attribute semantics.</p><p>If not encoded, they are difficult to capture by a system. However, the property shown in Lemma 3 can be used to drastically reduce the set of possible FDs that can appear after a join operation. Intuitively, from Lemma 3 follow that inferring FDs in the results of a join operation using Armstrong's transitivity axiom can only be done if the transitivity is done through the join attributes. This is formalized in the following theorem:</p><p>Theorem 2: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). For all A ⊆ atts(L) \ X and</p><formula xml:id="formula_14">B ⊆ atts(R) \ Y , If L♦ X=Y R |= A → X ∧ L♦ X=Y R |= X → B, Then L♦ X=Y R |= A → B.</formula><p>Example 4: In PATIENT subject_id ADMISSION result illustrated in Figure <ref type="figure" target="#fig_0">1</ref>  To compute the set of FDs with lhs attributes coming from a single instance, as described in Theorem 2, we propose Algorithm 4. First, the subroutine infer extracts the FDs that can be retrieved by transitivity (lines #12 and 13 in subroutine infer). Note that in the case of equijoins, equality of values might be enforced between sets of attributes with different names (i.e., X and Y might be different), thus for the general case, the FD (line #13) cannot be simplified into an FD X → b. Conversely, if we restrict the join operations to natural joins only, such a simplification can be made.</p><formula xml:id="formula_15">3 D inf L ← infer(X,Y ,DV L ,DV R ); 4 D inf R ← infer(Y ,X,DV L ,DV R ); 5 D inf ← D inf L ∪ D inf R ; 6 D ref ← refine(L,R,X,Y ,D inf , ♦);</formula><p>Then, for each FD returned by infer, the subroutine refine checks whether the FD is minimal or if a subset of its lhs leads to a minimal FD. To do so, subroutine refine uses an horizontal partition of the joined instances in which only the necessary attributes to perform the verification are considered (line #19). These necessary attributes are the join attributes (to perform the join operation), and the lhs and rhs attributes of the refined FD A → b (line #18) as refine only considers candidates with subsets of A as lhs and b as rhs (lines #20 and 21).</p><p>3) Mining of Join FDs from Joined Tables: Now, we characterize the set of join FDs which hold on a join result. Contrarily to the inferred FDs that can be deduced directly using a simple logical reasoning, these join FDs need to be discovered and validated from the data. For example, gender, expire_flag→ insurance of our example has attributes from PATIENT in lhs and attributes from ADMISSION in rhs and it cannot be inferred logically. Other FDs with the same properties are illustrated in orange in Figure <ref type="figure" target="#fig_0">1</ref>. In the following theorem, we show that if lhs attributes of an FD come from the instances participating in the join, then we cannot predict their validity without checking them directly with some representative (if not all) tuples of the join result:</p><p>Theorem 3: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). We cannot guarantee that all FDs over L♦ X=Y R can be inferred from Armstrong's axioms over the FDs over L and R taken separately. Such FDs are illustrated in the following example:</p><p>Example 5: In our example of Figure <ref type="figure" target="#fig_0">1</ref>, FDs that cannot be inferred are highlighted in orange. For example, gender, h_expire_flag→ insurance is specific to the join of PATIENT and ADMISSION. It holds in PATIENT ADMISSION. Attributes gender and expire_flag come from PATIENT and attribute insurance comes from ADMISSION.</p><p>Theorem 3 motivates the need for designing a new method for computing FDs from partial join results, as we cannot always infer all the FDs only using logical reasoning. However, we can rely on the following theorem to greatly reduce number of remaining FDs to check from the data:</p><p>Theorem 4: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). For all A ⊆ atts(L), A ⊆ atts(R) and b ∈ atts(R):</p><formula xml:id="formula_16">If L♦ X=Y R |= AA → b, Then L♦ X=Y R |= Y A → b.</formula><p>In-line with Theorem 4, we propose Algorithm 5 for selective mining and use the FDs previously discovered with Algorithms 3 and 4 to compute the remaining join FDs. Intuitively, Theorem 4 shows that a given attribute b can be a rhs of a remaining join FDs only if we have previously found an FD of the form Y A → b with Y being the join attributes of the instance containing b. Thus, it allows us to focus only on the plausible rhs (lines #11 and 15 in subroutine discover) and explore their candidate lhs (lines #12-13 and 16-17). In practice, there is no need to generate every candidate FDs initially. Instead, candidate FDs can be explored by generating a first level containing only the smallest candidates and by generating upper levels only when currently evaluated candidates are not valid. Moreover, we can avoid the computation of the full join by deleting a given lhs attribute a if a is not a possible rhs and, for every FD candidate d : A → b such that a ∈ A, d is logically implied by previously discovered FDs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Completeness, Correctness, and Complexity</head><p>In this section we show that the set of FDs retrieved by InFine is both complete and correct, and present our solution complexity. First, we show that InFine always retrieve every functional dependency in the specified SPJ view. Theorem 5 (InFine completeness): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let V R be a view specification over relations in R. Let f ds(V R ) denotes the set of minimal FDs over the view specified by V R . Let f ds(InFine ) denotes the set of FDs computed by InFine over the view specified by V R . Then:</p><formula xml:id="formula_17">∀d ∈ f ds(V R ), ∃d ∈ f ds(InFine ) s.t. d ≡ d</formula><p>This establish the completeness of our approach. Now, in the next theorem, we show that every FD retrieved by InFine is valid in the specified SPJ view:</p><p>Theorem 6 (InFine correctness): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let V R be a view specification over relations in R. Let I V R be the view specified by V R . Let f ds(InFine ) denotes the set of FDs computed by InFine over the view specified by V R . Then:</p><formula xml:id="formula_18">∀d ∈ f ds(InFine ), I V R |= d</formula><p>We now detail the complexity of our algorithms. Algorithms 2 and 3 are based on level-wise algorithms through the attributes lattices. Their complexity is exponential in the number of attributes of the considered table. They prune candidates at each level when it is possible. In terms of memory, only two levels are required.  </p><formula xml:id="formula_19">(f • f j )</formula><p>where f is the maximal number of validated FDs in the left or right instance and f j the number of validated FDs in the join instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTS</head><p>Evaluation Goals. The two main points we seek to validate in our experimental study are as follows: (1) Does our approach enable us to discover all FDs with their provenance information in an efficient manner and faster than the straightforward approach? (2) What is the impact of different data and SPJ view characteristics on the InFine performance?</p><p>Setup. We perform all experiments on a laptop HP ZBook 15 machine with an Intel Core i7-4900MQ, 2.8 GHz, 32 GB RAM, powered by Windows 10 pro 64-bit. Our implementation in C++ uses only one thread. Sharable datasets, SPJ queries, scripts, and code are available at https://github.com/ ucomignani/InFine.</p><p>Data. We use three real-world datasets and one synthetic dataset in our experiments: (1) MIMIC-3, a clinical database<ref type="foot" target="#foot_0">3</ref>  <ref type="bibr" target="#b13">[14]</ref>; (2) PTE <ref type="foot" target="#foot_1">4</ref> , a database for predictive toxicology evaluation, used to predict whether a compound is carcinogenic, and (3) PTC <ref type="foot" target="#foot_2">5</ref> , the dataset from the Predictive Toxicology Challenge that consists of more than three hundreds of organic molecules marked according to their carcinogenicity on male and female mice and rats; and (4) the TPC-H Benchmark<ref type="foot" target="#foot_3">6</ref> with scalefactor 1. The datasets characteristics are given in Table <ref type="table" target="#tab_5">I</ref> and the characteristics of the queries corresponding to the views on the above datasets are provided in Table <ref type="table" target="#tab_7">II</ref>  benchmarking FD discovery methods consist of single tables, while we use multi-table scenarios. Note that the numbers of discovered FDs in the literature datasets are not comparable as we do not employ the same datasets due to the SPJ views studied in our approach. To handle multiple tables with SPJ queries, we propose our own benchmark datasets along with views on top of them. We adapted TPC-H queries by removing group-by and order-by statements (that are not addressed in our approach) and used the specified constants <ref type="foot" target="#foot_4">7</ref> . SPJ queries for the other datasets were manually crafted to make use of multiple tables and obtain joins of various sizes (from 2 to 6 tables), number of tuples (from 299 to 3 millions), and coverage values (from 0.12 to 25,812.67) to show the performances of our method comparatively in a large and representative range of SPJ views. We observed that the cardinalities and overlap of the join attribute values in the datasets are rarely preserved through a join operation and this has a great impact on FD discovery from SPJ queries depending on the join operator used. To quantify this phenomenon, we define a measure called coverage as follows:</p><formula xml:id="formula_20">Coverage(R♦L) = 1 2 Cov(R♦L, L, X) + Cov(R♦L, R, Y ) with Cov(Join, I, a) = 1 |π a (I)| ∀v∈πa(I) |σ a=v (Join))| |σ a=v (I)| .</formula><p>where X and Y denote the join attributes of L and R base tables respectively. I is a considered instance and a the considered join attribute. If Coverage(R♦L) = 0, no tuple from L can be joined with tuples in R. For Coverage(R♦L) &lt; 1, some tuples in L (or R) may be missing from the join result, as it is the case for patients #257 in PATIENT and #247, #248, and #253 in ADMISSION that do not have their counterparts in the other table in our example. For Coverage(R♦L) = 1, there are as many tuples in both tables L and R as in the join result.</p><p>For Coverage(R♦L) &gt; 1, there are more tuples in the join result than in tables L or R as some tuples may be repeated through the join. The coverage values of the corresponding views are given in Table <ref type="table" target="#tab_9">III</ref>.</p><p>Methods. We compare the InFine algorithms applied to base tables against four state-of-the-art FD discovery methods, i.e.:</p><p>(1) TANE <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, (2) Fast FDs <ref type="bibr" target="#b28">[29]</ref>, and (3) FUN <ref type="bibr" target="#b20">[21]</ref>, and (4) HyFD <ref type="bibr" target="#b24">[25]</ref> with Java implementation of Metanome <ref type="bibr" target="#b22">[23]</ref> using command line. The datasets employed in our study are stored in a PostgresSQL DBMS (version 12.7). Join attributes are indexed with both B-Tree and hash indexes. The reported results correspond to the average over 10 runs for each query.</p><p>Metrics. We compute accuracy, average runtime, and maximal memory consumption for each view. In our setting, accuracy corresponds to precision and is defined as the fraction of the number of FDs correctly discovered by InFine applied only to the base tables over the total number of FDs found by baseline methods classically applied to the SPJ view results. Accuracy values are given in Table <ref type="table" target="#tab_9">III</ref> and represented as percentages in pie charts of Fig. <ref type="figure" target="#fig_8">5</ref>. All methods (including ours) reach accuracy of 1 at the end of their execution.</p><p>Comparison Setup. Our goal is to compare our method which discovers FDs from a SPJ view specification and base tables and provides FD provenance information against the straightforward approach which consists of discovering all the FDs from each base table, computing the view result, and discovering the FDs on top of the latter. Classical methods do not provide provenance information. Then, a fair comparison requires the preservation of FD provenance information from the base tables to the view. To know the origin of each FD, both the baselines and our approach have to discover FDs from the base tables first. Since these execution times are the same in both cases, we don't include them. On the one hand, the competing methods are applied to each SPJ view result and we report their average execution time to which we added the execution time of the full SPJ view computation. On the other hand, InFine is applied to the base tables only and it computes a partial SPJ view depending on the view specification (query sub-tree) and generate FD provenance triples; we report InFine average execution time with time breakdown per algorithm. The time of the partial SPJ view computation is included in mineFDs. The generation of provenance triples is included in the execution of each InFine algorithm in charge of annotating each FD accordingly. Total I/O times of InFine are also reported in Table <ref type="table" target="#tab_9">III</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Efficiency Evaluation</head><p>In a first set of experiments, we evaluate the runtime and memory consumption of the InFine algorithms compared to the state-of-the-art FD discovery methods that follow the straightforward approach over the 16 SPJ queries on the real-world and synthetic datasets with a wide range of coverage values. The selected queries are representative in terms of coverage and size (number of tables, tuples, and attributes). Results for other queries follow the same trend and are available as supplementary material on Github. 1) Runtime: Fig. <ref type="figure">3</ref> presents, for each method, the average total runtime in seconds for FD discovery (including data loading) in log scale. For the competing methods, we included the average execution time of the SPJ view over the indexed data. Similarly, we included the partial SPJ view computation time included in mineFDs. For all methods including ours, we did not include the time for discovering FDs from base tables since these costs are the same. Since our method does not require the full SPJ view computation to discover FDs and does not operate over the query result but only on the single base tables, it is much faster than the traditional methods with one order of magnitude on average up to two orders of magnitude compared to Fast FDs (&gt; 2, 000 seconds). A provenance triple is generated each time an FD is validated by one of the InFine algorithms and is appended to the corresponding FD data structures with negligible time (included in each algorithm execution time). For MIMIC3 and TPC-H SPJ queries with the highest values for coverage and number of tuples (e.g., Q9 * and Q11 * ), InFine is still outperforming the other methods. The time difference between full and partial SPJ computations shown in Fig. <ref type="figure">3</ref> also explains the advantage of our approach.</p><p>2) Memory Consumption: As shown in Fig. <ref type="figure">4</ref>, the average maximal memory consumption of InFine (for accuracy equals 1) is the lowest for all queries across the datasets. HyFD has the second position in terms of memory consumption efficiency and TANE is the worst one. For all methods, Q9 * has the highest memory consumption due to its large size of ), and the number of joins between 6 tables. This case is an example of a worst case scenario where many tuples are repeated through the join of the base tables. FD discovery from Q9 * requires the mining and checking of all the valid FDs and storing all the relevant information. In this particular case, InFine time performance becomes comparable to HyFD over the full SJP view computation (due to mineFDs), although all FDs were discovered before by upstageFDs and inferFDs (see Fig. <ref type="figure" target="#fig_8">5</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Quality Evaluation</head><p>In Fig. <ref type="figure" target="#fig_8">5</ref>, we report the average runtime breakdown of each algorithm upstageFDs, inferFDs, and mineFDs of InFine (as horizontal histograms) and their respective percentages of discovered FDs (in the corresponding pie charts with the same color coding). Error bars represent the standard deviation of the average total runtime of InFine algorithms. selectionFDs's time is included in upstageFDs's time. Various base table data distributions, SPJ views, and coverage values with very different characteristics across the datasets illustrate the behavior of our algorithms.</p><p>Noticeably, upstageFDs can retrieve from 33.3% to 59% of the FDs in MIMIC3 in 0.75ms on average, from 58.3% to 75% in PTC in 1.12ms, from 66.7% to 100% in PTE in 1.5ms, and from 42.8.7% to 87.5% in TPC-H in 7.65ms, which are negligible times compared to mineFDs time and I/O time, the most time-consuming steps. Table <ref type="table" target="#tab_9">III</ref> gives the number of FDs retrieved by each algorithm and time breakdowns.</p><p>The logical inference times are negligible (below 0.0001 ms) and are not reported in the table. inferFDs can retrieve 100% of the FDs for 3 queries over PTE. In some cases, mineFDs is executed but does not return any new FD (e.g., Q * 9 in TPC-H or [atm bond atm] drug), whereas in the other queries, mining subsets of the SPJ view using mineFDs is necessary to recover the remaining FDs. Without computing and mining the join results, upstageFDs and inferFDs can retrieve 83.01% of FDs (68.38±20.00 and 14.63±15.47, respectively) on average across all the datasets. We also observed that join ordering does not affect the total number of discovered FDs, but it changes FD provenance. The main reason is due to the difference in the query execution sub-trees triggering different FD validation by each InFine algorithm.</p><p>It should be noted that, due to the NP-completeness of the FD mining problem (cf. <ref type="bibr" target="#b6">[7]</ref>), this exploration is necessary to ensure that no valid FD is missed.</p><p>These results clearly show the main advantages of our approach, reducing drastically the execution time of FD discovery from SPJ queries with minimal memory consumption, outperforming all the state-of-the art methods tested in our experiments over a large representative range of queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>In the last three decades, numerous approaches from the database and the data mining communities have been proposed to extract automatically valid exact and approximate FDs from single relational tables <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b4">[5]</ref>. Liu et al. <ref type="bibr" target="#b18">[19]</ref>   where k is the number of attributes and n the number of records considered. To find FDs efficiently, existing approaches can be classified into three categories: (1) Tuple-oriented methods (e.g., FastFDs <ref type="bibr" target="#b28">[29]</ref>, DepMiner <ref type="bibr" target="#b19">[20]</ref>) that exploit the notion of tuples agreeing on the same values to determine the combinations of attributes of an FD; (2) Attribute-oriented methods (e.g., Tane <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref>, Fun <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b21">[22]</ref>, FDMine <ref type="bibr" target="#b29">[30]</ref>) that use pruning techniques and reduce the search space to the necessary set of attributes of the relation to discover exact and approximate FDs. HyFD <ref type="bibr" target="#b24">[25]</ref> exploits simultaneously the tuple-and attribute-oriented approaches to outperform the previous approaches; and more recently (3) Structure learning methods relying on sparse regression <ref type="bibr" target="#b30">[31]</ref>, or on entropy-based measures <ref type="bibr" target="#b14">[15]</ref> to score candidate constraints (not limited to FDs alone). More particularly, FDX <ref type="bibr" target="#b30">[31]</ref> performs structure learning over a sample constructed by taking the value differences over sampled pairs of tuples from the raw data. In addition, incremental approaches (e.g., <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b3">[4]</ref>) have been developed to tackle data volume and velocity with updating all valid FDs when new tuples are inserted outperforming classical approaches that recalculate all FDs after each data update. Extensive evaluations of FD discovery algorithms can be found in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b23">[24]</ref>. To the best of our knowledge, previous work on FD discovery did not attempt to address the problem of FD discovery from integrated views in an efficient manner while preserving data provenance. Our approach combining logical inference and selective mining from the base tables adapting FD lattice approach avoids the full computation of FDs from the views and it is the first solution in this direction.</p><p>The problem of deciding whether a semantic constraint (being a FD or a Join Dependency) is valid on a tableau view, knowing that it is valid on the base relations has been addressed by Klug et al. <ref type="bibr" target="#b16">[17]</ref>. However, their view constraint problem and FD implication is inherently different from our FD inference problem, and allowing to reuse discovered FDs of base tables while annotating them with provenance information and efficiently recomputing FDs that are valid on the and are not valid on the base tables (as stated in Th.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5)</head><p>. Moreover, the underlying technique employed in <ref type="bibr" target="#b16">[17]</ref> and used for checking the validity of FDs leverages the tableau chase as opposed to using the FD lattice, the latter being a well established efficient method for FD discovery. The problem of propagating XML keys to relations is an orthogonal problem with respect to ours <ref type="bibr" target="#b5">[6]</ref>. The simple mapping language from XML to relations and the restriction to XML keys, that cannot capture relational functional dependencies, is specific to this work as also stated in their paper <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSIONS</head><p>We addressed the problem of FD discovery from integrated views starting from the FDs of multiple base tables by avoiding the full computation of the view beforehand. The salient features of our work are the following: (1) We leverage singletable approximate FDs that become exact FDs due to the join operation; <ref type="bibr" target="#b1">(2)</ref> We leverage logical inference to discover FDs from the base tables without computing the full view result; and (3) We find new multi-table join FDs from partial join using selective mining on the necessary attributes. We empirically show that InFine outperforms, both in terms of runtime and memory consumption, the state-of-the-art FD discovery methods applied to the SPJ views that have to be computed beforehand. We hope that our work will open a new line of research for reusing the FDs discovered from multiple base tables. Various orderings of the base tables lead to different sets of potential upstaged FDs, which, in turn, may trigger different logical inferences. Future work will be to find the optimal ordering of the base tables to reduce the overall execution time and memory consumption.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Excerpt of the MIMIC-III clinical database with FDs on base tables and integrated view (best viewed in color).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>FDs from Logical inference of FDs for FD Discovery from the projection on the base relations in V Output: Sets of FDs discovered from L and R and set of inferred FDs from the view specification V with provenance metadata Integrated view specification V applied to base relational instances L and R with operators :</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Workflow of InFine for discovering inferred FDs from a view specification V (L, R)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 1 : 8 switch V R do 9 case R ∈ R do 10 P ← ∅; 11 D</head><label>1891011</label><figDesc>InFineInput: R: a set of relational instances;V R : a view specification over instances in R. Result: the set of provenance triples of the FDs over V R . 1 ED ← ∅; 2 AV ← compute the set of attributes proj(V R ) ; 3 for each relation Ri ∈ R do 4 DR i ← compute FDs in Ri limited to attributes in AV ; 5 add DR i to ED; 6 return provFDs(R, V R , ED, AV ); 7 Subroutine provFDs(R, V R , ED, AV ) ← get DR in ED; 12 for each FD d ∈ D do 13 add triple (d, "base", R) to P 14 return P;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>23 24 P</head><label>24</label><figDesc>Pup ← joinUpFDs (AV ); inf ←inferFDs (); 25 Pjoin ←joinFDs (); 26 return Prec ∪ Pup ∪ P inf ∪ Pjoin ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>12 until</head><label>12</label><figDesc>D cand = ∅; 13 for each FD d ∈ Dout do 14 add triple (d, "upstaged selection", V R ) to P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 2 (</head><label>2</label><figDesc>Upstaged join FDs): Let L and R be two instances over relations S and T, respectively, and D L and D R be the two sets of all FDs such that L |= D L and R |= D R , respectively. Then the sets of upstaged join FDs denoted D new L and D new R are the sets:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>17 Let</head><label>17</label><figDesc>7 for each FD d ∈ D ref do 8 add triple (d, "inferred", VL♦VR) to P 9 return P; 10 Subroutine infer(X,Y ,D, D ) 11 Dout ← ∅; 12 forall A → X in D do 13 forall Y → b in D do 14 add A → b to Dout; 15 return Dout; 16 Subroutine refine(L,R,X,Y ,D inf , ♦) Dout ← D inf ; 18 forall A → b in D inf do 19 Let I ← πX∪A(L)♦π Y ∪{b} (R); 20 forall A ⊂ A do 21 if A → b holds in I then 22 add A → b to Dout; 23 prune non-minimal FDs in Dout knowing that A → b is valid; 24 return Dout;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Algorithm 5 :</head><label>5</label><figDesc>mineFDsInput: VL, VR: two view specifications; X, Y : the sets of join attributes for VL and VR; ♦: a join operator in { ; ; ; ; ; }; PV L , PV R : the provenance triples sets of VL and VR; P inf V L ♦V R : the inferred provenance triples set. Result: join FDs provenance triples over L♦X=Y R 1 D inf ← get the set of FDs in the triples inP inf V L ♦V R ; 2 DV L ← get the set of FDs in the triples in PV L ; 3 D lef t ← mine(L,R,X,Y ,DV R ,D inf );4 DV R ← get the set of FDs in the triples in PV R ; 5 D right ← mine(R,L,Y ,X,DV L ,D inf ); 6 for each FD d ∈ D lef t ∪ D right do 7 add triple (d, "joinFD", VL♦VR) to P 8 return P; 9 Subroutine mine(I,J,X,Y ,DJ ,D inf ) 10 Dout ← ∅; 11 forall Y → b in DJ do 12 forall A ⊆ atts(I) \ X do 13 if ∃A ⊂ A, A → b ∈ D inf and A → b holds in I♦J then 14 add A → b to Dout; 15 forall Y A → b ∈ DJ such that A → b do 16 forall A ∪ A → b such that A ⊆ atts(I) \ X do 17 if A ∪ A → b holds in I♦J then 18 add A ∪ A → b to Dout; 19 return Dout;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 3 :Fig. 4 :</head><label>34</label><figDesc>Fig. 3: Average runtime (in seconds): InFine against HyFD, FastFDs, FUN, and TANE with full and partial SPJ computation</figDesc><graphic coords="11,104.27,276.26,176.03,67.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Average runtime and accuracy of InFine with breakdown per algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>this end, we propose InFine, an efficient solution for automatically discovering multi-relation FDs starting from the FDs of the</figDesc><table><row><cell>9 Exact FDs from PATIENTS</cell><cell cols="3">ADMISSION</cell><cell></cell><cell></cell></row><row><cell></cell><cell cols="2">subject_id admittime</cell><cell>admission_location</cell><cell>insurance</cell><cell>diagnosis</cell><cell>h_expire_flag</cell></row><row><cell></cell><cell>247</cell><cell cols="3">03/08/56 20:35 CLINIC REFERRAL/PREMATURE HOME UNOBTAINABLE</cell><cell>CHEST PAIN</cell><cell>0</cell></row><row><cell></cell><cell>248</cell><cell>19/10/42 16:30</cell><cell>EMERGENCY ROOM ADMIT</cell><cell>Private</cell><cell>S/P MOTOR ROLLOR</cell><cell>0</cell></row><row><cell></cell><cell>249</cell><cell>17/12/49 20:41</cell><cell>EMERGENCY ROOM ADMIT</cell><cell>Medicare</cell><cell>UNSTABLE ANGINA ASTHMA BRONCHITIS</cell><cell>0</cell></row><row><cell></cell><cell>249</cell><cell>03/02/55 20:16</cell><cell>EMERGENCY ROOM ADMIT</cell><cell>Medicare</cell><cell>CHEST PAIN</cell><cell>0</cell></row><row><cell></cell><cell>249</cell><cell>27/04/56 15:33</cell><cell>PHYS REFERRAL/NORMAL DELI</cell><cell>Medicare</cell><cell>GI BLEEDING\COLONOSCOPY</cell><cell>0</cell></row><row><cell></cell><cell>250</cell><cell>12/11/88 09:22</cell><cell>EMERGENCY ROOM ADMIT</cell><cell>Self Pay</cell><cell>PNEUMONIA R/O TB</cell><cell>1</cell></row><row><cell></cell><cell>251</cell><cell>27/07/10 06:46</cell><cell>EMERGENCY ROOM ADMIT</cell><cell>Private</cell><cell>INTRACRANIAL HEAD BLEED</cell><cell>0</cell></row><row><cell></cell><cell>252</cell><cell>31/03/33 04:24</cell><cell>EMERGENCY ROOM ADMIT</cell><cell>Private</cell><cell>GASTROINTESTINAL BLEED</cell><cell>0</cell></row><row><cell></cell><cell>252</cell><cell>15/08/33 04:23</cell><cell>EMERGENCY ROOM ADMIT</cell><cell>Private</cell><cell>GASTROINTESTINAL BLEED</cell><cell>0</cell></row><row><cell></cell><cell>253</cell><cell>21/01/74 20:58</cell><cell>TRANSFER FROM HOSP/EXTRAM</cell><cell>Medicare</cell><cell>COMPLETE HEART BLOCK\PACEMAKER IMPLANT</cell><cell>0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>generate candidate FDs for first level of V R ;</figDesc><table /><note><p><p>6</p>prune FDs in D sel with attributes not in AV ; 7 repeat 8 prune non-minimal FDs in D cand knowing Dout ; 9 prune non-minimal FDs in D cand knowing DV ; 10 add to Dout the FDs from D cand holding in V ; 11 D cand ← generate candidate FDs for next level;</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>. The FD expire_flag 1 dod in Table PATIENT is violated by the presence of two tuples for patient (#257). However, in the join result of PATIENT subject_id ADMISSION, the violating tuple #257 has no counterpart in the ADMISSION table and it disappears from the join result. Consequently, the FD expire_flag → dod becomes valid in the join result. DV L ← get the set of FDs in the triples in PV L ;</figDesc><table><row><cell>Algorithm 3: joinUpFDs</cell></row></table><note><p>Input: VL, VR: two view specifications; X, Y : the sets of join attributes for VL and VR; ♦: a join operator in { ; ; ; ; ; }; PV L , PV R : the provenance triples sets of VL and VR; AV : the set of projected attributes to explore. Result: upstaged FDs provenance triples over VL and VR 1 P ← ∅; 2 3 D up lef t ← upstagedFDs(VL, VR, X, Y , DV L ,AV ); 4 for each FD d ∈ D up lef t do 5 add triple (d, "upstaged left", VL♦VR) to P; 6 DV R ← get the set of FDs in the triples in DVR; 7 D up right ← upstagedFDs(VR, VL, Y , X, DV R ,AV ); 8 for each FD d ∈ D up right do 9 add triple (d, "upstaged right", VL♦VR) to P; 10 return P; 11 Subroutine upstagedFDs(I,J,X,Y ,D,AV ) 12 Dout ← ∅; 13 Ijoin ← I♦X=Y (πY (J)); 14 if size(Ijoin) &lt; size(I) then 15 D cand ← generate candidate FDs for first level of Ijoin; 16 prune FDs in D cand with attributes not in AV ; 17 repeat 18 prune non-minimal FDs in D cand knowing Dout; 19 prune non-minimal FDs in D cand knowing DV ; 20 add to Dout the FDs from D cand holding in I; 21 D cand ← generate candidate FDs for next level; 22 until D cand = ∅; 23 return Dout</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>, we observe that the diagnosis determines the date of birth, i.e., diagnosis → dob. The reason is that we have: admission_location, diagnosis → subject_id in ADMISSION and subject_id → dob in PATIENT. Since these tables do not contain any null values for the lhs and rhs attributes, joining them with attribute subject_id leaves these FDs unchanged with no violation. By transitivity, we obtain: diagnosis → dob. VL, VR: two view specifications; X, Y : the sets of join attributes for VL and VR; ♦: a join operator in { ; ; ; ; ; }; PV L , PV R : the provenance triples sets of VL and VR; AV : the set of projected attributes to explore. Result: inferred FDs provenance triples over L♦X=Y R 1 DV L ← get the set of FDs in the triples in PV L ; 2 DV R ← get the set of FDs in the triples in PV R ;</figDesc><table><row><cell>Algorithm 4: inferFDs</cell></row></table><note><p>Input:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>The memory size is bounded by O k k/2 where k is the number of attributes. Algorithm 4 infers and refines FDs coming from the previous step with complexity O(n • f ), where f is the number of</figDesc><table><row><cell>DB</cell><cell>Table</cell><cell>(Att# ; Tuple#)</cell><cell>FD#</cell></row><row><cell></cell><cell>Patients</cell><cell>(7 ; 46.52k)</cell><cell>11</cell></row><row><cell cols="2">MIMIC3 Admissions</cell><cell>(18 ; 58.976k)</cell><cell>631</cell></row><row><cell></cell><cell>Diagnoses icd</cell><cell>(4 ; 651.047k)</cell><cell>2</cell></row><row><cell></cell><cell>D icd Diagnoses</cell><cell>(3 ; 14.710k)</cell><cell>2</cell></row><row><cell></cell><cell>active</cell><cell>(2; 300)</cell><cell>1</cell></row><row><cell>PTE</cell><cell>bond</cell><cell>(4 ; 9.317k)</cell><cell>3</cell></row><row><cell></cell><cell>atm</cell><cell>(5 ; 9.189k)</cell><cell>5</cell></row><row><cell></cell><cell>drug</cell><cell>(1 ; 340)</cell><cell>0</cell></row><row><cell></cell><cell>atom</cell><cell>(3; 12.333k)</cell><cell>2</cell></row><row><cell>PTC</cell><cell>connected</cell><cell>(3 ; 24.758k)</cell><cell>3</cell></row><row><cell></cell><cell>bond</cell><cell>(3 ; 12.379k)</cell><cell>2</cell></row><row><cell></cell><cell>molecule</cell><cell>(2 ; 343)</cell><cell>1</cell></row><row><cell></cell><cell>Supplier</cell><cell>(7 ; 10k)</cell><cell>34</cell></row><row><cell>TPC-H</cell><cell>Customer</cell><cell>(8 ; 150k)</cell><cell>51</cell></row><row><cell></cell><cell>Orders</cell><cell>(9 ; 1.5M)</cell><cell>53</cell></row><row><cell></cell><cell>LineItem</cell><cell cols="2">(16 ; 6M) 3946</cell></row><row><cell></cell><cell>Nation</cell><cell>(4 ; 23)</cell><cell>9</cell></row><row><cell></cell><cell>Region</cell><cell>(3 ; 5)</cell><cell>6</cell></row><row><cell></cell><cell>Part</cell><cell>(7 ; 200k)</cell><cell>99</cell></row><row><cell></cell><cell>Partsupp</cell><cell>(5 ; 800k)</cell><cell>11</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE I :</head><label>I</label><figDesc>Data characteristics. validated FDs and n the maximal number of tuples in the left or right instance. The complexity of Algorithm 5 is O</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>. To the best of our knowledge, all the datasets used in the literature for</figDesc><table><row><cell cols="4">DB SPJ View</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Tuple# FD#</cell></row><row><cell>MIMIC3</cell><cell cols="8">Q(patients diagnosesicd dicddiagnoses [diagnosesicd patients] admissions) patients diagnosesicd dicddiag-</cell><cell>58,976 58,798 658,498 658,498</cell><cell>16 12 22 44</cell></row><row><cell></cell><cell>noses</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>atom</cell><cell></cell><cell cols="2">molecule</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>9,111</cell><cell>4</cell></row><row><cell>PTC</cell><cell cols="3">connected [connected</cell><cell cols="2">bond bond]</cell><cell cols="3">molecule</cell><cell>24,758 18,312</cell><cell>8 12</cell></row><row><cell></cell><cell cols="6">connected id1 [atom</cell><cell cols="2">molecule]</cell><cell>18,312</cell><cell>12</cell></row><row><cell></cell><cell>atm</cell><cell cols="2">drug</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>9,189</cell><cell>5</cell></row><row><cell>PTE</cell><cell>active [bond</cell><cell></cell><cell cols="2">drug drug]</cell><cell cols="2">active</cell><cell></cell><cell></cell><cell>299 7,994</cell><cell>1 6</cell></row><row><cell></cell><cell>[atm</cell><cell></cell><cell>bond</cell><cell cols="2">atm]</cell><cell></cell><cell>drug</cell><cell></cell><cell>9,317</cell><cell>24</cell></row><row><cell>TPC-H</cell><cell cols="2">Q2  *  (P Q3  *  (C Q9  *  (P Q11  *  (P</cell><cell>PS O PS S</cell><cell cols="2">S L) S N)</cell><cell>N L</cell><cell>R) O</cell><cell>N)</cell><cell>21,696 60,150 3,735,632 284,160</cell><cell>69 14 8 151</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE II :</head><label>II</label><figDesc>SPJ queries considered in our experiments.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>have shown</figDesc><table><row><cell>DB</cell><cell cols="2">SPJ View</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(Att# ; Tuple#)</cell><cell>Cov.</cell><cell>UpstageFDs</cell><cell>InferFDs</cell><cell>MineFDs</cell><cell>Total Accu-</cell><cell>I/O (s)</cell><cell>upstageFDs</cell><cell>mineFDs</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Accuracy</cell><cell>Accuracy</cell><cell>Accuracy</cell><cell>racy (FD#)</cell><cell>(s)</cell><cell>(s)</cell></row><row><cell></cell><cell>atm</cell><cell cols="2">drug</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(5 ; 9,189)</cell><cell>14.01</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell>1 (5 FDs)</cell><cell>0.0246</cell><cell>0.0000</cell><cell>0.0000</cell></row><row><cell>PTE</cell><cell>active [bond</cell><cell cols="3">drug drug]</cell><cell cols="2">active</cell><cell></cell><cell></cell><cell>(2 : 299) (6 ; 7,994)</cell><cell>0.94 13.83</cell><cell>1 0.67</cell><cell>0 0.33</cell><cell>0 0</cell><cell>1 (1 FD) 1 (6 FDs)</cell><cell>0.0015 0.0215</cell><cell>0.0000 0.0030</cell><cell>0.0000 0.0000</cell></row><row><cell></cell><cell>[atm</cell><cell cols="2">bond</cell><cell cols="2">atm]</cell><cell></cell><cell>drug</cell><cell></cell><cell>(14 ; 9,317)</cell><cell>14.20</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell>1 (24 FDs)</cell><cell>0.0879</cell><cell>0.0030</cell><cell>0.0492</cell></row><row><cell></cell><cell>atom</cell><cell cols="3">molecule</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(4 ; 9,111)</cell><cell>13.67</cell><cell>0.75</cell><cell>0.25</cell><cell>0</cell><cell>1 (4 FDs)</cell><cell>0.0231</cell><cell>0.0000</cell><cell>0.0015</cell></row><row><cell>PTC</cell><cell cols="3">connected [connected</cell><cell cols="2">bond bond]</cell><cell cols="2">molecule</cell><cell></cell><cell>(5 ; 24,758) (6 ; 18,312)</cell><cell>1.50 27.08</cell><cell>0.625 0.75</cell><cell>0.375 0.25</cell><cell>0 0</cell><cell>1 (8 FDs) 12 (12FDs)</cell><cell>0.1012 0.0686</cell><cell>0.0015 0.0000</cell><cell>0.0015 0.0030</cell></row><row><cell></cell><cell cols="6">connected id1 [atom</cell><cell cols="2">molecule]</cell><cell>(6 ; 18,312)</cell><cell>27.08</cell><cell>0.583</cell><cell>0.417</cell><cell>0</cell><cell>1 (12 FDs)</cell><cell>0.0903</cell><cell>0.0030</cell><cell>0.0045</cell></row><row><cell>MIMIC3</cell><cell cols="3">diagnosesicd dicddiagnoses [diagnosesicd Q(patients</cell><cell cols="5">patients diagnosesicd patients] dicddiagnoses admissions)</cell><cell>(12 ; 651,047) (7 ; 658,498) (14 ; 658,498) (10 ; 6,736)</cell><cell>7.50 22.84 22.84 0.79</cell><cell>0.591 0.333 0.545 0.563</cell><cell>0.273 0 0 0</cell><cell>0.136 0.667 0.455 0437</cell><cell>1 (22 FDs) 1 (12 FDs) 1 (44 FDs) 1 (16 FDs)</cell><cell>2.1876 1.7202 5.1232 0.2360</cell><cell>0.0015 0.0000 0.0000 0.0015</cell><cell>2.3120 0.3497 6.1325 0.0230</cell></row><row><cell>TPC-H</cell><cell cols="2">Q2  *  (P Q3  *  (C Q9  *  (P Q11  *  (P</cell><cell>PS O PS S</cell><cell cols="2">S L) S N)</cell><cell>N L</cell><cell>R) O</cell><cell>N)</cell><cell>(10 ; 21,696) (6 ; 60,150) (9 ; 3,735,632) (15 ; 284,160)</cell><cell cols="2">1.50 0.12 25,813 0.875 0.594 0.429 80.09 0.636</cell><cell>0.087 0 0.125 0.232</cell><cell>0.319 0.571 0 0.132</cell><cell>1 (69 FDs) 1 (14 FDs) 1 (8 FDs) 1 (151 FDs)</cell><cell>0.1299 13.036 16.967 13.771</cell><cell>0.0045 0.0000 0.0015 0.0246</cell><cell>0.0120 0.0198 12.1261 0.5777</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>TABLE III :</head><label>III</label><figDesc>Accuracy and time breakdowns of InFine algorithms that the complexity of FD discovery is in O(n 2 ( k 2 ) 2 2 k )</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>https://physionet.org/content/mimiciii/1.4/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>https://relational.fit.cvut.cz/dataset/PTE</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>https://relational.fit.cvut.cz/dataset/PTC</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>http://www.tpc.org/tpch/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>see query validation sections of the TPC documentation at http://tpc.org/ tpc documents current versions/pdf/tpc-h v3.0.0.pdf</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>Theorem and sketches of proofs: Theorem 1: Let V, V 1 , and V 2 be view specifications. Let D, D 1 and D 2 be the sets of FDs over views specified by V, V 1 and V 2 , respectively. Let f ds(V ) denotes the set of FDs over a view specified by V . Then:</p><p>f ds(σ ρ (V)) ⊇ D, and</p><p>with ∈ { ; ; ; ; ; } Proof: Trivial. Lemma 1 (FD types conservation though join operations): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let f ds(R i ) denotes the set of minimal FDs over the relationnal instance R i . Let Σ lef t up , Σ right up , Σ inf andΣ join denote the sets of left upstaged, right upstaged, inferred and join FDs over R 1 • • • R n , respectively. Then, the sets Σ lef t up ∪ Σ right up , Σ inf and Σ join are equals regardless of the join order. At the opposite, equality between sets Σ lef t up and Σ right up cannot be guaranteed. </p><p>Lemma 3: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). For all A ⊆ atts(L) \ X and </p><p>and there exists a tuple t L (x 1 , . . . , x n , a 1 , . . . , a k , . . . ) in L with a 1 , . . . , a k , the values of the attributes in A (otherwise, tuples t R and t R would have been filtered during the join operation). Thus, the join L♦ X=Y R leads to the two tuples:</p><p>Theorem 2: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). For all A ⊆ atts(L) \ X and</p><p>Proof: This is trivially derived from lemma 3 by transitivity, with the use of Armstrong's transitivity axiom.</p><p>Theorem 3: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). We cannot guarantee that all FDs over L♦ X=Y R can be inferred from Armstrong's axioms over the FDs over L and R taken separately.</p><p>Proof: In the two following instances L and R, we can see that only the FDs Y A → b and Y b → A hold.</p><p>In the join result, the FD AA → b holds but it cannot be inferred using Armstrong's axioms over the FDs discovered from each instance L and R. Theorem 4: Let L and R be two instances over relations S and T, respectively. Let L♦ X=Y R be a join result with X ⊆ atts(L), Y ⊆ atts(R). For all A ⊆ atts(L), A ⊆ atts(R) and b ∈ atts(R):</p><p>Theorem 5 (InFine completeness): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let V R be a view specification over relations in R. Let f ds(V R ) denotes the set of minimal FDs over the view specified by V R . Let f ds(InFine ) denotes the set of FDs computed by InFine over the view specified by V R . Then:</p><p>Proof sketch: Algorithm 1 begins by extracting the attributes that are retrieved by a view in order to guide the mining process of these attributes while still guaranteeing completeness. Then Algorithm 1 recursively explores the view specification, thus its completeness can be shown inductively. For the base case where we have a relational instance R (Algorithm 1, line# 9), the FDs are mined using a classic level-wise algorithm allowing to retrieve every FD in R. In the case of a projection (Algorithm 1, line# 15), as the relevant attributes are extracted at the very first step of Algorithm 1, no computation is performed and the previously computed FDs are returned. In the cases of a selection or a join (Algorithm 1, line# 17 or line# 20 respectively), the tuples are filtered by the join operation and Algorithm 2 mines all exact FDs. Algorithm 4 retrieves the minimal FDs from the logically inferred FDs, thus no lhs subset of FDs remains unchecked.</p><p>Theorem 4 indicates which part of the candidate FD lattice is pruned. Then, Algorithm 5 explores the candidate FDs using a classic bottom-up approach, thus no minimal FD remains unchecked. Overall, our algorithms explore the lattice of candidate FDs until they find minimal FDs; they avoid only the parts of the lattice that do not contain valid candidate FDs, thus InFine with selective mining retrieves the complete set of minimal candidate FDs.</p><p>Theorem 6 (InFine correctness): Let R = {R 1 ; . . . ; R n } be a set of relational instances. Let V R be a view specification over relations in R. Let I V R be the view specified by V R . Let f ds(InFine ) denotes the set of FDs computed by InFine over the view specified by V R . Then:</p><p>Proof sketch: Algorithm 1 recursively explores the view specification, thus its correctness can be shown inductively. For the base case where we have a relational instance R (Algorithm 1, line# 9) the FDs are mined using a classic levelwise algorithm allowing to retrieve FDs in R.</p><p>In case of a projection (Algorithm 1, line# 15), the process ensure that only the FDs with relevant attributes (i.e., the one that are retrieved in the output view) are kept. Thus, if the FDs output by the steps are correct, the handling of projection will only lead to remove irrelevant FDs without introducing incorrect ones.</p><p>In case of a selection (Algorithm 1, line# 17), Algorithm 2, valid exact FDs are discovered from the data using the principle of the level-wise algorithms adapted to mine upstaged FDs, thus the FDs are guaranteed to hold on the joined instance and only minimal FDs are kept.</p><p>In case of a join (Algorithm 1, line 20), at first in Algorithm 3, valid exact FDs are discovered from the data using the same principle as in Algorithm 2, thus returning FDs that are guaranteed to hold on the joined instance. Theorem 2 shows the correctness of the set of FDs inferred through logical inference. Then, the subroutine refine checks the correctness of its candidates FDs holding on the data. Therefore, the set of FDs D 2 discovered by Algorithm 4 is such that D 2 |= D ♦ . In Algorithm 5, Theorem 4 enforces the retrieval of FDs based only on the attributes that can become rhs in the joined instance, then only plausible candidate FDs are explored. Therefore, every discovered FD holds in the joined instance. By construction, Algorithm 4 and 5 lead to the retrieval of FDs that are minimal.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Data Profiling</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Abedjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Golab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Synthesis Lectures on Data Management</title>
		<imprint>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Discovery of genuine functional dependencies from relational data with missing values</title>
		<author>
			<persName><forename type="first">L</forename><surname>Berti-Équille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Harmouch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Novelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thirumuruganathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="880" to="892" />
			<date type="published" when="2018-04">Apr. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Database Theory -ICDT 2001, 8th International Conference</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">January 4-6, 2001. 2001</date>
			<biblScope unit="page" from="316" to="330" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Incremental discovery of functional dependencies with a bit-vector algorithm</title>
		<author>
			<persName><forename type="first">L</forename><surname>Caruccio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cirillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Deufemia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Polese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CEUR Workshop</title>
		<meeting>of CEUR Workshop</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">2400</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Relaxed functional dependencies-a survey of approaches</title>
		<author>
			<persName><forename type="first">L</forename><surname>Caruccio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Deufemia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Polese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="147" to="165" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Propagating XML constraints to relations</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Hara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="316" to="361" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Np-completeness of searches for smallest possible feature sets</title>
		<author>
			<persName><forename type="first">S</forename><surname>Davies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Russell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI Symposium on Intelligent Relevance</title>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="37" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Inclusion dependency discovery: An experimental evaluation of thirteen algorithms</title>
		<author>
			<persName><forename type="first">F</forename><surname>Dürsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Stebner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Windheuser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Friedrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Strelow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bleifuß</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Harmouch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM 2019</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="219" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Database systems -the complete book</title>
		<author>
			<persName><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Pearson Education</publisher>
		</imprint>
	</monogr>
	<note>International Ed</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data integration: After the teenage years</title>
		<author>
			<persName><forename type="first">B</forename><surname>Golshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Mihaila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017</title>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">May 14-19, 2017. 2017</date>
			<biblScope unit="page" from="101" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient discovery of functional and approximate dependencies using partitions</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huhtala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kärkkäinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Porkka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDE</title>
		<meeting>of ICDE</meeting>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="392" to="401" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Tane: An efficient algorithm for discovering functional and approximate dependencies</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huhtala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kärkkäinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Porkka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Journal</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="100" to="111" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">CORDS: automatic discovery of correlations and soft functional dependencies</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Markl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">J</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMOD</title>
		<meeting>of ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="647" to="658" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">MIMIC-III, a freely accessible critical care database</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Pollard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Li-Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ghassemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Moody</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Szolovits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Celi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G</forename><surname>Mark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific data</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Kenig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mundra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Salimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
		<title level="m">Mining approximate acyclic schemes from relations</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Approximate inference of functional dependencies from relations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kivinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">149</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="129" to="149" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Determining view dependencies using tableaux</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Klug</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Price</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="361" to="380" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient discovery of approximate dependencies</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kruse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="759" to="772" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Discover dependencies from data-a review</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Knowl. and Data Eng</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="251" to="264" />
			<date type="published" when="2012-02">Feb. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient discovery of functional dependencies and armstrong relations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Petit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Lakhal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EDBT</title>
		<meeting>of EDBT</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="350" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">FUN: an efficient algorithm for mining functional and embedded dependencies</title>
		<author>
			<persName><forename type="first">N</forename><surname>Novelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cicchetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICDT</title>
		<meeting>of ICDT</meeting>
		<imprint>
			<date type="published" when="1973">1973. 2001</date>
			<biblScope unit="page" from="189" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Functional and embedded dependency inference: a data mining point of view</title>
		<author>
			<persName><forename type="first">N</forename><surname>Novelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cicchetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="477" to="506" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Data profiling with metanome</title>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bergmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Finke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zwiener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1860" to="1863" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Functional dependency discovery: An experimental evaluation of seven algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ehrlich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Neubert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schönberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zwiener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1082" to="1093" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A hybrid approach to functional dependency discovery</title>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD&apos;16</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="821" to="833" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Exploiting Functional Dependence in Query Optimization</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">N</forename><surname>Paulley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Citeseer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">DynFD: Functional dependency discovery in dynamic datasets</title>
		<author>
			<persName><forename type="first">P</forename><surname>Schirmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kruse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hempfing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Neuschäfer-Rube</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EDBT</title>
		<meeting>of EDBT</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="253" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Uguide: User-guided discovery of fd-detectable errors</title>
		<author>
			<persName><forename type="first">S</forename><surname>Thirumuruganathan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Berti-Équille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ouzzani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Quiané-Ruiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMOD</title>
		<meeting>of ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1385" to="1397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">FastFDs: A heuristicdriven, depth-first algorithm for mining functional dependencies from relation instances -extended abstract</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Wyss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Giannella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Robertson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of DaWaK</title>
		<meeting>of DaWaK</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2114</biblScope>
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Mining functional dependencies from data</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Min. Knowl. Discov</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="197" to="219" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A statistical perspective on discovering functional dependencies in noisy data</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rekatsinas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMOD</title>
		<meeting>of ACM SIGMOD</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
