<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Graph-based keyword search in heterogeneous data sources</title>
				<funder ref="#_rdwR6tP">
					<orgName type="full">ANR AI Chair SourcesSay</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Angelos</forename><forename type="middle">Christos</forename><surname>Anadiotis</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Ecole Polytechnique</orgName>
								<orgName type="institution">Institut Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mhd</forename><surname>Yamen Haddad</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Graph-based keyword search in heterogeneous data sources</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C702B2BA1992050BAE761A96F43D6A1F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Data journalism is the eld of investigative journalism which focuses on digital data by treating them as rst-class citizens. Following the trends in human activity, which leaves strong digital traces, data journalism becomes increasingly important. However, as the number and the diversity of data sources increase, heterogeneous data models with di erent structure, or even no structure at all, need to be considered in query answering.</p><p>Inspired by our collaboration with Le Monde, a leading French newspaper, we designed a novel query algorithm for exploiting such heterogeneous corpora through keyword search. We model our underlying data as graphs and, given a set of search terms, our algorithm nds links between them within and across the heterogeneous datasets included in the graph. We draw inspiration from prior work on keyword search in structured and unstructured data, which we extend with the data heterogeneity dimension, which makes the keyword search problem computationally harder. We implement our algorithm and we evaluate its performance using synthetic and real-world datasets.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Data analysis is increasingly important for several organizations today, as it creates value by drawing meaningful insights from the data. As we are moving towards large data lakes installations where huge amounts of data are stored, the opportunities for important discoveries are growing; unfortunately, on par with the useless information. Moreover, the data to be processed is often stored in di erent formats, ranging from fully and semi-structured, to completely unstructured, like free text. Accordingly, the challenges in processing all this data that is available today, reside in both expressing and answering queries.</p><p>Research in heterogeneous data processing has proposed several approaches in addressing the above challenges. On the one side, massively parallel processing systems like Spark <ref type="bibr" target="#b32">[33]</ref>, Hive <ref type="bibr" target="#b27">[28]</ref> and Pig <ref type="bibr" target="#b25">[26]</ref> provide connectors for heterogeneous data sources and allow the execution of data analysis tasks on top of them, using either a platform-speci c API or a query language like SQL. Polystore-based approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b11">12]</ref> focus more on the data model and the query planning and optimization on top of heterogeneous data stores. Finally, the so-called just-in-time (JIT) data virtualization approach generates the query engine at runtime based on the data format <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref>. All these works consider that users, typically data scientists, already know what they are looking for, and they express it either using a powerful query language or a rich API.</p><p>However, today the data analysis paradigm has shifted and a central point is to nd parts of the data which feature interesting patterns. The patterns may not be known at query time; instead, users may have to discover them through a process of trial and error. A popular query paradigm in such a context is keyword search.</p><p>A staple of Information Retrieval in data with little or no structure, keyword search has been applied also on relational, XML or graph data, when users are unsure of the structure and would like the system to identify possible connections. In this work, we model a set of heterogeneous data sources as a graph, and focus on answering queries asking for connections among the nodes of the graph which are of interest to the users. This work is inspired from our collaboration with Les Décodeurs, Le Monde's fact-checking team <ref type="foot" target="#foot_0">1</ref> , within the ContentCheck collaborative research project <ref type="foot" target="#foot_1">2</ref> . Our study is novel with respect to the state of the art (Section 6) as we are the rst to consider that an answer may span over multiple datasets of di erent data models, with very different or even absent internal structure, e.g., text data. For instance, a national company registry is typically relational, contracts or political speeches are text, social media content typically comes as JSON documents, and open data is often encoded in RDF graphs. Integrated graph preserving all original nodes In the data journalism context mentioned above, it is important to be able to show where each piece of information in an answer came from, and how the connections were created. This is a form of provenance, and can also be seen as result explanation. Therefore, the queried graph needs to preserve the identity of each node from the original sources. At the same time, to enable interesting connections, we: (i) extract several kinds of meaningful entities from all the data sources of all kinds; (ii) interconnect data sources that comprise the same entity, or very similar ones, through so-called sameAs. Both extraction and similarity produce results with some con dence, a value between 0 and 1, thus, some edges in our graph have can be seen as uncertain (but quite likely).</p><p>No help from a score function An important dimension of keyword search problems is scoring, i.e., how do we evaluate the interestingness of a given connection (or query result). This is important for two reasons. First, in many scenarios, the number of results is extremely large, users can only look at a small number of results, say k. Second, some answer score measures have properties that can help limit the search, by allowing to determine that some of the answers not explored yet would not make it into the top k. Unfortunately, while desirable from an algorithmic perspective (since they simplify the problem), such assumptions on the cost model are not always realistic from a user perspective, as we learned by exchanging with journalists; we detail this in Section 3. Bidirectional search All edges in our graph are directed, e.g., from the subject to the object in an RDF graph, from the parent to the child in a hierarchical document etc., and, in keeping with our goal of integral source preservation, we store the edge direction in the graph. However, we allow answer trees to traverse edges in any direction, since heterogeneous data sources may model the same information either, say, of the form Alice wrote -----→ Paper 1 or Paper 1 hasAuthor --------→ Alice; since users are unfamiliar with the data, they should not be penalized for not having "guessed" correctly the edge directions. This is in contrast with many prior works (see Section 6) which de ne answers as a tree where from the root, a node matching each keyword is reached by traversing edges in their original direction only. For instance, assume the graph comprises a 1 wrote -----→ p 1 and a 2 wrote -----→ p 1 . With a restricted notion of answers, the query {a 1 a 2 } has no answer; in contrast, in our approach, the answer connecting them through p 1 is easily found. Bidirectional search gives a functional advantage, but makes the search more challenging: in a graph of |E| edges, the search space is multiplied by 2 |E | .</p><p>The contributions made in this work are as follows:</p><p>• We formalize the problem of bidirectional keyword search on graphs as described above, built from a combination of data sources. • With respect to scoring, we introduce a general score function that can be extended and customized to re ect all interesting properties of a given answer. We show that this generality, together with the possibility of con dence lower than 1.0 on some edges, does not enable search to take advantage of simplifying assumptions made in prior work. • We propose a complete (if exhaustive) algorithm for solving the keyword search problem in this context, as well as some original pruning criteria arising speci cally in the context of our graphs. Given the usually huge search space size, a practical use of this algorithm is to run it until a time-out and retain the best answers found. • We have implemented our algorithm and present a set of experiments validating its practical interest.</p><p>A previous version of our system had been demonstrated in <ref type="bibr" target="#b4">[5]</ref>. Since then, we have completely re-engineered the graph construction (this is described in the companion paper <ref type="bibr" target="#b3">[4]</ref>), deepened our analysis of the query problem, and proposed a new algorithm, described in the present work; this also di ers from (and improves over) our previous technical report <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">OUTLINE AND PROBLEM STATEMENT</head><p>In this section, we formalize our keyword search problem over a graph that we build by integrating data from various datasets, organized in di erent data models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Integrated graph</head><p>We consider a set M of data models: relational (including SQL databases, CSV les etc.), RDF, JSON, HTML, XML, and text. A dataset D is an instance of one of these data models <ref type="foot" target="#foot_2">3</ref> .</p><p>From a set D = {D 1 , D 2 , . . . , D n } of datasets, we create an integrated graph G = (N , E), where N is the set of nodes and E the set of edges. For instance, consider the dataset collection shown in Figure <ref type="figure" target="#fig_0">1</ref>. Starting from the top left, in clockwise order, it shows: a table with assets of public o cials, a JSON listing of France elected o cials, an article from the newspaper Libération with entities highlighted, and a subset of the DBPedia RDF knowledge base.</p><p>Figure <ref type="figure" target="#fig_1">2</ref> shows the graph produced from the datasets in Figure <ref type="figure" target="#fig_0">1</ref>. There are several observations to be made on this graph:</p><p>(i) The graph comprises four dataset nodes (the ones lled with yellow), one for each data source.</p><p>(ii) All the internal structure present in the input datasets is preserved in the graph: each RDF node became a node in the integrated graph, and each triple became an edge. A node is created for each map, array, and value in the JSON document. A node is created from each tuple, and from each attribute in the relational databases. Finally, a single node is created from the whole text document, which has no internal structure. When a text consists of more than one phrase, we segment it as a sequence of phrases, each of which is a node (child of the dataset node) to avoid overly large nodes that are hard to interpret by users.</p><p>(iii) Entity nodes (rounded-corners blue boxes) are extracted using Information Extraction (IE) techniques. Thus, in the example, nodes labeled "P. Balkany", "I. Balkany" are recognized as People, "Levallois-Perret" and "Centrafrique" are recognized as Locations, while "Areva" is an Organization. An extracted entity is added to the graph as a child of the node (leaf in an XML, HTML, JSON or text document; attribute value from a relational dataset; or RDF literal) from which it has been extracted.</p><p>(i ) Equivalence edges (solid red edges in Figure <ref type="figure" target="#fig_0">1</ref>) connect nodes found in di erent datasets which are considered to refer to the same real-world entity. For instance, the three occurrences of "P. Balkany" are pairwise connected by edges with a con dence of 1.0. The condence of the edges derived directly from the datasets, as explained above, is 1.0; we do not show it in the gure to avoid clutter. We say nodes connected by equivalence edges are equivalent.</p><p>( ) Similarity edges (dotted, curved red edge between "Central African Republic" and "Centrafrique" in Figure <ref type="figure" target="#fig_0">1</ref>) connect nodes which are considered strongly similar but not equivalent. In our example, the two nodes have a similarity of 0.85, which is attached to the edge as con dence.</p><p>For e ciency, when k nodes are equivalent, we do not consider all the</p><formula xml:id="formula_0">k (k -1)<label>2</label></formula><p>edges; instead, one of the nodes (the rst to be added to the graph -any other choice could be made) is designated the representative of all of them, and we store associated with each node, the ID of its representative.</p><p>The purpose of the equivalence and similarity edges is to interconnect nodes within and across the datasets; entity extraction prepares the ground for the same, since it creates nodes that may co-occur across data sources, e.g., entities mentioned in separate texts, such as "P. Balkany" in the gure. This increases the value and usefulness of the graph, since it allows to nd connections which cannot be established based on any dataset taken separately. For instance, consider the question: «What connections exist between "I. Balkany", "Africa", and "real estate"?» This can be asked as a three-keyword query {"I. Balkany", "Africa", "Estate"}, for which an answer (a tree composed of graph edges) is shown as a light green highlight in Figure <ref type="figure" target="#fig_0">1</ref>; the three nodes matching the respective keywords are shown in bold. This answer interconnects all four data sources.  We formalize this keyword search query problem below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Search problem</head><p>Given our graph G = (N , E), we denote by L the set of all the labels of G nodes, plus the special constant ϵ denoting the empty label. We denote by λ(•) a function assigning to each node and edge a label, which may be empty. As illustrated in Figure <ref type="figure" target="#fig_1">2</ref>, internal nodes, which correspond, e.g., to a relational tuple, or to a JSON map or array, have an empty label.</p><p>Let W be the set of keywords, obtained by stemming the label set L; a search query is a set of keywords Q = {w 1 , ..., w m }, where w i ∈ W . We de ne an answer tree (AT, in short) as a set t of G edges which (i) together, form a tree (each node is reachable from any other through exactly one path), (ii) for each w i , contain at least one node whose label matches w i . Here, the edges are considered undirected, that is:</p><formula xml:id="formula_1">n 1 a -→ n 2 b ← -n 3 c -→ n 4 is a sample AT, such that for all w i ∈ Q, there is a node n i ∈ t such that w i ∈ λ(n i ).</formula><p>We treat the edges of G as undirected when de ning the AT in order to allow more query results, on a graph built out of heterogeneous content whose structure is not well-known to users. For instance, consider a query consisting of the keywords k 1 , k 4 such that k 1 ∈ λ(n 1 ) and k 4 ∈ λ(n 4 ) on the four-nodes sample AT introduced above. If our ATs were restricted to the original direction of G edges, the query would have no answer; ignoring the edge directions, it has one. One could easily extend the de nition and the whole discussion in order to allow matches to also occur on edges (just enlarge L to also include the stemmed edge labels).</p><p>Further, we are interested in minimal answer trees, that is:</p><p>(1) Removing an edge from the tree should make it lack one or more of the query keywords w i . (2) If a query keyword w i matches the label of more than one nodes in the answer tree, then all these matching nodes must be equivalent.</p><p>Condition <ref type="bibr" target="#b1">(2)</ref> is speci c to the graph we consider, originating in several data sources connected by equivalence or similarity edges. In classical graph keyword search problems, each query keyword is matched exactly once in an answer (otherwise, the tree is considered non-minimal). In contrast, our answer trees may need to traverse equivalence edges, and if w i is matched by one node connected by such an edge, it is also matched by the other. For instance, consider the three-keyword query "Gyucy Balkany Levallois" in Figure <ref type="figure" target="#fig_1">2</ref>: the keyword Balkany is matched by the two nodes labeled "P. Balkany" which are part of the answer. As a counter-example to condition (2), consider the query "Balkany Centrafrique" in Figure <ref type="figure" target="#fig_1">2</ref>, assuming the keyword Centrafrique is also matched in the label "Central African Republic" <ref type="foot" target="#foot_3">4</ref> . Consider the tree that connects a "P. Balkany" node with "Centrafrique", and also traverses the edge between "Centrafrique" and "Central African Republic": this tree is not minimal, thus it is not an answer. The intuition for rejecting it is that "Centrafrique" and "Central African Republic" may or may not be the same thing (we have a similarity, not an equivalence edge), therefore the query keyword "Centrafrique" is matched by two potentially di erent things in this answer, making it hard to interpret.</p><p>A direct consequence of minimality is that in an answer, each and every leaf matches a query keyword.</p><p>Several minimal answer trees may exist in G for a given query. We consider available a scoring function which assigns a higher value to more interesting answer trees (see Section 3). Thus, our problem can be stated as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P</head><p>Given the graph G built out of the datasets D and a query Q, return the k highest-score minimal answer trees.</p><p>An AT may potentially span over the whole graph, (also) because it can traverse G edges in any direction; this makes the problem challenging. Discussion: degraded answers. In some cases, a query may have no answer (as de ned above) on a given graph, yet if one is willing to drop the second condition concerning nodes matching the same query keyword, an answer tree could be found. For instance, consider a graph of the form a If we removed condition (2), we could accept such an answer, which we call degraded, since it is harder to interpret for users (lacking one clearly identi ed node for each keyword). One could then generalize our problem statement into: (i) solve the problem stated above, and (ii) only if there are no answers, nd the topk degraded answers (if they exist). We do not pursue degraded answer search further in this paper, and focus instead on nding those de ned above.</p><formula xml:id="formula_2">1 l - → b 1 m --→ b 2 n -→ c 1 , such that b 1 is not equivalent to b 2 ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Search space and complexity</head><p>The problem that we study is related to the (Group) Steiner Tree Problem, which we recall below.</p><p>Given a graph G with weights (costs) on edges, and a set of m nodes n 1 , . . . , n m , the Steiner Tree Problem (STP) <ref type="bibr" target="#b13">[14]</ref> consists of nding the smallest-cost tree in G that connects all the nodes together. We could answer our queries by solving one STP problem for each combination of nodes matching the keywords w 1 , . . . , w m . However, there are several obstacles left: ( ) STP is a known NP-hard problem in the size of G, denoted |G |; ( ) as we consider that each edge can be taken in the direct or reverse direction, this amounts to "doubling" every edge in G. Thus, our search space is 2 |G | larger than the one of the STP, or that considered in similar works, discussed in Section 6. This is daunting even for small graphs of a few hundred edges; ( ) we need the k smallest-cost trees, not just one; (•) each keyword may match several nodes, not just one.</p><p>The closely related Group STP (GSTP, in short) <ref type="bibr" target="#b13">[14]</ref> is: given m sets of nodes from G, nd the minimum-cost subtree connecting one node from each of these subtrees. GSTP does not raise the problem (•), but still has all the others.</p><p>In conclusion, the complexity of the problem we consider is extremely high. Therefore, solving it fully is unfeasible for large and/or high-connectivity graphs. Instead, our approach is:</p><p>• Attempt to nd all answers from the smallest (fewest edges) to the largest. Enumerating small trees rst is both a practical decision (we use them to build larger ones) and ts the intuition that we shouldn't miss small answers that a human could have found manually. However, as we will explain, we still "opportunistically" build some trees before exhausting the enumeration of smaller ones, whenever this is likely to lead faster to answers. The strategy for choosing to move towards bigger instead of smaller tress leaves rooms for optimizations on the search order. • Stop at a given time-out or when m answers have been found, for some m ≥ k; • Return the k top-scoring answers found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SCORING ANSWER TREES</head><p>We now discuss how to evaluate the quality of an answer. Section 3.1 introduces the general notion of score on which we base our approach. Section 3.2 describes one particular metric we attach to edges in order to instantiate this score, nally Section 3.3 details the actual score function we used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Generic score function</head><p>We have con gured our problem setting to allow any scoring function, which enables the use of di erent scoring schemes tting the requirements of di erent users. As a consequence, this approach allows us to study the interaction of the scoring function with di erent properties of the graph. For instance, we are currently investigating the possibility to learn what makes an answer interesting for a user, so that we may return customized answers to each user.</p><p>Given an answer tree t to a query Q, we consider a score function consisting of (at least) the following two components:</p><p>• The matching score ms(t), which re ects the quality of the answer tree, that is, how well its leaves match the query terms.</p><p>• The connection score cs(t), which re ects the quality of the tree connecting the edges. Any formula can be used here, considering the number of edges, the con dence or any other property attached to edges, or a query-independent property of the nodes, such as their PageRank or betweenness centrality score etc.</p><p>The score of t for Q, denoted s(t), is computed as a combination of the two independent components ms(t) and cs(t). Popular combinations functions (a weighted sums, or product etc.) are monotonous in both components, however, our framework does not require it. Finally, both ms(t) and cs(t) can be tuned based on a given user's preferences, to personalize the score, or make them evolve in time through user feedback etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Edge speci city</head><p>We now describe a metric on edges, which we used (through the connection score cs(t)) to favor edges that are "rare" for both nodes they connect. This metric was inspired by our experiments with real-world data sources, and it helped return interesting answer trees in our experience.</p><p>For a given node n and label l, let N l →n be the number of l-labeled edges entering n, and N l n→ the number of l-labeled edges exiting n.</p><p>The speci city of an edge e = n 1 l -→ n 2 is de ned as:</p><p>s(e) = 2/(N l n 1 → + N l →n 2 ). s(e) is 1.0 for edges that are "unique" for both their source and their target, and decreases when the edge does not "stand out" among the edges of these two nodes. For instance, the city council of Levallois-Perret comprises only one mayor (and one individual cannot be mayor of two cities in France, because he has to inhabit the city where he runs for o ce). Thus, the edge from the city council to P. Balkany has a speci city of 2/(1.0 + 1.0) = 1.0. In contrast, there are 54 countries in Africa (we show only two), and each country is in exactly one continent; thus, the speci city of the dbo:partOf edges in the DBPedia fragment, going from the node named Morocco (or the one named Central African Republic) to the node named Africa is 2/(1 + 54) .036.</p><p>Speci city computation. When registering the rst dataset D 1 , computing the speci city of its edges is trivial. However, when registering subsequent datasets D 2 , D 3 etc., if some node, say n 2 ∈ D 2 is found to be equivalent to a node n 1 ∈ D 1 , all the D 1 edges adjacent to n 1 and the D 2 edges adjacent to n 2 should be re ected in the speci city of each of these edges. Thus, in particular, the speci city of D 1 edges needs to be recomputed when a node in a source added after D 1 is equivalent to one of its nodes. A naïve approach would be: when the edges of D 2 are traversed (when we add this dataset to the graph), re-traverse the edges of n 1 in D 1 in order to (re)compute their speci city. However, that would be quite ine cient.</p><p>Instead, below, we describe an e cient incremental algorithm to compute speci city. We introduce two notations. For any edge e, we denote N e →• , respectively N e •→ , the two numbers out of which the speci city of e has been most recently computed <ref type="foot" target="#foot_4">5</ref> . Speci cally, N e →• counts l-labeled edges incoming to the target of e, while N e</p><p>•→ counts l-labeled edges outgoing the source of e. In Figure <ref type="figure" target="#fig_3">3</ref>, if e is the edge</p><formula xml:id="formula_3">x l - → n 1 , then N e →• = 3 (blue edges) and N e •→ = 1, thus s(e) = 2/4 = .5.</formula><p>Let n 1 ∈ D 1 be a node, es 1 be the set of all nodes equivalent to n 1 , and n 2 ∈ D 2 be a node in a dataset we currently register, and which has just been found to be equivalent to n 1 , also.</p><p>Further, let l be a label of an edge incoming or outgoing (any) node from es 1 , and/or n 2 . We denote by N l →es 1 the sum n ∈es 1 (N l →n ) and similarly by N l es 1 → the sum n ∈es 1 (N l n→ ); they are the numbers of l-labeled outgoing (resp., incoming) l-labeled edges of any node in es 1 . When n 2 joins the equivalence set es 1 of n 1 (see Fig- 0, are handled in a similar manner. The above method only needs, for a given node n 2 newly added to the graph, and label l, the number of edges adjacent to n 2 in its dataset, and the number of l edges adjacent to a node equivalent to n 2 . Unlike the naïve speci city computation method, it does not need to actually traverse these edges previously registered edges, making it more e cient.</p><p>Concretely, for each edge e ∈ E, we store three attributes: N e →• , N e •→ and s, the last-computed speci city, and we update N e →• , N e</p><p>•→ as explained above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Concrete score function</head><p>In our experiments, we used the following score function.</p><p>For an answer t to the query Q, we compute the matching score ms(t) as the average, over all query keywords w i , of the similarity between the t node matching w i and the keyword w i itself; we used the edit distance.</p><p>We compute the connection score cs(t) based on edge con dence, on one hand, and edge speci city on the other. We multiply the con dence values, since we consider that uncertainty (con dence &lt; 1) multiplies; and we also multiply the speci cities of all edges in t, to discourage many low-speci city edges. Speci cally, our score is computed as:</p><formula xml:id="formula_4">score(t, Q) = α • ms(t, Q) + β • e ∈E c(e) + (1 -α -β) • e ∈E s(e)</formula><p>where α, β are parameters of the system such that 0 ≤ α, β &lt; 1 and α + β ≤ 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Orthogonality between the score and the algorithm</head><p>Before we describe the search algorithm, we make a few more remarks on the connection between the score function and the search algorithm. We start by considering the classical Steiner Tree and Group Steiner Tree Problems (Section 2.3). These assume that the tree cost is monotonous, that is: for any query Q and all trees T , T where T is a subtree of T it follows that the cost of T is higher (in our terminology, its score is lower) than the cost of T . This is naturally satis ed if the cost is the addition of edge weights. In contrast, the score, in its general form (Section 3.1), and in particular our concrete one (Section 3.3), is not monotonous, as illustrated in Figure <ref type="figure" target="#fig_6">4</ref>, where on each edge, c is the con dence and s is the speci city. Denoting T the four-edge tree rooted in n 1 , the connection score</p><formula xml:id="formula_5">cs(T ) = β +(1-α -β)•(.5) 4 , while cs(T ) = β •.5+(1-α -β)(.5) 4 •.25.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>If we assume</head><formula xml:id="formula_6">α = β = 1 3 , then cs(T ) = 1 3 (1 + (.5) 4 ) .35 while cs(T ) = 1 3 • (.5 + (.5) 5</formula><p>) .17, which is clearly smaller. Assuming T has the same matching score as T , the global score of T is smaller than that of T , contradicting the monotonicity assumption.</p><p>Another property sometimes assumed by score functions is the called optimal substructure, that is: the best solution for a problem of size p is part of the best solution for a problem of size p + 1 that is an extension of p, for some problem size p. When this holds, the problem can be e ciently solved in a dynamic programming fashion. However, STP does not enjoy this property: the smallestcost tree connecting two nodes n 1 , n 2 is not necessarily part of the smallest-cost tree that connects n 1 , n 2 , n 3 (and the same holds for GSTP). Some existing algorithms also assume a variant of the optimal substructure property (see <ref type="bibr">Section 6)</ref>. In contrast, our score function (both in its general and its concrete form) does not ensure such favorable properties. This is why the search algorithm we describe next has to nd as many answers as possible, as quickly as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ANSWERING KEYWORD QUERIES</head><p>We now present our approach for computing query answers, based on the integrated graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">G and M</head><p>Our rst algorithm uses some concepts from the prior literature <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b17">18]</ref> while exploring many more trees. Speci cally, it starts from the sets of nodes N 1 , . . . , N m where the nodes in N i all match the query keyword w i ; each node n i, j ∈ N i forms a one-node partial tree. For instance, in Figure <ref type="figure" target="#fig_1">2</ref>, one-node trees are built from the nodes with boldface text, labeled "Africa", "Real Estate" and "I. Balkany". Two transformations can be applied to form increasingly larger trees, working toward query answers:</p><p>• G (t, e), where t is a tree, e is an edge adjacent to the root of t, and e does not close a loop with a node in t, creates a new tree t having all the edges of t plus e; the root of the new tree is the other end of the edge e. For instance, starting from the node labeled "Africa", a G can add the edge labeled dbo:name.</p><p>• M (t 1 , t 2 ), where t 1 , t 2 are trees with the same root, whose other nodes are disjoint, and matching disjoint sets of keywords, creates a tree t with the same root and with all edges from t 1 and t 2 . Intuitively, G moves away from the keywords, to explore the graph; M fuses two trees into one that matches more keywords than both t 1 and t 2 .</p><p>In a single-dataset context, G and M have the following properties. ( m 1 ) G alone is complete (guaranteed to nd all answers) for k = 1, 2 only; for higher k, G and M together are complete. ( m 2 ) Using M steps helps nd answers faster than using just G <ref type="bibr" target="#b17">[18]</ref>: partial trees, each starting from a leaf that matches a keyword, are merged into an answer as soon as they have reached the same root. ( m 3 ) An answer can be found through multiple combinations of G and M . For instance, consider a linear graph n 1 → n 2 → . . . n p and the two-keyword query {a 1 , a p } where a i matches the label of n i . The answer is obviously the full graph. It can be found: starting from n 1 and applying p -1 G steps; starting from n p and applying p -1 G steps; and in p -2 ways of the form M (G (G . . . ), G (G . . . )), each merging in an intermediary node n 2 , . . . , n p-1 . These are all the same according to our de nition of an answer (Section 2.2), which does not distinguish a root in an answer tree; this follows users' need to know how things are connected, and for which the tree root is irrelevant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Adapting to multi-datasets graphs</head><p>The changes we brought for our harder problem (bidirectional edges and multiple interconnected datasets) are as follows.</p><p>1. Bidirectional growth. We allow G to traverse an edge both going from the source to the target, and going from the target to the source. For instance, the type edge from "Real Estate" to &lt;tuple1&gt; is  traversed target-to-source, whereas the location edge from &lt;tuple1&gt; to "Real Estate" is traversed source-to-target.</p><p>2. Many-dataset answers. As de ned in a single-dataset scenario, G and M do not allow to connect multiple datasets. To make that possible, we need to enable one, another, or both to also traverse similarity and equivalence edges (shown in solid or dotted red lines in Figure <ref type="figure" target="#fig_1">2</ref>. We decide to simply extend G to allow it to traverse not just data edges, but also similarity edges between nodes of the same or di erent datasets. We handle equivalence edges as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.a Naïve solution: G</head><p>-to-equivalent. The simplest idea is to allow G to also add an equivalence edge to the root of a tree. However, this can be very ine cient. Consider three equivalent nodes m, m and m , e.g., the three "P. Balkany" nodes in Figure <ref type="figure" target="#fig_1">2</ref>: a G step could add one equivalence edge, the next G could add another on top of it etc. More generally, for a group of p equivalent nodes, from a tree rooted in one of these nodes, 2 p trees would be created just by G . In our French journalistic datasets, some entities, e.g. "France", are very frequent, leading to high p; exploring 2 p subtrees every time we reach a "France" node is extremely expensive <ref type="foot" target="#foot_5">6</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.b G -to-representative</head><p>To avoid this, we devise a third algorithmic step, called G -to-representative (G 2R ), as follows. Let t be a partial tree developed during the search, rooted in a node n, such that the representative of n (recall Section 2.1) is a node n r ep n. G 2R creates a new tree by adding to t the edge n ≡ -→ n r ep ; this new tree is rooted in n r ep . If n is part of a group of p equivalent nodes, only one G 2R step is possible from t, to the unique representative of n; G 2R does not apply again on G 2R (t), because the root of this tree is n r ep , which is its own representative.</p><p>Together, G , G 2R and M enable nding answers that span multiple data sources, as follows:</p><p>• G allows exploring data edges within a dataset, and similarity edges within or across datasets; • G 2R goes from a node to its representative when they di er; the representative may be in a di erent dataset; • M merges trees with a same root: when that root is the representative of a group of p equivalent nodes, this allows connecting partial trees, including G 2R results, containing nodes from di erent datasets. Thus, M can build trees spanning multiple datasets.</p><p>One potential performance problem remains. Consider again p equivalent nodes n 1 , . . . , n p ; assume without loss of generality that their representative is n 1 . Assume that during the search, a tree t i is created rooted in each of these p nodes. G 2R applies to all but the rst of these trees, creating the trees t 2 , t 3 , . . . , t p , all rooted in n 1 . Now, M can merge any pair of them, and can then repeatedly apply to merge three, then four such trees etc., as they all have the same root n 1 . The exponential explosion of G trees, avoided by introducing G 2R , is still present due to M ! We solve this problem as follows. Observe that in an answer, a path of two or more equivalence edges of the form n 1 ≡ -→ n 2 ≡ -→ n 3 such that a node internal to the path, e.g. n 2 , has no other adjacent edge, even if allowed by our de nition, is redundant. Intuitively, such a node brings nothing to the answer, since its neighbors, e.g., n 1 and n 3 , could have been connected directly by a single equivalence edge, thanks to the transitivity of equivalence. We call non-redundant an answer that does not feature any such path, and decide to search for non-redundant answers only.</p><p>The following properties hold on non-redundant answers:</p><formula xml:id="formula_7">P 1.</formula><p>There exists a graph G and a k-keyword query Q such that a non-redundant answer contains k -1 adjacent equivalence edges (edges that, together, form a single connected subtree). We prove this by exhibiting such an instance. Let G be a graph of 2k nodes shown in Figure <ref type="figure" target="#fig_7">5 (a)</ref>, such that all the x i are equivalent, and consider the k-keyword query Q = {a 1 , . . . , a k } (each keyword matches exactly the respective a i node). An answer needs to traverse all the k edges from a i to x i , and then connect the nodes x i , . . . , x k ; we need k -1 equivalence edges for this.</p><p>Next, we show: P 2. Let t be a non-redundant answer to a query Q of k keywords. A group of adjacent equivalence edges contained in t has at most k -1 edges.</p><p>We prove this by induction over k. For k = 1, each answer has 1 node and 0 edge (trivial case). Now, consider this true for k and let us prove it for k + 1. Assume by contradiction that a non-redundant answer t Q to a query Q of k + 1 keywords comprises k + 1 adjacent equivalence edges. Let Q be the query having only the rst k keywords of Q, and t be a subtree of t that is a non-redundant answer to Q :</p><p>• t exists, because t connects all Q keywords, thus also the Q keywords; • t is non-redundant, because its edges are also in the (nonredundant) t.</p><p>By the induction hypothesis, t has at most k -1 adjacent equivalence edges. This means that there are two adjacent equivalent edges in t \ t .</p><p>(1) If these edges, together, lead to two distinct leaves of t, then t has two leaves not in t . This is not possible, because by de nition of an answer, t has k + 1 leaves (each matching a keyword) and similarly t has k leaves. (2) It follows, then, that the two edges lead to a single leaf of t, therefore the edges form a redundant path. This contradicts the non-redundancy of t, and concludes our proof.</p><p>Property 2 gives us an important way to control the exponential development of trees due to p equivalent nodes. G , G 2R and M , together, can generate trees with up to k (instead of k-1) adjacent equivalence edges. This happens because G 2R may "force" the search to visit the representative of a set of k equivalent nodes (see Figure <ref type="figure" target="#fig_7">5</ref>(b), assuming x 1 is the representative of all the equivalent x i s, and the query {a 2 , . . . , a k }). The resulting answer may be redundant, if the representative has no other adjacent edges in the answer other than equivalence edges. In such cases, in a postprocessing step, we remove from the answer the representative and its equivalence edges, then reconnect the respective equivalent nodes using k -1 equivalence edges. This guarantees obtaining a non-redundant tree, such as the one in Figure <ref type="figure" target="#fig_7">5(c</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The GAM algorithm</head><p>We now have the basic exploration steps we need: G , G 2R and M</p><p>. In this section, we explain how we use them in our integrated keyword search algorithm.</p><p>We decide to apply in sequence: one G or G 2R (see below), leading to a new tree t, immediately followed by all the M operations possible on t. Thus, we call our algorithm Grow and Aggressive Merge (GAM, in short). We merge aggressively in order to detect as quickly as possible when some of our trees, merged at the root, form an answer.</p><p>Given that every node of a currently explored answer tree can be connected with several edges, we need to decide which G (or G 2R ) to apply at a certain point. For that, we use a priority queue U in which we add (tree, edge) entries: for G , with the notation above, we add the (t, e) pair, while for G 2R , we add t together with the equivalence edge leading to the representative of t's root. In both cases, when a (t, e) pair is extracted from U , we just extend t with the edge e (adjacent to its root), leading to a new tree t G , whose root is the other end of the edge e. Then we aggressively merge t G with all compatible trees explored so far, nally we read from the graph the (data, similarity or equivalence) edges adjacent to t G 's root and add to U more (tree, edge) pairs to be considered further during the search. The algorithm then picks the highest-priority pair in U and reiterates; it stops when U is empty, at a timeout, or when a maximum number of answers are found (whichever comes rst).</p><p>The last parameter impacting the exploration order is the priority used in U : at any point, U gives the highest-priority (t, e) pair, which determines the operations performed next.</p><p>(1) Trees matching many query keywords are preferable, to go toward complete query answers; (2) At the same number of matched keywords, smaller trees are preferable in order not to miss small answers; (3) Finally, among (t 1 , e 1 ), (t 2 , e 2 ) with the same number of nodes and matched keywords, we prefer the pair with the higher speci city edge. Algorithm details Beyond the priority queue U described above, the algorithm also uses a memory of all the trees explored, called E. It also organizes all the (non-answer) trees into a map K in which they can be accessed by the subset of query keywords that they match. The algorithm is shown in pseudocode in Figure <ref type="figure" target="#fig_8">6</ref>, following the notations introduced in the above discussion.</p><p>While not shown in Figure <ref type="figure" target="#fig_8">6</ref> to avoid clutter, the algorithm only develops minimal trees (thus, it only nds minimal answers). This is guaranteed:</p><p>• When creating G and G 2R opportunities (steps 3 and 4d): we check not only that the newly added does not close a cycle, but also that the matches present in the new tree satisfy our minimality condition (Section 2.2).</p><p>• Similarly, when selecting potential M candidates (step 4(c)iiiA).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTAL EVALUATION</head><p>We implemented our approach in the ConnectionLens prototype, available online at https://gitlab.inria.fr/cedar/connectionlens, which we used to experimentally evaluate the performance of our algorithms. This section presents the results that we obtained by using synthetic graphs, which are similar to the real-world datasets that we have obtained. First, we describe the hardware and software setup that we used to run our experiments, and then we give our ndings for various combinations of amount of keywords and graph sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Hardware and software setup</head><p>We conducted our experiments on a server equipped with 2x10-core Intel Xeon E5-2640 CPUs clocked at 2.40GHz, and 128GB DRAM. The graph is constructed following the approach described in <ref type="bibr" target="#b3">[4]</ref> and we used Postgres 9.6.5 to store and query the graph for nodes, edges and labels. The search algorithms are implemented in a Java application which communicates with the database over JDBC, whereas it also maintains an in-memory cache. Every time that the search algorithm needs information about a node, it rst looks into the cache, and if the requested information is not there, it is directly retrieved from the database and then stored in the cache. To avoid any e ects of the cache replacement algorithm, in our experiments we set the cache to be large enough to include all the information that has been retrieved from the database. Synthetic datasets For controlled experiments, we generated different types of (RDF) graphs. The rst type is a line graph, which the simplest model that we can use. In the line graph, every node is connected with two others, having one edge for each node, except two nodes which are connected with only one. By using the line graph, Procedure process(tree t)</p><p>• if t is not already in E • then add t to E if t has matches for all the query keywords then post-process t if needed; output the result as an answer (initially ∅). (ii) Let p 1 be the keyword set of t (iii) For each keyword subset p 2 that is a key within K, and such that p 1 ∩ p 2 = ∅ (A) For each tree t i that corresponds to p 2 , try to merge t with t i . Process any possible result; if it is new (not in E previously), add it to NT . (d) Re-plenish U (add more entries in it). This is performed as in step 3 but based on NT (not on E). and M operations with respect to the size of the graph. The second type is a chain graph, which is the same as the line graph, but instead of one edge connecting every pair of nodes, we have two. We use this type to show the performance of the algorithm as we double the amount of edges of the line graph and we give more options to the G and the M algorithms. The third type is the star graph, where we have several line graphs connected through a strongly connected cluster of nodes with a representative. We use this type to show the performance of G 2R , by placing the query keywords on di erent line graphs. The fourth type is a random graph based on the Barabasi-Albert (BA, in short) model <ref type="bibr" target="#b0">[1]</ref>, which generates scale-free networks with only a few nodes (referred to as hubs) of the graph having much higher degree than the rest. The graph in this model is created in a two-staged process. During the rst stage, a network of some nodes is created. Then, during the second stage, new nodes are inserted in the graph and they are connected to nodes created during the rst stage. At the second stage, we can control how many connections every node will have to the ones created at the rst stage. By setting that every node created at the second stage to be connected with exactly one node created at the rst stage, we have observed that we can construct graphs which are similar to the real-world ones, and therefore we tune our model accordingly.</p><formula xml:id="formula_8">• else insert t into K Algorithm GAMSearch(query Q = {w 1 , w 2 , . . . , w k })<label>(1)</label></formula><p>Real-world dataset The real-world dataset that we used is based on data that we have obtained from journalists with whom 0 100 200 300 400 500 600 700 800 900 1,000 0 1,000  For the microbenchmarks, we report the time needed for our system to return the rst answer, as well as the time for all answers. For the macrobenchmarks, we only report the time to return all the answers, as we do not have full control over the graphs and, hence, it is hard to draw meaningful conclusions and explain them relying on the whole graphs. Finally, we set an upper bound to the overall execution time at 120 seconds, which is applied to all the experiments that we performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Querying synthetic datasets</head><p>Figure <ref type="figure" target="#fig_9">7</ref> shows the execution time of our algorithm when executing a query with two keywords on a line graph, as we vary the number of nodes of the graph. We place the keywords on the two "ends" of the graph to show the impact of the distance on the execution time. The performance of our algorithm is naturally a ected by the size of the graph, as it generates 2 * N answer trees, where N is the number of nodes. Given that this is a line graph, there is only one answer, which is the whole graph, and, therefore, the time to nd the rst answer is also the overall execution time.</p><p>Figure <ref type="figure" target="#fig_11">8</ref> shows the execution of our algorithm on a chain graph. Speci cally, Figure <ref type="figure" target="#fig_11">8a</ref> shows the time elapsed until the rst answer is found, whereas Figure <ref type="figure" target="#fig_11">8b</ref> shows the overall execution time. The execution times reported in Figure <ref type="figure" target="#fig_11">8a</ref> are almost the same, as the size of the graph increases slowly. On the other hand, the overall execution times increase at a much higher (exponential) rate, as shown in Figure <ref type="figure" target="#fig_11">8b</ref>, where the axis has a logarithmic scale. The reason is that every pair of nodes is connected with two edges, which increases the amount of answers exponentially with the amount of nodes in the graph.</p><p>Similar to the chain graph, in Figure <ref type="figure" target="#fig_13">9</ref> we report the execution time until our algorithm nds the rst and all answers (left and right hand side, respectively). Given that we use keywords which are placed in two di erent lines connected through the center of the graph, the algorithm has to use G 2R , whereas in the previous cases it only had to use G and M . The number of branches, depicted on the x axis of Figure <ref type="figure" target="#fig_13">9</ref>, corresponds to the number of line graphs connected in the star. Each line graph has 10 nodes and we place the query keywords at the extremities of two di erent line graphs. Given that our algorithm will have to check all possible answers, it follows that the number of merges is exponential to the number of branches, that is O(2 K ), where K is the number of branches. This behaviour is clearly shown in both parts of Figure <ref type="figure" target="#fig_13">9</ref>, where on the axis (in logarithmic scale) we show the times to nd the rst, and, respectively, all answers. Above 12 branches, the timeout of 120 seconds that we have set is hit and, thus, search is terminated, as shown in Figure <ref type="figure" target="#fig_13">9b</ref>.</p><p>Figure <ref type="figure" target="#fig_14">10</ref> depicts the performance of our algorithm when considering the Barabasi-Albert graph model. In this experiment, we keep the graph with 2000 nodes xed and we vary the position of two keywords, by choosing nodes which have a distance, as given in the x axis; note the logarithmic axis. Due to the fact that the graph is randomly generated within the BA model, we note some irregularity in the time to the rst solution, which however grows at a moderate pace as the distance between the keyword node grows. The overall relation between the time to the rst solution and the total time con rms that the search space is very large but that most of the exploration is not needed, since the rst solution is found quite fast.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Querying a real-world dataset</head><p>This Section includes the results that we obtained by running our algorithm on real-world data. Our dataset is a corpus of 462 HTML articles (about 6MB) crawled from the French online newspaper Mediapart with the search keywords "gilets jaunes" (yellow vests, a protest movement in France over the last year). We built a graph using these articles which consists of 90626 edges and 65868 nodes, out of which 1525 correpond to people, 1240 to locations and 1050 to organizations. We query the graph using queries of one, two and three di erent keywords.</p><p>We report our ndings in Table <ref type="table" target="#tab_2">1</ref>. The results are not given as a basis comparison, rather than as a proof of concept. Nevertheless, there are several interesting observations to be made. First, the amount of answers for every query is generally larger than 1. We allow several results, as the end users (in our case, the investigative journalists) need to see di erent connections to reach to potentially interesting conclusions. Second, there are queries where several answers are found, and the execution is interrupted due to the threshold. We allow the user to set the threshold, based on the results returned every time. Third, the answers returned to the user are signi cantly less than the answer trees discovered, showing the impact of minimality as a requirement for returning an answer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK AND CONCLUSIONS</head><p>Keyword search (KS, in short) is the method of choice for searching in unstructured (typically text) data, and it is also the best search method for novice users, as witnessed by the enormous success of keyword-based search engines. As databases grew larger and more complex, KS has been proposed as a method for searching also in structured data <ref type="bibr" target="#b30">[31]</ref>, when users are not perfectly familiar with the data, or to get answers enabled by di erent tuple connection networks. For relational data, in <ref type="bibr" target="#b18">[19]</ref> and subsequent works, tuples are represented as nodes, and two tuples are interconnected only through primary key-foreign key pairs. The graphs that result are thus quite uniform, e.g., they consist of "Company nodes", "Employee nodes" etc. The same model was considered in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b31">32]</ref>; <ref type="bibr" target="#b26">[27]</ref> also establishes links based on similarity (or equality) of constants appearing in di erent relational attributes. As explained in Section 2.3, our problem is (much) harder since our trees can traverse edges in both directions, and paths can be (much) longer than those based on PK-FK alone. <ref type="bibr" target="#b29">[30]</ref> proposes to incorporate user feedback through active learning to improve the quality of answers in a relational data integration setting. We are working to devise such a learning-to-rank approach for our graphs, also.</p><p>KS has also been studied in XML documents <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b24">25]</ref>.</p><p>Here, an answer is de ned as a subtree of the original document, whose leaves match the query keywords. This problem is much easier than the one we face, since: (i) an XML document is a tree, guaranteeing just one connection between any two nodes; in contrast, there can be any number of such connections in our graphs; (ii) the maximum size of an answer to a k-keywords query is k • h where h, the height of an XML tree, is almost always quite small, e.g., 20 is considered "quite high"; in contrast, with our bi-directional search, the bound is k • D where D is the diameter of our graph -which can be enormously larger.</p><p>Our G and M steps are borrowed from <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b17">18]</ref>, which address KS for graphs, assuming optimal-substructure which does not hold for us, and single-direction edge traversal. For RDF graphs <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b21">22]</ref> traverse edges in their direction only; moreover, <ref type="bibr" target="#b21">[22]</ref> also make strong assumptions on the graph, e.g., that all non-leaf nodes have types, and that there are a small number of types (regular graph).     In <ref type="bibr" target="#b5">[6]</ref>, the authors investigate a di erent kind of answers to keyword search, the so-called r -clique graphs, which they solve with the help of speci c indexes. Keyword search across heterogeneous datasets has been previously studied in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b22">23]</ref>. However, in these works, each answer comes from a single dataset, that is, they never consider answers In the literature, (G)STP has been addressed under various simpli cations that do not hold in our context. For instance: the quality of a solution exponentially decreases with the tree size, thus search can stop when all trees are under a certain threshold <ref type="bibr" target="#b1">[2]</ref>; edges are considered in a single direction <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b31">32]</ref>; the cost function has the suboptimal-structure property <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b23">24]</ref> etc. assumptions reduce the computational cost; in contrast, to leave our options open as to the best score function, we worked to build a feasible solution for the general problem we study. Some works have focused on nding bounded (G)STP approximations, i.e., (G)STP trees solutions whose cost is at most f times higher than the optimal cost, e.g., <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>. Beyond the di erences between our problem and (G)STP, due notably to the fact that our score is much more general (Section 3), non-expert users nd it hard to set f .</p><p>Beyond the di erences we mentioned above, most of which concern our bidirectional search, and the lack of favorable cost hypothesis, our work is the rst to study querying of graphs originating from integrating several data sources, while at the same time preserving the identity of each node from the original document; this is a requirement for integrating, and simultaneously preserving, datasets of journalistic interest. In a companion paper <ref type="bibr" target="#b3">[4]</ref> we present our latest algorithms for creating such graphs, relying also on information extraction, data matching, and named entity disambiguation; earlier versions were outlined in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Sample dataset collection D.</figDesc><graphic coords="4,77.90,83.69,453.95,209.93" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Integrated graph corresponding to the datasets of Figure 1.</figDesc><graphic coords="4,103.12,319.98,403.52,222.49" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>and the query {a, b, c}, such that the keyword a matches the node a 1 , b matches b 1 and b 2 and c matches c 1 . Given our de nition of answers above, this query has no answer, because b matches the two nodes b 1 and b 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Illustration for speci city (re)computation. The speci city of the edge x l -→ n 1 , s(e) is initially computed out of the blue edges; when n 2 joins the equivalence set es 1 , it is recomputed to also re ect the violet edges.A naïve approach would be: when the edges of D 2 are traversed (when we add this dataset to the graph), re-traverse the edges of n 1 in D 1 in order to (re)compute their speci city. However, that would be quite ine cient.Instead, below, we describe an e cient incremental algorithm to compute speci city. We introduce two notations. For any edge e, we denote N e →• , respectively N e •→ , the two numbers out of which the speci city of e has been most recently computed5 . Speci cally, N e →• counts l-labeled edges incoming to the target of e, while N e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>2 0 1 0 1 →</head><label>211</label><figDesc>speci city of every llabeled edge e incoming either a node in es 1 or the node n 2 must be recomputed. Let e be such an incoming edge labeled l. When n 2 is added to the set es 1 , the speci city of e becomes 2/((N e →• + N l →n 2 ) + N e •→ ), to re ect that n 2 brings more incoming l-labeled edges. This amounts to 2/(3 + 2 + 1) = .33 in Figure 3: the violet edges have joined the blue ones. Following this adjustment, the numbers out of which e's speci city has been most recently computed are modi ed as follows: N e →• becomes N e →• + N l →n 2 , thus 3 + 2 = 5 in Figure 3; N e •→ remains unchanged. (2) If N l →es 1 = 0 and N l →n , the speci city of every llabeled edge e incoming n 2 does not change when n 2 joins the equivalence set es 1 . (3) If N l →es and N l →n 2 = 0, the newly added node n 2 does not change the edges adjacent to the nodes of es 1 , nor their speci city values. The last two cases, when N l es</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>5 s 6 n 7 s</head><label>567</label><figDesc>= .5, c = 1 s = .5, c = 1 s = .5, c = 1 s = .5, c = 1 n = .25, c = .5 s = 1, c = 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Example (non-monotonicity of the tree score). T is the four-edges tree rooted in n 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Sample answer trees for algorithm discussion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Outline of GAM algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Line graph execution time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>in the graph Execution time (ms) (b) Time to nd all answers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Chain graph execution time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>in the graph Execution time (ms) (b) to nd all answers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Star graph execution time Query keyword(s) Answers Answer trees Time to 1st (ms) Total time (ms)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Barabasi-Albert graph execution time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>For each w i , 1 ≤ i ≤ k • For each node n : try to merge every pair of trees from E, and process any resulting answer tree. Insert into U the pair (t, e), for each t ∈ E and e a data or similarity edge adjacent to t's root. (b) Create G 2R opportunities: Insert into U the pair (t, n → n r ep ) for each t ∈ E whose root is n, such that the representative of n is n r ep n. Let NT be a set of new trees obtained from the M</figDesc><table><row><cell cols="2">j i matching w i , let t  (3) Initialize U (empty so far): (2) Initial</cell><cell cols="2">j i be the 1-node tree consisting of n</cell><cell>j i ; process(t</cell><cell>j i )</cell></row><row><cell>(a) Create G opportunities: (4) While (U is not empty)</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">(a) Pop out of U the highest-priority pair (t, e).</cell></row><row><cell>(b) Apply the corresponding G</cell><cell cols="2">or G</cell><cell cols="2">2R , resulting in a new tree t ; process(t ).</cell></row><row><cell cols="3">(c) If t was not already in E, agressively M</cell><cell>:</cell></row><row><cell>(i)</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>*  </p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Results with real-world dataset</figDesc><table><row><cell>Macron</cell><cell>118</cell><cell>0</cell><cell>179</cell><cell>390</cell></row><row><cell>Trump</cell><cell>10</cell><cell>0</cell><cell>26</cell><cell>36</cell></row><row><cell>Melenchon</cell><cell>8</cell><cell>0</cell><cell>31</cell><cell>39</cell></row><row><cell>Christophe, Dettinger</cell><cell>1105</cell><cell>319611</cell><cell>136</cell><cell>123932</cell></row><row><cell>Etienne, Chouard, Rodrigues</cell><cell>1</cell><cell>194</cell><cell>144</cell><cell>146</cell></row><row><cell>Thierry-Paul, Valette, Drouet</cell><cell>0</cell><cell>300813</cell><cell>N/A</cell><cell>120001</cell></row><row><cell>Melenchon, Aubry</cell><cell>9</cell><cell>284</cell><cell>38</cell><cell>929</cell></row><row><cell>Castaner, ashball</cell><cell>17</cell><cell>1724</cell><cell>61</cell><cell>545</cell></row><row><cell>Drouet, Levavasseur</cell><cell>18</cell><cell>518</cell><cell>145</cell><cell>309</cell></row><row><cell>Dupont-Aignan, Chalencon</cell><cell>21</cell><cell>1850</cell><cell>53</cell><cell>393</cell></row><row><cell>Estrosi, Castaner</cell><cell>16</cell><cell>2203</cell><cell>205</cell><cell>529</cell></row><row><cell>Alexis, Corbiere, Ru n</cell><cell>11</cell><cell>3782</cell><cell>57</cell><cell>1022</cell></row><row><cell>Macron, Nunez</cell><cell>13</cell><cell>4107</cell><cell>1511</cell><cell>1561</cell></row><row><cell>Hamon, Drouet</cell><cell>5</cell><cell>421</cell><cell>71</cell><cell>145</cell></row><row><cell>Drouet, Ludosky</cell><cell>27</cell><cell>486</cell><cell>43</cell><cell>145</cell></row><row><cell>Salvini, Ludosky</cell><cell>17</cell><cell>1156</cell><cell>111</cell><cell>375</cell></row><row><cell>Salvini, Chouard</cell><cell>16</cell><cell>3205</cell><cell>76</cell><cell>710</cell></row><row><cell>Corbiere, Drouet</cell><cell>13</cell><cell>2341</cell><cell>129</cell><cell>673</cell></row><row><cell>Cauchy, Drouet</cell><cell>22</cell><cell>516</cell><cell>96</cell><cell>260</cell></row><row><cell>Benalla, Nunez</cell><cell>15</cell><cell>1027</cell><cell>199</cell><cell>347</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.lemonde.fr/les-decodeurs/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://team.inria.fr/cedar/contentcheck/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Our graph can also integrate other kinds of les, in particular PDF documents and spreadsheet les, by converting them to one or several instances of the above data models; as this is orthogonal wrt this paper, we delegate those details to<ref type="bibr" target="#b3">[4]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>This may be the case using a more advanced indexing system that includes some natural language understanding, term dictionaries etc.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>This can be either during the rst speci city computation of e, or during a recomputation, as discussed below.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Note that similarity edges do not raise the same problem, because in our graph we only have such edges if the similarity between two nodes is above a certain threshold τ . Thus, if a node n 1 is at least τ -similar to n 2 , and n 2 is at least τ -similar to n 3 , n 1 may be at least τ -similar to n 3 , or not. This leads to much smaller groups of similar nodes, than the groups of equivalent nodes we encountered.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements The authors would like to thank: <rs type="person">Helena Galhardas</rs> and <rs type="person">Julien Leblay</rs> who contributed to previous versions on this work [5,7] and <rs type="person">Tayeb Merabti</rs> for his support in the development and maintenance of the ConnectionLens system [4]. This work was partially supported by the <rs type="programName">H2020 research program</rs> under grant agreement nr. <rs type="grantNumber">800192</rs>, and by the <rs type="funder">ANR AI Chair SourcesSay</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_rdwR6tP">
					<idno type="grant-number">800192</idno>
					<orgName type="program" subtype="full">H2020 research program</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Emergence of Scaling in Random Networks</title>
		<author>
			<persName><forename type="first">Albert-László</forename><surname>Barabási</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Réka</forename><surname>Albert</surname></persName>
		</author>
		<idno type="DOI">10.1126/science.286.5439.509</idno>
		<ptr target="http://dx.doi.org/10.1126/science.286.5439.509" />
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">286</biblScope>
			<biblScope unit="page">5439</biblScope>
			<date type="published" when="1999">1999. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Social, Structured and Semantic Search</title>
		<author>
			<persName><forename type="first">Raphaël</forename><surname>Bonaque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bogdan</forename><surname>Cautis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Invisible Glue: Scalable Self-Tunning Multi-Stores</title>
		<author>
			<persName><forename type="first">Francesca</forename><surname>Bugiotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damian</forename><surname>Bursztyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Ileana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Graph integration of structured, semistructured and unstructured data for data journalism</title>
		<author>
			<persName><forename type="first">Oana</forename><surname>Bǎlǎlǎu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catarina</forename><surname>Conceia ¸o</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helena</forename><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tayeb</forename><surname>Merabti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingmao</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Youssr</forename><surname>Youssef</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-02904797" />
	</analytic>
	<monogr>
		<title level="j">BDA</title>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">C L : Finding Connections Across Heterogeneous Data Sources</title>
		<author>
			<persName><forename type="first">Camille</forename><surname>Chanial</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rédouane</forename><surname>Dziri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helena</forename><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julien</forename><surname>Leblay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minh</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Huong</forename><forename type="middle">Le</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<publisher>VLDB</publisher>
		</imprint>
	</monogr>
	<note>demonstration</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Keyword Query over Error-Tolerant Knowledge Bases</title>
		<author>
			<persName><forename type="first">Yu-Rong</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ye</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jia-Yu</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lei</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guo-Ren</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Science and Technology</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Keyword Search in Heterogeneous Data Sources</title>
		<author>
			<persName><forename type="first">Felipe</forename><surname>Cordeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helena</forename><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julien</forename><surname>Leblay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tayeb</forename><surname>Merabti</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-02559688Technicalreport" />
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Ranking Candidate Networks of relations to improve keyword search over relational databases</title>
		<author>
			<persName><forename type="first">Altigran</forename><surname>Pericles De Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edleno</forename><surname>Soares Da Silva</surname></persName>
		</author>
		<author>
			<persName><surname>Silva De Moura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Split Query Processing in Polybase</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Halverson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rimma</forename><surname>Nehme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinath</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josep</forename><surname>Aguilar-Saborit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Artin</forename><surname>Avanes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miro</forename><surname>Flasza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Gramling</surname></persName>
		</author>
		<idno type="DOI">10.1145/2463676.2463709</idno>
		<ptr target="http://dx.doi.org/10.1145/2463676.2463709" />
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Finding top-k min-cost connected trees in databases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Indexing Dataspaces</title>
		<author>
			<persName><forename type="first">Xin</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><surname>Halevy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The BigDAWG Polystore System</title>
		<author>
			<persName><forename type="first">Jennie</forename><surname>Duggan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><forename type="middle">J</forename><surname>Elmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Magda</forename><surname>Balazinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bill</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Kepner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Mattson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stan</forename><surname>Zdonik</surname></persName>
		</author>
		<idno type="DOI">10.1145/2814710.2814713</idno>
		<ptr target="http://dx.doi.org/10.1145/2814710.2814713" />
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Keyword Search over RDF Graphs</title>
		<author>
			<persName><forename type="first">Shady</forename><surname>Elbassuoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roi</forename><surname>Blanco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>W. H. Freeman &amp; Co</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A polylogarithmic approximation algorithm for the group Steiner tree problem</title>
		<author>
			<persName><forename type="first">N</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Konjevod</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ravi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast approximation of Steiner trees in large graphs</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">XRANK: Ranked keyword search over XML documents</title>
		<author>
			<persName><forename type="first">Lin</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chavdar</forename><surname>Botev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jayavel</forename><surname>Shanmugasundaram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2003 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">BLINKS: ranked keyword searches on graphs</title>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Hao He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">DISCOVER: Keyword Search in Relational Databases</title>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast Queries over Heterogeneous Data through Engine Customization</title>
		<author>
			<persName><forename type="first">Manos</forename><surname>Karpathiotakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioannis</forename><surname>Alagiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Ailamaki</surname></persName>
		</author>
		<idno type="DOI">10.14778/2994509.2994516</idno>
		<ptr target="http://dx.doi.org/10.14778/2994509.2994516" />
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Just-In-Time Data Virtualization: Lightweight Data Management with ViDa</title>
		<author>
			<persName><forename type="first">Manos</forename><surname>Karpathiotakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioannis</forename><surname>Alagiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Heinis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miguel</forename><surname>Branco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Ailamaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scalable Keyword Search on Large RDF Data</title>
		<author>
			<persName><forename type="first">Wangchao</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feifei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Songyun</forename><surname>Duan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">EASE: An E ective 3-in-1 Keyword Search Method for Unstructured, Semi-structured and Structured Data</title>
		<author>
			<persName><forename type="first">Guoliang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Beng</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Chin</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianhua</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianyong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizhu</forename><surname>Zhou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">E cient and Progressive Group Steiner Tree Search</title>
		<author>
			<persName><forename type="first">Rong-Hua</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Je</forename><surname>Rey Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rui</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><surname>Mao</surname></persName>
		</author>
		<editor>SIGMOD, Fatma Özcan, Georgia Koutrika, and Sam Madden</editor>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Identifying meaningful return information for XML keyword search</title>
		<author>
			<persName><forename type="first">Ziyang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2007 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="329" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Pig Latin: A Not-so-Foreign Language for Data Processing</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Utkarsh</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ravi</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Tomkins</surname></persName>
		</author>
		<idno type="DOI">10.1145/1376616.1376726</idno>
		<ptr target="http://dx.doi.org/10.1145/1376616.1376726" />
	</analytic>
	<monogr>
		<title level="m">SIGMOD (SIGMOD &apos;08)</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Ecient Keyword Search Across Heterogeneous Relational Databases</title>
		<author>
			<persName><forename type="first">Mayssam</forename><surname>Sayyadian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hieu</forename><surname>Lekhac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anhai</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Gravano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Hive: A Warehousing Solution over a Map-Reduce Framework</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Thusoo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sen</forename><surname>Joydeep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Namit</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zheng</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prasad</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suresh</forename><surname>Chakka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Anthony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pete</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghotham</forename><surname>Wycko</surname></persName>
		</author>
		<author>
			<persName><surname>Murthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A graph method for keyword-based selection of the top-K databases</title>
		<author>
			<persName><forename type="first">Quang Hieu</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Beng</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Chin</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dimitris</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Active learning in keyword search-based data integration</title>
		<author>
			<persName><forename type="first">Zhepeng</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nan</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Partha</forename><surname>Pratim Talukdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cong</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page">5</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Keyword Search in Databases</title>
		<author>
			<persName><forename type="first">Je</forename><surname>Rey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
		<idno type="DOI">10.2200/S00231ED1V01Y200912DTM001</idno>
		<ptr target="http://dx.doi.org/10.2200/S00231ED1V01Y200912DTM001" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Keyword Search in Relational Databases: A Survey</title>
		<author>
			<persName><forename type="first">Je</forename><surname>Rey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lijun</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Apache Spark: A Uni ed Engine for Big Data Processing</title>
		<author>
			<persName><forename type="first">Matei</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reynold</forename><forename type="middle">S</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Wendell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tathagata</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Armbrust</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankur</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangrui</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josh</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shivaram</forename><surname>Venkataraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
