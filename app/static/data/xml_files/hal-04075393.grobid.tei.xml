<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Improved Complexity Results and an Efficient Solution for Connected Multi-Agent Path Finding</title>
				<funder ref="#_C2TvAnA">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Isseïnie</forename><surname>Calviac</surname></persName>
							<email>isseinie.calviac@ens-rennes.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS Rennes</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ocan</forename><surname>Sankur</surname></persName>
							<email>ocan.sankur@cnrs.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS Rennes</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">François</forename><surname>Schwarzentruber</surname></persName>
							<email>francois.schwarzentruber@ens-rennes.fr</email>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">CNRS Rennes</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Improved Complexity Results and an Efficient Solution for Connected Multi-Agent Path Finding</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">61932A4FB46E2A29EE8E42F8590847F8</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>AI planning</term>
					<term>multi-agent path finding</term>
					<term>connectivity</term>
					<term>CA</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Connected multi-agent path finding (CMAPF) consists in computing paths for multiple agents which must reach a goal configuration while remaining connected at all steps. We prove the PSPACEhardness of the problem when the underlying graph is a subgraph of a 3D grid and with range-based connectivity. Moreover, we provide an application of the WHCA * algorithm and show that it outperforms previously given algorithms by an order of magnitude in terms of the sizes of the instances it can handle.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Multiple agents may have to cooperate in various situations in order to achieve a goal, such as search and rescue missions, or nuclear decommissioning. Some applications require agents to remain connected during the mission, for example, in order to transmit a video stream or other data to human operators <ref type="bibr" target="#b0">[1]</ref>.</p><p>In this article, we study the so-called Connected Multi-Agent Path Finding (CMAPF) problem <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b15">16]</ref> which is the extension of the multi-agent path finding problem <ref type="bibr" target="#b7">[8]</ref> to deal with connectivity constraints between agents. In this setting, the environment is modeled by a graph whose nodes are locations that can be occupied by a single agent at any time. There are two types of edges: movement and communication edges. Agents start in some starting locations (sources) and have to reach target locations, while forming a connected graph through communication edges at each step.</p><p>In <ref type="bibr" target="#b15">[16]</ref>, the authors prove that CMAPF is PSPACE-complete in general graphs, and give one deterministic and two randomized algorithms which consist in greedily selecting a successor configuration at each step so as to build an execution towards the targets. Surprisingly, their algorithms do not consider the collision constraints (i.e. allow collisions between agents). This study however does not fully settle the theoretical complexity of the problem. In fact, PSPACE-hardness result requires arbitrary graphs. Although the movement edges form a planar graph in their reduction, the communication graph has a very particular shape, and is far from being planar. So the PSPACE-hardness holds but on graphs that may look artificial. Many applications of MAPF are actually restricted to subgraphs of grids <ref type="bibr" target="#b6">[7]</ref>, and communication is often determined by range <ref type="bibr" target="#b0">[1]</ref>, that is, two agents can communicate whenever their distance is smaller than a given threshold. Our first objective in this paper was therefore to establish the complexity of the problem for subgraphs of grids and range-based communication. Second, algorithmic solutions given in <ref type="bibr" target="#b15">[16]</ref> do not scale beyond about 10-20 agents (despite allowing collisions between agents). Our second objective was to show that it is possible to derive much more efficient algorithmic solutions for the CMAPF problem by exploiting the multi-agent planning literature. Moreover, we enforce collision constraints, since we believe that the CMAPF problem only makes sense when both collision and connectivity constraints are taken into consideration.</p><p>This paper provides two contributions.</p><p>(1) First we show that CMAPF is PSPACE-hard even when agents move in a subgraph of a 3D grid, and with rangebased communication, that is, when two agents can communicate when their distance is within a given range. Our reduction is from non-deterministic constraint logic (NCL) <ref type="bibr" target="#b4">[5]</ref>, and is based on <ref type="bibr" target="#b15">[16]</ref>. NCL is a computation model based on a so-called AND/OR graph in which edges are to be flipped sequentially. The main technical challenge we solve is to provide gadgets that mimic the sequential flips of edges. (2) Second, we provide an algorithmic solution based on windowed hierarchical cooperative A * (WHCA * ), and provide a randomized conflict resolution mechanism well adapted to connectivity constraints, which scales to instances with an order of magnitude more agents than <ref type="bibr" target="#b15">[16]</ref>. This solution has the advantage of being simple, and finding plans often quickly, and thus significantly improves over the previously given algorithms. Moreover, the randomization we introduce allows us to address the incompleteness of the basic WHCA * algorithm and solve more instances. For example, on some benchmarks, we were able to solve instances with about 80 agents where the performance of the previous algorithm dropped after about 10-20 agents.</p><p>Related Work. Connectivity constraints are very different in nature than collision constraints alone, so most techniques developed for MAPF in the literature do not easily apply to connectivity constraints. In fact, while collisions are often local (occur at a given time step) and mostly involve two or a few agents, connectivity constraints are global and continuous, that is, they involve the set of all agents and a violation of connectivity can span a large time window, if not the whole execution. So these conflicts cannot be dealt locally, unlike collision constraints.</p><p>The popular conflict-based search algorithm for MAPF <ref type="bibr" target="#b12">[13]</ref> (without connectivity) is difficult to generalize connectivity constraints although some attempt was made <ref type="bibr" target="#b9">[10]</ref> which allows collisions between agents and only focus on connectivity; but the scalability seemed limited. We also observe that allowing collisions has little interest in practice, and it renders the problem easier (this can also be observed in the experiments of <ref type="bibr" target="#b15">[16]</ref>). In instances with particular communication graphs called sight-moveable, and in the presence of a basis vertex to which the group of agents are to be constantly connected, the problem was shown to be in LOGSPACE <ref type="bibr" target="#b2">[3]</ref>. However, this does not apply to grid graphs with range-based communication.</p><p>MAPF with imperfect information has been considered in the literature, for instance <ref type="bibr" target="#b16">[17]</ref> or <ref type="bibr" target="#b8">[9]</ref>. The closer work seems to be <ref type="bibr" target="#b10">[11]</ref>. They also use topological graphs with both movement and communication edges. The connectivity is then taken into account to compute the knowledge of each agents. In our work, we consider the perfect information case where connectivity must be maintained.</p><p>Improvements over WHCA * have been considered e.g. <ref type="bibr" target="#b1">[2]</ref> that specifically target conflicts due to collisions. Some other algorithms that target collisions are <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. Algorithms combining plans for groups of agents such as <ref type="bibr" target="#b14">[15]</ref> are also difficult to apply here due to connectivity being a global constraint on all agents.</p><p>Outline In Section 2 we recall the background about CMAPF. In Section 3, we first recall NCL and then explain our reduction to prove that CMAPF is PSPACE-hard for 3D instances. Section 4 provides our algorithm and its performance against the state-of-art ones. Section 5 is the conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SETTING</head><p>The environment of the CMAPF problem is represented by a socalled topological graph 𝐺 = (𝑉 , 𝐸 𝑀 , 𝐸 𝐶 ) with a non-empty finite set 𝑉 of vertices, and with two types of undirected edges: the movement edges (set 𝐸 𝑀 ) and the communication edges (set 𝐸 𝐶 ). We denote 𝐺 𝑀 = ⟨𝑉 , 𝐸 𝑀 ⟩ and 𝐺 𝐶 = ⟨𝑉 , 𝐸 𝐶 ⟩. Figure <ref type="figure" target="#fig_0">1</ref> shows such a graph which contains 8 vertices. The solid lines represent the movement edges and the dashed ones the communication edges. The agents can thus move along the solid lines and communicate with other agents along the dashed ones. We consider 𝑛 agents that must move in 𝐺 𝑀 from their initial vertices to their target ones.</p><p>A configuration 𝑐 of 𝑛 agents in 𝑉 is a tuple of 𝑛 distinct vertices of 𝑉 , denoted (𝑐 1 , ...𝑐 𝑛 ) where for 𝑖 ∈ {1, ..., 𝑛}, 𝑐 𝑖 is the position</p><formula xml:id="formula_0">𝑠 2 𝑠 1 𝑠 3 𝑢 𝑣 𝑡 2 𝑡 3 𝑡 1 ⌣ 𝑎 1 ⌣ 𝑎 2 ⌣ 𝑎 3 (a)</formula><p>Step 0: agents are at the initial configuration</p><formula xml:id="formula_1">(𝑠 1 , 𝑠 2 , 𝑠 3 ) 𝑠 2 𝑠 1 𝑠 3 𝑢 𝑣 𝑡 2 𝑡 3 𝑡 1 ⌣ 𝑎 1 ⌣ 𝑎 2 ⌣ 𝑎 3 (b)</formula><p>Step 1: agents move to configuration (𝑠 2 , 𝑣, 𝑢)</p><formula xml:id="formula_2">𝑠 2 𝑠 1 𝑠 3 𝑢 𝑣 𝑡 2 𝑡 3 𝑡 1 ⌣ 𝑎 1 ⌣ 𝑎 2 ⌣ 𝑎 3 (c)</formula><p>Step 2: agents move to configuration (𝑣, 𝑡 2 , 𝑡 1 ) We allow agents to idle. Moreover, the agents must stay connected along their movements. We say that a configuration 𝑐 of 𝑛 agents is connected if and only if it forms a connected sub-graph of 𝐺 𝐶 . In Figure <ref type="figure" target="#fig_0">1</ref>, assume that we have 3 agents that must move from (𝑠 1 , 𝑠 2 , 𝑠 3 ) to (𝑡 1 , 𝑡 2 , 𝑡 3 ). The configuration (𝑠 1 , 𝑠 2 , 𝑠 3 ) is connected because (𝑠 1 , 𝑠 2 ), (𝑠 1 , 𝑠 3 ) ∈ 𝐸 𝐶 . Intuitively, agent at 𝑠 3 can communicate with the agent at 𝑠 2 via the agent at 𝑠 1 (multi-hop).</p><formula xml:id="formula_3">𝑠 2 𝑠 1 𝑠 3 𝑢 𝑣 𝑡 2 𝑡 3 𝑡 1 ⌣ 𝑎 1 ⌣ 𝑎 2 ⌣ 𝑎 3 (d)</formula><p>An execution 𝑒 of length ℓ is a sequence of configurations, denoted (𝑐 1 , ..., 𝑐 ℓ ) such that for each 𝑖 ∈ {1, ..., ℓ -1}, 𝑐 𝑖 and 𝑐 𝑖+1 are consequent. An execution 𝑒 of length ℓ is connected in the graph of communication 𝐺 𝐶 if for each 𝑖 ∈ {1, ..., ℓ }, 𝑐 𝑖 is connected. We want a connected execution from 𝑠 to 𝑡.</p><p>Importantly, as in MAPF (unlike <ref type="bibr" target="#b15">[16]</ref>), we suppose that agents do not collide. In other words, agents have distinct positions in all configurations. We thus consider here a simple form of collision constraints; one could as well consider forbidding taking the same edge in opposite directions <ref type="bibr" target="#b19">[20]</ref>.</p><p>Example 2.1. Figure <ref type="figure">2</ref> shows an example of a connected execution from the Figure <ref type="figure" target="#fig_0">1</ref>. Agents start in configuration (𝑠 1 , 𝑠 2 , 𝑠 3 ) (see Figure <ref type="figure" target="#fig_0">1(a)</ref>). Note that agent 𝑎 2 communicates indirectly with agent 𝑎 3 , via the agent 𝑎 1 . Then the agents move synchronously to configuration (𝑠 2 , 𝑣, 𝑢): agent 𝑎 1 moves to 𝑠 2 by taking the movement edge (𝑠1, 𝑠2) ∈ 𝐸 𝑀 , agent 𝑎 2 takes the edge (𝑠2, 𝑣) ∈ 𝐸 𝑀 and 𝑎 3 takes (𝑠3, 𝑢) ∈ 𝐸 𝑀 . At step 2, the configuration is (𝑣, 𝑡 2 , 𝑡 1 ). Note that now agent 𝑎 2 communicates directly with agent 𝑎 3 via the communication edge (𝑡 2 , 𝑡 1 ) ∈ 𝐸 𝐶 ; 𝑎 1 communicates with 𝑎 3 indirectly via 𝑎 2 . Definition 2.2 (CMAPF Problem). Given ⟨𝐺, 𝑠, 𝑡⟩ decide if there is a connected execution (𝑐 1 , ..., 𝑐 ℓ ) such that 𝑐 1 = 𝑠 and 𝑐 ℓ = 𝑡. We say that the execution is from 𝑠 to 𝑡.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>𝑥</head><p>The CMAPF problem was proven to be PSPACE-complete on general graphs <ref type="bibr" target="#b15">[16]</ref>. However, the reduction requires a connectivity graph 𝐺 𝐶 that is arbitrary and unrealistic. In the next section, we establish the PSPACE-hardness of the problem on instances defined on subgraphs of 3D grids, and with range-based communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PSPACE-COMPLETENESS IN 3D</head><p>We focus on 3D grid instances where the communication is rangebased.</p><p>Definition 3.1. A 3D grid topological graph is a triplet (𝐺, 𝑝𝑜𝑠, 𝜌) where 𝐺 = (𝑉 , 𝐸 𝑀 , 𝐸 𝐶 ) is a topological graph, 𝑝𝑜𝑠 is a position function 𝑝𝑜𝑠 : 𝑉 → N 3 , which is injective, and a radius 𝜌 which respects the following conditions:</p><p>(1) for all (𝑢, 𝑣) ∈ 𝐸 𝑀 ,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>|pos(𝑢).𝑥pos(𝑣).𝑥 | + |pos(𝑢).𝑦pos(𝑣).𝑦|+ |pos(𝑢).𝑧pos(𝑣).𝑧| ≤ 1,</head><p>where pos(𝑢).𝑥, pos(𝑢).𝑦, pos(𝑢).𝑧 denote the three components of pos(𝑢); (2) and (𝑢, 𝑣) ∈ 𝐸 𝐶 if and only if 𝑑 (pos(𝑢), pos(𝑣)) ≤ 𝜌, where 𝑑 is the Euclidean distance (range-based communication).</p><p>Example 3.2. Figure <ref type="figure" target="#fig_8">3</ref> shows a 3D grid topological graph with 13 vertices and with a radius 𝜌 = 2. The graph consists of two layers: the bottom layer (𝑧 = 0) contains 9 vertices, while the top layer (𝑧 = 1) contains 4 vertices. As shown, the graph can be seen a subgraph of the 3D grid. For instance, 𝑝𝑜𝑠 (𝑢) = (0, 2, 0), 𝑝𝑜𝑠 (𝑣) = (0, 1, 1) and 𝑝𝑜𝑠 (𝑤) = (2, 0, 0). An agent can move from layer 0 to layer 1 throw a movement edge from the node at position (1, 0, 0) to the node at position (1, 0, 1). We have:</p><formula xml:id="formula_4">• (𝑢, 𝑣) ∈ 𝐸 𝐶 because √ 0 2 + 1 2 + 1 2 = √ 2 ≤ 2; • (𝑢, 𝑤) ∉ 𝐸 𝐶 because √ 2 2 + 2 2 + 0 = √ 8 &gt; 2.</formula><p>Now, a 3D grid instance for the CMAPF problem is described by a 3D topological graph (𝐺, 𝑝𝑜𝑠, 𝜌, 𝑠, 𝑡) where (𝐺, 𝑝𝑜𝑠, 𝜌) is a 3D grid topological graph, and two connected configurations 𝑠 and 𝑡. In this section, we prove the following theorem: Theorem 3.3. CMAPF is PSPACE-complete, even for a graph which is a 3D grid instance.</p><formula xml:id="formula_5">2 𝑒 1 2 𝑒 2 2 𝑒 3 1 𝑒 1 2 𝑒 2 1 𝑒 3 Figure 4:</formula><p>The two types of nodes in an AND/OR graph: OR node (left) and AND node (right). An OR node has three incident edges of weight 2 (blue), while an AND has two incident edges of weight 1 (red) and one of weight 2.</p><p>PSPACE membership holds because CMAPF is in PSPACE in the general case <ref type="bibr" target="#b15">[16]</ref>. The PSPACE-hardness on arbitrary graphs relies on a reduction from the the PSPACE-complete problem related to Nondeterministic Constraint Logic (NCL) <ref type="bibr" target="#b4">[5]</ref>. Here, we also provide a reduction from NCL, while our technical contribution consists in defining the reduction with the restrictions of a 3D grid graph, and only using range-based communication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Nondeterministic Constraint Logic</head><p>Let us recall that a graph is planar if there exists an injective embedding of the set of nodes in N 2 such that edges do not cross. An AND/OR graph is an undirected planar graph 𝔊 such that:</p><p>• each edge has a weight of either 1 or 2;</p><p>• each node is either an OR node, or an AND node (see Figure <ref type="figure">4</ref>; ignore the direction of edges for now). As shown in Figure <ref type="figure">4</ref>, a node has three incident edges 𝑒 1 , 𝑒 2 , 𝑒 3 . All are of weight 2 for an OR node. For an AND node, two of them, say 𝑒 1 , 𝑒 3 , are of weight 1 while the third one, 𝑒 2 , is of weight 2.</p><p>Given an AND/OR graph 𝔊, a configuration 𝛾 is an orientation of 𝔊, defining a direction for each edge in 𝔊; 𝛾 is valid if the in-flow of each node (the sum of the weights of the incoming edges) is at least 2 (in the directed graph defined by the pair (𝔊, 𝛾)). Concretely, for an OR node, at least one edge must enter the node. For an AND node, either 𝑒 2 enters the node or 𝑒 1 and 𝑒 3 both enter the node. Given two valid configurations 𝛾, 𝛾 ′ , we define an elementary step denoted, 𝛾 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Description of the reduction</head><p>Let us consider a NCL instance (𝔊, 𝛾 0 , 𝛾 𝑓 ). We show how to construct in poly-time a 3D CMAPF instance written 𝑡𝑟 (𝔊, 𝛾 0 , 𝛾 𝑓 ) = (𝐺, 𝑝𝑜𝑠, 𝜌, 𝑠, 𝑡) such that 𝛾 0 flip --→ . . . flip --→ 𝛾 𝑓 iff there is a connected execution from 𝑠 to 𝑡.</p><p>The 3D grid topological graph (𝐺, 𝑝𝑜𝑠, 𝜌) contains 5 layers as shown in Figure <ref type="figure" target="#fig_3">5</ref>. Each layer lies in a 𝑂𝑥𝑦-plane (a plane in which the 𝑧-coordinate is constant). As we will see, each layer contains some gadgets. As indicated in Figure <ref type="figure" target="#fig_3">5</ref>, layer 0 and 1 are at distance 2, and the 𝑂𝑥𝑦-plane between layer 0 and 1 does not contain any node (in other words, it is an obstacle). In the same way, layer 1 and 2 are at distance 8 and are separated by 7 𝑂𝑥𝑦-planes without any node (obstacle), and so on. Let 𝜌 = 10 be our communication radius. Encoding of the AND/OR graph 𝔊. We consider an embedding of 𝔊 in a 2D grid in which edges do not cross each other and follow the lines of the grid; such an embedding always exists and is computable in poly-time <ref type="bibr" target="#b11">[12]</ref>.</p><p>In layer 1, we place flipping agents that will simulate the directions of the edges on 𝔊. This layer has the same shape as the embedding of the AND/OR graph 𝔊 and each node in 𝔊 is replaced by a gadget of the form given in Figure <ref type="figure">6</ref>. The edge 𝑒 𝑖 in Figure <ref type="figure">4</ref> is symbolized by the path between nodes 𝑢 𝑖 and 𝑣 𝑖 , called an edge-path. For simplicity, in Figure <ref type="figure">4</ref>, the edge-path is depicted as a straight line, but in general it follows the shape of that edge in the planar AND/OR graph embedding. The flip of 𝑒 𝑖 corresponds to the agent moving from 𝑢 𝑖 to 𝑣 𝑖 , or from 𝑣 𝑖 to 𝑢 𝑖 . We say that a flipping agent is near 𝑢 𝑖 (resp. 𝑣 𝑖 ) when it is placed at a distance of at most 6 from 𝑢 𝑖 (resp. 𝑣 𝑖 ) on the layer 1. When the agent is placed near 𝑢 𝑖 (resp. near 𝑣 𝑖 ), it means that the edge 𝑒 𝑖 is going in (resp. out) the AND/OR node (in Figure <ref type="figure">4</ref>). A flipping agent can in general be anywhere on its edge-path between 𝑢 𝑖 and 𝑣 𝑖 . But when they are all near extremities 𝑢 𝑖 or 𝑣 𝑖 , this corresponds to an AND/OR graph configuration.</p><p>In order to impose the dynamics of NCL, we introduce layer 4 which is far from layer 1 and thus is not connected to it directly. Layer 4 contains just a complete grid of stationary agents (see Figure <ref type="figure" target="#fig_7">9</ref>) that are connected. We will introduce layer 2 and 3 that respectively impose that a configuration of the agents should represent a AND/OR configuration, and that a single flip occurs each time.</p><p>Connectivity for AND/OR configurations. Layer 2, shown in Fig. <ref type="figure" target="#fig_5">7</ref>, provides connectivity to flipping agents who are near some edgepath extremities 𝑢 𝑖 or 𝑣 𝑖 . It consists of stationary agents placed at the vertices 𝑢 ′ 𝑖 and 𝑣 ′ 𝑖 : vertex 𝑢 ′ 𝑖 (resp. 𝑣 ′ 𝑖 ) is placed exactly above 𝑢 𝑖 (resp. 𝑣 𝑖 ). Layer 2 is placed at a distance of 8 from layer 1. Thereby, a stationary agent only communicates with the flipping agent that is just below them (or almost below but near the extremity). More precisely, the flipping agent is near the extremity if and only if it communicates directly with the stationary agent above it, as √ 6 2 + 8 2 = 10. For instance, the stationary agent at 𝑢 ′ 𝑖 communicates with the agent near 𝑢 𝑖 if there is one. Note that the stationary agents are all connected to layer 4.</p><p>Flips. An elementary step 𝛾 flip --→ 𝛾 ′ consists in flipping exactly one edge. In other words, we should ensure that at most one flipping agent should move from an extremity to another. To do that, we introduce layer 3 made of a fully connected grid with a relay agent on it (Figure <ref type="figure" target="#fig_6">8</ref>). The idea is that the relay agent follows the flipping agent while she moves from 𝑢 𝑖 to 𝑣 𝑖 (or conversely). The layer 3 is at a distance of 10 from layer 1 to ensure that the relay agent provides the connectivity of layer 4 to at most one flipping agent that attempts to move.</p><p>NCL configurations should be valid. Last, we add layer 0 to ensure that the incoming flow in each AND/OR node is at least 2 (Figure <ref type="figure" target="#fig_9">10</ref>).</p><p>(a) An OR node must be pointed to by at least one edge, since all edges 𝑒 1 , 𝑒 2 and 𝑒 3 are of weight 2. In our construction, we need thus to ensure that at least one flipping agent must be near 𝑢 1 , 𝑢 2 or 𝑢 3 . To this aim, we introduce a line of agents 𝑎 1 , 𝑎 2 , 𝑎 3 that are all connected (see Figure <ref type="figure" target="#fig_9">10a</ref>). For them to be connected with all the other agents, one flipping agent must be near 𝑢 1 , 𝑢 2 or 𝑢 3 .</p><p>For instance, a flipping agent in 𝑢 1 provides direct connectivity to 𝑎 1 : the distance between 𝑢 1 and the position 𝑎 1 is √ 6 2 + 6 2 + 2 2 = √ 76 &lt; 10. Note that agents 𝑎 1 -𝑎 2 -𝑎 3 will not be connected otherwise: agents in layer 2 are too far from 𝑎 1 -𝑎 2 -𝑎 3 to provide connectivity to 𝑎 1 -𝑎 2 -𝑎 3 . (b) For an AND node, recall that the edges 𝑒 1 , 𝑒 2 and 𝑒 3 are of weights 1, 2 and 1 respectively. The constraint of having an in-flow of at least 2 can be reformulated by: (i) either 𝑒 1 or 𝑒 2 is pointing in (or both); (ii) and either 𝑒 2 or 𝑒 3 is pointing in (or both). We therefore add the line of agents 𝑎 ′ 1 -𝑎 ′ 2 (resp. 𝑎 ′′ 2 -𝑎 ′′ 3 ) for handling condition (i) (resp. (ii)). If 𝑒 1 and 𝑒 2 are pointing out (condition (i) is unsatisfied), then it means no agent is in 𝑢 1 (or nearby) and no agent is in 𝑢 2 (or nearby), then the agents 𝑎 ′ 1 -𝑎 ′ 2 are disconnected from the rest of the group. We defined the vertices of 𝑡𝑟 (𝔊, 𝛾 0 , 𝛾 𝑓 ) = (𝐺, 𝑠, 𝑡) as well as their positions. It remains to define 𝑠 and 𝑡. We show how to map and AND/OR graph configuration 𝛾 to a configuration of agents 𝑐 𝛾 . We define 𝑠 := 𝑐 𝛾 0 and 𝑡 := 𝑐 𝛾 𝑓 . For an AND/OR configuration 𝛾, 𝑐 𝛾 is the configuration in which, at each AND or OR node, in the corresponding gadget of Figure <ref type="figure">6</ref>, if 𝑒 𝑖 enters that node, then the corresponding agent is in 𝑢 𝑖 (and if 𝑒 𝑖 leaves that node, she is near 𝑣 𝑖 ). The relay agent is, say, at the bottom-left corner as in Figure <ref type="figure" target="#fig_6">8</ref>. The other agents are stationary so their positions are obvious.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Properties of the reduction</head><p>Proposition 3.6. 𝑡𝑟 (𝔊, 𝛾 0 , 𝛾 𝑓 ) = (𝐺, 𝑝𝑜𝑠, 𝜌, 𝑠, 𝑡) is computable in time polynomial in the size of 𝔊, 𝛾 0 , 𝛾 𝑓 .</p><p>Proof. The computation starts by computing an embedding for the graph 𝔊 in a grid in 𝑝𝑜𝑙𝑦 (|𝔊|) (this is doable via the result of</p><formula xml:id="formula_6">• 𝑧 𝑥 𝑦 𝑣 1 𝑢 1 𝑢 2 𝑣 2 𝑣 3 𝑢 3 ⌣ ⌣ ⌣ Figure 6</formula><p>: Layer 1: Three edge-paths that simulate an AND or OR vertex in the AND/OR graph. Each path 𝑢 𝑖 -𝑣 𝑖 , called an edge-path, corresponds to an edge in the AND/OR graph. For instance, the agent at 𝑢 1 can move along its edge-path until 𝑣 1 .</p><p>[12]). That embedding will then give the positions of the gadget on layer 0 and 1. □ We construct an execution from that sequence of flips as follows. For each flip of a given edge, we move the corresponding flipping agent to the other extremities (𝑢 𝑖 to 𝑣 𝑖 , or 𝑣 𝑖 to 𝑢 𝑖 ) with the relay agent moving above that flipping agent on the same way in its own layer 3. The obtained execution is connected. On the one hand, when flipping agents are at some 𝑢 𝑖 /𝑣 𝑖 , the connectivity is guaranteed by the agents of layer 2. On the other hand, when a flipping agent is moving, its connectivity is guaranteed by the relay agent. Agents 𝑎 1 -𝑎 2 -𝑎 3 and <ref type="figure" target="#fig_9">10</ref> remain connected to the rest of the group because the in-flow at each AND/OR node is at least 2.</p><formula xml:id="formula_7">𝑎 ′ 1 -𝑎 ′ 2 -𝑎 ′′ 2 -𝑎 ′′ 3 of Figure</formula><p>⇐ Conversely, consider a connected execution from 𝑠 to 𝑡. We extract a sequence of flips as follows. When a flipping agent moves far from an edge-path extremity, it must be accompanied by the relay agent in order to remain connected to the rest of the agents. During its move, it starts near some 𝑢 𝑖 (or 𝑣 𝑖 ). If it goes back near the same extremity (𝑢 𝑖 to 𝑢 𝑖 , or 𝑣 𝑖 to 𝑣 𝑖 ), the move is simply ignored. Otherwise, if the flipping agent goes near the other extremity (𝑢 𝑖 to 𝑣 𝑖 , or 𝑣 𝑖 to 𝑢 𝑖 ), that move is interpreted as a flip of the corresponding edge. The sequence of flips extracted in that way transform 𝛾 0 into 𝛾 𝑓 . Again, as the agents of layer 0 are always connected, it guarantees that the in-flow at each AND/OR node during the extracted sequence of flips is at least 2. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ALGORITHM</head><p>In this section, we will present a simple algorithm to solve the connected MAPF problem. We first review previously published algorithms from <ref type="bibr" target="#b15">[16]</ref>, which will be the baseline for comparison.</p><p>6   One of the main difficulties in multi-agent path finding is combinatorial explosion due to the number of agents. In fact, from each configuration, there is, in general, an exponential number of successor configurations despite the connectivity constraints. Searching for a plan in an exponentially-branching state space is infeasible, and even choosing a good successor configuration is a nontrivial task. To deal with the large branching factor, a greedy approach was presented <ref type="bibr" target="#b15">[16]</ref> in which a heuristic A * search is used to select a successor configuration step by step to minimize the remaining distance to the target configuration. This becomes theoretically complete with an additional backtracking mechanism. The resulting algorithm is similar to a DFS over the configuration space guided by a heuristic; so it will be named simply DFS in our experiments. We use here the authors' own implementation modified to take collision constraints into account; this was a straightforward adaptation. The authors also present sampling-based algorithms</p><formula xml:id="formula_8">• 𝑧 𝑥 𝑦 ⌣ ⌣ ⌣ ⌣ ⌣ ⌣ 𝑣 ′ 1 𝑢 ′ 1 𝑢 ′ 2 𝑣 ′ 2 𝑣 ′ 3 𝑢 ′ 3</formula><formula xml:id="formula_9">• 𝑧 𝑥 𝑦 ⌣ 𝑎 1 ⌣ 𝑎 2 ⌣ 𝑎 3 ⌣ ⌣ ⌣ ⌣ ⌣</formula><p>(a) Simulating an OR node: agents from 𝑎 1 -𝑎 2 -𝑎 3 must be connected.</p><p>6  in which the successors are selected with a randomization scheme. These scale up to 10 agents <ref type="bibr" target="#b15">[16]</ref> but become inefficient above 20 agents. We will only consider the deterministic DFS algorithm as a representative of this approach. An algorithm is described in <ref type="bibr" target="#b5">[6]</ref> but within a different setting requiring only periodic connectivity.</p><formula xml:id="formula_10">• 𝑧 𝑥 𝑦 ⌣ 𝑎 ′ 1 ⌣ 𝑎 ′ 2 ⌣ 𝑎 ′′ 2 ⌣ 𝑎 ′′</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Our suggestion</head><p>We show here that a straightforward application of the windowed hierarchical cooperative A * (WHCA * ) <ref type="bibr" target="#b13">[14]</ref> with a simple randomized conflict resolution mechanism performs much better than the above algorithms from the literature. The idea of CA * , explained in our setting, is the following. In order to compute a plan for 𝑛 agents, we select a random total order of the agents. We first compute a shortest path 𝜌 1 for the first agent from their source to target vertices. At iteration 𝑖, we compute a shortest path 𝜌 𝑖 for the 𝑖-th agent from their source to target, but subject to the constraints of the previous agents: the 𝑖-th agent cannot occupy the same vertex as a previous agent at the same time step (that is, 𝜌 𝑖 𝑡 ≠ 𝜌 𝑗 𝑡 for all 1 ≤ 𝑗 &lt; 𝑖 and all 𝑡), and moreover they must be connected to one of the previous agents at all moments (that is, for each 𝑡, there exists 1 ≤ 𝑗 &lt; 𝑖 such that (𝜌 𝑗 𝑡 , 𝜌 𝑖 𝑡 ) ∈ 𝐸 𝐶 ). The algorithm retries different orderings until an execution is found. The window optimization consists in changing the order randomly after a certain number of steps. Furthermore, the hierarchical version uses heuristic values that are shortest path distances computed by ignoring all interactions between agents. With both optimizations, this defines the WHCA * algorithm. We call each iteration that starts from the source a trial.</p><p>It is known however that WHCA * is not complete <ref type="bibr" target="#b13">[14]</ref>: on some instances that a solution, WHCA * does not find one. The source of incompleteness is due to the fact that the algorithm assumes that one of the agents follows a shortest path. Such a situation is depicted in Fig. <ref type="figure" target="#fig_10">11</ref>. In the figure, the target of the upper agent is 𝑡 1 , and their shortest path moves upwards, and disconnects from the bottom agent. The bottom agent's situation is symmetric: they want to reach the vertex 𝑡 2 , and their shortest path moves down, disconnecting from the other agent. The only solution is to pass through the path at the middle; but then none of the agents use a shortest path, and WHCA * fails. WHCA * can also fail due to collision conflicts if the execution requires agents to idle, for instance, to let other agents pass. Randomized conflict resolution. We focus here on conflicts due to connectivity constraints, and introduce a simple mechanism to resolve such conflicts, well adapted to connectivity constraints. While running WHCA * , if no solution is found after 𝜃 trials, then we start each subsequent trial by randomly selecting a direction, and moving all agents from the source towards that direction for a number ℓ of steps using WHCA * , and continuing the trial from this new configuration to target. We also apply randomization inside each trial: if the execution has not been extended in the last 𝜃 ′ windows, then we move towards a random configuration, and continue our way towards target. We slowly increment ℓ after each trial so that if a longer execution towards a particular direction is necessary, this will be tried eventually. In Fig. <ref type="figure" target="#fig_10">11</ref>, moving the agents towards left (including upper or bottom left), for a few steps suffices to unblock the situation, a solution is found eventually.</p><formula xml:id="formula_11">𝜌 = 4 ⌣ ⌣ 𝑠 1 𝑠 2 𝑡 1 𝑡 2</formula><p>The resulting algorithm is probabilistically complete. In fact, when ℓ is sufficiently large, if there is a connected execution from the current configuration to goal configuration, then, there is a nonzero probability to pick precisely that execution. This holds at each step with a uniform lower bound on the probability; thus, it will eventually be picked with probability 1. Of course, no useful bound on the expected time can be obtained from this reasoning. Thus, we rather evaluate the algorithm empirically.    The approach of WHCA * is particularly well adapted for connected MAPF. In fact, due to connectivity, agents are tightly dependent on each other since none of them can travel far from the group. This makes the problem quite different than the disconnected case where interactions between agents can be sparse and local (only a few collisions might have to be addressed at distinct instants). In WHCA * , once an execution is found for a few agents, this can create a lot of room for the rest of the agents, and the search can find an execution quickly, or make progress towards the goal. Blocking situations are overcome by conflict resolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Experiments</head><p>We evaluate the WHCA * approach in comparison with the DFS algorithm from <ref type="bibr" target="#b15">[16]</ref> on four benchmarks: the maps Offices and Cubicles are 2D grids; Obstacles and Pyramid are in 3D. The bitmap images corresponding to each map are shown in Fig. <ref type="figure" target="#fig_12">12</ref>. The 3D maps were obtained from the bitmap image by copying it 5 times towards a third dimension, and adding obstacles at the free cells with a density of 15%. Similar benchmarks were considered in <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b15">16]</ref>; Offices appears in <ref type="bibr" target="#b5">[6]</ref>. For each 2 ≤ 𝑛 ≤ 80, we created 20 random instances with 𝑛 agents, on each map. The instances on the Cubicles were particular: we placed two agents at a position similar to that of Fig. <ref type="figure" target="#fig_10">11</ref> while others were assigned random positions.</p><p>In our implementation, at each trial, we compute the longest possible execution before changing the order of the agents. So trials do not necessarily change the ordering of the agents at predetermined window sizes, but only when the current ordering does not allow to make further progress. The program attempts to extend each trial 100 times with a random order; let us call these extension trials. This parameter was observed to work well on our benchmarks. A too small value meant that trials ended without making enough progress so solutions were found less often; and a too large value meant that too much time was spent in each trial so less time could be spent for remaining trials. We show the performance with 300 extension trials in Fig. <ref type="figure" target="#fig_15">15</ref> where a performance drop was observed. We allowed the solver 5 minutes per instance. The parameters used in conflict resolution was 𝜃 = 5, ℓ = 10. A small (arbitrary) value for 𝜃 was convenient here because WHCA * alone could not make any progress from the source configuration in Cubicles, a small value meant that this initial conflict could be resolved quickly. Moving towards a random direction for a small number of steps does not affect the feasibility of the instance; it can only slightly increase the total length of the computed plan.  The results are shown in Fig. <ref type="figure" target="#fig_13">13</ref> which gives the average success rates for the instances per number of agents. The success rate of WHCA * was systematically higher than that of DFS. The former scaled up to 80 agents on Pyramid and Obstacles maps, and up to about 30-40 on Offices and Cubicles. The performance of DFS dropped quickly, often after 10 agents. Figure <ref type="figure" target="#fig_14">14</ref> compares the execution times; the WHCA * solved a large number of instances; for instance, in Obstacles, the algorithm solved about 1200 instances (out of 1580) each under a minute, while the DFS algorithm could only solve about 400 instances each under a minute.</p><p>Figure <ref type="figure" target="#fig_15">15</ref> compares the success rates of the WHCA * algorithm with 100, 200, and 300 extension trials. A larger number means that the algorithm insists in trying to extend each trial. The performance in Offices improved as this number increased, presumably because a larger number of ordering changes is often required in this map, but that in Cubicles was better with a smaller number. A smaller number has the advantage of inducing more fresh trials within the given deadline. There was no substantial difference in performance in Pyramid and Obstacles maps.</p><p>In Fig. <ref type="figure" target="#fig_16">16</ref>, we show the effect of randomized conflict resolution on performance, particularly in the Cubicles instances which contain at least two agents placed in a position depicted in Fig. <ref type="figure" target="#fig_10">11</ref>. The success rate without randomization is 0 for small instances. For larger numbers of agents, this varies, in a rather unpredictable way but stays clearly lower than the success rate with randomization. This is due to randomly generated instances in which some agents can be placed near the problematic situation and render the instance solvable by WHCA * . Overall, randomization helped increase and stabilize the success rate. It did not have a large impact on performance on other maps (not shown here) where instances were generated completely randomly. However, on several instances of Offices and Obstacles we noticed that situations similar to Figure <ref type="figure" target="#fig_10">11</ref> did occur, and randomization did help solve the instances; these were however not frequent enough to be noticed on average plots because instances were generated randomly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>In this work, we proved the PSPACE-hardness of the CMAPF problem when the topological graph is a subgraph of a 3D grid under range-based communication, establishing the computational complexity in a more realistic setting than in the literature. The hardness for subgraphs of the 2D grid is open. Our experiments contained both 2D and 3D maps, but the shape of the map seemed to have more impact on performance than its dimension. An important question is automatizing the choice of the parameters used in WHCA * (such as ℓ, 𝜃, 𝜃 ′ ). We chose them empirically and specifically for our benchmarks, but other values might be preferable for maps of different shapes and sizes.</p><p>The connected coverage problem consists in finding an execution that visits all vertices and is similar to CMAPF <ref type="bibr" target="#b3">[4]</ref>. In particular, it is also PSPACE-complete. We conjecture that our reduction could be adapted to prove the PSPACE-hardness of the coverage problem in 3D.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example of a topological graph for the CMAPF problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 Figure 3 :</head><label>23</label><figDesc>Figure 3: 3D grid topological graph, with 13 vertices and with a radius 𝜌 = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>flip --→ 𝛾 ′ , iff 𝛾 ′ is obtained from 𝛾 by flipping the direction of exactly one edge. An NCL execution is a sequence of valid configurations 𝛾 0 , . . . , 𝛾 ℓ with 𝛾 𝑖 flip --→ 𝛾 𝑖+1 . Definition 3.4. The NCL reconfiguration problem is defined as follows: given an AND/OR graph 𝔊 and two valid configurations 𝛾 0 , 𝛾 𝑓 , does there exist an execution 𝛾 0 flip --→ . . . flip --→ 𝛾 𝑓 ? Theorem 3.5. [5] The NCL reconfiguration problem is PSPACEcomplete.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Sectional view of the organisation of the 3D topological graph 𝐺. Layers contain gadgets. Each layer is given with a summary of its contents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Proposition 3 . 7 .</head><label>37</label><figDesc>With 𝑡𝑟 (𝔊, 𝛾 0 , 𝛾 𝑓 ) = (𝐺, 𝑠, 𝑡), we have: 𝛾 0 flip ---→ . . . flip ---→ 𝛾 𝑓 iff there is a connected execution from 𝑠 to 𝑡. Proof. ⇒ Suppose 𝛾 0 flip --→ . . . flip --→ 𝛾 𝑓 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Layer 2: Stationary isolated agents placed above the extremities of the edge-paths.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Layer 3: a complete connected grid with a single so-called relay agent being moving on it.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Layer 4: a complete grid of isolated agents.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>3 (</head><label>3</label><figDesc>b) Simulating an AND node: agents from 𝑎 ′ 1 -𝑎 ′ 2 and 𝑎 ′′ 2 -𝑎 ′′ 3 must be connected.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Layer 0: handling the inflow of at least 2 at each node. Agents 𝑎 1 -𝑎 2 -𝑎 3 , 𝑎 ′ 1, 𝑎 ′ 2 , 𝑎 ′′ 2 , 𝑎 ′′ 3 are all isolated and thus stationary. Vertices shown in gray are those in Layer 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: An instance that is difficult for WHCA * . Agent at 𝑠 1 should reach 𝑡 1 , agent at 𝑠 2 should reach 𝑡 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: The four maps used to obtain topological graphs. Obstacles are black pixels. The communication range is 1 pixel for Offices and Obstacles, and 3 pixels for Cubicles and Pyramid.</figDesc><graphic coords="8,60.52,214.79,110.25,65.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Average success rate of the algorithms as a function of the number of agents. Each point (𝑥, 𝑦) means that a percentage of 𝑦 among the 20 instances with 𝑥 agents were solved each within the timeout (5 minutes).</figDesc><graphic coords="8,183.82,342.37,111.38,65.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Cactus plots of the execution times: point (𝑥, 𝑦) means that 𝑥 instances were solved each within 𝑦 seconds.</figDesc><graphic coords="8,55.48,342.37,109.69,65.81" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Success rates of WHCA * with 100, 200, and 300 extension trials with a 5 minute timeout per instance.</figDesc><graphic coords="9,77.90,188.37,192.00,87.75" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Success rates of WHCA * with and without randomized conflict resolution (for 100 extension trials).</figDesc><graphic coords="9,87.86,329.92,172.13,99.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>of the agent 𝑎 𝑖 . The initial configuration is 𝑠 = (𝑠 1 , ..., 𝑠 𝑛 ) and the final one 𝑡 = (𝑡 1 , ..., 𝑡 𝑛 ). Two configurations 𝑐 and 𝑐 ′ of length 𝑛 are consequent if and only if for each 𝑖 ∈ {1, ..., 𝑛} we have (𝑐 𝑖 , 𝑐 ′ 𝑖 ) ∈ 𝐸 𝑀 ; thus, each agent makes one move in 𝐺 𝑀 .</figDesc><table><row><cell>Step 3: agents are at the</cell></row><row><cell>final configuration</cell></row><row><cell>(𝑡 1 , 𝑡 2 , 𝑡 3 )</cell></row><row><cell>Figure 2: Example of connected execution.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Proc. of the 22nd International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2023), A. Ricci, W. Yeoh, N. Agmon, B. An (eds.), May 29 -June 2, 2023, London, United Kingdom.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This work was supported by the <rs type="funder">ANR EpiRL</rs> project <rs type="grantNumber">ANR-22-CE23-0029</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_C2TvAnA">
					<idno type="grant-number">ANR-22-CE23-0029</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Multirobot Exploration of Communication-Restricted Environments: A Survey</title>
		<author>
			<persName><forename type="first">F</forename><surname>Amigoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Banfi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Basilico</surname></persName>
		</author>
		<idno type="DOI">10.1109/MIS.2017.4531226</idno>
		<ptr target="https://doi.org/10.1109/MIS.2017.4531226" />
	</analytic>
	<monogr>
		<title level="j">IEEE Intelli. Sys</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="48" to="57" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Conflict-Oriented Windowed Hierarchical Cooperative A*</title>
		<author>
			<persName><forename type="first">Zahy</forename><surname>Bnaya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Felner</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICRA.2014.6907401</idno>
		<idno>3743-3748</idno>
		<ptr target="https://doi.org/10.1109/ICRA.2014.6907401" />
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Robotics and Automation (ICRA)</title>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Complexity of planning for connected agents</title>
		<author>
			<persName><forename type="first">Tristan</forename><surname>Charrier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arthur</forename><surname>Queffelec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ocan</forename><surname>Sankur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Schwarzentruber</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10458-020-09468-5</idno>
		<ptr target="https://doi.org/10.1007/s10458-020-09468-5" />
	</analytic>
	<monogr>
		<title level="j">Auton. Agents Multi Agent Syst</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">44</biblScope>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Complexity of planning for connected agents</title>
		<author>
			<persName><forename type="first">Tristan</forename><surname>Charrier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arthur</forename><surname>Queffelec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ocan</forename><surname>Sankur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Schwarzentruber</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10458-020-09468-5</idno>
		<ptr target="https://doi.org/10.1007/s10458-020-09468-5" />
	</analytic>
	<monogr>
		<title level="j">Auton. Agents Multi Agent Syst</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">44</biblScope>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">PSPACE-completeness of slidingblock puzzles and other problems through the nondeterministic constraint logic model of computation</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">A</forename><surname>Hearn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erik</forename><forename type="middle">D</forename><surname>Demaine</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2005.05.008</idno>
		<ptr target="https://doi.org/10.1016/j.tcs.2005.05.008" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">343</biblScope>
			<biblScope unit="page" from="72" to="96" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Multirobot Coordination With Periodic Connectivity: Theory and Experiments</title>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">A</forename><surname>Hollinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjiv</forename><surname>Singh</surname></persName>
		</author>
		<idno type="DOI">10.1109/TRO.2012.2190178</idno>
		<ptr target="https://doi.org/10.1109/TRO.2012.2190178" />
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Robotics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="967" to="973" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Lifelong multi-agent path finding in large-scale warehouses</title>
		<author>
			<persName><forename type="first">Jiaoyang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Tinka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Kiesel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">W</forename><surname>Durham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tk Satish</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Koenig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Conference on Artificial Intelligence</title>
		<meeting>the AAAI Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="11272" to="11281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">AI Buzzwords Explained: Multi-Agent Path Finding (MAPF)</title>
		<author>
			<persName><forename type="first">Hang</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Koenig</surname></persName>
		</author>
		<idno type="DOI">10.1145/3137574.3137579</idno>
		<ptr target="https://doi.org/10.1145/3137574.3137579" />
	</analytic>
	<monogr>
		<title level="j">AI Matters</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Implicitly Coordinated Multi-Agent Path Finding under Destination Uncertainty: Success Guarantees and Computational Complexity</title>
		<author>
			<persName><forename type="first">Bernhard</forename><surname>Nebel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Bolander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Engesser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Mattmüller</surname></persName>
		</author>
		<idno type="DOI">10.1613/jair.1.11376</idno>
		<ptr target="https://doi.org/10.1613/jair.1.11376" />
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="497" to="527" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">Arthur</forename><surname>Queffelec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ocan</forename><surname>Sankur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Schwarzentruber</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2006.03280</idno>
		<title level="m">Conflictbased search for connected multi-agent path finding</title>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Planning for Connected Agents in a Partially Known Environment</title>
		<author>
			<persName><forename type="first">Arthur</forename><surname>Queffelec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ocan</forename><surname>Sankur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Schwarzentruber</surname></persName>
		</author>
		<ptr target="https://hal.archives-ouvertes.fr/hal-03205744" />
	</analytic>
	<monogr>
		<title level="m">AI 2021 -34th Canadian Conference on Artificial Intelligence</title>
		<meeting><address><addrLine>Vancouver / Virtual, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Embedding Planar Graphs on the Grid</title>
		<author>
			<persName><forename type="first">Walter</forename><surname>Schnyder</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=320176.320191" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<editor>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</editor>
		<meeting>the First Annual ACM-SIAM Symposium on Discrete Algorithms<address><addrLine>San Francisco, California</addrLine></address></meeting>
		<imprint>
			<publisher>SIAM</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="138" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Conflictbased search for optimal multi-agent pathfinding</title>
		<author>
			<persName><forename type="first">Guni</forename><surname>Sharon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roni</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Felner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><forename type="middle">R</forename><surname>Sturtevant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">219</biblScope>
			<biblScope unit="page" from="40" to="66" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Cooperative Pathfinding</title>
		<author>
			<persName><forename type="first">David</forename><surname>Silver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment</title>
		<meeting>the First AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment<address><addrLine>Marina del Rey, California</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="117" to="122" />
		</imprint>
	</monogr>
	<note>AIIDE&apos;05)</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Complete Algorithms for Cooperative Pathfinding Problems</title>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Standley</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Korf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-Second International Joint Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Multiagent Connected Path Planning: PSPACE-Completeness and How to Deal With It</title>
		<author>
			<persName><forename type="first">Davide</forename><surname>Tateo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Banfi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Riva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Amigoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Bonarini</surname></persName>
		</author>
		<idno type="DOI">10.1609/aaai.v32i1.11587</idno>
		<ptr target="https://doi.org/10.1609/aaai.v32i1.11587" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Conference on Artificial Intelligence</title>
		<meeting>the AAAI Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2018-04">2018. Apr. 2018</date>
			<biblScope unit="volume">32</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Path Planning for Multiple Agents under Uncertainty</title>
		<author>
			<persName><forename type="first">Glenn</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howie</forename><surname>Choset</surname></persName>
		</author>
		<ptr target="https://aaai.org/ocs/index.php/ICAPS/ICAPS17/paper/view/15756" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Seventh International Conference on Automated Planning and Scheduling, ICAPS 2017</title>
		<editor>
			<persName><forename type="first">Laura</forename><surname>Barbulescu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jeremy</forename><surname>Frank</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stephen</forename><forename type="middle">F</forename><surname>Mausam</surname></persName>
		</editor>
		<editor>
			<persName><surname>Smith</surname></persName>
		</editor>
		<meeting>the Twenty-Seventh International Conference on Automated Planning and Scheduling, ICAPS 2017<address><addrLine>Pittsburgh, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2017-06-18">2017. June 18-23, 2017</date>
			<biblScope unit="page" from="577" to="585" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">MAPP: A Scalable Multi-Agent Path Planning Algorithm with Tractability and Completeness Guarantees</title>
		<author>
			<persName><forename type="first">Cindy</forename><surname>Ko-Hsin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><surname>Botea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Int. Res</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="90" />
			<date type="published" when="2011-09">2011. sep 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fast and Memory-Efficient Multi-Agent Pathfinding</title>
		<author>
			<persName><forename type="first">Cindy</forename><surname>Ko-Hsin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><surname>Botea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICAPS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="380" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Collision-Free Route Planning for Multiple AGVs in an Automated Warehouse Based on Collision Classification</title>
		<author>
			<persName><forename type="first">Zheng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qing</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peijiang</forename><surname>Yuan</surname></persName>
		</author>
		<idno type="DOI">10.1109/ACCESS.2018.2819199</idno>
		<ptr target="https://doi.org/10.1109/ACCESS.2018.2819199" />
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="26022" to="26035" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
