<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Knowledge-Preserving Certain Answers for SQL-like Queries</title>
				<funder ref="#_3Rs4XBt">
					<orgName type="full">Foundation Sciences Mathématiques de Paris</orgName>
				</funder>
				<funder ref="#_rppCx5u #_dp29UzK">
					<orgName type="full">EPSRC</orgName>
				</funder>
				<funder ref="#_kyEt7KZ">
					<orgName type="full">EPSRC Centre</orgName>
				</funder>
				<funder ref="#_bjmZcbk">
					<orgName type="full">Royal Society</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Etienne</forename><surname>Toussaint</surname></persName>
							<email>etienne.toussaint@ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
							<email>paolo.guagliardo@ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
							<email>libkin@ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">ENS-Paris</orgName>
								<address>
									<country>PSL</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Neo4j</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Knowledge-Preserving Certain Answers for SQL-like Queries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">281D5E9F44DFEA8C6223E1747B4B713B</idno>
					<idno type="DOI">10.24963/kr.2020/78</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Answering queries over incomplete data is based on finding answers that are certainly true, independently of how missing values are interpreted. This informal description has given rise to several different mathematical definitions of certainty. To unify them, a framework based on "explanations", or extra information about incomplete data, was recently proposed. It partly succeeded in justifying query answering methods for relational databases under set semantics, but had two major limitations. First, it was firmly tied to the set data model, and a fixed way of comparing incomplete databases with respect to their information content. These assumptions fail for reallife database queries in languages such as SQL that use bag semantics instead. Second, it was restricted to queries that only manipulate data, while in practice most analytical SQL queries invent new values, typically via arithmetic operations and aggregation. To leverage our understanding of the notion of certainty for queries in SQL-like languages, we consider incomplete databases whose information content may be enriched by additional knowledge. The knowledge order among them is derived from their semantics, rather than being fixed a priori. The resulting framework allows us to capture and justify existing notions of certainty, and extend these concepts to other data models and query languages. As natural applications, we provide for the first time a well-founded definition of certain answers for the relational bag data model and for valueinventing queries on incomplete databases, addressing the key shortcomings of previous approaches.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many data analysis tasks that occur in traditional AI applications rely on the standard trusted database technology to produce final solutions to a problem. Most of such applications in a very natural way produce data that is incomplete; in particular, data with missing values represented as NULLs in SQL. Even though SQL has no explicit support for dealing with incompleteness and does not even specify whether NULL denotes a non-applicable or missing value, one can always consider a setting where non-applicable nulls have been removed -e.g., by using the techniques of <ref type="bibr" target="#b12">(Franconi and Tessaris 2012)</ref> -and NULLs only denote missing values. These commonly occur in ontology-mediated query answering <ref type="bibr" target="#b4">(Bienvenu and Ortiz 2015;</ref><ref type="bibr" target="#b26">Poggi et al. 2008;</ref><ref type="bibr" target="#b20">Kontchakov et al. 2011)</ref>, data integration <ref type="bibr" target="#b21">(Lenzerini 2002;</ref><ref type="bibr" target="#b6">Calì, Lembo, and Rosati 2003)</ref>, data exchange <ref type="bibr" target="#b2">(Arenas et al. 2014)</ref>, and handling inconsistent data <ref type="bibr" target="#b3">(Bertossi 2011)</ref>.</p><p>Reliance on database techniques imposes significant limits on queries that can be answered correctly. Indeed, an experimental study showed that common benchmark queries with negation produce unreliable results <ref type="bibr" target="#b15">(Guagliardo and Libkin 2016)</ref>. Unfortunately, our technical arsenal for correct query answering on incomplete databases is still rather limited. This is especially so when it comes to queries most commonly found in real-life scenarios.</p><p>Since the early days of database field, the standard approach to answering queries over incomplete databases has been based on finding answers one can be certain about, regardless of the interpretation of the missing data. This notion was introduced about 40 years ago <ref type="bibr" target="#b14">(Grant 1977;</ref><ref type="bibr" target="#b18">Jr. 1979;</ref><ref type="bibr" target="#b8">Codd 1979)</ref> and has since been studied on its own, leading to varying mathematical definitions of certainty <ref type="bibr" target="#b13">(Grahne 1991;</ref><ref type="bibr" target="#b28">van der Meyden 1998;</ref><ref type="bibr" target="#b19">Jr. 1984;</ref><ref type="bibr" target="#b17">Imielinski and Jr. 1984;</ref><ref type="bibr" target="#b0">Abiteboul, Segoufin, and Vianu 2006;</ref><ref type="bibr">Libkin 2016a;</ref><ref type="bibr">Libkin 2016b)</ref>. All these notions are traditionally tested against a single setting: first-order (or closely related) queries over relational databases, interpreted under set semantics. While understanding certainty and its computational properties in this setting was very useful <ref type="bibr" target="#b9">(Console et al. 2020)</ref>, it nonetheless falls short of what one needs to deal with in realistic everyday queries, like those written in SQL.</p><p>The key shortcomings of existing techniques are of two kinds. To start with, real-life databases operate with bags rather than sets. Syntactically straightforward extensions of certainty notions have been studied over bags <ref type="bibr" target="#b10">(Console, Guagliardo, and Libkin 2017)</ref> but they were not properly justified unlike their set-theoretic counterparts (and we shall see later that this indeed leads to serious problems with existing definitions). Furthermore, existing notions only work for queries that essentially manipulate data. Real-life queries also generate new data values, by means of, for example, arithmetic operations or aggregates. In fact, in the standard TPC-H benchmark for evaluating SQL-database performance, over 90% of queries are value-inventing <ref type="bibr">(TPC 2014)</ref>, and all of them use bag semantics.</p><p>Our goal is thus twofold. We want to build an abstract framework for justifying the notion of certainty, and upon validating it, we shall use it to explain what certainty is for realistic SQL-like queries that use bag semantics and valueinvention. By validating we mean that it should capture existing notions in the setting where they are well understood, namely relational databases under set semantics, and no value invention in queries.</p><p>We follow an approach advocated in <ref type="bibr">(Libkin 2016a</ref>) that has the advantage of being applicable in different data models. The key concept is that of informativeness of databases: a database x is more informative than a database y if all the possible worlds it represents are also possible worlds represented by y. Intuitively the more informative a database is, the fewer worlds it may represent and the less ambiguous it is. Then the certain answer to a query on an incomplete database x is the most informative database which is not more informative than the query answer on every possible world of x. This however may be too permissive as it misses the reason, or explanation, why a complete database is a possible world for an incomplete database x. In general an explanation can turn an incomplete object into a more informative object; explanations compose, and certain answers must preserve the informativeness order provided by the explanation. Such an order essentially says that applying an explanation to a database results in a more informative database. Using this idea, <ref type="bibr" target="#b1">(Amendola and Libkin 2018</ref>) developed a framework that was capable of explaining the commonly used definition of certainty of <ref type="bibr" target="#b19">(Jr. 1984)</ref>, for relational database queries under set semantics and informativeness orders naturally imposed by such a model. The main drawback of the approach is that it is too closely tied to a particular data model (relations as sets) and the informativeness orders it imposes, and to particular features of query languages (no bags, no value invention).</p><p>To overcome those problems, we refine the informationbased framework in a way that opens up an approach to defining certainty for most typical queries that occur in SQLlike languages over real-life databases. The key concept is that of knowledge preservation to improve the information content of answers to queries on incomplete databases. Intuitively, the interpretation of missing data may be specified by some additional knowledge, and hence the information content of a database is defined with respect to this knowledge. Consequently, certainty of an answer to a query q on a database x means two things. First, it is no more informative than answers to q in all possible worlds x. Second, if c is a possible world for x obtained by providing some new knowledge, then the answer to q on c must also be a possible world for the answer to q on x with this new knowledge.</p><p>The main distinguishing feature of this approach is that we derive the knowledge-preserving information pre-order from the semantics of data, rather than have it as a basic notion in the model. The latter restricted us to a handful of cases where such an ordering already existed, such as familiar open-and closed-world interpretation of incomplete databases under set semantics. The new approach allows us to unify already existing notions of certain answers without using any specific database model. The framework is very natural to instantiate for other data models and for expressive query languages. We demonstrate it by showing that it allows us for the first time to give a well-founded notion of certain answers on bag relational databases. We demonstrate its additional power with respect to query language features by showing that we can define, again for the first time, a notion of certain answers for value-inventing queries. We can further use the approach to devise an implementationfriendly approximation scheme for such certain answers.</p><p>Organization Preliminary definitions and notation are introduced in Section 2, and in Section 3 we present our framework based a notion of certain answers that preserve knowledge. We then apply the general framework to two cases of practical interest: bag relational databases (Section 4) and value-inventing queries (Section 5). We conclude with final remarks and a discussion of future work in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We begin by introducing the basic notions and notation that we will use throughout the paper. The abstract framework is largely adapted from <ref type="bibr">(Libkin 2016a)</ref>, which itself was based on earlier work utilizing techniques from programming semantics and domain theory in handling incompleteness in databases such as <ref type="bibr" target="#b5">(Buneman, Jung, and Ohori 1991;</ref><ref type="bibr" target="#b27">Rounds 1991;</ref><ref type="bibr" target="#b22">Libkin 1995)</ref>. We refer the reader to <ref type="bibr" target="#b23">(Libkin 2011;</ref><ref type="bibr">Libkin 2016a</ref>) for more detailed information about such connections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Information-Based Certain Answers</head><p>A database domain D is a triple (I, C, • ), where I is a set of database objects, 1 C ⊆ I is the set of complete databases in I and • : I → P(C) is the semantic function that assigns a set of complete databases (possible worlds) to a database object. For notational convenience, we also use I D , C D , • D to refer to the set of incomplete databases, the set of complete databases, and the semantic function, respectively, of a database domain D. Intuitively, the more possible worlds an incomplete database represents, the more ambiguous it is. To make this intuition formal, with a database domain D = (I, C, • ) we associate an information pre-order D on I, defined as follows: x D y iff y ⊆ x . That is, a database x ∈ I is less informative than a database y ∈ I if every possible world of y is also a possible world of x. This is a pre-order (i.e., a reflexive transitive relation). The associated equivalence relations, when x D y and y D x, is denoted by x ≡ D y. We shall be using the notation X for x∈X x . Given two database domains S (for source) and T (for target), a query from S to T is a mapping q from C S to C T , i.e., it maps complete databases of a source database domain S to complete databases of a target database domain T. The standard way to define query answers on incomplete databases is by considering answers that are true in all possible worlds, that is, answers that are no more informative than the answers to the query on all possible worlds represented by the incomplete database. To this end, if C is a set of complete databases, we let q(C) = q(c) | c ∈ C Then, the information-based certain answer to a query q from S to T on an incomplete source database x ∈ I S is the greatest lower bound (denoted by glb ) of the query answers on the possible worlds of x with respect to the information pre-order: cert (q, x) = glb T q( x S )</p><p>(1) In other words, the information based-certain answer is the most informative database that is consistent, w.r.t. the information pre-order, with every possible answer to the query. In particular, we have q( x S ) ⊆ cert (q, x) T . Note that for general pre-orders, the greatest lower bound may not exist, especially for infinite sets, and even when it exists in (1), it is defined up to the ≡ T equivalence relation. We will see an example of information-based certain answers after introducing relational database domains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Relational Databases</head><p>In the context of relational databases, the standard model for representing incomplete data is that of marked nulls, where databases are populated by two kinds of values, constants and nulls. These come from two disjoint countably infinite sets, Const and Null, respectively. We denote the elements of Null using the symbol ⊥ with subscripts.</p><p>A relational database schema is a finite set of table names with associated arities, and a k-ary table is a finite bag (a.k.a. multiset) of k-tuples over Const ∪ Null. The number of occurrences of a tuple t in a table T is denoted by #(R, t). Then, a relational database d over a given schema maps each table name R in the schema to a table R d of appropriate arity. We write Const(d) and Null(d) for the set of constants and nulls occurring in d, respectively. For convenience of notation, we sometimes represent a relational database as a bag of facts; e.g.,</p><formula xml:id="formula_0">d = {|R(1, ⊥ 1 ), S(⊥ 1 , 2), R(1, ⊥ 1 )| } is the database d such that R d = {|(1, ⊥ 1 ), (1, ⊥ 1 )| } and S d = {|(⊥ 1 , 2))| }.</formula><p>A valuation is a partial function v from Null to Const. If v is defined on all elements of Null(d), we say that v is dcomplete. For t = (t 1 , . . . , t k ), we let v( t) denote the tuple ṽ(t 1 ), . . . , ṽ(t k ) , where ṽ is the total function on Null ∪ Const such that ṽ(t) = v(t) whenever v(t) is defined, and ṽ(t) = t otherwise. When tables are constrained to be sets, the result of applying a valuation v to a table T is the table v(T ) = {v( t) | t ∈ T }, and this extends to databases in the natural way. When tables are bags, things are slightly more complicated, as we shall see in Section 4.</p><p>A database domain</p><formula xml:id="formula_1">(I, C, • ) is relational if I is a set of relational databases and, for every d ∈ C ⊆ I, Null(d) = ∅.</formula><p>When tables are constrained to be sets, the two most common semantics of incompleteness, referred to as the semantics under open-world and closed-world assumptions (OWA and CWA), are defined as follows (cf. <ref type="bibr" target="#b17">(Imielinski and Jr. 1984;</ref><ref type="bibr" target="#b13">Grahne 1991</ref>)):</p><formula xml:id="formula_2">d OWA = {d complete | ∃ valuation v s.t. v(d) ⊆ d } d CWA = {d complete | ∃ valuation v s.t. v(d) = d }</formula><p>In other words, under CWA we simply replace nulls with constants, while under OWA we can also add extra tuples.</p><p>On relational databases, a query answer can be improved in two ways: by finding more tuples, or by instantiating nulls with values. This corresponds to the open-world semantics of incompleteness. Therefore, we assume that the the target domain of queries always uses the OWA semantics, while the source can use either the CWA or OWA semantics; see <ref type="bibr" target="#b9">(Console et al. 2020)</ref>.</p><p>Below, we recall two commonly used notions of certain answers due to <ref type="bibr" target="#b19">(Jr. 1984;</ref><ref type="bibr">Libkin 2016b;</ref><ref type="bibr" target="#b10">Console, Guagliardo, and Libkin 2017)</ref>. These apply for queries from relational database domains under OWA or CWA to relational database domains under OWA.</p><p>The intersection-based certain answer to a query q on a relational database d is the intersection of the answers to q on every possible world represented by d:</p><formula xml:id="formula_3">cert ∩ (q, d) = q(d ) | d ∈ d (2)</formula><p>The certain answer with nulls to a query q on a relational database d is the table cert ⊥ (q, d) such that, for every dcomplete valuation v and for every c ∈ v(d) , the multiplicity of each tuple in v cert ⊥ (q, d) is less than or equal to its multiplicity in q(c):</p><formula xml:id="formula_4"># cert ⊥ (q, d), t = min # q(c), v( t) | c ∈ v(d) , v is a d-complete valuation<label>(3)</label></formula><p>We remark that the above definition is implicit in (Console, Guagliardo, and Libkin 2017) and it is a natural extension of certain answers with nulls for sets <ref type="bibr">(Libkin 2016b</ref>) to bags.</p><p>The information-based notion of certain answers (1) is able to capture intersection-based certain answers. Let S be a relational database domains and T a complete relational database domain, i.e., relational databases without null values. Then, for every query q from S to T, either both the information-based certain answer cert (q, d) and the intersection-based certain answer cert ∩ (q, d) exist and coincide, or neither of them exists.</p><p>On the other hand, the information-based notion of certain answers fails to capture certain answers with nulls. This is due to the fact that it does not keep track of what nulls are mapped to, as the following example shows. Example 1. Consider the database d = {R(⊥ 1 , 1)} and a query q that returns the first and second columns of R plus an extra column with their sum. The most relevant answer one could expect is (⊥ 1 , 1, ⊥ 1 +1). But cert ⊥ (q, d) is the empty table, because it cannot capture the value ⊥ 1 +1. Indeed, for every null ⊥ there exits a valuation v such that v (⊥ 1 , 1, ⊥) is not in q v(d) . On the other hand, the information-based notion is more permissive, as cert (q, d) gives us a tuple of the form (⊥ i , 1, ⊥ j ), where ⊥ i and ⊥ j are fresh nulls. However, since null labels are not preserved, there is no relationship between ⊥ i and ⊥ j in the output, and ⊥ 1 in the input. In particular, it is not enforced that the value ⊥ i in the output and the value ⊥ 1 in the input must be equal (and that ⊥ j is equal to ⊥ 1 + 1).</p><p>We will later build on the above example to also show that neither information-based certain answers nor certain answers with nulls are entirely satisfactory. To reconcile the two notions, we introduce the concept of knowledge preservation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Knowledge-preserving Certain Answers</head><p>As explained earlier, an incomplete database x is less informative than y if every possible world of y is also a possible world of x. Suppose now that we discover some new information that reduces the ambiguity of x by eliminating some possible worlds; nothing ensures that this knowledge would also reduce the incompleteness of y. Indeed, it may well be the case that, in the presence of some additional knowledge, x would become more informative than y.</p><p>To make this intuition formal, we define the notion of universal knowledge K. Its elements are viewed as pieces of knowledge that can be applied to a database to make it potentially more informative. Such pieces of knowledge can be concatenated: applying ωω means applying ω first and then applying ω to the result of applying ω. Finally we have the empty knowledge ε: applying it to any database x does not change x. That is, K is a monoid as it has a binary concatenation operation ωω (which we assume to be associative) and the identity ε satisfying εω = ωε = ω.</p><p>Then, for a database domain (I, C, • ), the K-semantics of an incomplete database x ∈ I under knowledge ω ∈ K is the set x ω of complete databases in C represented by x when ω is known. We assume that, for any given database domain, such a semantic function from I × K to 2 C always exists and it is such that x ε = x for every x ∈ I. Intuitively, the empty knowledge does not give us any extra information about the semantics of incomplete databases.</p><p>As K contains all possible knowledge, it would be reasonable to assume that the K-semantics, while always existing, is not always fully known. Thus, we consider sub-monoids of K, in particular those whose knowledge increases the information content of database objects.</p><formula xml:id="formula_5">Definition 1. A sub-monoid A of the universal knowledge K is additional knowledge for a database domain D if ∅ x ωω D ⊆ x ω D (4)</formula><p>for every x ∈ I D and for every ω, ω ∈ A.</p><p>Intuitively, the information content of an incomplete database can only increase with the additional knowledge in A and is consistent with it. Note that {ε} is additional knowledge for every database domain and corresponds to the situation in which we only have "empty" knowledge.</p><p>We can now define the relative informativeness of incomplete databases in the presence of additional knowledge. Definition 2. Let A be additional knowledge for D, and let x, y ∈ I D . We say that x is less A-informative than y, and write x A D y, if y ω D ⊆ x ω D for every ω ∈ A. In other words, x is less informative than y under the additional knowledge A if, for every piece of knowledge ω ∈ A, each possible world of y under ω is also a possible world of x under ω. We omit the subscript in A D , and simply write A , when the database domain is clear from the context.</p><p>As shown below, additional knowledge conservatively extends the information-based framework of <ref type="bibr">(Libkin 2016a</ref>): if we do not have any knowledge beyond ε, we get the standard information pre-order ; but the more we discover -by means of additional knowledge -of the K-semantics of incomplete databases, the less permissive the information preorder becomes.</p><p>Proposition 1. The following are true:</p><formula xml:id="formula_6">(a) A is a pre-order; (b) {ε} is a equivalent to ; (c) If x A y, then x B y for every sub-monoid B of A.</formula><p>With this in place, our goal is to capture answers that are consistent with the answers on every possible world under every extra knowledge.</p><p>Definition 3 (Knowledge-preserving certain answer). Let q be a query from S to T, let x ∈ I S , and let A be additional knowledge for both S and T. The A-preserving certain answer to q on x, denoted by cert A (q, x), is the most informative database with respect to A that satisfies the following:</p><formula xml:id="formula_7">q x ω S ⊆ cert A (q, x) ω T (5)</formula><p>for every ω ∈ A.</p><p>This notion generalizes the information-based certain answer cert and it relies only on the existence of a possibleworlds semantics for the additional knowledge in A.</p><p>The A-preserving certain answer can also be interpreted as a kind of "synchronized" greatest lower bound, with respect to A , of the query answers on the possible worlds of the input:</p><formula xml:id="formula_8">cert A (q, d) = glb A q(x)</formula><p>where, for every knowledge ω ∈ K, the K-semantics of the artifact q(x) is given as q(x) ω T = q( x ω S ). The expected behavior of query answering under incomplete information is that more informative query inputs yield more informative query outputs. We show that this is indeed the case for certain answers that preserve additional knowledge. Moreover, the information-based certain answers are precisely the certain answers that preserve the empty knowledge.</p><p>Proposition 2 (Information preservation). Let A be a submonoid of K, and let q be a query from S to T. Then, for all x, y ∈ I S and every ω ∈ A, all of the following hold:</p><p>(a) If cert A (q, x) and cert A (q, y) exist and x A y, then cert A (q, x) A cert A (q, y); (b) cert A (q, x) B cert B (q, x) for every B ⊆ A; (c) cert (q, x) = cert {ε} (q, x).</p><p>The above also implies that information-based certain answers are the most informative answers one could expect with empty knowledge; however, they do not preserve nonempty knowledge in general. The following example shows why this is important.</p><p>Example 2. Consider again the setting of Example 1, and the extra piece of knowledge ω encoding the fact that the value of ⊥ j is 0. Clearly, the information content of the original database d is not increased by this new knowledge, since ⊥ j ∈ Null(d). But ⊥ j occurs in the information-based certain answer (⊥ i , 1, ⊥ j ), whose possible worlds under ω always contain the tuple (⊥ i , 1, 0). Thus, the informationbased certain answer under additional knowledge is not less informative than all possible answers under the same knowledge, and it may contain false tuples.</p><p>What this means is that information-based certain answers become irrelevant once we discover additional knowledge: they must be recomputed on a more informative database, if it exists. Knowledge-preserving certain answers do not have this shortcoming, as we show next.</p><p>Theorem 1. Let q be a query from S to T, let x ∈ I S , and let A be additional knowledge for both S and T. If cert A (q, x) exists, then</p><formula xml:id="formula_9">cert A (q, x) ω T ⊆ q( x ω S )<label>(6)</label></formula><p>for every ω ∈ A. Moreover, there exist a query q, database x ∈ I S and w ∈ A such that:</p><p>(a) cert (q, x) ω T ⊆ q( x ω S ), and (b) cert A (q, x) ω T ⊆ cert (q, x) T . Informally, knowledge-preserving certain answers remain relevant and consistent when new information is discovered. Moreover, there are queries for which this notion gives more informative answers under additional knowledge.</p><p>Next, we apply our general framework to relational databases, under the bag semantics that is the standard in all relational products. We do so in a setting where additional knowledge is given by partial valuations of nulls. We then show that the well-known certain answers with nulls corresponds to the valuation-preserving certain answers. We also use our results to justify notions used hitherto in the set semantics context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Certainty in Bag Relational Databases</head><p>Recall that an incomplete relational database is a finite set of tables populated by constants and nulls, and its semantics of incompleteness is given by instantiating nulls with constants by means of valuations.</p><p>Definition 4. The monoid of partial valuations V ⊆ K consists of all partial functions from Null to Const. Moreover, for every v, v ∈ V, the K-semantics of incomplete relational databases is</p><formula xml:id="formula_10">d vv = v v(d) .</formula><p>We immediately have that the knowledge encoded by V is additional to the relational database domain for both closed and open world semantics. However, so far we have not explained how a valuation v is applied to a relational database d. When tables T are constrained to be sets, there is no ambiguity on how to construct v(T ). But when they are bags, there are several possibilities, each leading to different semantics <ref type="bibr" target="#b16">(Hernich and Kolaitis 2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Collapsing and Additive Semantics</head><p>The first construction we study prescribes that, when a valuation is applied to a table, distinct tuples that become equal (i.e., unify) under the valuation are "collapsed" together, so that the maximum number of occurrences of each such tuple appears in the result. Definition 5. The collapsing application of a valuation v on a table T is the table v(T ) such that for every tuple t</p><formula xml:id="formula_11"># v(T ), t = max #(T, ū) | v(ū) = t</formula><p>For example, consider a table T given by the following bag:</p><formula xml:id="formula_12">{|(1, 2), (⊥ 1 , 2), (1, ⊥ 2 ), (1, ⊥ 2 )| } (7</formula><p>) and a valuation v such that v(⊥ i ) = i for every i. Then, the collapsing application of v to T is the table v(T ) given by the bag {|(1, 2), (1, 2)| }.</p><p>Intuitively, when valuations are applied in such a way, incomplete facts only represent new information if they do not unify with already existing data. Below we show that, under this semantics of valuations, the certain answers with nulls coincide with the valuation-preserving ones. Proposition 3. Let S and T be relational database domains under the collapsing application of valuations. Then, for every query q from S to T and for every d ∈ I S , either both cert V (q, d) and cert ⊥ (q, d) exist and coincide, or neither of them exists.</p><p>We remark that the above result holds for databases under the bag data model, but also -in particular -when tables are constrained to be sets.</p><p>Since the collapsing semantics negates the importance of a tuple's identity by disregarding -to some extent -its multiplicity, the most commonly used semantics is instead one where the multiplicities of tuples that become equal under a valuation are added up in the result. Definition 6. The additive application of a valuation v on a table T is the table v(T ) such that for every tuple t</p><formula xml:id="formula_13"># v(T ), t = ū : v(ū)= t #(T, ū)</formula><p>To see the difference with the collapsing semantics, consider again the table T given by the bag in (7), and the same valuation v such that ⊥ i → i. The additive application of v to T results in a table v(T ) consisting of 4 (as opposed to 2) occurrences of the tuple (1, 2). When valuations are applied in such an additive way, incomplete facts always represent new information even if they unify with already existing data, in contrast with the collapsing semantics discussed earlier.</p><p>However, while more natural, this semantics of valuations leads to problems in terms of certain answers, as shown below. Theorem 2. There exists a union of conjunctive queries with negation where the source and target database domain are relational database with additive semantics, such that:</p><p>(a) the valuation-preserving certain answer does not exist;</p><p>(b) the {ε}-preserving certain answer does not exist.</p><p>(c) the certain answer with nulls is not less informative than every possible answer.</p><p>Below we give an example in which the certain answer with nulls to a query q on a database d is not less informative than the answer to q on some possible world of d. Example 3. Consider the following database D:</p><formula xml:id="formula_14">R A B C 1 ⊥ 1 2 ⊥ 2 2 1 S A B C D 1 2 ⊥ 2 ⊥ 1 T A B 1 2</formula><p>and the following relational algebra query q:</p><formula xml:id="formula_15">π A,B σ A =C∧B =C (R) π A,B σ A=C∧B=D (S) T Then, cert ⊥ (q, D) is the bag {|(1, 2), (1, ⊥ 1 ), (⊥ 2 , 2)| }. If we take a valuation v such that v(⊥ 1 ) = 2 and v(⊥ 2 ) = 1, then {|(1, 2); (1, 2)| } belongs to q v(D)</formula><p>. But with the additive semantics cert ⊥ (q, D) contains at least three tuples and so it cannot be less informative than q v(D) . The answers</p><formula xml:id="formula_16">A 1 = {|(1, 2)| } and A 2 = {|(1, ⊥ i ), (⊥ k , 2)</formula><p>| } are both less informative than every element of q( d ). Thus, cert (q, D) should be more informative than both A 1 and A 2 . We clearly have that A 1 A 2 and A 2 A 1 ; moreover, it is easy to check that we cannot increase the information content of A 1 or A 2 and still be less informative than the answer to q on every possible world described by D. Therefore, the information-based certain answer does not exist.</p><p>The above result tells us that, under additive valuations, the notion of certain answers with nulls is not well-founded, as even for simple queries they may not be less informative than the query answers on every possible world. Thus, some fact in the certain answers with nulls might be false.</p><p>Moreover, Example 2 showed that the information-based certain answer can be strictly less informative than the certain answer with nulls, and Proposition 2 states that, for every knowledge, the knowledge-preserving certain answer is no more informative than the information-based certain answer. Therefore, there is no additional knowledge such that knowledge-preserving certain answers capture certain answers with nulls. We argue that this is due to the additive semantics itself.</p><p>To see this, consider two incomplete relational databases d 1 and d 2 of the same schema. Then, under OWA and collapsing valuations, we can always build a database d 3 such that</p><formula xml:id="formula_17">d 3 = d 1 ∩ d 2 = d 1 ∪ d 2 , where ∪ denotes the union- max operator: #(T 1 ∪T 2 , t) = max #(T 1 , t), #(T 2 , t)</formula><p>. This ensures that, if we have a finite number of possible answers to a query, then the certain answers always exist. However, under additive valuations, we lose this property: as shown in Example 3, there exist databases d 1 and d 2 such that, for every database d 3 , we have d 3 = d 1 ∩ d 2 . This can be interpreted as a mismatch between the semantics and the set of incomplete objects.: there are not enough objects to capture the complexity of the semantics. Now that we have identified the problem, we can finally capture the notion of certain answers with nulls by changing the semantics of target. To do this under additive valuations, we need to interpret query answers under the collapsing semantics.</p><p>Proposition 4. Let S and T be relational database domains under the additive and collapsing application of valuations, respectively. Then, for every query q from S to T and for every database d ∈ I S , either both cert V (q, d) and cert ⊥ (q, d) exist and coincide, or neither of them exists.</p><p>Corollary 1. The result of Proposition 4 holds, in particular, for relational databases under set, rather than bag, semantics. In that context, the certain answer with nulls becomes:</p><formula xml:id="formula_18">cert ⊥ (q, d) = t | v( t) ∈ q v(d)</formula><p>for every d-complete valuation v which corresponds to the definition given by <ref type="bibr" target="#b19">(Jr. 1984)</ref>.</p><p>We have been able to justify the notion of certain answers with nulls for both the additive and the collapsing semantics of valuations, but neither is entirely satisfactory. On the one hand, collapsing valuations decreases the expressiveness of the relational data model based on bags. On the other hand, certain answers with nulls under additive valuations must be interpreted using the collapsing semantics, which is counterintuitive.</p><p>We will now propose a new semantics of incompleteness for relational databases that overcomes these shortcomings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Mixed Semantics</head><p>The main idea behind our proposed semantics is that applying a valuation to a table does not produce one table, as is the case with the collapsing and additive semantics, but rather a set of tables.</p><p>Definition 7. The mixed application of a valuation v to a kary table T is the set v(T ) consisting of all tables B of arity k such that, for every k-ary tuple t of constants and nulls:</p><formula xml:id="formula_19">max #(B, ū) | v(ū) = t ≤ #(B, t) ≤ ū : v(ū)= t #(B, ū)</formula><p>This extends to databases d as follows: v(d) is the set of all databases d 1 of the same schema as d such that R d1 belongs to v(R d ) for every table name R.</p><p>Finally, the mixed semantics of incompleteness under OWA and CWA are given as follows:</p><formula xml:id="formula_20">d CWA = {d 1 complete | d 1 ∈ v(d), v is a valuation} d OWA = {d 2 complete | d 2 ⊇ d 1 ∈ v(d), v is a valuation}</formula><p>As the name suggests, the mixed semantics combines the collapsing and the additive ones, by taking into account that incomplete facts unifying with already existing data may or may not represent new information.</p><p>Below we show that, when using the mixed semantics of valuations on both the source and target domain of queries, the valuation-preserving certain answers and the certain answers with nulls coincide.</p><p>Theorem 3. Let S and T be relational database domains under the mixed application of valuations. Then, for every query q from S to T and for every database d ∈ I S , either both cert V (q, d) and cert ⊥ (q, d) exist and coincide, or neither of them exists.</p><p>Note that when we consider the open world assumption, the collapsing and mixed semantics are equivalent. And for every valuation from V their K-semantics are also the same. However, as illustrated in Example 4, there exists a query such that valuation-preserving certain answers upon additive, collapsing and mixed semantics are different for closedworld semantics. Example 4. Let d be a relational database such that</p><formula xml:id="formula_21">R d = {|1, ⊥ 1 , ⊥ 2 | } ; S d = {|1, 1| } ;</formula><p>and consider the following relational algebra query q:</p><formula xml:id="formula_22">π ∅ (R -S) (S -R)</formula><p>It is easy to see that the certain answers of q are empty iff there exists a possible world c of d such that R c = S c . Since S d does not contain nulls, we focus on R.</p><p>Under the additive semantics of valuations, for every possible world c of d there are at least 3 tuples in R c . As there are always exactly 2 tuples in S c , we have that R c -S c cannot be empty. Thus, the valuation-preserving certain answer to q on d is non-empty.</p><p>Under the collapsing semantics of valuations, {|1, 1| } = v(R d ) for every valuation v because, even if v(⊥ 1 ) = 1 or v(⊥ 2 ) = 1, they collapse into a single occurrence of value 1. Hence, for every possible world c of d, we have that S c -R c cannot be empty, and therefore the valuation-preserving certain answer to q on d is non-empty.</p><p>Under the mixed semantics of valuations, we consider every possible multiplicity for each tuple, and {|1, 1| } ∈ v(R d ) when v(⊥ 1 ) = v(⊥ 2 ) = 1. Thus, the empty bag is a possible answer to q, and the valuation-preserving certain answer to q on d is empty.</p><p>In light of the above, we argue that the semantics of valuations one should use in the context of relational databases is the mixed semantics, because it behaves consistently independently of whether a (relational) database domain is the source or the target of queries. However, under mixed semantics, the valuation-preserving certain answers coincide with the certain answers with nulls, and these are still unsatisfactory as they cannot produce answers involving values that were not present in the original data, as Example 1 illustrates.</p><p>We would like to capture all the information-based certain answers, while keeping the valuation-preservation property of the certain answers with nulls. By Proposition 2, we know that with the relational database domain as target it is impossible to be valuation-preserving and more informative at the same time. Therefore, we must modify the target domain; this is what we do in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Certainty for Value-Inventing Queries</head><p>To handle queries whose answers may contain values not appearing in the original input, we extend relational databases with the notion of persistent nulls. Informally, these are information placeholders with the same semantics as marked nulls, but their incompleteness does not decrease in the presence of new knowledge: every interpretation of a persistent null is consistent with any additional knowledge.</p><p>Relational database domains with persistent nulls are simply relational database domains, where databases are populated by constants, nulls and persistent nulls. The latter values come from a countably infinite set PNull. We denote the elements of PNull using the symbol with subscripts. For a database d, we denote by PNull(d) the set of persistent nulls appearing in it.</p><p>A P-valuation is a partial function v from Null ∪ PNull to Const. We denote by v(d) the database obtained from d by replacing each element e of Null ∪ PNull with v(e), if this is defined. We introduce P-valuations only as a means to define the semantics of relational database domains with persistent nulls; such P-valuations, however, do not provide additional knowledge, as the incompleteness of persistent nulls cannot be reduced. Indeed, we consider again the monoid V of partial valuations introduced in Section 4, which is additional to relational database domains with persistent nulls.</p><p>In what follows, we will only use relational database domains with persistent nulls as target, and we focus on openworld semantics as before. For simplicity, we use the collapsing semantics of P-valuations, which is defined below and is equivalent to the mixed one.</p><p>Definition 8. The collapsing application of a P-valuation v to a k-ary table T is the k-ary table v(T ) such that, for every tuple t ∈ Const k we have:</p><formula xml:id="formula_23"># v(T ), t = max #(R, ū) | v(ū) = t</formula><p>The corresponding OWA semantics of incompleteness is defined as follows:</p><formula xml:id="formula_24">d OWA = {d complete | d ⊇ v(d), v is a P-valuation}</formula><p>With all of this in place, we can capture information-based certain answers while still preserving knowledge from partial valuations.</p><p>Below, we show that the valuation-preserving certain answers with persistent nulls are as informative as informationbased certain answers, and more informative than valuationpreserving certain answers without persistent nulls.</p><p>Proposition 5. Let R be a relational database domain, and let P be a relational database domain with persistent nulls, such that C R = C P . Let q be a query from R to R, and let q be a query identical to q, but from R to P. Then, for every d ∈ I R , all of the following hold: (a) cert (q, d) ≡ P cert V (q , d); (b) cert V (q, d) V P cert V (q , d). Since we are now able to capture information-based certain answers, the valuation-preserving certain answers will not be empty. As an application, we look at a class UCQ-F of value-inventing queries defined by unions of conjunctive queries with function application.</p><p>5.1 Query Answering for UCQ-F Let F be a set of functions where each function f of arity k is from Const k to Const. Definition 9. The language UCQ-F of union of conjunctive queries with function application is defined by the following grammar:</p><formula xml:id="formula_25">q := R | q × q | q q | π ᾱ(q) | σ αi=αj (q)</formula><p>| Apply ᾱ(f, q) with f ∈ F where α i and α j are attributes, and ᾱ is a tuple of attributes.</p><p>All of the operations above, except Apply, are defined in the standard way <ref type="bibr" target="#b11">(Console, Guagliardo, and Libkin 2019)</ref>. The semantics of q = Apply α1,...,α k (f, q), for every complete relational database d and for every tuple t of the same arity as q, is defined as follows:</p><formula xml:id="formula_26"># q (d), ( t, t) = # q(d), t if t = f t[α 1 ], . . . , t[α k ] 0 otherwise</formula><p>While the query language UCQ-F is conceptually quite simple, computing the valuation-preserving certain answers for UCQ-F queries is intractable even if F consists of just one unary function. Proposition 6. There is a unary function f such that computing the {ε}-preserving certain answer and the valuationpreserving certain answer to Boolean queries in UCQ-{f }, on relational databases with or without persistent nulls, is coNP-hard in data complexity.</p><p>For UCQ-F queries, the standard SQL evaluation is polynomial, so it cannot compute any knowledge-preserving notion of certain answers, which may result in counter-intuitive results on database with nulls. An approach to approximate certain answers when they are intractable is to build a query evaluation algorithm with correctness guarantees that runs in polynomial time. Definition 10. Let S and T be database domains, and Q be a query language. A query evaluation algorithm Eval : Q × I S → I T has A-preserving correctness guarantees for Q if, for every query q ∈ Q, all of the following hold:</p><p>(a) Eval(q, x) A T cert A (q, x) for every x ∈ I S , and (b) Eval(q, c) = q(c) for every c ∈ C S .</p><p>In other words, a query evaluation algorithm with correctness guarantees produces answers that are consistent (w.r.t. the A-preserving information ordering on the target domain) with the query answers on incomplete databases, and equal to them on complete databases.</p><p>In order to obtain a polynomial-time algorithm, we extend the idea of naive evaluation on relational database domains based on a free algebra of terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Relational Databases over Free Algebra</head><p>We consider a free algebra of terms T , where the basis of T is the set Const ∪ Null of constants and (marked) nulls, and the operations are functions from T × • • • × T to T . The set of such functions is denoted by Γ. Then, a relational database is over T if it is populated with elements of T .</p><p>Definition 11. An interpretation • I of Γ over Const associates each γ ∈ Γ of arity k with a function γ I : Const k → Const. The grounding of T under I is the function grd that maps each t ∈ T to an element of Const ∪ Null ∪ PNull as follows: </p><formula xml:id="formula_27">grd(t) =            t if t ∈ Const ∪ Null γ I (c 1 , . . . , c k ) if t = γ(</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>#(T, ū)</head><p>Finally, the grounding of a relational database d over T is the database grd(d) of the same schema such that, for every table name R, we have R grd(d) = grd(R d ).</p><p>A relational database domain D is over the free algebra T if every database in I D is over T and its grounding belongs to C D ; in addition, • D uses OWA with the collapsing semantics of valuations as defined below. Definition 12. For every valuation v : Null → Const and for every term t = γ(t 1 , . . . , t k ) ∈ T , we let v(t) denote the term γ v(t 1 ), . . . , v(t k ) .</p><p>The collapsing application of v to a k-ary table T over T is the k-ary table v(T ) such that, for every t ∈ T k , we have:</p><formula xml:id="formula_28"># v(T ), t = max #(R, ū) | v(ū) = t</formula><p>The corresponding OWA semantics of incompleteness is defined as follows:</p><formula xml:id="formula_29">d OWA = {d complete | d ⊇ v(d), v is a valuation}</formula><p>We will now use the relational database domain over T to define naive evaluation for value-inventing queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Approximation Algorithms for UCQ-F</head><p>For the rest of this section, we consider the free algebra of terms T defined as above, with a set Γ of operations whose interpretation I over Const is assumed to be computable in polynomial time. We take F = {γ I | γ ∈ Γ} as the set of functions for UCQ-F queries. Definition 13. The interpreted naive evaluation of a UCQ-F query q is the query q i-naive from incomplete relational databases to incomplete relational databases over T , where q i-naive is the standard naive evaluation for relational algebra (i.e., nulls are treated as new constants) and such that, for every relational database d and for every tuple t of appropriate arity, we have:</p><p>• for q = Apply α1,...,α k (γ I , q ); # q i-naive (d), ( t, t) is</p><formula xml:id="formula_30"># q i-naive (d), t if t = γ( t[α 1 ], . . . , t[α k ]) 0 otherwise • for q = σ αi=αj (q ); # q i-naive (d), t is #(q i-naive (d), t) if grd( t[α i ]) = grd( t[α j ]) 0 otherwise</formula><p>Informally, the interpreted naive evaluation behaves like the classical naive evaluation for relational algebra, except that it interprets the free algebra terms when checking for equality in selections. Proposition 7. For UCQ-F query q and for every relational database d, the interpreted naive evaluation of q can be computed in polynomial time in the size of d.</p><p>We have built a polynomial-time evaluation algorithm for UCQ-F queries on relational database domains over T . In addition, by means of grounding, we can provide an evaluation algorithm with correctness guarantees. Theorem 4. The grounding of the interpreted naive evaluation is a query evaluation algorithm with correctness guarantees for UCQ-F. Thus, for every query q ∈ UCQ-F and for every relational database d, we have:</p><p>(a) grd q i-naive (d) V P cert V (q, d); and (b) if d is complete, then grd q i-naive (d) = q(d).</p><p>We conclude this section with a fully worked-out example of how UCQ-F queries are evaluated and grounded. Example 5. Consider a database D with a relation R =  The naive evaluation of q = σ (A+B)=(C+D) q on D and its grounding are: q naive (D) A + B C + D +(1, ⊥ 1 ) +(1, ⊥ 1 ) grd q naive (D)</p><formula xml:id="formula_31">{(3, 0, 1, 2), (1, ⊥ 1 , 1, ⊥ 1 ), (2, ⊥ 2 , ⊥ 2 , 2)</formula><formula xml:id="formula_32">A + B C + D i i</formula><p>These return unsatisfactory answers, because they miss some complete tuples. Naive evaluation cannot capture the fact that +(0, 3) = +(1, 2) = 3, as it does not interpret the function. On the other hand, the interpreted naive evaluation and its grounding are: q i-naive (D) A + B C + D +(3, 0) +(1, 2) +(1, ⊥ 1 ) +(1, ⊥ 1 ) grd q i-naive (D)</p><formula xml:id="formula_33">A + B C + D 3 3 j j</formula><p>The interpreted naive evaluation is able to capture all complete tuples. It recognizes that constant terms such as +(3, 0) and +(1, 2) are equal. Moreover, for this query, the interpreted-naive evaluation captures more tuples than the certain answers with nulls, but strictly less tuples than the valuation-preserving certain answers on the relational database domain with persistent nulls: cert ⊥ (q, D) A + B C + D 3 3 cert V (q, D) A + B C + D 3 3</p><formula xml:id="formula_34">j j k k</formula><p>The valuation-preserving certain answer captures more tuples, because it is able to recognize that +(2, ⊥ 2 ) and +(⊥ 2 , 2) are equal for every valuation.</p><p>We have been able to build a polynomial query evaluation algorithm with correctness guarantee for the applied union of conjunctive query language UCQ-F. Moreover as illustrated in Example 5, there exist queries where the interpreted naive evaluation algorithm is a strict improvement from the certain answers with nulls: it returns more certain tuples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>A big obstacle in further developing areas where AI techniques, in particular logic-based ones, interact with data management is understanding notions of query answers over incomplete data. Indeed, applications such as OBDA, data integration, data exchange combine reasoning and query answering tasks, but in the end need to rely on database technology to produce answers. This technology is to be applied in settings where data is naturally incomplete, by the very means of its construction. This in turn severely limits the applicability of the techniques: one typically resorts to conjunctive queries, or their unions, or a handful of very closely related classes where we have an understanding of correctness of query answers and an arsenal of techniques for computing those answers.</p><p>However, if one looks at real life database queries (e.g., in standard benchmarks, as those produced by the TPC), there are very few queries from the classes for which we have query answering techniques in the presence of incomplete data. Real-life queries differ in the most basic semantics of the underlying data model, and in their features, as crucially they invent new values that form part of the output. For those, we lacked notions of correctness, or certainty, of query answering.</p><p>Our goal here was to remedy this situation by first providing a general framework explaining what correctness is, and second by showing how it can be applied in some cases that go well beyond queries that we had known how to handle. We have done so for the prevalent bag semantics, and for queries that can invent new values by means, for example, of arithmetic functions.</p><p>The most pressing next question to us is to extend these techniques to aggregate queries that can produce new values by applying arithmetic functions to entire columns in relations. These are extremely common in applications, as witnessed again by benchmark queries, and theoretical literature still offers no insight into the notions of correctness of query answering with aggregates over incomplete data. We expect techniques presented here to open up new ways of attacking this long standing open problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>over attributes A, B, C, D, and the following value inventing query q :π (A+B);(C+D) Apply (C,D) (+, Apply (A,B) (+, R))where +(c, c ) = c + c for every c, c ∈ Const. The naive evaluation of q on D gives the following answers:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>q i-naive (D) = q naive (D) = ⊥ 1 ) +(1, ⊥ 1 ) +(2, ⊥ 2 ) +(⊥ 2 , 2)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>t 1 , . . . , t k ) and c i = grd(t i ) ∈ Const for every i ∈ {1, . . . , k}</figDesc><table><row><cell>grd(t)</cell><cell>otherwise</cell></row><row><cell cols="2">This naturally extends tables and relational databases over</cell></row><row><cell cols="2">T . The grounding of a table T is the table grd(T ) with per-</cell></row><row><cell cols="2">sistent nulls such that, for every tuple t of the same arity as</cell></row><row><cell>T , we have:</cell><cell></cell></row><row><cell># grd(T ), t =</cell><cell></cell></row></table><note><p>ū : grd(ū)=t</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The term "database objects" here refers to generic structures, such as relational or graph databases, that store data. Some of these objects are assumed to provide complete information, while others do not.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements Work partially supported by <rs type="funder">EPSRC</rs> grants <rs type="grantNumber">M025268</rs> and <rs type="grantNumber">N023056</rs>, <rs type="funder">EPSRC Centre</rs> <rs type="programName">for Doctoral Training in Data Science</rs>, a grant from the <rs type="funder">Foundation Sciences Mathématiques de Paris</rs> under the <rs type="programName">FSMP Chairs program</rs>, and the <rs type="funder">Royal Society</rs> through a <rs type="grantName">Wolfson Research Merit Award</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_rppCx5u">
					<idno type="grant-number">M025268</idno>
				</org>
				<org type="funding" xml:id="_dp29UzK">
					<idno type="grant-number">N023056</idno>
				</org>
				<org type="funding" xml:id="_kyEt7KZ">
					<orgName type="program" subtype="full">for Doctoral Training in Data Science</orgName>
				</org>
				<org type="funding" xml:id="_3Rs4XBt">
					<orgName type="program" subtype="full">FSMP Chairs program</orgName>
				</org>
				<org type="funding" xml:id="_bjmZcbk">
					<orgName type="grant-name">Wolfson Research Merit Award</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Representing and querying XML with incomplete information</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Segoufin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="208" to="254" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Explainable certain answers</title>
		<author>
			<persName><forename type="first">G</forename><surname>Amendola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<ptr target="ijcai.org" />
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1683" to="1690" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Murlak</surname></persName>
		</author>
		<title level="m">Foundations of Data Exchange</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Database Repairing and Consistent Query Answering</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Bertossi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Data Management</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Ontology-mediated query answering with data-tractable description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reasoning Web</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015. 9203</date>
			<biblScope unit="page" from="218" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Using powerdomains to generalize relational databases</title>
		<author>
			<persName><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ohori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="23" to="55" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Query rewriting and answering under constraints in data integration systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="16" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Morgan</forename><surname>Kaufmann</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Extending the database relational model to capture more meaning</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="397" to="434" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Coping with incomplete data: Recent advances</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Toussaint</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="33" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On querying incomplete information in databases under bag semantics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<ptr target="ijcai.org" />
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="993" to="999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fragments of bag relational algebra: Expressiveness and certain answers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the logic of SQL nulls</title>
		<author>
			<persName><forename type="first">E</forename><surname>Franconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tessaris</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">AMW</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">866</biblScope>
			<biblScope unit="page" from="114" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Problem of Incomplete Information in Relational Databases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">554</biblScope>
			<date type="published" when="1991">1991</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Null values in a relational data base</title>
		<author>
			<persName><forename type="first">J</forename><surname>Grant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="156" to="157" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Making SQL queries correct on incomplete databases: A feasibility study</title>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="211" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Foundations of information integration under bag semantics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hernich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Incomplete information in relational databases</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On semantic issues connected with incomplete information databases</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="262" to="296" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On relational algebra with marked nulls</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Jr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="201" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The combined approach to ontologybased data access</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI, 2656-2661. IJCAI/AAAI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Data integration: A theoretical perspective</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PODS</title>
		<imprint>
			<biblScope unit="page" from="233" to="246" />
			<date type="published" when="2002">2002</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A semantics-based approach to design of query languages for partial information</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantics in Databases</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">1358</biblScope>
			<biblScope unit="page" from="170" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Incomplete information and certain answers in general data models</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Certain answers as objects and knowledge</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">232</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Sql&apos;s three-valued logic and certain answers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Linking data to ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Data Semantics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="133" to="173" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Situation-theoretic aspects of databases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Rounds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Situation Theory and Applications</title>
		<title level="s">TPC Benchmark™ H Standard Specification</title>
		<imprint>
			<publisher>Transaction Processing Performance Council</publisher>
			<date type="published" when="1991">1991. 2014</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="229" to="256" />
		</imprint>
	</monogr>
	<note>CSLI Lecture Notes. Revision 2.17.1</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Logical approaches to incomplete information: A survey</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Der Meyden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logics for Databases and Information Systems</title>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="307" to="356" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
