<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Researcher&apos;s Digest of GQL</title>
				<funder ref="#_6N8qWNs #_4QmtyXJ #_hqYNqFP">
					<orgName type="full">German Research Foundation (DFG)</orgName>
				</funder>
				<funder ref="#_6HFRUjs #_MeqQUuC #_shdVgRC">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_6nmZqzr">
					<orgName type="full">Leverhulme Trust</orgName>
				</funder>
				<funder ref="#_ThU25xe">
					<orgName type="full">NCN</orgName>
				</funder>
				<funder ref="#_MXQEhmN">
					<orgName type="full">unknown</orgName>
				</funder>
				<funder ref="#_wvk5j2H">
					<orgName type="full">EPSRC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Amélie</forename><surname>Gheerbrant</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Liat</forename><surname>Peterfreund</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Alexandra</forename><surname>Rogova</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Amélie</forename><surname>Francis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Gheerbrant</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Leonid</forename><surname>Guagliardo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Victor</forename><surname>Libkin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wim</forename><surname>Marsault</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Filip</forename><surname>Martens</surname></persName>
						</author>
						<author>
							<persName><surname>Murlak</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratoire d&apos;Informatique Gaspard Monge</orgName>
								<orgName type="institution" key="instit1">Université Gustave Eiffel</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">IRIF</orgName>
								<orgName type="institution" key="instit1">Université Paris Cité</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="laboratory">RelationalAI</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
								<address>
									<country>UK, France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">PSL University</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="laboratory">Laboratoire d&apos;Informatique Gaspard Monge</orgName>
								<orgName type="institution" key="instit1">Université Gustave Eiffel</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">Universität Bayreuth</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution">University of Warsaw</orgName>
								<address>
									<country key="PL">Poland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="laboratory">Laboratoire d&apos;Informatique Gaspard Monge</orgName>
								<orgName type="institution" key="instit1">Université Gustave Eiffel</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff9">
								<orgName type="laboratory">IRIF</orgName>
								<orgName type="institution" key="instit1">Université Paris Cité</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Data Intelligence Institute of Paris</orgName>
								<orgName type="institution" key="instit2">Inria Domagoj Vrgoč University of Zagreb</orgName>
								<orgName type="institution" key="instit3">Coratia</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff11">
								<orgName type="institution">Pontificia Universidad Católica de Chile</orgName>
								<address>
									<settlement>Santiago</settlement>
									<country key="CL">Chile</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff12">
								<orgName type="department" key="dep1">Leibniz International Proceedings</orgName>
								<orgName type="department" key="dep2">Informatics Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
								<orgName type="department" key="dep3">Dagstuhl Publishing</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Researcher&apos;s Digest of GQL</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1A8EB439CDBB616085979CC978EA0600</idno>
					<idno type="DOI">10.4230/LIPIcs.ICDT.2023.1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>2012 ACM Subject Classification Theory of computation → Database theory; Theory of computation → Database Information systems → Structured Query Language Keywords and phrases GQL</term>
					<term>Property Graph</term>
					<term>Query Language</term>
					<term>Graph Database</term>
					<term>Pattern matching</term>
					<term>Multi-Graph Digital Object Identifier 10.4230/LIPIcs.ICDT.2023.1 Category Invited Talk</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>GQL (Graph Query Language) is being developed as a new ISO standard for graph query languages to play the same role for graph databases as SQL plays for relational. In parallel, an extension of SQL for querying property graphs, SQL/PGQ, is added to the SQL standard; it shares the graph pattern matching functionality with GQL. Both standards (not yet published) are hard-to-understand specifications of hundreds of pages. The goal of this paper is to present a digest of the language that is easy for the research community to understand, and thus to initiate research on these future standards for querying graphs. The paper concentrates on pattern matching features shared by GQL and SQL/PGQ, as well as querying facilities of GQL.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Graph databases have grown steadily in popularity this century. They handle data as it is viewed conceptually, making them easily applicable in many tasks where traditional relational databases are not easy or natural to use. While many early applications cited social networks and the Semantic Web as the key motivation (since in both cases data is naturally viewed as a graph), industry scale applications are much more diverse and include fraud detection, network management, medical data management, knowledge management, and even investigative journalism. There are several dozen graph database products on the market, including the current leader Neo4j, as well as both established and upcoming companies offering graph products (e.g., Oracle, Amazon, IBM, SAP, Redis, DataStax, TigerGraph, Memgraph, etc.). Graph databases' widespread use happened without them having their lingua franca, which is the role that SQL is playing for relational databases. The landscape of graph languages -at least at first sight -is very varied. Neo4j has its own language called Cypher <ref type="bibr" target="#b18">[18]</ref>, which is also implemented in other products, including SAP HANA and Amazon Neptune. Oracle introduced its language PGQL <ref type="bibr" target="#b34">[34]</ref>; TigerGraph has GSQL <ref type="bibr" target="#b13">[13]</ref>, and several products use the non-declarative graph traversal language Gremlin <ref type="bibr" target="#b33">[33]</ref>. However, upon a closer examination, one discovers that declarative languages are more like different dialects of the same language rather than different languages altogether. This led to a proposal to define a new unifying standard for a Graph Query Language (GQL) <ref type="bibr" target="#b36">[36]</ref>. The proposal was given a go-ahead in 2019, and since then was taken up by the same committee that produces and maintains the SQL Standard. It is known as ISO/IEC JTC1 SC32 WG3 within the International Organization for Standardization, or ISO.</p><p>In fact, this committee develops two projects in parallel: SQL/PGQ, a new Part 16 of the SQL Standard, that defines querying graphs specified as views over a relational schema; it is expected to be published roughly at the time of the EDBT/ICDT 2023 conference. GQL, a standalone language for querying property graphs, that is expected to be published in late 2023 or early 2024.</p><p>The language of the Standard, even when published (behind paywall) is hardly of the kind that the research community is accustomed to. It consists of a grammar for the constructs, supplemented with syntax and semantic rules, the latter written in natural language describing an algorithm for computing the result of a particular operation (essentially a mix of prose and pseudocode). Such descriptions are long, far from formal definitions suitable for initiating research in the area, and often prone to misinterpretation. To researchers, such a text is therefore much like a 500+ page legal document, instead of a workable definition that helps them understand the essence of the language.</p><p>This motivates the goal of the present paper: to distill, in a form accessible to the database research community, the principal elements of the forthcoming GQL Standard, and provide their formal semantics.</p><p>The idea of finding calculi underlying programming languages and providing their formal semantics is mainstream in the programming languages field. Recently we saw it extended to database query languages, specifically to core fragments of SQL <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b6">7]</ref> and Cypher <ref type="bibr" target="#b18">[18]</ref>. The present paper follows this trend. It provides a significant simplification of the GQL Standard, which at the same time covers its key features, and yet is sufficiently simple to provide its formal semantics, thereby enabling its further study and opening up new avenues of research on graph query languages. We do not follow GQL letter to letter, for two reasons. Firstly, the Standard itself is not yet finalized, and what is written today may still change before it is published. Second, we choose to simplify some of the idiosyncrasies of a real-life language to better highlight its essential features. Queries presented here are close to the eventual features of the languageeven if they change somewhat in the meantime. They come with a formal grammar that is a fragment of GQL's grammar, and a formal semantics, that is suitable as a starting point of new research in graph query languages. The paper focuses on read-only GQL queries, to which we will simply refer as GQL queries. That is, we do not yet consider data updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Previous Academic Work on GQL</head><p>The two graph languages currently standardized -GQL and SQL/PGQ -share their pattern matching facilities, which constitute the key part of any graph language. These were described in <ref type="bibr" target="#b12">[12]</ref>, by a group that included members of ISO's Standard group, as well as members of LDBC's Formal Semantics Working Group (FSWG), whose goal was to analyze and formalize the design of the language. FSWG then produced a theoretical reconstruction of the GQL and PGQ pattern language <ref type="bibr" target="#b16">[16]</ref>. This paper is the next installment in the effort to distill PGQ and GQL standards for the research community.</p><p>Apart from this recent work on GQL, we note that academic foundations already influenced its design process. As seen in GQL's influence graph <ref type="bibr" target="#b19">[19]</ref>, the language draws inspiration from regular path queries <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b30">30]</ref>, STRUQL <ref type="bibr" target="#b14">[14]</ref>, GXPath <ref type="bibr" target="#b27">[27]</ref>, and regular queries <ref type="bibr" target="#b32">[32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">GQL by Example</head><p>In this section we give a high-level description of GQL queries and their evaluation. The graph database model used by GQL is simply a collection of one or more property graphs. As an illustration, Figure <ref type="figure" target="#fig_0">1</ref> is a graph database consisting of two property graphs: the Fraud graph has information about bank transactions that are to be investigated for fraud, and the Social graph has information about people's social activities such as membership in a yacht club. Notice that these two graphs have a non-empty intersection: the nodes for Jay and Mike belong to both graphs, but they are seen in a different way and therefore have different We start with a simple query that looks for large (over $1M) transfers into a blocked account, and reports owners of accounts involved in such transfers: The reader familiar with Cypher will parse this query easily; it roughly follows Cypher's ascii-art syntax for expressing patterns, and also permits checking conditions on properties inside patterns. Basically, the pattern in line 2, namely:</p><formula xml:id="formula_0">I C D T 2 0 2 3</formula><formula xml:id="formula_1">(x) -[z:Transfer WHERE z.amount&gt;1000000]-&gt; (y WHERE y.isBlocked=true)</formula><p>asks for nodes x and y that are connected with an edge z that is labeled with Transfer. Furthermore, the amount property of z should exceed one million and the isBlocked property of y should be true. Such patterns, called path patterns in GQL, are the main building block of GQL queries, and they roughly correspond to regular path queries (RPQs), which have been well studied in the research literature <ref type="bibr" target="#b30">[30]</ref>.</p><p>Note also that the query is preceded by a USE clause stating explicitly in which graph matches are sought. When evaluating a query, GQL keeps track of the working graph, which is the current graph in the database on which we do pattern matching and the working table, which contains intermediate results of the query, up to the current evaluation point.</p><p>Intuitively, the working table is a collection of records that gets passed from one part of the query to another in order to compute the final result. Thus, while GQL is a graph query language, it uses tables to represent intermediate and end-results of queries. In Section 4, we also discuss a third ingredient that GQL keeps track of, namely the working record.</p><p>Coming back to our sample query, in the first line we write USE Fraud, which turns the Fraud graph into our working graph. In line 2, we have our path pattern, preceded by the keyword MATCH. This clause is the main workhorse of GQL, and it tells us to do the matching of the pattern onto the working graph. When evaluating our query over the database from Figure <ref type="figure" target="#fig_0">1</ref>, after executing line 2 of the query, we will be left with the following working table:</p><formula xml:id="formula_2">x y z p1 p2 t1</formula><p>Continuing in line 3, the working table is modified by keeping only the owner attribute of the nodes x and y, while renaming them, and the following is returned to the user:</p><formula xml:id="formula_3">sender recipient Jay Mike<label>(1)</label></formula><p>We next extend this query by checking for such transfers where both account owners are members of the same yacht club, reporting this time the address for the yacht club to send investigators to.  Here lines 1-3 repeat the previous query. The keyword THEN is used to pipe the result of this query to the following subquery. While the curly braces extend the scope of USE Fraud beyond THEN, in line 5 we switch the working graph to Social in order to match the pattern: This pattern consists of two path patterns, separated by a comma. In GQL, the comma performs a join on the results of the two path patterns. From a theoretical point of view, it brings us in the realm of conjunctive (two-way) regular path queries. In GQL, such patterns are called graph patterns. When this pattern is evaluated over the Social graph, we obtain the following (fresh) working table:</p><formula xml:id="formula_4">x1 y1 z1 p1 p2 c1 p1 p1 c1 p2 p2 c1<label>(2)</label></formula><p>this time with variables x1, y1, and z1. After evaluating the pattern, the MATCH statement makes the natural join of table <ref type="bibr" target="#b1">(2)</ref>  The output is similar to the output of the previous example, but this time we have the entire path instead of the list of nodes in each answer. We note that property graphs can have multiple edges with the same end-nodes, so the list of nodes in a path is not sufficient to determine the path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Syntax of GQL</head><p>The full syntax of GQL queries is given in Figure <ref type="figure" target="#fig_3">2</ref> with G a set of property graphs, and the following pairwise disjoint countable sets: L of labels, K of keys, Const of value constants with a designated value null, and Vars of variables.</p><p>While somewhat intimidating at a first glance, the grammar can be roughly divided into four parts:</p><p>path patterns, which mimic regular path queries <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b30">30]</ref>, but have additional features such as two-way navigation and conditioning; graph patterns, which generalize conjunctive two-way regular path queries <ref type="bibr" target="#b7">[8]</ref> with the ability to return different types of paths; queries, which allow us to manipulate the results of graph patterns and combine their evaluation over different graphs in the database; and expressions and conditions, which allow filtering results obtained in previous three parts of GQL.</p><p>Of course, each of these parts has many specific features. For instance, path patterns allow using descriptors, which bind a node/edge to a variable, test its label or more complex conditions (e.g. amount is greater than 1000000). Simple node/edge patterns can be combined into regular expressions, by using concatenation, union or repetitions. Graph patterns, on the other hand, allow specifying the subset of matched paths that is to be returned, or joining path patterns into more complex queries. Finally, clauses/queries themselves allow us to manipulate results obtained from graph patterns, much like what is possible in the relational. Complex features such as iteration over the returned elements, passing the results to another subquery, and changing the evaluation graph, are also supported.</p><formula xml:id="formula_5">PATH PATTERN For x ∈ Vars, ℓ ∈ L, 0 ≤ n ≤ m ∈ N:</formula><p>(descriptor) δ := x :ℓ WHERE θ x, :ℓ, and WHERE θ are optional</p><formula xml:id="formula_6">(path pattern) π := ( δ ) (node pattern) | -[ δ ]-&gt; | &lt;-[ δ ]-| ~[ δ ]~(edge pattern) | π π (concatenation) | π|π (union) | π WHERE θ (conditioning) | π{n,m} (bounded repetition) | π{n,} (unbounded repetition) EXPRESSION and CONDITION For x ∈ Vars, ℓ ∈ L, a ∈ K, c ∈ Const: (expression) χ := x | x.a | c (condition) θ := χ = χ | χ &lt; χ | χ IS NULL | x : ℓ | EXISTS { Q } | θ OR θ | θ AND θ | NOT θ GRAPH PATTERN For x ∈ Vars: (path mode) µ := (ALL | ANY) [SHORTEST] [TRAIL | ACYCLIC] (graph pattern) Π := µ [x =] π | Π, Π</formula><p>CLAUSE and QUERY For k ≥ 0, ℓ ≥ 1, and x, y, x 1 , . . . , x k ∈ Vars, and G ∈ G: </p><formula xml:id="formula_7">(clause) C := MATCH Π | LET x = χ | FOR x IN y | FILTER θ (linear query) L := USE G L | C L | RETURN χ 1 AS x 1 , . . . , χ k AS x k (query) Q := L | USE G {Q 1 THEN Q 2 • • • THEN Q ℓ } | Q INTERSECT Q | Q UNION Q | Q EXCEPT Q</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Well-Formed Queries</head><p>The syntax of path patterns defined in Figure <ref type="figure" target="#fig_3">2</ref> is permissive as it allows expressions that do not type-check. For example, (x)-[x]-&gt;() is syntactically permitted even though it equates a node variable with an edge variable. Other patterns would provide great expressive power, such as the graph pattern ()-[y]-&gt;{0,}(), ()-[y]-&gt;{0,}*(), which implicitly joins on lists. We introduced in [16] a type system operating on a subset of the patterns described in Figure <ref type="figure" target="#fig_3">2</ref>. Its goal is to ensure that GQL path patterns and graph patterns do not exhibit the pathological behavior illustrated above. Here, we will only describe the resulting syntactic restrictions informally.</p><p>Each variable is given a type τ from the set T defined by the following grammar.</p><formula xml:id="formula_8">τ ::= Node | Edge | Path | Maybe(τ ) | Group(τ )</formula><p>The three atomic types are used for variables returning nodes, edges, and paths, respectively. The type constructor Maybe is used for variables occurring on one side of a disjunction only, while Group is used for variables occurring under repetition, whose bindings are grouped together. As variables in pattern matching are never bound to data values, we do not need the usual types like integers or strings here. Types are computed in a bottom-up fashion as follows. Variables appearing in node patterns (resp. in edge patterns, resp. as names of path patterns) are of type Node (resp. Edge, resp. Path). Variables appearing on one side of a disjunction with type τ but not the other are of type Maybe(τ ). Variables appearing under a repetition with type τ are of type Group(τ ) higher-up in the syntax tree of the expression. Consider the pattern</p><formula xml:id="formula_9">(-[x]-&gt; | -[y]-&gt;){0,}. The type of x is Edge in -[x]-&gt;, while it is Maybe(Edge) in -[x]-&gt; | -[y]-&gt;, and Group(Maybe(Edge)) in (-[x]-&gt; | -[y]-&gt;){0,} .</formula><p>A variable x appearing in a path/graph pattern ξ is called: a singleton variable if its type is Node or Edge with respect to ξ a conditional variable if its type is Maybe(τ ) for some type τ ; a group variable if its type is Group(τ ) for some type τ ; a path variable if its type is Path. Here is a non-exhaustive list of the syntactic conditions a pattern must meet in order for its semantics to be defined. A pattern ξ is well-formed if 1. Every variable appearing in a pattern ξ has one and only one type w.r.t. ξ. 2. In concatenation and join, variables appearing in both operands are singleton variables with respect to each operand. 3. In a conditioned path pattern π WHERE θ, every variable appearing in θ must have a type w.r.t. π. 4. In a graph pattern of the form µ π or µ x = π such that µ is ALL (which is possible since all of SHORTEST, TRAIL, and ACYCLIC are optional), π must contain no unbounded repetition, to avoid potentially infinite outputs. 5. For every repeated pattern π{n,m} or π{n,}, the minimum path length ∥π∥ min of π, defined below, is positive. This avoids applying repetitions to paths that do not match an edge.</p><formula xml:id="formula_10">∥ν∥ min = 0 ∥π WHERE θ∥ min = ∥π∥ min ∥η∥ min = 1 ∥π 1 | π 2 ∥ min = min(∥π 1 ∥ min , ∥π 2 ∥ min ) ∥π{n, }∥ min = ∥π{n, m}∥ min = n • ∥π∥ min ∥π 1 π 2 ∥ min = ∥π 1 ∥ min + ∥π 2 ∥ min</formula><p>Note that the local nature of types is important in item 2: implicit joins are allowed under repetitions, as in</p><formula xml:id="formula_11">( (a)-[]-&gt;(b)-[]-&gt;(a)-[]-&gt; ){1,}.</formula><p>Moreover, item 1 implies the existence of a schema, which is defined as follows:</p><p>▶ Definition 1 (Schema). A schema of a well-formed pattern ξ is a function sch(ξ) : var(ξ) → T, where var(ξ) is the set of variables appearing in ξ.</p><p>We will assume these syntactic restrictions to be in place when defining the semantics of GQL queries in Section 4. Moreover, we define the semantics only when the computation goes as expected, that is, when it satisfies preconditions we state explicitly. For instance, we will assume that a variable is bound before being used, that we never run into clashes in variable names, and that if a specific type is expected for an operation, then the value will have that type at runtime. Some of the preconditions could be checked syntactically, at the cost of a tedious type system. Some of the preconditions cannot be checked before run-time because they depend on the data stored in the database. Deciding how to treat those cases (static analysis, runtime exceptions, implicit casts) is outside the scope of this paper. In some cases, the GQL standard describes how they should be treated, in others, they are implementation-dependent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Semantics</head><p>In this section we present the formal semantics of GQL. At a high level, when evaluating a query, GQL keeps track of three things: (i) the working graph, which is the property graph we are using to match our patterns currently; (ii) the working table, that stores the information computed thus far; and (iii) the working record, which contains the tuple of the result we are currently using. In this section we provide mathematical abstractions for each of these concepts in order to define the semantics of GQL. We start by setting the preliminary definitions, and then move to defining the semantics for each portion of the language, as specified in Figure <ref type="figure" target="#fig_3">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Preliminaries</head><p>Data model. We follow the formal definition adapted by the GQL Standard <ref type="bibr" target="#b20">[20]</ref> to handle databases that contain multiple graphs. To define property graphs we need, in addition to the pairwise disjoint countable sets (L of labels, K of keys, and Const of constants) mentioned in Section 3, the following fresh pairwise disjoint countable sets: N of node ids, E d of directed edge ids, and E u of undirected edge ids.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>▶ Definition 2 (Property Graph). A property graph is a tuple</head><formula xml:id="formula_12">G = ⟨N G , E G d , E G u , lab G , endpoints G , src G , tgt G , prop G ⟩</formula><p>where </p><formula xml:id="formula_13">N G ⊂ N is a finite set of node ids used in G; E G d ⊂ E d is a finite set of directed edge ids used in G; E G u ⊂ E u is a finite set of undirected edge ids used in G; lab G : N G ∪ E G d ∪ E G u → 2 L is</formula><formula xml:id="formula_14">G : E G u → 2 N so that |endpoints G (e)| is 1 or 2 define endpoints of an undirected edge; prop G : (N G ∪ E G d ∪ E G u ) × K →</formula><p>Const is a partial function that associates a constant with an id and a key from K. If G is clear from the context, it will be omitted in the superscript. Recall that G denotes the set of all property graphs.</p><p>We use node and edge to refer to node ids and edge ids, respectively, and call a node u an ℓ-node iff ℓ ∈ lab(u); similarly for edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>▶ Definition 3 (Graph Database). A (property) graph database is a tuple</head><formula xml:id="formula_15">D = ⟨G 1 , . . . , G k ⟩</formula><p>where each G i is a property graph. We call the graph G 1 the default graph. <ref type="foot" target="#foot_0">2</ref>This is the most general definition of a database containing multiple graphs and it imposes no restrictions whatsoever on how labeling, properties, and topology agree across different graphs that share some node and edge ids. For example we may have the same id 1 for a person who has label employee and properties salary, department in a company graph and label student and properties year, major in a university graph. In fact it is even possible that the same edge id has different source and target in different graphs. We allow this complete flexibility because it is orthogonal to the choice of operations in the language, and thus we shall not impose restrictions that are not necessary for our purposes.</p><p>Paths and lists. GQL allows returning paths and lists as query answers. Here we define them formally. We start with paths.</p><p>▶ Definition 4 (Path). A path is an alternating sequence of nodes and edges that starts and ends with a node. We write paths as p = path(u 0 , e 1 , u 1 , e 2 , • • • e n , u n ), where u 0 , . . . , u n are nodes, e 1 , . . . , e n are (directed or undirected) edges, and n ≥ 0. We write src(p) for u 0 and tgt(p) for u n , and len(p) for its length n. We denote the set of all paths by Paths.</p><p>For a property graph G, we say that p ∈ Paths is a path in G if each edge in p connects the nodes before and after it in the sequence, that is, for each i ∈ {1, . . . , n}, at least one of the following is true: (a) src(e i ) = u i-1 and tgt(e i ) = u i in which case we speak of e i as a forward edge in the path; (b) src(e i ) = u i and tgt(e i ) = u i-1 in which case we speak of e i as a backward edge in the path; (c) endpoints(e i ) = {u i-1 , u i } in which case we speak of e i as an undirected edge in the path. We denote the set of paths in G by Paths(G).</p><p>Note that we allow n = 0, in which case the path consists of a single vertex and no edges. Note also that in the case of a directed self-loop, both (a) and (b) in the definition above are true, hence the cases are not mutually exclusive. ▶ Definition 5 (Concatenation of Paths). Two paths p = path(u 0 , e 0 , . . . , u k ) and p ′ = path(u ′ 0 , e ′ 0 , . . . , u ′ j ) concatenate if u k = u ′ 0 , in which case their concatenation p • p ′ is defined as path(u 0 , e 0 , . . . , u k , e ′ 0 , . . . , u ′ j ).</p><p>Note that a path of length 0 is a neutral element of concatenation; that is, p • path(u) is defined iff u = tgt(p), in which case p = p • path(u); likewise for path(u) • p and u = src(p).</p><p>▶ Definition 6 (List). We use the notation list(v 1 , . . . , v n ) to denote the list containing the objects v 1 , . . . , v n in this order. Lists can be empty, in which case we write list(). We use Lists to denote the set of all lists with elements in N ∪ E d ∪ E u . Bindings. To define the formal semantics we use bindings which specify how variables are matched to values V of the input graph database. Intuitively, a binding is a mathematical formalization of the concept of a working record in GQL. Formally, we set V as the union</p><formula xml:id="formula_16">Const ∪ N ∪ E d ∪ E u ∪ Paths ∪ Lists.</formula><p>▶ Definition 7 (Binding). A binding µ is a partial function µ : Vars → V whose domain Dom(µ) is finite. We denote bindings µ explicitly by (x 1 → v 1 , . . . , x n → v n ) where x 1 , . . . , x n are variables in Dom(µ), v 1 , . . . , v n are values in V, and for every i it holds that µ(x i ) = v i .</p><p>Note that the domains of bindings are not ordered, hence for instance (a</p><formula xml:id="formula_17">1 → v 1 , a 2 → v 2 ) = (a 2 → v 2 , a 1 → v 1 )</formula><p>. The empty binding, that is, the binding with an empty domain, is denoted by ().</p><p>▶ Definition 8 (Compatibility of Bindings). Two bindings µ 1 , µ 2 are said to be compatible, denoted by µ 1 ∼ µ 2 , if they agree on their shared variables, that is, for every</p><formula xml:id="formula_18">x ∈ Dom(µ 1 ) ∩ Dom(µ 2 ) it holds that µ 1 (x) = µ 2 (x). If µ 1 ∼ µ 2 , we define their join µ 1 ⋊ ⋉ µ 2 as expected, that is Dom(µ 1 ⋊ ⋉ µ 2 ) = Dom(µ 1 ) ∪ Dom(µ 2 ) and (µ 1 ⋊ ⋉ µ 2 ) (x) = µ 1 (x) whenever x ∈ Dom(µ 1 ) \ Dom(µ 2 ), and (µ 1 ⋊ ⋉ µ 2 ) (x) = µ 2 (x) whenever x ∈ Dom (µ 2 ).</formula><p>We remark here that our definition allows joins on variables that are bound to paths or lists. However, as we will see, the syntactic restrictions on queries limit this feature significantly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Semantics of Path Patterns</head><p>We start by defining the semantics of path patterns. For the remainder of this subsection, we consider a fixed property graph</p><formula xml:id="formula_19">G = ⟨N G , E G d , E G u , lab G , endpoints G , src G , tgt G , prop G ⟩.</formula><p>Moreover, we assume that all queries are well-formed and all patterns considered are restricted syntactically as described in Section 3. The semantics π G of a pattern π is a set of pairs (p, µ) where µ a binding, and p is a path in G. In π G , G denotes the working graph in GQL parlance (specified by the keyword USE), and the pairs (p, µ) model what is computed over this working graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics of Node and Edge Patterns</head><formula xml:id="formula_20">() G = (n, ()) n ∈ N G (x) G = (n, (x → n)) n ∈ N G (:ℓ) G = (n, ()) n ∈ N G , ℓ ∈ lab G (n)</formula><p>Other cases are treated by moving the label and conditions outside of the node pattern. For instance, (x:ℓ WHERE θ) is rewritten as </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics of Concatenation, Union, and Conditioning</head><formula xml:id="formula_21">π 1 π 2 G    (p 1 • p 2 , µ 1 ⋊ ⋉ µ 2 ) (p i , µ i ) ∈ π i G for i = 1, 2 p 1 and p 2 concatenate µ 1 ∼ µ 2   </formula><p>Note that since π 1 π 2 is assumed to be well-formed, all variables shared by π 1 and π 2 are singleton variables (Condition 2 in Section 3). In other words, implicit joins over group and optional variables are disallowed; the same remark will also apply for the semantics of joins.</p><p>▶ Remark 9. Consider the pattern</p><formula xml:id="formula_22">(x) (-[:Transfer]-&gt;()-[:Transfer]-&gt;(x)]){1,}</formula><p>This pattern is disallowed in GQL because the leftmost x is a singleton variable, whereas the rightmost x is a group variable. In GQL philosophy, the leftmost x will be bound to a node and the rightmost x will be bound to a list of nodes, which is a type mismatch.</p><formula xml:id="formula_23">π 1 | π 2 G = { (p, µ ∪ µ ′ ) | (p, µ) ∈ π 1 G ∪ π 2 G }</formula><p>where µ ′ maps every variable in var(π 1 | π 2 ) \ Dom(µ) to null. (Recall that var maps a pattern to the set of variables appearing in it.)</p><formula xml:id="formula_24">π WHERE θ G = { (p, µ) ∈ π G | θ µ G = true }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics of Repetition</head><formula xml:id="formula_25">π{n, m} G = m i=n π i G π{n, } G = ∞ i=n π i G</formula><p>Above, for a pattern π and a natural number i ≥ 0, we use π i G to denote the i-th power of π G , which we define as</p><formula xml:id="formula_26">π 0 G = { (path(u), µ) | u is a node in G }</formula><p>where µ binds each variable in Dom(sch(π)) to list(), that is, the empty-list value; and</p><formula xml:id="formula_27">∀i &gt; 0 π i G = (p 1 • . . . • p i , µ ′ ) (p 1 , µ 1 ), . . . , (p n , µ i ) ∈ π G p 1 , . . . , p i concatenate</formula><p>where µ ′ binds each variable in Dom(sch(π)) to list µ 1 (x), . . . , µ i (x) . Recall that sch is defined in Section 3.</p><p>▶ Remark 10. Since π{n, } is assumed to be well-formed, it holds ∥π∥ min ≥ 1. A simple induction then yields that each p i in the definition above has positive length. A second induction then yields that, given a path p, there are finitely many assignments µ such that (p, µ) ∈ π{n, m} G . This fact is crucial to have a finite output in the end.</p><p>For instance, consider a graph with a single node u and no edges, and the pattern (a){0,} which is not well-formed (the minimal path length of () is 0). For every i, the set (a) i G contains (path(u), µ i ) where µ i = (a → list(u, . . . , u i times</p><p>)); hence the union in the definition of π{n, } G above would not only yield an infinite number of elements, but all of them would be associated to the same path. As a result a graph pattern such as ALL SHORTEST (a){0,} would have infinitely many results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Semantics of Graph Patterns</head><p>We now define the semantics of graph patterns. We first fully define atomic graph patterns and then define their joins.</p><formula xml:id="formula_28">x = π G = (p, µ ∪ {x → p}) | (p, µ) ∈ π G</formula><p>In the following we denote by π a graph pattern that never uses the "," operator, hence it is of the form µ x= π, where µ is a path mode, x is a variable, π is a path pattern, and "x=" is optional.</p><formula xml:id="formula_29">TRAIL π G = { (p, µ) ∈ π G | no edge occurs more than once in p } ACYCLIC π G = { (p, µ) ∈ π G | no node occurs more than once in p } SHORTEST π G =    (p, µ) ∈ π G len(p) = min    len(p ′ ) (p ′ , µ ′ ) ∈ π G src(p ′ ) = src(p) tgt(p ′ ) = tgt(p)       ALL π G = π G ANY π G = (s,t)∈X {any({ (p, µ) | (p, µ) ∈ π G , endpoints(p) = (s, t) }} where X = { src(p), tgt(p) | (p, µ) ∈ π G }</formula><p>and any is a procedure that arbitrarily returns one element from a set; any need not be deterministic.</p><formula xml:id="formula_30">Π 1 , Π 2 G = { (p 1 × p2 , µ 1 ⋊ ⋉ µ 2 ) | (p i , µ i ) ∈ Π i G for i = 1, 2 and µ 1 ∼ µ 2 }</formula><p>Here, p1 = (p ). Just as it is the case of concatenation, since Π 1 , Π 2 is well-formed, implicit joins can occur over singleton variables only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Semantics of Conditions and Expressions</head><p>The semantics χ µ G of an expression χ is an element in V that is computed with respect to a binding µ and a graph G. Intuitively, variables in χ are evaluated with µ and we use G to access the properties of an element. It is formally defined as follows.</p><formula xml:id="formula_31">c µ G = c for c ∈ Const x µ G = µ(x) for x ∈ Dom(µ) x.a µ G = prop G (µ(x), a) if (µ(x), a) ∈ Dom(prop G ) null else if µ(x) ∈ (N ∪ E d ∪ E u ) for x ∈ Dom(µ), a ∈ K I C D T 2 0 2 3 If x / ∈ Dom(T ), then LET x = χ G (T ) = µ∈T {µ ⋊ ⋉ (x → χ µ G )} FILTER θ G (T ) = µ∈T µ | θ µ G = true .</formula><p>If x / ∈ Dom(T ) and, for every µ ∈ T , µ(y) is a list or null, <ref type="foot" target="#foot_1">3</ref> then</p><formula xml:id="formula_32">FOR x IN y G (T ) = µ∈T µ ⋊ ⋉ (x → v) | v ∈ µ(y) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics of Linear Queries</head><formula xml:id="formula_33">USE G ′ L G (T ) = L G ′ (T ) C L G (T ) = L G C G (T ) RETURN χ 1 AS x 1 , . . . , χ ℓ AS x ℓ G (T ) = µ∈T {(x 1 → χ 1 µ G , . . . , x ℓ → χ ℓ µ G )}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics of Queries</head><p>The output of a query Q is defined as</p><formula xml:id="formula_34">Output(Q) = Q G ({()}) ,</formula><p>where {()} is the unit table that consists of the empty binding, and G is the default graph in D. We define the semantics of queries recursively as follows.</p><formula xml:id="formula_35">USE G ′ {Q 1 THEN Q 2 • • • THEN Q k } G (T ) = Q k G ′ • • • • • Q 1 G ′ (T ) If Dom ( Q 1 G (T )) = Dom ( Q 2 G (T )</formula><p>), then we let</p><formula xml:id="formula_36">Q 1 INTERSECT Q 2 G (T ) = Q 1 G (T ) ∩ Q 2 G (T ) Q 1 UNION Q 2 G (T ) = Q 1 G (T ) ∪ Q 2 G (T ) Q 1 EXCEPT Q 2 G (T ) = Q 1 G (T ) \ Q 2 G (T )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A Few Known Discrepancies with the GQL Standard</head><p>In pursuing the goal of introducing the key features of GQL to the research community, we inevitably had to make decisions that resulted in discrepancies between our presentation and the 500+ pages of the forthcoming Standard. In this section, we discuss a non-exhaustive list of differences between the actual GQL Standard and our digest. To start with, in all our formal development we assumed that queries are given by their syntax trees, which result from parsing them. Hence we completely omitted such parsing-related aspects as parentheses, operator precedence etc. Also we note that many GQL features, even those described here, are optional, and not every implementation is obliged to have them all.</p><p>The remaining discrepancies are divided into three main categories: syntactic restrictions (Section 5.1), query evaluation (Section 5.2), and missing features (Section 5.3). The reader must bear in mind that, as the GQL Standard is roughly one year from publication in its final form, many aspects of the language may still change in a way that depends on the work of the Committee, and thus is impossible to predict.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">User-Friendly Syntactic Restrictions</head><p>The GQL Standard imposes restrictions on the syntax that aim at preventing unexpected behavior, and that we generally did not describe. Two such examples are given below.</p><p>First, the queries</p><formula xml:id="formula_37">Q 1 = MATCH µ x=-[]-&gt;* and Q 2 = MATCH µ x=-[]-&gt;*()</formula><p>for some path mode µ (it does not matter which one). According to our semantics, both return one binding, namely (x → path(u)), for each node u in the graph; however, Q 1 is syntactically forbidden in the GQL Standard because no node pattern occurs. Another interesting syntactic restriction concerns strict interior variables under selectors, such as c in the following:</p><formula xml:id="formula_38">MATCH ANY (:Person) -[]-&gt;* (c:Account) -[]-&gt;* (:Person), ANY (:Person) -[]-&gt;* (c:Account) -[]-&gt;* (:Person)</formula><p>The ANY selectors are evaluated independently, and before the implicit join on variable c. Then, the node bound to the variable c by either path pattern is arbitrary, and joining on them is very likely to fail. This situation was not deemed user-friendly by the Committee, and therefore precluded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Query Evaluation</head><p>Bag semantics. For simplicity, we described GQL as if it was following set semantics but, in reality, GQL uses bags just like Cypher and SQL. In order to define clauses and queries under bag semantics, small changes are needed: tables should be defined as bags, rather than sets, of bindings; unions (∪) over the elements of a table should be additive bag unions (⊎); and set comprehensions should be replaced with bag comprehensions. As an example, if we denote bags with double curly braces, then the semantics of RETURN is</p><formula xml:id="formula_39">RETURN χ 1 AS x 1 , . . . , χ ℓ AS x ℓ G (T ) = µ∈T { {(x 1 → χ 1 µ G , . . . , x ℓ → χ ℓ µ G )} }</formula><p>Note that GQL partially eliminates duplicates during pattern matching, which is reflected here by the semantics of graph patterns: Π G is a set of path/binding pairs, while MATCH Π G returns a bag of bindings by projecting out the paths (see the definition of MATCH Π G in Section 4.5). Hence, different ways to compute the same path/binding pair will only contribute to one copy of the binding in the output of MATCH Π G . It is still possible to get multiple copies of some binding in the output, but these come from pairs with different paths.</p><p>Partial deduplication is an effort to unify the multiplicies of queries that express the same pattern in different ways. To see this, consider the queries</p><formula xml:id="formula_40">Q 1 : MATCH (a:Person)-[]-&gt;(b WHERE b:Person OR b:Account) Q 2 : MATCH (a:Person)-[]-&gt;(b:Person) | (a)-[]-&gt;(b:Account)</formula><p>and the path (v 1 , e 1 , v 2 ) matched by either of them with the binding</p><formula xml:id="formula_41">µ 1 = (a → v 1 , b → v 2 ),</formula><p>where v 2 bears both labels Person and Account. As the disjunction in Q 1 is expressed using a Boolean condition, this query always returns a single copy of µ 1 . In Q 2 , however, the disjunction is expressed with a union (|) of patterns; thus, if the semantics of | were defined as a bag-union, the query would return two copies of µ 1 .</p><p>Finally, as in SQL, the operations INTERSECT, UNION, and EXCEPT remove duplicates in GQL, while the variants INTERSECT ALL, UNION ALL, and EXCEPT ALL do not.</p><p>Path bindings. In a nutshell, a path binding is a path where each element may be annotated with variables, and it is inconsistent as soon as two different elements have the same annotation (see <ref type="bibr" target="#b12">[12]</ref> for details). Thus, a path binding defines a single path/binding pair, whereas a path/binding pair can define several path bindings. In GQL Standard, pattern matching computes a set of consistent path bindings, while our semantics computes a set of path/binding pairs, and the results are bags formed by projecting away paths. Consequently, our semantics might sometimes return fewer results than GQL's, but the difference only affects multiplicity. For example, consider MATCH ()-[]-&gt;(a) | (a)-[]-&gt;() on a graph with a single node u and a single (looping) edge. According to our semantics, only one copy of (a → u) is returned, while two occurrences of it are returned according to GQL Standard.</p><p>Postponed evaluation of conditions. In our treatment of the language, the semantics of the following query is undefined:</p><formula xml:id="formula_42">MATCH ALL SHORTEST -[x]-&gt; ( ()-[y]-&gt;() WHERE x.amount &lt; y.amount ){10,10}</formula><p>Indeed, when the condition WHERE x.amount &lt; y.amount is evaluated, the variable x is not yet bound, as -[x]-&gt; occurs in a different branch of the query's syntax tree. In GQL Standard, however, the above query is legal, because the evaluation of WHERE conditions is postponed for as long as possible. <ref type="foot" target="#foot_2">4</ref> While the meaning of the query is clear, its evaluation is non-trivial. The context of each condition (here, y is bound to ten successive edge ids) must be recorded, because it will be different when the evaluation occurs. Note that the evaluation of conditions must occur before the evaluation of SHORTEST, hence queries like</p><formula xml:id="formula_43">MATCH -[x]-&gt;, ALL SHORTEST ( -[y]-&gt; WHERE x.amount &lt; y.amount ){10,10}</formula><p>are not allowed in GQL.</p><p>Referencing the input table in conditions during pattern patching. In our semantics, the input table is not passed on to pattern matching, so one cannot refer to variables from it in WHERE conditions. As an example, the semantics of LET x=42 MATCH (a WHERE a.amount=x) is undefined. It is not yet clear whether such a query is allowed in the GQL Standard or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Missing Features</head><p>Syntactic sugar. The GQL Standard includes a lot of syntactic sugar that we disregarded. For instance, several other types of edge patterns exist, such as -[δ]-, which matches edges regardless of their direction. Another example is the possibility of using * and + as shorthands for {0,} and {1,}, respectively.</p><p>Complex label expressions. We only allow a single label in descriptors, but the GQL Standard allows complex label expressions, as in MATCH (a:YachtClub|(Person&amp;!Account)). Using WHERE, this could be rewritten as MATCH (a WHERE a:YachtClub OR (a:Person AND NOT a:Account))</p><p>Label expressions can also use the special atom "%" to check the nonemptyness of the label set. For example, MATCH (a:%) matches nodes with at least one label and MATCH (a:!%) matches node with no labels. Note that "%" cannot be used to define a regular expression of labels, unlike its usage in the LIKE expressions of SQL.</p><p>Complex path modes. GQL allows more complex path modes than described here. Recall that SHORTEST partitions matched paths by endpoints and returns the shortest paths for each pair of endpoints. SHORTEST k GROUPS generalizes this: for each pair of endpoints, it returns all paths of length at most i k , where i 1 &lt; i 2 &lt; • • • &lt; i k are the k smallest lengths of paths between these endpoints. SHORTEST k PATHS returns k shortest paths for each pair of endpoints. Another mode present in GQL is SIMPLE: it is similar to ACYCLIC but allows the first and the last node on a path to be the same, i.e., a simple cycle. There is also the keyword WALK to explicitly indicate the absence of a path mode.</p><p>GQL's TRAIL differs from Cypher's trail semantics <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b17">17]</ref>. The latter corresponds to GQL's match mode DIFFERENT EDGES, which is omitted in this digest. Indeed, Cypher's requirement that all matched edges must be different operates at the level of graph patterns, whereas GQL's TRAIL operates at the level of path patterns. Hence, while the GQL query MATCH TRAIL ()-[e1]-&gt;(), TRAIL ()-[e2]-&gt;() will return bindings in which e1 and e2 are equal, the Cypher query MATCH ()-[e1]&gt;(), ()-[e2]-&gt;() would not; the latter behaviour is captured by the GQL query MATCH DIFFERENT EDGES ()-[e1]&gt;(), ()-[e2]-&gt;().</p><p>Finally, we only use path modes at the beginning of path patterns. GQL's rules are more involved, in that they allow TRAIL and ACYCLIC to be used inside patterns.</p><p>Projection clauses. The GQL Standard includes several clauses similar to RETURN, such as YIELD, PROJECT, and SELECT. We ignored these because, although they are not allowed at the same positions in queries, they can be simulated by simple rewritings in terms of RETURN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Combination of queries.</head><p>In addition to set operations (UNION, etc.) and bag operations (UNION ALL, etc.), queries could be of the form Q 1 OTHERWISE Q 2 . Its semantics is as follows:</p><formula xml:id="formula_44">Q 1 OTHERWISE Q 2 (T ) equals Q 1 (T ) if table Q 1 (T ) is non-empty, otherwise it equals Q 2 (T ).</formula><p>Aggregation. The GQL Standard will feature two kinds of aggregation. The first one, much like GROUP BY in SQL, groups together bindings under which the evaluation of an expression produces the same value, then an aggregate value is computed for each group. The exact details are still under development, but it appears likely that such aggregation will be limited to RETURN statements, thus having a very relational character.</p><p>The second kind will aggregate along matched paths to compute a value, both during and after pattern matching. Computing the length of a path is a typical example; one can have more complex aggregates, such as the sum of the values n.amount for each node n in the path. This is similar to reduce in Cypher. The use of this feature in pattern matching requires strong syntactic restrictions for query evaluation to be decidable <ref type="bibr" target="#b16">[16]</ref>.</p><p>Subqueries. GQL has a facility to run subqueries through the CALL Q clause, the semantics of which is roughly as follows: for each binding µ in the input table, Q G ({µ}) is evaluated in a sub-process, and the resulting table is left-joined with the current working table. An important detail is that CALL can only expand bindings. It cannot remove columns from the input table nor change the values in them. The existence of read-only columns matters in clauses like RETURN, which cannot therefore be treated with our semantics as is. In GQL, this is handled with a notion of working record.</p><p>Note also that CALL Q will make nondeterminism much harder to detect if updates happen in Q. Tables are unordered sets (or bags) but in an update clause each binding causes changes in the graph (see next item) and so it can modify the evaluation of the clause for the next binding. In such cases, inconsistent changes may be detected <ref type="bibr" target="#b21">[21]</ref>.</p><p>Updates. Graph database updates in GQL are outside the scope of this paper. They will work similarly to Cypher updates <ref type="bibr" target="#b21">[21]</ref>, by using clauses that can add and remove elements (INSERT and DELETE), or modify elements' attributes (SET and REMOVE). Therefore, pattern matching and updates can be mixed together and result in bulk updates to the graph based on its contents, as in the example below: Expressiveness and complexity. For relational query languages, the database research community has uncovered a rich landscape of fragments (conjunctive queries, positive queries, and queries with inequalities are some very well studied examples) and extensions (for example, adding counting and aggregation, or adding recursion as in many instantiations of datalog), see <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4]</ref>. For these, we understand the trade-off between their expressiveness and the complexity of query evaluation. Here we have described a basic language for graphs, essentially the core of GQL, akin to relational algebra and calculus. Now we need to develop its theory, starting with understanding expressiveness and complexity and their trade-offs, in a way similar to what we know about relational databases. For the pattern matching facilities of GQL, shared with SQL/PGQ, some early results are available <ref type="bibr" target="#b16">[16]</ref>.</p><p>Query processing and optimization. Query processing and optimization is a central area in relational database research that needs yet to be developed for GQL. In a more theoretical level, the basis for understanding optimization is query equivalence and containment. We know a thing or two about containment for (conjunctive) regular path queries <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b15">15]</ref> and extensions with data <ref type="bibr" target="#b26">[26]</ref> but not for queries that resemble the real-life language. Moving to more practical aspects, one needs efficient and practical algorithms and data structures for processing graph queries in GQL, whether in a native system, or a relational implementation. Of course there is significant work in this direction <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b23">23,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b35">35,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b25">25]</ref> but it needs to be adjusted to languages that will dominate the practical landscape for decades.</p><p>Design decisions and alternatives. We explained in Remark 9 how GQL currently forbids concatenating patterns that contain different kinds of variables. Notice, however, that this current state reflects a design decision and it may be interesting to explore other avenues for graph query languages. For instance, one could consider a semantics in which both occurrences of x in Remark 9 should be bound to single nodes. Under such a semantics, the pattern would essentially perform a join on the even nodes of the path and would match "flower" shaped paths centered around node x, consisting of Transfer-loops of length two. Alternatively, one could consider a semantics in which, as soon as x occurs as a group variable, all occurrences of x are considered to be group variable occurrences. In this case, the query would match Transfer-paths of even length and bind x to the list of "even" nodes on such paths. In line with this work would be the study of an automaton model with group variables that would allow classical evaluation and automata-theoretic constructions such as the product, determinization, etc. Since GQL is a complex language, there are many such places in which fundamental research can either help to validate the current design decisions or propose alternatives.</p><formula xml:id="formula_45">I</formula><p>Updates. We have concentrated on the read-only part of the languages and have not touched updates. Designing a proper update language is not a simple task: in Cypher, for example, the initial design exhibited a multitude of problems <ref type="bibr" target="#b21">[21]</ref>. GQL largely follows Cypher, which means its updates and transaction processing facilities need to be designed with care and subjected to the same research scrutiny as their relational counterpart.</p><p>Graph-to-graph queries. GQL, as its precursors including Cypher, is a very good tool for turning graphs into relations. The ever reappearing issue in the field of graph languages is how to design a graph-to-graph language whose queries output graphs. Queries are then composable: a query can be applied to the output of a previous one. We also regain such basic concepts as views and subqueries, taken for granted in relational databases, but very limited in the current graph database landscape.</p><p>Metadata. Looking into the future, we need to have a good schema language for graphs, and see how it interacts with graph query languages. Some efforts in this direction have already been made: for example, the PG-Keys proposal introduces keys for property graphs <ref type="bibr" target="#b2">[3]</ref> and more recently proposed PG-Schema <ref type="bibr" target="#b1">[2]</ref> specifies a schema language for property graphs that should lead to future schema standards. As these are formulated, much theory needs to be developed, for example semantic query optimization, as well as incremental validation of schemas and constraints following work for relational and semistructured data <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b5">6]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 A</head><label>1</label><figDesc>Figure 1 A database with graphs Fraud and Social.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>8 . 9 .</head><label>89</label><figDesc>FILTER sender=x1.name AND recipient=y1.name RETURN z1.address AS clubAddress 10. }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>(</head><label></label><figDesc>x1) -[:Member]-&gt; (z1:YachtClub) , (y1) -[:Member]-&gt; (z1:YachtClub)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2</head><label>2</label><figDesc>Figure 2 Syntax of GQL.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>10 A</head><label>10</label><figDesc>a labeling function that associates with every id a (possibly empty) finite set of labels from L; Researcher's Digest of GQL src G , tgt G : E G d → N G define source and target of a directed edge; endpoints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>(x) WHERE (x:ℓ AND θ). -&gt; G = (path(src(e), e, tgt(e)), ()) e ∈ E G d -[x]-&gt; G = (path(src(e), e, tgt(e)), (x → e)) e ∈ E G d -[:ℓ]-&gt; G = (path(src(e), e, tgt(e)), ()) e ∈ E G d , ℓ ∈ lab G (e) Other cases of the forward edge patterns are treated by moving the label and conditions outside of the edge pattern, just as for node patterns. Backward edge patterns and undirected edge patterns are treated similarly, with the base cases given below. &lt;-[]-G = (path(tgt(e), e, src(e)), ()) e ∈ E G d ~[]~ G = (path(u 1 , e, u 2 ), ()), (path(u 2 , e, u 1 ), ()) e ∈ E G u {u 1 , u 2 } = endpoints G (e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>1:4 A Researcher's Digest of GQL labels</head><label></label><figDesc>and properties. In Fraud, the nodes have label Account and properties owner and isBlocked, indicating the status of the account. In Social, these nodes have label Person and property name.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>1 .</head><label>1</label><figDesc>USE Fraud 2. MATCH (x) -[z:Transfer WHERE z.amount&gt;1000000]-&gt; (y WHERE y.isBlocked=true) 3. RETURN x.owner AS sender, y.owner AS recipient</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>The FILTER condition in line 8 selects only the first row of the latter table. The RETURN statement in line 9 tells us to keep only the address attribute of z1, renamed as clubAddress, resulting in:</head><label></label><figDesc>Notice that the query uses Cypher's ascii-art ( ) for nodes in the subexpressions (x), (y), and (), but also uses ( ) for indicating the subexpression over which {1,} is applied.</figDesc><table><row><cell></cell><cell></cell><cell>with table (1), leading to</cell></row><row><cell cols="3">sender recipient x1 y1 z1</cell></row><row><cell>Jay</cell><cell>Mike</cell><cell>p1 p2 c1</cell></row><row><cell>Jay</cell><cell>Mike</cell><cell>p1 p1 c1</cell></row><row><cell>Jay</cell><cell>Mike</cell><cell>p2 p2 c1</cell></row><row><cell cols="3">In this case, this will be the Cartesian product since the two working tables have no variables</cell></row><row><cell cols="2">in common. clubAddress</cell><cell></cell></row><row><cell cols="2">Cable Street</cell><cell></cell></row><row><cell cols="3">This is also where our query ends, and the working table contains all the results to our query.</cell></row><row><cell cols="3">The examples we have seen thus far illustrate only a limited part of GQL since their</cell></row><row><cell cols="3">variables only bind to single nodes or edges. Next, we show what happens to variables that</cell></row><row><cell cols="3">can bind to lists and paths. Concerning lists, a query 1 such as</cell></row><row><cell>USE Fraud</cell><cell></cell><cell></cell></row><row><cell cols="3">MATCH TRAIL (x) ((y)-[:Transfer]-&gt;()){1,} (x)</cell></row><row><cell cols="3">RETURN x AS source, y AS moneyTrail</cell></row><row><cell cols="3">would return the following table.</cell></row></table><note><p><p>1</p>I C</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>D T 2 0 2 3 1:6 A Researcher's Digest of GQL</head><label></label><figDesc></figDesc><table><row><cell cols="2">source moneyTrail</cell></row><row><cell>p1</cell><cell>list(p1, p2, a2, a1)</cell></row><row><cell>p2</cell><cell>list(p2, a2, a1, p1)</cell></row><row><cell>a2</cell><cell>list(a2, a1, p1, p2)</cell></row><row><cell>a1</cell><cell>list(a1, p1, p2, a2)</cell></row><row><cell cols="2">Here, the variable y is bound to a list of nodes. The four outputs all describe the same trail,</cell></row><row><cell cols="2">which is the only Transfer-cycle in the graph, but the bindings use different start nodes for x</cell></row><row><cell cols="2">and therefore also order the nodes in the lists for y differently. Concerning paths, the query</cell></row><row><cell>USE Fraud</cell><cell></cell></row><row><cell cols="2">MATCH TRAIL p = (x) (-[:Transfer]-&gt;()){1,} (x)</cell></row><row><cell cols="2">RETURN x AS source, p AS path</cell></row><row><cell cols="2">would return the following table.</cell></row><row><cell cols="2">source path</cell></row><row><cell>p1</cell><cell>path(p1, t1, p2, t2, a2, t3, a1, t4, p1)</cell></row><row><cell>p2</cell><cell>path(p2, t2, a2, t3, a1, t4, p1, t1, p2)</cell></row><row><cell>a2</cell><cell>path(a2, t3, a1, t4, p1, t1, p2, t2, a2)</cell></row><row><cell>a1</cell><cell>path(a1, t4, p1, t1, p2, t2, a2, t3, a1)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>In this paper we have summarized the key elements of GQL, which is currently being developed as a new standard graph query language (the timeline of ISO calls for the publication of the Standard in either late 2023 or early 2024). At the time when the first version of the SQL Standard was produced, many key elements of relational theory were already in place. For GQL, the standardization work is well ahead of the academic developments it should ideally be based upon. In what follows, we bring to the attention of the community several directions of academic work that will facilitate the development of graph query languages and their standardization.</figDesc><table><row><cell></cell><cell cols="2">MATCH (a:Account)</cell><cell>--match every Account a</cell></row><row><cell></cell><cell cols="2">INSERT (p:Person)</cell><cell>--create a new Person node for each a</cell></row><row><cell></cell><cell>SET</cell><cell>p.name = a.owner</cell><cell>--set the name of the new node</cell></row><row><cell></cell><cell cols="2">INSERT (p)-[:Owns]-&gt;(a)</cell><cell>--create a new "Owns" edge from p to a</cell></row><row><cell></cell><cell cols="2">REMOVE a.owner</cell><cell>--remove the owner property from a</cell></row><row><cell>6</cell><cell cols="3">What the Future Holds</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>The default graph is used for evaluation when a specific graph is not declared by the query.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>Note that null is treated just as list() I C D T 2 0 2 3</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>This is orthogonal to left-to-right evaluation: -[x]-&gt; could be placed on the right instead.</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>Funding This work is supported by: a <rs type="funder">Leverhulme Trust</rs> <rs type="grantName">Research Fellowship</rs>; <rs type="funder">EPSRC</rs> grant <rs type="grantNumber">S003800</rs>; <rs type="funder">French ANR</rs> projects grants <rs type="grantNumber">ANR-18-CE40-0031</rs> (<rs type="projectName">QUID</rs>), <rs type="grantNumber">ANR-19-CE48-0019</rs> (<rs type="projectName">EQUUS</rs>), and <rs type="grantNumber">ANR-21-CE48-0015</rs> (Verigraph); <rs type="funder">German Research Foundation (DFG)</rs> projects <rs type="grantNumber">431183758</rs> and <rs type="grantNumber">369116833</rs>; <rs type="programName">ANID Millennium Science Initiative Program</rs>, Code <rs type="grantNumber">ICN17_002</rs>; <rs type="projectName">ANID Fondecyt Regular</rs> project <rs type="grantNumber">1221799</rs>; <rs type="funder">NCN</rs> grant <rs type="grantNumber">2018/30/E/ST6/00042</rs>.</p></div>
<div><head>Acknowledgements</head><p>The authors are grateful to members of the ISO/IEC JTC1 SC32 WG3 committee and especially <rs type="person">Fred Zemke</rs> for many comments on our formalization of the language.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_6nmZqzr">
					<orgName type="grant-name">Research Fellowship</orgName>
				</org>
				<org type="funding" xml:id="_wvk5j2H">
					<idno type="grant-number">S003800</idno>
				</org>
				<org type="funded-project" xml:id="_6HFRUjs">
					<idno type="grant-number">ANR-18-CE40-0031</idno>
					<orgName type="project" subtype="full">QUID</orgName>
				</org>
				<org type="funded-project" xml:id="_MeqQUuC">
					<idno type="grant-number">ANR-19-CE48-0019</idno>
					<orgName type="project" subtype="full">EQUUS</orgName>
				</org>
				<org type="funding" xml:id="_shdVgRC">
					<idno type="grant-number">ANR-21-CE48-0015</idno>
				</org>
				<org type="funding" xml:id="_6N8qWNs">
					<idno type="grant-number">431183758</idno>
				</org>
				<org type="funding" xml:id="_4QmtyXJ">
					<idno type="grant-number">369116833</idno>
					<orgName type="program" subtype="full">ANID Millennium Science Initiative Program</orgName>
				</org>
				<org type="funded-project" xml:id="_hqYNqFP">
					<idno type="grant-number">ICN17_002</idno>
					<orgName type="project" subtype="full">ANID Fondecyt Regular</orgName>
				</org>
				<org type="funding" xml:id="_ThU25xe">
					<idno type="grant-number">1221799</idno>
				</org>
				<org type="funding" xml:id="_MXQEhmN">
					<idno type="grant-number">2018/30/E/ST6/00042</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Researcher's Digest of GQL</head><p>▶ Remark 11. Recall that different graphs may share nodes and edges. Hence the condition (µ(x), a) ∈ Dom(prop G ), above, does imply that µ(x) is a node or an edge in G, but does not imply that it was matched in G.</p><p>The semantics θ µ G of a condition θ is an element in {true, false, null} that is evaluated with respect to a binding µ and a graph G, and is defined as follows:</p><p>Operators ∧, ∨, and ¬ are defined as in SQL three-valued logic, e.g. null ∨ true = true while null ∧ true = null.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Semantics of Queries</head><p>Clauses and queries are interpreted as functions that operate on tables. These tables are our abstraction of GQL's working tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>▶ Definition 12. A table T is a set of bindings that have the same domains, referred to as Dom(T ).</head><p>Note that tables do not have schemas: two different bindings in a table might associate a variable to values of incompatible types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantics of Clauses</head><p>The semantics C G of a clause C is a function that maps tables into tables, and is parametrized by a graph G. Patterns, conditions and expression in a clause are evaluated with respect to that G.</p><p>Note that if Π uses a variable that already occurs in Dom(T ), a join is performed. Unlike in the case of path patterns and graph patterns, this join can involve variables bound to lists or paths. While this is not problematic mathematically, it might be disallowed in future iterations of GQL.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefania</forename><surname>Dumbrava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ognjen</forename><surname>Savkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Slawek</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dominik</forename><surname>Tomaszuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingxi</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dusan</forename><surname>Zivkovic</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2211.10962</idno>
		<title level="m">PG-Schema: Schemas for property graphs</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">PG-Keys: Keys for property graphs</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefania</forename><surname>Dumbrava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><forename type="middle">W</forename><surname>Hare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><forename type="middle">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josh</forename><surname>Perryman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ognjen</forename><surname>Savkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">F</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Slawek</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dominik</forename><surname>Tomaszuk</surname></persName>
		</author>
		<idno type="DOI">10.1145/3448016.3457561</idno>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;21: International Conference on Management of Data</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="2423" to="2436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Database Theory</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<ptr target="https://github.com/pdm-book/community" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Evaluating navigational RDF queries over the web</title>
		<author>
			<persName><forename type="first">Jorge</forename><forename type="middle">A</forename><surname>Baier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dietrich</forename><surname>Daroch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoč</surname></persName>
		</author>
		<idno type="DOI">10.1145/3078714.3078731</idno>
	</analytic>
	<monogr>
		<title level="j">HT</title>
		<imprint>
			<biblScope unit="page" from="165" to="174" />
			<date type="published" when="2017">2017</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient incremental validation of XML documents</title>
		<author>
			<persName><forename type="first">Denilson</forename><surname>Barbosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Mignet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2004.1320036</idno>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="671" to="682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A coq mechanised formal semantics for realistic SQL queries: formally reconciling SQL and bag relational algebra</title>
		<author>
			<persName><forename type="first">Véronique</forename><surname>Benzaken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evelyne</forename><surname>Contejean</surname></persName>
		</author>
		<idno type="DOI">10.1145/3293880.3294107</idno>
	</analytic>
	<monogr>
		<title level="m">CPP</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="249" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Containment of conjunctive regular path queries with inverse</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KR</title>
		<imprint>
			<biblScope unit="page" from="176" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Morgan</forename><surname>Kaufmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reasoning on regular path queries</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1145/959060.959076</idno>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="83" to="92" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">HoTTSQL: proving query rewrites with univalent SQL semantics</title>
		<author>
			<persName><forename type="first">Shumo</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantin</forename><surname>Weitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1145/3062341.3062348</idno>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="510" to="524" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A graphical query language supporting recursion</title>
		<author>
			<persName><forename type="first">Isabel</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1145/38713.38749</idno>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Graph pattern matching in GQL and SQL/PGQ</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Hare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Michels</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Oskar Van Rest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingxi</forename><surname>Vrgoc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><surname>Zemke</surname></persName>
		</author>
		<idno type="DOI">10.1145/3514221.3526057</idno>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="2246" to="2258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Aggregation support for modern graph analytics in TigerGraph</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingxi</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><forename type="middle">E</forename><surname>Lee</surname></persName>
		</author>
		<idno type="DOI">10.1145/3318464.3386144</idno>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="377" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A query language for a web-site management system</title>
		<author>
			<persName><forename type="first">Mary</forename><forename type="middle">F</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1145/262762.262763</idno>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="4" to="11" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Containment of simple conjunctive regular path queries</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Figueira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adwait</forename><surname>Godbole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shankara</forename><surname>Narayanan Krishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Niewerth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tina</forename><surname>Trautner</surname></persName>
		</author>
		<idno type="DOI">10.24963/kr.2020/38</idno>
	</analytic>
	<monogr>
		<title level="j">KR</title>
		<imprint>
			<biblScope unit="page" from="371" to="380" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">GPC: A pattern calculus for property graphs</title>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amélie</forename><surname>Gheerbrant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liat</forename><surname>Peterfreund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Rogova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoč</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS&apos;23</title>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Formal semantics of the language Cypher</title>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Rydberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrés</forename><surname>Taylor</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.09984</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Cypher: An evolving query language for property graphs</title>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Rydberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrés</forename><surname>Taylor</surname></persName>
		</author>
		<idno type="DOI">10.1145/3183713.3190657</idno>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1433" to="1445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<ptr target="https://www.gqlstandards.org/existing-languages" />
		<title level="m">GQL influence graph</title>
		<imprint>
			<date type="published" when="2023-01-17">2023. 2023-01-17</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Property graphs and paths in GQL: Mathematical definitions</title>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<idno type="DOI">10.54285/ldbc.TZJP7279</idno>
		<imprint>
			<date type="published" when="2021-10">October 2021</date>
		</imprint>
		<respStmt>
			<orgName>Linked Data Benchmark Council (LDBC)</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Reports</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Updating graph databases with Cypher</title>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Voigt</surname></persName>
		</author>
		<idno type="DOI">10.14778/3352063.3352139</idno>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2242" to="2253" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A formal semantics of SQL queries, its validation, and applications</title>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<idno type="DOI">10.14778/3151113.3151116</idno>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="39" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Sparqling Kleene: Fast property paths in RDF-3X</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srikanta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Bedathur</surname></persName>
		</author>
		<author>
			<persName><surname>Seufert</surname></persName>
		</author>
		<idno type="DOI">10.1145/2484425.2484443</idno>
	</analytic>
	<monogr>
		<title level="m">GRADES. CWI/ACM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Mumick</surname></persName>
		</author>
		<title level="m">Materialized Views: Techniques, Implementations, and Applications</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A worst-case optimal join algorithm for SPARQL</title>
		<author>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Riveros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Rojas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrián</forename><surname>Soto</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-30793-6_15</idno>
	</analytic>
	<monogr>
		<title level="m">ISWC (1)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">11778</biblScope>
			<biblScope unit="page" from="258" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Containment of queries for graphs with data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Egor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><surname>Vrgoc</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.jcss.2017.09.005</idno>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="65" to="91" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Querying graphs with data</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoč</surname></persName>
		</author>
		<idno type="DOI">10.1145/2850413</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Representing paths in graph database pattern matching</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Niewerth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tina</forename><surname>Popp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoč</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2207.13541</idno>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Querying the world wide web</title>
		<author>
			<persName><forename type="first">Alberto</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><forename type="middle">A</forename><surname>Mihaila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<idno type="DOI">10.1109/PDIS.1996.568671</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Conference on Parallel and Distributed Information Systems</title>
		<meeting>the Fourth International Conference on Parallel and Distributed Information Systems<address><addrLine>Miami Beach, Florida, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996">December 18-20, 1996. 1996</date>
			<biblScope unit="page" from="80" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Finding regular simple paths in graph databases</title>
		<author>
			<persName><forename type="first">Alberto</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
		<idno type="DOI">10.1137/S009753979122370X</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1235" to="1258" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Join processing for graph patterns: An old dog with new tricks</title>
		<author>
			<persName><forename type="first">Dung</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Molham</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Bravenboer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Kollias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hung</forename><forename type="middle">Q</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atri</forename><surname>Rudra</surname></persName>
		</author>
		<idno type="DOI">10.1145/2764947.2764948</idno>
	</analytic>
	<monogr>
		<title level="j">GRADES</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">8</biblScope>
			<date type="published" when="2015">2015</date>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Regular queries on graph databases</title>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miguel</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00224-016-9676-2</idno>
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="83" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The Gremlin graph traversal machine and language</title>
		<author>
			<persName><forename type="first">Marko</forename><forename type="middle">A</forename><surname>Rodriguez</surname></persName>
		</author>
		<idno type="DOI">10.1145/2815072.2815073</idno>
	</analytic>
	<monogr>
		<title level="m">DBPL</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">PGQL: a property graph query language</title>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Oskar Van Rest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinha</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuming</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><surname>Chafi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2960414.2960421</idno>
	</analytic>
	<monogr>
		<title level="m">GRADES</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoč</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2204.11137</idno>
		<title level="m">Evaluating regular path queries under the all-shortest paths semantics</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">GQL graph query language</title>
		<ptr target="https://en.wikipedia.org/wiki/GQL_Graph_Query_Language" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note>Wikipedia contributors</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Query planning for evaluating SPARQL property paths</title>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parke</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jarek</forename><surname>Gryz</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2882944</idno>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1875" to="1889" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
