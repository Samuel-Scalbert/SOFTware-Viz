<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Determinization and Minimization of Automata for Nested Words Revisited</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
							<email>joachim.niehren@inria.fr</email>
							<idno type="ORCID">0000-0002-2611-8950</idno>
							<affiliation key="aff0">
								<orgName type="institution">Inria Lille</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Momar</forename><surname>Sakho</surname></persName>
							<email>momar.sakho@inria.fr</email>
							<idno type="ORCID">0000-0001-6802-5480</idno>
							<affiliation key="aff1">
								<orgName type="institution">Inria Lille</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Determinization and Minimization of Automata for Nested Words Revisited</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C933B203147F6CB41C9BD378D66CD7B5</idno>
					<idno type="DOI">10.3390/a14030068</idno>
					<note type="submission">Version February 8, 2021 submitted to Algorithms</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Regular Expressions</term>
					<term>Tree Automata</term>
					<term>Nested Words</term>
					<term>Hedges, Logical Queries</term>
					<term>XPath</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the problem of determinizing and minimizing automata for nested words in practice. For this we compile the nested regular expressions (NREs) from the usual XPath benchmark to nested word automata (NWAs). The determinization of these NWAs, however, fails to produce reasonably small automata. In the best case, huge deterministic NWAs are produced after few hours, even for relatively small NREs of the benchmark.</p><p>We propose a different approach to the determinization of automata for nested words. For this, we introduce stepwise hedge automata (SHAs) that generalize naturally on both (stepwise) tree automata and on finite word automata. We then show how to determinize SHAs, yielding reasonably small deterministic automata for the NREs from the XPath benchmark. The size of deterministic SHAs automata can be reduced further by a novel minimization algorithm for a subclass of SHAs.</p><p>In order to understand why the new approach to determinization and minimization works so nicely, we investigate the relationship between NWAs and SHAs further. Clearly, deterministic SHAs can be compiled to deterministic NWAs in linear time, and conversely, NWAs can be compiled to nondeterministic SHAs in polynomial time. Therefore, we can use SHAs as intermediates for determinizing NWAs, while avoiding the huge size increase with the usual determinization algorithm for NWAs. Notably, the NWAs obtained from the SHAs perform bottom-up and left-to-right computations only, but no top-down computations. This NWA-behavior can be distinguished syntactically by the (weak) single-entry property, suggesting a close relationship between SHAs and single-entry NWAs. In particular, it turns out that the usual determinization algorithm for NWAs behaves well for single-entry NWAs, while it quickly explodes without the single-entry property. Furthermore, it is known that the class of deterministic multi-module single-entry NWAs enjoys unique minimization. The subclass of deterministic SHAs to which our novel minimization algorithm applies is different though, in that we do not impose multiple modules. As further optimizations for reducing the sizes of the constructed SHAs, we propose schema-based cleaning and symbolic representations based on apply-else rules, that can be maintained by determinization. We implemented the optimizations and report the experimental results for the automata constructed for the XPathMark benchmark.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Nested words are hierarchical structures that are omnipresent in computer science. They were used to represent sequences of data trees, like XML or JSON documents, and to analyze the call structure of recursive programs. The idea of nested words is to generalize on both words and trees, resulting in sequences of unranked trees that are also known as hedges. Or else, nested words can be obtained by enriching Dyck words with internal letters, besides opening and closing parentheses. Furthermore, nested words are the elements of the least set containing internal letters from a given alphabet, triples consisting of an opening parenthesis, a nested word, and a closing parenthesis, and all sequences of nested words. Last but not least, nested words can be seen as words over an alphabet with internal letters, opening parentheses and closing parentheses, under the conditions that the parenthesis are well-nested, so that every opening parenthesis is properly closed and every closing parenthesis properly opened.</p><p>From the viewpoint of formal language theory, a natural question is how to lift the notions of finite automata and regular expressions, from words and trees to nested words, while preserving their well-known relationships. Nested word automata (NWAs) were heavily studied since the eighties <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b2">[2]</ref><ref type="bibr" target="#b3">[3]</ref><ref type="bibr" target="#b4">[4]</ref>, under then name input driven automata. They are the same as visibly pushdown automata <ref type="bibr" target="#b5">[5]</ref>, pushdown forest automata <ref type="bibr" target="#b6">[6]</ref> and streaming tree automata <ref type="bibr" target="#b7">[7]</ref>. NWAs can recognize the same languages of unranked trees as hedge automata <ref type="bibr" target="#b8">[8]</ref>, a generalization of tree automata for ranked trees <ref type="bibr" target="#b9">[9]</ref>. NWAs are often defined as pushdown automata with visible stacks, meaning that exactly one symbol is pushed when reading an opening parenthesis, and exactly one symbol is popped when reading a closing parenthesis, while the stack is not used otherwise. Their main advantage is a powerful notion of determinism, generalizing both over bottom-up and top-down determinism of tree automata for ranked trees <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b3">3]</ref>.</p><p>We note that general pushdown automata do not permit determinization in contrast.</p><p>Regular expressions for nested words were proposed more recently by Hosoya and Pierce <ref type="bibr" target="#b10">[10]</ref> under the name of regular expression types. In the present article, we will call them nested regular expressions (NREs) instead. Independently, more complex notions of nested regular expressions were introduced <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b12">12]</ref> in order to deal with generalizations of nested words with dangling opening and closing parentheses, which are not of interest to us. It was already claimed in <ref type="bibr" target="#b10">[10]</ref>, that our simpler notion of NREs has the same expressiveness as hedge automata <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b9">9]</ref>, which in turn have the same expressiveness as NWAs <ref type="bibr" target="#b3">[3]</ref>. However, the question under which conditions NREs can be compiled to small deterministic NWAs has not been studied. For classes of NREs for which deterministic NWAs can be computed in polynomial time, we can decide language inclusion or equivalence in polynomial time too. For other classes, these problems may not be feasible since language inclusion for nondeterministic NWAs is EXP-complete.</p><p>Our concrete interest in the universality of deterministic NWAs is motivated by XML stream processing: we want to compute the certain answers of a navigational XPath query on an XML stream <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14]</ref>, i.e., those elements that are selected in all possible futures of the stream. Whether an answer is certain is computationally hard, even for tiny syntactic fragments of navigational XPath <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b16">15]</ref>, but can be done in polynomial time for queries defined by deterministic NWAs <ref type="bibr" target="#b17">[16]</ref>. A natural question is therefore, whether it is possible to compile navigational XPath queries as in the usual benchmark <ref type="bibr" target="#b18">[17]</ref> to deterministic NWAs of reasonable size. Unfortunately, the existing compilers fail to do so <ref type="bibr" target="#b19">[18]</ref>, since they are based on NWA determinization for dealing with disjunction, negation, and recursive steps.</p><p>Thereby they produce huge deterministic automata even for very simple navigational XPath queries from the benchmark, or do not terminate after some hours.</p><p>In this article, we consider NREs for defining queries on nested words. For benchmarking with realistic example, we consider the navigational XPATH queries in the XPathMark benchmark with only forwards axis, that we compiled to NREs of the same size up to a constant factor. The question is then whether these NREs can be compiled to reasonably small deterministic NWAs.</p><p>As a first approach, we distinguish a subclass of "deterministic" NREs that can be compiled in polynomial time to deterministic NWAs by generalizing on Glushkov's construction of deterministic finite-state automata (DFAs) from "deterministic" regular expressions <ref type="bibr" target="#b20">[19,</ref><ref type="bibr" target="#b21">20]</ref>. However, the NREs obtained by compilation from navigational XPath queries are rarely deterministic, so neither are the NWAs compiled from them. And since we cannot apply NWA determinization to them in practice as argued above, this first approach has a much too low coverage to reach the objective. So we will report it only at the end in Section 9.</p><p>For our second approach, we propose a novel variant of automata for nested words that we call stepwise hedge automata (SHAs). Even though motivated by the wish to create deterministic automata for the NREs of our benchmark, they are of general interest: they generalize naturally on both (stepwise) tree automata <ref type="bibr" target="#b22">[21]</ref> and on finite word automata. In contrast to stepwise tree automata, SHAs cannot only recognize unranked trees but also sequences thereof, i.e., hedges or nested words. Furthermore, SHAs can be determinized in a bottom-up and left-to-right manner, by combining in a natural manner the determinization procedures for tree and word automata.</p><p>By adapting existing compilers for stepwise tree automata <ref type="bibr" target="#b22">[21]</ref>, SHAs can be compiled to NWAs with the same language in linear time while preserving determinism. And conversely, NWAs can be compiled to SHAs in polynomial time, but at the cost of introducing nondeterminism. By compiling NWAs to SHAs, determinizing the SHA, and compiling the obtained deterministic SHA back to a deterministic NWA, we can determinize NWAs by determinizing the corresponding SHAs. This alternative determinization algorithm for NWAs is different from the usual determinization algorithm for NWAs <ref type="bibr" target="#b2">[2,</ref><ref type="bibr" target="#b3">3,</ref><ref type="bibr" target="#b19">18]</ref>. Indeed, it yields reasonably small deterministic NWAs for the NREs from the XPath benchmark.</p><p>Yet another alternative algorithm for determinizing NWAs can be obtained by compiling NWAs to SHAs and back, and then determinizing the NWAs obtained in this manner. When applied to back-and-forth converted NWAs, the usual NWA determinization algorithm turns out to be well-behaved: it produces deterministic NWAs of reasonable size for all our benchmark NREs. This might be surprising, given that the same determinization algorithm behaved so poorly for the non-converted NWAs that were obtained from the benchmark NREs directly.</p><p>We contribute two further solutions for producing deterministic NWAs for our benchmark NREs.</p><p>These are both based on a direct compiler from NREs to SHAs. We can then determinize these SHAs, followed by compilation to deterministic NWAs. Or else, we can first compile the SHAs to NWAs and then determinize these NWAs. The next question is why the new determinization algorithms for NWAs, that use SHAs as intermediates, work so nicely. In order to understand this, we need to investigate the relationship between NWAs and SHAs more deeply. Clearly, the NWAs obtained via SHAs do all their work in a bottom-up and left-to-right manner, and nothing when moving top-down. We can characterize the subclass of NWAs with this restricted behavior syntactically by the (weak) single-entry property: it requires that all opening rules of the NWA go into into the same target state while popping the sources state onto the stack. Note that our single-entry property is weaker than the (multi-module) single-entry property studied previously <ref type="bibr" target="#b23">[22]</ref><ref type="bibr" target="#b24">[23]</ref><ref type="bibr" target="#b26">[24]</ref>, which in addition requires that the automaton can be split into at least 2 modules, one for the top level and one for the nested level. The NWAs obtained by compilation from SHAs all have the (weak) single-entry property (but not necessarily multiple modules). So when compiling NWAs to SHAs and back, the resulting NWAs also have the (weak) single-entry property. It seems that the usual determinization algorithm from NWAs is well-behaved when applied to NWAs with the (weak) single-entry property. The relationship between SHAs and (weak) single-entry NWAs seems sufficiently close, so that their determinization algorithms seem to operate in a somehow similar manners.</p><p>It is known that the subclass of deterministic multi-module single-entry NWAs (also called call driven automata) enjoys unique minimization <ref type="bibr" target="#b23">[22,</ref><ref type="bibr" target="#b24">23]</ref>. The separation of the module for the top level from the module for the nested level can be obtained w.l.o.g., by building a product with the NWA with 2 hedge states that distinguishes the two levels. In our application, minimization could thus be used to reduce the size of the deterministic NWAs produced by our four algorithms for converting NREs, with the hope to eventually obtain a unique outcome after minimization. However, since we will use some symbolic representations for sets of rules, the uniqueness will hold only for the non-symbolic counterpart. In any case, the number of states of the deterministic minimal NWAs obtained for the same NRE could be expected to become unique.</p><p>Motivated by our application, we found it more relevant to minimize deterministic SHAs rather than deterministic (weak) single-entry NWAs (despite of their close correspondence). As for the class of deterministic (weak) single-entry NWAs, a restriction is needed for the class of deterministic SHAs to obtain unique minimization. We could have required the existence of multiple modules as for multi-module single-entry NWAs. Instead we restrict ourselves to deterministic SHAs for which the initial states for trees and hedges coincide. We then show that minimization for such SHAs can be reduced to the minimization of tree automata up to a novel encoding of hedges to binary trees.</p><p>We implemented all 4 algorithms for compiling our benchmark NREs to deterministic NWAs and report the experimental results. We have also implemented the novel minimization algorithm for SHAs with equal tree and hedge initial states, and used it in our experiments. We propose two further optimization methods for reducing the sizes of the constructed automata. First, we introduce schema-based cleaning both for SHAs and NWAs. In our application, the schema expresses the XML data model, stating that hedges must encode valid XML documents. More generally, an automaton A can be cleaned relatively to an automaton S for the schema, if the language of interest is the intersection L(A) ∩ L(S) rather than L(A) itself. The idea of schema-based cleaning is to keep only those transition rules of A that are used to recognize some hedge of L(S). These transition rules can be computed from the product of A and S. It should be noticed that schema-based cleaning may change the language of the automaton. Only the intersection L(A) ∩ L(S) is preserved, not necessarily L(A).</p><p>Second we propose a symbolic representations for SHAs based on apply-else rules. They help to represent more compactly a large number of apply rules produced by the determinization of SHAs. Before compiling SHAs to NWAs, however, we need to eliminate the apply-else rules. This is because we have not developed analogous symbolic representations for NWAs so far. A second limitation is that we have not not implemented any minimization algorithm for NWAs at the time being.</p><p>The main improvement of this journal article compared with the conference version <ref type="bibr" target="#b27">[25]</ref> is the addition of the minimization algorithm for the subclass of SHAs with equal tree and hedge initial states. Furthermore, we added the idea of schema-based cleaning and the symbolic representations for SHAs by apply-else rules. The experimental results were enhanced with minimization, symbolic representations of rules, and schema-based cleaning. All the nested regular expressions generated for the XPathMark benchmark queries that we consider, as well as their corresponding automata -when we could produce them -can be found at http://researchers.lille.inria.fr/niehren/complementarymaterial. Related Work. In the present article, we restrict ourselves to nested words over signatures with a single opening parenthesis, a single closing parenthesis, and possibly many internal letters a, b. This permits us to simplify the presentation of nested regular expressions, the notions of NWAs and SHAs, their forth and back compilers, but also the determinization algorithms. Note that any multi-module NWA for such signatures must have exactly 2 modules. From an application perspective, multiple parentheses can be encoded by using internal letters, that is a named opening parenthesis a by the word a • and a named closing parenthesis b by the word b • . When encoding XML documents as nested words, such some encoding is needed anyway in order to deal with the complex information in XML tags, and also to provide symbolic representations with else rules that are able to deal with infinite signatures.</p><p>For the minimization of deterministic NWAs, general signatures with multiple parentheses raise additional problems. Chervet and Walukiewicz <ref type="bibr" target="#b24">[23]</ref> solved such problems by reducing the minimization for expanded CDAs to the minimization of CDAs. Gauwin, Muscholl and Raskin <ref type="bibr" target="#b26">[24]</ref> showed that the minimization for deterministic NWAs is NP-hard in the case with general signatures. Their approach is based on a reduction from the problem of minimal immersion for sequences of DFAs, for which they construct NWAs with an unbounded number of opening parenthesis and an unbounded number of entry states. Weak single-entry NWAs in our setting do not permit this. Neither do NWAs over fixed general signatures with a finite number of opening parenthesis. Navigational XPath queries on XML documents can be formalized in the language CoreXPath <ref type="bibr" target="#b29">[26]</ref>, or more generally by nested regular path queries <ref type="bibr" target="#b30">[27]</ref> on data trees. Nested regular path queries  were introduced earlier under the name of the propositional dynamic logic (PDL) in the seventies <ref type="bibr" target="#b31">[28]</ref>,</p><formula xml:id="formula_0">doc• elem • site• elem • closed_auctions• elem • closed_auction• elem • date • 0 • 1 • / • 0 • 1 • / • 2 • 0 • 0 • 0 elem • keyword • w • i • n • e •</formula><p>where they are applied to labeled graphs, that generalize on data trees. Since certain query answering for XPath was considered difficult, the currently existing approaches to XPath query evaluation on XML streams <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b19">18]</ref> either approximate certain query answers based on nondeterministic machines or restrict the queries so that answer certainty can be decided without latency <ref type="bibr" target="#b16">[15,</ref><ref type="bibr" target="#b32">29]</ref>. This also holds for recent streaming algorithms on words without nesting in the context of complex event processing <ref type="bibr" target="#b34">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Nested Words</head><p>Nested words are words with parentheses that are well-nested. They can be identified with hedges, that is sequences of internal symbols and unranked trees.</p><p>Nested words are constructed with opening and closing parentheses, respectively and . An unranked alphabet Σ is a possibly infinite set of so called "internal" symbols, that does not contain the two parentheses. The set of nested words over Σ is denoted N Σ and is defined by the following abstract syntax:</p><formula xml:id="formula_1">h, h ∈ N Σ ::= ε | a | h | h • h where a ∈ Σ</formula><p>The empty nested word is denoted by ε and assumed to be the neutral element of the composition</p><formula xml:id="formula_2">operator ε • h = h = h • ε, which furthermore is assumed to be associative, i.e., h 1 • (h 2 • h 3 ) = (h 1 • h 2 ) • h 3 .</formula><p>Nested words can be identified with hedges, i.e. words of trees and internal symbols. Seen as a graph, the inner nodes are labeled by the tree constructor and the leaves by symbols in Σ or the tree constructor. For instance a • b • ε • c • d • ε corresponds to the hedge in Figure <ref type="figure">1</ref>. A nested word of type tree has the form h . Variants. Our notion of nested words accepts only well-nested words without dangling opening or closing parentheses in contrast to others <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b5">5]</ref>. This will lead to simpler notion of regular expressions, avoiding the more complex operators as with visibly rational expressions <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b36">31]</ref>. A less important difference is that we do not support labeled parentheses. Labeled unranked trees. Labeled parentheses can be simulated by using internal letters. For instance, the labeled tree a(b(), c()) can be represented by the nested word of type tree a • b • c . In this way, the labeled tree a() is represented by the nested word a which is of type tree (while the internal letter a alone is not). Unranked sequences of subtrees, often called hedges and sometimes forests, can be composed by using the sequence operator.</p><formula xml:id="formula_3">doc • ¬x• elem • site • ¬x• elem • closed_auctions • ¬x• elem • closed_auction • ¬x• elem • date • x • 0 • 1 • / • 0 • 1 • / • 2 • 0 • 0 • 0 elem • keyword • ¬x • w • i • n • e •</formula><p>XML Documents. Our notion of nested words is sufficiently powerful to express general XML documents. An example of an XML document is given in Figure <ref type="figure">2</ref> and the representing nested word in Figure <ref type="figure" target="#fig_1">3</ref>.</p><p>We use the names of XML elements as labels of the nested word, as well as the letters of UTF8 for the string data values. Further labels such as doc and elem are added to express the types of the XML data model document and element respectively.</p><p>When it comes to querying for nodes in XML documents, we will be interested in nested words encoding XML documents, in which a unique node is marked. We will use the label x to mark the selected node and the label ¬x for all others. When marking the date in the XML document of Figure <ref type="figure">2</ref>, we obtain the nested word in Figure <ref type="figure" target="#fig_2">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Nested Regular Expressions</head><p>We present nested regular expressions (NREs), that were introduced under the name regular expression types in the context of XDuce <ref type="bibr" target="#b10">[10]</ref> up to minor details. Note that similar nested regular expressions for ranked trees are folklore in the context of tree automata <ref type="bibr" target="#b37">[32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Syntax and Semantics</head><p>Let the alphabet Σ be a set. An NRE over Σ is a term describing a language of nested words. It has the following abstract syntax where a ∈ Σ:</p><formula xml:id="formula_4">E, E ::= ε | a | _ | ∅ | E • E | E + E | E&amp;E | E * | E | E | µa.E</formula><p>The µa.E expressions are the same as in µ-calculus <ref type="bibr" target="#b38">[33]</ref>, except that we restrict them such that all occurrences of a in E are nested below parentheses. Otherwise nonregular languages could be defined such as with µa. (b • a • c + ε) whose language would be {b n • c n | n ∈ N}. We also forbid intersections and complements in expression µa.E on all paths between the µa-operator and the occurrences of a in E that are bound by this operator. The expressions µa.E allow for vertical recursion, while the expressions with the Kleene star E * support horizontal recursion.</p><p>Our syntax allows for conjunctions E&amp;E and negations E, which are well known to not add expressiveness if Σ is finite. They are still relevant from the viewpoints of modeling, and for the treatment of infinite signatures. This comes at the price of increasing the complexity, as for the well-known case of words <ref type="bibr" target="#b39">[34]</ref>.</p><p>For infinite signatures, we can define for any finite subset Σ of labels the language of single-letter words Σ \ Σ by some NRE. This can be seen as follows. If Σ = ∅, then the expression _ does the job: it matches exactly the set of all labels in Σ. And if Σ is nonempty then we can use negation. For instance if Σ = {a, b} then the expression a + b&amp;_ describes the language Σ \ Σ .</p><p>The sets of free and bound letters fn(E) and bn(E) are defined as usual. The only binder µa.E binds the symbol a with scope E. Note that f n(_) = ∅.</p><p>There are three differences with respect to the regular expression types from <ref type="bibr" target="#b10">[10]</ref>. First, our NREs treat labels as internal symbols instead of labels of parentheses. Second, they provide recursion through the µ-operator instead of using recursive equation systems. Third, conjunctions and general negations are not considered there.</p><p>Any NRE E describes a language L(E) of nested words that we define by induction on the structure of E as follows: N Σ is the set of nested words over Σ, as defined in Section 2.</p><formula xml:id="formula_5">L(ε) = {ε} L(a) = {a} L(_) = Σ L(E • E ) = L(E) • L(E ) L(E) = N Σ \ L(E) L(E + E ) = L(E) ∪ L(E ) L(E&amp;E ) = L(E) ∩ L(E ) L( E ) = { h | h ∈ L(E)} L(µa.E) = ∪ n≥0 L(µ n a.E) L(E * ) = L(E) * L(∅) = ∅</formula><p>For all expressions E, E 1 and E 2 , the notation E[E 1 /E 2 ] stands for the expression E where all the occurrences of E 1 have been replaced by E 2 . The semantics of a µ-operator is then defined using the shortcuts</p><formula xml:id="formula_6">µ 0 a.E = E[a/∅] and µ n a.E = E[a/µ n-1 a.E] for all n ≥ 1. In particular L(µa._) = L(_) = Σ, so that a ∈ L(µa._). The semantics of the complement expression L(E) is the complement of L(E) in the set of all nested words, that is N Σ \ L(E).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">XPATH Example</head><p>We now show how to express navigational XPATH queries by NREs that are restricted to forward axis. The idea is to adapt the spirit of a generate-and-test algorithm for query answering. The generation produces a nested word from XML documents by guessing a single node and marking it by x. This node is a candidate for a query answer that is to be tested. The test is done by a NRE.</p><p>For expressing XPATH queries with child and descendant-or-self axes we will use the following NREs where a ∈ fn(E):</p><formula xml:id="formula_7">T = df µa. ( a + _) * ch(E) = df T • E • T ch * (E) = df µa. (E + ch(a)) ch + (E) = df µa. (ch(E) + ch(a))</formula><p>For instance, consider the XPATH query A5 from the XPathMark benchmark <ref type="bibr" target="#b18">[17]</ref>:</p><p>/site/closed_auctions/closed_auction[descendant::keyword]/date Applied to the above XML document, it selects all date children of closed_auctions nodes that contain at least one keyword descendant. Query A5 can be compiled to the following NRE, which will accept the nested word in Figure <ref type="figure" target="#fig_2">4</ref> in particular:</p><formula xml:id="formula_8">doc • _ • elem • site • _ • ch(elem • closed_auctions • _ • ch( elem • closed_auction • _ • (ch + (elem • keyword • _ • T) &amp; ch(elem • date • x • T))))</formula><p>The only label that the expression _ may match on a document that is properly annotated with the variable x will be the letter ¬x ∈ Σ. The label x is annotated to the marked node, which is tested for  being selected by the query. The label ¬x is annotated to all other nodes beside of the unique x-marked node.</p><p>Note also that the µ-operator of the ch + (. . .)-expression expresses the recursion of the descendant axis. Furthermore, the conjunction permits us to connect the main path of A5 with its only filter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">XPath Benchmark</head><p>For testing NREs, we rely on the usual XPathMark benchmark <ref type="bibr" target="#b18">[17]</ref>. We restrict ourselves to navigational path queries with forward axis: child, descendant, and following-sibling. We notice that the following axis is excluded in contrast to following-sibling, since following is not strictly forwards. We can also admit path composition and filters with conjunction, disjunction and negation.</p><p>The XPATH queries of the benchmark satisfying these restrictions are the queries A1, . . . , A8 and B3 given in Figure <ref type="figure" target="#fig_3">5</ref>. We developed a more general compiler from navigational forward XPATH queries to NREs, which yields the NREs in Figure <ref type="figure">A1</ref> of the appendix for the benchmark XPATH queries. The NREs for A1-A3 do have neither conjunctions nor negations, while the queries A4-A8 contain filters, which are mapped to conjunctions in NREs. The compiler uses the µ-operator to capture the recursion of descendant axis as in A2, A3, and A5. Furthermore, nondeterminism is introduced by disjunctions in filters as in A7 and A8. Conjunction in filters appears in A6 which is mapped to conjunctions in NREs too. A detailed description of this compiler is not in the scope of the present article though.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Nested Word Automata</head><p>Nested word automata (NWAs) are pushdown automata reading nested words, whose stacks are visible: they push a single stack symbol when reading an opening parenthesis, pop a single stack symbol when reading a closing parenthesis, and do not alter or inspect the stack otherwise. <ref type="figure">Σ,</ref><ref type="figure">Γ,</ref><ref type="figure">∆,</ref><ref type="figure">I,</ref><ref type="figure">F</ref>) consisting of a possibly infinite set Σ of internal symbols, finite sets Q h and Q t of states of type hedge and tree respectively, sets of initial and final states I, F ⊆ Q h , a finite set Γ of stack symbols, and a finite set ∆ of transition rules of the forms:</p><formula xml:id="formula_9">Definition 1. An NWA is a tuple A = (Q h , Q t ,</formula><formula xml:id="formula_10">hedge rules a ∆ , _ ∆ , ε ∆ ⊆ Q h × Q h where a ∈ Σ opening rules ∆ γ ⊆ Q h × Q h where γ ∈ Γ tree rules T ∆ ⊆ Q h × Q t closing rules ∆ γ ⊆ Q t × Q h</formula><p>Our NWAs are symbolic, in that they come with else rules, i.e elements of (q, q ) ∈ _ ∆ that we will denote by q _ -→ q , for dealing with large or infinite alphabets. An example for an NWA is given in a graphical syntax in Figure <ref type="figure" target="#fig_4">6</ref>. Tree states are drawn in circles that are filled in light gray q , while hedge states are in unfilled circles q . Initial states are drawn as → q and final states as q . Hedge rules that have the form (q 1 , q 2 ) ∈ o ∆ where o ∈ Σ ∪ {_, ε} are denoted by q 1 o -→ q 2 , while any tree rule (q 1 , q 2 ) ∈ T ∆ is denoted q 1 -→ q 2 . Opening rules (q 1 , q 2 ) ∈ ∆ γ are represented as q 1 ↓γ --q 2 and closing rules (q 1 , q 2 ) ∈ ∆ γ as q 1 ↑γ --q 2 . Our notion of NWAs supports factorization in the spirit of <ref type="bibr" target="#b40">[35]</ref>. It is obtained by distinguishing two types of states q ∈ Q h and p ∈ Q t , and adding explicit type coercion rules q -→ p. Semantically, both kinds of states could be merged when replacing the type coercion rules by the epsilon rule q ε -→ p, but at the cost of introducing additional nondeterminism. This may lead to quadratically larger deterministic automata, as we will illustrate at the NWA in Figure <ref type="figure" target="#fig_11">20</ref>.</p><p>The language of nested words between two states q 1 , q 2 ∈ Q h is defined as the least language such that:</p><formula xml:id="formula_11">L q 1 ,q 2 (∆) = {ε | if q 1 = q 2 or q 1 ε -→ q 2 ∈ ∆} ∪ q 3 ∈Q h L q 1 ,q 3 (∆) • L q 3 ,q 2 (∆) ∪ {a | if q 1 a -→ q 2 ∈ ∆ or (q 1 _ -→ q 2 ∈ ∆ and ¬∃q 2 . q 1 a -→ q 2 ∈ ∆)} ∪ { h | ∃q 1 , q 2 ∈ Q h .∃q 3 ∈ Q t .∃γ ∈ Γ. q 1 ↓γ ---q 1 , h ∈ L q 1 ,q 2 (∆), q 2 -→ q 3 ∈ ∆ and q 3 ↑γ ---q 2 ∈ ∆}.</formula><p>The language of the NWA then is L(A) = q 1 ∈I,q 2 ∈F L q 1 ,q 2 (∆).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Determinization of NWAs</head><p>Determinization for NWAs was first studied by von Braunmühl and Verbeek <ref type="bibr" target="#b2">[2]</ref> in the eighties, where NWAs are named input driven pushdown automata. We notice that the determinization algorithm was published only in the journal version of this paper, but not in the conference version. Later on, the same algorithm was rediscovered in the context of visibly pushdown automata and republished for nested word automata.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2. An NWA A is called deterministic or equivalently a dNWA if</head><p>• I contains at most one element,</p><p>• there is no epsilon rule, i.e., ε ∆ = ∅, • a ∆ and _ ∆ are partial functions from Q h to Q h for all a ∈ Σ, and T ∆ is a partial function from Q h to Q t , • for all q ∈ Q h and γ ∈ Γ there exists a most one q ∈ Q h such that q ∈ ∆ γ , Proposition 1 (von Braunmühl and Verbeek <ref type="bibr" target="#b2">[2]</ref>). A NWA with n states can be determinized in time O(2 n 2 ).</p><formula xml:id="formula_12">• ∆ γ is a partial function from Q t to Q h for all γ ∈ Γ. 0 1 1 ↓ γ 0 _ ↓ γ 1 ↑ γ 1 _ ↑ γ 0</formula><p>Many of our results are based on the determinization algorithm going back to von Braunmühl and Verbeek. For self-containedness, we recall the version of this algorithm that we will use in the Appendix A. For illustrations, the determinization of the NWA in Figure <ref type="figure" target="#fig_4">6</ref> is also presented here too, see Figure <ref type="figure">A2</ref>. It has size 271 while the nondeterministic NWA has size 39 (12 states + 2 letters + 3 stack symbols + 22 rules). The blow-up is even worse in general as our experimental results will show and as noticed earlier by <ref type="bibr" target="#b19">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Multi-module NWAs</head><p>Multi-module NWAs will play a prominent rôle for our NWA constructions and are relevant for minimization <ref type="bibr" target="#b24">[23]</ref>. For signatures with a single opening parenthesis, each multi-module NWAs has exactly two modules, one for the top level and one for the nested level.</p><p>We can define multi-module NWAs based on the natural notion of homomorphisms for NWAs. A homomorphism from an NWA A to an NWA A with the same signature is a triple of functions</p><formula xml:id="formula_13">(α h : Q h → Q h , α t : Q t → Q t , β : Γ → Γ ) that</formula><p>maps all concepts of A to the corresponding concepts of A . These concepts are hedge initial states, final states, opening, closing, internal, and tree transitions. We do not enforce the preservation of epsilon rules by homomorphisms. Definition 3. A multi-module NWA A is an NWA for which there exists a homomorphism from A to the NWA T in Figure <ref type="figure" target="#fig_5">7</ref>.</p><p>The NWA T evaluates all top level positions of a nested word to state 0, all those positions that are not between parentheses. All nested positions are evaluated to state 1. The homomorphism of a multi-module NWA A to T thus partitions the states of A between those that can be assigned to top level positions, and the others that can be assigned to nested positions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Compilation of NREs to NWAs</head><p>We next discuss a compiler from NREs E to NWAs nwa(E). This compiler extends on the McNaughton-Yamada-Thompson algorithm <ref type="bibr" target="#b41">[36]</ref> for regular expressions, which introduces epsilon edges for constructing the automata of composition E • E .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 1. For any NRE E we can construct an NWA A such that L(A) = L(E). If E contains neither conjunctions nor negations, then the construction is in time O(|E|).</head><p>Proof sketch. Conjunctions E&amp;E are compiled to products of automata, so repeated conjunctions may lead to an exponential blow up. Negations E are computed by complementing automata based on determinization. Each complementation may lead to an exponential blow-up, so when this is repeated, the construction may become non-elementary.</p><p>For expressions without conjunction and negation, no such blow-up may arise. As stated by the theorem, we have to show that expressions can be compiled in linear time.</p><p>Case E = E • E : We use the McNaughton-Yamada-Thompson algorithm for composing the NWAs of nwa(E ) and nwa(E ).</p><formula xml:id="formula_14">q 0 q 1 q 2 q 3 ↓ γ a ↑ γ Figure 8.</formula><p>Automaton for the a * expression.</p><formula xml:id="formula_15">q 0 q 1 q 2 q 3 ↓ γ ↑ γ ε ε Figure 9.</formula><p>Wrong naive construction for µa. a * (q 0 , 1) (q 1 , 1) (q 2 , 1 ) (q 3 , 1)</p><formula xml:id="formula_16">(q 0 , 0) (q 3 , 0) ↓ (γ, γ 1 ) ↑ (γ, γ 1 ) a ↓ (γ, γ 0 ) ↑ (γ, γ 0 )</formula><p>Figure <ref type="figure">10</ref>. The multi-module NWA for a * .</p><p>(q 0 , 1) (q 1 , 1) (q 2 , 1 ) (q 3 , 1)</p><formula xml:id="formula_17">(q 0 , 0) (q 3 , 0) ↓ (γ, γ 1 ) ↑ (γ, γ 1 ) ε ε ↓ (γ, γ 0 ) ↑ (γ, γ 0 ) Figure 11.</formula><p>The correctly adapted naive construction for µa. a * Case E = E : Let Q h , Q t and Γ be respectively the set of hedge states, tree states and stack symbols of nwa(E ). We consider new hedge states q i and q f that are not in Q h , a new tree state p not in Q t and a new stack symbol γ not in Γ . Then nwa(E) is constructed by adding to nwa(E ) opening rules q i ↓γ --q for all the initial states q of nwa(E ), tree rules q -→ p for all the final states q of nwa(E ) and a closing rule p ↑γ --q f . Furthermore we set q i as the only initial state of nwa(E), and q f as its sole final state. Case E = µa.E : Special care has to be given to repeat expression µa.E. First of all, the naive compilation approach for these expression turns out to be wrong. And second, fixing the problem in the simplest possible manner does not lead to a linear time algorithm.</p><p>Note that we can assume w.l.o.g. that a occurs at most once in E by using the golden lemma of the µ-calculus <ref type="bibr" target="#b42">[37]</ref>, stating for all names a 1 , . . . , a n and expressions E in which a 1 , . . . , a n can appear free that µa 1 . . . . .µa n . E ≡ µa.E [a 1 /a, . . . , a n /a]. Our construction guarantees that all transitions of the form q a -→ q in nwa(E) will start with the same state q. The wrong naive construction would remove the transitions q a -→ q from nwa(E) and add ε-rules from q to all the initial states of nwa(E), and from all final states of nwa(E) to q . Unfortunately, the construction is not correct. For illustration, we consider the NRE E = µa. a * . The reader should be warned that constructing an NWA for E is less trivial than it might seem at first sight. One has to start from the NWA for a * which is given in Figure <ref type="figure">10</ref>. Simply adding epsilon edges to capture the operator µa will not work though. It will lead to the wrong automaton in Figure <ref type="figure">9</ref>. This automaton will wrongly accept the hedge , since this hedge does not belong to L(E).</p><p>If the NWA for E is multi-module, then the naive construction of compiling µa.E can be made correct. So the simplest fix is to make the NWA multi-moduled, before applying the naive construction. This can be achieved by typing the states of the automaton, by states of the NWA T in Figure <ref type="figure" target="#fig_5">7</ref>. The added types yield the homomorphism of the constructed automaton to T .</p><p>The naive algorithm is then adapted as follows. Let P be the multi-module NWA obtained from the product of nwa(E) and T . Note that we keep only the accessible top level states (type 0), but all nested states (type 1). In our example this yields the NWA in Figure <ref type="figure">11</ref>. We then remove transition (q, 1) a -→ (q , 1) and add ε-rules from state (q, 1) to all states in I × {1}, and from all states in F × {1} to (q , 2), where I and F are respectively the set of initial and final states of nwa(E). Then P recognizes L(µa.E). The result obtained in the example is shown in Figure <ref type="figure">11</ref>.</p><p>The algorithm described so far makes the NWA multi-moduled before compiling a µ-operator. For this, two copies of all states are introduced. This, however, could lead to an exponential construction, if multiple µ-operators are nested. This problem can be avoided by preserving multi-moduledness as an invariant. Whenever a new state is created, it is created twice, once for the top level and once for the nested level. This information is maintained by typing the states, so that no further copies of the same state are produced later on. We omit the correctness proof of this construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Experimental Results Starting with the NWA Compiler</head><p>In the first two column of Figure <ref type="figure" target="#fig_0">12</ref>, we report the sizes of the NWAs obtained from NREs by our compiler, and the size of the deterministic NWAs produced thereof. For each automaton we give its total size and in parentheses the number of states.</p><p>The sizes of the nondeterministic NWAs produced by the compiler for the NREs for A1-A8 and B3 are given in column nwa(.) of Figure <ref type="figure" target="#fig_0">12</ref>. Note that the NWAs are cleaned so that only accessible and co-accessible states remain. The sizes of the nondeterministic NWAs are acceptable for all NREs, except for A8 for which the NWA has more than 3000 states and an overall size greater than 10000.</p><p>This can be partially explained by the fact that the NRE for A8 contains 3 conjunctions (1 for the filter and 2 for the conjunctions in the filter). But still, the number of states remains surprising.</p><p>The determinized NWAs are given in column det(nwa(.)). It turns out that only A2 and A3 could be determinized successfully with some few hours of computation time on a standard laptop. But even in the successful cases, the resulting deterministic NWAs are simply huge. This confirms similar problems first noticed in <ref type="bibr" target="#b19">[18]</ref> and not solved since then.</p><p>The remaining columns of Figure <ref type="figure" target="#fig_0">12</ref> based on the back-and-forth compiler from SHAs to NWAs from the following Section 6. They show that better determinization algorithms can indeed be obtained, yielding NWAs of acceptable size for all benchmark queries, with the exception of A8. The idea of det(nwa(step(nwa(.))) is to compile the NWAs obtained from the NREs to stepwise hedge automata and back before applying the above algorithm for NWAs. This might be surprising, since this determinization algorithm failed for the original NWAs, while it now proves successful on the forth-and-back transformed NWAs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Stepwise Hedge Automata</head><p>We propose SHAs as an extension of stepwise tree automata <ref type="bibr" target="#b22">[21]</ref> that allows to recognize not only unranked trees but also hedges. We avoid more classical hedge automata from <ref type="bibr" target="#b9">[9]</ref> that were already introduced in 1967 by Thatcher <ref type="bibr" target="#b8">[8]</ref>, since their notion of determinism is problematic. For instance it makes unique minimization fail <ref type="bibr" target="#b43">[38]</ref> and universality hard.</p><p>Our notion of SHAs will be symbolic in using else rules, and factorized in the sense of <ref type="bibr" target="#b40">[35]</ref>: there are two types of states for hedges and trees and an operator for explicit type coercion. We also propose a novel treatment of internal letters inspired by nested word automata, so that SHAs generalize both on stepwise tree automata and on NFAs. Definition 4. A SHA is a tuple A = (Q h , Q t , Σ, ∆, I, F) such that Q t and Q h are finite sets of states of two types t for tree and respectively h for hedge, Σ an alphabet of internal letters (that may be infinite), I, F ⊆ Q h are subsets of hedge initial and final states respectively, and ∆ is a finite set of transition rules such that for all q ∈ Q t and a ∈ Σ:</p><formula xml:id="formula_18">hedge rules q ∆ , a ∆ , _ ∆ , ε ∆ ⊆ Q h × Q h tree final rules T ∆ ⊆ Q h × Q t tree initial states ∆ ⊆ Q h</formula><p>An example for a SHA is given in graphical syntax in Figure <ref type="figure" target="#fig_6">13</ref>. It recognizes all hedges which are either just a or b or contain some tree node that contains either just a or b. In the graphical syntax, the states of type tree q ∈ Q t are drawn in circles filled in light gray q , while the states of type hedge q ∈ Q h are drawn in unfilled circles q . The right part of the graph is an NFA which uses tree states as additional edge labels, while the left part is a stepwise tree automaton, that defines the tree languages of these tree states.</p><p>Let ∆ h be the restriction of ∆ to the hedge rules. Then, (Q h , Σ Q t , ∆ h , I, F) is a standard NFA with ε-rules, which is symbolic <ref type="bibr" target="#b44">[39]</ref> in providing else rules for dealing with large or infinite alphabets in addition. Therefore, we denote the hedge initial states q ∈ I by h -→ q and the final states q ∈ F by q . A rule with an internal letter (q 1 , q 2 ) ∈ a ∆ is denoted by q 1 a -→ q 2 ∈ ∆ stating that a hedge in state q 1 can be extended by the internal letter a leading to a hedge in state q 2 . Similarly, an epsilon rule (q 1 , q 2 ) ∈ ε ∆ is denoted by q 1 ε -→ q 2 , and an else rule (q 1 , q 2 ) ∈ _ ∆ is denoted by q 1 _ -→ q 2 . In the same spirit, a hedge rule (q 1 , q 2 ) ∈ q ∆ -also called apply rule -is denoted by q 1 q --q 2 ∈ ∆, stating that a hedge in state q 1 can be extended by a tree in state q leading to a hedge in state q 2 . A tree initial state q ∈ ∆ is graphically denoted by t -→ q and a tree final rule (q 1 , q 2 ) ∈ T ∆ by q 1 -→ q 2 . Intuitively, a tree h can be evaluated to state q if h can be evaluated starting with some tree initial state q 1 ∈ ∆ to some state q 2 such that q 2 -→ q ∈ ∆. More formally, the hedge languages L q 1 ,q 2 (A) between any two hedge states q 1 , q 2 ∈ Q h are defined as follows:</p><formula xml:id="formula_19">L q 1 ,q 2 (A) = {ε | if q 1 = q 2 or q 1 ε -→ q 2 ∈ ∆} ∪ q 3 ∈Q h L q 1 ,q 3 (A) • L q 3 ,q 2 (A) ∪ {a | if q 1 a -→ q 2 ∈ ∆ or (q 1 _ -→ q 2 ∈ ∆ and ¬∃q 2 . q 1 a -→ q 2 ∈ ∆)} ∪ q 1 q ---q 2 ∈∆ L q (A)</formula><p>This definition is mutually recursive with the definition of the tree languages L q (A) of all tree states q ∈ Q t :</p><formula xml:id="formula_20">L q (A) = { h | t -→q 1 ∈ ∆, h ∈ L q 1 ,q 2 (A), q 2 -→ q ∈ ∆}</formula><p>The hedge language L(A) that is recognized by the automaton is q 1 ∈I,q 2 ∈F L q 1 ,q 2 (S). The rules of standard bottom-up tree automata have the form a(q 1 , . . . , q n ) → q where a is a symbol of arity n. With SHAs, this rule can be encoded by the sequence</p><formula xml:id="formula_21">t -→p 0 a -→ p 1 q 1 ---. . . q n</formula><p>--p n -→ q where the states q 1 , . . . , q n , q are all tree states, and p 0 , . . . , p n new hedge states. </p><formula xml:id="formula_22">Q 1 ⊆ Q h P ⊆ Q t Q 2 = {q 2 | ∃q 1 ∈ Q 1 , p ∈ P. q 1 p ---q 2 ∈ ∆} Q 1 P ---ε ∆ * (Q 2 ) ∈ ∆ det Q 1 ⊆ Q h a ∈ lab(Q 1 ) Q 2 = {q 2 | ∃q 1 ∈ Q 1 , q 1 a -→ q 2 ∈ ∆} Q 2 = {q 2 | ∃q 1 ∈ Q 1 . q 1 _ -→ q 2 ∈ ∆ and ∃q 3 ∈ Q.q 1 a -→ q 3 ∈ ∆} Q 1 a -→ ε ∆ * (Q 2 ∪ Q 2 ) ∈ ∆ det Q 1 ⊆ Q h Q 2 = {q 2 | ∃q 1 ∈ Q 1 , q 1 -→ q 2 ∈ ∆} Q 1 -→ ε ∆ * (Q 2 ) ∈ ∆ det Q 2 = {q 2 | ∃q 1 ∈ Q 1 , q 1 _ -→ q 2 ∈ ∆} Q 1 _ -→ ε ∆ * (Q 2 ) ∈ ∆ det</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Determinization of SHAs</head><p>We formalize the notion of determinism for stepwise hedge automata and show how determinization works. Definition 5. A SHA (Q h , Q t , Σ, ∆, I, F) is deterministic or equivalently a dSHA, if it satisfies the following conditions:</p><p>• I contains at most one element,</p><p>• ∆ contains at most one element, • there is no epsilon transition, i.e., ε ∆ = ∅, • a ∆ , q ∆ , _ ∆ are partial functions from Q h to Q h for all a ∈ Σ and q ∈ Q t , and</p><formula xml:id="formula_23">• T ∆ is a partial function from Q h to Q t .</formula><p>Proposition 2. A SHA of size n can be made deterministic in time O(2 n ) while preserving the hedge language.</p><p>Proof. The determinization procedure for SHAs combines the determinization algorithms of word and tree automata in the natural manner, while eliminating epsilon transitions. Let ε ∆ * be the reflexive and transitive closure of ε ∆ , and for any subset</p><formula xml:id="formula_24">Q ⊆ Q h ∪ Q t let ε ∆ * (Q) = q∈Q ε ∆ * (q). Given a SHA A = (Q h , Q t , Σ, ∆, I, F), we define an equivalent deterministic SHA det(A) = (Q det h , Q det t , Σ, ∆ det , I det , F det ) such that Q det h = 2 Q h , Q det t = 2 Q t , I det = {ε ∆ * (I)} and F det = {Q ⊆ Q h | Q ∩ F = ∅}.</formula><p>There is a unique tree initial state in ∆ det = {ε ∆ * ( ∆ )} and no ε-rule, that is ε ∆ det = ∅. The inference rules in Figure <ref type="figure" target="#fig_7">14</ref> define the missing part of ∆ det . We can show for all</p><formula xml:id="formula_25">Q 1 , Q 2 ⊆ Q h and P ⊆ Q t that L Q 1 ,Q 2 (det(S)) = q 1 ∈Q 1 ,q 2 ∈Q 2 L q 1 ,q 2 (S) so that L P (det(S)) = q ∈Q L q (S). Hence L(det(S)) = Q ∈F det L I,Q (det(S)</formula><p>) and thus L(det(S)) = q 1 ∈I,q 2 ∈F L q 1 ,q 2 (S) = L(S).</p><p>For illustration, the deterministic SHA in Figure <ref type="figure" target="#fig_8">15</ref> is obtained by determinization of the SHA in Figure <ref type="figure" target="#fig_6">13</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Compilation of NREs to SHAs</head><p>As for NWAs, we introduce the notion of multi-module SHAs for which the sets of hedge states are partitioned between those that can evaluate top level positions and those to which nested positions are assigned. So multi-module SHAs will have exactly two modules too. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 6.</head><formula xml:id="formula_26">A SHA A = (Q h , Q t , Σ, ∆, I, F) is a multi-module SHA if there is a subset of states Q 0 h ⊆ Q h ,</formula><p>that we call top level states, such that:</p><formula xml:id="formula_27">• I ⊆ Q 0 h • the states in Q 0 h can reach only other states in Q 0 h via ∆.</formula><p>For instance, consider the multi-module SHA in Figure <ref type="figure" target="#fig_6">13</ref>. The states of module for the top level are Q 0 = {1, 2, 3, 4, 5, 6, 12}. The others belong to the module for the nested level.</p><p>Any NRE E can be compiled to a multi-module</p><formula xml:id="formula_28">SHA step(E) = (Q h , Q t , Σ, ∆, I, F) such that Q t = {E | E = E subexpression of E} and L t (E ) = L(E ) for all tree states E ∈ Q t . The SHA step(E) can be partitioned into disjoint SHAs step(E) = A top ∪ E ∈Q t A E such that A top = (Q top h , Q t , Σ, ∆ top , I, F) and A E = (Q E h , Q t , Σ, ∆ E , ∅, ∅) for all E ∈ Q t and ∆ top = ∅.</formula><p>Note that the transitions relation ∆ is decomposed thereby into independent connected components. The automaton A top can be identified with an NFA with signature Σ ∪ Q t given that it has no tree initial states. The automata A E are stepwise tree automata that recognize the tree language L(E ) when taking E as final state. For this, they may have tree initial states, but will not have any initial nor final states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. For any NRE E we can construct a SHA A such that L(A) = L(E). If E contains neither conjunctions nor negations, then the construction is in time O(|E|).</head><p>Proof sketch. For the case of expressions with conjunctions or negations, the construction is analogous to the way it is done for NWAs. We next sketch the construction of SHAs for expressions without conjunction and negation. <ref type="bibr" target="#b41">[36]</ref> for composing the multi-module NFAs of step(E ) and step(E ). The stepwise tree automata A E of the subexpressions of type tree are preserved. For succinctness, if some subexpression E occurs more than once, then only a single copy of A E is kept. References to states of the removed copy should be renamed to their equivalent counterparts. Case E = E : We construct step(E) from step(E ). The initial states of step(E ) are turned into tree initial states. We then add a new tree state E and connect it to all final states of step(E ) by a tree final rule q -→ E . Furthermore, the previously final state q becomes non final. Finally we add a new initial state q i , a new final state q f and a transition rule h -→q i E --q f . Case E = µa.E : The main idea of the construction is similar to the case of NWAs. The correctness argument relies on the invariant that only multi-module SHAs are built.</p><formula xml:id="formula_29">Case E = E • E : We use McNaughton-Yamada-Thompson algorithm</formula><p>Again by the golden lemma of the µ-calculus, we can assume w.l.o.g. that a occurs at most once in E . By using ε-rules, we can preserve the invariant that there will be at most one pair (q, q ) such that q a -→ q in step(E ). Furthermore, these transitions cannot be on top level, given that the occurrence of a in E must be nested below parentheses. The automaton step(E) is obtained from step(E ) by first copying the top level NFA of step(E ), as in Figure <ref type="figure" target="#fig_4">16</ref>. We thus obtain two versions for each state of the top level NFA of step(E ): one referred to as the top level copy -q 0,0 q 0,0 q 3,0 q 0,1 q 3,1</p><formula xml:id="formula_30">q 1,1 q 2,1 h t q 2,1 q 2,1 a Figure 16</formula><p>. SHA for a * q 0,0 q 3,0 q 0,1 q 3,1  and q 3,0 in Figure <ref type="figure" target="#fig_4">16</ref> -, and another one as the nested level -q 0,1 and q 3,1 in Figure <ref type="figure" target="#fig_4">16</ref>. Only top level states may be initial or final. Then we add ε-rules from q to the nested states that correspond to the initial states of step(E ), and from the nested states corresponding to the final states of step(E ) to q . Finally we remove the rule q a -→ q .</p><formula xml:id="formula_31">q 1,1 q 2,1 h t q 2,1 q 2,</formula><p>Note that every transition added for a state -top level or nested -in a subsequent step of the construction -except the ε-rules added for µ-expressions -must also be added for its copy.</p><p>The construction is correct since the µ-bound name a is nested below parenthesis in E . Therefore, it can be shown that the ε-edges introduced cannot be used to produce unwanted order in successful runs. That this invariant can be maintained in polynomial time requires an additional argument. Instead of copying the top level parts of subexpressions, each state is introduced twice during the construction: one version for nesting, and another one for being part of top level parts. This way the size of the automaton is not doubled at each step, but only once.</p><p>We omit the correctness proof of this construction.</p><p>Unlike NWAs, one cannot preserve the determinism of the expressions of nregexp(ch, T) in SHAs, even with Glushkov-like constructions. For instance, for the deterministic NRE a 1 • a 2 • . . . • a n . . . , one would have an SHA having a tree initial state for each of the a i . . . subtree, implying nondeterminism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Experimental Results Starting with the SHA Compiler</head><p>In the first two column of Figure <ref type="figure" target="#fig_9">18</ref>, we report the size of the SHAs obtained from NREs by our compiler, and the size of the deterministic SHAs produced thereof.</p><p>The SHA compiler yields automata of acceptable size from the NREs of all benchmark queries. These sizes are given in the first column step(.) of Figure <ref type="figure" target="#fig_9">18</ref>. This even holds for A8, in contrast to the case where the produced SHA has overall size 1106 and 267 states.</p><p>The determinization of the SHAs in the second column det(step(.)) even yields smaller automata in all cases. For A8 we obtain a deterministic stepwise automaton of overall size 749 and with 123 states. This might be surprising, in that the determinization algorithm may lead to an exponential blow-up in the worst case. But it may also clean the automaton, keeping only accessible sets of states. This is what seems to happen systematically on the benchmark with the exception of A2, where the size goes up by a factor of four and A5 where the size doubles. For A2 the number of states grows by one third, while for A5 it decreases by one third.</p><p>Based on the back-and-forth compiler from SHAs to NWAs from following Section 6, we can obtain deterministic NWAs of acceptable size for all benchmark queries. The method nwa(det(step(.))) yield for A a dNWA of size 2831 and with 124 states. The alternative method det(nwa(step(.))) yields a dNWA of size 2520 which is even smaller, and the same number of states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">NWAs versus SHAs</head><p>We next show how to compile SHAs to NWAs such that determinism is preserved, and back while introducing nondeterminism. Thereby we can obtain small NWAs for NREs such as E = ch * (a + b) for which det(nwa(E)) blew up in size in a surprising manner (see Figure <ref type="figure" target="#fig_0">12</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">SHAs to NWAs</head><p>As a first step, we introduce a transformation on SHAs, so that for any SHA A:</p><formula xml:id="formula_32">• if A is deterministic, the transformation returns A,</formula><p>• if A is nondeterministic with set of hedge states Q h and transition relation ∆, the transformation returns a new SHA A with set of hedge states Q h = Q h {q t-init } where q t-init is a new hedge state, and set of transitions ∆ which equals</p><formula xml:id="formula_33">∆ except that ∆ = {q t-init } and ε ∆ = ε ∆ ∪ {(q t-init , q) | q ∈ ∆ }.</formula><p>Then we compile any SHA A = (Q h , Q t , Σ, ∆, I, F) obtained after the above transformation to an NWA nwa</p><formula xml:id="formula_34">(A) = (Q h , Q t , Σ, Γ, ∆ , I, F) such that L(A) = L(nwa(A)). We set Γ = Q h , _ ∆ = _ ∆ , a ∆ = a ∆ for all a ∈ Σ, ε ∆ = ε ∆ , T ∆ = T ∆ : q 1 ↓q 2 ---∈ ∆ p ∈ ∆ q 1 ↓q 1 ---p ∈ ∆ and q ↑q 1 ---q 2 ∈ ∆</formula><p>Clearly, if S is deterministic then so is nwa(S), since p is unique in this case in particular. One might be tempted to skip the first-step transformation and restrict the above construction rule to states p such that L q (S[ ∆ /{p}]) = ∅. However, this would lead to a huge blow-up when determinizing these NWAs, basically since this change spoils the single-entry property discussed in Definition 7.</p><p>The conversion of step(ch * (a + b)) in Figure <ref type="figure" target="#fig_6">13</ref> yields the NWA in Figure <ref type="figure" target="#fig_10">19</ref>. Note that the opening rules are deterministic (but not the whole NWA), since for all tree states q there is at most one hedge state p with → p such that q is accessible from p. The NWA has size 64, while its determinization has size 159 (see Figure <ref type="figure" target="#fig_17">A4</ref> of the appendix). The size increase raised by determinization is thus 95 = 159 -64 for this NWA.</p><p>The size increase for determinization is considerably smaller for the NWA obtained from the regular expressions by indirection via a SHA than for NWAs obtained by direct compilation. Indeed, the determinization of nwa(ch * (a + b)) blows the size from 39 to 271. The size increase for the determinization of nwa(ch * (a + b)) is thus 242 = 271 -39 while for nwa(step(ch * (a + b))) it is only 95 = 159 -64.</p><p>The experiments will show that this is not an exception but the general rule. Intuitively, the reason is that NWAs obtained from SHAs do all the work bottom-up, where NWAs obtained directly from the regular expression do a considerable amount of work top-down. In terms of <ref type="bibr" target="#b23">[22]</ref> this restriction can be characterized syntactically by the single-entry property:  Definition 7. A (weak) single-entry NWA A = (Q h , Q t , Σ, Γ, ∆, I, F) is a NWA for which there exists a single state q entry ∈ Q h such that all opening rules in ∆ have the form q ↓q --q entry . Note that call driven automata (CDAs) discussed in <ref type="bibr" target="#b24">[23]</ref> coincide with multi-module single-entry dNWAs and also with (multi-module) single-entry visibly pushdown automata <ref type="bibr" target="#b23">[22,</ref><ref type="bibr" target="#b26">24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>555</head><p>It can be shown that nwa(S) has the (weak) single-entry property for all SHAs S for which the p's are unique in the above construction rule, i.e. such that ∆ = {p}. Note that this wasn't the case for step(ch * (a + b)) in Figure <ref type="figure" target="#fig_6">13</ref> but could have been imposed w.l.o.g. leading to a slightly different NWA than in Figure <ref type="figure" target="#fig_10">19</ref>.</p><p>The conversion of the determinization det(step(ch * (a + b))) in Figure <ref type="figure" target="#fig_8">15</ref> yields the deterministic 560 NWA in Figure <ref type="figure" target="#fig_11">20</ref>. The size goes up slightly from 53 to 73. It should be noticed that factorization avoids a quadratic blow up in this case. This can be observed at state 14, which has 3 incoming tree-edges and 10 outgoing closing edges. Without factorization, the 3 tree edges could be replaced by 3 ε-edges  whose elimination would produce 30 closing edges. This would increase the number 3 + 10 edges to 3 * 10 edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">NWAs to SHAs</head><p>Conversely, NWAs can be compiled to stepwise hedge automata, but at the cost of introducing nondeterminism, since an NWA may traverse the branches of a tree top-down, while a stepwise must traverse them bottom-up. For this, the stepwise guesses the state in which the NWA will arrive from above and then evaluates the subtree starting with this state, while verifying the correctness of the guess</p><formula xml:id="formula_35">later on. Let A = (Q h , Q t , Σ, ∆ , I, F) be an NWA. We build a SHA step(A) = (Q s h , Q s t , Σ, ∆ s , I s , F s ) where Q s h = Q h × Q h , Q s t = Q h × Q t , I s = {(q, q) | q ∈ I}, F s = I × F and ∆ s is the smallest satisfying the following rules: o ∈ Σ ∪ {_, ε} q 1 o -→ q 2 ∈ ∆ q ∈ Q h (q, q 1 ) o -→ (q, q 2 ) ∈ ∆ s q 1 -→ q 2 ∈ ∆ q ∈ Q h (q, q 1 ) -→ (q, q 2 ) ∈ ∆ s q 1 ↓γ ---q 2 ∈ ∆ (q 2 , q 2 ) ∈ ∆ s q 1 ↓γ ---q 2 ∈ ∆ q 3 ∈ Q t q 3 ↑γ ---q 4 ∈ ∆ q ∈ Q h (q, q 1 ) (q 2 ,q 3 ) ---→ (q, q 4 ) ∈ ∆ s</formula><p>The construction is such that L(A) = L(step(A)). For the NWA nwa(ch * (a + b)) in Figure <ref type="figure" target="#fig_4">6</ref> we obtain the stepwise in Figure <ref type="figure" target="#fig_16">A3</ref> up-to removing useless states and separating the top level. Determinization yields det(step(nwa(ch * (a + b)) = det(step(ch * (a + b))) in Figure <ref type="figure" target="#fig_8">15</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Optimizations</head><p>We will use three optimization methods for constructing smaller dSHAs and thus smaller dNWAs: minimization, symbolic representations of sets of transition rules, and schema-based cleaning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Minimization</head><p>Our next objective is to reduce the size of deterministic SHAs by developing a minimization algorithm for a subclass of dSHAs. Even though our implementation can deal with them, we consider SHAs without symbolic rules q --→ q for simplicity in this section. We start with an example that motivates the choice of our subclass. In Figures <ref type="figure" target="#fig_12">21</ref> and<ref type="figure" target="#fig_13">22</ref> two dSHAs are given that both recognize the language of all hedges with signature Σ = {x, y} containing exactly one occurrence of the letter x. The dSHA in Figure <ref type="figure" target="#fig_13">22</ref> is the dSHA recognizing this language which has the minimal number of states. The dSHA in Figure <ref type="figure" target="#fig_12">21</ref> is the minimal multi-module dSHA for this language. The question is how a minimization algorithm for dSHAs could convert the dSHA in Figure <ref type="figure" target="#fig_12">21</ref> to this minimal one in Figure <ref type="figure" target="#fig_13">22</ref>. In particular, why would it fusion the tree initial state and the hedge initial state? We do not see how this could be done based on some Myhill-Nerode-like equivalence relation. This motivates an a priori restriction to dSHAs imposing that the tree initial state and hedge initial state must be equal.</p><p>Note that any SHA can be converted into a dSHA with equal tree and hedge initial states. For this it is sufficient to "fusion" these states and then to determinize the SHA obtained. When doing so for the dSHA in Figure <ref type="figure" target="#fig_12">21</ref>, we indeed obtain the minimal dSHA from Figure <ref type="figure" target="#fig_14">24</ref>, so no further minimization is needed in this case.</p><p>Given the close relationship between SHAs and weak single-entry NWAs; it is instrutive to consider the existing results on minimization for dNWAs. It is known that the class of general dNWAs does not allow for unique minimization <ref type="bibr" target="#b23">[22]</ref> and that the minimization becomes NP-hard when admitting general signatures with multiple parenthesis <ref type="bibr" target="#b26">[24]</ref>.</p><p>On the positive side, the best existing minimization algorithm is due to Chervet and Walukiewicz <ref type="bibr" target="#b24">[23]</ref>. It applies to the subclass of multi-module single-entry dNWAs, called there call driven automata (CDA) 1 . They showed that the subclass of multi-module single-entry dNWAs enjoys unique minimization in polynomial time.</p><p>In the case of dSHAs, we believe that unique minimization holds for the following two subclasses, and will show it for the second:</p><p>• the subclass of multi-module dSHAs, and • the subclass of dSHAs where the hedge and tree initial state are the same, i.e., ∆ = I.</p><p>The first subclass of multi-module dSHAs is motivated by the subclass of multi-module single-entry dNWAs. Note however, that the SHAs that are obtained by compilation from single-entry dNWAs need not to be deterministic, so the analogy between both automata classes is not perfect. The dSHA in Figure <ref type="figure" target="#fig_12">21</ref> is minimal for the class of multi-module dSHAs.</p><p>The second subclass of dSHAs corresponds to the subclass of single-entry dNWAs in which the single-entry state is equal to the initial state. The dSHA in Figure <ref type="figure" target="#fig_13">22</ref> is minimal for the second subclass. In the remainder of this section, we present a minimization algorithm for the second subclass. For this, we identify dSHAs in which tree and hedge initial state coincide with two-sorted deterministic tree automata, so that we can use a minimization algorithm for the latter. Our automaton translation is based on a novel encoding of hedges into ranked well-sorted trees with monadic and binary function xssymbols, which is inspired by the previous binary encoding of unranked trees known from stepwise tree automata <ref type="bibr" target="#b22">[21]</ref>. For any unranked signature Σ, as for the construction of hedges, we consider two sort h for hedges and t for trees. We then consider the following ranked signature with these two sorts:</p><formula xml:id="formula_36">Σ @ = {a (h) | a ∈ Σ} ∪ {@ (h×t→h) , ε (h) , T (h→t) }</formula><p>The well-sorted trees over Σ @ of both sorts then have the following abstract syntax: well-sorted trees of sort h: τ ::= a(τ) | @(τ, τ ) | ε well-sorted trees of sort t:</p><p>τ ::= T(τ)</p><p>Any hedge over Σ can be encoded into a ranked well-sorted tree of sort h with signature Σ @ . For instance, the hedge:</p><formula xml:id="formula_37">h = a • b • c • d • e • f 1</formula><p>Chervet and Walukiewicz <ref type="bibr" target="#b24">[23]</ref> permit signatures with multiple opening parenthesis. In the case of a single opening parenthesis, the class of CDAs is equal to their subclass of expanded CDAs for which they develop their minimization algorithm in the first place.</p><p>step @ _ D(.)=det(step @ _(.)) S(.)=schema-clean(D(.)) M(.)=mini(S(.)) elim @ _(M(.)) nwa(M(.)) is encoded into the following ranked well-sorted tree of sort h over Σ @ :</p><formula xml:id="formula_38">A1</formula><p>[[h]] = ε@T( f (a(ε)@τ )) where τ = T(b(ε)@τ ) and τ = T(e(d(c(ε))))</p><p>Any SHA A = (Q h , Q t , Σ, ∆, I, F) with equal tree and hedge initial states, that is ∆ = I, can then be encoded into a two sorted tree automaton [[A]] = (Q h , Q t , Σ @ , ∆ , I, F) by mapping the transition rules in ∆ to those in ∆ as follows: ∆ ∆ q a -→ q a(q) → q q -→ p T(q) → p q p --q q@p → q q i ∈ ∆ = I ε → q i</p><p>We can first note that [[L(A)]] = L([[A]]). Second, the translation function is a bijection between SHAs over Σ and two-sorted tree automata over Σ @ . Furthermore, this translation preserves determinism.</p><p>It follows that if A is a dSHA with a minimal number of states recognizing L(A) then [[A]] is a deterministic two-sorted tree automaton with a minimal number of states recognizing [[L(A)]].</p><p>Furthermore, the unique minimization of deterministic two-sorted tree automata implies the unique minimization of the class of dSHAs with equal tree and hedge initial states. Using this translation back and forth, we can thus lift the minimization algorithm of deterministic two-sorted tree automata to a minimization algorithm for the subclass of dSHAs with equal tree and hedge initial states. This is the minimization algorithm for dSHAs that we have implemented. We then used it in our constructions to reduce the size of the dSHAs obtained by determinization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Symbolic SHAs with Apply-Else Rules</head><p>The sizes of the dSHAs constructed so far are dominated by the number of transitions. We now propose a class of symbolic dSHAs by adding apply-else rules, in order to represent large numbers of apply rules in a more compact and symbolic manner. An apply-else rule has the form q _ --q where q, q ∈ Q h . It represents the set of apply rules q p --q , where p ∈ Q t can be chosen arbitrarily from a subset of tree states distinguished by the automaton.</p><p>We have also adapted our determinization for dSHAs so that it preserves apply-else rules. What is missing so far is a concept for NWAs that corresponds to the apply-else rules of dSHAs. Therefore, we have to eliminate apply-else rules before translating SHAs to NWAs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Schema-Based Cleaning</head><p>Automata for XPATH queries recognize nested words that can be obtained by encoding XML documents with a single x-marked position. The class of such nested words is characterized by a  schema that we can define as the intersection of the two dSHAs in Figure <ref type="figure" target="#fig_14">24</ref> and Figure <ref type="figure" target="#fig_15">25</ref>. The first SHA tests whether there is exactly one occurrence of the internal letter x, and the second one tests that the XML data model is satisfied, and the node annotations with x and ¬x are put at the right positions.</p><p>The automata constructed for the XPATH queries may accept some trees that do not satisfy the schema (but will never be evaluated on such trees when answering the query). The idea of schema-based cleaning is to remove all transition rules and states that are not used for recognizing any nested word satisfying the schema. Schema-based cleaning of an automaton can be performed by constructing the product of the automaton with the schema, which is in our case an intersection of two dSHAs. We then only keep those states of the original SHA that are used in accessible and co-accessible states of the product with the schema. It should be noticed that schema-based cleaning typically changes the language of the automaton. Different languages may be obtained when cleaning different automata for the same query with respect to the schema. If one is interested in a unique language, then one can choose the intersection of the automaton with the schema. This intersection, however, is usually larger than the automaton obtained by schema-based cleaning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.">Experimental Results for Optimizations</head><p>The sizes of optimized automata for the benchmark queries are reported in Figure <ref type="figure" target="#fig_1">23</ref>. The function step @ _ used in the first column compiles NREs to SHAs with apply-else rules. This does not change the number of states, but reduces the number of automata transitions. In the case of A8 the size of the stepwise automaton is reduced from 1106 to 894.</p><p>An optimized determinizer is applied by the function D(.) = det(step @ _(.)) in the second column. It preserves apply-else rules in particular. For A8, the size is reduced from 749 to 639 while the number of states is preserved.</p><p>Schema-based cleaning is applied by the function S(.) = schemaclean(D(.)) in the third column.</p><p>For A8 the number of rules is reduced further from 639 to 527. Minimization is applied by the function M(.) = mini(S(.)) in the fourth column. In the case of A8 it reduces the number of states from 117 to 101 and the size from 527 to 487.</p><p>In order to come back to dNWAs, we have to eliminate the apply-else rules in column six. For A8 this increases the number of rules back from 527 to 1257.</p><p>In the final column, we apply the compiler from SHAs to NWAs which preserves determinism. For A8 this results in a dNWA of size 1413 and 102 states. This is better than the previous results, in particular with respect to the number of states. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Summary of Experimental Results</head><p>We now plug the different compilers and optimization methods all together and compare the sizes of deterministic NWAs that we can obtain thereby. The overall sizes (#states) of the resulting dNWAs are given in Figure <ref type="figure" target="#fig_4">26</ref>. We see that the two methods starting with SHAs nwa(det(step(.))) and det(nwa(step(.))) yield reasonably small deterministic NWAs for the NREs of all benchmark queries. The methods starting with NWAs nwa(det(step(nwa(.)))) and det(nwa(step(nwa(.)))) provide reasonably small deterministic NWAs for queries except for A8.</p><p>We also tested our algorithms on collections of XPath queries with a scalable parameter, such as the queries ch n (a) for increasing n. This series is known to require automaton with a number of states exponential in n for deterministic bottom-up evaluation. The best methods to produce deterministic NWAs in this case is nwa(det(step)). It works until n = 9, leading to an dNWA of size 134929 with 772 states. The number of states close to doubles when increasing n by 1. The second best method for producing dNWAs for the series ch n (a) works only until n = 6.</p><p>For explaining the different size of the dNWAs for the series ch n (a), we first note that no schema-based cleaning was applied in this experiment. As a consequence unique minimal single-entry dNWAs in which the single-entry state is the initial state should exist. The reason for the larger number of states with the three other methods is that we have not implemented any minimization algorithm for this subclass of single-entry dNWAs. Furthermore, our implementation of the minimization algorithm for our subclass of dSHAs failed for too big dSHAs. In this case, the number of states reported in Figure <ref type="figure" target="#fig_5">27</ref> could not be reduced to the minimum. In addition, the number of rules seems to be increased further by the lack of any symbolic representation for rules of NWAs that could mimic the apply-else rules for SHAs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Deterministic Nested Regular Expressions</head><p>We finally show how to distinguish NREs that can be evaluated deterministically in polynomial time, for instance by compilation to deterministic NWAs. For this, we consider the language of NREs nregexp(ch, T) that extends the abstract syntax of NREs by a new constant T and a new unary operator ch. Note in particular that ch(a) is a deterministic expression of nregexp(ch, T), since the child operator is added as a primitive there. In contrast, the semantically equivalent expression T. a .T is not deterministic. Similarly, T is deterministic since it is a primitive expression of nregexp(ch, T), while the equivalent expression µx.( x + _) * is nondeterministic for 3 different reasons: the µ-operator, the star * and the disjunction +. The recursive expression ch * (E) is nondeterministic: it is not primitive in nregexp(ch, T), and its definition is based on the µ-operator and disjunction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8. An expression of nregexp(ch, T) is deterministic if it does not contain a subexpression of any of the forms: E</head><formula xml:id="formula_39">1 + E 2 , E * , T • E, µa.E.</formula><p>The only query of the benchmark for which we can provide a deterministic NRE is the query A1. The NRE for query A1 in Figure <ref type="figure">A1</ref> is nondeterministic nevertheless, since we replaced ch(E) with T • E • T. This is not problematic, given that we can use a decent method for determinization of NWAs. For this reason, it does no more seem worth the effort to maintain specialized compilation methods for deterministic NREs. For the same reason, we will not present any experimental results for our specialized compiler from deterministic NREs to deterministic NWAs. Instead we use the more general compiler for general nondeterministic NREs.</p><p>The compiler from Theorem 1 introduces epsilon rules and thus, it does not preserve determinism: some deterministic NREs will be compiled to nondeterministic NWAs. This introduction of nondeterminism can be avoided by eliminating epsilon rules on the fly, that is by using Glushkov's approach rather than that of Thompson. Theorem 3. For any deterministic regular expression E of nregexp(ch, T) without conjunction and negation, we can construct in time O(|E| 2 ) a dNWA recognizing the same language.</p><p>Proof sketch. Theorem 3 uses Glushkov's construction and thus eliminates ε-edges on the fly compared to the McNaughton-Yamada-Thompson algorithm. The Glushkov construction is well-known to preserve determinism when compiling regular expressions without nesting to finite state automata <ref type="bibr" target="#b21">[20]</ref>. For the additional deterministic expressions ch(E), we adapt the deterministic compilation from <ref type="bibr" target="#b19">[18]</ref>. This quadratic time result generalizes a previous result for the Glushkov construction <ref type="bibr" target="#b20">[19]</ref> from regular expressions without conjunctions and negations to NREs without conjunctions and negations.</p><p>Small deterministic NREs without conjunction and negation can thus be compiled to small dNWAs.</p><p>On the benchmark, however, this construction can be applied to the query A1 only, so only a few queries can be covered in this manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">Conclusion and Future Work</head><p>We presented SHAs and showed how they can be used to compile NREs to deterministic NWAs. When applied to NREs for navigational XPATH queries in the usual XPathMark benchmark, we obtained reasonably small deterministic NWAs, in contrast to all previous approaches.</p><p>The dNWAs that we obtain by compilation from SHAs all have the weak single-entry property. This property means that the computation of the NWA is done in a purely bottom-up and left-to-right manner, so in the same way as by an SHA. Our experiments show that the usual determinization algorithm for NWAs is well-behaved when applied to weak single-entry NWAs, while it quickly fails without the weak single-entry property.</p><p>We have also stated a unique minimization algorithm for dSHAs with the same tree and hedge initial state. It is open whether unique minimization holds for general dSHAs. Neither do we know whether dSHA minimization is NP-hard. The analogous questions remain open for the class of weak single-entry dNWAs.</p><p>In future work, one needs to tackle the open questions on the minimization of dSHAs, weak single-entry dNWAs, and dNWAs with fixed general signatures. One has to understand, whether and why unique minimization holds or not, and whether and why minimization is hard or not. Independently, it is interesting to use SHAs in various questions in theory and practice. In particular, we want to develop new algorithms for earliest query answering for dSHAs that are more efficient than the existing algorithms for dNWAs <ref type="bibr" target="#b17">[16]</ref> and to see how they behave in practice. closure of ε ∆ . Finally, for any set Q, we write id Q to denote the binary relation that relates every element of Q to itself, that is id Q = {(q, q) ∈ Q 2 }.</p><p>We adapt the usual determinization procedure for NWAs <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b19">18]</ref> so that they can account for hedge ending and else rules. Given an NWA A = (Q h , Q t , Σ, Γ, ∆, I, F), the difficulty is to deal with concurrent opening rules q ↓γ 1 --q 1 and q ↓γ 2 --q 2 in ∆ during determinization without mixing up 855 the stack symbols γ 1 and γ 2 . Therefore, we use transition relations as states of the determinized automaton det(A) = (Q det h , Q det t , Σ, Γ det , ∆ det , I det , F det ), that is</p><formula xml:id="formula_40">Q det h = 2 Q h ×Q h , Q det t = 2 Q h ×Q t .</formula><p>The only initial state is the composition of id I with ε ∆ * , i.e., I det = {id I • ε ∆ * }. The set of final states is</p><formula xml:id="formula_41">F det = {τ ∈ Q det h | τ ∩ (I × F) = ∅}.</formula><p>Schemas generating the transition rules in ∆ det are given below.  </p><formula xml:id="formula_42">τ ∈ Q det h τ _ -→ τ • _ ∆ • ε ∆ * ∈ ∆ det τ ∈ Q det h Q = {q | ∃(_, q) ∈ τ. q ↓γ ---q ∈ ∆} τ ↓τ ---id Q • ε ∆ * ∈ ∆ det τ ∈ Q det h τ tree --→ τ • tree ∆ • ε ∆ * ∈ ∆ det τ ∈ Q det t τ ∈ Q det h τ = γ∈Γ ∆ γ • ε ∆ * • τ • ∆ γ τ ↑τ ---τ • τ • ε ∆ * ∈ ∆ det τ ∈ Q det h a ∈ lab(τ) τ = {(q, q ) ∈ _ ∆ | ∃q .q a -→ q wrt∆} τ a -→ τ • (a ∆ ∪ τ ) • ε ∆ * ∈ ∆ det</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .Figure 2 .</head><label>12</label><figDesc>Figure 1. Nested word a • b • ε • c • d • ε seen as a graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. The corresponding nested word.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. The nested word of the x-marked XML document from Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. XPath benchmark queries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Nested word automaton nwa(ch * (a + b)).</figDesc><graphic coords="10,119.66,87.89,355.95,148.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. The NWA T maps top level positions to state 0 and nested positions to 1 or 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Stepwise hedge automaton step(ch * (a + b)): the part with the stepwise tree automaton is on the left and middle, and the NFA part on the right.</figDesc><graphic coords="14,137.65,97.85,172.32,69.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Determinization of SHAs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>0Figure 15 .</head><label>15</label><figDesc>Figure 15. The determinized SHA det(step(ch * (a + b))).</figDesc><graphic coords="16,185.08,98.34,141.67,79.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 18 .</head><label>18</label><figDesc>Figure 18. The SHAs for the benchmark NREs and the automata derived thereof.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 19 .</head><label>19</label><figDesc>Figure 19. The single-entry NWA nwa(step(ch * (a + b))) obtained from the SHA.</figDesc><graphic coords="19,207.04,87.88,181.20,220.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 20 .</head><label>20</label><figDesc>Figure 20. Deterministic NWA: nwa(det(step(ch * (a + b)))).</figDesc><graphic coords="19,167.89,333.46,259.50,199.25" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 21 .</head><label>21</label><figDesc>Figure 21. A dSHA for hedges over Σ = {x, y} with single occurrence of x. It is minimal in the class of multi-module dSHAs.</figDesc><graphic coords="20,76.54,87.89,132.33,137.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 22 .</head><label>22</label><figDesc>Figure 22. An equivalent dSHA to that in Figure 21, that is minimal in the class of dSHAs with equal tree and hedge initial states.</figDesc><graphic coords="20,300.13,100.78,132.33,98.67" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 24 .</head><label>24</label><figDesc>Figure 24. A single x-marked position.</figDesc><graphic coords="23,76.54,119.43,134.97,98.67" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 25 .</head><label>25</label><figDesc>Figure 25. Nested words of x-marked XML documents.</figDesc><graphic coords="23,255.31,87.89,270.93,174.57" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure A3 .</head><label>A3</label><figDesc>Figure A3. Stepwise hedge automaton from NWA for step(nwa(ch * (a + b))).</figDesc><graphic coords="32,76.54,87.89,207.75,293.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure A4 .</head><label>A4</label><figDesc>Figure A4. Determinization of NWA from stepwise hedge automaton: det(nwa(step(ch * (a + b)))).</figDesc><graphic coords="33,153.84,163.47,287.60,517.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The size (#states) of the NWAs for the benchmark NREs and the automata derived thereof.</figDesc><table><row><cell></cell><cell>nwa(.)</cell><cell>det(nwa(.))</cell><cell cols="3">step(nwa(.)) det(nwa(step(nwa(.)))) nwa(det(step(nwa(.))))</cell></row><row><cell>A1</cell><cell>221 (68)</cell><cell>-</cell><cell>231 (88)</cell><cell>398 (37)</cell><cell>409 (37)</cell></row><row><cell>A2</cell><cell>185 (49)</cell><cell>362600 (6782)</cell><cell>224 (81)</cell><cell>4105 (148)</cell><cell>1659 (127)</cell></row><row><cell>A3</cell><cell>189 (54)</cell><cell>318704 (8216)</cell><cell>213 (79)</cell><cell>907 (62)</cell><cell>635 (56)</cell></row><row><cell>A4</cell><cell>625 (193)</cell><cell>-</cell><cell>414 (159)</cell><cell>487 (42)</cell><cell>499 (42</cell></row><row><cell>A5</cell><cell>486 (135)</cell><cell>-</cell><cell>516 (190)</cell><cell>1192 (73)</cell><cell>868 (67)</cell></row><row><cell>A6</cell><cell>2170 (653)</cell><cell>-</cell><cell>1005 (391)</cell><cell>548 (45)</cell><cell>561 (45)</cell></row><row><cell>A7</cell><cell>434 (135)</cell><cell>-</cell><cell>378 (146)</cell><cell>468 (41)</cell><cell>480 (41)</cell></row><row><cell cols="2">A8 10597 (3127)</cell><cell>-</cell><cell>21848 (7022)</cell><cell>-</cell><cell>-</cell></row><row><cell>B3</cell><cell>253 (77)</cell><cell>-</cell><cell>239 (91)</cell><cell>423 (38)</cell><cell>407 (37)</cell></row><row><cell cols="2">Figure 12.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Optimized automata for derived stepwise automata compiled from NREs.</figDesc><table><row><cell></cell><cell>133 (56)</cell><cell>145 (36)</cell><cell>106 (36)</cell><cell>106 (36)</cell><cell>234 (36)</cell><cell>268 (37)</cell></row><row><cell>A2</cell><cell>104 (41)</cell><cell>157 (30)</cell><cell>101 (30)</cell><cell>55 (16)</cell><cell>73 (16)</cell><cell>87 (17)</cell></row><row><cell>A3</cell><cell>111 (45)</cell><cell>193 (32)</cell><cell>123 (32)</cell><cell>95 (24)</cell><cell>145 (24)</cell><cell>167 (25)</cell></row><row><cell>A4</cell><cell>160 (66)</cell><cell>167 (41)</cell><cell>123 (41)</cell><cell>123 (41)</cell><cell>294 (41)</cell><cell>334 (42)</cell></row><row><cell>A5</cell><cell>179 (70)</cell><cell>387 (53)</cell><cell>274 (53)</cell><cell>274 (53)</cell><cell>580 (53)</cell><cell>650 (54)</cell></row><row><cell>A6</cell><cell>237 (90)</cell><cell>189 (44)</cell><cell>144 (44)</cell><cell>144 (44)</cell><cell>364 (44)</cell><cell>410 (45)</cell></row><row><cell>A7</cell><cell>159 (64)</cell><cell>166 (40)</cell><cell>125 (40)</cell><cell>115 (36)</cell><cell>241 (36)</cell><cell>279 (37)</cell></row><row><cell cols="2">A8 894 (267)</cell><cell>639 (117)</cell><cell>527 (117)</cell><cell>487 (101)</cell><cell>1257 (101)</cell><cell>1413 (102)</cell></row><row><cell>B3</cell><cell>139 (58)</cell><cell>135 (33)</cell><cell>102 (33)</cell><cell>96 (32)</cell><cell>200 (32)</cell><cell>228 (33)</cell></row><row><cell></cell><cell>Figure 23.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Deterministic NWAs computed with optimizations for the XPath benchmark queries. Note that different dNWAs for the same query may recognize different languages, due to schema-based cleaning with respect to the XML data model. Furthermore, our implementation of the minimization algorithm for the subclass of dSHAs worked successfully only for dSHAs with at most 200 states.</figDesc><table><row><cell></cell><cell>det(nwa(.))</cell><cell>nwa(det(</cell><cell>det(nwa(</cell><cell>nwa(det(</cell><cell>det(nwa(</cell></row><row><cell></cell><cell></cell><cell>step(.)))</cell><cell>step(.)))</cell><cell>step(nwa(.))))</cell><cell>step(nwa(.))))</cell></row><row><cell>A1</cell><cell>-</cell><cell>268 (37)</cell><cell>363 (37)</cell><cell>204 (37)</cell><cell>363 (37)</cell></row><row><cell cols="2">A2 362600 (6782)</cell><cell>87 (17)</cell><cell>3781 (142)</cell><cell>67 (17)</cell><cell>540 (51)</cell></row><row><cell cols="2">A3 318704 (8216)</cell><cell>167 (25)</cell><cell>837 (61)</cell><cell>113 (25)</cell><cell>417 (43)</cell></row><row><cell>A4</cell><cell>-</cell><cell>334 (42)</cell><cell>447 (42)</cell><cell>298 (42)</cell><cell>447 (42)</cell></row><row><cell>A5</cell><cell>-</cell><cell>650 (54)</cell><cell>1110 (72)</cell><cell>194 (34)</cell><cell>612 (54)</cell></row><row><cell>A6</cell><cell>-</cell><cell>410 (45)</cell><cell>507 (45)</cell><cell>349 (45)</cell><cell>507 (45)</cell></row><row><cell>A7</cell><cell>-</cell><cell>279 (37)</cell><cell>431 (41)</cell><cell>162 (30)</cell><cell>431(41)</cell></row><row><cell>A8</cell><cell>-</cell><cell>1413 (102)</cell><cell>2406 (124)</cell><cell>-</cell><cell>-</cell></row><row><cell>B3</cell><cell>-</cell><cell>228 (33)</cell><cell>392 (38)</cell><cell>189 (33)</cell><cell>392 (38)</cell></row><row><cell>Figure 26.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Figure<ref type="bibr" target="#b30">27</ref>. Deterministic NWAs for the queries ch n (a) where n = 0, . . . , 9: size (#states). There is no schema-based cleaning. Our implementation of the minimization algorithm was applied to all dSHA with at most 200 states, since it failed for larger dSHAs. No minimization algorithm for subclasses of single-entry dNWAs was implemented.</figDesc><table><row><cell></cell><cell>det(nwa(.))</cell><cell>nwa(det(</cell><cell>det(nwa(</cell><cell>nwa(det(</cell><cell>det(nwa(</cell></row><row><cell></cell><cell></cell><cell>step(.)))</cell><cell>step(.)))</cell><cell>step(nwa(.)))</cell><cell>step(nwa(.))))</cell></row><row><cell>ch 0 (a)</cell><cell>4 (2)</cell><cell>4 (2)</cell><cell>4 (2)</cell><cell>4 (2)</cell><cell>4 (2)</cell></row><row><cell>ch 1 (a)</cell><cell>165 (33)</cell><cell>34 (7)</cell><cell>55 (10)</cell><cell>34 (7)</cell><cell>55 (10)</cell></row><row><cell>ch 2 (a)</cell><cell>1530 (199)</cell><cell>55 (10)</cell><cell>112 (16)</cell><cell>55 (10)</cell><cell>112 (16)</cell></row><row><cell cols="2">ch 3 (a) 19828 (1281)</cell><cell>109 (16)</cell><cell>352 (32)</cell><cell>109 (16)</cell><cell>352 (32)</cell></row><row><cell>ch 4 (a)</cell><cell></cell><cell>265 (28)</cell><cell>2200 (88)</cell><cell>265 (28)</cell><cell>2200 (88)</cell></row><row><cell>ch 5 (a)</cell><cell></cell><cell>769 (52)</cell><cell>22792 (296)</cell><cell>769 (52)</cell><cell>22792 (296)</cell></row><row><cell>ch 6 (a)</cell><cell></cell><cell>2545 (100)</cell><cell>303592 (1096)</cell><cell>80369 (2148)</cell><cell></cell></row><row><cell>ch 7 (a)</cell><cell></cell><cell>9169 (196)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>ch 8 (a)</cell><cell></cell><cell>34705 (388)</cell><cell></cell><cell></cell><cell></cell></row><row><cell>ch 9 (a)</cell><cell></cell><cell>134929 (772)</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Submitted to Algorithms, pages 1 -32 www.mdpi.com/journal/algorithms</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments: It is a pleasure to thank <rs type="person">Iovka Boneva</rs> for her contributions to the conference version [25] onto which this journal article extends. We are equally grateful to <rs type="person">Antonio Al Serhali</rs> for implementing the determinization algorithm for SHAs with apply-else rules.</p></div>
			</div>			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A Determinization of NWAs</head><p>Let us first introduce some notations. For a transition τ ∈ Q h × Q h , we write lab(τ) = {a ∈ Σ | ∃(q, q ) ∈ τ, q ∈ Q.q a -→ q ∈ ∆}. Furthermore we write ε ∆ * to denote the reflexive and transitive</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix B NREs for the XPathMark Benchmark</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>860</head><p>We compiled navigational XPath queries of the XPathMark benchmark to the NREs given in Figure <ref type="figure">A1</ref>. Publisher's Note: MDPI stays neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Pebbling Moutain Ranges and its Application of DCFL-Recognition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mehlhorn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming, 7th Colloquium</title>
		<meeting><address><addrLine>Noordweijkerhout, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1980">July 14-18, 1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-10003-2_89</idno>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="422" to="435" />
			<date type="published" when="1980">1980</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Input Driven Languages are Recognized in log n Space</title>
		<author>
			<persName><forename type="first">B</forename><surname>Von Braunmühl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Verbeek</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0304-0208(08)73072-X</idno>
		<ptr target="https://doi.org/10.1016/S0304-0208(08)73072-X" />
	</analytic>
	<monogr>
		<title level="m">Topics in the Theory of Computation</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Karplnski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<publisher>North-Holland Mathematics Studies</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="1" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Marrying Words and Trees</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<imprint>
			<publisher>ACM-Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="233" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Complexity of input-driven pushdown automata</title>
		<author>
			<persName><forename type="first">A</forename><surname>Okhotin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Salomaa</surname></persName>
		</author>
		<idno type="DOI">10.1145/2636805.2636821</idno>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="47" to="67" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Visibly pushdown languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">36th ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM-Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="202" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Locating Matches of Tree Patterns in Forests</title>
		<author>
			<persName><forename type="first">A</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Technology and Theoretical Computer Science</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1530</biblScope>
			<biblScope unit="page" from="134" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Streaming Tree Automata</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Roos</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ipl.2008.08.002</idno>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="page" from="13" to="17" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Characterizing derivation trees of context-free grammars through a generalization of automata theory</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="317" to="322" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Tree Automata Techniques and Applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://tata.gforge.inria.fr" />
		<imprint>
			<date type="published" when="1997">1997. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">XDuce: A statically typed XML processing language</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hosoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<idno type="DOI">10.1145/767193.767195</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Internet Techn</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="117" to="148" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">From Regular Expressions to Nested Words: Unifying Languages and Query Execution for Relational and XML Sequences</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
		<idno type="DOI">10.14778/1920841.1920865</idno>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="150" to="161" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Visibly Pushdown Expression Effects for XML Stream Processing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pitcher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>PlanX</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SPEX: Streamed and Progressive Evaluation of XPath</title>
		<author>
			<persName><forename type="first">D</forename><surname>Olteanu</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2007.1063</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Know. Data Eng</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="934" to="949" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Streamable Fragments of Forward XPath</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Implementation and Application of Automata</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">B</forename><surname>Markhoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Caron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Champarnaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maurel</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-22256-6_2</idno>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">6807</biblScope>
			<biblScope unit="page" from="3" to="15" />
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Stream Firewalling of XML Constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jeffrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ley-Wild</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD International Conference on Management of Data</title>
		<imprint>
			<publisher>ACM-Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="487" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Earliest Query Answering for Deterministic Nested Word Automata</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th International Symposium on Fundamentals of Computer Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5699</biblScope>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Franceschet</surname></persName>
		</author>
		<ptr target="https://users.dimi.uniud.it/~massimo.franceschet/xpathmark/PTbench.html" />
		<title level="m">XPathMark Performance Test</title>
		<imprint>
			<date type="published" when="2020-10-25">2020-10-25</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Early nested word automata for XPath query answering on XML streams</title>
		<author>
			<persName><forename type="first">D</forename><surname>Debarbieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zergaoui</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2015.01.017</idno>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">578</biblScope>
			<biblScope unit="page" from="100" to="125" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Regular Expressions into Finite Automata</title>
		<author>
			<persName><forename type="first">A</forename><surname>Brüggemann-Klein</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(93)90287-4</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">120</biblScope>
			<biblScope unit="page" from="197" to="213" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">One-Unambiguous Regular Languages</title>
		<author>
			<persName><forename type="first">A</forename><surname>Brüggemann-Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">142</biblScope>
			<biblScope unit="page" from="182" to="206" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Querying Unranked Trees with Stepwise Tree Automata</title>
		<author>
			<persName><forename type="first">J</forename><surname>Carme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tommasi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th International Conference on Rewriting Techniques and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3091</biblScope>
			<biblScope unit="page" from="105" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Congruences for Visibly Pushdown Languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Viswanathan</surname></persName>
		</author>
		<idno type="DOI">10.1007/11523468_89</idno>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1102" to="1114" />
		</imprint>
	</monogr>
	<note>International Colloquium</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Minimizing Variants of Visibly Pushdown Automata</title>
		<author>
			<persName><forename type="first">P</forename><surname>Chervet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Walukiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">L</forename><surname>Kučera</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kučera</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="135" to="146" />
			<pubPlace>Berlin Heidelberg; Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Minimization of visibly pushdown automata is NP-complete</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Muscholl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Raskin</surname></persName>
		</author>
		<idno type="DOI">10.23638/LMCS-16(1:14)2020</idno>
	</analytic>
	<monogr>
		<title level="j">Log. Methods Comput. Sci</title>
		<imprint>
			<biblScope unit="page">16</biblScope>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Nested Regular Expressions Can Be Compiled to Small Deterministic Nested Word Automata</title>
		<author>
			<persName><forename type="first">I</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sakho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Science -Theory and Applications -15th International Computer Science Symposium in Russia, CSR 2020</title>
		<meeting><address><addrLine>Yekaterinburg, Russia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020-07-03">June 29 -July 3, 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Fernau</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-50026-9_12</idno>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">12159</biblScope>
			<biblScope unit="page" from="169" to="183" />
			<date type="published" when="2020">2020</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The complexity of XPath query evaluation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pichler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="179" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Querying Graph Databases with XPath</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vrgoč</surname></persName>
		</author>
		<idno type="DOI">10.1145/2448496.2448513</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Database Theory</title>
		<meeting>the 16th International Conference on Database Theory<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="129" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Propositional Dynamic Logic of Regular Programs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Ladner</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(79)90046-1</idno>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="194" to="211" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">High-performance complex event processing over XML streams</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Candan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fuxman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Candan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fuxman</surname></persName>
		</author>
		<idno type="DOI">10.1145/2213836.2213866</idno>
	</analytic>
	<monogr>
		<title level="j">ACM</title>
		<imprint>
			<biblScope unit="page" from="253" to="264" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A Formal Framework for Complex Event Processing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Grez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riveros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ugarte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd International Conference on Database Theory, ICDT 2019</title>
		<meeting><address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">March 26-28, 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Calautti</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2019.5</idno>
		<title level="m">Schloss Dagstuhl -Leibniz-Zentrum fuer Informatik</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Visibly Rational Expressions</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bozzelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sánchez</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00236-013-0190-6</idno>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="25" to="49" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Tree Automata</title>
		<author>
			<persName><forename type="first">F</forename><surname>Gécseg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steinby</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
			<publisher>Akadémiai Kiadó</publisher>
			<pubPlace>Budapest</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">A theory of programs</title>
		<author>
			<persName><forename type="first">D</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1969">1969</date>
			<pubPlace>Vienna</pubPlace>
		</imprint>
		<respStmt>
			<orgName>IBM</orgName>
		</respStmt>
	</monogr>
	<note>Unpublished manuscript</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Word Problems Requiring Exponential Time</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">J</forename><surname>Stockmeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th ACM Symp. on Theory of Computing</title>
		<meeting>5th ACM Symp. on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Efficient Inclusion Checking for Deterministic Tree Automata and XML Schemas</title>
		<author>
			<persName><forename type="first">J</forename><surname>Champavère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ic.2009.03.003</idno>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">207</biblScope>
			<biblScope unit="page" from="1181" to="1208" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers: Principles, Techniques, and Tools</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>2nd Edition</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Complete lattices and fixed-point theorems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Niwi Ński</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Rudiments of µ-calculus</title>
		<title level="s">Studies in Logic and the Foundations of Mathematics</title>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">146</biblScope>
			<biblScope unit="page" from="1" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">On the Minimization of XML-Schemas and Tree Automata for Unranked Trees</title>
		<author>
			<persName><forename type="first">W</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.jcss.2006.10.021</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Science</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="550" to="583" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>Special issue of DBPL 05</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Symbolic Visibly Pushdown Automata</title>
		<author>
			<persName><forename type="first">L</forename><surname>D'antoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification -26th International Conference, CAV 2014, Held as Part of the Vienna Summer of Logic, VSL 2014</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">July 18-22, 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bloem</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-08867-9_14</idno>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">8559</biblScope>
			<biblScope unit="page" from="209" to="225" />
			<date type="published" when="2014">2014</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
