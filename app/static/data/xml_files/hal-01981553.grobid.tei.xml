<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Linear Programs with Conjunctive Queries</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Florent</forename><surname>Capelli</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189 -CRIStAL</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicolas</forename><surname>Crosetti</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189 -CRIStAL</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189 -CRIStAL</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Ramon</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189 -CRIStAL</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Linear Programs with Conjunctive Queries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">0865136387E89C72AC59DC6169FB22AA</idno>
					<idno type="DOI">10.4230/LIPIcs</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>2012 ACM Subject Classification Computer Science</term>
					<term>Logic</term>
					<term>Databases Database queries</term>
					<term>linear programming</term>
					<term>hypergraph decomposition. Digital Object Identifier 10.4230/LIPIcs</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we study the problem of optimizing a linear program whose variables are answers to a conjunctive query. For this we propose the language LP(CQ) for specifying linear programs whose constraints and objective functions depend on the answer sets of conjunctive queries. We contribute an efficient algorithm for solving programs in a fragment of LP(CQ). The naive approach constructs a linear program having as many variables as elements in the answer set of the queries.</p><p>Our approach constructs a linear program having the same optimal value but fewer variables. This is done by exploiting the structure of the conjunctive queries using hypertree decompositions of small width to group elements of the answer set together. We illustrate the various applications of LP(CQ) programs on three examples: optimizing deliveries of resources, minimizing noise for differential privacy, and computing the s-measure of patterns in graphs as needed for data mining.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>When modeling optimization problems it often seems natural to separate the logical constraints from the relational data. This holds for linear programming with AMPL <ref type="bibr" target="#b6">[7]</ref> and for constraint programming in MiniZinc <ref type="bibr" target="#b16">[17]</ref>. It was also noticed in the context of database research, when using integer linear programming for finding optimal database repairs as proposed by Kolaitis, Pema and Tan <ref type="bibr" target="#b13">[14]</ref>, or when using linear optimization to explain the result of a database query to the user as proposed by Meliou and Suciu <ref type="bibr" target="#b15">[16]</ref>. Moreover, tools like SolveDB <ref type="bibr" target="#b20">[21]</ref> have been developed to better integrate mixed integer programming and thus linear programming into relational databases.</p><p>We also find it natural to define the relational data of linear optimization problems by database queries. For this reason, we propose the language of linear programs with conjunctive queries LP(CQ) in the present paper. The objective is to become able to specify weightings of answer sets of database queries, that optimize a linear objective function subject to linear constraints. The optimal weightings of LP(CQ) programs can be computed in a naive manner, by first answering the database queries, and then solving a linear program parametrized by the answer sets. We then approach the question -to our knowledge for the first time -of whether this can be done with lower complexity for subclasses of conjunctive queries such as the class of acyclic conjunctive queries.</p><p>As our main contribution we present a more efficient algorithm for computing the optimal value of a program in the fragment of so-called projecting LP(CQ) programs for which we also bound the hypertree width of the queries. The particular case of width 1 covers the class of acyclic conjunctive queries. By using hypertree decompositions, our algorithm is based on a factorized interpretation of any projecting LP(CQ) program over a database to a linear program without conjunctive queries. The factorized interpretation uses other linear program variables, that represent sums of the linear program variables in the naive interpretation.</p><p>The number of linear program variables in the factorized interpretation depends only on the widths of the hypertree decompositions of the queries in the LP(CQ) program, rather than on the number of query variables. In this manner, our more efficient algorithm can decrease the data complexity, i.e., the degree of the polynomial in the upper bound of the run time of the naive algorithm. With respect to the combined complexity, the special case of projecting LP(CQ) programs with bounded quantifier depth becomes tractable for acyclic conjunctive queries, while it is NP-complete in general.</p><p>We prove the correctness of the factorized interpretation with respect to the naive interpretation. For this we have to show a correspondence between weightings of answer sets on the naive interpretation, and weightings of answer sets on the factorized interpretation. This correspondence can be seen as an independent contribution as it shows that one can reconstruct a relevant weighting of the answer set of a quantifier free conjunctive query by only knowing the value of the projected weighting on the bags of the tree decomposition.</p><p>Conjunctive queries with existential quantifier are dealt with by showing that one can find an equivalent projecting LP(CQ) program using only quantifier free conjunctive queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Applications</head><p>A wide range of applications of linear programs can benefit from conjunctive queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Resource Delivery Optimization.</head><p>We consider a situation in logistics where a company received orders for specific quantities of resource objects. The objects must be produced at a factory then transported to a warehouse before being delivered to the buyer.</p><p>The objective is to fulfill every order while minimizing the overall delivery costs and respecting the production capacities of the factories as well as the storing capacities of the warehouses.</p><p>Let F be the set of factories, O the set of objects, W the set of warehouses and B the set of buyers. We consider a database D with elements in the domain</p><formula xml:id="formula_0">D = F O W B R + .</formula><p>The elements d ∈ D encoding a positive real number can be decoded back by applying the database's functions num D , yielding the positive real number num D (d) ∈ R + . The database D has four tables. The first table prod D ⊆ F × O × R + contains triples (f, o, q) stating that the factory f can produce up to q units of object o. The second table order D : B × O × R + contains triples (b, o, q) stating that the buyer b orders q units of object o. The third table store D ⊆ W × R + contains pairs (w, l) stating that the warehouse w has a storing limit of l. The fourth table route D : (F × W × R + ) ∪ (W × B × R + ) contains triples (f, w, c) stating that the transport from factory f to warehouse w costs c, and triples (w, b, c) stating that the transport from warehouse w to buyer b costs c. The query:</p><p>dlr(f, w, b, o) = ∃q.∃q .∃c∃c . prod(f, o, q) ∧ order(b, o, q ) ∧ route(f, w, c) ∧ route(w, b, c ) selects from the database D all tuples (f, w, b, o) such that the factory f can produce some objects o to be delivered to buyer b through the warehouse w. Let Q = dlr(f , w , b , o ). The questions is to determine for each of these possible deliveries the quantity of the object that should actually be sent. These quantities are modelled by the unknown weights θ α Q of the query answers α ∈ sol D (Q). For any factory f and warehouse w the sum α∈sol D (Q∧w . We use the LP(CQ) program in Figure <ref type="figure" target="#fig_1">1</ref> to describe the optimal weights that minimize the overall delivery costs. The weights depend on the interpretation of the program over the database, since D specifies the production capacities of the factories, the stocking limits of the warehouses, etc. The program has the following constraints:</p><p>-for each (f, o, q) ∈ prod D the overall quantity of object o produced by f is at most q.</p><p>-for each (b, o, q) ∈ order D the overall quantity of objects o delivered to b is at least q.</p><p>-for each (w, l) ∈ store D the overall quantity of objects stored in w is at most l.</p><p>F. Capelli, N. Crosetti, J. Niehren and J. Ramon By answering the query Q on the database D and introducing a linear program variable θ α Q for each of the query answers α, we can interpret the LP(CQ) program in Figure <ref type="figure" target="#fig_1">1</ref> as a linear program. However the number of answers of Q and thus the number of variables in this program could be cubic in the size of the database, which quickly grows too big.</p><formula xml:id="formula_1">XX:3 minimize (f,w,c):route(f,w,c) num(c) weight (f ,w ,b ,o ):f . =f ∧w . =w (Q) + (w,b,c):route(w,b,c) num(c) weight (f ,w ,b ,o ):w . =w∧b . =b (Q) subject to ∀(f, o, q):prod(f, o, q). weight (f ,w ,b ,o ):f . =f ∧o . =o (Q) ≤ num(q) ∀(b, o, q):order(b, o, q). weight (f ,w ,b ,o ):b . =b∧o . =o (Q) ≥ num(q) ∀(w, l):store(w, l). weight (f ,w ,b ,o ):w . =w (Q) ≤ num(l)</formula><p>Our factorized interpretation for the projecting LP(CQ) program in Figure <ref type="figure" target="#fig_1">1</ref> produces a linear program that only has a quadratic number of variables, since query Q has a hypertree decomposition of width 2 as well as the whole LP(CQ) program.</p><p>Minimizing Noise for ε-Differential Privacy. The strategy of differential privacy is to add noise to the relational data before publication. Roughly speaking, the general objective of ε-differential privacy <ref type="bibr" target="#b4">[5]</ref> is to add as little noise as possible, without disclosing more than an ε amount of information. We illustrate this with the example of a set of hospitals which publish medical studies aggregating results of tests on patients, which are to be kept confidential. We consider the problem of how to compute the optimal amount of noise to be added to each separate piece of sensitive information (in terms of total utility of the studies) while guaranteeing ε-differential privacy. We show that this question can be solved (approximately) by computing the optimal solution of a projecting program in LP(CQ)</p><p>with a single conjunctive query that is acyclic, i.e., of hypertree with 1. While the naive interpretation yields a linear program with a quadratic number of variables in the size of the database, the factorized interpretation requires only a linear number. The example is worked out in Appendix A. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computing</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XX:4</head><p>Linear Programs with Conjunctive Queries</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>Our result builds on well-known techniques using dynamic programming on tree decompositions of the hypergraph of conjunctive queries. This techniques were first introduced by Yannkakis <ref type="bibr" target="#b24">[24]</ref> who observed that so-called acyclic conjunctive queries could be answered in linear time using dynamic programming on a tree whose nodes are in correspondence with the atoms of the query. Generalizations have followed in two directions: on the one hand, generalizations of acyclicity such as notions of hypertree width <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11]</ref> have been introduced and on the other hand enumeration and aggregation problems have been shown</p><p>to be tractable on these families of queries such as finding the size of the answer set <ref type="bibr" target="#b18">[19]</ref> or enumerating it with small delay <ref type="bibr" target="#b0">[1]</ref>. More recently, these tractability results have been explained by the mean of factorized databases <ref type="bibr" target="#b17">[18]</ref>, observing that the answer set of bounded width conjunctive queries could be succinctly represented by circuits enjoying interesting syntactic properties allowing to efficiently solve numerous aggregation problems on it in polynomial time in the size of the representation. While the complexity of several aggregation problems in databases have been studied on such structures <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b19">20]</ref>, our result is, to the best of our knowledge, the first one to exploit the structure of conjunctive queries to solve linear programs more efficiently. While our result could be made to work on factorized representations of queries answer sets, we choose to directly work on tree decompositions because the semantic of the query is clearer in its conjunctive form than its factorized representation.</p><p>Since one of our contribution is to offer a language to describe linear programs parametrized by the answer set of queries, this aspect is important to write intelligible linear programs.</p><p>Organization of the paper. Section 2 contains the necessary definitions to understand the paper. Section 3 presents the language LP(CQ) of linear programs parametrized by conjunctive queries and gives its semantics. Section 4 defines a fragment of LP(CQ) for which we propose a more efficient algorithm. Finally, Section 5 presents encouraging practical results on solving the delivery optimization problem using this algorithm. Due to space limit, most proofs and full details on applications to differential privacy and s-measure computation have been moved to the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Sets, Functions and Relations. Let B = {0, 1} be the set of Booleans, N the set of natural numbers including 0, R + be the set of positive reals subsuming N, and R the set of all reals.</p><p>Given any set S and n ∈ N we denote by S n the set all n-tuples over S and by S * = ∪ n∈N S n the set of all words over S. A weighting on S is a (total) function f : S → R + .</p><p>Given a set of (total) functions A ⊆ D S = {f | f : S → D} and a subset S ⊆ S, we define the set of restrictions</p><formula xml:id="formula_2">A |S = {f |S | f ∈ A}. For any binary relation R ⊆ S × S,</formula><p>we denote its transitive closure by R + ⊆ S × S and the reflexive transitive closure by</p><formula xml:id="formula_3">R * = R + ∪ {(s, s) | s ∈ S}.</formula><p>Variable assignments. We fix a countably infinite set of (query) variables X . For any set D of database elements, an assignment of (query) variables to database elements is a function α : X → D that maps elements of a finite subset of variables X ⊆ X to values of D. For any two sets of variable assignments A 1 ⊆ D X1 and A 2 ⊆ D X2 we define their join</p><formula xml:id="formula_4">A 1 A 2 = {α 1 ∪ α 2 | α 1 ∈ A 1 , α 2 ∈ A 2 , α 1|I = α 2|I } where I = X 1 ∩ X 2 .</formula><p>We also use a few vector notations. Given a vector of variables x = (x 1 , . . . , x n ) ∈ X n we denote by set(x) = {x 1 , . . . , x n } the set of the elements of x. For any variable assignment </p><formula xml:id="formula_5">Expressions E 1 , . . . , E n ∈ Ex C ::= x | a Conjunctive queries Q, Q ∈ C q Σ ::= E 1 . =E 2 | r(E 1 , . . . , E n ) | Q ∧ Q | ∃x.Q | true Figure 3</formula><p>The set of conjunctive queries C q Σ with schema Σ = ((R (n) ) n∈N , C) where x ∈ X , a ∈ C, and r ∈ R (n) . α : X → D with set(x) ⊆ X we denote the application of the assignment α on x by α(x) = (α(x 1 ), . . . , α(x n )).</p><p>Linear programs. Let Ξ be a set of linear program variables. In Figure <ref type="figure" target="#fig_3">2</ref> The formal semantics of linear programs is recalled in Figure <ref type="figure" target="#fig_1">10</ref>. Since we will only be interested in variables for positive real numbers -and do not want to impose positivity constraints all over -we restrict variables of linear programs to always be positive real numbers. For any weightings ω : Ξ → R + , the value of a sum S ∈ Sum is the real number S ω ∈ R, and the value of a constraint C ∈ Lc is the truth value C ω ∈ B. The optimal solution L ∈ R of a linear program L with objective function S and constraint C is</p><formula xml:id="formula_6">L = max{ S ω | ω : Ξ → R + , C ω = 1}.</formula><p>It is well-known that the optimal solution of a linear program can be computed in polynomial time <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rooted trees.</head><p>A digraph is a pair (V, E) with node set V and edge sets E ⊆ V × V. A digraph is acyclic if there is no v ∈ V for which (v, v) ∈ E + . For any node u ∈ V, we denote by ↓ u = {v ∈ V | (u, v) ∈ E * } the set of nodes in V reachable over some downwards path from u, and by ↑u = {v ∈ V | (v, u) ∈ E * } the set of nodes that are in the context of or equal to u. A rooted tree is an acyclic digraph where (u, v), (u , v) ∈ E implies u = u , and there exists a node r ∈ V such that V = ↓ (r). In this case, r is unique and called the root of the tree. Observe that in this tree, the paths are oriented from the root to the leaves of the tree. Conjunctive Queries. In Figure <ref type="figure">3</ref> we recall the notion of conjunctive queries on relational databases. An expression E ∈ Ex C is either a (query) variable x ∈ X or a constant a ∈ C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Relational</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XX:6 Linear Programs with Conjunctive Queries</head><p>The set of conjunctive queries Q ∈ C q Σ is built from equations E 1 . =E 2 , atoms r(E 1 , . . . , E n ), the logical operators of conjunction Q ∧ Q and existential quantification ∃x.Q. Given a vector x = (x 1 , . . . , x n ) ∈ X n and a query Q, we write ∃x.Q instead of ∃x 1 . . . . .∃x n .Q.</p><p>The set of free variables fv(Q) ⊆ X are those variables that occur in Q outside the scope of an existential quantifier. A conjunctive query Q is said to be quantifier free if it does not contain any existential quantifier.</p><p>For any conjunctive query Q ∈ C q Σ , set X ⊇ fv(Q) and database D ∈ db Σ we define the answer set sol D X (Q) in Figure <ref type="figure" target="#fig_13">11</ref>. It contains all those assignments α : X → dom(D) for which Q becomes true on D. We also write sol</p><formula xml:id="formula_7">D (Q) instead of sol D fv(Q) (Q). Observe that sol D (∃x.Q) = sol D (Q) |fv(Q)\set(x) .</formula><p>Hypertree Decompositions. Hypertree decompositions of conjunctive queries are a way of laying out the structure of a conjunctive query in a tree. It allows to solve many aggregation problems (such as checking the existence of a solution, counting or enumerating the solutions etc.) on quantifier free conjunctive queries in polynomial time where the degree of the polynomial is given by the width of the decomposition. <ref type="figure">E</ref>) is a finite directed rooted tree with edges from the root to the leaves,</p><formula xml:id="formula_8">Definition 1. Let X ⊆ X be a finite set of variables. A decomposition tree T of X is a tuple (V, E, B) such that: -(V,</formula><formula xml:id="formula_9">-the bag function B : V → 2 X maps nodes to subsets of variables in X, -for all x ∈ X the subset of nodes {u ∈ V | x ∈ B(u)} is connected in the tree (V, E), -each variable of X appears in some bag, that is u∈V B(u) = X.</formula><p>Now a hypertree decomposition of a quantifier free conjunctive query is a decomposition tree where the variables of each atom of the query is covered by at least one bag:</p><p>Definition 2 (Hypertree width of quantifier free conjunctive queries). Let Q ∈ C q Σ be a quantifier free conjunctive query. A generalized hypertree decomposition of Q is a decomposition tree T = (V, E, B) of fv(Q) such that for each atom r(x) of Q there is a vertex u ∈ V such that set(x) ⊆ B(u). The width of T with respect to Q is the minimal number k such that every bag of T can be covered by the variables of k atoms of Q. The generalized hypertree width of a query Q is the minimal width of a tree decomposition of Q.</p><p>We call a conjunctive query α-acyclic if it has general hypertree width 1. The query r(x, y) ∧ r(y, z) has the generalized hypertree decomposition (V, E, B) with V = {1, 2, 3},</p><formula xml:id="formula_10">E = {(1, 2), (1, 3)}, and B = [1/{x}, 2/{x, y}, 3/{y, z}] of width 1, so it is α-acyclic.</formula><p>Many problems can be solved efficiently on conjunctive queries having a small hypertree width. We will mainly be interested in the problem of efficiently computing sol D (Q).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3 (Folklore). Given a tree decomposition</head><formula xml:id="formula_11">T = (V, E, B) of a quantifier free conjunctive query Q ∈ C q Σ of width k and a database D ∈ db Σ , one can compute the collection of bag projections (sol D (Q) |B(u) ) u∈V in time O((|D| k log(|D|)) • |T |).</formula><p>Lemma 3 is folklore and can be proven by computing the semi-join of every bag in a subtree in a bottom-up fashion, as it is done in <ref type="bibr" target="#b14">[15,</ref><ref type="bibr">Theorem 6.25</ref>]. It gives a superset S u of sol D (Q)| B(u) for every u. Then, with a second top-down phase, one can remove tuples from</p><formula xml:id="formula_12">S u that cannot be extended to a solution of sol D (Q). Note that if Q contains n atoms, sol D (Q) may be of size O(|D| n ) whereas (sol D (Q) |B(u) ) u∈V , that has size O(|D| k • |T |)</formula><p>where k is the width of T . In the particular case of α-acyclic conjunctive queries, where n = 1, the overall size of the projections is linear. It gives a succinct way of describing the set of solutions of Q that we exploit in this paper.</p><p>Parts of our result will be easier to describe on so-called normalized decomposition trees:</p><p>F. Capelli, N. Crosetti, J. Niehren and J. Ramon XX:7</p><formula xml:id="formula_13">Constant numbers N ∈ Num C ::= c | num(E) Linear sums S, S ∈ Sum Σ ::= weight x:Q (Q) | x:Q S | N S | S + S | N Linear constraints C, C ∈ Lc Σ ::= S ≤ S | C ∧ C | true | ∀x:Q.C Linear programs L ∈ Lp Σ ::= maximize S subject to C where fv(S) = fv(C) = ∅. Figure 4 LP(CQ) programs L ∈ Lp Σ where c ∈ R, E ∈ ExC, x ∈ X * and Q, Q ∈ C q Σ .</formula><p>Definition 4. Let T = (V, E, B) be a decomposition tree. We call a node u ∈ V of T :</p><p>-an extend node if it has a single child u and B(u</p><formula xml:id="formula_14">) = B(u ) ∪ {x} for some x ∈ X \ B(u ), -a project node if it has a single child u and B(u) = B(u ) \ {x} for some x ∈ X \ B(u), -a join node if it has k ≥ 1 children u 1 , ..., u k with B(u) = B(u 1 ) = ... = B(u k ).</formula><p>We call T normalized if all its nodes in V are either extend nodes, project nodes, join nodes, or leaves. <ref type="foot" target="#foot_0">1</ref>It is well-known that tree decompositions can always be normalized without changing the width. Thus normalization does not change the asymptotic complexity of the algorithms.</p><p>Lemma 5 (Lemma of 13.1.2 of <ref type="bibr" target="#b12">[13]</ref>). For every tree decomposition of T = (V, E, B) of</p><formula xml:id="formula_15">Q of width k, there exists a normalized tree decomposition T = (V , E , B ) having width k.</formula><p>Moreover, one can compute T from T in polynomial time.</p><p>3 Linear Programs with Conjunctive Queries</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Syntax</head><p>We want to assign weights to the answers of a conjunctive query on a database, such that they maximize a linear objective function subject to linear constraints. For this, we introduce the language LP(CQ) of linear programs with conjunctive queries that we also call linear C q-programs. Its syntax is given in Figure <ref type="figure">4</ref>. Note that an example of an LP(CQ) program for optimal warehouse selection was already given in Figure <ref type="figure" target="#fig_1">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LP(CQ)</head><p>programs are interpreted as linear programs whose variables describe the solutions of conjunctive queries. As a consequence, they do not contain any explicit linear program variables. Instead, they may contain weight expressions weight Beside weight expressions, linear sums in Sum Σ may also contain expression N ∈ Num C</p><formula xml:id="formula_16">x:Q (Q) over conjunctive queries Q, Q ∈ C q Σ .</formula><p>or N S where S ∈ Sum Σ and N is a constant number expression, which is either a real number</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XX:8</head><p>Linear Programs with Conjunctive Queries LP(CQ) programs or equivalently linear C q-programs L ∈ Lp Σ are build from linear sums in Sum Σ and linear constraints in Lp Σ as one might expect. Note, however, that free query variables are ruled out at this level, while being permitted in nested linear constraints in Lc Σ and linear sums in Sum Σ .</p><formula xml:id="formula_17">fv(c) = ∅ fv(num(E)) = fv(E) fv(weight x:Q (Q)) = fv(Q) ∪ fv(Q ) \ set(x) fv( x:Q S) = fv(S) ∪ fv(Q) \ set(x) fv(N S) = fv(N ) ∪ fv(S) fv(S ≤ S ) = fv(S) ∪ fv(S ) fv(S + S ) = fv(S) ∪ fv(S ) fv(C ∧ C ) = fv(C) ∪ fv(C ) fv(∀x:Q. C) = fv(Q) ∪ fv(C) \ {x} fv(true) = ∅ fv(maximize S subject to C) = ∅</formula><p>The sets of free variables of linear sums, constraints, and programs are formally defined in Figure <ref type="figure" target="#fig_7">5</ref>. For instance, the following linear constraint C from the warehouse example has three free variables in fv(C) = {f, o, q}:</p><formula xml:id="formula_18">weight (f ,w ,b ,o ):f . =f ∧o . =o (dlr(f , w , b , o )) ≤ num(q)</formula><p>The variables f , w , b , o are bound by the weight expression. The free variables f, o, q are bound by a quantifier in the context, which in the resource delivery example is the universal quantifier ∀(f, o, q):prod(f, o, q).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Semantics</head><p>We next define the semantics of a LP(CQ) program L ∈ Lp Σ with respect to a database D ∈ db Σ with real numbers by an interpretation to a linear program L D ∈ Lp, that we will refer to as the naïve interpretation from now on.</p><p>For doing so, one step is to replace the free query variables of the LP(CQ) programs by elements from the database. For this we assume that we have constants for all elements of the database domain, that is dom(D) ⊆ C and define for any conjunctive query Q and variable assignment γ : Y → D where fv(Q) ⊆ Y a conjunctive query sbs γ (Q), by replacing in Q all free occurrences of variables y ∈ Y by γ(y). The formal definition is given in Figure <ref type="figure" target="#fig_3">12</ref>.</p><p>In order to define the semantics of a linear program L over a database D we consider the following set of linear program variables: </p><formula xml:id="formula_19">Θ D L = {θ α sbsγ (Q) | S = weight x:Q (Q) in L, α : set(x) → dom(D), γ : fv(S) → dom(D)} Let S = weight x:Q (Q) be</formula><formula xml:id="formula_20">weight x:Q (Q) D,γ = α∈sol D set(x) (sbsγ (Q∧Q )) θ α sbsγ (Q) ∀x:Q. C D,γ = γ ∈sol D set(x) (sbsγ (Q)) C D,γ∪γ x:Q S D,γ = γ ∈sol D set(x) (sbsγ (Q)) S D,γ∪γ N S D,γ = N D,γ S D,γ num(a) D,γ = num D (a D )</formula><p>(may be undefined) expression S D,γ is the overall weight of the solutions</p><formula xml:id="formula_21">S 1 + S 2 D,γ = S 1 D,γ + S 2 D,γ S 1 ≤ S 2 D,γ = S 1 D,γ ≤ S 2 D,γ C 1 ∧ C 2 D,γ = C 1 D,γ ∧ C 2 D,γ true D,γ = true c D,γ = c maximize S subject to C D = maximize S D,∅ subject to C D,∅</formula><formula xml:id="formula_22">α ∈ sol D set(x) (sbs γ (Q ∧ Q)) where γ = γ |Y \set(x) in the table sol D set(x) (sbs γ (Q)).</formula><p>It is described by the following linear sum:</p><formula xml:id="formula_23">S D,γ = α∈sol D set(x) (sbsγ (Q∧Q )) θ α sbsγ (Q)</formula><p>The (naive) interpretations S D,γ and C D,γ of other kinds of linear sums S ∈ Sum Σ and constraints C ∈ Lc Σ over a database D and an environment γ are rather obvious. Note that LP(CQ) program L can be interpreted as linear program L D ∈ Lp without any environment as they do not have free variables. The definitions are summarized in Figure <ref type="figure" target="#fig_9">6</ref>.</p><p>We note that α-renaming the bound variables in weight expressions does not always preserve the semantics of LP(CQ) programs. It may make previously equal queries different, so that different weights may be assigned to their answer sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Example from Resource Delivery Optimization</head><p>Reconsider the LP(CQ) program L from Figure <ref type="figure" target="#fig_1">1</ref> with the following database D:</p><formula xml:id="formula_24">prod D = {(F, O 1 , 1.5), (F, O 2 , 2.2)} store D = {(W 1 , 0.9), (W 2 , 2.5)} route D = {(F, W 1 , 0.5), (F, W 2 , 0.4), order D = {(B, O 1 , 0.8), (B, O 2 , 1.4)} (W 1 , B, 0.6), (W 2 , B, 0.8)}</formula><p>The answer set of query Q = dlr(f , w , b , o ) on D is to be weighted. We denote every</p><formula xml:id="formula_25">answer α : {f , w , b , o } → dom(D) by (α(f ), α(w ), α(b ), α(o )). Then: sol D (dlr) = {(F, W 1 , B, O 1 ), (F, W 2 , B, O 1 ), (F, W 1 , B, O 2 ), (F, W 2 , B, O 2 )}</formula><p>The naive interpretation L D is the following linear program with variables in Θ D L :</p><formula xml:id="formula_26">minimize 0.5 (θ (F,W1,B,O1) Q + θ (F,W1,B,O2) Q ) + 0.4 (θ (F,W2,B,O1) Q + θ (F,W2,B,O2) Q ) +0.6 (θ (F,W1,B,O1) Q + θ (F,W1,B,O2) Q ) + 0.8 (θ (F,W2,B,O1) Q + θ (F,W2,B,O2) Q ) subject to θ (F,W1,B,O1) Q + θ (F,W2,B,O1) Q ≤ 1.5 ∧ θ (F,W1,B,O2) Q + θ (F,W2,B,O2) Q ≤ 2.2 ∧ θ (F,W1,B,O1) Q + θ (F,W2,B,O1) Q ≥ 0.8 ∧ θ (F,W1,B,O2) Q + θ (F,W2,B,O2) Q ≥ 1.4 ∧ θ (F,W1,B,O1) Q + θ (F,W1,B,O2) Q ≤ 0.9 ∧ θ (F,W2,B,O1) Q + θ (F,W2,B,O2) Q ≤ 2.5</formula><p>The term (θ  </p><formula xml:id="formula_27">(F,W1,B,O1) Q + θ (F,W1,B,O2) Q ) in</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">An Efficiently Solvable Fragment</head><p>We introduce a class of projecting LP(CQ) programs and define a notion of width of linear C q-program in this fragment through a collection of hypertree decompositions of the queries they contain. We then show one can find the optimal solution of such programs L more efficiently than by explicitly computing the interpretation over a database D as a linear program L D . For this we will present an alternative factorized interpretation of L to a linear program having fewer variables, while preserving the optimal solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Projecting LP(CQ) Programs</head><p>We start with the definition of projecting LP(CQ) programs, whose main restriction resides on how they can use conjunctive queries.</p><p>Definition 6. The fragment LP(CQ) proj is the set of LP(CQ) programs L such that:</p><p>-for any subexpression weight x:Q (Q) of L, we have that set(x) = fv(Q) and Q is a projecting query of the form x .</p><p>=y with set(x ) ⊆ set(x) and set(x) ∩ set(y) = ∅.</p><p>-for any sum x:Q S and any universal quantifier ∀x:Q. C of L, the query Q is of the form ∃z.r(y) for some relation symbol r ∈ R (n) , vector y ∈ X n and vector z ∈ X * such that set(x) ⊆ fv(Q).</p><p>We denote by LP(CQ qf ) proj the subset of LP(CQ) proj where every conjunctive query Q appearing in a weight expression quantifier free.</p><p>Any expression weight x:Q (Q) of a projecting LP(CQ) program is restricted to projection in Q . Furthermore Q may not have any variables that are free in the weight expression.</p><p>This condition ensures that the interpretation in environment γ of Q does not substitute any variables, that is sbs γ (Q) = Q. Thus, it is interpreted as a sum over θ α Q variables where α are solutions of Q taking the same value γ(y) on variables x . Our algorithm will exploit this fact by utilizing tree decompositions of Q to interpreter weight</p><formula xml:id="formula_28">x:Q (Q) of LP(CQ qf ) proj with one variable instead of |sol D (Q ∧ Q )| needed in the naive interpretation.</formula><p>Another restriction of LP(CQ) proj is that universal quantifiers and sums are guarded by a database relation. Our algorithm does not exploit the structure of conjunctive queries in universal quantifiers and sums so we interpret these expressions in the same way as in Figure <ref type="figure" target="#fig_9">6</ref>.</p><p>To avoid a blow up in the number of constraints, we chose to guard these constructions.</p><p>Hypertree Width of Projecting LP(CQ) Programs. We next lift the concept of generalized hypertree width from quantifier free conjunctive queries to LP(CQ qf ) proj programs. The complexity of our algorithm will depend thereof.   B Q (u) = set(x ). We define the width of T to be the maximal width of</p><formula xml:id="formula_29">(Q) in L, T Q = (V Q , E Q , B Q ) is</formula><formula xml:id="formula_30">ρ T,D,γ (S 1 + S 2 ) = ρ T,D,γ (S 1 ) + ρ T,D,γ (S 2 ) ρ T,D,γ (S 1 ≤ S 2 ) = ρ T,D,γ (S 1 ) ≤ ρ T,D,γ (S 2 ) ρ T,D,γ (C 1 ∧ C 2 ) = ρ T,D,γ (C 1 ) ∧ ρ T,D,γ (C 2 ) ρ T,D,γ (true) = true ρ T,D,γ (c) = c ρ T,D,γ (weight x:x . =y (Q)) = ξ Q,u,β if β = [x /γ(y)] ∈ sol D (Q) |B Q (u) 0 else where u is a node of T Q such that set(x ) = B Q (u).</formula><formula xml:id="formula_31">T Q for Q ∈ cqs(L).</formula><p>The size of T is defined to be</p><formula xml:id="formula_32">|T| = Q∈cqs(L) |V Q |.</formula><p>The rest of the section is dedicated to proving the following theorem:</p><formula xml:id="formula_33">Theorem 8 (Main). Let L be a LP(CQ qf ) proj program, T a decomposition of L of width</formula><p>k and D a database. There exists an interpretation ρ T,D (L) of L having the same value as</p><formula xml:id="formula_34">L D and O(|T||D| k ) variables.</formula><p>Observe that the number of variables of L D is roughly the total number of solutions of the conjunctive queries in cqs(L), which may be up to O(|D| n ), where n is the number of atoms in the conjunctive queries. In Theorem 8, the degree of the polynomial now only depends on the width of the queries, which may be much smaller, resulting in a more succinct linear program that is easier to solve. In the resource optimization example, this allows to go from a cubic number of variables to a quadratic one, but the improvement may be much better on queries having many atoms and small width.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Factorized Interpretation</head><p>Based on hypertree decompositions we present an alternative factorized interpretation to smaller linear program having the same optimal value.</p><p>In this section, we explain how we can exploit tree decompositions of projecting LP(CQ)</p><p>programs with quantifier free conjunctive queries to find a smaller interpretation. We fix a program L of LP(CQ qf ) proj . Let T = (T Q ) Q∈cqs(L) be a tree decomposition of L of width k</p><p>where The set of linear program variables for the factorized interpretation ρ T,D (L) is defined by:</p><formula xml:id="formula_35">T Q = (V Q , E Q , B Q ). The T-factorized interpretation ρ T,D (L) of L is</formula><formula xml:id="formula_36">Ξ T,D L = {ξ Q,u,β | Q ∈ cqs(L), u ∈ V Q , β ∈ sol D (Q) |B Q (u) }. Observe that since T Q is a tree decomposition of Q of width at most k, sol D (Q) |B Q (u) is of size at most |D| k .</formula><p>Thus we have at most |T||D| k variables in ρ T,D (L), as stated in Theorem 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XX:12 Linear Programs with Conjunctive Queries</head><p>One can see that given a context γ such that ρ T,D,γ (weight x:x . =y (Q)) = ξ Q,u,β , the usual interpretation would have been weight</p><formula xml:id="formula_37">x:x . =y (Q) D,γ = α∈sol D set(x) (Q):α| x =β θ α Q , that</formula><p>is, intuitively, ξ Q,u,β represents the linear sum of variables θ α Q in the naive interpretation with α compatible with β.</p><p>To prove that ρ T,D (L) has the same optimal value as L D , we will reconstruct a solution to L D from a solution to ρ T,D (L) such that the value of ξ Q,u,β indeed corresponds to the sum of the values of variables θ α Q with α compatible with β and vice-versa. To ensure that this is always possible, we have to be careful that variables ξ Q,u,β and ξ Q,v,β are compatible with one another because they may correspond to two sums on θ α Q variables having a non-empty intersection. We ensure this through local soundness constraints lsc T,D (Q) for every query</p><formula xml:id="formula_38">Q ∈ cqs(L) (where A = sol D (Q)): lsc T,D (Q) = (u,v)∈E Q γ∈A |B Q (u)∩B Q (v) β∈A |B Q (u) ,β |B Q (u) =γ ξ Q,u,β . = β ∈A |B Q (v) ,β |B Q (v) =γ ξ Q,v,β .</formula><p>Observe we added at most</p><formula xml:id="formula_39">|D| k |E Q | constraints for each Q ∈ Q. Moreover constructing ρ T,D<label>(</label></formula><p>L) from L and D mainly relies on being able to compute sol D (Q) |B(u) for every node u of T Q . This is possible in polynomial time by dynamic programming on T Q , see Lemma 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Correctness</head><p>Weightings on Tree Decompositions. One can observe that the key idea in the definition of ρ T,D (L) is to introduce linear program variables that will intuitively encode the sum of several linear program variables in the naive interpretation L D . A solution to L D maps a variable θ α Q to a non-negative real number where α ∈ sol D (Q). In other words, it assigns a weight ω(α) ∈ R + to every α ∈ sol D (Q) for every Q ∈ cqs(L). A solution to ρ T,D (L) maps a variable ξ Q,u,β to a non-negative real number where β ∈ sol D (Q) |B Q (u) . In other words, it assigns a weight W u to every β that is in sol D (Q) |B(u) for every node u of T Q .</p><p>To reconstruct a solution of L D from a solution W of ρ T,D (L), we need to be able to reconstruct a weighting ω of sol D (Q) such that α| B Q (u) =β ω(α) = W u (β). In this section, we explain that this is always possible as long as the W u are compatible with one another, which is ensured by local soundness constraints lsc T,D (Q) in ρ T,D (L).</p><p>The technique is not specifically tied to the fact that the weights are assigned to the solutions of a quantifier free conjunctive query, thus we formulate our result in a more general setting by considering weightings on a set A ⊆ D X = {α | α : X → D} for a finite set of variables X. Intuitively however, one can think of A as sol D (Q) for a quantifier-free conjunctive query Q.</p><p>We start by introducing a few notations. Let X ⊆ X ⊆ X . For any α : X → D we define the set of its extensions into A by</p><formula xml:id="formula_40">A[α ] = {α ∈ A | α |X = α }. Moreover, given a weighting ω : A → R + of A, we define the projection π X (ω) : A |X → R + such that for all α ∈ A |X : π X (ω)(α ) = α∈A[α ] ω(α).</formula><p>We now fix T = (V, E, B) a decomposition tree for X. Given two nodes u, v ∈ V we denote the intersection of their bags by B uv = B(u) ∩ B(v).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 9.</head><p>A family W = (W v ) v ∈V is a weighting collection on T for A if it satisfies the following conditions for any two nodes u, v ∈ V:</p><formula xml:id="formula_41">-W u is a weighting of A |B(u) , i.e., W u : A |B(u) → R + .</formula><p>-W u is sound for T at {u, v}, i.e., π</p><formula xml:id="formula_42">B uv (W u ) = π B uv (W v ).</formula><p>F. Capelli, N. Crosetti, J. Niehren and J. Ramon</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XX:13</head><p>Intuitively, the soundness of a weighting collection on T is a minimal requirement for the existence of a weighting ω of A such that W u is the projection of ω on the bag B(u) of T , that is W u = π B(u) (ω) since we have the following:</p><p>Proposition 10. For any weighting ω : A → R + , the family (π B(v) (ω)) v∈V is a weighting collection on T for A.</p><p>What is more interesting is the other way around, that is, given (W u ) u∈V a weighting collection on T , whether we can find a weighting ω of A such that W u = π B(u) (ω) for every u. It turns out that soundness is not enough to ensure the existence of such a weighting.</p><p>However it becomes possible when A is conjunctively decomposed: Definition 11. Let T = (V, E, B) be a decomposition tree of X ⊆ X . We call a subset of variable assignments A ⊆ D X conjunctively decomposed by T if for all u ∈ V and</p><formula xml:id="formula_43">β ∈ A |B(u) : {α 1 ∪ α 2 | α 1 ∈ A |B(↑u) [β], α 2 ∈ A |B(↓u) [β]} ⊆ A[β] where B(V ) = v∈V B(v)</formula><p>for any V ⊆ V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note that the inverse inclusion holds in general. Of course, this property holds if</head><p>A is the answer set of a conjunctive queries and the tree is a tree decompositions of Q:</p><p>Proposition 12. For any tree decomposition T of a quantifier free conjunctive query Soundness and conjunctive decomposition are enough to prove this correspondence theorem that allows us to transform solutions of ρ T,D (L) to solutions of L D and vice-versa.</p><formula xml:id="formula_44">Q ∈ C q Σ and</formula><p>Theorem 13 (Correspondence). Let T = (V, E, B) be a normalized decomposition tree of X ⊆ X and A ⊆ D X be a set of variable assignment that is conjunctively decomposed by T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.</head><p>For every weighting ω of A, (π B(u) (ω)) u∈V is a weighting collection on T for A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>For any weighting collection W on T for A there exists a weighting ω of A such that</p><formula xml:id="formula_45">∀u : W u = π B(u) (ω).</formula><p>While the first item of Theorem 13 follows by Proposition 10 and can be proven by a simple calculation, the second item is harder to prove. We present here one way of constructing ω from (W u ) u∈V . The proof of correctness of this construction can be found Appendix C.</p><p>Let T = (V, E, B) be a normalized decomposition tree of X and W = (W u ) u∈V a weighting collection on T for A ⊆ D X . For any node u ∈ V, we inductively construct ω u :</p><formula xml:id="formula_46">A |B(↓u) → R + .</formula><p>If u is a leaf of T , we define ω u such that for all α ∈ A |B(↓u) , ω u (α) := W u (α). Now, assume ω u is defined for all children u of u. Let α ∈ A |B(↓u) and denote by</p><formula xml:id="formula_47">β = α |B(u)</formula><p>. We define ω u (α) as follows:</p><formula xml:id="formula_48">If u is an extend node with a child v then ω u (α) := Wu(β) Wv(α |B(v) ) ω v (α |B(↓v) ) if W v (α |B(v) ) &gt; 0 and ω u (α) := 0 otherwise. If u is a project node with a child v then ω u (α) := ω v (α |B(↓v) ). If u is a join node with children v 1 , . . . , v k then ω u (α) := k i=1 ωv i (α |B(↓v i ) ) Wu(β) k-1 if W u (β) &gt; 0</formula><p>and ω u (α) := 0 otherwise. Finally, we let ω be ω r where r is the root of T . The proof that ∀u : W u = π B(u) (ω) is done via two inductions. The first one is a bottom-up induction to prove that W u = π B(u) (ω) for every node u in the tree decomposition. Then, by top-down induction, one can prove that XX:14 Linear Programs with Conjunctive Queries ω u = π B(↓u) (ω r ). The proof is tedious and mainly rely on calculations and careful analysis on how A is decomposed along T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Correctness Proof.</head><p>We are now ready to prove that, given a tree decomposition T of a linear C q-program L of LP(CQ qf ) proj , ρ T,D (L) and L D have the same optimal value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For any weighting</head><p>. ω: Θ L → R + we define a weighting Π(</p><p>.</p><formula xml:id="formula_49">ω) : Ξ T,D L → R + such that for all ξ Q,u,β ∈ Ξ T,D L : Π( . ω)(ξ Q,u,β ) = α∈sol D (Q)[β]</formula><p>.</p><formula xml:id="formula_50">ω (θ α Q ).</formula><p>Observe that  <ref type="figure">ω</ref>) is a solution of ρ T,D (L) with the same value. Thus, the optimal value of ρ T,D (L) is greater or equal than the optimal value of L D .</p><p>To prove the equality, it remains to prove that the optimal value of L D is greater or equal than the optimal value of ρ T,D (L). To this end, consider a solution of ρ T,D (L). It is a W .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">For any solution</head><p>.</p><p>W of ρ T,D (L) there is a solution</p><formula xml:id="formula_51">. ω of L D s.t. S D,∅ . ω = ρ T,D (S) . W .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Treatment of Existential Quantifiers</head><p>The previous method of factorized interpretation only works for the LP(CQ qf ) proj fragment, where conjunctive queries are supposed to be quantifier free. It turns out that one can similarly solve linear programs of LP(CQ) proj programs by applying a simple transformation. Observe that we can use this technique for the resource delivery problem L. In mvq(L),</p><p>there is only one query on variables (f , o , q, q , b , w , c, c ). It is easy to see that it has hypertree width 2 since we can construct a tree decomposition having two connected bags  </p><formula xml:id="formula_52">B(u) = {f , o , b , q, q } and B(v) = {f ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Preliminary Experimental Results</head><p>The practical performances of our idea heavily depends on how linear solvers perform on factorized interpretation. We compared the performances of GLPK on both the naive interpretation and the factorized interpretation of the resource delivery problem from the introduction using some synthetic data. We used Python and the Pulp library to build the linear programs. The tree-decomposition of the dlr query is hard-coded. The tests were run on an office laptop by making the number of tuples in the randomly filled prod, order and route tables vary. A summary of our experiments is displayed on Figure <ref type="figure" target="#fig_21">8</ref>.</p><p>As expected when comparing both linear programs we observed a larger number of constraints (due to the soundness constraints) and a smaller number of variables in the factorized interpretation. While building the naive interpretation quickly became slower than building the factorized interpretation, we do not analyze this aspect further since we are not using a database engine to build the naive interpretation and solve it directly from the tree decomposition, which may not be the fastest method without further optimizations.</p><p>Most interestingly solving the factorized interpretation was faster than solving the naive interpretation in spite of the increased number of constraints thanks to the decrease in the number of variables. In particular for an instance with an input size of 2000 lines per table, the naive interpretation had roughly 1.5 million variables while the factorized interpretation had only roughly 150000. The solving time was also noticeably improved at 22s for the factorized case against 106s for the naive one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion and Future Work</head><p>Our preliminary experiments seem to confirm the efficiency of factorized interpretation, in accordance with our complexity results. More thorough benchmarking is needed to evaluate the practical relevance though. Another direction to explore would be to better integrate our approach into a database engine, in the way it is done by SolveDB for example. Finally, other optimization problems may benefit from this approach such as convex optimization or integer linear programming. It would be interesting to define languages analogous to LP(CQ) for these optimization problems and study how conjunctive query decompositions could help to improve the efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Minimizing Noise in -Differential Privacy</head><p>The strategy of differental privacy is to add noise to the relational data before publication.</p><p>Roughly speaking, the general objective of ε-differential privacy <ref type="bibr" target="#b4">[5]</ref> is to add as few noise as possible, without disclosing more than an ε amount of information. We illustrate this with the example of a set of hospitals which publish medical studies aggregating results of tests on patients, which are to be kept confidential. We consider the problem of how to compute the optimal amount of noise to be added to each separate piece of sensitive information (in terms of total utility of the studies) while guaranteeing ε-differential privacy. We show that this question can be solved (approximately) by computing the optimal solution of a projecting LP(CQ) program with an acyclic conjunctive query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Hospital Database about Medical Studies on Patient Tests</head><p>We consider a database D with signature Σ = {H, Test, St, Priv, Sens} whose domain provides patients, hospitals, studies, and positive real numbers. The relations of D are the following:</p><p>(pat, hosp) ∈ H D : the patient pat is in the hospital hosp.</p><p>(pat, st) ∈ Test D : the patient pat participates in the study st.</p><p>(test, st) ∈ St D : the test test is used in the study st.</p><p>(obj, ε) ∈ Priv D : the object obj is either a patient or a hospital. The positive real number ε indicates the privacy budget for obj.</p><p>(st, test, val) ∈ Sens D : the value (in terms of study results) of a patient participating in a study and contributing a unit of information on their result on test test.</p><p>The following query defines the sensitive information that will be revealed to the researchers performing the medical studies. It selects all pairs of patients pat and tests test, such pat did the test which was then used by some study st.</p><formula xml:id="formula_53">InStudy(pat, test) = ∃st. Test(pat, test) ∧ St(test, st)</formula><p>More precisely, the sensitive information is the answer set of this query over the database D. We want to assign a weight to all the pairs in the answer set. The weight of a sensitive pair states the amout of information that may be disclosed about the pair after the addition of the noise. The needed amount of noise for the pair is then inversely proportional to the amount of information that may be disclosed, i.e, the weight of the pair, which is also called its privacy budget. The weight of a patient pat and a test test is specified by the weight expression:</p><p>weight <ref type="bibr">(</ref>  This sum may be represented more compactly in factorized interpretation avoiding the enumeration of the answer set for the database D.</p><p>The LP(CQ) program for this example is given in Figure <ref type="figure" target="#fig_22">9</ref>. The linear privacy constraints that are to be satisfied are C Pat and C Hosp . Constraint C Pat states that for all patients pat with privacy requirement ε, i.e., ∀(pat, ε) : Priv(pat, ε), the sum of all weights of all sensitive pairs (pat, test ) in InStudy must be bounded by ε. This constraint is motivated by the composition rule of differential privacy (DP). Suppose we have sensitive pairs p i = (pat i , test i ).</p><formula xml:id="formula_54">If p i is ε i -DP for 1 ≤ i ≤ n, then {p 1 . . . p n } is ( n i=1 ε i )-DP.</formula><p>Similarly, constraint C Hosp states that for all hospitals hosp with privacy requirement ε, i.e., ∀(hosp, ε) : Priv(hosp, ε), the sum of all weights of all sensitive pairs (pat, test) in InStudy where pat is a patient of hosp must be bounded by ε. Finally, the objective function is to maximize the sum over all triples (st, test, val) in Sens of the weights of pairs <ref type="bibr">(pat , test)</ref> in InStudy but multiplied with num(val), the utility of the information for the study. This program is projecting, so it is a member of LP(CQ) proj . Furthermore, a hypertree decomposition of width 1 is available. While the naive interpretation over a database yields a linear program with a quadratic number of variables (in the size of the database), the factorized interpretation yields a linear program with a linear number of variables.</p><p>Please note that the approach presented above is only approximate. For example, summing over noise variance in the objective function would be more accurate but would only lead to a convex program, which motivates us to extend beyond linear programs in future work. Also, the composition rule for DP is only approximate, more advanced composition rules have been studied but they are more complex and still approximate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Computing the s-Measure for Graph Pattern Matching</head><p>The s-measure has been introduced by Wang et al. <ref type="bibr" target="#b23">[23]</ref> to evaluate the frequency of matchings of a subgraph pattern in a larger graph. Here, we consider pattern matches as graph homomorphism, but we could also restrict them to graph isomorphisms.</p><p>A naive way of evaluating this frequency is to use the number of pattern matches as the frequency measure. Using this value as a frequency measure is problematic since different XX:20 Linear Programs with Conjunctive Queries pattern maches may overlap, and as such they share some kind of dependencies that is relevant from a statistical point of view. More importantly, due to the overlaps, this measure fails to be anti-monotone, meaning that a subpattern may be counter-intuitively matched less frequently than the pattern itself. Therefore, the finding of better anti-monotonic frequency measures -also known as support measures -has received a lot of attention in the data mining community <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6]</ref>. A first idea is to count the maximal number of non-overlapping patterns <ref type="bibr">[22]</ref>. However, finding such a maximal subset of patterns essentially boils down to finding a maximal independent set in a graph, a notorious NP-complete problem <ref type="bibr" target="#b7">[8]</ref>.</p><p>The s-measure is a relaxation of this idea where the frequency of pattern matches is computed as the maximum of the sum of the weights that can be assigned to each pattern match, under the constraint that for any node v of the graph and node v in the subgraph pattern that the sum of the weights of the matchings mapping v to v is at most 1. More formally, given two digraphs G = (V G , E G ) and P = (V P , E P ), we define a matching of the pattern P in graph G as a graph homomorphism h : V P → V G . Recall that a graph homomorphism requires for all (v, v ) ∈ E p that (h(v), h(v )) ∈ E G . We denote by hom(P, G) the set of matchings of P in G. The s-measure of P in G is then defines as the optimal value of the following linear program with variables in {θ h | h ∈ hom(P, G)} for positive real numbers:</p><formula xml:id="formula_55">maximize h∈hom(P,G) θ h subject to ∀v ∈ V G .∀v ∈ V P . h∈hom(P,G) h(v )=v θ h ≤ 1</formula><p>We can consider each graph G as a database D with signature Σ = {node, edge}, domain dom(D G ) = V G and relations node D = V G and edge D = E G . Since the names of the nodes of the pattern do not care for pattern matching, we can assume without loss of generality that V P = {1, . . . , } for some ∈ N. We can then define a matching of a pattern P by a conjunctive query match P (x 1 , . . . , x ):  </p><formula xml:id="formula_56">match P (x 1 , . . . , x ) = (i,</formula><formula xml:id="formula_57">, α 2 ∈ A |X , if α 1 = α 2 then A[α 1 ] ∩ A[α 2 ] = ∅. Proof. If α 1 = α 2 ∈ A |X , then there exists x ∈ X such that α 1 (x ) = α 2 (x ), so if γ 1 ∈ A[α 1 ] and γ 2 ∈ A[α 2 ] then γ 1 (x ) = α 1 (x ) = α 2 (x ) = γ 2 (x ). Lemma 20. For A ⊆ D X , X ⊆ X ⊆ X, α ∈ A |X : A[α ] = α ∈A |X [α ] A[α ].</formula><p>Proof. First note that the union on the right is disjoint by Lemma 19.</p><p>For the inclusion from the left to the right, let α ∈ A[α ] and α = α |X . By definition,</p><formula xml:id="formula_58">α ∈ A |X so α ∈ A[α ]. Furthermore, α ∈ A |X [α ] so α ∈ α ∈A |X [α ] A[ α ].</formula><p>For the inclusion from the right to the left, let α</p><formula xml:id="formula_59">∈ α ∈A |X [α ] A[α ] and let α ∈ A |X [α ] be such that α ∈ A[α ]. By definition, α |X = α and α |X = α . Since X ⊆ X , α |X = α |X = α . Thus α ∈ A[α ].</formula><p>For any weighting ω of A and subset of variables X ⊆ X, we define the projection π X (ω) :</p><formula xml:id="formula_60">A |X → R + such that for all α ∈ A |X : π X (ω)(α ) = α∈A[α ] ω(α) Proposition 21. For A ∈ D X , ω : A → R + , X ⊆ X ⊆ X: π X (ω) = π X (π X (ω)).</formula><p>Proof sketch. This is a consequence of the disjoint decomposition of Lemma 20.</p><p>Proof. Indeed, let α ∈ A |X . We have:</p><formula xml:id="formula_61">π X (ω)(α ) = α∈A[α ] ω(α) by definition = α ∈A |X [α ] α∈A[α ] ω(α) by Lemma 20 = α ∈A |X [α ] π X (ω)(α ) by definition of π X (ω) = π X (π X (ω))(α ) by definition of π X (π X (ω)).</formula><p>The last equality is well defined since α ∈ A |X = (A |X ) |X .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 Weighting collections on decomposition trees</head><p>Let X ⊆ X be a finite set of variables and T = (V, E, B) a decomposition tree of X. Given two nodes u, v ∈ V we denote the intersection of their bags by:</p><formula xml:id="formula_62">B uv = B(u) ∩ B(v)</formula><p>Definition 22. Let A ⊆ D X and let T = (V, E, B) be a decomposition tree for X. We call a family W = (W v ) v ∈V a weighting collection on T for A if it satisfies the following two conditions for any two nodes u, v ∈ V: XX:28 Linear Programs with Conjunctive Queries</p><formula xml:id="formula_63">-W u is a weighting of A |B(u) , i.e., W u : A |B(u) → R + . -W u is sound for T at {u, v}, i.e., π B uv (W u ) = π B uv (W v ).</formula><formula xml:id="formula_64">c ω = c ξ ω = ω(ξ) cS ω = c • S ω S + S ω = S ω + S ω true ω = 1 S ≤ S ω = 1 if S ω ≤ S ω 0 otherwise. C ∧ C ω = C ω ∧ C ω maximize S subject to C = max({ S ω | ω : Ξ → R + , C ω .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>=1})</head><p>Figure <ref type="figure" target="#fig_1">10</ref> Evaluation of linear sums, constraints and programs. To illustrate this let x = (x 1 , x 2 ) and L be the following linear C q-program: maximize weight x:x2 . =a (r(x)) subject to weight x (r(x)) ≤ 1.</p><formula xml:id="formula_65">eval D,α (x) = α(x) eval D,α (a) = a D sol D X (E 1 . =E 2 ) = {α : X → D | eval D,α (E 1 ) = eval D,α (E 2 )} sol D X (r(E 1 , . . . , E n )) = {α : X → D | (eval D,α (E 1 ), . . . , eval D,α (E n )) ∈ r D } sol D X (Q 1 ∧ Q 2 ) = sol D X (Q 1 ) ∩ sol D X (Q 2 ) sol D X (∃x.Q) = {α |X | α ∈ sol D X∪{x} (Q)} if x ∈ X sol D X (true) = X dom(D)</formula><p>Let D be a database with signature Σ = {r (2) } and interpretation r D = {(0, 0), (0, 1)}. If Q is the query r(x) then the semantics of this linear C q-program L D is the linear program:</p><formula xml:id="formula_66">maximize θ (0,1) Q subject to θ (0,0) Q + θ (0,1) Q ≤ 1 The optimal value L D is L D = 1 since θ (0,0) Q + θ (0,1) Q ≤ 1 and θ (0,0) Q ≥ 0. Now let us α-rename the second occurrence of x in L apart to x = (x 1 , x 2 ) yielding the following linear C q-program L : maximize weight x:x2 . =a (r(x)) subject to weight x (r(x )) ≤ 1.</formula><p>The semantics L D is the following linear program where Q is r(x ) and Q is r(x):</p><formula xml:id="formula_67">maximize θ (0,1) Q subject to θ (0,0) Q + θ (0,1) Q ≤ 1</formula><p>The optimal value of L D is ∞ since θ (0,1) Q is no more constrained: the renaming made the variables of Q and Q different, so that the variable assignments answering these queries F. Capelli, N. Crosetti, J. Niehren and J. Ramon XX:29  Observe that it follows from the hypothesis that lsc T,D (Q) . W = 1 so given a pair of nodes (u, v) in T Q and a γ ∈ sol D (Q) |B uv then β∈A |B(u) [γ]   ω:</p><formula xml:id="formula_68">sbs γ (Q ∧ Q ) = sbs γ (Q) ∧ sbs γ (Q ) sbs γ (∃x.Q) = ∃x.sbs γ |dom(γ)\{x} (Q) sbs γ (r(t 1 , . . . , t n )) = r(sbs γ (t 1 ), . . . , sbs γ (t n )) sbs γ (x) = γ(x) if x ∈ dom(γ) x otherwise sbs γ (a) = a</formula><formula xml:id="formula_69">Θ Q → R + such that . ω (θ α Q ) = ω Q (α) for each θ α Q ∈ Θ Q .</formula><p>We fix a ξ Q,u,β ∈ Ξ T,D L . By definition  .</p><formula xml:id="formula_70">W (ξ Q,u,β ) = W Q u (β) = (π B(u) (ω Q ))(β) = α∈sol D (Q)[β] ω Q (α). Thus W (ξ Q,u,β ) = Π( . ω)(ξ Q,u,</formula><p>ω (θ α∪β Q ). Again, it is readily verified that the value weight x:Q (∃z.Q) . ω is the same as weight x,z:Q (Q) . ω and thus that . ω is a solution of L and L . ω = mvq(L) . ω .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>the expression weight (f ,w ,b ,o ):f .=f ∧w . =w (Q) when interpreted over D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 A</head><label>1</label><figDesc>Figure 1 A LP(CQ) program for the resource delivery optimization where Q = dlr(f , w , b , o ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>the s-Measure for Graph Pattern Matching. A matching of a subgraph pattern in a graph is a graph homomorphism from the pattern to the graph. The s-measure of Wang et al.<ref type="bibr" target="#b23">[23]</ref> is used in data mining to measure the frequency of matchings of subgraph patterns, while accounting for overlaps of different matchings. The idea is to find a maximal weighting for the set of matchings, such that for any node of the subgraph pattern, the set of matchings mapping it on the same graph node must have a overall weight less then 1. This optimization problem can be expressed by a projecting LP(CQ) program over a database storing the graph. The conjunctive query of this program expresses the matching of the subgraph pattern. The hypertree width of this conjunctive query is bounded by the hypertree width of the subgraph pattern. Our factorized interpretation therefore reduces the size of the linear program for subgraph patterns with small hypertree width. More information on the LP(CQ) program can be found in Appendix B.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2</head><label>2</label><figDesc>Figure 2The set of linear programs Lp with variables ξ ∈ Ξ and constants c ∈ R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>, we recall the definition of the sets of linear sums Sum, linear constraints Lc, and linear programs Lp with variables in Ξ. We consider the usual linear equations S . =S as syntactic sugar for the constraints S ≤ S ∧S ≤ S. For any linear program L = maximize S subject to C we call S the objective function of L and C the constraint of L. Note that minimize S subject to C can be expressed by maximize -1 S subject to C up to negation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Databases. A database schema is a pair Σ = (R, C) where C a finite set of constants ranged over by a, b and R = ∪ n∈N R (n) is a finite set of relation symbols. The elements r ∈ R (n) are called relation symbols of arity n ∈ N. A database D ∈ db Σ is a tuple D = (Σ, D, • D ), where Σ is a schema, D a finite set of database elements, and r D ⊆ D n a relation for any relation symbol r ∈ R (n) and a D ∈ D a database element for any constant a ∈ C. We also define the database's domain dom(D) = D. A database with real numbers is a tuple D = (Σ, D, • D , num D ) such that D = (Σ, D, • D ) is a relational database and num D a partial function from D to R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Intuitively, this expressions is interpreted as a linear sum over linear program variables representing a solution of Q ∧ Q . Variables of Q and Q however may be bound in the context, for example through universal quantifiers or Σ-operators. The query variables in x are bound by the expression taking scope over Q and Q . The free (query) variable of weight expressions must however be bound by the context, so that they will be instantiated to some database values before evaluation. Weight expressions without free variables reason about an unknown weighting of the answer set of query Q on the given database D with the variables in set(x). Its value is then the sum over the weights of tuples in answer set of Q ∧ Q on the database D with variables in set(x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5</head><label>5</label><figDesc>Figure 5Free variables of linear sums, constraints, and linear C q-programs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>a weight expression and γ : Y → dom(D) a variable assignment for the free variables fv(S) ⊆ Y such that set(x) ∩ Y = ∅. The interpretation of the weight F. Capelli, N. Crosetti, J. Niehren and J. Ramon XX:9</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6</head><label>6</label><figDesc>Figure 6 Naïve interpretation of linear expressions (sums, constraints, programs) with conjunctive queries F over database D as standard linear expression (sums, constraints, and respectively programs) F D,γ , where γ : Y → dom(D) and fv(F ) ⊆ Y ⊆ X and γ = γ |Y \set(x) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>the objective function of this linear program is obtained by computing the value of the expression weight (f ,w ,b ,o ):f .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>=s∧w . =e (Q) with XX:10 Linear Programs with Conjunctive Queries the environment [f /F, w /W 1 ]. Similarly the term θ (F,W1,B,O1) Q + θ (F,W2,B,O1) Q in the first constraint is obtained by computing the value of weight (f ,w ,b ,o ):f . =f ∧o . =o (Q) with the environment [r/O 1 , f /F ]. Observe that both weight expressions share the same linear program variable θ (F,W1,B,O1) Q so they are related semantically.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>ForDefinition 7 .</head><label>7</label><figDesc>any program L in LP(CQ) proj , we define the set of queries cqs(L) that are weighted when interpreting L as cqs(L) = {Q | weight x:Q (Q) is a subexpression of L}. Observe that the resource delivery problem L is in LP(CQ) proj with cqs(L) = {dlr(f , w , b , o )}. Let L be an LP(CQ qf ) proj program and T = (T Q ) Q∈cqs(L) a collection of decomposition trees. We call T a tree decomposition of L if for any expression weight x:x . =y</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>11 ρ</head><label>11</label><figDesc>a tree decomposition of Q and there is a node u of T Q such that F. Capelli, N. Crosetti, J. Niehren and J. Ramon XX:T,D,γ (∀x:r(x).C) = γ ∈sol D (r(x)) ρ T,D,γ∪γ (C) ρ T,D,γ ( x:r(x) S) = γ ∈sol D (r(x)) ρ T,D,γ∪γ (S) ρ T,D,γ (N S) = ρ T,D,γ (N )ρ T,D,γ (S) ρ T,D,γ (num(a)) = num D (a D ) (may be undefined)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>ρFigure 7 T</head><label>7</label><figDesc>Figure 7 T-factorized interpretation of LP(CQ qf )proj programs L with respect to a database D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>formally defined in Figure 7 .</head><label>7</label><figDesc>It mainly mirrors the naïve interpretation of Figure 6 but significantly differs in two places: the first one is the way weight x:x . =y (Q) is interpreted and one can observe the addition local soundness constraints lsc T,D (Q) to the program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>database D ∈ db Σ , the answer set sol D (Q) is conjunctively decomposed by T . Proposition 12 does not hold when Q is not quantifier free. It explains why the technique only works for the fragment LP(CQ qf ) proj . We however explain how one can use the same technique on LP(CQ) proj in Section 4.4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>.ωLemma 14 .Lemma 15 .</head><label>1415</label><figDesc>can be seen as a collection of weightings of sol D (Q) for Q ∈ cqs(L). It turns out that evaluating linear sums and constraints of L D with . ω returns the same value as the evaluation of linear sums and constraints of ρ T,D (L) with Π( . For any T-projecting sum S ∈ Sum Σ and environment γ : X → dom(D) where fv(S) ⊆ X it holds that S D,γ . ω = ρ T,D,γ (S) Π( . For any constraint C ∈ Lc Σ that is T-projecting and environment γ : X → dom(D) where fv(C) ⊆ X: C D,γ . ω = ρ T,D,γ (C) Π( . ω) . Lemma 14 and Lemma 15 rely on Proposition 10. It is easy to see that they imply that if . ω is a solution of L D (the fact that it respects the local soundness constraints follows from Proposition 10), then Π( .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>weighting.WLemma 16 .Proposition 17 . 1 .</head><label>16171</label><figDesc>of Ξ T,D L which respects the local soundness constraints. By Theorem 13, we will be able to reconstruct a weighting . ω of Θ L which respects the constraint of L D . It is formalized in the following lemma whose proof can be found in the appendix. For any weighting . W of Ξ T,D L such that Q∈Q lsc T,D (Q) . W = 1, there exists a weighting . ω of Θ Q such that . Let D be a database and T a collection of decomposition tree. Any T-projecting LP(CQ) program L = (maximize S subject to C) ∈ Lp Σ satisfies that: For any solution . ω of L D there is a solution . W of ρ T,D (L) s.t. S D,∅ . ω = ρ T,D (S) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>For</head><label></label><figDesc>any LP(CQ) proj program L we can move the existential quantifiers of the conjunctive query into the weight expression as follows, yielding an LP(CQ qf ) proj program mvq(L): we replace every subexpression weight x:Q (∃z.Q) of L, where Q is quantifier free, by weight xz:Q (Q) where xz is the concatenation of vectors x and z. We have: Theorem 18 (Removing Existential Quantifiers). For any projecting LP(CQ) program, the LP(CQ qf ) proj program mvq(L) has the same optimal value as L.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>w , b , c, c }. B(u) is covered by the first two atoms</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 8</head><label>8</label><figDesc>Figure 8 Number of variables and performances of GLPK for naive (blue) and factorized (red) interpretation of the resource delivery problem with respect to table size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 9</head><label>9</label><figDesc>Figure<ref type="bibr" target="#b8">9</ref> An LP(CQ) proj program for differential privacy when publishing medical studies aggregating patient tests in hospitals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>1 21 Lemma 19 .</head><label>12119</label><figDesc>Projections of weightingsLet X ⊆ X ⊆ X and A ⊆ D X = {α | α : X → D} be a set of variable assignments. For any α : X → D we define the set of its extensions into A byA[α ] = {α ∈ A | α |X = α }.F. Capelli, N. Crosetti, J. Niehren and J. Ramon XX:For any two α 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Proposition 23 .</head><label>23</label><figDesc>Let A ⊆ D X and let T = (V, E, B) be a decomposition tree for X. For any weigthing ω : A → R + , the family (π B(v) (ω)) v∈V is a weighting collection on T for A.of Theorem 29. The first item follows directly from Proposition 23.For the second item we know by Proposition 31 that W u = π B(u) (ω u ) which is equal to π B(u) (π B(↓u) (ω r )) by Proposition 34. Thus W u = π B(u) (ω r ) by Proposition 21.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Figure 11</head><label>11</label><figDesc>Figure 11 Answer sets of conjunctive queries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Figure 12 Lemma 14 .</head><label>1214</label><figDesc>Figure 12Lifting substitutions γ : fv(Q) → C to queries Q.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Lemma 15 .Induction step 2 CγLemma 16 .</head><label>15216</label><figDesc>ξ Q,u,β ) by definition of Π = ξ Q,u,β Π( . ω) = ρ T,D,γ (S) Π( . ω) Case S = N . Straightforward.XX:30 Linear Programs with Conjunctive QueriesCase S = x:Q S . S D,γ . ω = γ ∈sol D set(x) (sbsγ (Q)) S D,γ∪γ . ω = γ ∈sol D set(x) (sbsγ (Q)) S D,γ∪γ . ω = γ ∈sol D set(x) (sbsγ (Q)) ρ T,D,γ∪γ (S ) Π( Case S = N S. Straightforward. Case S = S + S . Straightforward. For any constraint C ∈ Lc Σ that is T-projecting and environment γ : X → dom(D) where fv(C) ⊆ X: C D,γ . ω = ρ T,D,γ (C) Π( . ω) .Proof. By induction on the structure of C.Base case 1 C = true Obvious.Base case 2 C = S ≤ S Straightforward using Lemma 14.Induction step 1 C = C ∧ C Straightforward. = ∀x:r(x).C C D,γ . ω = ∀x:r(x). C D,γ . ω = γ ∈sol D set(x) (r(x)) C D,γ∪γ . ω = γ ∈sol D set(x) (r(x)) C D,γ∪γ . ω = γ ∈sol D set(x) (r(x)) ρ T,D,γ∪γ (C ) Π( ∈sol D (r(x)) ρ T,D,γ∪γ (C ) Π( . ω)= ρ T,D,γ (∀x:r(x).C ) Π( For any weighting. W of Ξ T,D L such that Q∈Q lsc T,D (Q) . W = 1, there exists a weighting . ω of Θ Q such that . For each Q ∈ Q, let W Q = (W Q u ) u∈T Q where W Q u (β) = . W (ξ Q,u,β ) for each ξ Q,u,β ∈ Ξ T,D L .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head></head><label></label><figDesc>ξ Q,u,β . W = β ∈A |B(v) [γ] ξ Q,v,β . W .By definition ofW Q we then have β∈A |B(u) [γ] W Q u (β) = β ∈A |B(v) [γ] W Q u (β ). By definition of the projection of weightings it follows that πB uv (W Q u ) = π B uv (W Q v ) so W Q is a weighting collection on T Q . Thus by Theorem 13 for each Q ∈ Q, there is a weighting ω Q : sol D (Q) → R + such that W Q = (π B(u) (ω Q )) u∈V .Finally we define a weighting</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>.</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_30"><head>Proposition 17 . 1 . 2 .Case 1 Case 2 Theorem 18 (</head><label>17121218</label><figDesc>β ) by definition of Π. Let D be a database and T a collection of decomposition tree. Any T-projecting LP(CQ) program L = (maximize S subject to C) ∈ Lp Σ satisfies that: For any solution . ω of L D there is a solution . W of ρ T,D (L) s.t. S D,∅ . ω = ρ T,D (S) . W . For any solution .W of ρ T,D (L) there is a solution.ω of L D s.t. S D,∅ . ω = ρ T,D (S) . W . Proof. Let Q = cqs(L). Consider a solution . ω of L D . Let . W be a weighting of Θ Q such that . W = Π( . ω). By hypothesis C D,∅ . ω = 1 so ρ T,D (C) . W = 1 by Lemma 15. Thus . W is a solution of ρ T,D (L). Moreover S D,∅ . ω = ρ T,D(S) . W by Lemma 14. Fixed solution . W of ρ T,D (L) By Lemma 16 there is a weighting . ω of Θ Q such that . By hypothesis ρ T,D (C) . W = 1 so C D,∅ . ω = 1 by Lemma 15. Thus . W is a solution of ρ T,D (L). Moreover S D,∅ . ω = ρ T,D (S) . W by Lemma 14. Removing Existential Quantifiers). For any projecting LP(CQ) program, the LP(CQ qf ) proj program mvq(L) has the same optimal value as L. Proof. It is clear that every Q appearing in a subexpression weight xz:Q (Q) of mvq(L) is quantifier free by definition. Now, since L is in LP(CQ) proj , Q is of the form x = y where x only contains free variables of ∃z.Q. Since fv(∃z.Q) ⊆ fv(Q), we have that x only contains free variables of Q. Moreover, the other condition of LP(CQ) proj concerning the sum and universal quantification are still respected in mvq(L), thus L is in LP(CQ qf ) proj . Now, let . ω: Θ D L → R + be a solution of L. We define . ω : Θ D mvq(L) → R + as follows: ) where U = fv(∃z.Q) and N = #{β : z → dom | α ∪ β ∈ sol D (Q)}. It is readily verified that the value weight x:Q (∃z.Q) .ω is the same as weight x,z:Q (Q) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_31"><head>ω and thus that .ω</head><label>that</label><figDesc>is a solution of mvq(L) and L . ω = mvq(L) .ω .For the other way around, given.ω : Θ D mvq(L) → R + a solution of mvq(L), we construct . ω: Θ D L → R + as . ω (θ α ∃z.Q ) = β|α∪β∈sol D (Q)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Capelli, N. Crosetti, J. Niehren and J. Ramon XX:19</head><label></label><figDesc>pat ,test ):test . In an environment γ for the global variables pat and test this weight expression is interpreted as the linear program variable:</figDesc><table><row><cell>Queries</cell><cell></cell></row><row><cell cols="3">InStudy(pat, test) = ∃st. Test(pat, test) ∧ St(st, test)</cell></row><row><cell>Constraints</cell><cell></cell></row><row><cell cols="3">C Pat = ∀(pat, ε):P riv(pat, ε).</cell></row><row><cell cols="3">weight (pat ,test ):pat . =pat (Q(pat , test )) ≤ num(ε)</cell></row><row><cell cols="3">C Hosp = ∀(hosp, ε):P riv(hosp, ε).</cell><cell>(pat):H(pat,hosp)</cell></row><row><cell cols="3">weight (pat ,test ):pat . =pat (InStudy(pat , test )) ≤ num(ε)</cell></row><row><cell>Program</cell><cell></cell></row><row><cell>maximize</cell><cell cols="2">(st,test,val):Sens(st,test,val)</cell></row><row><cell></cell><cell cols="2">num(val) weight (pat ,test ):test . =test (InStudy(pat , test ))</cell></row><row><cell cols="2">subject to C Pat ∧ C Hosp</cell></row><row><cell></cell><cell>θ</cell><cell>[pat /γ(pat),test /γ(test)] InStudy(pat ,test )</cell></row><row><cell cols="3">The overall weight of all sensitive tests of the same patient pat is described by the weight</cell></row><row><cell>expression:</cell><cell></cell></row><row><cell></cell><cell cols="2">weight (pat ,test ):pat . =pat (InStudy(pat , test ))</cell></row><row><cell cols="3">In an environment γ for the global variable pat this weight expression is interpreted as the</cell></row><row><cell cols="3">following sum of linear program variables:</cell></row><row><cell></cell><cell></cell><cell>θ</cell><cell>[pat /γ(pat),test /α(test )] InStudy(pat ,test )</cell></row><row><cell cols="3">α∈sol D (InStudy(pat ,test )∧pat =γ(pat))</cell></row></table><note><p><p>=test∧pat . =pat (InStudy(pat , test ))</p>F.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>j)∈E P edge(x i , x j ) It is clear that α ∈ sol D (match P (x 1 , . . . , x ) if and only if α • [1/x 1 , . . . , /x ] is a pattern matching in hom(P, Q). One can thus rewrite the previous linear program as LP(CQ) program as follows: ∧ i=1 weight (x1,...,xn):xi . Moreover, the hypertree width of the conjunctive query match P (x 1 , . . . , x ) is at most the (hyper)tree width of the pattern graph P . By our main Theorem 8, the factorized interpretation yields a linear program with at most (|V G | + |E G ]) k variables, where k is the (hyper)tree width of pattern P . The original linear program could have been of size |V G | which is bounded by |V G | . So the factorized interpretation will pay off if the (hyper)tree width k of the pattern is considerably smaller than the number of its nodes.</figDesc><table><row><cell>maximize</cell><cell>(x):node(x) weight (x1,...,xn):x1 .</cell></row></table><note><p>=x (match P (x 1 , . . . , x n )) subject to ∀(x) : node(x): =x (match P (x 1 , . . . , x n )) ≤ 1.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In the literature this property is referred to as "nice" tree decompositions.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof. For any u ∈ V let W u = π B(u) (ω). The first condition on weighting projections holds trivially so we only have to show that the soundness constraint holds. By definition of W u , π B uv (W u ) = π B uv (π B(u) (ω)). Observe that B uv ⊆ B(u) so by Proposition 21 π B uv (W u ) = π B uv (ω). Similarly π B uv (W v ) = π B uv (ω).</p><p>We next show that the global soundness at any subset of nodes {u, v} ⊆ V follows from the local soundness at all subsets {u, v} such that (u, v) ∈ E.</p><p>Lemma 24. If W is sound for T at {u, v} for all edges (u, v) ∈ E then W is sound for T at all subsets {u, v} ⊆ V.</p><p>Proof. We show by induction on k ≥ 0 for all pairs of nodes (u, v)</p><p>The base case where k = 0 is obvious. We now show the induction step from k to k + 1. Let (u, v) ∈ (E ∪ E -1 ) k+1 be arbitrary. Then there exists w ∈ V such that (u, w) ∈ (E ∪ E -1 ) k and (v, w) ∈ E ∪ E -1 . By induction hypothesis, we have π B uw (W u ) = π B uw (W w ). We need to show that π B uv (W u ) = π B uv (W v ). We first observe that B uv ⊆ B(w) by connectedness of T which implies that B uv ⊆ B uw and B uv ⊆ B vw . Therefore, we can conclude as follows:</p><p>by Proposition 21 and</p><p>If T is normalized then the local soundness constraint (22) of W at (u, v) ∈ E can be rewritten equivalently into a simpler form as follows:</p><p>if u is an extend node with unique child v then:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3 Conjunctive decomposition</head><p>We need to restrict ourselves to particular subsets of variable assignments, including answer sets of acyclic conjunctive queries. More generally, we define what it means for a subset of variable assignments to be conjunctively decomposed by a decomposition tree. For any decomposition tree T = (V, E, B) and subset V ⊆ V we define the set of variables:</p><p>In particular, this defines for any v ∈ V the union B(↑v) of bags of vertices in-the-contextor-equal-to v, and the union B(↓ v) of bags of vertices that are descendants-or-equal-to v.</p><p>Definition 25. Let T = (V, E, B) be a decomposition tree of X ⊆ X . We call a subset of variable assignments A ⊆ D X conjunctively decomposed by T if for all u ∈ V and β ∈ A |B(u) :</p><p>F. Capelli, N. Crosetti, J. Niehren and J. Ramon</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XX:23</head><p>Note that the inverse inclusion holds in general. To see this let</p><p>then α ∈ A and β = α |B(u) . Hence, α = α |B(↑u) ∪ α |B(↓u) , so we can define α 1 = α |B(↑u) and</p><p>Proposition 26. For any tree decomposition T of a quantifier free conjunctive query</p><p>Proof. Let u be a node of T . The proof is based on the following observation: given an atom</p><p>and</p><p>Lemma 27. Let T be a decomposition tree of X, u an extend node of T with child v, and A ⊆ D X a subset of variable assignments. If A is conjunctively decomposed by T then any assignment β ∈ A |B(u) satisfies:</p><p>Proof. For the inclusion from the left to the right let </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For the inclusion from the right to the left let</head><p>Proof. The inclusion from the left to the right is obvious by projecting an element of</p><p>For the inclusion from the right to the left let</p><p>Base case p = 1: Obvious. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.4 Weightings correspondence</head><p>We are now ready to prove the main correspondence between weightings of A and weighting collection on T :</p><p>Theorem 29. Let T = (V, E, B) be a normalized decomposition tree of X ⊆ X and A ⊆ D X be a set of variable assignment that is conjunctively decomposed by T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1.</head><p>For every weighting ω of A, (π B(u) (ω)) u∈V is a weighting collection on T for A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>For any weighting collection W on T for A there exists a weighting ω of A such that</p><p>Definition 30. Let T = (V, E, B) be a normalized decomposition tree of X and W = (W u ) u∈V a weighting collection on T for A ⊆ D X .</p><p>For any node u ∈ V, ω u : A |B(↓u) → R + is a weighting defined by induction on wellfounded order on the nodes of tree T .</p><p>For the base case where u is a leaf of T , we define ω u such that for all α ∈ A |B(↓u) :</p><p>For the induction step we suppose that ω u is defined for all children u of u. With</p><p>If u is an extend node with a child v then:</p><p>If u is a project node with a child v then</p><p>Observe that B(u</p><p>If u is a join node with children v 1 , . . . , v k then</p><p>Proof. We show by bottom-up induction on the nodes of T that for all u ∈ V and</p><p>The base case is clearly true by the definition of ω u when u is a leaf.</p><p>Case 1 u is an extend node with v its only child.</p><p>Recall that by soundness</p><p>F. Capelli, N. Crosetti, J. Niehren and J. Ramon</p><p>by Lemma 27</p><p>Case 2 u is a project node with only child v.</p><p>by soundness at (u, v)</p><p>α∈A |B(↓u) [β] ω u (α)</p><p>Proof. For the inclusion from the left to the right, let τ ∈ A[α] and β = τ |B(u) . Observe Proof. We show by top-down induction on the nodes of T that for all v ∈ V and α ∈ A |B(↓v) ,</p><p>The base case is clearly true when v is the root r of T .</p><p>In the following we consider a given α ∈ A |B(↓v) . and we let β = α |B(v) Case 1 v is the only child of an extend node u.</p><p>Case 2 v is the only child of a project node u.</p><p>Observe that B(↓ u) = B(↓ v) because u is a project node so by induction τ ∈A</p><p>Case 3 v is the child of a join node u.</p><p>Let v 1 , . . . , v n be the children of u, we assume wlog that v is v 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>By Proposition 21,</head><p>By induction we obtain α ∈A |B(↓u) [α] ω u (α ).  . Observe that each term in the product only depends on α i (or α for i = 1) and that the denominator only depends on the fixed β so we can rewrite the formula into the following ω v (α)</p><p>ωv i (αi)</p><p>which is equal to ω v (α) • </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On acyclic conjunctive queries and constant delay enumeration</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Grandjean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Computer Science Logic</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="208" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Aggregation and ordering in factorised databases</title>
		<author>
			<persName><forename type="first">Nurzhan</forename><surname>Bakibayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tomáš</forename><surname>Kočiskỳ</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakub</forename><surname>Závodnỳ</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1990" to="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">What is frequent in a single graph?</title>
		<author>
			<persName><forename type="first">Björn</forename><surname>Bringmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siegfried</forename><surname>Nijssen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific-Asia Conference on Knowledge Discovery and Data Mining</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="858" to="863" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">All normalized anti-monotonic overlap graph measures are bounded</title>
		<author>
			<persName><forename type="first">Toon</forename><surname>Calders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Ramon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dries</forename><surname>Van Dyck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="503" to="548" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Algorithmic Foundations of Differential Privacy</title>
		<author>
			<persName><forename type="first">Cynthia</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="211" to="407" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Support computation for mining frequent subgraphs in a single graph</title>
		<author>
			<persName><forename type="first">Mathias</forename><surname>Fiedler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Borgelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MLG. Citeseer</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A modeling language for mathematical programming</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Fourer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">M</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Management Science</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="519" to="554" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Computers and intractability</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>wh freeman</publisher>
			<biblScope unit="volume">29</biblScope>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Hypertree Decompositions and Tractable Queries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Scarcello</surname></persName>
		</author>
		<idno type="arXiv">arXiv:cs/9812022</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="579" to="627" />
			<date type="published" when="2002-05">May 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On tractable queries and constraints</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Scarcello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Database and Expert Systems Applications</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The structure of tractable constraint satisfaction problems</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Mathematical Foundations of Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="58" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A new polynomial-time algorithm for linear programming</title>
		<author>
			<persName><forename type="first">Narendra</forename><surname>Karmarkar</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF02579150</idno>
	</analytic>
	<monogr>
		<title level="j">Comb</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="373" to="396" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Treewidth: computations and approximations</title>
		<author>
			<persName><forename type="first">Ton</forename><surname>Kloks</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Springer Science &amp; Business Media</publisher>
			<biblScope unit="volume">842</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient querying of inconsistent databases with binary integer programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enela</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang-Chiew</forename><surname>Pema</surname></persName>
		</author>
		<author>
			<persName><surname>Tan</surname></persName>
		</author>
		<idno type="DOI">10.14778/2536336.2536341</idno>
		<ptr target="http://dl.acm.org/citation.cfm?doid=2536336.2536341" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2013-04">April 2013</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="397" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Elements of finite model theory</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Tiresias: The database oracle for how-to queries</title>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2213836.2213875</idno>
		<idno>doi:10.1145/2213836.2213875</idno>
		<ptr target="http://doi.acm.org/10.1145/2213836.2213875" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;12</title>
		<meeting>the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Minizinc: Towards a standard cp modelling language</title>
		<author>
			<persName><forename type="first">Nicholas</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralph</forename><surname>Stuckey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Becket</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><forename type="middle">J</forename><surname>Brand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guido</forename><surname>Duck</surname></persName>
		</author>
		<author>
			<persName><surname>Tack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Principles and Practice of Constraint Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="529" to="543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Size bounds for factorised representations of query results</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jakub</forename><surname>Závodnỳ</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="44" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Tractable counting of the answers to conjunctive queries</title>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Skritek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="984" to="1001" />
			<date type="published" when="2013-09">September 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Learning linear regression models over factorized joins</title>
		<author>
			<persName><forename type="first">Maximilian</forename><surname>Schleich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radu</forename><surname>Ciucanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data</title>
		<meeting>the 2016 International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="3" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">SolveDB: Integrating optimization problem solvers into SQL databases</title>
		<author>
			<persName><forename type="first">Laurynas</forename><surname>Šikšnys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Torben</forename><surname>Bach Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Scientific and Statistical Database Management</title>
		<meeting>the 28th International Conference on Scientific and Statistical Database Management</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">F</forename><surname>Capelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Crosetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Niehren and J. Ramon</title>
		<imprint>
			<biblScope unit="volume">XX</biblScope>
			<biblScope unit="page" from="17" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Computing frequent graph patterns from semistructured data</title>
		<author>
			<persName><forename type="first">Natalia</forename><surname>Vanetik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ehud</forename><surname>Gudes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Solomon</forename><forename type="middle">Eyal</forename><surname>Shimony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM 2003. Proceedings. 2002 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002">2002. 2002</date>
			<biblScope unit="page" from="458" to="465" />
		</imprint>
	</monogr>
	<note>Data Mining</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An efficiently computable subgraph pattern support measure: counting independent observations</title>
		<author>
			<persName><forename type="first">Yuyi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Ramon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Fannes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="444" to="477" />
			<date type="published" when="2013-11">November 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Algorithms for acyclic database schemes</title>
		<author>
			<persName><forename type="first">Mihalis</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Conference on Very Large Data Bases</title>
		<meeting>the Seventh International Conference on Very Large Data Bases</meeting>
		<imprint>
			<publisher>VLDB Endowment</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="82" to="94" />
		</imprint>
	</monogr>
	<note>VLDB &apos;81</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
