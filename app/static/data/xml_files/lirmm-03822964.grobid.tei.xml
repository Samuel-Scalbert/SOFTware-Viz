<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A graph based semantics for Logical Functional Diagrams in power plant controllers</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aziz</forename><surname>Sfar</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">GraphIK</orgName>
								<orgName type="laboratory" key="lab2">LIRMM</orgName>
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">CNRS and University of Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">PRISME Department</orgName>
								<orgName type="institution">EDF R&amp;D</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dina</forename><surname>Irofti</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">PRISME Department</orgName>
								<orgName type="institution">EDF R&amp;D</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Madalina</forename><surname>Croitoru</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">GraphIK</orgName>
								<orgName type="laboratory" key="lab2">LIRMM</orgName>
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">CNRS and University of Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A graph based semantics for Logical Functional Diagrams in power plant controllers</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">235D25596312B3A58750849AA7855E1D</idno>
					<idno type="DOI">10.1007/978-</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>System Validation</term>
					<term>Functional Specifications</term>
					<term>Logic Functional Diagram</term>
					<term>Graph based Knowledge Representation and Reasoning</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper we place ourselves in the setting of formal representation of functional specifications given in logical diagrams (LD) for verification and test purposes. Our contribution consists in defining a formal structure that explicitly encodes the semantics and behavior of a LD. We put in a complete transformation procedure of the non-formal LD specifications into a directed state graph such that properties like oscillatory behavior become formally verifiable on LDs. We motivate and illustrate our approach with a scenario inspired from a real world power plant specification.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A power plant is a complex system and its functional behavior is described, for each of its subsystems, using logical diagrams. The logical diagrams are coded and uploaded into the controllers. During the power plant life-cycle (around 60 years and even more), the controllers' code needs to be updated and verified. Engineers generate scenarios in order to verify the new code. However, the scenarios generation is far from being a simple procedure because of the system's complexity. Indeed, the power plant contains a few hundred subsystems, and the behavior of each subsystem is described in a few hundred pages of logical diagrams. Knowing that a logical diagram page contains on average 10 logic blocks, a quick calculation shows that a power plant behavior can be described by a few hundred of thousands of logic blocks. Another nontrivial problem for scenario generation for such systems is caused by the loops existing between the logic blocks, i.e. the input of some logic blocks depends on their outputs, which can cause cyclic behaviors. These are indefinite variations of signals in the controller without a change occurring on its input parameters.</p><p>Logical diagram specifications lack the formal semantics that allow the use of formal methods for properties verification and test scenarios generation. Done through manual procedures, these tasks are tedious. In this paper, we tackle the problem of lack of semantics of logical diagram specifications. To solve this problem, we propose a formal graph model called the Sequential Graph of State/Transition (SGST ) and we define a transformation method of logical diagrams into the proposed graph. On the SGST , we show how to formally verify that the functional behavior described by the logical diagram specification is deterministic. In fact, the specification model is supposed to provide a description of the expected behavior of the controller. If the expected behavior itself is non-deterministic, then test generation based on that behavior does not make sense. This problem can be generated by the presence of loop structures in the logical diagrams that may prevent the behavior (i.e the expected outputs) from converging. The convergence property has to be verified before getting to test generation. Verifying this property directly on the logical diagram, which is a mix of logical blocks and connections presented in a non-formal diagram, is not easy to achieve. This task is possible in theory, as the logical diagrams can be reduced to combinatorial circuits. In literature, a combinatorial circuit <ref type="bibr" target="#b6">[7]</ref> is a collection of logic gates for which the outputs can be written as Boolean functions of the inputs. In <ref type="bibr" target="#b10">[11]</ref> it is shown that a cyclic circuit can be combinatorial, and a method based on binary decision diagrams is proposed to obtain the truth table of the circuit. The problem of where to cut the loops in the circuits and how to solve this loops has also been addressed in other studies <ref type="bibr" target="#b11">[12]</ref>, and applied in particular on the Esterel synchronous programming language <ref type="bibr" target="#b5">[6]</ref>. Another algorithm for analysis cyclic circuits based on minimising the set of input assignments to cover all the combinatorial circuit has been proposed in <ref type="bibr" target="#b7">[8]</ref>. Identifying oscillatory behavior due the combinatorial loops in the circuit has also been studied (see <ref type="bibr" target="#b1">[2]</ref> and references therein). However, all studies cited here are mainly based on simulation rather than formal verification on models. The focus of these works is entirely dedicated to the verification of the cyclic behavior of the circuits and not to test purposes. Yet, several studies have already been published for the matter of both formal properties verification and test sequences generation. For instance, in their survey <ref type="bibr" target="#b4">[5]</ref> Lee and Yannakakis address the techniques and challenges of black box tests derived from design specifications given in the form of finite state machines (Mealy machines). In <ref type="bibr" target="#b12">[13]</ref>, the author extends the test sequences generation to timed state machines inspired from the theory of timed automata <ref type="bibr" target="#b0">[1]</ref>. These results and many others (such as formal verification of properties <ref type="bibr">[9]</ref>) are applicable on state/transition graphs and can by no means be directly used on logical diagrams. In order to take advantage of the already established techniques, we focus our study on transforming logical diagrams into formal state graphs. Prvosot <ref type="bibr" target="#b9">[10]</ref>, has proposed transformation procedures of Grafcet specifications into Mealy machines, allowing the application of the previously mentioned formal methods of verification and test generation. However, Grafcets and logical diagrams are completely different representation models. A model transformation of logical diagrams into state graphs has been conducted by Electrict√© de France (EDF) <ref type="bibr" target="#b2">[3]</ref> for cyclic behavior verification purposes; we note that <ref type="bibr" target="#b2">[3]</ref> is not suitable for test generation and does not take into consideration the behavior of timer blocks. We inspired our work from both <ref type="bibr" target="#b9">[10]</ref> and <ref type="bibr" target="#b2">[3]</ref> to develop a formal state graph representation of the exhaustive behavior encoded in the logical diagram, the SGST . The pro-posed graph allows the verification of the cyclic behavior (called convergence in this paper) and potentially the formal verification of other properties. It also provides the ground to obtain the equivalent Mealy machine on which the existing formal test generation results can be applied. This paper is organized as follows. The second section introduces the Logical Diagram specification with an example. A formal definition of the proposed SGST is given in Section 3. Section 4 details the model transformation procedure from logical diagrams to SGST graphs. In Section 5 we show how the behavior convergence property could be formally verified on the SGST . A discussion and a conclusion are given in the last section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivating example and preliminary notions</head><p>The main objective of a logical controller is to fulfill the set of requirements that it was built for. After their definition, the requirements are transformed into a functional description of the expected behavior called functional specification. A two level verification is needed to validate the controllers: first, the model is compared with respect to the specification, and second, the physical controller is tested to verify the conformity with respect to the specification (see functional validation and system validation in <ref type="bibr" target="#b3">[4]</ref>). For both aspects, the specification model is the key point and the basis of the procedure, therefore it has to be well established and comprehended. In this section, we introduce Logical Diagram specifications used for power plant controllers, we define its composing elements and explain how it describes the functional behavior of the controller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Logical diagrams</head><p>Logical diagrams are specification models used to describe control functions in power plants. They contain a number of interconnected logic blocks that define how a system should behave under a set of input values.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> illustrates a logical diagram extracted from a larger real world controller's logic specification in a power plant. It has five inputs (denoted by i 1 to i 5 ), one output (denoted o 1 ) and logic blocks: either blocks corresponding to logic gates or status blocks (corresponding to memory and on-delay timer blocks described below). The gates in Figure <ref type="figure" target="#fig_0">1</ref> are: two NOT gates followed by two AND gates and two OR gates. They correspond to the conjunction (‚Ä¢), disjunction (+), and negation (¬Ø) Boolean operators, respectively (e.g. the output of an OR gate with two inputs is equal to 0 if and only if both inputs are equal to 0 etc.). The on-delay timer block gives the value 1 at its output if its input maintains the value 1 for 2 seconds; 2 seconds being the characteristic delay Œ∏ of the timer shown in the T block in Figure <ref type="figure" target="#fig_0">1</ref>. The memory block is a set (E) /reset (H) block: if the E input is equal to 1, then the output is equal to 1; if the H input is equal to 1, then the output of the block is 0. If both E and H inputs are equal to 1, the output is equal to 0 since the memory in this example gives priority to the reset H over the set E. This priority is indicated in the block symbol by the letter p. A 0 at both inputs keeps the output of the memory block at the same last given value.</p><p>The timer and the memory are blocks whose outputs not only depend on the values at their inputs, but also on their last memorized status. In this paper we call them status blocks. Each of them possesses a finite set of status values and evolves between them. A status block output value {0,1} is associated to each possible status. In the case of the example of Figure <ref type="figure" target="#fig_0">1</ref>, the memory block M 2 has two possible status values M 1 and M 0 where the status M 1 gives a logic value of 1 at the output of the block M 2 and M 0 status corresponds to the logic value 0. The on-delay timer block T 1 has 3 statuses denoted T D 0, T I 0 and T A 1, where the associated block output values are 0, 0 and 1, respectively. We also note on this example the presence of a loop structure (containing the block T 1 , an OR block and the memory block M 2 ). the logic gates B LG : these are the AND, OR and NOT blocks in the diagram.</p><p>Each of them is equivalent to a Boolean expression over its entries using the Boolean operators (+), (.) and (¬Ø) for AND, OR and NOT, respectively. the status blocks B S : these are blocks that have a status that evolves between a set of values. The evolution of a status of a block b s ‚àà B S depends on the values at its entries and the last value of its status. A logic value at the output of the status block is associated to each of these status values.</p><p>Definition 1 (P status set). We denote by P status the set of all the possible status values of the blocks B S of the logical diagram.</p><p>We note that the status values that a block b s ‚àà B S can take are in a subset of P status . Some insights are given in the following example.</p><p>Example 1 (Illustration of P status set on the motivating example given in Figure <ref type="figure" target="#fig_0">1</ref>). For an on-delay timer status block (such as the block denoted T 1 in Figure <ref type="figure" target="#fig_0">1</ref>), P T ON status = {T D 0, T I 0, T A 1}; for a memory status block (such as M 2 block in Figure <ref type="figure" target="#fig_0">1</ref>), P M status = {M 0, M 1}. The associated block output logic value of a status value 'S X' is indicated in its name by the numeric 'X'. The P status set for the example illustrated in Figure <ref type="figure" target="#fig_0">1</ref>  We denote by Exp V ars the infinite set of all possible Boolean expressions on logic variables in Vars. For example, (o b s k + i k ) ‚àà Exp V ars . In the reminder of this paper, we will use the following mathematical notations on sets. Let A be a set of elements:</p><formula xml:id="formula_0">A k = k A √ó A √ó ... √ó A is the set of all ordered k-tuples of elements of A. Given e =(a 1 ,...,a k )‚àà A k , we denote e(i) the i th element of e, i.e. e(i) = a i . Given e =(a 1 ,...,a k )‚àà A k , we denote ord e (a k ) = k the order k of a k in e.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Test generation for logical diagrams</head><p>Let us explain how these diagrams are supposed to be read and subsequently implemented in a physical system (i.e. the logic controller<ref type="foot" target="#foot_0">3</ref> ). The diagrams are evaluated in evaluation cycles repeated periodically. Within each evaluation cycle the status blocks B S are sequentially evaluated in accordance to a defined order œâ while logic gates are evaluated from left to right. The logic specification diagrams are implemented using a low level programming language into logical controllers. In order to check the conformity of the code with respect to the diagram, test beds are generated. The tests function in a black box manner: we check the conformance of the observed output values to the expected ones for different input values. As one can see, even for a simple diagram like the one given in Figure <ref type="figure" target="#fig_0">1</ref>, finding an exhaustive testing strategy is not obvious. A simple solution for scenario test generation is through simulations of the diagram for each and every possible combination on the inputs i 1 ...i 5 . This poses practical difficulties for two main reasons. On one hand, manual exhaustive test generation is a tedious, timeconsuming task that has to be done to hundreds and hundreds of logical diagram specifications uploaded on logic controllers. On the other hand, a loop structure in the logical diagram could cause oscillation problems. This means that logic values that circulate in a loop could keep changing indefinitely when passing through the blocks of the loop. This is a non desired phenomenon as it might prevent the controller's outputs from converging for a fixed set of input values. To overcome these difficulties, we propose (1) a graph state model called sequential graph of state/transition (SGST ) and ( <ref type="formula">2</ref>) a transformation procedure of the logical diagrams into the SGST . In this new graph, the nodes represent the states of the logical controller. The edges are labelled with the Boolean conditions over logic variables Vars. For instance, using the procedure we propose in this paper, we obtain for the logical diagram shown in Figure <ref type="figure" target="#fig_0">1</ref> the corresponding sequential graph of state/transition given by Figure <ref type="figure" target="#fig_2">2</ref>. Throughout this paper, the logical diagram in Figure <ref type="figure" target="#fig_0">1</ref> will be our case study.</p><p>3 The sequential graph of state/transition (SGST )</p><p>A sequential graph of state transition (SGST ) is a combinatorial structure that explicitly represents all the possible evaluation steps within evaluation cycles of the logical diagram by the controller. Formally, the Sequential Graph of State/Transition (SGST) is an directed graph defined by the tuple (N , E) where N is the set of nodes and E ‚äÜ N √ó N is the set of directed edges. Nodes and edges of the graph are both labeled using the labeling functions l N and l E , respectively.</p><p>Definition 3 (l N function). For a given set of status blocks B S , the labeling function of the nodes of the SGST graph l N is defined as l N : N ‚Üí (P status ) L , where L = Card(B S ). This function assigns, for each status block b s ‚àà B S in the logical diagram, a status value to the node n ‚àà N in the SGST . Definition 5 (Eval logic function). We define Eval logic : P status ‚Üí {0, 1} as the logic evaluation function that returns the equivalent logic value of a status value. In a node n ‚àà N , the logic value at the output of a status block</p><formula xml:id="formula_1">b s i is o b s i = Eval logic (n(i))</formula><p>where n(i) is the status value of the block b s i in the node n. Some notions from Definitions 2-5 are illustrated in Figure <ref type="figure" target="#fig_6">3</ref>. We remind that a logic value at the output o b s is associated to each status value of b s assigned to a node n ‚àà N . Therefore, a node n containing the status values of all blocks B S encodes the logic values at each of their outputs. Definition 6 (n Seq logical sequence). For a given set of status blocks B S , we define n Seq of a node n ‚àà N as the logical sequence on status blocks output variables o B S . It is a logical expression associated to the set of status values in N . This expression uses only the conjunction operator AND ( ‚Ä¢ ) and the complement operator (¬Ø) and involves all the status output variables o b s ‚àà O B S of status blocks b s ‚àà B S :</p><formula xml:id="formula_2">n Seq = L k=1 (Eval logic (n(k)) ‚Ä¢ o b s k + Eval logic (n(k)) ‚Ä¢ o b s k ); whereL = Card(B S ).</formula><p>Example 2 (Illustration of n Seq on the motivating example given by Figure <ref type="figure" target="#fig_0">1</ref>).</p><p>In the SGST example of Figure <ref type="figure" target="#fig_2">2</ref>, the node n 1 encapsulates the status values {M 2 0, T 1 D 0}. These status values correspond to the logic values 0 and 0 at the outputs of the blocks M 2 and T 1 , respectively. The logical sequence </p><formula xml:id="formula_3">n Seq 1 of the node n 1 is n Seq 1 = ( 0 Eval logic (M 2 0) ‚Ä¢o M2 + 1 Eval logic (M 2 0) ‚Ä¢o M2 ) ‚Ä¢ ( 0 Eval logic (T 1 D 0) ‚Ä¢o T1 + 1 Eval logic (T 1 D 0) ‚Ä¢o T1 ) = o M2 ‚Ä¢ o T1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SGST construction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Building the SGST nodes</head><p>We will construct one node for each possible combination of status values between the status blocks. Let us start by defining the set of all the possible combinations of status values of blocks b s ‚àà B S D . Let n T be the number of on-delay timer blocks and n M the number of memory blocks in the logical diagram D. We define the set of all combinations of status values as C status = (P M status ) n M √ó (P T ON status ) n T . The number of nodes of the</p><formula xml:id="formula_4">SGST D is Card(N D ) = Card(C status ) = 3 n T √ó 2 n M ; Card(P T ON status ) = 3, Card(P M status ) = 2.</formula><p>To each of these nodes we attribute a combination of status values using the l N function: We build the edges of the SGST D that link the nodes following the sequential evaluation of status blocks that we just established. This sequential evaluation dictates that only one status block is evaluated at a time. In other words, status blocks are not evaluated simultaneously. The result of evaluation of a status block is used in the evaluation of the next status block in the ordered sequence œâ. This is translated in the graph by building edges that only connect nodes that have the same status values for all status blocks except for one. We call these nodes neighboring nodes. Roughly speaking, Proposition 1 tells us that two nodes in the SGST graph can be neighbours only if all their status values are identical except one. To conclude, an edge of the graph is equivalent to a change of the status value of a single status block between two neighboring nodes n S and n A linked by that edge. We refer to this change of value as an evolution evol and we define EV OL b s as the set of all evolution possibilities of b s ‚àà B S D between its status values P b s status .</p><formula xml:id="formula_5">‚àÄn i ‚àà N D , l N (n i ) = c i where c i ‚àà C status , i ‚àà {1..Card(N D )}. In the example of Figure 1, P T ON status = {T D 0, T I 0, T A 1}, P M status = {M 0, M 1}, C status ={(M 0, T D 0), (M 1, T D 0), (M 1, T I 0), (M 1, T A 1), (M 0, T I 0), (M 0, T A 1)}. Card(C status )=6, the SGST D has therefore six nodes n 1 to n 6 ‚àà N D labeled c 1 ...c 6 ‚àà C status , as shown in Figure 2.</formula><p>Definition 7 (evol tuple). An evolution evol ‚àà EV OL b s is defined by the tuple (s i , s f , C evol ), with:</p><p>s i : the initial status value of the evolution evol; s i ‚àà P b s status s f : the final status value of the evolution evol; s f ‚àà P b s status -C evol : the evolution condition; this is a Boolean expression deducted from the logical diagram. The evolution from s i to s f can only occur if this expression is True. We note that C evol ‚àà Exp V ars .</p><p>In order to construct the edges of the SGST D , first the Boolean expressions of the status block entries have to be calculated (A). Second, the evolution sets EV OL b s of every status block b s have to be determined using the calculated expressions (B). Finally, edges of the graph are constructed based on the determined evolution sets of status blocks (C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Developing the logical expressions at the entries of status blocks:</head><p>We remind that the status value of a block b s ‚àà B S D is calculated based on its previous status value and the logic values at the entries of the block. The logic values at these entries are obtained by evaluating the elements connected to them. We develop these connections into Boolean expressions. The evaluation of a Boolean expression associated to an entry of a status block gives the logic value of that entry. These expressions are developed as follows: Let x b s k be an entry of a status block b s k ‚àà B S D . x b s k could be connected to one of the following elements:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Evolution construction algorithm for status blocks of memory type</head><p>Input: Boolean expressions (E,H) ‚ñ∑ E and H are the two entries of the memory block Output: evolution set EV OL b s ; Reminder: evol ‚àà EV OL b s , evol =(si, s f , C evol ) for all (si, s f ) ‚àà P M status √ó P M status do if (si, The entry H is connected to the output of an 'OR' gate that we call or 1 , H = or 1 . The variable or 1 can be developed into the following expression: or 1 = i 5 + o T1 . The expression of the entry H is therefore H = i 5 + o T Similarly, the input terminal E is connected to an 'OR' logic gate E = or 2 . We denote by x 1 and x 2 the input terminals of this 'OR' gate. or 2 = x 1 + x 2 . Both x 1 and x 2 are connected to logic gates. They are therefore developed into Boolean expression in their turn. Following this process, we obtain</p><formula xml:id="formula_6">s f ) = (M 1, M 0) then C evol ‚Üê H else if (si, s f ) = (M 0, M 1) then C evol ‚Üê E ‚Ä¢ H end if evol ‚Üê (si, s f , C</formula><formula xml:id="formula_7">E = i 1 ‚Ä¢ i 2 + i 3 ‚Ä¢ i 4 .</formula><p>B. Building the evolution sets EV OL b s of every status blocks b s ‚àà B S D : The evolution possibilities of each status block are determined by the nature of the status block (i.e. memory blocks or timer blocks). Knowing the Boolean expressions at the entries of a block b s ‚àà B S D we define the algorithms that construct all the evolution possibilities EV OL b s of the block: Algorithm 1 corresponds to the evolution set construction for memory blocks, and Algorithm 2 constructs the evolution set for a timer block. We note that, in the case of timers, in addition to the logic value at the entry of the block, the status and output Algorithm 2 Evolution construction algorithm for status blocks of timer type Input: Boolean expressions X ‚ñ∑ X is the entry of the block Output: evolution set EV OL b s ; evol ‚àà EV OL b s , evol =(si, s f , C evol ) for all (si, s f ) ‚àà P T ON status √ó P T ON status do if (si, s f ) = (T D 0, T I 0) then</p><formula xml:id="formula_8">C evol ‚Üê X else if (si, s f ) = (T I 0, T D 0) then C evol ‚Üê X else if (si, s f ) = (T I 0, T A 1) then C evol ‚Üê X ‚Ä¢ X/Œ∏ else if (si, s f ) = (T A 1, T D 0) then C evol ‚Üê X end if evol ‚Üê (si, s f , C evol ) add evol to EV OLM end for</formula><p>value of timer blocks also depend on time. After receiving a stimulus (i.e. a rinsing or falling edge), a timer changes its status automatically after a time period during which the stimulus action is maintained. In the case of an on-delay timer with a characteristic delay Œ∏, if its input X is set to 1 for a period ‚àÜ t &gt; Œ∏, the timer goes to the activated status T A giving the value 1 at its output instead of 0 in its deactivated status T D. We introduce another logic variable X/Œ∏ ‚àà Vars such that:</p><p>X/Œ∏ = 1 if X holds the value 1 for a period t &gt; Œ∏ X/Œ∏ = 0 otherwise Example 4. Applying Algorithms 1 and 2 on the diagram example of Figure <ref type="figure" target="#fig_0">1</ref>, we obtain the evolution sets of the two status blocks in the diagram. For the timer T 1 , we obtain T 1 = {evol 1 , evol 2 , evol 3 , evol 4 }, with:</p><formula xml:id="formula_9">evol 1 = (T 1 D 0, T 1 I 0, O M2 ); evol 2 = (T 1 I 0, T 1 D 0, O M2 ); evol 3 = (T 1 I 0, T 1 A 1, O M2 ‚Ä¢ O M2\Œ∏ ); evol 4 = (T 1 A 1, T 1 D 0, O M2 ).</formula><p>For the memory M 2 , we obtain EV OL M2 = {evol 1 , evol 2 }, with:</p><formula xml:id="formula_10">evol 1 = (M 2 0, M 2 1, O T1 ‚Ä¢ e 5 ‚Ä¢ (i 1 + i 4 ) ‚Ä¢ (i 1 + i 3 ) ‚Ä¢ (i 4 + i 2 ) ‚Ä¢ (i 2 + i 3 )); evol 2 = (M 2 1, M 2 0, O T1 + e 5 ).</formula><p>C. Building the edges E D of the SGST D :</p><p>Having built the nodes of the graph and determined all the evolution sets EV OL b s of status blocks B S D , we build the edges that connect these nodes. We remind that the controller evaluates its status blocks in an ordered sequence œâ. In other words, status blocks are not evaluated simultaneously; they are evaluated one at a time. </p><formula xml:id="formula_11">(B S D ) do if nS(k) Ã∏ = nA(k) then dif f erences ‚Üê dif f erences + 1 if dif f erences &gt; 1 then AreN eighbors ‚Üê F alse break loop end if c ‚Üê k ‚ñ∑ c</formula><p>is the index of the block that changes status from nS to nA end if end for 5 Reasoning with the SGST In this section, we show how the convergence of the expected behavior of the controller described by its logical diagram could be verified using the equivalent SGST of that diagram. The SGST is composed of a set of nodes and edges that reproduce the information encoded in the logical diagram in a formal and explicit description. A node in the SGST corresponds to a possible state of the controller, i.e. a possible combination of status values. An edge corresponds to an evolution of a single status block. That is a change of the status value of a block b s ‚àà B S D . The outgoing edges E nj of a node n j ‚àà N D in the SGST D graph of a diagram D, are all the theoretical evolution possibilities of all the status blocks from the node n j . In practice, only one of these outgoing edges e ‚àà E nj , is traversed depending on the values of the input variables I D of the diagram. A traversal of an edge (n S , n A ) is the effective transition of the controller's state from the node n S to the node n A by running the correspondent status block evolution of the traversed edge. We remind that a full evaluation cycle of the logical diagram is held periodically by the controller. In each evaluation cycle of the diagram, status blocks are evaluated one after another according to an order œâ until each and every block b s ‚àà B S is evaluated once and only once. In the SGST , for a set of input values I v a full evaluation cycle corresponds to a chain of successive edges traversed one after another in respect to the order of evaluation œâ. In some cases, many successive evaluation sequences œâ may have </p><formula xml:id="formula_12">Input: nS ‚àà ND Output: n seq S n seq S ‚Üê T rue for all k = 1 to Card(B S D ) do n seq S ‚Üê n seq S ‚Ä¢ (Eval logic (nS(b s k )) ‚Ä¢ o b s k + Eval logic (nS(k)) ‚Ä¢ o b s k ) end for</formula><p>to be run to finally converge to a node. However in other cases, even after multiple evaluation sequences, this convergence may never be reached; Traversal of edges could be endlessly possible for a set of input values I v . The convergence of status values is the property that we are going to study in the rest of this paper. If we consider the real world case of power plants, the convergence property has to be verified on the logical diagrams before implementing them in the controllers. The non convergence of the evaluation cycles of the diagram for a set of input values I v leads to the physical output signals of the controller alternating continuously between 0 and 1 which is a non-desired phenomenon. In the SGST graph, this corresponds to a circuit of nodes being visited over and over again indefinitely. We will define trails and circuits in the graph then propose a formal criteria of behavior convergence on the SGST .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Traversal of the SGST : Trails</head><p>In the SGST , nodes are visited by traversing the edges that link them. A sequence of visited nodes in the graph is called a trail œÑ and is defined as follows:</p><p>Definition 8 (Trail œÑ ). For a given SGST D = (N D , E D ), a trail œÑ ‚àà (N D ) k , with k ‚àà N, is an ordered set of nodes (n 1 , n 2 ,..., n k ) where each pair of successive nodes n i and n i+1 , with i ‚àà {1..k -1}, are neighboring nodes.</p><p>A trail is therefore a series of state changes along neighboring nodes in the SGST graph. From the SGST we can form an infinite number of trails. However, only a finite subset of these trails could be effectively traversed in practice. This is due to the order œâ of the evaluation of status blocks. We call trails that are conform to the order œâ determined trails. These trails correspond to the progressive traversal of viable edges in the SGST for a set of input values I v .</p><p>Definition 9 (Viability of an edge). Let e = (n S , n A ) ‚àà E D be an edge in the SGST linking the start node n S to the arrival node n A . The edge e is said to be viable for a set of input values I v if the Boolean expression label(e) is True for the values I v . The traversal of the edge e changes the state of the controller from n S to n A by changing the status value of a single block b s ‚àà B S D . We denote by b s n S ‚Üín A the status block b s whose value was altered by going from n S to n A . A node n k visited in the middle of a determined trail œÑ , can have multiple outgoing edges in the SGST that are viable at the same time for a set of input values I v . Only one of the viable edges is traversed in accordance to the edge i 2 , i 3 )=(1, 1, 1). We suppose that the last visted node is n k coming from n k-1 . We note that, from the node n k , both edges e 2 =(n k , n u ) and e 3 =(n k , n v ), labeled i 2 and i 3 , respectively, are viable for the input values (1, 1, 1). The following node of the trail œÑ =(n k-1 , n k ) is determined in accordance with Proposition 2. We first consider œâ =(M 1 , M 2 , M 3 ) the order of evaluation of the three status blocks. The last traversed edge is e 1 =(n k-1 , n k ) with a change on the status value of the block M 1 of order ord œâ (M 1 ) = 1 in the evaluation sequence œâ. Edge e 2 alters the status value of the block M 2 of order ord œâ (M 2 ) = 2 while the edge e 3 alters the status value of the block M 3 of order ord œâ (M 3 ) = 3. Since ord œâ (M 1 ) = 1 &lt; ord œâ (M 2 ) = 2 &lt; ord œâ (M 3 ) = 3, the next status block to be evaluated after M 1 is M 2 , so the next node in the trail œÑ is n k+1 = n u . In this case, œÑ =(n k-1 , n k , n u ). However, if we consider œâ =(M 3 , M 2 , M 1 ), i.e. ord œâ (M 3 ) = 1, ord œâ (M 2 ) = 2, ord œâ (M 1 ) = 3, then the last evaluated block M 1 in the trail (n k-1 , n k ) is of order 3 which is the last order in the evaluation sequence œâ. For the same input values (i 1 , i 2 , i 3 )=(1, 1, 1), the next block to be evaluated from n k is this time M 3 of the order 1, which corresponds to edge e 3 =(n k , n v ). In this case, œÑ =(n k-1 , n k , n v ).</p><p>We make the assumption that the initial node of a determined trail is a permanent node. A permanent node, unlike a transitional node, is a node in which the controller's state can remain permanently for a certain set of input values. </p><formula xml:id="formula_13">‚Ä¢ (i 1 + i 4 ) ‚Ä¢ (i 1 + i 3 ) ‚Ä¢ (i 4 + i 2 ) ‚Ä¢ (i 2 + i 3 )</formula><p>. The holding on condition of node n 1 is</p><formula xml:id="formula_14">C Hold = i 5 ‚Ä¢ (i 1 + i 4 ) ‚Ä¢ (i 1 + i 3 ) ‚Ä¢ (i 4 + i 2 ) ‚Ä¢ (i 2 + i 3 ) = i 5 +i 2 ‚Ä¢i 3 +i 2 ‚Ä¢i 4 +i 3 ‚Ä¢i 1 +i 1 ‚Ä¢i 4 ,</formula><p>and can be satisfied for certain sets of input values, e.g. (i 1 , i 2 , i 3 , i 4 , i 5 ) = (0, 0, 0, 0, 1). Thus, node n 1 is a permanent node. From the permanent node n 1 , and for an order of evaluation œâ =(M 2 , T 1 ), a possible determined trail that could be effectively traversed would be œÑ 1 =(n 1 , n 2 , n 3 , n 4 , n 6 , n 1 ) for the order œâ =(M 2 , T 1 ) and the set of input values (i 1 , i 2 , i 3 , i 4 , i 5 ) = (1, 0, 0, 1, 0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Formal verification of the convergence property in the SGST</head><p>In practice, we say that a signal converges if its periodic evaluation by the logic controller gives a constant value over a long time range during which the input signals I remain constant. A non convergent Boolean signal is a signal that keeps oscillating between 0 and 1 over multiple evaluation cycles of the logic controller while input values are unchanged. In the SGST , oscillating Boolean signals correspond to an indefinite visiting of the same subset of nodes over and over again. This causes an indefinite change of status values, which results in its turn to an indefinite change of logic values at the output of status blocks.</p><p>Definition 11 (Circuits in the SGST ). We define a circuit in a SGST graph as a finite series of nodes (n 1 ,n 2 ,. . . ,n m ) such that the consecutive nodes n k and n k+1 are neighboring nodes and n 1 = n m .</p><p>However, a determined trail in the SGST graph could contain a circuit of nodes without necessarily traversing it indefinitely. Indeed, a trail could correspond to a one-time traversal of a circuit to leave it as soon as it visits the same node twice, as shown by Example 7. Example 7. We consider the SGST graph given by Figure <ref type="figure" target="#fig_10">5</ref>. The status blocks of the SGST are B S ={M 1 , M 2 }. It contains three possible circuits (n 1 , n 2 , n 1 ), (n 1 , n 3 , n 1 ) and (n 1 , n 2 , n 1 , n 3 , n 1 ). We suppose the evaluation order œâ=(M 2 , M 1 ). We fix a set of input values (i 1 , i 2 , i 3 , i 4 ) = (1, 1, 1, 0). Using Proposition 2, we obtain the trail œÑ =(n 1 , n 3 , n 1 , n 2 ), starting from the permanent node n 1 . We can observe that œÑ contains the circuit (n 1 , n 3 , n 1 ), but this circuit is quit to the node n 2 . However, if we fix the set of input values at (i 1 , i 2 , i 3 , i 4 ) = (1, 1, 0, 0), and start from node n 1 , we obtain the trail œÑ =(n 1 , n 3 , n 1 , n 3 ) that is equivalent to an indefinite traversal of the circuit (n 1 , n 3 , n 1 ).</p><formula xml:id="formula_15">M1_1 M2_1 i2 M1_1 M2_0 M 1 _0 M 2 _1 i4 i3 i1</formula><p>Generally, if for an input I v the progressive calculation of a the nodes of a trail œÑ results in visiting twice the same successive neighboring node couple (n k , n k+1 ), then œÑ corresponds to a circuit of nodes that can be indefinitely visited and the outputs of the blocks whose status values are changed in that trail are oscillating.</p><p>Definition 12 (Convergence property in a trail). We denote by T œâ SGST the set of all determined trails in the SGST that can be effectively traversed for an evaluation order œâ. A trail œÑ = (n 1 , n 2 , ..., n m ) ‚àà T œâ SGST is convergent if e k Ã∏ = e j ‚àÄe k = (n k , n k+1 ), e j = (n j , n j+1 ) two tuples of neighboring nodes in œÑ .</p><p>Definition 13 (Convergent logical diagram). We say that a logical diagram D is convergent for all the sets of input values if all the determined trails of its SGST D are convergent.</p><p>We propose a method for searching all the determined trails T œâ SGST for an evaluation order œâ. Trails are determined by giving their symbolic Boolean condition of traversal instead of the sets of input values. This means that a determined trail œÑ ‚àà T œâ SGST is defined by the sequence of its nodes œÑ = (n 1 , n 2 , ..., n m-1 , n m ) and its traversal condition C œÑ = k‚àà{1..m-1} label(e k = (n k , n k+1 )). Starting from each permanent node in the SGST we calculate all the possible trails based on the trail determination rule for an order œâ (Proposition 2). From each node we explore all the possible outgoing edges by negating the condition labels of edges alternating the blocks of the least order. Each label of an explored edge is added to C œÑ . For instance, let us suppose that a trail reaches a node n k coming from n k-1 and that n k that has two outgoing edges e 1 =(n k , n u ) and We suppose that ord œâ (b s n k-1 ‚Üín k ) &lt; ord œâ (b s n k ‚Üínu ) &lt; ord œâ (b s n k ‚Üínv ), for the order œâ. Since the status block altered by e 1 is of a lower order than the one altered by e 2 , if label(e 1 ) = T rue then e 1 is the next movement in œÑ , but if label(e 1 ) = F alse and label(e 2 ) = T rue then the next movement in œÑ is e 2 . Thus, two determined trails œÑ 1 and œÑ 2 can branch off from the determined trail œÑ at n k such that C œÑ1 = C œÑ ‚Ä¢ label(e 1 ) and C œÑ2 = C œÑ ‚Ä¢ label(e 1 ) ‚Ä¢ label(e 2 ). Both new trails continue the course and branch off to more possible trails at each bifurcation. Path exploration of a trail can stop in one of the following scenarios:</p><formula xml:id="formula_16">e 2 =(n k , n v ). œÑ = (n 1 , n 2 , ..., n k-1 , n k ), C œÑ = j‚àà{1..k-1} label(e k = (n j , n j+1 )).</formula><p>-If the last encountered node n k is a permanent node. Here, œÑ is a determined trail that puts the controller in the state of the node n k starting from the state of the initial node n 1 for all the input values I v that satisfy C œÑ . -If for the last encountered node n k , the update of the traversal condition C œÑ ‚Ä¢ label(e = (n k-1 , n k )) is False. This means that the trail is not possible due to a contradiction of the condition labels of the graph edges crossed by the trail.</p><p>-If the last two couple of nodes (n k-1 , n k ) have already been visited in œÑ . In this case œÑ corresponds to a circuit of nodes that can be effectively traversed an infinite number of times for the inputs values I v satisfying condition C œÑ .</p><p>Example 8. The SGST example of Figure <ref type="figure" target="#fig_2">2</ref> has only one permanent node n 1 .</p><p>Starting from n 1 , only two determined trails are possible in the case of the evaluation order œâ = (T 1 , M 2 ): </p><formula xml:id="formula_17">œÑ 1 = (n 1 , n 1 ), C œÑ1 = i 5 +i 2 ‚Ä¢i 3 +i 2 ‚Ä¢i 4 +i 3 ‚Ä¢i 1 +i 1 ‚Ä¢i 4 , œÑ 2 = (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>In this paper, we proposed a formal model, called the SGST graph, representing the possible states of a controller programmed based on a logical diagram specification. We show how to transform the logical diagram into the corresponding SGST graph, and how to verify the convergence property, i.e. verify that the controller does not have undesired oscillatory behavior.</p><p>Making sure that the behavior described by the logical diagram converges is crucial for test generation and for the overall verification and validation procedure. However, this is not the sole goal of transforming logical diagrams into SGST graphs. We developed the SGST to take a step in the application of the existing formal testing methods on logical diagrams. For the time being, generating tests derived from logical diagram specifications of power plants logical controllers is still handled manually or simulation-based. So, we designed the SGST to provide an explicit formal and exhaustive representation of the evolution steps between possible states of the controller described by a logical diagram. A test scenario is a sequence of these steps which are modeled with edges in the SGST . Therefore, the test sequences generation could be transposed into the application of existing graph traversal techniques such as the Chinese postman tour <ref type="bibr" target="#b13">[14]</ref>. The existing test generation ( <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b12">13]</ref>) and selection techniques are based on finite state machines specifications. We consider the SGST to be an important intermediate step to move from non-formal diagrams to state machines. A coded solution of the developed method has shown that the construction of the SGST is feasible for small to medium sized logical diagrams and provides very accurate graph representations. However, the SGST generation for diagrams with tens of memory and timer blocks is quite expensive in terms of complexity. This is due to the number of maximal states being in the worst case exponential to the number of blocks which can quickly lead to an explosion of the graph size.</p><p>We are currently working on methods to resolve the complexity problems such as the partition of the diagram into sub-diagrams and transforming them in SGST s then synchronizing them. Further work on complexity as well as transforming SGST graphs into state machines to apply test generation results in the literature for controllers described with logical diagrams will be handled in the future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of a logical diagram specification. More formally, a logical diagram specification is composed of I, the set of inputs of the diagram, O, the set of outputs of the diagram and B, the set of the logic blocks of the diagram. The logic blocks B connect the outputs O to the inputs I and define the function that relates them. B = B S ‚à™ B LG , namely:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>is P status = P T ON status ‚à™ P M status . Logic variables Vars. Logic gates B LG in the diagram can be developed into Boolean expressions over logic variables Vars by substituting them with their equivalent Boolean operator. Basically, we end up having outputs O and entries of B S blocks that are equal to Boolean expressions on Vars. Definition 2 (Vars and Exp V ars sets). We define Vars = I ‚à™ O B S by the set of logic variables, that includes I, the set of input variables of the logical diagram and O B S : the set of output variables of status blocks B s in the diagram.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. The SGST corresponding to the non-formal logical diagram given by Fig.1, obtained using our transformation procedure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Given a logical diagram D, we consider I D (the set of input variables of D) and B D (the set of logic blocks of D). As explained in the previous sections, B D =B D S ‚à™ B D LG , where B D S is the set of status blocks of D and B D LG is the set of logic gates of D. The SGST graph of the diagram D is denoted SGST D : (N D , E D ) and is constructed as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>4. 2</head><label>2</label><figDesc>Building the SGST edgesEdges that link the nodes in the graph are labelled with a logical expressions over Vars. If for a set of logic values of Vars, a Boolean expression that labels an edge starting from a node n S and arriving to a node n A is True, a change of status values of a B S block in the diagram takes place. The SGST D of a logical diagram D is developed to represent the evolution of states of the diagram in a formal model. The way this evolution works is defined by the evaluation process of the diagram by the controller. This evaluation is done in periodic cycles:1. Reading and saving the values of all input variables i k , where k ‚àà N. 2. Running a sequential evaluation algorithm on status blocks: at this point, each status block is evaluated, one after another, in accordance to the logic values at their entries and their last evaluated status value. The logic values at the entries of status blocks are obtained by the evaluation of logic gates connected to these entries in a left to right direction. We denote by œâ the order of the evaluation sequence of status blocks. 3. Evaluating outputs. Outputs o k are Boolean expressions of input variables I D and status blocks output variables O B S .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Proposition 1 .</head><label>1</label><figDesc>Let n 1 and n 2 be two nodes of N D and l N (n 1 ) = (¬µ 1 , ¬µ 2 , ..., ¬µ L ) and l N (n 2 ) = (Œª 1 , Œª 2 , ..., Œª L ) be their status values. n 1 and n 2 are two neighboring nodes and can possibly be linked by an edge in the SGST D if ‚àÉc ‚àà {1, ..., L}, with L = Card(B S D ), satisfying the following two conditions:-‚àÄk ‚àà {1, ..., L}\c, ¬µ k = Œª k ; we note that ¬µ k = n 1 (k) is the status value of b s k in n 1 and Œª k = n 2 (k) is the status value of b s k in n 2 where b s k are status blocks in B S D . n 1 (c) = ¬µ c Ã∏ = Œª c = n 2 (c) where b s c ‚àà B S Dis the only status block that changes value from ¬µ c in node n 1 to Œª c in node n 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Example 3 .</head><label>3</label><figDesc>evol ) add evol to EV OLM end for -An input i j ‚àà I D : in this case the logic value of this entry is equal to the logic value of the input variable x b s k = i j ; -The output of a status block b s j , with j Ã∏ = k: here, the entry takes the logic value of the output of the block b s j denoted by o b s j . Then, x b s k = o b s j ; -The output of a logic gate b LG : we denote by o b LG the output of the logic gate b LG ; then, x b s k = o b LG . The output o b LG of the logic gate b LG can be developed into a Boolean expression that uses the logic operator of the block b LG over its entries. Entries of b LG that are connected to the output of another logic gate are further developed into Boolean expressions and so on. This recursive development continues through all the encountered logic gates and stops at logic inputs I D and status block outputs O B S . The logical diagram of Figure 1 has two status blocks T 1 and M 2 with outputs denoted o T1 and o M2 , respectively. The block T 1 has a single entry x T directly connected to the output o M : x T = o M2 . The block M 2 has two input terminals denoted E and H.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 3</head><label>3</label><figDesc>A node in the SGST D encapsulates the status values of all the blocks B S D . Two nodes in N D can have one or many different status values. The sequential evaluation of the controller is reproduced in the graph by building edges that only link neighboring nodes that have the exact same status values of all blocks B S D except for one (see Proposition 1). An edge linking two neighboring nodes corresponds to an evolution evol ‚àà EV OL b s of a single status block b s . We propose Algorithm 5 for building the edges of the graph SGST D of a logical diagram D. For each node n k ‚àà N D of the SGST , the algorithm generates all the possible outgoing edges corresponding to all the evolution possibilities of all status blocks B S D from the node n k . Algorithms 3 and 4 are used in Algorithm 5 for neighboring nodes recognition and nodes logical sequences generation. Test whether n S and n A are neighboring nodes (see Proposition 1) Input: nS, nA ‚àà ND Output1: AreN eighbors ‚àà {T rue, F alse} Output2: c the index of the status block whose status value is changed from nS to nA AreN eighbors ‚Üê T rue dif f erences ‚Üê 0 ‚ñ∑ number of different status values between nS and nA for all k = 1 to Card</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Algorithm 4</head><label>4</label><figDesc>Build n seq S the logical values sequence of outputs O B S D equivalent to status values in n S (see Definition 6)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Trail building in an SGST graph. Two possible trails are valid for the same input values Iv in this example, depending on the order of evaluation of the three status blocks, M1, M2, M3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Example of multiple circuits in an SGST graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Trail traversal condition update.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Definition 4 (l E function). For a given set of logic variables Vars, the labeling function of the edges of the SGST graph l E : E ‚Üí Exp V ars , assigns a logical expression including logic variables from Vars to e ‚àà E in the SGST .</figDesc><table><row><cell>n S</cell><cell>n A</cell></row><row><cell>e = (nS, nA)</cell><cell></cell></row><row><cell>{ nS(1), nS(2),..., nS(L) }</cell><cell>{ nA(1), nA(2),..., nA(L) }</cell></row><row><cell>label ? ExpVars</cell><cell></cell></row></table><note><p>Fig. 3. SGST graph representation: example of two states nS and nA linked with a transition e. An edge e of the SGST graph links two states, from the starting node nS to the arrival node nA. The edge e is labelled with a Boolean expression label from the ExpV ars set. The starting and arrival nodes are labelled with a set of L status values, where L is the total number of status blocks in the logical diagram, i.e. Card(B S ) = L. The set ExpV ars contains Boolean expressions on logic variables in Vars. The set Vars = I ‚à™ O B S contains both the input variables I of the logical diagram, and the output variables O B S of status blocks B S in the logical diagram.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Definition 10 (permanent node). Let n k ‚àà N D be a node, and E n k ‚äÇ E D the set of outgoing edges from the node n k . We say that the node n k is a permanent node if ‚àÉ I v , a set of input values, satisfying the holding on condition of the node n k : C Hold = ei‚ààEn k label(e i ). For the SGST graph given in Figure2, node n 2 has two outgoing edges labeled i 5 and T rue. The holding on condition of node n 2 is C Hold = i 5 ‚Ä¢ T rue = F alse. This condition is False for any set of input values I v ; thus, n 2 is not a permanent node. The node n 1 has only one outgoing edge labeled i 5</figDesc><table><row><cell>Example 6.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>n 1 , n 2 , n 3 , n 4 , n 6 , n 1 , n 2 ), C œÑ2 = i 5 ‚Ä¢ (i 1 + i 4 ) ‚Ä¢ (i 1 + i 3 ) ‚Ä¢ (i 4 + i 2 ) ‚Ä¢ (i 2 + i 3 ).œÑ 2 does not converge meaning that for any set of input values I v that satisfies C œÑ2 the nodes of œÑ 2 are visited indefinitely which causes oscillating signals in the controller.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>We refer to the implemented logical diagram specification as a logic controller.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>traversal determination rule (n k-1 , n k ) ‚Üí n k+1 : the next viable edge (n k , n k+1 ) to be traversed is the one that alters the status value of the block b s n k ‚Üín k+1 of the lowest order in œâ after b s n k-1 ‚Üín k the block whose status value changed from n k-1 to n k .</p><p>Proposition 2 (edge traversal determination rule). Let œâ ‚àà (B S ) L , be an order of the evaluation sequence of status blocks, L = Card(B S ). Let us suppose that for a set of input values I v , the controller is placed in the state of node n k , coming from the previous node n k-1 ; between these two nodes, the status value of the block b s n k-1 ‚Üín k has changed. Let N next be the set of all the reachable nodes from n k by the viable edges e =(n k ,n next ), with n next ‚àà N next . Then, the next node n k+1 ‚àà N next to be effectively visited in the trail is satisfying:</p><p>) is the order of evaluation of the block b s n k ‚Üínj in œâ; b s n k ‚Üínj is the status changing block from n k to n j .</p><p>Example 5. Let us consider a logical diagram with three status blocks of memory type B S = {M 1 , M 2 , M 3 }; the corresponding SGST graph is illustrated in Figure <ref type="figure">4</ref>, and has four nodes and three edges. We fix the set of inputs values (i 1 ,</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A theory of timed automata</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Dill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical computer science</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="235" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient simulation of oscillatory combinational loops</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fayyazi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Kirsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Design Automation Conference</title>
		<meeting>the 47th Design Automation Conference</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="777" to="780" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Hery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C L</forename></persName>
		</author>
		<title level="m">Stabilit√© de la sp√©cification logique du contr√¥lecommande -m√©thodologie et mise en oeuvre</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
		<respStmt>
			<orgName>EDF R&amp;D</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. rep.</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Instrumentation and control important to safety-general requirements for systems</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">P</forename><surname>Iec</surname></persName>
		</author>
		<idno>iec 61513</idno>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>International Electrotechnical Commission</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Principles and methods of testing finite state machines-a survey</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="1090" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Removing cycles in esterel programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lukoschus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Von Hanxleden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP Journal on Embedded Systems</title>
		<imprint>
			<biblScope unit="page" from="1" to="23" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Analysis of cyclic combinational circuits</title>
		<author>
			<persName><forename type="first">S</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="950" to="956" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">An efficient algorithm for the analysis of cyclic circuits</title>
		<author>
			<persName><forename type="first">O</forename><surname>Neiroukh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Song</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISVLSI.2006</idno>
		<ptr target="https://doi.org/10.1109/ISVLSI.2006" />
		<imprint>
			<date type="published" when="2006-04">2006. 04 2006</date>
			<biblScope unit="page">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Black box checking</title>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods for Protocol Engineering and Distributed Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="225" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Translating grafcet specifications into mealy machines for conformance test purposes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Provost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Roussel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Faure</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Control Engineering Practice</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="947" to="957" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Cyclic combinational circuits</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Riedel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>California Inst. of Technology</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Constructive analysis of cyclic circuits</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Shiple</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Touati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings ED&amp;TC European Design and Test Conference</title>
		<meeting>ED&amp;TC European Design and Test Conference</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="328" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Testing timed automata</title>
		<author>
			<persName><forename type="first">J</forename><surname>Springintveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vaandrager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>D'argenio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical computer science</title>
		<imprint>
			<biblScope unit="volume">254</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="225" to="257" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The directed chinese postman problem</title>
		<author>
			<persName><forename type="first">H</forename><surname>Thimbleby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1081" to="1096" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
