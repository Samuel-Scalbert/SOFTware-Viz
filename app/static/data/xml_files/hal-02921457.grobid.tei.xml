<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Revisiting RDF storage layouts for efficient query answering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Institut Polytechnique de Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">IRISA</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Institut Polytechnique de Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tayeb</forename><surname>Merabti</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Institut Polytechnique de Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<email>mugnier@lirmm.fr</email>
						</author>
						<author>
							<persName><forename type="first">M.-L</forename><surname>Mugnier</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">Univ Montpellier</orgName>
								<orgName type="institution" key="instit2">LIRMM</orgName>
								<address>
									<settlement>Inria</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Revisiting RDF storage layouts for efficient query answering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FA8B741B9A23052F10F7FDD36DA200F9</idno>
					<note type="submission">Submitted on 25 Aug 2020</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We consider the problem of efficiently querying an RDF database, which stores RDF graphs persistently (e.g., on a disk) and allows queries and updates on the graphs, possibly concurrently by several users. We are interested in answering queries on a graph, taking into account an RDF Schema (RDFS, in short) ontology and associated RDFS entailment. We consider general SPARQL conjunctive queries (a.k.a. basic graph pattern queries, or BGPQs), which allow variables in any subject, property, or object position of query triples. For instance, in the query q(x, u) ← (x, :name, :Alice), (x, y, z), (z, rdf:type, u), where x, y, z, u are variables and the other terms are IRIs, the property y in the second triple is a variable, just like u which is the type of z. Such queries allow to fully take advantage of the freedom RDF provides: one does not need to know the relation between x and z, nor the exact type of z, to query the graph. Answering a BGPQ in an RDF database requires translating it into a description of work that the execution engine must perform; without loss of generality, we call this work description a query plan, as is common in the database literature. Specifically, we distinguish a logical plan specifying the operations to use to answer the query, from a physical (executable) plan, derived from the logical one with the help of statistics and cost parameters characterizing the data (size, value frequencies etc.) and the execution environment (hardware etc.)</p><p>Both plans start by accessing some data from the store and continue with various other processing steps (e.g., filtering, combining multiple inputs etc.). The set of persistent data structures that hold the data of an RDF graph in the database are called storage layout. When a set of frequent BGPQs are known in advance, they can be used to design a workload-aware layout, which optimizes data access for these queries, e.g., <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b12">15,</ref><ref type="bibr" target="#b17">20]</ref>. Lacking a known query set, a workload-unaware layout is used, with the two most popular being: T (triple), e.g., <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b22">25,</ref><ref type="bibr" target="#b16">19]</ref>, which stores all triples together as a single (s, p, o) (subject, predicate, object) collection; and CP (class and property) <ref type="bibr" target="#b1">[4]</ref>, which separates the data for each property and class, i.e., as (i) a collection of (s, o) pairs for every property p, and (ii) a collection of all the resources s that have a given type c in the graph. Indexes can be added to both the T and CP layouts. In this work, we focus on translating BGPQs, including general ones, for query answering under RDFS ontologies and entailment, into logical plans, on workload-unaware layouts. We target logical plans for generality, since physical plans strongly depend on the RDF database implementation, the presence of indexes etc.; these decisions are best left to the optimization and execution layer, and we do not study them here. However, as we will show, the choice of the logical plan can massively impact the space of alternatives (physical plans) considered for the query, and thus the query answering performance. In particular, we translate our plans in SQL (if the RDF database has a relational back-end) or SPARQL (if a native RDF engine evaluates them), which enables to retain all benefits of system-specific optimization. We study translation for the two classical ways of taking the ontology into account for query answering: by materializing entailed triples in the RDF graph (graph saturation) or by compiling relevant parts of the ontology in the query, which yields a union of BGPQs (query reformulation). Our contributions are the following: G ex = (:OpenArt, ≺ sc , :Article), (:GOpenArt, ≺ sc , :OpenArt), (:Prof, ≺ sc , :Person), (:teaches, ← d , :Prof), (:author, → r , :Person), (:firstAuth, ≺ sp , :author), (:art1, :title, "RDF storage"), (:Alice, :name, "Alice")(:art1, :firstAuth, :Alice), (:Alice, :teaches, :algo101), (:art1, :author, :Bob), (:Bob, :name, "Bob"), (:art1, rdf:type, :GOpenArt) Fig. <ref type="figure">1</ref>. Sample RDF graph Gex (schema triples on top and data triples below).</p><p>introducing the CP layout <ref type="bibr" target="#b1">[4]</ref>). Section 4 presents our technical contributions and Section 5 our experiments. We then discuss related works and conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We rely on three pairwise disjoint sets of values: the sets I of IRIs (resource identifiers), L of literals (constants) and B of blank nodes modeling unknown IRIs or literals. A triple (s, p, o) ∈ (I ∪ B) × I × (L ∪ I ∪ B) states that its subject s has the property p with the object value o [1]. We denote by Val(G) the set of all values (IRIs, blank nodes and literals) occurring in an RDF graph G. In triples, we use :b (possibly with indices) to denote blank nodes, and strings between quotes to denote literals. We distinguish schema triples from data ones. The former state RDF Schema (RDFS) constraints on classes and properties: subclass (specialization relation between classes), subproperty (specialization relation between properties), domain (typing of the first attribute of a property), and range (typing of the second attribute of a property). An RDFS ontology (or ontology, in short) is a set of schema triples. The ontology of an RDF graph G is the set of schema triples of G. The other triples, i.e., data triples, describe data by typing resources with classes or stating how resources are related through properties. Table <ref type="table" target="#tab_0">1</ref> introduces our short notations for schema and data triples. Example 1 (Running example). Figure <ref type="figure">1</ref> shows a sample graph G ex , describing articles and their authors; some articles are Open Access (:OpenArt), a subclass of which are Green Open Access ones (:GOpenArt).</p><p>An entailment rule (or simply rule) r has the form body(r) → head(r), where body(r) and head(r) are RDF graphs, respectively called body and head of the rule r. In this work, we consider the set of RDFS entailment rules R shown in Table <ref type="table" target="#tab_2">2</ref>, which allow reasoning with an RDFS ontology; in the table, all values except RDF reserved IRIs are blank nodes. These rules either combine schema triples to entail schema triples (rdfs5, rdfs11, ext1 to ext4), or combine schema triples together with data triples to entail data triples (rdfs2, rdfs3, rdfs7 and  </p><formula xml:id="formula_0">I ∪ B ∪ V ) × (I ∪ V ) × (I ∪ B ∪ L ∪ V ).</formula><p>The set of variables (resp. values: IRIs, blank nodes, literals and variables) occurring in a BGP P is denoted by Var(P) (resp. Val(P )). Note that a variable may occur in any position of a triple pattern. In particular, we say that a variable x occurs in property position for a triple of the form (-, x, -) and in class position for a triple of the form (-, τ, x). Definition 1 (BGPQ). A BGPQ q is of the form q(x) ← P , where P is a BGP (also denoted body(q)) and x ⊆ Var(P) are the answer variables of q.</p><p>For simplicity, below, we will assume that BGPQs have no blank nodes, as it is well-known that these can be replaced by non-answer variables <ref type="bibr">[3]</ref>. We also consider a slight generalization of BGPQs, namely partially instantiated BGPQs: such queries are obtained from BGPQs by substituting some variables with values from I ∪L ∪B. For simplicity again, we will not distinguish between a standard and a partially instantiated BGPQ. The semantics of a BGPQ on a graph is defined through homomorphisms from the query body to the graph: Definition 2 (BGP-to-RDF homomorphism). A homomorphism from a BGP P to an RDF graph G is a function ϕ from Val(P ) to Val(G) such that for any triple (s, p, o) ∈ P , the triple (ϕ(s), ϕ(p), ϕ(o)) is in G, with ϕ the identity on IRIs and literals.</p><p>We distinguish query evaluation, whose result is just based on the explicit graph triples, from query answering that also accounts for its implicit triples. Definition 3 (Evaluation and answering). Let q be a (partially instantiated) BGPQ. The answer set to q on a graph G w.r.t. rule set R is:</p><formula xml:id="formula_1">q(G, R) = { ϕ(x) | ϕ homomorphism from body(q) to G R }. If x = ∅, i.e.</formula><p>, q is a Boolean query, q is true iff q(G, R) = { }. The evaluation of q on G, denoted q(G, ∅), or q(G) in short, is obtained through homomorphisms from body(q) to G only. These notions and notations naturally extend to unions of (partially instantiated) BGPQs, or UBGPQs in short.</p><p>Example 3 (Example query). Consider the BGPQ asking who is writing which kind of articles: q(x, y) ← (z, :author, x), (z, τ, y), (y, ≺ sc , :Article). Its evaluation on G ex is empty. However, the answer set of q on G ex w.r.t. R is q(G ex , R) = { :Alice, :GOpenArt , :Alice, :OpenArt , :Bob, :GOpenArt , :Bob, :OpenArt }.</p><p>Many RDF data management systems use saturation-based query answering, i.e., query evaluation on the previously saturated graph; clearly, from the above definition, q(G, R) = q(G R ) holds. An alternative technique is reformulationbased query answering, e.g., <ref type="bibr" target="#b3">[6,</ref><ref type="bibr" target="#b15">18,</ref><ref type="bibr" target="#b6">9]</ref>, which injects the ontological knowledge into a reformulated query, whose simple evaluation on G yields the complete answer set of the original query. More precisely, given a BGPQ q asked on a graph G, the reformulation of q w.r.t. to R and the ontology of</p><formula xml:id="formula_2">G, denoted Q R , is such that q(G, R) = Q R (G).</formula><p>A property of the technique proposed in <ref type="bibr" target="#b6">[9]</ref>, on which we rely in this paper, is that the reformulated query does not contain schema triples anymore; intuitively, such triples are evaluated on the ontology of the queried graph during the query reformulation. Further, from now on, we assume that (U)BGPQs, in particular those produced through reformulation, are minimal: non-minimality incurs redundancy of triples in BGPQs, or of BGPQs within UBGPQs. Well-known query minimization techniques exist for this purpose.</p><p>Example 4. The reformulation of the example query q (Example 3) is:</p><formula xml:id="formula_3">Q R =</formula><p>q(x, :OpenArt) ← (z, :author, x), (z, τ, :OpenArt) ∪ q(x, :OpenArt) ← (z, :firstAuth, x), (z, τ, :OpenArt) ∪ q(x, :OpenArt) ← (z, :author, x), (z, τ, :GOpenArt) ∪ q(x, :OpenArt) ← (z, :firstAuth, x), (z, τ, :GOpenArt) ∪ q(x, :GOpenArt) ← (z, :author, x), (z, τ, :GOpenArt) ∪ q(x, :GOpenArt) ← (z, :firstAuth, x), (z, τ, :GOpenArt)</p><formula xml:id="formula_4">It can be checked that Q R (G ex ) = q(G ex , R).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BGPQ answering through translation on T and CP</head><p>We now detail how (saturation-or reformulation-based) query answering can be performed on the T and the CP storage layouts (Sections 3.1 and 3.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">BGPQ answering on the T layout</head><p>Let t(S, P, O) be the table storing the triples of a graph G for the T layout. Saturation-based query answering. The saturation G R of G is stored in the table t. The algebraic translation of a BGPQ q(x) ← t 1 , . . . , t n on the T layout is:</p><formula xml:id="formula_5">T (q) = π q ( jcond (α T (t 1 ), . . . , α T (t n ))</formula><p>where α T , the query triple translation for the T layout, translates the i-th query triple t i (s i , p i , o i ) into an algebraic expression of the form σ scond (t), where t is the triple table, and scond is a (possibly empty) set of selections over the attributes of t; specifically, if s i (respectively, p i , o i ) is an IRI or a literal, scond contains a predicate of the form S = s i (and similarly for p i , o i ); jcond is a conjunction of join predicates containing, for every variable appearing in several positions (in one or several triples) in q, an equality between the respective attributes in the α T (t i ) triple translations; finally π q is a projection on the attributes from the α(t i )'s corresponding to the answer variables of q, or the values to which such variables are bound in case of a partially instantiated query. Example 5. The example query translates on the T layout as:</p><formula xml:id="formula_6">π t1.O,t2</formula><p>.O ( t1.S=t2.S,t2.O=t3.S (σ P =:author (t), σ P =τ (t), σ P =≺sc∧O=:Article (t)))</p><p>In the above, the selection σ P =:author (t) restricts the triples from the t table to those having the attribute P equal to :author. Similarly, σ P =τ (t) corresponds to the selection P = τ . On the atom t 3 , α T applies a double selection σ P =≺sc∧O=:Article (t), since t 3 has only one variable in position S. Further, jcond = t1.S=t2.S,t2.O=t3.S joins the three previous selections, where t 1 .S = t 2 .S and t 2 .O = t 3 .S respectively reflect the co-occurrences of variables z and y. The final projection π t1.O,t2.O returns the pairs of values obtained for (x, y).</p><p>Reformulation-based query answering. Here, the graph G is stored in t (but not its saturation), and every incoming BGPQ q is reformulated into a (partially instantiated) UBGPQ Q R = n i=1 q i , whose algebraic translation on the T layout is the union of the algebraic translations of its (partially instantiated) BGPQs:</p><formula xml:id="formula_7">T (Q R ) = n i=1</formula><p>T (q i ) Example 6. Consider again the example query q and its reformulation Q R shown in Example 4. The algebraic translation T (Q R ) is: π t1.O,:OpenArt ( t1.S=t2.S (σ P =:author (t), σ P =τ ∧O=:OpenArt (t)) ∪ π t1.O,:OpenArt ( t1.S=t2.S (σ P =:firstAuth (t), σ P =τ ∧O=:OpenArt (t)) ∪ π t1.O,:OpenArt ( t1.S=t2.S (σ P =:author (t), σ P =τ ∧O=:GOpenArt (t)) ∪ π t1.O,:OpenArt ( t1.S=t2.S (σ P =:firstAuth (t), σ P =τ ∧O=:GOpenArt (t)) ∪ π t1.O,:GOpenArt ( t1.S=t2.S (σ P =:author (t)), σ P =τ ∧O=:GOpenArt (t)) ∪ π t1.O,:GOpenArt ( t1.S=t2.S (σ P =:firstAuth (t), σ P =τ ∧O=:GOpenArt (t))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">BGPQ answering on the CP layout</head><p>With the CP layout, an RDF graph is stored as a set of tables corresponding to classes and properties: for each class c, there is a table t c (S) that stores all subjects s of triples (s, τ, c), and for each data or schema property p = τ , there is a table t p (S, O) that stores all subject-object pairs (s, o) for triples (s, p, o). We call any such t c a class table, and t p a property table. The CP layout speeds up data access for queries which specify the class in every triple whose property is τ and specify the property in every triple. However, as noted e.g., in <ref type="bibr" target="#b18">[21]</ref>, it may render the evaluation of general queries, with variables in class or property position, inefficient, as the triples they refer to may be in any t c or t p tables, respectively. Saturation-based query answering. Assume that G R is stored using the CP layout. To obtain the answers to a BGPQ q(x) ← t 1 , . . . , t n , a first simple naïve translation, which can be traced back to <ref type="bibr" target="#b1">[4,</ref><ref type="bibr" target="#b18">21]</ref>, is:</p><formula xml:id="formula_8">CP (q) = π q ( jcond (α CP (t 1 ), • • • , α CP (t n )))</formula><p>where π q and jcond are defined as for the T layout, and α CP , the query triple translation for the CP layout, is:</p><formula xml:id="formula_9">α CP (t) =        π S,τ,c (σ scond (t c )) if t = (s, τ, c) with c ∈ V (1) π S,p,O (σ scond (t p )) if t = (s, p, o) with p ∈ V ∪ {τ } (2) c∈C α CP ((s, τ, c)) if t = (s, τ, x) with x ∈ V (3) α CP ((s, τ, o)) ∪ p∈P α CP ((s, p, o)) if t = (s, x, o) with x ∈ V (4)</formula><p>where C and P are, respectively, the set of classes and of properties other than τ in the queried graph, and scond is a (possibly empty) conjunction of selections, just as we defined it for α T , but over the class and property tables instead of the triple table t.</p><p>Example 7. The naive translation of the example query q on the CP layout is: Note that in cases (3) and ( <ref type="formula">4</ref>) above, α CP introduces unions under joins, as illustrated by the previous example. This leads to suboptimal evaluation performance in many data management engines, which may optimize and execute efficiently a join over several data collections, but do not attempt to reorder (commute) joins with unions. For instance, the query (x, :a, :a 1 ), (x, y, z), (z, τ, u), (z, :b, :b 1 ) translates into a plan that joins (among others) the union of all the tables (for (x, y, z)) with the union of all class tables (for (z, τ, u)). Most systems execute this "literally", i.e., they build and materialize these two very large unions, which is very costly, before joining them with the first and last triple <ref type="foot" target="#foot_0">6</ref> .</p><formula xml:id="formula_10">π t 1 .O,t 2 .O ( t 1 .S=t 2 .S,</formula><p>To avoid such unions under joins, we rely on the notion of instantiation, which has been used in various query answering techniques e.g., <ref type="bibr" target="#b12">[15,</ref><ref type="bibr" target="#b15">18]</ref>: Query instantiation. The instantiation of a BGPQ q consists in instantiating the variables in q that must be bound to classes and properties of the queried graph, in all possible ways, which yields a (partially instantiated) UBGPQ. Given a BGPQ q and a graph G, we denote by q p,G (resp. q c,G ) its property instantiation (resp. class instantiation), which is the UBGPQ obtained by instantiating all its variables in property position (resp. in class position), by all combinations of properties (resp. classes) of G.</p><p>Example 8. The class instantiation q c,Gex of the example query q, where the only instantiated variable is y, is:</p><p>q(x, :GOpenArt) ← (z, :author, x), (z, τ, :GOpenArt), (:GOpenArt, ≺ sc , :Article) ∪ q(x, :OpenArt) ← (z, :author, x), (z, τ, :OpenArt), (:OpenArt, ≺ sc , :Article) ∪ q(x, :Article) ← (z, :author, x), (z, τ, :Article), (:Article, ≺ sc , :Article) ∪ q(x, :Prof) ← (z, :author, x), (z, τ, :Prof), (:Prof, ≺ sc , :Article) ∪ q(x, :Person) ← (z, :author, x), (z, τ, :Person), (:Person, ≺ sc , :Article)</p><p>Class and property instantiations extend from BGPQs to UBGPQs in the natural way. Given a UBGPQ of the form Q = q 1 ∪ q 2 • • • ∪ q n , we set:</p><formula xml:id="formula_11">Q p,G = q p,G 1 ∪ q p,G 2 • • • ∪ q p,G n and Q c,G = q c,G 1 ∪ q c,G 2 • • • ∪ q c,G n</formula><p>Then, the instantiation of Q w.r.t. a graph G is the following:</p><formula xml:id="formula_12">Q G = (Q c,G ) p,G ∪ (Q p,G ) c,G</formula><p>We need both terms of the above union, exactly in the case when some variable of Q appears both in a property and in a class position. These cases are rare and easy to detect, thus in practice we only use one of the unions as soon as we detect both are not needed. Crucially, (U)BGPQ instantiation is correct for saturation-and reformulation-based query answering. Intuitively, this is because instantiation enumerates all possible combinations of classes and properties that query reformulation or evaluation may find in G.</p><p>We can now define the instantiation-based query translation. A BGPQ q is first instantiated into q G = n i=1 q i , then translated on the CP layout as:</p><formula xml:id="formula_13">CP (q G ) = n i=1 CP (q i )</formula><p>Importantly, because q G does not contain any variable in class or property position, every naïve translation CP (q i ) within CP (q G ) avoids both (3) or (4) in the α CP triple transformation function. Hence, the translation avoids the introduction of unions under joins, with their potential bad impact on performance. Example 9. Consider the query q and its instantiation q Gex = q c,Gex in Example 8. The instantiation-based translation of q corresponds to the naïve translation of q Gex : u∈{:GOpenArt,:OpenArt,:Article,:Prof,:Person} π t1.O,u ( t1.S=t2.S,t2.O=t3.S (π S,:author,O (t :author ), π S,τ,u (t u ), π S,≺sc,O (σ S=u,O=:Article (t ≺sc ))</p><p>Reformulation-based query answering. The graph G is again stored using the CP layout (but not saturated). In this case, answering a BGPQ q starts by computing its reformulation Q R w.r.t. the ontology of G. Then, we obtain the answers q(G, R)</p><formula xml:id="formula_14">either through CP (Q R ), the naïve translation of Q R , or through CP (Q G R ), the instantiation-based translation of Q R , i.e.</formula><p>, the naïve translation of its instantiation Q G R ; as in the previous section, the algebraic translation of a UBGPQ is defined as the union of the algebraic translations of its BGPQs. Instantiating Q R generally increases its size, but, by removing variables in class and property positions, it avoids the unions under joins introduced in cases (3) and ( <ref type="formula">4</ref>) by the α CP triple translation function.</p><p>Example 10. Consider the query q and its reformulation Q R from Example 4. Here, since no variable of Q R occurs in class or property position, CP (Q R ) and CP (Q G R ) lead to the same algebraic expression: 4 Taming general BGP answering performance</p><formula xml:id="formula_15">π t1.</formula><p>Below, we present our technical contributions: the TCP layout and its algebraic translation (Section 4.1), and summary-based pruning (Section 4.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">BGPQ answering based on the TCP layout</head><p>The TCP layout combines T and CP with the aim of getting the best of both, while avoiding the performance problems they respectively entail (Sections 3.1 and 3.2). Here, an RDF graph is stored both in the triple table t of the T layout and in the t c class and t p property tables of the CP layout. The rationale behind this is that CP is efficient to access triples when the data structures holding the triples we need to access are immediately clear from the query, and small ; this is the case with query triples of the form (s, τ, c) or (s, p, o) for a known class c or property p. However, with query triples of the form (s, τ, x) and (s, x, o), the CP translation introduces unions, typically executed before joins, degrading performance. Interestingly, direct access to a potentially large share of a graph's triples is exactly what the T layout supports well -thus our idea to combine them. As we show in the next section, this allows to significantly improve performance, at expense of some extra storage space, typically inexpensive since it is on disk. Saturation-based query answering. Let us assume that the saturation G R of a graph G is stored in the TCP layout. The answers to a BGPQ q ← t 1 , . . . , t n are obtained through its algebraic transformation for the TCP layout:</p><formula xml:id="formula_16">T CP (q) = π q ( jcond (α T CP (t 1 ), • • • , α T CP (t n )))</formula><p>where π q and jcond are defined as for the T and CP layouts, and α T CP , the query triple translation for the TCP layout, is: Reformulation-based query answering. Again, the answers to a query q are computed by evaluating the algebraic translation of its reformulation Q R = n i=1 q i , but now for the TCP layout:</p><formula xml:id="formula_17">α T CP (t) = α CP (t) if t = (s, τ, c) or t = (s, p, o) with c ∈ V , p ∈ V ∪ {τ } α T (t)</formula><formula xml:id="formula_18">T CP (Q R ) = n i=1</formula><p>T CP (q i ) Example 12. Consider the query q(x, y, z) → (x, τ, z), (x, :firstAuth, y) asking for all resources with their type and first author. Its reformulation w.r.t. G ex 's ontology is shown below (the last four union terms are omitted for space reasons):</p><formula xml:id="formula_19">Q R = q(x</formula><p>, y, z) ← (x, τ, z), (x, :firstAuth, y) ∪ q(x, y, :Article) ← (x, τ, :OpenArt), (x, :firstAuth, y) ∪ q(x, y, :Article) ← (x, τ, :GOpenArt), (x, :firstAuth, y) ∪ q(x, y, :OpenArt) ← (x, τ, :GOpenArt), (x, :firstAuth, y) ∪ q(x, y, :Person) ← (x, τ, :Prof), (x, :firstAuth, y) . . . </p><formula xml:id="formula_20">Its</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Summary-based query pruning</head><p>We now introduce an optimization technique, which can be applied on any storage layout to reduce (U)BGPQ answering time. It allows detecting some BGPQs with an empty answer set on a graph, without evaluating them, by using a (typically much smaller) structural summary of this graph. Given an RDF graph G and an equivalence relation ≡ among the nodes in G, i.e., the subjects and objects of triples, an RDF quotient summary <ref type="bibr" target="#b9">[12]</ref> is an RDF graph G /≡ built as follows. A node is created in G /≡ for each equivalence class among G's nodes; further, for any triple (n 1 , p, n 2 ) ∈ G, the triple (m 1 , p, m 2 ) appears in G /≡ , where m 1 and m 2 represent the equivalence class of n 1 and n 2 respectively. If there are large equivalence classes in G, summarization is a form of compression. Several types of RDF quotient summaries have been proposed <ref type="bibr" target="#b9">[12]</ref>; in our experiments, we used the RDFQuotient summary construction tool <ref type="bibr" target="#b11">[14]</ref>, due to its online availability and low summary construction cost (linear in the number of triples of G). An RDFQuotient summary represents each class and property node by itself, and consider they are not equivalent to any other G node; thus, G and any quotient summary G /≡ have the same schema triples. Crucially, it holds that if q(G /≡ ) = ∅ then q(G) = ∅, for q a structural (U)BGPQ, i.e., in which the subjects and objects of query triples are either class and property IRIs, or variables. Intuitively, this result holds because structural queries only allow selecting subject, property and object values that are preserved through summarization (class and property IRIs). Note however that the opposite does not hold in general, i.e., q(G /≡ ) may have results while q(G) does not. We exploit this result by defining the structural version of a BGPQ q, denoted q str , which is obtained by replacing in q the literals and the IRIs that are not class or property IRIs, by fresh variables. For example, the structural version of the query q(x) ← (x, τ, :OpenArt), (x, :firstAuth, :Alice) is: q str (x) ← (x, τ, :OpenArt), (x, :firstAuth, y), with :Alice replaced by y. Hence, when a summary G /≡ is available, we can use it to prune a UBGPQ Q = i q i by removing from the union all the q i terms for which q str i (G /≡ ) = ∅. As explained above, this may fail to prune some q i with no results on G, but it preserves query results:</p><formula xml:id="formula_21">Q(G) = Q pruned (G)</formula><p>where Q pruned is the result of pruning Q. As our experiments will show, this generally leads to a significant reduction of query answering time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental evaluation</head><p>We now describe experiments comparing the query answering methods presented in the previous sections, on the T, CP and TCP layouts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental settings</head><p>We implemented the T, CP and TCP layouts in OntoSQL (https://ontosql. inria.fr), a Java platform providing efficient RDF storage and saturation-and reformulation-based query answering on top of an RDBMS <ref type="bibr" target="#b6">[9,</ref><ref type="bibr" target="#b7">10,</ref><ref type="bibr" target="#b13">16]</ref> (Postgres 9.6 in these experiments). OntoSQL encodes IRIs and literals as integers, and a dictionary table allows going from one to the other; each table (t, t p or t c ) is indexed on all the subsets of its attributes. To use OntoSQL, we express our algebraic translations in SQL. We checked that in Postgres query plans, the relative positions of unions and joins in the query plans chosen by the RDBMS are those from our translations; <ref type="bibr" target="#b7">[10,</ref><ref type="bibr" target="#b8">11]</ref> showed that this holds for two other major RDBMSs. However, the RDBMS takes all optimization decisions, based on its cost model and statistics. To put this into perspective also with respect to native RDF engines, we ran the same experiments also on Virtuoso Open Source Edition 7.2, to whom we provided SPARQL queries, which correspond exactly to our algebraic translation on the T layout. Virtuoso also controls its optimization decisions, and has full control over its store. For summary-based pruning, we used the RDFQuotient (https://rdfquotient. inria.fr) tool to build the "typed strong" summary <ref type="bibr" target="#b11">[14]</ref> of a graph G; this summary is denoted G /TS . The summary groups typed nodes according to their types, and untyped nodes by exploiting the similarity of their incoming/outgoing properties (see <ref type="bibr" target="#b11">[14]</ref> for details). In general, any quotient summary could be used; a large (more detailed) summary makes pruning more accurate, but also slower since it needs to query the summary. Hardware We used a server with 2,7 GHz Intel Core i7 processors and 160 GB of RAM, running CentOs Linux 7.5.  <ref type="table">3</ref>. Graph and summary sizes (number of triples), OntoSQL database sizes (in GB), including all indexes, for the T, CP and TCP layouts.</p><formula xml:id="formula_22">Graph |G| |G /TS | |G R | |(G R ) /TS | |G|T |G|CP |G|TCP |G R |T |G R |CP |G R |TCP LUBM 100M</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RDF graphs</head><p>We used two benchmark graphs: a LUBM <ref type="bibr" target="#b14">[17]</ref> graph of 100M triples, as well as a graph of DBLP bibliographic data endowed with an ontology of 14 classes and 44 schema triples. Table <ref type="table">3</ref> shows, for these graphs and their saturation, the graph and summary sizes, and the sizes of the OntoSQL databases storing them in the T, CP and TCP layout. As expected, TCP takes most space, approx. 90% of the sum of the T and CP database sizes. However, this is stable storage (e.g., disk) space; the selective data access enabled by the class and property tables, and by indexes, as well as cost-based optimization, ensure that the data loaded in memory to process a query is much smaller.</p><formula xml:id="formula_23">Query Q01 Q02 Q03 Q04 Q05 Q06 Q07 Q08 Q09 Q10 Q11 Q12 Q13 Q14 |q(G, R)| 2.78M 0.59M 2.</formula><p>Queries We used two diverse sets of queries, having from 1 to 11 triples (4 on average) on LUBM, and from 2 to 9 triples (5.9 on average) on DBLP. Each query has 1 or 2 triple(s) of the form (s, τ, x) and/or (s, x, o), except Q11 and Q15 on DBLP which do not contain any. Table <ref type="table" target="#tab_8">4</ref> shows their number of answers, and the number of BGPQs in: their instantiation (q G ), reformulation (Q R ), and instantiation of their reformulation (Q G R ), before and after summary-based pruning. The impact of pruning ranges from none (in particular for q G , on LUBM Q01 to Q03 and on 8 DBLP queries) to very significant (97.8% of the q G BGPs are pruned on LUBM Q09). Details on our experiments, and code which can be used to reproduce them, are online 5 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experiment results: query answering times</head><p>For each query, we report the average of the last five ("hot") runs out of six. Through saturation Figure <ref type="figure" target="#fig_0">2</ref> shows the query answering times through saturation, for LUBM (top) and DBLP (bottom), with a timeout of 10 minutes; in all our graphs, executions that reached the timeout have been interrupted. Below the graphs, we show the label used in the plot for each query answering strategy, e.g., T SAT stands for T (q)(G R ). For readability, some very fast queries are repeated in a "zoom" plot (the LUBM one has a logarithmic y axis). On LUBM (top), we notice some very high running times for VIRTUOSO SAT, e.g., on Q03, Q06, and a time-out on Q14. Among the SQL-based strategies, the naïve translation on CP (green bars) is slowest in 10 out of 14 queries, with large performance penalties for Q04, Q07, Q08, Q11-13. Instantiation (CP SAT INS, red bars) is generally faster than naïve CP. It strongly speeds up Q04, Q07, Q08, Q10-Q14; it brings a modest improvement to Q01 and Q05, but also a modest overhead for Q02, Q03, Q06. However, on the complex Q09, which has the largest q G size, namely 3690, instantiating each of these more than doubles the answering time w.r.t. naïve CP translation (and ran until the timeout); pruning (yellow bars) brings it back below the timeout. T SAT is generally faster than all executions on the CP layout, because all queries contain triples of the form (s, τ, x) and/or (s, x, o), which, as explained in Section 3.2, challenge CP execution. TCP SAT avoids the (sometimes drastic) performance problems of all CP variants, and is the fastest (by up to several orders of magnitude) on all queries but Q14, where the CP variant with pruning is a bit faster. Virtuoso is also always slower than TCP (by up to 95×, almost two orders of magnitude).</p><formula xml:id="formula_24">T SAT CP SAT NAIVE CP SAT INS CP SAT INS PRUN TCP SAT VIRTUOSO SAT T (q)(G R ) CP (q)(G R ) CP (q G )(G R ) CP ((q G ) pruned )(G R ) T CP (q)(G R ) T (q)(G R )</formula><p>On DBLP (bottom), poor performance is exhibited by Virtuoso (Q03, Q07, Q09, Q10), and on even more queries by the naïve CP strategy (green bars, Q05-Q07, Q09-Q10, Q14). T SAT performs very badly on Q09, Q10, Q14 and Q15. These are rather large (6 to 9-triples) queries; an analysis of their plans shows significant errors in the RDBMS' estimation of join cardinality. As is well-known, join cardinality estimation errors multiply along subsequent joins; when all joins carry over a single, very large table, the negative impact of such cumulated errors can be quite strong. Historically, this observation actually motivated the introduction of the CP layout, on which join estimation errors still multiply, but usually much smaller tables are involved. Indeed, as expected, for the queries Q11 and Q15, exactly those where no triple has a variable in class and property position, naïve CP largely outperforms T SAT (by very far for Q15). Again, we observe the robust behavior of TCP SAT. We conclude that through saturation, T and CP execution each underperform on some queries, but TCP avoids all these pitfalls and is consistently very efficient.</p><p>Through reformulation Figure <ref type="figure">3</ref> shows reformulation-based query answering times (note the logarithmic y axis in the zoom), again with the correspondences between the bar labels and the strategy names previously used in the paper. On LUBM, among the evaluation strategies without pruning, TCP REF is generally the fastest (or very close to it), with the exception of Q14, where CP REF INS is 1.4× faster. This query with the most results (9.85M) and a large reformulation (Table <ref type="table" target="#tab_8">4</ref>) has two atoms of the form (x, p, z), (y, p, z). On CP, this leads to a large number of self-joins of the form t p o t p , executed very fast because loading t p in memory once ensures the join runs completely in-memory. While the rather unusual Q14 shows a case when CP may still outperform TCP, the difference is not dramatic. On the three layouts, pruning generally helps: it saves, e.g., more than half of the CP answering time for Q01, Q02. In the zoomed view (shortest-running queries), pruning brings an overhead (takes more time that the query evaluation time it saves) of a few milliseconds. Among the strategies with pruning, TCP REF PRUN is the fastest, except for Q14 discussed above. As Virtuoso did not support reasoning with our rule set R (details online 5 ), we gave it reformulations expressed in SPARQL; for Q07 and Q14, they failed to run, with the error "union nesting is too deep". The impact of instantiation for Virtuoso is unclear; it helped for Q04, Q08 but not for Q02, Q06 etc. All missing Virtuoso bars in Figure <ref type="figure">3</ref> are execution failures, mostly due to large unions. On DBLP, VIRTUOSO REF failed for Q06, Q07, Q09, Q10, Q13; VIRTU-OSO REF INS was consistently worse, and we omitted it from the plot. The rest of the analysis is similar to the one above, except that T REF performs very badly in a few cases (Q07, Q11). Overall, in Figure <ref type="figure">3</ref>, TCP query answering with pruning is the fastest, or very close to it, on all queries, while all other strategies's weaknesses are exposed by one or more queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experiment conclusion</head><p>We studied the performance of query answering in RDF databases through saturation and reformulation, on challenging queries that remain poorly supported: those with variables in class or property position. We have exhibited queries that lead to poor to catastrophic performance of query answering on the T layout (mainly due to many self-joins on a large table) and/or on the CP layout (mainly due to large unions, brought by variables in class and property positions, and/or by reformulation). Query answering on the TCP layout is extremely robust; it avoids all these pitfalls by taking the best of both T and CP, at the expense of more storage space. As disks are getting ever cheaper 7 , TCP appears to be a robust, practical layout, compatible with well-established large-scale RDF storage and query engines. For the challenging queries we study, summary-based pruning helps improve performance, in particular for the TCP layout. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related work and conclusion</head><p>Our work studies the impact of RDF graph storage on query answering in the presence of RDFS ontologies, both through graph saturation (SatQA) and query reformulation (RefQA). Prior works such as <ref type="bibr" target="#b1">[4,</ref><ref type="bibr" target="#b4">7,</ref><ref type="bibr" target="#b16">19,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b18">21]</ref> only considered SatQA. While <ref type="bibr" target="#b1">[4]</ref> advocated the CP layout, <ref type="bibr" target="#b18">[21]</ref> nuanced the analysis: in a row store, they show that proper indexing (such as we used here) can significantly improve performance using T, while many distinct properties may hurt CP performance. It is not fully clear if <ref type="bibr" target="#b1">[4,</ref><ref type="bibr" target="#b18">21]</ref> used the naïve or instantiation-based CP translation; as our experiments show, TCP outperforms both, in particular with summary pruning. The optimized T layout of <ref type="bibr" target="#b21">[24]</ref>, indexed on all (s, p, o) permutations, has been used for RefQA in <ref type="bibr" target="#b12">[15,</ref><ref type="bibr" target="#b13">16,</ref><ref type="bibr" target="#b7">10]</ref>; in our experiments, TCP avoids all its bad-performance scenarios. Storage was optimized based on a known workload by creating materialized views in <ref type="bibr" target="#b12">[15]</ref>. Query reformulation has also been used with the CP layout in <ref type="bibr" target="#b6">[9,</ref><ref type="bibr" target="#b8">11]</ref>. Both <ref type="bibr" target="#b7">[10]</ref> for T and <ref type="bibr" target="#b8">[11]</ref> for CP explored how to express a reformulated query as a join of several subqueries, so as to minimize the evaluation cost through the RDBMS. Applying this technique to the TCP layout could presumably also improve its performance. A simplified version of TCP is briefly mentioned in <ref type="bibr" target="#b10">[13]</ref>, which studies generic SPARQL-to-SQL translation functions, as an example of possible relational layout. However, <ref type="bibr" target="#b10">[13]</ref> does not consider the performance impact of this layout; nor do they consider RDFS entailment. Optimized storage layouts <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b22">25]</ref> or indexes <ref type="bibr" target="#b19">[22,</ref><ref type="bibr" target="#b2">5]</ref> have been investigated to limit joins by storing e.g., the values of several properties for a given subject together. They allow translating several BGPQ triples into a single table (or index) access; they could also be applied on the TCP layout to further improve it. Finally, in <ref type="bibr" target="#b20">[23]</ref>, the storage layout based on binary tables is adapted to the graph topology, in order to speed up query evaluation. TCP is a robust layout, which does not require query workload knowledge, and allows to significantly reduce BGPQ answering times. On queries well supported by the T, respectively, CP layout, TCP matches that performance; but most importantly, it avoids all the performance (or plain unfeasibility) issues they encounter, in saturation-or reformulation-based query answering. Summary-based pruning also importantly improves performance. We believe the TCP layout, and pruning, can be adopted with little effort, and can strongly consolidate and improve query answering performance in many RDF databases.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Query answering times (milliseconds) on LUBM (top) and DBLP (bottom), through saturation.</figDesc><graphic coords="14,134.77,234.68,345.82,116.35" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Fig. 3. LUBM (top) and DBLP (bottom) query answering times (ms) through reformulation.</figDesc><graphic coords="16,134.77,234.10,345.84,131.11" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Property assertion (s, p, o) with p ∈ {τ, ≺sc, ≺sp, ← d , →r} RDF statements.</figDesc><table><row><cell cols="4">RDFS constraint Schema triple notation RDFS constraint Schema triple notation</cell></row><row><cell>Subclass</cell><cell>(s, ≺sc, o)</cell><cell>Subproperty</cell><cell>(s, ≺sp, o)</cell></row><row><cell>Domain typing</cell><cell>(s, ← d , o)</cell><cell>Range typing</cell><cell>(s, →r, o)</cell></row><row><cell cols="3">RDF assertion Data triple notation</cell><cell></cell></row><row><cell cols="2">Class assertion</cell><cell>(s, τ, o)</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Sample set R of RDFS entailment rules.</figDesc><table><row><cell>rdfs9). The saturation of a graph G with the rule set R, denoted G R , allows</cell></row><row><cell>materializing its semantics, by iteratively augmenting it with the triples it entails</cell></row><row><cell>using R, until reaching a fixpoint; this process is finite [2].</cell></row><row><cell>Example 2. The saturation of G ex with R (Table 2) is: (G ex ) R = G ex ∪</cell></row><row><cell>{(:GOpenArt, ≺ sc , :Article), (:teaches, ← d , :Person), (:firstAuth, → r , :Person),</cell></row><row><cell>(:Alice, τ, :Prof), (:Bob, τ, :Person), (:art1, :author, :Alice), (:art1, τ, :OpenArt),</cell></row><row><cell>(:Alice, τ, :Person), (:art1, τ, :Article)}</cell></row><row><cell>Given a set of variables V disjoint from I ∪ B ∪ L , a basic graph pat-</cell></row><row><cell>tern (BGP in short) is a set of triple patterns (or triples in short, when non-</cell></row><row><cell>ambiguous) belonging to (</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>t 2 .O=t 3 .S (π S,:author,O (t :author ), π</figDesc><table /><note><p>s,τ,:GOpenArt (t :GOpenArt ) ∪ π s,τ,:OpenArt (t :OpenArt ) ∪ π s,τ,:Article (t :Article ) ∪ π s,τ,:Prof (t :Prof ) ∪ π s,τ,:Person (t :Person ) ∪ π S,≺ sc ,O (σ O=:Article (t ≺ sc )))</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>O,:OpenArt ( t1.S=t2.S (π S,:author,O (t :author ), π S,τ,:OpenArt (t :OpenArt )) ∪ π t1.O,:OpenArt ( t1.S=t2.S (π S,:firstAuth,O (t :firstAuth ), π S,τ,:OpenArt (t :OpenArt )) ∪ π t1.O,:OpenArt ( t1.S=t2.S (π S,:author,O (t :author ), π S,τ,:GOpenArt (t :GOpenArt )) ∪ π t1.O,:OpenArt ( t1.S=t2.S (π S,:firstAuth,O (t :firstAuth ), π S,τ,:GOpenArt (t :GOpenArt )) ∪ π t1.O,:GOpenArt ( t1.S=t2.S (π S,:author,O (t :author ), π S,τ,:GOpenArt (t :GOpenArt )) ∪ π t1.O,:GOpenArt ( t1.S=t2.S (π S,:firstAuth,O (t :firstAuth ), π S,τ,:GOpenArt (t :GOpenArt ))</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Importantly, α T CP translates the triples that penalize the CP layout into t atoms, and never into a union: hence, α T CP avoids the cases (3) and (4) of α CP . Example 11. The translation of the example query for the TCP layout combines the T layout for the second triple and the CP layout for the others:</figDesc><table><row><cell>π t1.O,t2.O ( t1.S=t2.S,t2.O=t3.</cell></row></table><note><p>otherwise, i.e., if t = (s, τ, x) or t = (s, x, o) with x ∈ V S (π S,:author,O (t :author ), σ P =τ (t), π S,≺sc,O (σ O=:Article (t ≺sc ))))</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>algebraic translation on the TCP layout (similarly abridged) is: π t1.S,t2.O,t1.O ( t1.S=t2.S (σ P =τ (t), π S,:firstAuth,O (t :firstAuth ))) ∪ π t1.S,t2.O,:Article ( t1.S=t2.S (π S,τ,:OpenArt (t :OpenArt ), π S,:firstAuth,O (t :firstAuth ))) ∪ π t1.S,t2.O,:Article ( t1.S=t2.S (π S,τ,:GOpenArt (t :GOpenArt ), π S,:firstAuth,O (t :firstAuth ))) ∪ π t1.S,t2.O,:OpenArt ( t1.S=t2.S (π S,τ,:GOpenArt (t :GOpenArt ), π S,:firstAuth,O (t :firstAuth ))) ∪ π t1.S,t2.O,:Person ( t1.S=t2.S (π S,τ,:Prof (t :Prof ), π S,:firstAuth,O (t :firstAuth ))) . . . Above, the first union term refers to the triple table t, while the others do not.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 .</head><label>4</label><figDesc>Statistics of our queries on LUBM (top) and DBLP (bottom); M stands for millions and K for thousands.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="11">15M 1.72M 0.47M 2.77M 25K 3696 2003 17.35M 187 518K 857 9.85M</cell></row><row><cell>|q G |</cell><cell>45</cell><cell>45</cell><cell>45</cell><cell cols="2">82 2025</cell><cell cols="3">45 45 82 3690</cell><cell cols="2">82 82</cell><cell cols="2">37 1369</cell><cell>82</cell></row><row><cell>|(q G ) pruned |</cell><cell>45</cell><cell>45</cell><cell>45</cell><cell cols="2">67 1806</cell><cell>44 44</cell><cell cols="2">3 88</cell><cell cols="2">68 59</cell><cell cols="2">23 43</cell><cell>51</cell></row><row><cell>|QR|</cell><cell>318</cell><cell>106</cell><cell>146</cell><cell>68</cell><cell>216</cell><cell>80 318</cell><cell cols="2">9 36</cell><cell>88</cell><cell>9</cell><cell cols="3">27 39 1152</cell></row><row><cell>|(QR) pruned |</cell><cell>120</cell><cell>56</cell><cell>59</cell><cell>48</cell><cell>108</cell><cell>34 173</cell><cell>7</cell><cell>2</cell><cell>78</cell><cell>7</cell><cell cols="2">21 21</cell><cell>889</cell></row><row><cell>|Q G R |</cell><cell>447</cell><cell>149</cell><cell>226</cell><cell>68</cell><cell>216</cell><cell>121 447</cell><cell cols="2">9 36</cell><cell>169</cell><cell>9</cell><cell cols="3">63 1797 1188</cell></row><row><cell>|(Q G R ) pruned |</cell><cell>206</cell><cell>99</cell><cell>135</cell><cell>48</cell><cell>108</cell><cell>73 299</cell><cell>7</cell><cell>2</cell><cell>144</cell><cell>7</cell><cell cols="2">42 50</cell><cell>892</cell></row><row><cell>Query</cell><cell cols="13">Q01 Q02 Q03 Q04 Q05 Q06 Q07 Q08 Q09 Q10 Q11 Q12 Q13 Q14 Q15</cell></row><row><cell>|q(G, R)|</cell><cell cols="13">72K 24K 96.3M 361K 4K 10 138 42K 1.52M 3.09M 957K 414K 409K 16.3K 460K</cell></row><row><cell>|q G |</cell><cell cols="2">18 18</cell><cell>18</cell><cell cols="3">18 50 900 900 18</cell><cell>900</cell><cell>900</cell><cell>1</cell><cell cols="2">18 324</cell><cell>50</cell><cell>1</cell></row><row><cell>|(q G ) pruned |</cell><cell cols="2">18 18</cell><cell>18</cell><cell>18</cell><cell cols="2">3 136 136 17</cell><cell>85</cell><cell>85</cell><cell>1</cell><cell cols="2">18 324</cell><cell>3</cell><cell>1</cell></row><row><cell>|QR|</cell><cell cols="2">117 297</cell><cell cols="7">265 117 873 4257 3163 36 1500 3652 243</cell><cell cols="4">39 381 129 243</cell></row><row><cell cols="3">|(QR) pruned | 56 205</cell><cell>151</cell><cell cols="5">56 616 3089 2166 32 1184 2620</cell><cell>36</cell><cell cols="3">24 174 114</cell><cell>3</cell></row><row><cell>|Q G R |</cell><cell cols="2">252 440</cell><cell cols="4">408 252 1529 5927 3345 72</cell><cell>1</cell><cell>324</cell><cell>3</cell><cell cols="4">84 2088 270 243</cell></row><row><cell cols="3">|(Q G R ) pruned | 161 331</cell><cell cols="4">277 161 1224 3275 2189 37</cell><cell>1</cell><cell>64</cell><cell>3</cell><cell cols="3">69 1497 117</cell><cell>3</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_0"><p>We checked this on systems that disclose their query execution strategy; experiments with others who do not, confirm the same hypothesis (see Section 5).</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="https://www.w3.org/TR/sparql11-query/" />
		<title level="m">RDF 1.1 Concepts</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Scalable Semantic Web Data Management Using Vertical Partitioning</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marcus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hollenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Matrix &quot;bit&quot; loaded: a scalable lightweight join query processor for RDF data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Chaoji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hendler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WWW</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Schema-agnostic query rewriting in SPARQL 1</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bischof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Building an efficient RDF store over a relational database</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Bornea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dolby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Srinivas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Dantressangle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Udrea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Bhattacharjee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sesame: A generic architecture for storing and querying RDF and RDF schema</title>
		<author>
			<persName><forename type="first">J</forename><surname>Broekstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kampman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reformulation-based query answering for RDF graphs with RDFS ontologies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimizing reformulation-based query answering in RDF</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bursztyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Teaching an RDBMS about ontological constraints</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bursztyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Summarizing Semantic Graphs: A Survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cebiric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Troullinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zneika</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Semantics preserving SPARQL-to-SQL translation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chebotko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Fotouhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Knowl. Eng</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">RDF Graph Summarization for Firstsight Structure Discovery</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<date type="published" when="2020-04">Apr 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">View selection in semantic web databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Karanasos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leblay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient query answering against dynamic RDF databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roatis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">LUBM: A benchmark for OWL knowledge base systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Heflin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Sem</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Answering SPARQL queries over databases under OWL 2 QL entailment regime</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The RDF-3X engine for scalable management of RDF data</title>
		<author>
			<persName><forename type="first">T</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deriving an emergent relational schema from RDF data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Passing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WWW</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Column-store support for RDF data management: not all swans are white</title>
		<author>
			<persName><forename type="first">L</forename><surname>Sidirourgos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Goncalves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Manegold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">GRIN: A graph based RDF index</title>
		<author>
			<persName><forename type="first">O</forename><surname>Udrea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pugliese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Adaptive low-level storage of very large knowledge graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J H</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WWW</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Hexastore: Sextuple indexing for Semantic Web data management</title>
		<author>
			<persName><forename type="first">C</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Karras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Efficient RDF storage and retrieval in Jena2</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wilkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sayers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kuno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Reynolds</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>SWDB</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
