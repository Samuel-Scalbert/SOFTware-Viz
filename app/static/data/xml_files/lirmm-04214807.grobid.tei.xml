<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Testing Logical Diagrams in power plants: a tale of LTL model checking</title>
				<funder ref="#_aTwZWXc">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Aziz</forename><surname>Sfar</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">EDF R&amp;D</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Madalina</forename><surname>Croitoru</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Testing Logical Diagrams in power plants: a tale of LTL model checking</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A100692C4F3514D0BE03DA3E32277218</idno>
					<idno type="DOI">10.1007/978-3-031-43681-9_11</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Validation tests</term>
					<term>Symbolic Model Checking</term>
					<term>Linear Temporal Logic</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we focus on the application of LTL (Linear Temporal Logic) model checking on logical diagrams (LD), which are a type of functional specification used for logical controllers in many nuclear power plants. The goal is to check properties on LDs and to generate counter examples serving as validation tests for logical controllers. We propose a sound and complete LTL encoding framework for LDs allowing the use of model checking (MC) and evaluate different MC techniques on real world LD to efficiently generate counterexamples for verifiable properties.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We place ourselves in an applicative setting of the EDF company (French Electricity) where the behavior of Programmable Logical Controllers (PLC) used for nuclear power plants is periodically updated and tested manually within expert defined functional validation scenarios. A PLC is a system that embeds a program running control and protection functions. In a critical domain like nuclear energy production, the behavior of PLCs have to satisfy strict performance and safety requirements. Therefore, during the life-cycle of nuclear reactors, several updates are introduced to the PLC programs to keep up with last requirements defined by nuclear authorities. The updated behavior has to be validated by testing it against its functional specifications to ensure that no functional errors were generated following the modification process.</p><p>In the case of our application, the functional specifications of the behavior of PLCs are given in the form of Logical Diagrams (LD). These are graphical representations of a number of inputs and outputs connected through different types of logical blocks defining the expected behaviour of the machine (PLC). In a nuclear power plant, the number and size of LDs used as specifications for PLCs is enormous which makes the manual generation of test scenarios, as it is today, a tedious and time consuming task. Moreover, a Logical Diagram may contain feedback connections, i.e a number of blocks connected to each other in a loop, which could lead to cyclic behavior. This is a situation where one or many outputs keep changing indefinitely without any change on the inputs making the specified behavior divergent.</p><p>In this paper, we address the problem of the stability property verification (i.e. absence of cyclic behaviour) on the Logical Diagrams and the generation of validation test cases for PLCs. Several works propose the transformation of the PLC description languages into formal representations like finite state models and timed automata to make use of the already existing tools and methods for test generation. For instance, Provost et al. <ref type="bibr" target="#b36">[11]</ref> have proposed a translation of Grafcet specification models into Mealy machines to generate conformance test scenarios. In a previous work <ref type="bibr" target="#b37">[12]</ref> inspired from <ref type="bibr" target="#b36">[11]</ref>, we have introduced a transformation of Logical Diagrams into state/transition graphs. The aim was to make use of the test generation techniques for transition systems as presented in <ref type="bibr" target="#b35">[10]</ref> and <ref type="bibr" target="#b38">[13]</ref> as well as the formal verification techniques to prove stability in Logical Diagrams. However, the exponential growth of the size of the generated transition systems makes their generation complicated for the biggest sized LDs. In <ref type="bibr" target="#b33">[8]</ref>, model-checking techniques were used to generate tests for PLC programs developed in Function Block Diagram (FBD). The paper describes the transformation of FBDs into timed automata and the use of a Model-Checker to generate test sequences. An experimental evaluation of their solution was made for many train control systems programs. However, to the authors knowledge, no similar approach was done for PLCs based on LD specifications used in nuclear power plants. In this paper, we propose to automatise the checking process of PLC behaviour specified in Logical Diagrams using tools from the Model Checking (MC ) domain. We define a sound and complete transformation of Logical Diagrams into Linear Temporal Logic (LTL) formulas. We demonstrate how the stability property can be expressed into LTL expressions. We also show how test cases could be generated by formulating properties like the activation and deactivation of the outputs of the system in an LTL encoding and running Model-checkers on them. Finally, we empirically evaluate the efficiency of existing MC tools (NuSMV <ref type="bibr" target="#b30">[5]</ref> and nuXmv <ref type="bibr" target="#b28">[3]</ref>) on EDF logical diagrams. The empirical results obtained show that techniques like k-MC <ref type="bibr" target="#b31">[6]</ref> is useful for checking the stability property while other techniques (BDD <ref type="bibr" target="#b32">[7]</ref>, BMC <ref type="bibr" target="#b26">[1]</ref> and SBMC <ref type="bibr" target="#b34">[9]</ref>) are timing out. The counterexample generation for activation and deactivation of outputs is possible for all techniques except BDD. We believe that the overview of the practical usability of LTL Model Checking tools for our real world scenario could be of use to researchers undergoing similar tasks (e.g. LTL encoding and LTL Model Checking for test generation). This paper is organized as follows. In section 2 we set a formal definition of the Logical Diagram specification and we give an example. Section 3 introduces the LTL formalism and presents the LTL encoding of the logical diagram and the stability, activation and deactivation properties. Proof of the soundness and completeness of the transformation is given in section 4. Finally, section 5 discusses the application and evaluation of Model-Checking tools and techniques on our Logical Diagrams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Logical Diagram</head><p>A logical diagram (LD) is a graphical representation of a set of interconnected blocks that perform logical functions. Before running a code implementing the logical diagram on a controller, a few properties of the logical diagram have to be studied. One of these properties is the stability property ensuring that the outputs of the logical diagram converge for some fixed inputs. Moreover, in order to test the implementation of a logical diagram on a controller, we would like to be able to generate input values, that allow to activate or deactivate a chosen output. Thus, we need to define the properties of activation and deactivation of outputs and use these properties in the verification and validation (V&amp;V) process to validate the correct implementation of the logical diagram on the logical controller. In this section, we introduce a formal definition for logical diagrams and the properties of stability, activation and deactivation of outputs, and we illustrate them on the logical diagram in Figure <ref type="figure">1</ref>.</p><formula xml:id="formula_0">i 1 i 2 i 3 m 1 m 2 v o 1 o 2 order: ( m 1 , m 2 ) Fig. 1. A logical diagram example LD = ⟨V, E, O⟩: V (input) = {i1, i2, i3}, V (output) = {o1, o2}, V (ME) = {m1, m2}, V (and) = {v}, E = {i1 s -→ m1, i2 r -→ m1, m1 s -→ m2, v r -→ m2, i3 → v, m2 → v, m1 → o1, m2 → o2}, O(m1) = 1 and O(m2) = 2.</formula><p>A logical diagram is formally defined by a set of vertices V , and a set of directed edges E connecting these vertices. Every vertex v ∈ V has a type that defines the number and nature of its incoming and outgoing edges as formally defined in Def. 1. Output vertices are denoted by V (output), input vertices by V (input), memory vertices by V (M) and finally vertices of the type 'and ', 'or ' and 'not' are denoted V (and), V (or) and V (not), respectively. In a logical diagram, we can find cycles. A cycle is a sequence of edges that starts and finishes at the same vertex v. In the diagrams used by EDF all cycles contain at least one memory vertex within the sequence. Consider the example of Figure <ref type="figure">1</ref>: it contains three input vertices i 1 , i 2 and i 3 , two output vertices o 1 and o 2 , two memory vertices m 1 and m 2 , one vertex v of type 'and' and one cycle composed of v and m 2 . Note that the memory vertices are represented in the diagram by set/reset (RS) blocks that have two inputs: E for set and H for reset. In the case of m 1 , the incoming edge corresponding to the set is represented by i 1 s -→ m 1 while i 2 r -→ m 1 represents the reset edge. The incoming edges of the other vertices types is given by a simple arrow as in i 3 → v. The letter 'p' in 'Hp' indicates that reset has priority over set. Then, we denote M H as the type of the memory vertex. This is the case for both m 1 and m 2 . Otherwise, the memory vertex is of type M E with the priority expressed by 'Ep' in the set input of the block.</p><p>Definition 1 (Vertex type and LD). The set of vertex types is {input, output, and, or, not, M E , M H }. Henceforth, we associate every vertex v with a vertex type tp(v). Given a set V of vertices and a vertex type t, let</p><formula xml:id="formula_1">V (t) = {v ∈ V | tp(v) = t}. Moreover, let V (M) = V (M E ) ∪ V (M H ). Moreover, a directed edge over V is an expression of the form u → v, u s - → v, or u r - → v with u, v ∈ V . A logical diagram (LD) is a tuple ⟨V, E, O⟩ such that V is a set of vertices, E is a set of directed edges (over V ), O is a bijection from V (M) to {1, . . . , |V (M)|},</formula><p>and all of the following hold:</p><p>1. If u → v ∈ E for some u, v ∈ V ; then tp(v) is output, and, or, or not.</p><formula xml:id="formula_2">2. If u s - → v or u r - → v are in E for some u, v ∈ V , then tp(v) is M E or M H . 3. For every v ∈ V (not) ∪ V (output)</formula><p>, there is exactly one edge of the form u → v ∈ E. 4. For every v ∈ V (and) ∪ V (or), there are at least two edges of the form u → v ∈ E. 5. For every v ∈ V (M), there is exactly one edge of the form u s -→ v ∈ E and exactly one edge of the form w</p><formula xml:id="formula_3">r - → v ∈ E. 6. For every v 1 , . . . , v n ∈ V , either v n → v 1 / ∈ E or v i-1 → v i / ∈ E for some 2 ≤ i ≤ n.</formula><p>That is, every cycle have to traverse at least one memory vertex.</p><p>Each vertex in a logical diagram has an associated logical value called the output of the vertex. It takes the value true referred to by ⊤ or false referred to by ⊥. Furthermore, the vertex output is evaluated in accordance to increasing time steps and can vary from a step to another. The time step k starts at zero. Initially, i.e. at k = 0, output values of memory and input vertices are given by an initializing function f . Then, the output value of every vertex v at a time step k ≥ 0, is defined by the function LD f (v, k). Specifically, the output of memory vertices are evaluated one after the other according to an evaluation order specified by the function O. The output value of only one memory vertex can change at each time step if it is its turn, while the others maintain the same value from the previous step. Note that the output of a memory vertex of type M E (resp. M H ) is evaluated to True, denoted ⊤, (resp. False, denoted ⊥), when both set and reset inputs are evaluated to True. The complete output evaluation for different vertices types is given by Def. </p><formula xml:id="formula_4">-ev(⊤) = ⊤. -ev(⊥) = ⊥. -ev(¬a) = ⊤ iff ev(a) = ⊥. -ev(a ∨ b) = ⊤ iff ev(a) = ⊤ or ev(b) = ⊤. -ev(a ∧ b) = ⊤ iff ev(a) = ⊤ and ev(b) = ⊤.</formula><p>Definition 3 (Output function). Consider a diagram LD = ⟨V, E, O⟩ and an initializing function f for LD; that is, a total function from</p><formula xml:id="formula_5">V (input) ∪ V (M) to {⊤, ⊥}. For every vertex v ∈ V (M), let turn O (v) be the set that contains O(v) + n • |V (M)| for every n ≥ 0. Also, for every v ∈ V and k ≥ 0, we define LD f (v, k) ∈ {⊤, ⊥} as follows: -If v ∈ V (input), then LD f (v, k) = f(v). -If v ∈ V (output), then LD f (v, k) = ev(LD f (u, k)) where u is the vertex in V with u → v ∈ E. -If v ∈ V (not), then LD f (v, k) = ev(¬LD f (u, k)) where u is the vertex with u → v ∈ E. -If v ∈ V (or), then LD f (v, k) = ev( u∈P LD f (u, k)) where P = {u ∈ V | u → v ∈ E}. -If v ∈ V (and), then LD f (v, k) = ev( u∈P LD f (u, k)) where P = {u ∈ V | u → v ∈ E}. -If v ∈ V (M) and k = 0, then LD f (v, k) = f (v). -If v ∈ V (M), k ≥ 1, and k / ∈ turn O (v) then LD f (v, k) = LD f (v, k -1). -If v ∈ V (M) and k ∈ turn O (v), we consider two cases: • If tp(v) = M E , then LD f (v, k) = ev((LD f (v, k -1) ∧ ¬LD f (h, k -1)) ∨ LD f (e, k -1)). • If tp(v) = M H , then LD f (v, k) = ev(¬LD f (h, k -1) ∧ (LD f (v, k -1) ∨ LD f (e, k -1))). In the above, h ∈ V with h r - → v ∈ E and e ∈ V with e s - → v ∈ E.</formula><p>In the example of Figure <ref type="figure">1</ref>, the evaluation order of LD is O(m 1 ) = 1 and O(m 2 ) = 2. The output function LD f depends on this evaluation order as well as the initializing function as established in Def. 3. Note that input vertices maintain the value given to them in the initial step.</p><p>Thus far, we have defined the different elements composing a logical diagram and the output evaluation function. We define in the sequel the properties of stability, activation and deactivation of outputs. For the stability property, we want to make sure that in some future time step k, the output values of vertices converge. In other words, having an initializing function f , the logical output value of every vertex should not oscillate indefinitely between the values true and false, from a step to the next. For this to be avoided, it suffices that the outputs of memory vertices converge as mentioned in Def. 4. In this case, we say that the logical diagram is stable for the initializing function f . We also say that a logical diagram is uniformly stable if it is stable for every possible input scenario, i.e. for every initializing function f . Definition 4 (stability). A logical diagram LD = ⟨V, E, O⟩ is stable for some initializing function f , if there exists k ′ ≥ 0 such that for every k ≥ k ′ and v ∈ V (M), we have LD f (v, k) = LD f (v, k + 1). We say that a logical Diagram LD is uniformly stable if it is stable for every initializing function f .</p><p>To illustrate, we consider the initializing function <ref type="figure">1</ref>. By applying the evaluation function on the memory vertex m 2 , we can see that LD f (m 2 , k) is not equal to LD f (m 2 , k + 2) for every k ≥ 0. Therefore, LD is not stable for f . Hence LD is not uniformly stable.</p><formula xml:id="formula_6">f (i 1 ) = ⊤, f (i 2 ) = ⊥, f (i 3 ) = ⊤, f (m 1 ) = ⊥ and f (m 2 ) = ⊥ for the logical diagram of Figure</formula><p>Once the stability is verified, the next step consists in generating initializing functions that allow to set to true (i.e activate) or set to false (i.e deactivate) an output vertex o. It is also possible to set some initial conditions over the input and output values before generating scenarios. We look to answer questions like: is there an initializing function f that eventually activates an output o, when initially, o is deactivated (i.e. LD f (o, 0) = ⊥) and the input i is activated (i.e. LD f (i, 0) = ⊤). The chosen initial conditions are given by an initial configuration function conf S setting the initial values of a set of vertices S ⊆ V (output) ∪ V (input). Then, we say that the output o is activated (resp. deactivated) for an initializing function f , if f satisfies the initial configuration conf S , and grants the activation (resp. deactivation) of o in some future step k (as per Def. 5).</p><p>Definition 5. Consider a logical diagram LD = ⟨V, E, O⟩ and an initial configuration function conf S ; that is a function from S ⊆ V (input) ∪ V (output) to {⊤, ⊥}. An output vertex o ∈ V (output) is activated (resp. deactivated ) for some initial configuration conf S , if there is an initializing function f and</p><formula xml:id="formula_7">k ′ ≥ 0 such that; for every v ∈ S, LD f (v, 0) = conf S (v) and for every k ≥ k ′ , LD f (o, k) = ⊤ (resp. LD f (o, k) = ⊥).</formula><p>Consider for instance the logical diagram of Figure <ref type="figure">1</ref>, the set S = {o 1 , o 2 } and the initial configuration conf S (o 1 ) = ⊥ and conf S (o 2 ) = ⊥. Let f 1 be an initializing function such that f</p><formula xml:id="formula_8">1 (i 1 ) = ⊤, f 1 (i 2 ) = ⊥, f 1 (i 3 ) = ⊥, f 1 (m 1 ) = ⊥ and f 1 (m 2 ) = ⊥. By Def. 3, we have LD f (o 1 , 0) = ⊥, LD f (o 2 , 0) = ⊥ and LD f (o 2 , k) = ⊤ for every k ≥ 2. Therefore, o 2 is activated for f 1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">LTL encoding of logical diagrams</head><p>In this section, we propose an encoding framework of the logical diagrams and properties into a set of Linear Temporal Logic (LTL) formulas. An LTL formula is built up from a set of propositional variables AP and a set of logical and temporal operators. The set L of LTL formulas is defined by the following grammar:</p><formula xml:id="formula_9">L ::= p | ⊤ | ⊥ | ¬L | L ∧ L | L ∨ L | L → L | L ↔ L | ⃝L | □L | ♢L where p ∈ AP . A word W is a sequence s 0 , s 1 , .</formula><p>. . of subsets of AP. Each element s i of the sequence is referred to by ⟨W, i⟩. Given a word W, a propositional variable p, two LTL formulas φ and ψ, and some i ≥ 0; we write:</p><formula xml:id="formula_10">-⟨W, i⟩ |= p iff p ∈ s i . -⟨W, i⟩ |= ⊤. -⟨W, i⟩ ⊭⊥. -⟨W, i⟩ |= ¬φ iff ⟨W, i⟩ ⊭ φ. -⟨W, i⟩ |= φ ∧ ψ iff ⟨W, i⟩ |= φ and ⟨W, i⟩ |= ψ. -⟨W, i⟩ |= φ ∨ ψ iff ⟨W, i⟩ |= φ or ⟨W, i⟩ |= ψ. -⟨W, i⟩ |= φ → ψ iff ⟨W, i⟩ |= ¬φ ∨ ψ. -⟨W, i⟩ |= φ ↔ ψ iff ⟨W, i⟩ |= (ψ → φ) ∧ (φ → ψ). -⟨W, i⟩ |= ⃝φ iff ⟨M, i + 1⟩ |= φ.</formula><p>-⟨W, i⟩ |= ♢φ iff ⟨M, j⟩ |= φ for some j ≥ i.</p><p>-⟨W, i⟩ |= □φ iff ⟨M, j⟩ |= φ for every j ≥ i.</p><p>We say that a word W satisfies an LTL formula Φ at a time step i and we write ⟨M, i⟩ |= Φ. Moreover, W is a model of Φ (W |= Φ) if W satisfies Φ at the time step 0. An LTL theory is a defined finite set of LTL formulas. A word W is a model of an LTL theory T if it is a model of every formula Φ ∈ T . An LTL theory T 1 entails another theory T 2 (T 1 |= T 2 ) when every model of T 1 is also a model of T 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">LTL encoding of logical diagrams and initializing functions</head><p>We introduce a sound and complete LTL encoding of logical diagrams. The encoding will be given in two LTL theories. The first, denoted T LD , encodes the vertices, edges and characteristics of a logical diagram LD; the second T f encodes the initial output values given by an initializing function f . Let LD = ⟨V, E, O⟩ be a logical diagram. We define the LTL vocabulary AP LD of propositional variables: we associate to every vertex v ∈ V a propositional variable t v and to each number i ≥ 1 a variable t i . The set AP LD is composed of these t v and t i . Then, the LTL theory T LD contains an LTL formula for every vertex v ∈ V . This formula represents the output function of v at every time step. On the logical diagram of Figure <ref type="figure">1</ref>, the LTL theory T LD of our example contains the formulas {□(t o1 ↔ t m1 ), □(t o2 ↔ t m2 )} for the vertices o 1 and o 2 , the formula □(t v ↔ t i3 ∧ t m2 ) for the vertex v, and {□(⃝t m1 ↔ ((¬t</p><formula xml:id="formula_11">1 ∧ t m1 ) ∨ (t 1 ∧ ¬t i2 ∧ (t m1 ∨ t i1 )))), □(⃝t m2 ↔ ((¬t 2 ∧ t m2 ) ∨ (t 2 ∧ ¬t v ∧ (t m2 ∨ t m1 ))</formula><p>))} for the vertices m 1 and m 2 . In the last two formulas, the variable t 1 indicates the evaluation turn of m 1 , and likewise with t 2 and m 2 . Therefore, we add to T LD the formulas that translate the ordered evaluation of memory vertices. We construct these formulas in a way that ensures that t O(v) is exclusively true at the time steps dedicated for the evaluation of the memory vertex v according to O(v). For the logical diagram LD in Fig. <ref type="figure">1</ref>, we add to T LD the set of LTL formulas :</p><formula xml:id="formula_12">{(t 1 ∧ ¬t 2 ), □(t 1 ↔ ⃝(¬t 1 ∧ t 2 )), □(t 2 ↔ ⃝(¬t 2 ∧ t 1 ))}.</formula><p>Finally, we add to T LD the set of formulas that translate the fact that input vertices of the logical diagram keep the same values assigned to them in the initial time step. We do this by adding the LTL formula (□t v ∨ □¬t v ) for every vertex v ∈ V (input). The formulas {(□t i1 ∨ □¬t i1 ), (□t i2 ∨ □¬t i2 ), (□t i3 ∨ □¬t i3 )} belong therefore to the theory T LD of previous example. The full definition of T LD is established in <ref type="bibr">Def. 6</ref> Definition 6 (T LD ). The set of propositional variables AP LD contains a variable t v for every v ∈ V and a variable t i for every i ≥ 1. Consider a logical diagram LD = ⟨V, E, O⟩ and some initializing function f . We define the T LD , the LTL theory over AP LD that contains all the following formulas :</p><formula xml:id="formula_13">-(t 1 ∧ i∈{2,...,|V (M)|} ¬t i ). -i∈{1,...,|V (M)|-1} □(t i ↔ ⃝(¬t i ∧ t i+1 )). -□(t |V (M)| ↔ ⃝(¬t |V (M)| ∧ t 1 )) ). -For every v ∈ V (input), add (□t v ∨ □¬t v ). -For every v ∈ V (output), add □(t u ↔ t v ) where u ∈ V with u → v ∈ E. -For every v ∈ V (not), add □(t u ↔ ¬t v ) where u ∈ V with u → v ∈ E. -For every v ∈ V (or), add □(t v ↔ u∈P t u ) where P = {u | u → v ∈ E}. -For every v ∈ V (and), add □(t v ↔ u∈P t u ) where P = {u | u → v ∈ E}. -if tp(v) = M E , then add □ ⃝ t v ↔ (¬t O(v) ∧ t v ) ∨ (t O(v) ∧ ((t v ∧ ¬t h ) ∨ t e )) -if tp(v) = M H with i = O(v), then: □ ⃝ t v ↔ (¬t O(v) ∧ t v ) ∨ (t O(v) ∧ ¬t h ∧ (t v ∨ t e ))</formula><p>In the above, h is the vertex with h Let us now consider some initializing function f . The second LTL encoding is given by the LTL theory T f that contains, for every vertex</p><formula xml:id="formula_14">v ∈ V (input) ∪ V (M), the LTL formula (t v ↔ f (v)).</formula><p>Definition 7 (T f ). Consider some initiliazing function f for a logical diagram LD = ⟨V, E, O⟩. Then, let T f be the LTL theory over AP LD such that</p><formula xml:id="formula_15">(t v ↔ f (v)) ∈ T f for every v ∈ V (input) ∪ V (M).</formula><p>Consider a word W that is a model of the LTL encoding T LD of a logical diagram LD and T f of an initializing function f . At each time step k, W satisfies the variables t v of the vertices v whose outputs LD f (v, k) are evaluated to True. In other words, the proposed LTL encoding is sound and complete as stated by Theorem 1 proven in section 4.</p><p>Theorem 1. Consider a logical diagram LD = ⟨V, E, O⟩, some initializing function f , and the LTL theories T LD and T f . Let W |= T LD ∪ T f . Then for every v ∈ V and k ≥ 0, LD f (v, k) = ⊤ ⇔ ⟨W, k⟩ |= t v , where t v ∈ AP LD .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">LTL encoding of properties</head><p>In section 2, three types of properties were defined for logical diagrams. Here, we introduce an LTL theory for each different property. We first specify the LTL theory T stable for the stability property. Then, we define the LTL theories T o act and T o deact , respectively for the activation and deactivation properties. Let us consider a logical diagram LD = ⟨V, E, O⟩ and an initializing function f . The stability of LD is satisfied if in some future the output values of all the memory vertices remain unchanged. This can easily be expressed using the temporal operators offered by LTL. We encode the stability property of a logical diagram in the LTL theory T stable that contains the formula ♢(□t v ∨ □¬t v ) for every v ∈ V (M). Using the LTL encoding, we can establish whether or not a logical diagram is stable. In fact, if the model W of the theories T LD and T f is also a model of T stable , then the logical diagram LD is stable for f as stated in Theorem 2. In the case of the logical diagram of Figure <ref type="figure">1</ref>, let f 1 be an initializing function such that f</p><formula xml:id="formula_16">1 (i 1 ) = ⊤, f 1 (i 2 ) = ⊥, f 1 (i 3 ) = ⊤, f 1 (m 1 ) = ⊥ and f 1 (m 2 ) = ⊥. Then, T f1 = {t i1 ↔ ⊤, t i2 ↔ ⊥, t i3 ↔ ⊤, t m1 ↔ ⊥, t m2 ↔ ⊥}.</formula><p>The LTL encoding of the stability property is T stable = {♢(□t m1 ∨ □¬t m1 ), ♢(□t m2 ∨□¬t m2 )}. The LTL model checking proves that the satisfaction relation T LD ∪ T f1 |= T stable is false. Therefore, we conclude that the logical diagram is not stable for the initializing function f 1 . This also means that LD is not uniformly stable.</p><p>Theorem 2. Consider a logical diagram LD = ⟨V, E, O⟩, some initializing function f , and the LTL theories T LD , T f and T stable . Then, LD is stable for f if</p><formula xml:id="formula_17">T LD ∪ T f |= T stable . The logical diagram is uniformly stable if T LD |= T stable .</formula><p>We next encode the activation and deactivation properties. Let o ∈ V (output) be an output vertex and S a subset of vertices. The LTL theory T o act represents the activation property of o for an initial configuration conf S . For every vertex v ∈ S, it contains the formula (t v ↔ conf S (v)) which translates the initial configuration. It also contains the formula (♢□t o ) that translates the activation of the output o in some future. Likewise, the LTL theory T o deact that encodes the deactivation property of the output vertex o for the initial configuration conf S , contains the formulas (♢□¬t o ) and (v ↔ conf S (v)), for every v ∈ S. Theorem 3 states that the satisfaction of the LTL theory T LD and the theories of the activation and deactivation properties means that the encoded logical diagram also satisfies these properties. For the illustration example of Figure <ref type="figure">1</ref>, consider the subset of vertices S = {o 1 , o 2 } and the initial configuration conf S (o 1 ) = ⊥ and conf S (o 2 ) = ⊥. The activation property encoding for the output vertex o 2 is T o2 act = {(t o1 ↔ ⊥), (t o2 ↔ ⊥), ♢□t o2 }. We are looking to find some initializing function f 1 such that T LD ∪ T f1 |= T o2 act . In order to do so, we run an LTL model checking on the formula T LD ∪ T o2 act |= ⊥. Using a BDD based model checking algorithm <ref type="bibr" target="#b32">[7]</ref>, the property is declared as false with the counterexample</p><formula xml:id="formula_18">W |= T LD ∪ T f1 ∪ T o2 act where f 1 (i 1 ) = ⊤, f 1 (i 2 ) = ⊥, f 1 (i 3 ) = ⊥, f 1 (m 1 ) = ⊥ and f 1 (m 2 ) = ⊥. The output o 2 is therefore activated for f 1 .</formula><p>Theorem 3. Consider a logical diagram LD = ⟨V, E, O⟩ and the LTL theory T LD . An output vertex o ∈ V (output) is activated (resp. deactivated) for some initial configuration conf S , if there is an initializing function f such that</p><formula xml:id="formula_19">T LD ∪ T f |= T o act (resp. T LD ∪ T f |= T o deact ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Proofs</head><p>In this section we include the proof of Theorem 1. Lines will be enumerated for readability purposes and to make it easier to refer to different elements of the proof. The proof of Theorem 1 is established on three steps (A), (B) and (C). Moreover, we introduce and prove the following auxiliary lemma, which is later used for the proof of (C).</p><p>Lemma 1. Consider a logical diagram LD = ⟨V, E, O⟩, and the LTL theory</p><formula xml:id="formula_20">T LD . Let W |= T LD and v ∈ V (M) then, for every k ≥ 1 ⟨W, k -1⟩ |= t O(v) iff k ∈ turn O (v).</formula><p>Proof. Proof of Lemma 1.</p><p>1. Let LD = ⟨V, E, O⟩ be a logical diagram and T LD be the corresponding LTL theory over AP LD . 2. Let W be a word such that W |= T LD . 3. We prove the following by induction:</p><formula xml:id="formula_21">if k ∈ turn O (v) then ⟨W, k -1⟩ |= t O(v)</formula><p>for every k ≥ 1. 4. We prove the statement for the base case: k=1. 4.c Based on 4.a and 4.b, the statement 3 holds for k = 1. 5. We assume that the statement in 3 holds for some k ≥ 1. We then prove that it also holds for k + 1 and v ∈ V (M). </p><formula xml:id="formula_22">6. Let k ≥ 1 where k + 1 ∈ turn O (v). We prove that ⟨W, k⟩ |= t O(v) . 7. If O(v) ∈ {2 . . . |V (M)|}:</formula><formula xml:id="formula_23">M)|-1} □(t i ↔ ⃝(¬t i ∧ t i+1 )). 7.d Based on 7.c, ⟨W, k -1⟩ |= (t O(v)-1 ↔ ⃝(¬t O(v)-1 ∧ t O(v) )).</formula><p>7.e From 7.b and 7.d we conclude that ⟨W, k⟩ |= t O(v) . Thus, the statement 3 is true for k + 1. 8. Like in 7, we use 5, Def 3 and Def 6 to prove that 3 also holds when O(v) = 1. 9. Based on 7.e and 8, the statement 3 holds for k + 1. Consequently, for every</p><formula xml:id="formula_24">k ≥ 1, if k ∈ turn O (v) then ⟨W, k -1⟩ |= t O(v)</formula><p>. 10. Next, we prove the following by induction:</p><formula xml:id="formula_25">for k ≥ 1, if ⟨W, k -1⟩ |= t O(v)</formula><p>then k ∈ turn O (v). 11. We prove the statement 10 for the base case: k = 1.</p><p>11.a By Def. 6 we have</p><formula xml:id="formula_26">W |= (t 1 ∧ i∈{2,...,|V (M)|} ¬t i ). Thus, ⟨W, 0⟩ |= t 1 . 11.b By Def. 3, we have k = 1 ∈ turn O (v) where v ∈ V (M) and O(v) = 1.</formula><p>11.c Based on 11.a and 11.b, the statement 10 holds for k = 1. 12. We now assume that the statement 10 holds for some k ≥ 1. We prove that it also holds for k + 1.</p><formula xml:id="formula_27">13. Let v ∈ V (M). Assuming that ⟨M, k⟩ |= t O(v) , we prove that k+1 ∈ turn O (v). 14. If O(v) ∈ {2 . . . |V (M)| -1}: 14.a By Def. 6 we have W |= i∈{1,...,|V (M)|-1} □(t i ↔ ⃝(¬t i ∧ t i+1 )).</formula><p>14.b Based on 14.a we have:</p><formula xml:id="formula_28">⟨W, k⟩ |= (t O(v) ↔ ⃝(¬t O(v) ∧ t O(v)+1 )).</formula><p>14.c By 13 we know that ⟨M, k⟩ |= t O(v) . Therefore, based on 14.b we have</p><formula xml:id="formula_29">⟨M, k + 1⟩ |= t O(v)+1 and ⟨M, k + 1⟩ ⊭ t O(v) .</formula><p>37. Consider a logical diagram LD = ⟨V, E, O⟩ and an initializing function f . The LTL theories are T LD and T f . Let W |= T LD ∪ T f and v ∈ V 38. We prove Theorem 1 for k ≥ 1 by induction. We first prove it holds for the base case k </p><formula xml:id="formula_30">= 1 for v ∈ V (M E ) then for v ∈ V (M H ) and finally for v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output). 39. Let v ∈ V (M E ) with e s - → v ∈ E, h r - → v ∈ E, e ∈ V and h ∈ V . 40. Let k = 1. If O(v) = 1 then k = 1 ∈ turn O (v): 40.a By Def. 6, W |= □ ⃝ t v ↔ (¬t O(v) ∧ t v ) ∨ (t O(v) ∧ ((t v ∧ ¬t h ) ∨ t e )) .</formula><formula xml:id="formula_31">1⟩ |= t v iff ⟨W, 0⟩ |= (t v ∧ ¬t h ) ∨ t e . 40.d By Def. 3, we have LD f (v, 1) = ev((LD f (v, 0)∧¬LD f (h, 0))∨LD f (e, 0)).</formula><p>40.e By 40.c and 40.d and knowing that Theorem 1 is true for k = 0 (proven in (B)), we conclude that ⟨W, 43. In the same way we prove that Theorem 1 holds for k = 1 and v ∈ V (M H ). 44. Similarly to (B) from 27 to 35, we have Theorem 1 holds for k = 1 and v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output). 45. By (A), 42, 43 and 44, Theorem 1 holds for k = 1 and v ∈ V . 46. We assume that Theorem 1 holds for some k ≥ 1. We prove that it also holds for k </p><formula xml:id="formula_32">1⟩ |= t v iff LD f (v, 1) = ⊤. 41. Let k = 1. If O(v) ̸ = 1 (i.e k / ∈ turn O (v)): 41.a By Def. 6, W |= □ ⃝ t v ↔ (¬t O(v) ∧ t v ) ∨ (t O(v) ∧ ((t v ∧ ¬t h ) ∨ t e )) .</formula><formula xml:id="formula_33">+ 1 for v ∈ V (M E ) then for v ∈ V (M H ) and finally for v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output). 47. Let v ∈ V (M E ) with e s - → v ∈ E, h r - → v ∈ E, e ∈ V and h ∈ V . 48. Let k + 1 ∈ turn O (v): 48.a By Def. 6, W |= □ ⃝ t v ↔ (¬t O(v) ∧ t v ) ∨ (t O(v) ∧ ((t v ∧ ¬t h ) ∨ t e )) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>48.b By</head><formula xml:id="formula_34">(v, k+1) = ev((LD f (v, k)∧¬LD f (h, k))∨LD f (e, k)).</formula><p>48.e By 48.c and 48.d and knowing that Theorem 1 holds for k as stated in 46, we conclude that ⟨W, k </p><formula xml:id="formula_35">+ 1⟩ |= t v iff LD f (v, k + 1) = ⊤. 49. Let k + 1 / ∈ turn O(v) : 49.a By Def. 6, W |= □ ⃝ t v ↔ (¬t O(v) ∧ t v ) ∨ (t O(v) ∧ ((t v ∧ ¬t h ) ∨ t e )) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation and discussion</head><p>In this section, we evaluate different LTL model checking (MC) techniques on a real world logical diagram used for a logical controller in a nuclear power plant. The goal is to generate scenarios that could be used for validation tests. These scenarios consist in a set of input values and the set of expected output values. In the testing process, the generated inputs are applied on the logical controller in order to observe the real output values and make sure that they are conform to the expected output values of the generated scenario. However, before generating these scenarios it is important to ensure that the logical diagram satisfies the stability property. An unstable behavior is when a value of one or many outputs keep changing indefinitely for fixed inputs. In this case, the logical diagram has to be revised to satisfy the stability. This is because the unstable behavior means that the expected value of the output is not defined and therefore, generating tests for that output becomes meaningless. Verification of the stability and generating test scenarios are the main focus of this evaluation. The real world logical diagram chosen for the evaluation is representative of many other logical diagrams used by EDF. It contains 16 input vertices, 12 output vertices, 19 memory vertices and 77 vertices of the types {and, or, not}. First, the satisfaction of the stability property is verified. Then, the purpose is to generate scenarios that set an output to the value true when it is initially set to false (i.e. activation scenarios) and others that put it to false when it is initially set to true (i.e. deactivation scenarios). These scenarios will be generated for each different output. The concerned real world logical diagram will be referred to as LD R . The results previously established in this paper were implemented to generate the LTL theory T LD R that encodes the logical diagram LD R as well as the theory T stable encoding the stability of LD R and the theories T oi act and T oi deact for the activation and deactivation of every output vertex o i . The LTL theory of stability is T stable = {♢(□t mi ∨ □¬t mi ) | i ∈ 1, 2, . . . , 19}. We use the LTL model checking techniques to prove the truthfulness of the following LTL property: T LD |= T stable . This property will be referred to as the stability property P stab . If it is proven to be true, then LD R is uniformly stable. If it is not, then we get a counterexample, i.e. a word W that is a model of T LD R and the theory T f of some initializing function f for which LD R is unstable. The LTL theory that encodes the activation of an output o i which is initially deactivated is T oi act = {(t oi ↔ ⊥), (♢□t oi )}. Likewise, the LTL theory that encodes the deactivation of an output o i which is initially activated is T oi deact = {(t oi ↔ ⊤), (♢□¬t oi )}. In order to generate activation and deactivation scenarios for an output o i , we apply the model checking on the property T LD ∪T oi act |= ⊥ referred to as P act (o i ) and the property T LD ∪T oi deact |= ⊥ referred to as P deact (o i ). If P act (o i ) (resp. P deact (o i )) is true, then no activation (resp. deactivation) scenarios exist. Otherwise, if P act (o i ) (resp. P deact (o i )) is not satisfied we get a counterexample, i.e a word W that satisfies all the formulae of the LD R theory T LD R , the activation theory T oi act (resp. the deactivation theory T oi deact ) and the theory T f of some initializing function f for which the output o i is activated (resp. deactivated). The generated word expresses the testing scenario to be applied on the logical controller. We check P act (o i ) and P deact (o i ) properties for every output vertex o i of the 12 outputs in LD R .</p><p>For this evaluation, the verification of each property was done using a well known symbolic model checking tool called NuSMV <ref type="bibr" target="#b30">[5]</ref>. Different techniques were used for each property. In the following, we list the evaluated NuSMV LTL model checking techniques presented in <ref type="bibr" target="#b29">[4]</ref>:</p><p>-The Binary Decision Diagram (BDD) based LTL Model Checking <ref type="bibr" target="#b32">[7]</ref>.</p><p>-Bounded Model Checking (BMC ) based on SAT solvers as described in <ref type="bibr" target="#b26">[1]</ref>.</p><p>-Simple Bounded Model Checking (SBMC) based on SAT solvers as in <ref type="bibr" target="#b34">[9]</ref>.</p><p>The usage of the BDD based technique allows to verify whether an LTL property is true or false and to generate a counterexample when it is false. On the other hand, BMC based techniques prove that a property is false by increasingly exploring the different lengths of counterexamples starting from zero to a preset upper bound. When the maximum bound is reached and no counterexamples are found, then the truth of the property is not decided. In other words, unlike the BDD based technique, the BMC based ones are useful only in case the property is false. In this evaluation, the upper bound of the BMC based techniques was set to 1000. Another technique tested for the verification of the properties is the k-liveness algorithm based model checking technique (k-MC ) as described in <ref type="bibr" target="#b31">[6]</ref>. The technique was introduced in another tool called nuXmv <ref type="bibr" target="#b28">[3]</ref>: an extension for NuSMV. The usage of the technique is presented in <ref type="bibr" target="#b27">[2]</ref>. For this evaluation, the timeout delay for each of the mentioned techniques was set to two hours.</p><p>The verification of the uniform stability of LD R was done by checking the property P stab using the different techniques. The BDD, BMC, and SBMC techniques timed-out. The stability could not therefore be concluded with these techniques. However, the k-MC technique terminated successfully in 26 minutes declaring that the property P stab is true. Therefore, the logical diagram LD R is uniformly stable. Each technique was then tested for the activation (P act (o i )) and deactivation (P deact (o i )) property for every output o i . Except for the BDD technique which timed-out in every single check, all the other techniques successfully generated counterexamples of the same length for every output of LD R . The evaluation results are given by table 1. The SBMC technique was the fastest to generate the counterexample for every output while BMC was considerably slower especially on the longest counterexamples.</p><p>This study shows that the proposed LTL encoding of the logical diagrams is a good candidate for test generation, as multiple counterexamples can be generated starting from different initial configuration defined by the verification process. We tested the proposed LTL encoding on a real, representative logical diagram by comparing different LTL model checking techniques. It turns out that k-MC and SBMC techniques are particularly efficient for checking the properties we defined, allowing us to test the controller's outputs with respect to the LD.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>3 .</head><label>3</label><figDesc>Definition 2 (ev function). The set B of Boolean expressions is defined by the grammar B ::= ⊤ | ⊥ | ¬B | B ∧ B | B ∨ B. We define ev : B → {⊤, ⊥} such that for every a, b ∈ B:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>E and e is the vertex with e s -→ v ∈ E.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>4.a By Def. 3, we have k = 1 ∈ turn O (v) where v ∈ V (M) and O(v) = 1. 4.b By Def 6, we have ⟨W, 0⟩ |= t 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>7 .a</head><label>7</label><figDesc>As established in 6, k +1 ∈ turn O (v). Then by Def 3, k ∈ turn O (w) where w ∈ V (M) and O(w) = O(v) -1. 7.b By 5 and 7.a, we conclude that ⟨W, k -1⟩ |= t O(v)-1 . 7.c By Def. 6 we have W |= i∈{1,...,|V (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>40.b By Lemma 1 we have ⟨W, 0⟩ |= t 1 . 40.c By 40.a and 40.b we have ⟨W,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>41.b By Lemma 1 we have ⟨W, 0⟩ ⊭ t 1 . 41.c By 41.a and 41.b we have ⟨W, 1⟩ |= t v iff ⟨W, 0⟩ |= t v . 41.d By Def. 3, we have LD f (v, 1) = ev(LD f (v, 0)). 41.e By 41.c and 41.d and knowing that Theorem 1 is true for k = 0 (proven in (B)), we conclude that ⟨W, 1⟩ |= t v iff LD f (v, 1) = ⊤. 42. By 40.e and 41.e we conclude that Theorem 1 holds for k = 1 and v ∈ V (M E ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>49.b By Lemma 1 we have ⟨W, k⟩ ⊭ t O(v) . 49.c By 49.a and 49.b we have ⟨W, k + 1⟩ |= t v iff ⟨W, k⟩ |= t v . 49.d Based on Def. 3, we have LD f (v, k + 1) = ev(LD f (v, k)). 49.e By 49.c and 49.d and knowing that Theorem 1 holds for k as stated in 46, we conclude that ⟨W, k + 1⟩ |= t v iff LD f (v, k + 1) = ⊤. 50. By 48.e and 49.e we conclude that Theorem 1 holds for k +1 and v ∈ V (M E ). 51. Likewise, Theorem 1 holds for k + 1 and v ∈ V (M H ). 52. Similarly to (B) from 27 to 35, Theorem 1 holds for k + 1 and v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output). 53. By (A), 50, 51 and 52, Theorem 1 holds for every k ≥ 1 and v ∈ V . Conclusion: theorem 1 holds for every k ≥ 0 and for every v ∈ V .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Lemma 1 we have ⟨W, k⟩ |= t O(v) . 48.c By 48.a and 48.b we have ⟨W, k + 1⟩ |= t v iff ⟨W, k⟩ |= (t v ∧ ¬t h ) ∨ t e . 48.d Based on Def. 3, LD f</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Evaluation of the MC techniques on Pact and P deact of all the 12 outputs. m: minutes; s: seconds; mean: median time of the 12 outputs; min/max : minimum/maximum time out of the 12 outputs; (n): n is the length of the counterexample.</figDesc><table><row><cell>BDD</cell><cell>BMC</cell><cell>SBMC</cell><cell>k-MC</cell></row><row><cell></cell><cell>mean: 26s (33)</cell><cell>mean: 3.4s (33)</cell><cell>mean: 6.2s (33)</cell></row><row><cell>Pact(o) timeout</cell><cell>min: 4.2s (22)</cell><cell>min: 1.3s (22)</cell><cell>min: 3.9s (24)</cell></row><row><cell></cell><cell>max: 2m 11s (57)</cell><cell>max: 11.3s (57)</cell><cell>max: 12.9s (57)</cell></row><row><cell></cell><cell>mean: 18.2s (32)</cell><cell>mean: 2.9s (32)</cell><cell>mean: 5.3s (32)</cell></row><row><cell>P deact (o) timeout</cell><cell>min: 4s (22)</cell><cell>min: 1.3s (22)</cell><cell>min: 3.4s (22)</cell></row><row><cell></cell><cell>max: 35s (39)</cell><cell>max: 4.4s (39)</cell><cell>max: 7.5s (35)</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p><rs type="person">David Carral</rs> is funded by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_aTwZWXc">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">d Based on 14.a, we have ⟨W, k⟩</title>
		<imprint/>
	</monogr>
	<note>1 ↔ ⃝(¬t O(v)-1 ∧ t O(v</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">e From 14.c we have ⟨M, k + 1⟩ ⊭ t O(v) . Thus, based on 14.d we conclude</title>
		<imprint/>
	</monogr>
	<note>that ⟨M, k⟩ ⊭ t O(v)-1</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">f Based on 14.a, we have ⟨W, k -1⟩ |= (t O(v)-1 ↔ ⃝(¬t O(v)-1 ∧ t O(v) )). 14.g From 13 and 14.e we have ⟨M, k⟩ |= t O(v) and ⟨M, k⟩ ⊭ t O</title>
		<imprint/>
	</monogr>
	<note>f ⟨M, k -1⟩ |= t O</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">h As per 12, the statement 10 holds for k. By 14.g, ⟨M, k -1⟩ |= t O(v)-1 . Thus, k ∈ turn O (w) where w ∈ V (</title>
	</analytic>
	<monogr>
		<title level="m">M) and O(w) = O(v) -1</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Like in 14, we use 12</title>
		<imprint/>
	</monogr>
	<note>and Def 6 to prove that statement 10 also holds when O(v) = 1 and O(v) = |V (M)</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Based on 14.i and 15, the statement 10 holds for k + 1. Consequently, for every</title>
		<imprint/>
	</monogr>
	<note>k ≥ 1, if ⟨W, k -1⟩ |= t O(v) then k ∈ turn O (v). 17. Conclusion: By 9 and 16 we conclude that Lemma 1 is true</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Next, we give the proof of Theorem 1. Consider a logical diagram LD = ⟨V, E, O⟩, some initializing function f , and a word W |= T LD ∪ T f ; we prove the following: LD f (v, k) = ⊤ ⇔ ⟨W, k⟩ |= t v where t AP LD (A) for every v ∈ V (input) and k ≥ 0, (B) for every v ∈ V and k = 0 , (C) for every v ∈ V and k ≥ 1 . Proof</title>
	</analytic>
	<monogr>
		<title level="m">Proof of Theorem 1 part (A): v ∈ V (input) and k ≥ 0</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Consider a logical diagram LD = ⟨V, E, O⟩ and an initializing function f . The LTL theories are T LD and T f . Let W |= T LD ∪ T f . Let v ∈ V (input). 19</title>
		<imprint/>
	</monogr>
	<note>By Def. 3 we have LD f (v, k) = ⊤ iff f (v) = ⊤ for every k ≥ 0</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">By Def. 6 we have W |= (□t v ∨□¬t v ) and by Def. 7, ⟨M, 0⟩ |= t v iff f (v) = ⊤. Thus, ⟨M, k⟩ |= t v iff f (v) = ⊤ for every k ≥ 0</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">By 19 and 20 we conclude that Theorem 1 holds for v ∈ V (input) and k ≥ 0</title>
		<imprint/>
	</monogr>
	<note>. Proof. Proof of Theorem 1 part (B): v ∈ V and k = 0</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">initializing function f and the LTL theories</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ld = ⟨v</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">F</forename><surname>Let</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>|= T Ld ∪ T F And V ∈ V . 23</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">We assume that v ∈ V (M)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Based on Def. 3, we have LD f</title>
		<imprint/>
	</monogr>
	<note>⊤ iff f (v) = ⊤</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">7, ⟨W, 0⟩ |= t v ↔ f (v). Consequently, ⟨W</title>
		<author>
			<persName><forename type="first">By</forename><surname>Def</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">0</biblScope>
		</imprint>
	</monogr>
	<note>⟩ |= t v iff f (v) = ⊤</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Based on 24 and 25 we</title>
		<imprint/>
	</monogr>
	<note>conclude that LD f (v, 0) = ⊤ iff ⟨W, 0⟩ |= t v . Thus, the theorem holds for k = 0 and for every v ∈ V (M)</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">We prove Theorem 1 for v ∈ V (not) ∪ V (or) ∪ V (and) ∪ V (output) and k = 0. 29</title>
		<imprint/>
	</monogr>
	<note>We use the proof by induction. Base case: pos(v) = 1</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">We assume that v ∈ V (output) and u → v ∈ E: 30.a By Def. 3</title>
		<imprint/>
	</monogr>
	<note>we have LD f (v, 0) = ev(LD f (u, 0)</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">6, we have W |= □(t u ↔ t v ). Thus</title>
		<author>
			<persName><forename type="first">Def</forename><surname>By</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">t v iff ⟨W</title>
		<imprint>
			<biblScope unit="volume">0</biblScope>
		</imprint>
	</monogr>
	<note>0⟩ |= t u</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">c As per 27, we have pos(u) = 0 and u ∈ V (input) ∪ V (M). 30.d As stated in (A) and 26, the theorem is true for k = 0 and for every w ∈ V (input) ∪ V (M). 30.e By 30.c and 30.d we have ⟨W</title>
		<imprint/>
	</monogr>
	<note>, 0⟩ |= t u iff LD f (u, 0) = ⊤. 30</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">f From 30.a, 30.b and 30.e we conclude that ⟨W, 0⟩ |= t v iff LD f (v, 0) = ⊤. Consequently</title>
		<imprint/>
	</monogr>
	<note>, Theorem 1 holds for pos(v) = 1, k = 0 and v ∈ V (output)</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">we prove that Theorem 1 holds for k = 0 and pos(v) = 1 for the vertices v ∈ V (not), v ∈ V (or)</title>
		<author>
			<persName><surname>Similarly</surname></persName>
		</author>
		<editor>and v ∈ V</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">We assume that v ∈ V (output) with pos(v) = j + 1 and u → v ∈ E: 33.a By Def. 3, we have LD f</title>
		<imprint/>
	</monogr>
	<note>LD f (u, 0)</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">6, we have W |= □(t u ↔ t v ). Thus</title>
		<author>
			<persName><forename type="first">Def</forename><surname>By</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">t v iff ⟨W</title>
		<imprint>
			<biblScope unit="volume">0</biblScope>
		</imprint>
	</monogr>
	<note>0⟩ |= t u</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">c As per 27, we have pos(u) = j. Thus</title>
		<imprint/>
	</monogr>
	<note>based on 32 we have ⟨M, 0⟩ |= t u iff LD f (u, 0) = ⊤</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">we prove that the theorem holds for k = 0 and pos(v) = j + 1 for the vertices v ∈ V (not), v ∈ V (or)</title>
		<author>
			<persName><surname>Similarly</surname></persName>
		</author>
		<editor>and v ∈ V</editor>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">∈ V (not) ∪ V (or)</title>
	</analytic>
	<monogr>
		<title level="m">∪ V (and) ∪ V (output)</title>
		<imprint/>
	</monogr>
	<note>We conclude that Theorem 1 is true for k = 0 and v ∈ v</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Conclusion: by (A)</title>
	</analytic>
	<monogr>
		<title level="m">Proof of Theorem 1 part (C): v ∈ V and k ≥ 1. References</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
		</imprint>
	</monogr>
	<note>Theorem 1 holds for k = 0 and v ∈ V . Proof</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Symbolic model checking without BDDs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems: 5th International Conference, TACAS&apos;99 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS&apos;99</title>
		<meeting><address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">March 22-28, 1999. 1999</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="193" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Bozzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cavada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dorigatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Griggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mariotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Micheli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tonetta</surname></persName>
		</author>
		<title level="m">nuXmv 2.0. 0 User Manual</title>
		<editor>
			<persName><forename type="first">Bruno</forename><surname>Fondazione</surname></persName>
		</editor>
		<editor>
			<persName><surname>Kessler</surname></persName>
		</editor>
		<meeting><address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
		<respStmt>
			<orgName>Tech. Rept.</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The nuXmv symbolic model checker</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cavada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dorigatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Griggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mariotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Micheli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tonetta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification: 26th International Conference, CAV 2014, Held as Part of the Vienna Summer of Logic, VSL 2014</title>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">July 18-22, 2014. 2014</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="334" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Cavada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Jochim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Keighren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pistore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tchaltsev</surname></persName>
		</author>
		<title level="m">Nusmv 2.4 user manual</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
	<note type="report_type">CMU and ITC-irst</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Nusmv 2: An opensource tool for symbolic model checking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Giunchiglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pistore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sebastiani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tacchella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification: 14th International Conference</title>
		<meeting><address><addrLine>CAV; Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002-07-27">2002. July 27-31, 2002. 2002</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="359" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A liveness checking algorithm that counts</title>
		<author>
			<persName><forename type="first">K</forename><surname>Claessen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sörensson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods in Computer-Aided Design (FMCAD)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="page" from="52" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Another look at LTL model checking</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hamaguchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Methods in System Design</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="47" to="71" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Automated test generation using model checking: an industrial evaluation</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Enoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Čaušević</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Ostrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Weyuker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sundmark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Pettersson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Software Tools for Technology Transfer</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="335" to="353" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Simple is better: Efficient bounded model checking for past LTL</title>
		<author>
			<persName><forename type="first">T</forename><surname>Latvala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Heljanko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Junttila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Verification, Model Checking, and Abstract Interpretation: 6th International Conference, VMCAI 2005</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">January 17-19, 2005. 2005</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="380" to="395" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Principles and methods of testing finite state machines-a survey</title>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="1090" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Translating Grafcet specifications into Mealy machines for conformance test purposes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Provost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Roussel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Faure</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Control Engineering Practice</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="947" to="957" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A graph based semantics for Logical Functional Diagrams in power plant controllers</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sfar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Irofti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Croitoru</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Information and Knowledge Systems: 12th International Symposium</title>
		<meeting><address><addrLine>FoIKS; Helsinki, Finland</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2022-06-20">2022. June 20-23, 2022. 2022</date>
			<biblScope unit="page" from="55" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Testing timed automata</title>
		<author>
			<persName><forename type="first">J</forename><surname>Springintveld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vaandrager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>D'argenio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical computer science</title>
		<imprint>
			<biblScope unit="volume">254</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="225" to="257" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
