<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps</title>
				<funder>
					<orgName type="full">Ministère de la culture</orgName>
				</funder>
				<funder ref="#_EC2hvXb">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder>
					<orgName type="full">BnF</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nacira</forename><surname>Abbas</surname></persName>
							<email>nacira.abbas@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université de Lorraine</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<addrLine>Loria</addrLine>
									<postCode>F-54000</postCode>
									<settlement>Nancy</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jérôme</forename><surname>David</surname></persName>
							<email>jerome.david@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Grenoble INP</orgName>
								<orgName type="institution" key="instit5">LIG</orgName>
								<address>
									<postCode>F-38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amedeo</forename><surname>Napoli</surname></persName>
							<email>amedeo.napoli@loria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université de Lorraine</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<addrLine>Loria</addrLine>
									<postCode>F-54000</postCode>
									<settlement>Nancy</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2D9319787C82D801358A8026E795843E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Link key</term>
					<term>Link Key Discovery</term>
					<term>Pattern Structures</term>
					<term>Linked Data</term>
					<term>RDF</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we are interested in the discovery of link keys among two different RDF datasets based on FCA and pattern structures. A link key identifies individuals which represent the same real world entity. Two main strategies are used to automatically discover link keys, ignoring or not the classes to which the individuals belong to. Indeed, a link key may be relevant for some pair of classes and not relevant for another. Then, discovering link keys for one pair of classes at a time may be computationally expensive if every pair should be considered. To overcome such limitations, we introduce a specific and original pattern structure where link keys can be discovered in one pass while specifying the pair of classes associated with each link key, focusing on the discovery process and allowing more flexibility.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>RDF (Resource Description Framework) triples subject,property,object are the basic bricks of the web of data. The elements in the triples are described using terms of RDF Schema and OWL ontologies. The same real world entity can be represented in different datasets by different individuals, i.e. subjects. Data interlinking is the task of finding identity links across datasets. Two main approaches are proposed to perform this task. The first one measures a similarity between subjects considering that the closest the subjects, the more likely they are the same <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b10">11]</ref>. The second one is based on rules, which express sufficient conditions for two subjects to be the same <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b0">1]</ref>. One method using the latter approach is based on link keys <ref type="bibr" target="#b2">[3]</ref> that extend the notion of a key used in databases. Link keys are rules allowing to infer identity links between RDF datasets. A link key takes the form of two sets of pairs of properties associated with a pair of classes. The pairs of properties express sufficient conditions for two subjects, from the associated pair of classes, to be the same. An example of a link key is:</p><p>{ designation, title }, { creator, author }, Book, Novel stating that whenever an instance a 1 of the class Book has the same values for the property designation as an instance b 1 of the class Novel for the property title, and that a 1 and b 1 share at least one value for the properties creator and author, then a 1 and b 1 denote the same entity.</p><p>Usually link keys are not provided. For this reason, a first algorithm was proposed in <ref type="bibr" target="#b2">[3]</ref> for automatically discovering link keys from datasets. This algorithm starts from two RDF datasets, discovers link key candidates then, evaluates these candidates according to quality measures. The quality of a link key candidate is evaluated according to two measures <ref type="bibr" target="#b2">[3]</ref>. The first one, called coverage, relies on the intuition that the more subjects linked by a link key candidate, the more complete this link key is. The second measure, called discriminability, assumes that subjects, in each dataset, have to be distinct. It measures the capability of a link key candidate to discriminate between subjects. In order to take into account these two measures, an harmonic mean might be used.</p><p>The question of using Formal Concept Analysis (FCA) to discover link keys has arisen naturally, since a link key candidate presents some mathematical properties which are similar to the ones of a formal concept in FCA <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>.</p><p>To discover link keys candidates, the existing methods apply one of the following strategies. The first one takes as input all the subjects from two datasets, ignoring the classes to which the subjects belong to, e.g. Book. This strategy generates link key candidates that apply to the whole datasets, i.e. it does not specify the pair of classes associated with each link key candidate. These candidates are then evaluated considering the whole datasets and again without taking into account the pair of classes. This evaluation, however, is not accurate since a link key candidate may be relevant for a pair of classes e.g. Book, Dictionary and not relevant for another pair e.g. Book, Novel . The second strategy consists in finding link key candidates for one particular pair of classes at a time, then evaluating these candidates w.r.t. this particular pair. This strategy repeats the same process for all the pairs of classes issued from the two datasets. This allows a more accurate evaluation of the link key candidates. However, we do not know in advance which classes to take as input at a time. Consequently, a naive approach would be to consider all the pairs of classes from the Cartesian product of the sets of classes of the given datasets, or to require a class alignment <ref type="bibr" target="#b6">[7]</ref>. The first solution is computationally expensive and the second one is not always possible because we do not have systematically a class alignment.</p><p>In this paper, we propose a method based on Pattern Structures, a generalization of Formal Concept Analysis <ref type="bibr" target="#b7">[8]</ref>, that overcomes these limits. This method allows to find link key candidates in one pass, i.e. without iterating on every pair of classes, while specifying the pairs of classes associated with each link key candidate without requiring an a priori alignment. Moreover, datasets may classify the same entities differently, for example, in one dataset "Marie Curie" is an instance of the class "Woman" and at the same time an instance of the class "Scientist", while in an another dataset, "Marie Curie" is an instance of a unique class "FemaleScientist". In this work, we propose to take into account this difference in abstraction, by generalizing the notion of a link key associated with a pair of classes to a link key associated with a pair of class expressions. For example, such a link key candidate could be associated with the pair Woman and Scientist, FemaleScientist where "Woman and Scientist" is a class expression.</p><p>The plan of the paper is as follows. First we give some definitions and notations. Then, we present how the problem of link key discovery is encoded in FCA. After that, we formalize the problem with pattern structure and we show how to discover link keys from two datasets in one pass while specifing which pairs of class expressions are associated with these candidates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>An RDF dataset <ref type="bibr" target="#b9">[10]</ref> is a set of triples s,p,o ∈ (U ∪ B) × U × (U ∪ B ∪ L), where U is a set of IRIs (Internationalized Resource Identifier), B a set of blank nodes i.e. variables or "anonymous resources" and L a set of literals, i.e. values depending on datatypes. To avoid any confusion with FCA objects, we refer to an "object" in an RDF triple as "RDF object". Figure <ref type="figure" target="#fig_6">1</ref> represents two RDF datasets where an example of an RDF triple is b 13 , title,Les Misérables , expressing that the subject b 13 is related through the property title to the RDF object Les Misérables. For short, we will write that b 13 has the value Les Misérables for the property title. The properties in RDF are not functional, i.e. for one property, a subject may be related to more than one RDF object or no RDF object at all. The set of values of a subject s for the property p is given by p(s) such as p(s) = {o| s, p, o ∈ D} e.g. author(b 15 ) = {Stephen King, Peter Straub}. The property rdf:type is used in RDF to expess that a subject belongs to a particular class i.e. that a subject is an instance of a class. For example, the triple b 13 , rdf:type,Novel means that b 13 is an instance of the class Novel. Given a dataset D, the sets S(D), P(D),Cl(D) denote respectively the set of subjects, the set of properties and the set of classes in D. The set of instances of a class C is S(C) = {s | s,rdf:type,C ∈ D}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Link keys</head><p>Given two datasets D 1 and D 2 , we aim to discover identity links between these datasets. An identity link is a statement of the form s 1 , owl:sameAs, s 2 expressing that the subject s 1 from D 1 and the subject s 2 from D 2 represent the same real world entity. For example, given D 1 and D 2 as represented in Figure <ref type="figure" target="#fig_6">1</ref>, the data interlinking task should discover the identity link a 13 ,owl:sameAs,b 13 because the subjects a 13 and b 13 represent both the same book Les Misérables written by Victor Hugo. For short, we write a 13 , b 13 and we call this pair a link. A link key is used to generate such links.</p><p>We distinguish two notions related to link keys. The first one is link key expression which is the syntactic form of a link key, i.e. it does not necessarily generate actual links. The second one is link key candidate which is a link key expression that generates at least a link and it is maximal w.r.t. its generated link set. Actually, link key discovery methods find link key candidates and evaluate them thanks to adapted measures such as proposed in <ref type="bibr" target="#b2">[3]</ref>. Finally, the most relevant candidates will be selected as valid link keys and used to infer identity links among the datasets.</p><p>The notion of a link key has been defined in <ref type="bibr" target="#b4">[5]</ref>. In this paper, we generalize the notion of a link key candidate associated with a pair of classes to a link key candidate associated with a pair of class expressions. We restrict ourselves to a subset of class expressions from description logics <ref type="bibr" target="#b5">[6]</ref>, composed of concept names related by the Boolean operators DL and DL (respectively conjunction and disjunction in description logics). The intuition behind this generalization is that the ontologies on which the datasets rely may use different levels of abstraction to describe entities. For example the set of female scientists may be described by the intersection of the classes Woman and Scientist in one dataset and by the named class FemaleScientist in another dataset. In this case, it would be more accurate to define a link key that discovers links between the class intersection Woman and Scientist and the class FemaleScientist.</p><p>The restriction to DL and DL operators, comes from the fact that we are dealing only with asserted rdf:type in the RDF dataset. Following the semantics of operators in description logics, the set of subjects belonging to</p><formula xml:id="formula_0">C 1 DL C 2 is S(C 1 DL C 2 ) = S(C 1 ) ∩ S(C 2 )</formula><p>and the set of subjects belonging to</p><formula xml:id="formula_1">C 1 DL C 2 is S(C 1 DL C 2 ) = S(C 1 ) ∪ S(C 2 ).</formula><p>Firstly below we introduce the definition of a link key expression associated with a pair of class expressions.</p><p>Definition 1 (Link key expression associated with a pair of class expressions). Let us consider two datasets D 1 and D 2 . Let Eq and In = / 0 be subsets of pairs of properties, such as, Eq ⊆ P(D 1 ) × P(D 2 ), In ⊆ P(D 1 ) × P(D 2 ), Eq ⊆ In. Let CE 1 be a class expression over Cl(D 1 ) and CE 2 a class expression over Cl(D 2 ). k = (Eq, In, CE 1 ,CE 2 ) is a link key expression associated with the pair of class expressions CE 1 ,CE 2 over D 1 and D 2 .</p><p>Actually we replace the pair of named classes in a link key expression as defined in <ref type="bibr" target="#b4">[5]</ref> with a pair of class expressions. As example of link key expression is k = ({ given,year }, { given,year }, Woman DL Scientist,FemaleScientist ).</p><p>A link key expression associated with a pair of class expressions may generate links among these class expressions. We define this link set as follows.</p><p>Definition 2 (Link set generated by a link key expression associated with a pair of class expressions). Given two datasets D 1 and D 2 . Let k = (Eq, In, CE 1 ,CE 2 ) be a link key expression associated with the pair of class expressions CE 1 ,CE 2 over D 1 and D 2 . The link set generated by k is the subset</p><formula xml:id="formula_2">L k ⊆ (S(CE 1 ) × S(CE 2 )) defined as L k = { s 1 , s 2 ∈ S(CE 1 ) × S(CE 2 )) | p 1 (s 1 ) = p 2 (s 2 ) = /</formula><p>0 for all p 1 , p 2 ∈ Eq and p 1 (s 1 ) ∩ p 2 (s 2 ) = / 0 for all p 1 , p 2 ∈ In}.</p><p>As the properties in RDF are not functional, we compare the values of subjects in two ways (i) Eq are pairs of properties for which two subjects share all their values and (ii) In are those pairs of properties for which two subjects share at least one value. A link key candidate is a link key expression that generates at least a link and it is maximal on the link set that it generates. To define "maximality" we have to define an order between link key expressions. Definition 3 (Meet, join of link key expressions associated with a pair of class expressions). Given two datasets D 1 and D</p><formula xml:id="formula_3">2 . Let k 1 = (Eq 1 , In 1 , CE 1 1 ,CE 1 2 ) and k 2 = (Eq 2 , In 2 , CE 2 1 ,CE<label>2</label></formula><p>2 ) be link key expressions over D 1 and D 2 . The meet and the join of k 1 and k 2 are defined as follows:</p><formula xml:id="formula_4">k 1 k 2 = (Eq 1 ∩ Eq 2 , In 1 ∩ In 2 , (CE 1 1 DL CE 2 1 ), (CE 1 2 DL CE 2 2 ) ) k 1 k 2 = (Eq 1 ∪ Eq 2 , In 1 ∪ In 2 , (CE 1 1 DL CE 2 1 ), (CE 1 2 DL CE 2<label>2</label></formula><p>) ) The link set of a link key expression k 1 k 2 is equal to the union of the link sets of k 1 and k 2 . The less the number of pairs of properties to compare in a link key expression, the more the pairs of subjects satisfying these pairs of properties. Thus the larger the classes in a link key expression, and dually for k 1 k 2 .</p><p>As an example from the datasets represented in Figure <ref type="figure" target="#fig_6">1</ref>, the meet of two link key expressions k 1 = ({ given,firstName }, { given,firstName }, Woman,FemaleScientist ) and k 2 = ({ given,firstName }, { given,firstName , name,familyN }, </p><formula xml:id="formula_5">(Woman DL Scientist),FemaleScientist ) is k 1 k 2 = ({ given,firstName }, { given,firstName }, Woman,FemaleScientist ) . The join k 1 k 2 = ({</formula><formula xml:id="formula_6">k = h∈[k] h such that [k] = {h | L k = L h }</formula><p>Intuitively the link sets generated by link key expressions form a partition of the set of link key expressions. Link key candidates are the maximal elements of the classes of this partition. This definition matches the definition of a closed set. This explains the use of Formal Concept Analysis <ref type="bibr" target="#b8">[9]</ref> for link key discovery since the intent and the extent of a formal concept are closed sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Link key discovery with Formal Concept Analysis</head><p>The link key discovery based on Formal Concept Analysis is detailed in <ref type="bibr" target="#b4">[5]</ref>. Given two datasets D 1 and D 2 and a pair of classes C 1 ,C 2 ∈ Cl(D 1 ) ×Cl(D 2 ). The LK-formal context or the formal context for link key candidates associated with a pair of classes C 1 ,C 2 is the triple (S(C 1 ) × S(C 2 )), {∃, ∀} × P(D 1 ) × P(D 2 ), I such that:</p><p>-The set of objects of the LK-formal context is the set of pairs of subjects s 1 , s 2 ∈ (S(C 1 ) × S(C 2 )). -The set of attributes of the LK-formal context is the set of pairs of properties p 1 , p 2 ∈ P(D 1 ) × P(D 2 ) preceded by a quantifier in {∃, ∀} i.e. ∀ p 1 , p 2 and ∃ p 1 , p 2 . -The relation I between an object and an attribut is defined as follows:</p><formula xml:id="formula_7">s 1 , s 2 I ∀ p 1 , p 2 iff p 1 (s 1 ) = p 2 (s 2 ) = / 0 s 1 , s 2 I ∃ p 1 , p 2 iff p 1 (s 1 ) ∩ p 2 (s 2 ) = / 0</formula><p>Link key discovery based on FCA takes as input one pair of classes at a time. To discover link key candidates, in one pass, we take as input the pair of classes owl:Thing, owl:Thing , where owl:Thing is a class containing all the subjects. The generated link key candidates will be associated with the pair owl:Thing,owl:Thing which means that they apply to the whole datasets. Figure <ref type="figure">2</ref> presents the concept lattice related to the LK-formal context associated with the pair of classes owl:Thing, owl:Thing for the datasets D 1 and D 2 introduced in Figure <ref type="figure" target="#fig_6">1</ref>. It was shown in <ref type="bibr" target="#b4">[5]</ref> that the intents of the formal concepts of the lattice generated from the LK-formal context C 1 ×C 2 , {∃, ∀} × P(D 1 ) × P(D 2 ), I are the link key candidates for the pair of classes C 1 ,C 2 . In this case, if (A, B) is a formal concept, the link key candidate in (A, B) is k B = (Eq, In, C 1 ,C 2 ) where Eq = {∀ p 1 , p 2 ∈ B}, In = {∃ p 1 , p 2 ∈ B} and the link set generated by k B is the extent of this formal concept L k B = A. For example, k 8 corresponds to the link key candidate ({ given,firstName }, { given,firstName }, owl:Thing, owl:Thing ). Now, to evaluate the quality of a link key candidate in terms of coverage and discriminability, let us consider L ⊆ (S(CE 1 )×S(CE 2 )) and The coverage of a link key candidate k associated with a pair of class expressions CE 1 ,CE 2 is denoted by co(k) and defined as:</p><formula xml:id="formula_8">π 1 (L) = {s 1 ∈ S(CE 1 )| s 1 , s 2 ∈ L}, π 2 (L) = {s 2 ∈ S(CE 2 )| s 1 , s 2 ∈ L},</formula><formula xml:id="formula_9">co(k) = |π 1 (L k ) ∪ π 2 (L k )| |S(CE 1 ) ∪ S(CE 2 )|</formula><p>The coverage is the proportion between the number of instances identified (linked) by k and the overall number of instances of the two class expressions. This means that the coverage measures how general a link key candidate is. When co(k) is equal to 1, this means that all instances from CE 1 and CE 2 are identified by the link key candidate k.</p><p>The discriminability of a link key candidate k associated with a pair of class expressions CE 1 ,CE 2 is denoted by di(k) and defined as:</p><formula xml:id="formula_10">di(k) = min(|π 1 (L k ), π 2 (L k )|) |L k | di(k)</formula><p>is the proportion of the minimum number of instances identified by k and the number of links generated by k. When di(k) is equal to 1, then the link key is perfectly discriminant, i.e. it generates one-to-one mappings.</p><p>Coverage and discriminability are aggregated by the harmonic mean denoted hm(k) and defined as:</p><formula xml:id="formula_11">hm(k) = 2 1 co(k) + 1 di(k)</formula><p>The coverage, discriminability, and harmonic mean of the link key cadidate k 9 in the lattice in Figure <ref type="figure">2</ref>, are respectively, co=0.46, di=1, hm=0.63. The link key discovery methods return as link keys the link key candidates whose harmonic mean value is the highest. In this example, they return the link key candidates k 7 , k 8 and k 9 , because they have the highest hm. However, even if these candidates are relevant for the pair (Woman DL Scientist),FemaleScientist , they do not generate any links for the pair Book,Dictionary . In fact for this latter pair, the link key candidate k 2 is more relevant, because it generates only and all correct links, even if it has a low hm. For the pair Book,Novel , the candidate k 4 is more relevant. Even if they are relevant, these link key candidates show a low hm because they are evaluated considering the whole datasets i.e. owl:Thing, owl:Thing .</p><p>We propose in the following our main contribution which is a method based on pattern structures for discovering relevant link keys for given pairs of classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Link key discovery within Pattern Structures</head><p>In the following, we propose a method based on pattern structures, a generalization of FCA <ref type="bibr" target="#b7">[8]</ref>, that, given two datasets, discovers link key candidates in one pass (without iterating on every pair of classes) while specifying the classes associated with each link key candidate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">A Pattern Structure for Link Key Discovery</head><p>We define the pattern structure for link key candidates discovery where the set of objects is the set of pairs of subjects issued from two datasets. Actually these pairs correspond to potential links. In the pattern structure, the description of a potential link is given by the maximal link key expression that generates this link. Then the meet of two descriptions corresponds to the meet of link key expressions as introduced in Definition 3.  <ref type="figure">(E,</ref><ref type="figure"></ref> ) is a meet semilattice where the meet of two descriptions</p><formula xml:id="formula_12">k 1 = (Eq 1 , In 1 , CE 1 1 ,CE 1 2 ) and k 2 = (Eq 2 , In 2 , CE 2 1 ,CE 2 2 ) is given in Defini- tion 3: k 1 k 2 = (Eq 1 ∩ Eq 2 , In 1 ∩ In 2 , (CE 1 1 DL CE 2 1 ), (CE 1 2 DL CE 2 2 )</formula><p>). The descriptions are partially ordered by defined w.r.t. the similarity operator .</p><formula xml:id="formula_13">If k 1 k 2 = k 1 ⇔ k 1 k 2 . -The mapping δ : S(D 1 ) × S(D 2 ) → E associates each pair of subjects s 1 , s 2 ∈ S(D 1 ) × S(D 2 ) to its description δ ( s 1 , s 2 ) = (Eq, In, CE 1 ,CE 2 ) where, Eq = { p 1 , p 2 |p 1 (s 1 ) = p 2 (s 2 ) = / 0}, In = { p 1 , p 2 |p 1 (s 1 ) ∩ p 2 (s 2 ) = / 0}, CE 1 (resp. CE 2 ) is the conjunction of the classes of s 1 (resp. s 2 ) over Cl(D 1 ) (resp. Cl(D 2 )).</formula><p>The LK-pattern structure for the datasets in Figure <ref type="figure" target="#fig_6">1</ref> is given in Table <ref type="table" target="#tab_0">1</ref>. The set of objects is the set of pairs of subjects from S(D 1 )×S(D 2 ). The set of potential object descriptions E is the set link key expressions over D 1 and D 2 . For example, such a description is given by k = ({ designation,title }, { designation,title }, Book,Dictionary ). We may calculate the description of the pair a 8 , b 8 ∈ S(D 1 ) × S(D 2 ) as follows:</p><formula xml:id="formula_14">δ ( a 8 , b 8 ) = ({ given,firstName , familyN,name }, { given,firstName , familyN,name }, (Woman DL Scientist),FemaleScientist )</formula><p>The meet of the two descriptions k 1 and k 2 can be calculated as follows:</p><p>k 1 = ({ given,firstName , familyN,name }, { given,firstName , familyN,name },</p><formula xml:id="formula_15">(Woman DL Scientist),FemaleScientist ) k 2 = ({ given,firstName }, { given,firstName }, Woman,FemaleScientist ) k 1 k 2 = ({ given,firstName }, { given,firstName }, Woman,FemaleScientist ) k 1 k 2 = k 2 , hence, k 2 k 1</formula><p>The derivation operators . form a Galois connection between 2 S(D 1 )×S(D 2 ) and E and defined as follows:</p><formula xml:id="formula_16">L = s 1 ,s 2 ∈L δ ( s 1 , s 2 ) L ⊆ S(D 1 ) × S(D 2 ) k = { s 1 , s 2 ∈ S(D 1 ) × S(D 2 )|k δ ( s 1 , s 2 )} k ∈ E Objects Descriptions S(D 1 ) × S(D 2 )Eq</formula><p>In CE  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Discussion</head><p>Figure <ref type="figure" target="#fig_7">3</ref> represents the pattern concept lattice generated from the LK-pattern structure in Table <ref type="table" target="#tab_0">1</ref>. Each intent of a pattern concept represents a link key candidate associated with a pair of class expressions. For example the link key candidate k 9 is associated with the pair of class expressions (Woman DL Scientist),FemaleScientist . It should be noticed that the link key candidate k 9 in Figure <ref type="figure" target="#fig_7">3</ref> corresponds to the link key candidate k 9 in Figure <ref type="figure">2</ref> (calculated with plain FCA). In the pattern concept lattice we can see that the link key k 9 is associated with the pair of class expressions (Woman DL Scientist),FemaleScientist , whereas this was not possible using plain FCA (see <ref type="bibr" target="#b4">[5]</ref>). Moreover, different link key candidates may have the same sets of pairs of properties (Eq and In) but are associated with different pairs of class expressions. For example, k 1a and k 1b , which correspond to the link key candidate k 1 in Figure <ref type="figure">2</ref>   <ref type="table" target="#tab_0">1</ref> appearing in such link key candidates are used to describe subjects belonging to different classes. For example, the property title appearing in k 1a and k 1b is used to describe the instances of the classes Dictionary and Novel. Furthermore, we may notice that one pair of classes can be associated with more than one link key candidate. For example, we can see the pair of classes Book,Novel (in orange) which is associated with four link key candidates k 3 , k 4 , k 5 and k 6 . This means that there are four possible choices to select a link key candidate for the pair Book,Novel among the four candidates k 3 , k 4 , k 5 and k 6 .</p><p>Specifying the pairs of classes associated with a link key candidate is a critical task to properly evaluate this candidate. For example, the link key candidate k 4 , in Figure <ref type="figure">2</ref>, shows a low harmonic mean hm=0.37, because it is evaluated on the whole datasets. Consequently, k 4 is poorly ranked by a system based on FCA. This means that k 4 will not be returned as a relevant candidate despite the fact that it generates all the correct links between the classes Book and Novel while no other candidate is able to generate those links. By contrast, in Figure <ref type="figure" target="#fig_7">3</ref>, k 4 , shows a good harmonic mean hm=0.85 because it is evaluated on the "right pair" of classes Book,Novel . The candidate k 4 will be returned by a LK-pattern structure as a relevant candidate for the pair of classes Book,Novel . Hence, we can appreciate the importance of introducing the notion of LK-pattern structure and the discovery of link key candidates associated with pairs of classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusion</head><p>Link keys are used to discover identity links across RDF datasets. In this paper, given two datasets, we propose a method based on pattern structures and introduce the notion of LK-pattern structure to discover link key candidates. An added value of the present method is to allow the discovery of link key candidates while specifying the classes to which they apply. This is a substantial improvement for properly evaluating the discovered link key candidates. For future work we plan to study the scalability and the efficiency of the method by running experiments on real-world datasets.We also intend to extend this research work by taking advantage of domain ontologies related to the datasets under study.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 Fig. 1 .</head><label>21</label><figDesc>Fig. 1. Example of two RDF datasets. On the left-hand side, the dataset D 1 populated with instances of the classes: Woman, Scientist and Book. On the right-hand side, the dataset D 2 populated with instances of the classes: FemaleScientist, Dictionary and Novel</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>For example a 15 , b 15 ∈ L k where: k = ({ designation,title }, { designation,title , creator,author }, Book,Novel ) because a 15 , b 15 ∈ S(Book) × S(Novel) and designation(a 15 ) = title(b 15 ) = / 0 and creator(a 15 )∩author(b 15 ) = / 0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 4 (</head><label>4</label><figDesc>given,firstName }, { given,firstName , name,familyN }, (Woman DL Scientist),FemaleScientist ). Now we formally define a link key candidate associated with a pair of class expressions. Link key candidate associated with a pair of class expressions). Let us consider two datasets D 1 and D 2 . Let k = (Eq, In, CE 1 ,CE 2 ) be a link key expression associated with the pair of class expressions CE 1 ,CE 2 over D 1 and D 2 . k is a link key candidate for D 1 and D 2 if -L k = / 0, and -</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>S(D 1 ){ a 11 , 10 Fig. 2 .</head><label>111102</label><figDesc>Fig. 2. The lattice of the LK-formal context associated with the pair of classes owl:Thing, owl:Thing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>where π 1 (L) is the set of instances of the class expession CE 1 appearing in L and π 2 (L) is the set of instances of the class expession CE 2 appearing in L.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Definition 5 (</head><label>5</label><figDesc>Pattern structure for link key candidate discovery). Given two datasets D 1 and D 2 . The pattern structure for link key candidate discovery between D 1 and D 2 , called hereafter the LK-pattern structure, is the triple (S(D 1 ) × S(D 2 ), (E, ), δ ) where: -The set of objects S(D 1 ) × S(D 2 ) is the set of pairs of subjects over D 1 and D 2 . -E is the set of potential object descriptions. A description is a link key expression k = (Eq, In, CE 1 ,CE 2 ) over D 1 and D 2 . -</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 1 As</head><label>1</label><figDesc>usual, L is a closed set if L = L and k is a closed set if k = k. Then a pattern concept verifies: L = k and k = L. The link key expression k is a link key candidate for the two datasets D 1 and D 2 if and only if (L, k) is a pattern concept of the LK-pattern structure for D 1 and D 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 3 .</head><label>3</label><figDesc>Fig.3. Pattern concept lattice generated from the LK-pattern structure in Table1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>LK-pattern structure for the datasets given in</figDesc><table><row><cell>1 ,CE 2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>, have the same sets of pairs of properties { designation,title }, { designation,title }, but they are associated with different pairs of class expressions: k 1a is associated with Book,(Dictionary DL Novel) and k 1b is associated with Book,Novel . The properties { creator,author , designation,title } { creator,author , designation,title }</figDesc><table><row><cell></cell><cell></cell><cell>k0</cell></row><row><cell></cell><cell></cell><cell>S(D1) × S(D2)</cell></row><row><cell></cell><cell></cell><cell>*</cell></row><row><cell>k8</cell><cell></cell><cell>k7</cell></row><row><cell>co=.92 di=.85 hm=.89</cell><cell cols="2">co=.92 di=.85 hm=.89</cell></row><row><cell>{ a2, b3 }</cell><cell></cell><cell>{ a9, b8 }</cell></row><row><cell>{ given,firstName },</cell><cell cols="2">{ familyN,name }},</cell></row><row><cell>{ given,firstName }</cell><cell cols="2">{ familyN,name }}</cell></row><row><cell>Woman,FemaleScientist</cell><cell cols="2">Scientist,FemaleScientist</cell></row><row><cell>k9</cell><cell></cell><cell></cell></row><row><cell>{ a3, b3 , a4, b4 , a5, b5 , co=1 di=1 hm=1</cell><cell></cell><cell>k1a co=1 di=.71 hm=.83</cell><cell>k3 co=.75 di=.60 hm=.66</cell></row><row><cell>a6, b6 , a7, b7 , a8, b8 } { familyN,name , given,firstName }, { familyN,name , given,firstName } (Woman DLScientist),FemaleScientist</cell><cell></cell><cell>{ designation,title }, { designation,title } Book,(Dictionary DLNovel)</cell><cell>{}, { creator,author } Book,Novel</cell></row><row><cell>k1b</cell><cell></cell><cell>k4</cell><cell>k5</cell></row><row><cell cols="2">co=.57 di=.50 hm=.53</cell><cell>co=.75 di=1 hm=.85</cell><cell>co=.50 di=.0.50 hm=.50</cell></row><row><cell cols="2">{ a11, b12 , a12, b11 }</cell><cell>{ a15, b15 }</cell><cell>{ a13, b14 , a14, b13 }</cell></row><row><cell cols="2">{ designation,title },</cell><cell cols="2">{ designation,title }</cell><cell>{ creator,author },</cell></row><row><cell cols="2">{ designation,title }</cell><cell cols="2">{ designation,title , creator,author }</cell><cell>{ creator,author }</cell></row><row><cell cols="2">Book,Dictionary</cell><cell>Book,Novel</cell><cell>Book,Novel</cell></row><row><cell></cell><cell></cell><cell>k2</cell><cell>k6</cell></row><row><cell></cell><cell cols="2">co=.57 di=1 hm=.72</cell><cell>co=.50 di=1 hm=.66</cell></row><row><cell></cell><cell cols="2">{ a11, b11 , a12, b12 }</cell><cell>{ a13, b13 , a14, b14 }</cell></row><row><cell cols="3">{ date,year , designation,title }</cell></row><row><cell cols="3">{ date,year , designation,title }</cell></row><row><cell></cell><cell cols="2">Book,Dictionary</cell><cell>Book,Novel</cell></row><row><cell></cell><cell></cell><cell>k10</cell></row><row><cell></cell><cell></cell><cell>P(D1) × P(D2)</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>This work has been supported by the <rs type="funder">ANR</rs> project <rs type="projectName">Elker</rs> (<rs type="grantNumber">ANR-17-CE23-0007-01</rs>) and the <rs type="funder">BnF</rs> in the context of the agreement between <rs type="institution">Inria</rs> and <rs type="funder">Ministère de la culture</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_EC2hvXb">
					<idno type="grant-number">ANR-17-CE23-0007-01</idno>
					<orgName type="project" subtype="full">Elker</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Uncertainty-sensitive reasoning for inferring same as facts in linked data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Al-Bakri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lalande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ECAI</title>
		<meeting>ECAI</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="698" to="706" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Inferring same-as facts from linked data: an iterative import-by-query approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Al-Bakri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lalande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI</title>
		<meeting>AAAI</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Data interlinking through robust linkkey extraction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECAI</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="15" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">What can FCA do for database linkkey extraction?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FCA4AI workshop</title>
		<meeting>FCA4AI workshop</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="85" to="92" />
		</imprint>
	</monogr>
	<note>No commercial editor</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Link key candidate extraction with relational concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vizzini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DAM</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="2" to="20" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<title level="m">The description logic handbook: Theory, implementation and applications</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Ontology Matching, Second Edition</title>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Shvaiko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Pattern structures and their projections</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wille</surname></persName>
		</author>
		<title level="m">Formal Concept Analysis -Mathematical Foundations</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Foundations of semantic web technologies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krotzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>CRC press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Limes-a time-efficient approach for large-scale link discovery on the web of data</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C N</forename><surname>Ngomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Auer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IJCAI</title>
		<meeting>IJCAI</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">L2r: A logical method for reference reconciliation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Saïs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pernelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI</title>
		<meeting>AAAI</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="329" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Silk-a link discovery framework for the web of data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Volz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gaedke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kobilarov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LDOW</title>
		<imprint>
			<biblScope unit="volume">538</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
