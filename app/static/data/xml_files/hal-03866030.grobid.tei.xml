<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exploring the Application of Graph-FCA to the Problem of Knowledge Graph Alignment</title>
				<funder ref="#_GsyZxVj">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Sébastien</forename><surname>Ferré</surname></persName>
							<email>ferre@irisa.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">IRISA Campus de Beaulieu</orgName>
								<address>
									<postCode>35042</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Exploring the Application of Graph-FCA to the Problem of Knowledge Graph Alignment</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C8B188C0D7695091058A0108311439CD</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Knowledge Graphs (KG) have become a widespread knowledge representation. When different KGs exist for some domain, it is valuable to merge them into a richer KG. This is known as the problem of KG alignement, which encompasses related problems such as entity alignement or ontology matching. Although most recent approaches rely on supervised representation learning, Formal Concept Analysis (FCA) has also been proposed as a basis for symbolic and unsupervised approaches. We here explore the application of Graph-FCA, an extension of FCA for KGs, to different scenarios of KG alignments: (A) when the two KGs have common values, and (B) when pre-aligned pairs are known. We show that, compared to previous FCA-based approaches, Graph-FCA allows for a more natural and scalable representation of the KGs to be aligned, and makes it simpler to extract alignments from the concepts. It also features flexibility w.r.t. different alignment scenarios.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A knowledge graph (KG) is a modelling of some domain of interest that supports many tasks such as question answering, reasoning over data or machine learning. They are commonly represented in languages of the Semantic Web (RDF(S), OWL), and published on the web as Linked Open Data (LOD) <ref type="bibr" target="#b8">[9]</ref>. A KG is a set of entities described by their classes, properties, and relations with other entities. Due to the open nature of the web, it is common that a same domain of interest is modelled by multiple KGs. Those have in general overlapping, hence redundant, information but also complementary information. It is therefore valuable to merge the different KGs that model a same domain into a single richer KG. The difficulty is that different KGs generally use different entity identifiers (URIs) for the same real entities, and even different schemas or ontologies, i.e. different classes, properties and relations.</p><p>The problem of merging two KGs consists in discovering equivalence links between entities and/or between schemas, which is known as knowledge graph alignment. A number of other terms are used in the literature, partially depending on the focus on entities or on the schema: entity alignment, entity matching, ontology alignment/matching, data interlinking <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b13">14]</ref>. In order to align two KGs, they must have something in common, some alignment seeds. Those seeds can be: a common language for the string values (e.g., names, titles), a set pre-aligned pairs, or a combination of those. Most existing work consider a single scenario, and may not apply to other scenarios. A common scenario (called Scenario A in the following) is to only assume a common language, and no pre-aligned pairs. This is an unsupervised setting. Another common scenario in recent literature (called Scenario B in the following), assumes that a set of pre-aligned pairs is available <ref type="bibr" target="#b13">[14]</ref>. This is a supervised setting where the pre-aligned pairs serve as a training set. Most approaches use similarity measures that combine terminological features (i.e., strings for names, titles, ...), and structural features (i.e., relationships between entities). A recent trend is to use KG embeddings as such features. Formal Concept Analysis (FCA) <ref type="bibr" target="#b6">[7]</ref> and FCA extensions, such as Pattern Structures <ref type="bibr" target="#b5">[6]</ref> and Relational Concept Analysis <ref type="bibr" target="#b10">[11]</ref>, have been recently proposed for tasks related to KG alignment <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b0">1]</ref>. Formal concepts are used there as a symbolic form of similarity.</p><p>In this paper, we explore the application of Graph-FCA <ref type="bibr" target="#b4">[5]</ref>, an extension of FCA specifically designed for analyzing KGs, to the two main scenarios of KG alignment. We propose an approach that makes three contributions to previous FCA-based approaches.</p><p>1. A more natural and scalable representation. The formal context is the union (rather than the product) of the two KGs to be aligned, with minor adjustments depending on the alignment scenario. 2. A uniform alignment extraction methods for both entities and schema elements (classes, properties and relations). All alignement pairs are extracted from concept extents (rather than from both extents and intents). 3. A flexible approach w.r.t. different scenarios. They are handled through minor adjustments to the representation of KGs.</p><p>We show the effectiveness of our approach on a few use cases taken or adapted from previous FCA-based work. Section 2 states the KG alignment problem. Section 3 presents the related work. Section 4 shortly describes Graph-FCA. Section 5 explains our approach from principles to concrete application, and discusses the results on the two main scenarios. Section 6 concludes and draws perspectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem Statement</head><p>We start by defining knowledge graphs (KG), taking care to distinguish between classes, properties and relations in order to allow for a more accurate modelling. Many work on KGs only consider entities and relations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (knowledge graph).</head><p>A knowledge graph is a structure G = E, C, P, R, T , where E is the set of entities, C is the set of classes, P is the set of properties, R is the set of relations, and T is a set of triples. The In RDF and OWL, entities are called individuals, values are called literals, and the distinction between properties and relations corresponds to the distinction in OWL between datatype properties and object properties. URIs are used to identify entities, classes, properties, and relations.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> shows two knowledge graphs, one on the left and another on the right. It falls into Scenario A as it uses completely different schemas and it only shares proper names of entities (square boxes). The objective is to find the best alignement between the two. This is the most complex example considered by Atencia et al <ref type="bibr" target="#b2">[3]</ref> (Fig. <ref type="figure">8</ref>, p.23). It involves cyclic dependencies that have to be taken into account to find the correct alignment.</p><p>It is easy to find that o1:z1 aligns with o2:i1 because they are the unique entities in each KG to have "Dupont" as a value. From this first alignement, one can find two additional alignments: property o1:lastname with o2:name, and class o1:Person with o2:Inhabitant. It is more difficult to find that o1:z3 aligns with o2:i3. o1:z3 has lastname "Dubois" but both o2:i2 and o2:i3 have name "Dubois". o1:z3 has a home/address in Paris but so do o2:i2 and o2:i3. Traversing deeper in the graph, we find that o1:z3's home is owned by a Dupont who lives in Grenoble. Something equivalent can be found for o2:i3 but not for o2:i2. We observe that the alignment of entities, classes, properties and relations depend on each other, and that handling long-range dependencies may be necessary to resolve alignments.</p><p>The example in Figure <ref type="figure" target="#fig_0">1</ref> can be adapted to cover Scenario B where string values are in different incomparable languages but some pre-aligned pairs may be available. Imagine for instance that the strings of the left-side KG are in Chinese, and that we already know that o1:z1 aligns with o2:i1. Without that pre-aligned pair, one only has structural information, which is not enough to discriminate between the different people and places. Knowing that o1:z1 aligns with o2:i1 (Dupont), one can align classes o1:Person and o2:Inhabitant, and also relations o1:home and o2:address. By propagating alignments through neighborhood, starting from the pre-aligned pair, it is here possible to find the correct alignment for all elements: first o1:h1 with o2:a1, then o1:city with o2:city and o1:z2 with o2:i2, and so on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Related Work</head><p>The alignment of KGs (or entities, or ontologies) is a matter of defining and combining similarity measures <ref type="bibr" target="#b1">[2]</ref>. There are four kinds of similarities, depending on the kind of information that is used. Terminological similarity is based on the strings that are used to name entities and schema elements. Structural similarity is based on the description of entities by classes, properties, and relations. Extensional similarity is based on the extensions of classes. Semantic similarity is based on external sources of knowledge, and on automated reasoning (e.g., subsumption checks in description logics). Terminological and structural similarities are the most common methods, and are often combined to get better results. In general, strutural similarity does not consider the KG as a whole but use either tree-shaped descriptions extracted from the knowledge graph, or neighbor-based propagation of similarity values (e.g., RiMOM-IM <ref type="bibr" target="#b12">[13]</ref>).</p><p>The trend in KG alignement is to use representation learning methods, in a supervised setting where a significant number of pre-aligned pairs is supposed to be known <ref type="bibr" target="#b13">[14]</ref>. The principle is first to learn embeddings for the two KGs that coincide for the pre-aligned pairs. Other alignments can then be found by nearest-neighbor search in the embedding space. Many representation learning methods exist, such as TransE <ref type="bibr" target="#b3">[4]</ref>, ComplEx-N3 <ref type="bibr" target="#b9">[10]</ref> or R-GCN <ref type="bibr" target="#b11">[12]</ref>.</p><p>Different variants of FCA have been applied to tasks related to KG alignment. Classical FCA was used for aligning (aka. matching) several biomedical ontologies, in a system called FCA-Map <ref type="bibr" target="#b14">[15]</ref>. The scenario is here to match classes and relations based on their names and their relationships (e.g., class hierarchies, class disjointness, relation domains and ranges), there are no entities per se. The intuition behind using FCA is that if a concept has only two objects in its extent (here classes and relations), one from each ontology, then this is a strong indication that the two entities should be aligned. This is called an anchor in FCA-Map. The global alignment is obtained by defining a succession of five formal contexts, and computing their concept lattices. This can be seen as an ad-hoc form of Relational Concept Analysis (RCA) <ref type="bibr" target="#b10">[11]</ref>, with the notions of iterative concept formation, and relational attributes.</p><p>RCA was used for the task of link key discovery <ref type="bibr" target="#b2">[3]</ref>, which consists in finding pairs of properties and/or relations that are identifying keys for the entities of a pair of classes. In Figure <ref type="figure" target="#fig_0">1</ref>, the pair o1:lastname/o2:name is not a link key for the pair of classes o1:Person/o2:Inhabitant, but combined with the pair o1:home/o2:address, it is. Link key discovery is somewhat stronger than KG alignment because in addition to provide alignments, it provides a rule for predicting aligned pairs in unseen data. RCA can be compared to methods that propagate similarity values through relations, except that formal concepts are used in place of numerical values. Pattern Structures <ref type="bibr" target="#b5">[6]</ref> were used for the same task with an approach that is similar but does not cover long-range and cyclic dependencies like in RCA. In those approaches, the discovery of an alignment between two KGs is somewhat contrived. First, although a KG can be naturally represented as an RCA context, the RCA context must instead represent the product of the two KGs: i.e., the objects are all pairs of entities (one from each KG), the properties are all pairs of properties, and so on. This entails a quadratic increase in the size of the data, which poses scalibility issues. Second, the discovered alignment is scattered in the extents and intents of formal concepts, across several concept lattices. We show in this paper that those two disadvantages are overcome when using Graph-FCA <ref type="bibr" target="#b4">[5]</ref> on the task of KG alignment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Graph-FCA</head><p>Graph-FCA <ref type="bibr" target="#b4">[5]</ref> is an extension of FCA for multi-relational data, and in particular for knowledge graphs. Graph-FCA defines a graph context as an incidence relation between tuples of objects and attributes. A graph context is a triple   It can be used as a definition of the "sibling" relationship, i.e. the fact that x and y are siblings if they have a common parent z. FCA is extended to graph contexts by extending the set operations to PGPs. PGP inclusion ⊆ q is based on graph homomorphisms, and PGP intersection ∩ q is based on the categorical product of graphs (see <ref type="bibr" target="#b4">[5]</ref> for details).</p><formula xml:id="formula_0">K = (O, A, I),</formula><p>The Galois connection is defined in Graph-FCA between PGPs (Q, ⊆ q ) and sets of object tuples (2 O * , ⊆). In the definitions of Q and R below, the PGP [o ← I] represents the description of an object tuple o by the whole incidence relation I seen from the relative position of o.</p><formula xml:id="formula_1">Q := {o ∈ O n | Q ⊆ q [o ← I]}, for Q = [(x 1 , . . . , x n ) ← P ] ∈ Q R := ∩ q {[o ← I] | o ∈ R}, for R ⊆ O n , n ∈ N</formula><p>Informally, Q can be understood as the result set of Q, seen as a query; and R as the most specific query whose result set contains R. From there, concepts can be defined in the usual way, and organized into lattices. A concept is a pair (R, Q) such that Q = R and R = q Q. The arity of Q and R must be the same, it determines the arity of the concept. Unary concepts are about sets of objects, while binary concepts are about relationships between objects, and so on. Unlike RCA, there is a concept lattice for each concept arity rather than for each object type.</p><p>Figure <ref type="figure" target="#fig_3">3</ref> displays a compact representation of the graph concepts about dishes, cereals, and countries. It only shows unary concepts (R, Q), with Q = [x ← P ], s.t. |R| ≥ 2, P = ∅, and P is a "core pattern" (i.e., P has no homomorphic subset). Each box x identifies a unary concept, with its name at the top (e.g., Q1b), and its extent at the bottom (here, Pakistan, Thailand). The concept intent is the PGP [x ← P ], where P is the subgraph made of solid arrows containing node x. Those arrows denote binary edges while the middle part of the boxes denote unary edges. By reading the graph, we learn that Concept Q1b is the concept of "Asian countries, which eat a lot of some dish whose main cereal is a rice produced in the country itself ". Formally, its intent is denoted by [b ← country(b), Asia(b), eatLotOf (b, a), dish(a), hasM ainCereal(a, c), cereal(c), rice(c), isP roducedIn(c, b)] (using the small letters of concept names as pattern variables). Concepts Q1a and Q1c have the same graph pattern as Q1b but with a different focus, on dishes for Q1a and on cereals for Q2c. N-ary concepts are obtained by picking several distinguished nodes. For example, (Q1b,Q1a,Q1c) is a ternary concept whose instances are the object triples (P akistan, biryani, basmatiRice) and (T hailand, khaoM anKai, thaiRice). It represents the cyclic relationship existing between a country, a dish, and a cereal in Asian countries. The Q2-concepts are generalizations of the Q1-concepts. For example, concept Q2b covers all countries. The dashed arrow from Q2b to Q1b says that Q1b is a subconcept of Q2b. The Q2-intents say that, in the context, all dishes use some rice as a main cereal, and that all cereals are produced in some country but that not all countries eat a lot of some dish, and not all dishes are eaten a lot by some country.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Concept-based Knowledge Graph Alignment</head><p>In this section, we explain how KG alignments can be extracted from Graph-FCA concepts, and we discuss the results on the example and scenarios of Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Principle</head><p>When two entities from two different KGs are equivalent, e.g. o1:z1 and o2:i1 in the example, they generally have equivalent types (e.g., o1:Person and o2:Inhabitant), equivalent properties with equal values (e.g. o1:lastname and o2:name "Dupont"), and equivalent relations with equivalent entities (e.g., o1:home o1:h1 and o2:address o2:a1). Similarly, when two classes are equivalent, they are the type of equivalent entities. In FCA terms, the two equivalent entities (or classes) belong to the extent of a formal concept whose intent expresses everything they have in common. Here, the intent is not only about how the entities are described but also about how the entities are related to other entities. Moreover, the equivalence between two entities depend on the equivalence between the related entities, and so on recursively. This makes Graph-FCA, like RCA, a good match for the problem of KG alignment.</p><p>More precisely, let G 1 and G 2 be two KGs. If an unary concept C = (R, Q) has only two elements in its extent, R = {x 1 , x 2 }, where x 1 belong to G 1 and x 2 belongs to G 2 , then this is a strong indication that x 1 and x 2 are equivalent because they are unique in their own KG to match the projected graph pattern Q. Such a concept is called an anchor in <ref type="bibr" target="#b14">[15]</ref>. Concepts that are not anchors can also contribute to the alignement, although in a less direct and less certain way. For example, a concept with extent {x 1 , y 1 , x 2 , y 2 } says that G 1 -entities x 1 and y 1 align with G 2 -entities x 2 and y 2 , without knowing which aligns to which. However, if we also have the anchor {x 1 , x 2 }, we can deduce an alignment between y 1 and y 2 . Another example is a concept with extent {x 1 , y 2 , z 2 } where some ambiguity remains on the alignment of x 1 but it nonetheless reduces the set of possibilities from all G 2 -entities to only two entities, y 2 and z 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Graph-FCA Representation</head><p>The immediate representation of a KG as a Graph-FCA context is to use classes, properties and relations as attributes (hyper-edge labels), and entities as objects (nodes). Each occurrence of a value is represented by a distinct node labelled by the value as this avoids spurious connections between objects. This is formalized by the following mappings from KG triples to Graph-FCA hyper-edges: where p(e, "v") is a shorthand for p(e, o), v(o) for some fresh object o. This immediate representation, however, does not produce any alignment because the two KG representations do not share any attribute. Indeed, the two KGs have different schemas, hence different classes, properties and relations. Recall that Graph-FCA concept intents are made of attributes and variables. As a consequence, for all concepts except the top one, the concept extent contains only objects from a single KG, and no anchor concept can be found.</p><p>An adequate representation should use the same set of attributes for the two KGs to be aligned, and those attributes should reflect what they have in common. In Scenario A, the two KGs only share the values. Actually, they also share the graph structure, and the distinction between classes, properties and relations. Anything else must hence be represented as objects: i.e., not only entities but also classes, properties and relations. We achieve this by introducing three meta-level common attributes: type for expressing the relation between entities and classes, prop for relating entities to values through properties, and rel for relating entities to entities through relations. The new mapping from KG triples to Graph-FCA hyper-edges is hence as follows:</p><p>(e, type, c)</p><p>type(e, c) (e, p, v) prop(e, p, "v") (e, r, e ) rel (e, r, e ) This is a form of reification, in which classes, properties and relations are treated as objects. It is made possible by the fact that Graph-FCA supports hyper-edges beyond binary edges. As defined above, the notation "v" for a value implicitly introduces an attribute v, hence accounts for the values shared between KGs.</p><p>In Scenario B, in contrast to Scenario A, even the values are different in the two KGs. This means that values do not bring any information so that the mapping for properties can be simplified as (e, p, v)</p><p>prop(e, p). Obviously, the two mappings can be mixed if some values are shared and others not. To compensate for the lack of shared elements, a set of pre-aligned pairs (x 1 , x 2 ) may be given as input, and modelled as equivalence triples (x 1 , sameAs, x 2 ). Such an equivalence can be represented in Graph-FCA by using a fresh attribute a x that represents the real entity or schema element x that x 1 and x 2 refer to. The mapping rule is (x 1 , sameAs, x 2 ) a x (x 1 ), a x (x 2 ), for some fresh attribute a x .</p><p>Attribute a x works like a nominal attribute for each KG, labelling only x 1 in G 1 , and only x 2 in G 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Results and Discussion</head><p>We ran our Graph-FCA implementation<ref type="foot" target="#foot_0">1</ref> on the two scenarios in order to find anchors, and hence KG alignments. We used the following options to make their computation more efficient, and the output smaller: -minsupp 2 because anchors have by definition a support equal to 2, and -only-cores because it excludes concepts that represent under-optimal alignments (an example is given below).</p><p>Scenario A (common values). Graph-FCA finds 24 unary concepts, grouped in only two patterns: Q1 and Q2. All anchor concepts are in Q1, and all concepts in Q1 are anchor concepts. Moreover, all elements of the two KGs (entities and schema) appear in those concepts. Pattern Q1 therefore represents a complete alignement between the two KGs. Table <ref type="table" target="#tab_0">1</ref> lists those concepts with their identifier (a lowercase letter), their extent (an object from each KG), and their neighboring intent. For instance, concept g shows the alignment of o1:z1 with o2:i1, and its intent reads as follows: The two entities have type l, property a with value "Dupont", relation d to entity h, and relation c from entity i. Each variable in the intent refers to a concept in the same pattern, and hence to an aligned pair: e.g., the common type l is o1:Person/o2:Inhabitant, and the property with value "Dupont" is o1:lastname/o2:name. One can observe that the alignement is also correct, not only for entities but also for classes, properties and relations. The concepts in pattern Q2 are general concepts. One concept gathers all entities (people and places), another all classes, and similarly for properties and relations. It simply reflects the meta-model used in our representation. Without option -only-cores, Graph-FCA outputs additional concepts that represent approximate alignments, such as {o1:z1, o1:z3, o2:i1, o2:i3} or {o1:lastname, o2:name, o2:given}. Scenario B (pre-aligned pairs). Without common values nor any pre-aligned pairs, Graph-FCA only finds the meta-concepts, like in pattern Q2 in the above scenario. Indeed, there is no rationale for making any alignment. When adding a pre-aligned pair, like o1:z1 with o2:i1, Graph-FCA finds an almost complete alignment (see Table <ref type="table" target="#tab_1">2</ref>). The only uncertainty is about o1:lastname that aligns with either o2:name or o2:given. Indeed, without values, the different properties that apply to an entity cannot be distinguished. Choosing any other pair of entities as pre-aligned pair gives the same result. However, if the pre-aligned pair is about the schema (e.g., two equivalent classes), then only the schema elements are correctly aligned. Entities are grouped by type (people and places) but they are not aligned individually.</p><p>Other results. We also applied our approach to the example of Abbas et al <ref type="bibr" target="#b0">[1]</ref>, which falls in Scenario A (common values). It is at the same time simpler than the example of Atencia et al because it has no relations (only classes and properties), and more difficult because there is not a one-to-one mapping between the two KGs. First, there are entities in G 1 that are not present in G 2 . Second, the classes are not equivalent: the G 1 -class o1:Book is split in two G 2classes, o2:Dictionary and o2:Novel; and the G 2 -class o2:FemaleScientist is equivalent to the intersection of two G 1 -classes, o1:Woman and o1:Scientist. The alignments produced by Graph-FCA are grouped in two patterns, one for people and another for books, because there are no relations between them in the data. All common entities and all properties are completely and correctly aligned (one anchor concept for each pair). For classes, three interesting concepts are found: {o1:Woman, o1:Scientist, o2:FemaleScientist}, {o1:Book, o2:Novel}, and {o1:Book, o2:Dictionary}. They can be read as "Woman and Scientist together align with FemaleScientist", and "Book aligns with either Novel or Dictionary". This is exactly as expected. Note that each entity with type o1:Book is correctly assigned to one of o2:Novel and o2:Dictionary (two distinct concepts), based on its properties ("author" for novels, "year" for dictionaries).</p><p>Discussion. Compared to the use of classical FCA, RCA or Pattern Structures, our approach does not build a context as the "product" of the two KGs, i.e. with all pairs of entities as objects, and all pairs of classes/properties/relations as attributes. Instead, the Graph-FCA context is built as the "union" of the two KGs. This entails that the size of our context is the sum of the size of the two KGs, rather than the product. This clearly favors the scalability of our approach.</p><p>A key enabling feature of Graph-FCA is the support for k-ary relations as it enables to reify the binary properties and relations as objects, along with entities, and to use them as arguments of meta-level ternary predicates (e.g., prop). Note that this is akin to RDF triples where properties belong to the same space as individuals. As a consequence, the alignment of classes, properties and relations (the schema) can be interpreted in the Graph-FCA output exactly like for entities, through concept extents. This is in contrast with other FCA-based approaches, where a different interpretation method must be used for the schema because it appears in concept intents. Although it can be difficult to read Graph-FCA output in general, a KG alignment can be read from the unary concept extents, which are sets of objects, like in classical FCA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion and Perspectives</head><p>Graph-FCA is FCA for knowledge graphs, and we have shown in this paper that by adequately representing two KGs in terms of what they have in common, we can extract aligned pairs of entities, classes, properties and relations from Graph-FCA concepts in a uniform way. The results in this paper are limited to a few encouraging illustrative examples in different scenarios, and much remains to be done to apply our approach to real KGs. A first issue is scalability. A research track is to only generate anchors, i.e. concepts that result from the intersection of two objects, one from each KG. A second issue is to allow for approximate matching of values, especially texts, as they often slightly differ from one KG to another.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Two KGs (left and right) with cyclic dependencies (from Atencia et al [3])</figDesc><graphic coords="4,134.77,116.83,345.82,175.51" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Graph context about dishes, cereals, and countries.</figDesc><graphic coords="6,134.77,116.83,345.83,125.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>where O is a set of objects, A is a set of attributes, and I ⊆ O * ×A is an incidence relation between object tuples o = (o 1 , . . . , o k ) ∈ O * , for any arity k, and attributes a ∈ A. A graph context represents a KG with objects as nodes, and attributes as hyper-edge labels. An hyper-edge ((o 1 , . . . , o k ), a) can</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Compact representation of graph concepts about dishes, cereals, and countries.</figDesc><graphic coords="7,169.35,116.83,276.66,152.02" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2</head><label>2</label><figDesc>shows the graphical representation of a graph context about dishes, cereals, and countries. Each box represents an object o along with the list of attributes a such that there is an unary edge a(o) ∈ I. Each arrow from box o 1 to box o 2 labelled by attribute a denotes a binary edge a(o 1 , o 2 ) ∈ I. An hyperedge a(o 1 , . . . , o k ) with k &gt; 2 is represented as an ellipsis labeled by a, and having an arrow labeled i to each box o i (not illustrated here). Concept intents express what several n-tuples of objects have in common. They are graph patterns with n distinguished nodes. They are called Projected Graph Patterns (PGP), and they are similar to conjunctive queries. For example, the PGP [(x, y) ← parent(x, z), parent(y, z)] has three nodes x, y, z, two edges parent(x, z) and parent(y, z), and two distinguished nodes x, y.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>(e, type, c) c(e) (e, p, v) p(e, "v") (e, r, e ) r(e, e )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Anchor concepts in Scenario A (common values).</figDesc><table><row><cell>C extent(C)</cell><cell></cell><cell>intent(C), only adjacent edges</cell></row><row><cell cols="2">a o1:lastname o2:name</cell><cell>prop(e, a, "Dubois"), prop(f, a, "Dubois"),</cell></row><row><cell></cell><cell></cell><cell>prop(g, a, "Dupont")</cell></row><row><cell>b o1:city</cell><cell>o2:city</cell><cell>prop(h, b, "Grenoble"), prop(i, b, "P aris"),</cell></row><row><cell></cell><cell></cell><cell>prop(j, b, "P aris")</cell></row><row><cell>c o1:owner</cell><cell>o2:ownedBy</cell><cell>rel(h, c, f ), rel(i, c, g), rel(j, c, e)</cell></row><row><cell>d o1:home</cell><cell>o2:address</cell><cell>rel(e, d, i), rel(f, d, j), rel(g, d, h)</cell></row><row><cell>e o1:z3</cell><cell>o2:i3</cell><cell>type(e, l), prop(e, a, "Dubois"), rel(e, d, i), rel(j, c, e)</cell></row><row><cell>f o1:z2</cell><cell>o2:i2</cell><cell>type(f, l), prop(f, a, "Dubois"), rel(f, d, j), rel(h, c, f )</cell></row><row><cell>g o1:z1</cell><cell>o2:i1</cell><cell>type(g, l), prop(g, a, "Dupont"), rel(g, d, h), rel(i, c, g)</cell></row><row><cell>h o1:h1</cell><cell>o2:a1</cell><cell>type(h, k), prop(h, b, "Grenoble"), rel(g, d, h),</cell></row><row><cell></cell><cell></cell><cell>rel(h, c, f )</cell></row><row><cell>i o1:h3</cell><cell>o2:a3</cell><cell>type(i, k), prop(i, b, "P aris"), rel(e, d, i), rel(i, c, g)</cell></row><row><cell>j o1:h2</cell><cell>o2:a2</cell><cell>type(j, k), prop(j, b, "P aris"), rel(f, d, j), rel(j, c, e)</cell></row><row><cell>k o1:House</cell><cell>o2:Place</cell><cell>type(h, k), type(i, k), type(j, k)</cell></row><row><cell cols="3">l o1:Person o2:Inhabitant type(e, l), type(f, l), type(g, l)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Anchor concepts in Scenario B (pre-aligned pairs).</figDesc><table><row><cell>C extent(C)</cell><cell></cell><cell>intent(C), only adjacent edges</cell></row><row><cell>a o1:city</cell><cell>o2:city</cell><cell>prop(g, a), prop(h, a), prop(i, a)</cell></row><row><cell cols="2">b o1:lastname o2:name</cell><cell>prop(e, b), prop(f, b), prop(l, b)</cell></row><row><cell></cell><cell>o2:given</cell><cell></cell></row><row><cell>c o1:owner</cell><cell>o2:ownedBy</cell><cell>rel(g, c, f ), rel(h, c, l), rel(i, c, e)</cell></row><row><cell>d o1:home</cell><cell>o2:address</cell><cell>rel(e, d, h), rel(f, d, i), rel(l, d, g)</cell></row><row><cell>e o1:z3</cell><cell>o2:i3</cell><cell>type(e, k), prop(e, b), rel(e, d, h), rel(i, c, e)</cell></row><row><cell>f o1:z2</cell><cell>o2:i2</cell><cell>type(f, k), prop(f, b), rel(f, d, i), rel(g, c, f )</cell></row><row><cell>g o1:h1</cell><cell>o2:a1</cell><cell>type(g, j), prop(g, a), rel(g, c, f ), rel(l, d, g)</cell></row><row><cell>h o1:h3</cell><cell>o2:a3</cell><cell>type(h, j), prop(h, a), rel(e, d, h), rel(h, c, l)</cell></row><row><cell>i o1:h2</cell><cell>o2:a2</cell><cell>type(i, j), prop(i, a), rel(f, d, i), rel(i, c, e)</cell></row><row><cell>j o1:House</cell><cell>o2:Place</cell><cell>type(g, j), type(h, j), type(i, j)</cell></row><row><cell cols="3">k o1:Person o2:Inhabitant type(e, k), type(f, k), type(l, k)</cell></row><row><cell>l o1:z1</cell><cell>o2:i1</cell><cell>z1i1(l), type(l, k), prop(l, b), rel(h, c, l), rel(l, d, g)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Open source at https://bitbucket.org/sebferre/graph-fca/</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>This research is supported by <rs type="funder">ANR</rs> project <rs type="projectName">SmartFCA</rs> (<rs type="grantNumber">ANR-21-CE23-0023</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_GsyZxVj">
					<idno type="grant-number">ANR-21-CE23-0023</idno>
					<orgName type="project" subtype="full">SmartFCA</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Discovery of link keys in RDF data based on pattern structures: Preliminary steps</title>
		<author>
			<persName><forename type="first">N</forename><surname>Abbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Concept Lattices and Their Applications</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Ontology-alignment techniques: Survey and analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ardjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bouchiha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Malki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Modern Education &amp; Computer Science</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Link key candidate extraction with relational concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vizzini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="2" to="20" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Translating embeddings for modeling multi-relational data</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bordes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Usunier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Garcia-Duran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Yakhnenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in neural information processing systems</title>
		<imprint>
			<biblScope unit="page" from="2787" to="2795" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Graph-FCA: An extension of formal concept analysis to knowledge graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cellier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="81" to="102" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Pattern structures and their projections</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Conceptual Structures</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Delugach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Stumme</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2120</biblScope>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wille</surname></persName>
		</author>
		<title level="m">Formal Concept Analysis -Mathematical Foundations</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Graph homomorphisms: structure and symmetry</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tardif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Graph symmetry</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="107" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Foundations of Semantic Web Technologies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Chapman &amp; Hall/CRC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Canonical tensor decomposition for knowledge base completion</title>
		<author>
			<persName><forename type="first">T</forename><surname>Lacroix</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Usunier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Obozinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Machine Learning. Proceedings of Machine Learning Research</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">G</forename><surname>Dy</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Krause</surname></persName>
		</editor>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="2869" to="2878" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Relational concept analysis: mining concept lattices from multi-relational data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rouane-Hacene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valtchev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="108" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Modeling relational data with graph convolutional networks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schlichtkrull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">N</forename><surname>Kipf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Van Den Berg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Titov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Semantic Web Conf. (ESWC)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="593" to="607" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Rimom-im: A novel iterative framework for instance matching</title>
		<author>
			<persName><forename type="first">C</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Xia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. computer science and technology</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="185" to="197" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A comprehensive survey of entity alignment for knowledge graphs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Open</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Matching biomedical ontologies based on formal concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. biomedical semantics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
