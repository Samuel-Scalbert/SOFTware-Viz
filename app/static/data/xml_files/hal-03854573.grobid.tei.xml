<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Passive Query-Recovery Attack Against Secure Conjunctive Keyword Search Schemes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marco</forename><surname>Dijkslag</surname></persName>
							<email>m.dijkslag@alumnus.utwente.nl</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Twente</orgName>
								<address>
									<settlement>Enschede</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marc</forename><surname>Damie</surname></persName>
							<email>marc.damie@inria.fr</email>
							<affiliation key="aff2">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Centrale Lille -CRIStAL</orgName>
								<address>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Florian</forename><surname>Hahn</surname></persName>
							<email>f.w.hahn@utwente.nl</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Twente</orgName>
								<address>
									<settlement>Enschede</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Peter</surname></persName>
							<email>a.peter@utwente.nl</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Twente</orgName>
								<address>
									<settlement>Enschede</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">University of Oldenburg</orgName>
								<address>
									<settlement>Oldenburg</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Passive Query-Recovery Attack Against Secure Conjunctive Keyword Search Schemes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">6FAB087AC2398833E128B88CBB8B1A61</idno>
					<idno type="DOI">10.1007/978-3-031-09234-</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Searchable encryption</term>
					<term>conjunctive keyword search</term>
					<term>passive query-recovery attack</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>While storing documents on the cloud can be attractive, the question remains whether cloud providers can be trusted with storing private documents. Even if trusted, data breaches are ubiquitous. To prevent information leakage one can store documents encrypted. If encrypted under traditional schemes, one loses the ability to perform simple operations over the documents, such as searching through them. Searchable encryption schemes were proposed allowing some search functionality while documents remain encrypted. Orthogonally, research is done to find attacks that exploit search and access pattern leakage that most efficient schemes have. One type of such an attack is the ability to recover plaintext queries. Passive query-recovery attacks on single-keyword search schemes have been proposed in literature, however, conjunctive keyword search has not been considered, although keyword searches with two or three keywords appear more frequently in online searches. We introduce a generic extension strategy for existing passive queryrecovery attacks against single-keyword search schemes and explore its applicability for the attack presented by Damie et al. (USENIX Security '21). While the original attack achieves up to a recovery rate of 85% against single-keyword search schemes for an attacker without exact background knowledge, our experiments show that the generic extension to conjunctive queries comes with a significant performance decrease achieving recovery rates of at most 32%. Assuming a stronger attacker with partial knowledge of the indexed document set boosts the recovery rate to 85% for conjunctive keyword queries with two keywords and achieves similar recovery rates as previous attacks by Cash et al. (CCS  '15)  and Islam et al. (NDSS '12)  in the same setting for single-keyword search schemes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>With increasing number of enterprises storing their documents in the cloud the question arises how to cope with storing sensitive documents on the cloud with-out the cloud provider learning information about the stored documents or information being leaked when a data breach occurs. One solution for this problem would be to encrypt the documents to hide its contents to the cloud provider. However, this prevents users from using the (often available) computational resources cloud providers offer, since searching through the documents is no longer possible without first downloading and decrypting it.</p><p>Searchable symmetric encryption schemes can be a solution to this problem that offer constructions for search functionalities over encrypted documents. The first practical solution towards searchable encryption has been proposed by Song et al. <ref type="bibr" target="#b21">[22]</ref>. Proposers of searchable encryption schemes need to find a trade-off in efficiency, security, and functionality. With this trade-off in terms of security comes information leakage such as possible search pattern leakage (revealing which queries concerned the same underlying, but unknown, keyword) and access pattern leakage (revealing the identifiers of all documents matching the search query). Most of the efficient searchable encryption schemes that allow for keyword search leak information in the access pattern for efficiency.</p><p>Searchable encryption is an active line of research for finding efficient schemes that allow for search in encrypted documents with well-defined security in terms of a leakage function. Orthogonally, research is performed on finding attacks against proposed searchable encryption schemes. One such type of attack is a query-recovery attack, i.e. the ability for an adversary to recover the plaintexts from performed queries. In general two kinds of query-recovery attacks exist: <ref type="bibr" target="#b0">(1)</ref> a passive attack where an adversary only has access to the information leaked by a scheme and (2) an active attack in which an adversary is able to inject tailored documents into the to-be-searched dataset.</p><p>Active query-recovery attacks on conjunctive keyword search do exist <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b17">18]</ref> which are described as an extension on the proposed single-keyword search attack. Currently, all existing passive query-recovery attacks against searchable symmetric encryption that allow for keyword searches only focuses on singlekeyword search schemes. However, these attacks do not reflect a realistic scenario, since single-keyword searches are limited and statistics show that the number of keywords used by people online in the US peaks at two keywords <ref type="bibr" target="#b4">[5]</ref>. Also, three keyword searches are still more frequent than searches for a single keyword. The frequency of searches using seven or more keywords becomes negligible.</p><p>Note that the recovery of conjunctive keyword queries is more difficult with respect to the recovery of single-keyword queries using similar vocabulary sizes. This difficulty stems from the fact that the space for keyword conjunctions is combinatorial in the number of conjunction terms compared to single-keywords, therefore an attacker needs to consider more possible candidates of keyword conjunctions for each observed query.</p><p>In this work, we explore a passive query-recovery attack against secure conjunctive keyword search (CKWS) schemes. We propose a generic extension strategy for query-recovery attacks against single-keyword search to recover conjunctive queries using the same attack. Our extension strategy is based on the use of trapdoors created from a keyword-conjunction set as a generalization of trap-doors created from single-keywords. Replacing keywords with keyword conjunction sets. Our attack is static and does also work on forward and backward private schemes ( <ref type="bibr" target="#b16">[17]</ref>).</p><p>We introduce an adaptation of the query-recovery attack proposed by Damie et al. <ref type="bibr" target="#b5">[6]</ref> to achieve keyword conjunction recovery. We explore the applicability of the attack in two setups: (1) a similar-documents attack, where the attacker only has access to a set of documents that is similar, but otherwise different, from the indexed documents and (2) a known-documents attack, where the attacker has (partial) knowledge of the indexed documents. In both setups it is assumed the attacker knows the keyword conjunctions for a small set of queries a priori. We experimentally show that our attack can work for a relatively small vocabulary size (500) in an attack setup allowing only conjunctive keyword search using 2 keywords. However, we show that in an attack setup using similar-documents the attack performs poorly unless many known queries are assumed to be part of the attacker's knowledge. Furthermore, we demonstrate limitations of our generic extension posed by the combinatorial complexity increase for larger conjunctions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>Most attacks against searchable symmetric encryption that have been described in the literature are query-recovery attacks. Islam et al. <ref type="bibr" target="#b9">[10]</ref> were the first to propose a passive query-recovery attack in which they are exploiting the access pattern leakage, i.e. leaked document identifiers from observed queries. In their attack, the adversary needs to know all the documents indexed on the server to be successful. They introduced the idea of computing (word-word and trapdoortrapdoor) co-occurrences to attack SSE. This idea being reused by other the passive attacks. The attack works by finding the closest mapping between the word-word co-occurrence matrix and trapdoor-trapdoor co-occurrence matrix in which they use meta heuristic simulated annealing. Also, the attack requires a number of known queries to work, i.e. trapdoors from which the attacker knows the underlying plaintext value.</p><p>Cash et al. <ref type="bibr" target="#b2">[3]</ref> proposed another passive query-recovery attack. Their attack first exploits that keywords with high frequency have unique keyword document counts to initialize their set of known queries. Then for keywords that do not have a unique keyword document occurrence count they construct a co-occurrence matrix of their known documents and observed queries, similar to Islam et al. They try to recover more queries by constructing for every unknown query their candidate set (i.e. keywords having the same document occurrence count) and remove candidates from the set that do not have the same co-occurrence with a known query in the known queries set. If after iterating over every known query only one candidate is left, the last candidate is appended to the known queries set. This process is repeated for all unknown queries until the set of known queries stops increasing.</p><p>Both <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3]</ref> rely on the attacker knowing a large part of the indexed documents, where the count attack performs better than the attack by Islam et al. However, their query recovery rate roughly only increases when the attacker knows at least 80% of the indexed documents.</p><p>The query-recovery attack proposed by Pouliot et al. <ref type="bibr" target="#b20">[21]</ref> uses weighted graph matching where the attacker needs to find mapping of keyword graph and trapdoor graph . The attack achieves recovery rates above 90% when the attacker knows the entire set of indexed documents, but fails as similar-documents attack unless having a smaller set of documents and vocabulary size. Also, the runtime of the attack increases rapidly, where for a vocabulary size of 500 the attack runs in less than one hour, whereas it takes more than 16 hours for a vocabulary size of 1000. The attack in <ref type="bibr" target="#b9">[10]</ref> has a runtime of a maximum of 14 hours, whereas attacks from <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6]</ref> run in seconds.</p><p>Ning et al. <ref type="bibr" target="#b14">[15]</ref> introduced a query-recovery attack that works when the attacker knows a percentage of the indexed documents. Keywords and trapdoors are represented as a binary string where the -th bit is 1 if the keyword (resp. trapdoor) occurs in document . Recovery is done by converting the bit strings to integers, where it is considered that a keyword corresponds to a trapdoor if they have the same integer value.</p><p>The proposed attack outperforms the attack by Cash et al. <ref type="bibr" target="#b2">[3]</ref>, where in their scenario <ref type="bibr" target="#b2">[3]</ref> achieves a recovery rate of roughly 28% and their proposed attack around 56% when the attacker knows 80% of the indexed documents. However, they do not report a recovery rate for an attacker having knowledge of more than 80% of the indexed documents.</p><p>Blackstone et al. <ref type="bibr" target="#b1">[2]</ref> proposed a "sub-graph" attack requiring much less known documents to be successful and also works on co-occurrence hiding schemes. Their experiments show that an attacker only needs to know 20% of the indexed documents to succeed in her attack.</p><p>In <ref type="bibr" target="#b5">[6]</ref>, Damie et al. proposed their refined score attack that works in a setting where the attacker only knows a similar, but otherwise different and non-indexed, set of documents for query-recovery. A mathematical formalization of the similarity is proposed in their paper. In <ref type="bibr" target="#b2">[3]</ref> they showed that both the attack proposed by Islam et al. <ref type="bibr" target="#b9">[10]</ref> and their proposed count attack do not work using similar documents. In <ref type="bibr" target="#b5">[6]</ref>, the query-recovery attack uses similar techniques as used by <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3]</ref>, i.e. constructing co-occurrence matrices from the document set known by the attacker and a trapdoor-trapdoor co-occurrence matrix from the assumed access pattern leakage. By starting with a few known (keyword, trapdoor)-pairs their attack iteratively recovers queries where previous recovered queries with high confidence scores are added to the set of known queries. Using this approach their attack reaches recovery rates around 85%.</p><p>Other types of attacks. Zhang et al. <ref type="bibr" target="#b27">[28]</ref> proposed an effective active document injection attack to recover keywords. Furthermore, they proposed an extension of their attack to a conjunctive keyword search setting which was experimentally verified for queries with 3 keywords.</p><p>In <ref type="bibr" target="#b17">[18]</ref>, Poddar et al. proposed several attacks that uses volume pattern as auxiliary information in combination with the attacker's ability to replay queries and inject documents. Moreover, they also gave an extension of their attack for queries with conjunctive keywords which is based on the extension from <ref type="bibr" target="#b27">[28]</ref> using a document injection approach.</p><p>Liu et al. <ref type="bibr" target="#b13">[14]</ref> proposed a query-recovery attack which makes use of the search pattern leakage as auxiliary information. In particular, they exploit the query frequency. However, they simulated their queries by applying Gaussian noise to keyword search frequency from Google Trends<ref type="foot" target="#foot_0">4</ref> because of the lack of a query dataset. The attacker has access to the original frequencies.</p><p>Another attack introduced by Oya and Kerschbaum <ref type="bibr" target="#b15">[16]</ref> combines both volume information derived from the access pattern leakage and query frequency information derived from the search pattern leakage as auxiliary information.</p><p>Conjunctive keyword search schemes. Passive query-recovery attacks against single-keyword search schemes already work for some conjunctive keyword search schemes where the server performs search for each individual keyword in a query independently and returns the intersection of document identifiers of each single-keyword search, i.e. leaking the full access pattern for each individual keyword in the conjunction. However, these attacks cannot be applied on conjunctive keyword search schemes with less or common access pattern leakage, where common refers to the scheme only leaking the document identifiers for the documents containing all keywords from a conjunctive keyword query. Hence, in this work we explore one extension strategy for conjunctive keywords that can be applied to most passive query-recovery attacks against single-keyword search using only common access pattern leakage. <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b22">23]</ref> both proposed such a conjunctive keyword search scheme that returns the intersection of document identifiers for each individual keyword in a conjunctive keyword query, thus leaking the full access pattern. However, we would like to emphasize that in this scenario only an honest-but-curious server that is able to observe the result set for each intermediate keyword can be considered an attacker, since an eavesdropper on the communication channel would not be able to observe the document identifiers for each intermediate single-keyword search. Furthermore, it should be noted that both schemes also offer more functionality than conjunctive keyword search alone. Where <ref type="bibr" target="#b18">[19]</ref> allows for phrase searches and <ref type="bibr" target="#b22">[23]</ref> offers result set verifiability and index updatability.</p><p>Other proposed conjunctive keyword search schemes exist ( <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b23">24]</ref>). However, all of them leak at least the common access pattern, where <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b24">25]</ref> have more than common access pattern leakage. To the best of our knowledge there do not exist efficient conjunctive keyword search schemes that have no access pattern leakage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Preliminaries</head><p>We first introduce some notations that are used throughout this work. Let document set D consist of documents { 1 , ..., }. Let keyword set W consist of keywords { 1 , ..., }. Document consists of keywords that form a subset of keyword set W. Let ( ) = return the identifier for document . We denote ∈ if keyword (∈ W) occurs in document . A summary of all notations and their meaning used throughout this work is given in Table <ref type="table" target="#tab_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Searchable symmetric encryption</head><p>A searchable encryption scheme allows a user to search in encrypted documents and is often described in a client-server setting. The client can search through encrypted documents stored on the server, without the server learning information about the plaintext documents. Often a searchable encryption scheme can be divided in four algorithms:</p><p>-KeyGen(1 ): takes security parameter and outputs a secret key .</p><p>-BuildIndex( , D): takes document set D and secret key and produces an (inverted) index . -Trapdoor( , ): takes query and secret key and outputs a trapdoor . -Search( , td ): takes trapdoor td and index and outputs the documents that match with query .</p><p>In single-keyword search schemes corresponds to a keyword , whereas in conjunctive keyword search schemes would correspond to a query for documents containing keywords, i.e., the conjunction of keywords 1 ∧ ... ∧ of keywords 1 , ..., . Then, td would correspond to the conjunction of keywords.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Considered conjunctive keyword search model</head><p>We assume a fixed number of keywords ( ) that are allowed to be searched for in a conjunctive keyword search. For instance if = 2, only trapdoors with 2 distinct keywords are allowed. We denote such a fixed-scheme as secureconjunctive keyword search scheme.</p><p>For simplicity, we assume a fixed number of distinct keywords, however one could consider as a maximum number of keywords in the conjunctive search by reusing the same keyword for non-used keyword entries in the conjunction. For instance, when = 2, ∧ for the same keyword would be equivalent to a single-keyword search for . We consider ckw to be the set of different keywords that are used to construct a trapdoor (td ckw ). For instance, if we consider a conjunctive keyword search scheme that allows search for = 3 conjunctive keywords, we would create a keyword set ckw for every possible combination of 3 keywords, where</p><formula xml:id="formula_0">ckw 1 = { 1 , 2 , 3 }. 5</formula><p>First, in the BuildIndex algorithm, the client encrypts every document in the document set locally. Then creates an encrypted index of the document set (locally). Given a trapdoor , the server can find the documents containing keywords in using such a created index. The encrypted document set and index are then uploaded by the client to the server.</p><p>Although in literature different methods for constructing such an index were proposed, here we do not fix which index is used. We only require the model to have at least common access pattern leakage, where common refers to the scheme only leaking the document identifiers for the documents containing all keywords in a conjunctive keyword query. All conjunctive search schemes described in Section 2 leak at least the common access pattern.</p><p>The client can search documents by constructing trapdoors. The client constructs a trapdoor by picking keywords she wants to search for. In our model, she constructs a trapdoor using the function td = Trapdoor( , ckw = { 1 , ..., }), for the keywords she wants to search for. By sending the trapdoor td to the server, the server responds with a set of document identifiers td for documents that contain all keywords in ckw .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Attacker model</head><p>Like in <ref type="bibr" target="#b5">[6]</ref>, we consider two types of passive attackers which both can observe trapdoors sent by a user and its response including the document identifiers. The first type of attacker is an honest-but-curious server. The server is considered to be an honest entity meaning it follows the protocol. Hence, it always returns the correct result for each query. However, such curious server tries to learn as much information as possible using the scheme leakage. Secondly, we consider an eavesdropper that is able to observe pairs of trapdoor and document identifiers from the communication channel between client and server as an attacker.</p><p>For both attackers an is a tuple (td , td ) considering conjunctive keyword queries where trapdoor td corresponds to conjunctive keywords.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Attacker knowledge</head><p>It is assumed the attacker knows the number of keywords that are allowed to construct trapdoors. Moreover, it can be assumed that an honest-but-curious attacker knows the byte size of the stored documents and the number of documents stored (e.g. from the index). However, an eavesdropper does not. In that case we make use of the proposed formula by <ref type="bibr" target="#b5">[6]</ref> that approximates the number of documents stored on the server ( real ) derived from the attacker's knowledge.</p><p>We consider two types of attack setups, i.e. a similar-documents attack setup where the attacker has access to a set of similar documents (as formalized in <ref type="bibr" target="#b5">[6]</ref>) and a known-documents attack setup where the attacker has (partial) knowledge of the documents stored on the server.</p><p>Similar-documents attack. In our similar-documents attack we assume the attacker has a document set D similar that is -similar to the real indexed document set D real . However, we assume -similarity (as formalized in <ref type="bibr" target="#b5">[6]</ref>) over the possible keyword conjunctions rather than keywords, where smaller means more similar. Also, D similar ∩ D real = ∅, thus do not have overlapping documents.</p><p>Known-documents attack. Like in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3]</ref>, for our known-documents attack setup we assume that the attacker has a -known document set D -known , where 0 &lt; ≤ 1 defines the known-documents rate. Meaning, the attacker knows a fraction of the real indexed document set D real stored on the server.</p><p>It should be noted that a similar-documents attack can be considered more realistic than a known-documents attack as discussed by Damie et al. <ref type="bibr" target="#b5">[6]</ref>. Since a known-documents attack will most likely only be possible on a data breach, whereas documents that are only similar to the actual indexed documents maybe even publicly available. Moreover, the user could remove the leaked documents that are used in a known-documents attack from the index.</p><p>The assumption that the attacker knows (a subset of) the documents stored on the server is rather strong, but is based on what is done in previous work <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CKWS-adapted refined score attack</head><p>In this section we describe our conjunctive keyword search (CKWS) adaptation of the refined score attack. Our adaptation builds upon the score attacks that were introduced by Damie et al. <ref type="bibr" target="#b5">[6]</ref>. We have chosen to use their queryrecovery attack against single-keyword search schemes, since it is, to the best of our knowledge, the most accurate similar-documents attack that has been described yet. Furthermore, the matching algorithm used in their attack only has a runtime of 20 seconds while considering a vocabulary size of 4000 keywords. Since the space of possible queries increases combinatorial, we have to consider many possible keyword conjunctions and thus faster runtimes is desired. Moreover, their attack can use either known documents or similar documents as adversary's knowledge. We describe how one can transform their query-recovery attack to an attack on conjunctive keyword search schemes, i.e. considering the (abstract) secure -conjunctive keyword search scheme described in Section 3.2, using similar terminology as in <ref type="bibr" target="#b5">[6]</ref>.</p><p>In addition, the code for the score attacks has been made publicly available online by Damie et al. This allowed us to verify their results first before adapting it to our conjunctive keyword setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Score attacks</head><p>Damie et al. <ref type="bibr" target="#b5">[6]</ref> first propose the score attack based on the idea of ranking potential keyword-trapdoor mappings according to a score function. To run the score attack an attacker calculates the word-word co-occurrence matrix from its auxiliary document set and constructs a trapdoor-trapdoor co-occurrence matrix from observed queries and their result sets. Assuming some known queries, the attacker removes the columns from both matrices that do not occur in their set of known queries (i.e. word-trapdoor pairs) to obtain so-called sub-matrices. Then for every (observed) trapdoor, it goes through all possible keywords extracted from the auxiliary document set and returns the keyword for which their score function is maximized.</p><p>Secondly, their proposed refined score attack builds upon previously described score attack. Instead of returning a prediction for all trapdoors, they define a certainty function for each prediction and only keep the best predictions according to this certainty function. These predictions are then added to the set of known queries and the attacker recomputes the co-occurrence submatrices. This procedure is repeated until there are no predictions left to make, i.e. no unknown queries left.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Generic extension</head><p>In short, our generic extension proposes to replace single keywords with keyword conjunction sets. The extension consists of five steps, highlighted by the next five subsections to adapt a passive query-recovery attack against single-keyword search to conjunctive keyword search, i.e. attacks that try to find a mapping between co-occurrences of keywords and trapdoors to recover queries. We describe our extension in a similar-documents attack setup using D similar , but the same steps can be taken in a known-documents attack setup using D -known as the attacker's auxiliary document set.</p><p>Extract vocabulary. First, the attacker extracts keywords from the set of documents D similar to vocabulary W similar . As in query-recovery attacks on single-keyword search <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b5">6]</ref>, we also assume that the keyword extraction method used by the attacker is the same as the one used by the user when she created the encrypted index.</p><p>Construct set of possible keyword conjunctions. The attacker creates the set of all possible keyword conjunctions K similar = {ckw ∈ P (W similar ) |ckw | = }, where similar = |K similar | = similar and P ( ) denotes the power set of set .</p><p>Compute co-occurrence matrix for keyword conjunctions. From D similar and derived keyword conjunctions set K similar the attacker creates the similar × similar matrix similar . Here similar [ , ] = 1 if the -th document in D similar contains the keywords that are in keyword conjunction ckw and is otherwise 0. Then the attacker computes the ckw-ckw co-occurrence matrix ckw = similar • similar • 1 similar .<ref type="foot" target="#foot_2">6</ref> Compute the trapdoor-trapdoor co-occurrence matrix. We define Q = {td 1 , ..., td } to be the set of observed queries by the attacker containing trapdoors that have been queried by the user. These trapdoors were created by the user from keyword conjunctions in</p><formula xml:id="formula_1">K real = {ckw ∈ P (W real ) |ckw | = }. Let td = { ( )|(ckw ∈ K real ) ∧ (td = Trapdoor( , ckw)) ∧ ( ∈ D real ) ∧ ∀ ∈ckw ( ∈ )</formula><p>} be the set of document identifiers that were observed by the attacker for trapdoor td. Then we define the set of document identifiers = td∈ Q td of size , where ≤ real . Similar to the construction of the matrix similar , we construct × trapdoor-document matrix real , where real [ , ] = 1 if -th document identifier occurs in td (and refers to -th trapdoor from Q). Otherwise, real [ , ] = 0. Then trapdoor-trapdoor co-occurrence matrix td = real • real • 1 real . Apply attack. The last step is to apply a passive query-recovery attack using the set of keyword conjunctions and the co-occurrence matrices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Transform key steps of refined score attack</head><p>As in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b5">6]</ref>, our attack also requires the attacker to have knowledge of a set of known queries. However, our set of known queries is slightly different because of the keyword conjunctions. In a similar-documents attack setup our set of known queries = {(ckw , td known )|(ckw ∈ K similar ∩ K real ) ∧ (td known ∈ Q) ∧ (td known = Trapdoor( , ckw )}. For our known-documents attack setup, is similarly defined by replacing K similar with K known . We recall key steps in the score attack w.r.t. the projection of the keywordkeyword co-occurrence and trapdoor-trapdoor co-occurrence matrix to sub-matrices using the set of known queries. These steps are important because they are different for our CKWS-adapted refined score attack. In short, the projection is done by only keeping the columns of known queries in ckw and td .</p><p>Our goal is to generate sub-matrices ckw and td from ckw and td respectively. We describe the projection step for ckw using K similar , but the same holds for K known . Recall that K similar = {ckw 1 , ..., ckw similar }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We define</head><p>(ckw), which returns the position of ckw ∈ K . That is, (ckw ) = . Similarly, ( ) returns the position of td in Q = {td 1 , ..., td }. Let ckw = . . . , ì , . . . ∈ [ similar ] be the similar × similar co-occurrence matrix, where the column vector ì denotes its -th column. Then the similar × sub-matrix ckw = . . . , ì (ckw ) , . . . (ckw ,td ) ∈</p><p>, where ì (ckw ) is the (ckw )-th column vector of ckw . Let td = . . . , ì , . . . ∈ [ ] be the × trapdoor-trapdoor co-occurrence matrix, where the column vector ì denotes its -th column. Then × sub-matrix td can be constructed as follows: td = . . . , ì (td ) , . . . (ckw ,td ) ∈</p><p>, where</p><p>(td ) is the (td )-th column vector of td . Superscript emphasizes that ckw and td are sub-matrices of ckw and td respectively. Also, we denote ckw [ckw ] to be the -th row vector for keyword conjunction set ckw and td [td ] to be the -th row vector for trapdoor td , where</p><formula xml:id="formula_2">| ckw [ckw ]| = | td [td ]| = .</formula><p>Additionally, we revise the scoring algorithm for which the score is higher if a trapdoor corresponds to a certain keyword conjunction, i.e. the distance between two vectors td [td ] and ckw [ckw ] is small. Using keyword conjunctions the score function is defined as:</p><formula xml:id="formula_3">(td , ckw ) = -(|| ckw [ckw ] -td [td ]||)</formula><p>, for all ckw ∈ K similar (or K known ) and all td ∈ Q, where (•) is the natural log and || • || is a vector-norm (e.g. L2 norm).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Revised algorithm</head><p>We substitute for ckw in <ref type="bibr" target="#b5">[6]</ref> to transform the refined score attack to the CKWS-adapted refined score attack. Algorithm 1 contains its pseudocode, where a step is highlighted blue if it is different from the refined score attack proposed by Damie et al. <ref type="bibr" target="#b5">[6]</ref>. Note that this algorithm is described using K similar , but also works for K known as input.</p><p>One iteration of the algorithm can be defined by the three key phases. First remove known queries from the observed queries set Q. Secondly, find the best scoring keyword conjunction candidate for each unknown query and compute the certainty of this candidate. Using keyword conjunctions the certainty of a keyword conjunction candidate ckw for trapdoor td is defined by: (td, ckw ) = (td, ckw )max ≠ (td, ckw ) Using this definition the certainty of a correct match of keyword conjunction with a trapdoor is higher when the score of the match is much higher than all other possible candidate scores.</p><p>The algorithm defines a notion of refinement speed ( ) which defines the number of most certain predictions that will be added each iteration of the algorithm to the set of known queries. Which describes the third and last key step of an iteration, i.e. adding the most certain predictions to the known queries and recompute sub-matrices ckw and td . Thereafter, either start a new iteration or stop the algorithm if the number of unknown queries is less than .</p><p>Algorithm 1: CKWS-adapted refined score attack. </p><formula xml:id="formula_4">Input: K similar , ckw , Q, td ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Complexity</head><p>As in <ref type="bibr" target="#b5">[6]</ref>, a higher refinement speed will result in a faster runtime, but less accurate predictions. However, due to our use of keyword conjunctions the number of candidates for a trapdoor increases for larger . Therefore, the runtime of the CKWS-adapted refined score attack grows combinatorial. The time complexity of the attack is given by O ( ( ) + ( )), where ( ) = ! !( -)! • ( -1) corresponds to the time complexity of the generic extension, where we assume multiplying two vectors takes constant time. Further, ( )</p><formula xml:id="formula_5">= | Q | • |Q| • ! !( -)! •</formula><p>is the time complexity of the attack. For both and , input is either similar or known depending on the attack setup.</p><p>Besides the increase in runtime, having &gt; 1 also the space complexity of the algorithm increases faster relative to the vocabulary size. Since co-occurrence matrix ckw in the similar-documents attack setup is similar × similar , in terms of vocabulary size is similar ! !( similar -)! × similar ! !( similar -)! thus increasing faster with larger similar .</p><p>This increase in time and space complexity led us to first further optimize the revised algorithm for our implementations. Moreover, we use a GPU to decrease runtimes through computing expensive matrix operations on it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Setup</head><p>Documents. As described previously, in our experiments we simulate our attack using the publicly available Enron email document set introduced by Klimt &amp; Yang <ref type="bibr" target="#b11">[12]</ref>. We chose this document set since this one is also used in most attack papers requiring a set of documents. Similarly, we constructed the same corpus of emails from the folder which results in a set of 30109 documents. Keyword extraction. We extract keywords from solely the contents of the emails in the dataset, i.e. we do not consider email addresses or email subjects to be part of the document set. For keyword extraction we use the Porter Stemmer algorithm <ref type="bibr" target="#b19">[20]</ref> to obtain stemmed words, moreover we remove stop words in the English language like 'the' or 'a'. Using this method results in a total of 62976 unique keywords in our entire considered document set.</p><p>Number of keywords in conjunction. Throughout our experiments we fix , i.e. the number of keywords allowed in one conjunction, to either 1, 2 or 3. This means that no mixture of number of keywords is allowed in search. For instance, when the = 3 only queries with 3 distinct keywords are allowed, i.e. queries that contain either 1 or 2 keywords are not allowed.</p><p>Testing environment. We implemented the attack on an Ubuntu 20.04 server with Intel Xeon 20-core processor (64 bits, 2.2 GHz), 512 GB of memory, and NVIDIA Tesla P100 GPU (16GB). We used Python 3.7 and the Tensorflow library <ref type="bibr" target="#b0">[1]</ref> to accelerate matrix operations on a GPU. <ref type="foot" target="#foot_3">7</ref>Limitations. Running experiments with larger vocabulary sizes requires a lot of memory, since a vocabulary size of 150 and = 2 means a documentkeyword-conjunction matrix size of 18065 × 11175 (already 1.5 GiB) and a maximum co-occurrence matrix size of 11175 × 11175 (0.9 GiB) which both have to fit in the memory of the GPU for fast calculations. Therefore, having similar vocabulary sizes as used in the score attack is unrealistic in our generic extension strategy setting without having sufficient resources. However, we propose an extrapolation strategy to have approximate results for larger vocabularies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Results</head><p>In our experiments where similar-documents are used as the attacker's knowledge, we use the same ratio in similar (40%) and real (60%) documents as in <ref type="bibr" target="#b5">[6]</ref>. Similar to <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b5">6]</ref>, we define the accuracy to be the number of correct predictions divided by the number of unknown queries excluding the initial known queries, i.e. the</p><formula xml:id="formula_6">= | ( ) | | Q |-| |</formula><p>. If not specified otherwise, each accuracy result corresponds to the average accuracy over 50 experiments. Also, the vocabulary used in experiments is always created from the most frequently occurring keywords in the document set. From this vocabulary the keyword conjunctions set is generated. In each experiment it is assumed the attacker has observed 15% of queries that can be performed by the user, i.e. |Q| = 0.15 • real , where queries are sampled u.a.r. from K real to construct trapdoors. Result extrapolation. Figure <ref type="figure">1</ref> shows the accuracy of the score attack from <ref type="bibr" target="#b5">[6]</ref> where the attacker has access to similar-documents for varying vocabulary size and = 2. We show these results to highlight that we can extrapolate the accuracy of the attack in a similar-documents setting closely, where the extrapolation is depicted by the dashed line and measured results are the solid line. We obtain this extrapolation by first transforming the accuracies using the logit 8 function. Using this transformation, we obtain a space in which we seem to have a linear relationship such that logit( ) = • similar + . We then perform a linear regression to obtain these coefficients using our experimental results. Lastly, we use the inverse logit function to transform it back to the original scale. We make use of this extrapolation where running experiments becomes infeasible (i.e. experiments with = 2 and real &gt; 500) to extrapolate the accuracy for larger vocabulary sizes.</p><p>In our linear regressions, we do not provide the coefficient of determination 2 and the -value since they are based on the assumption that results are independent which is not true in our experiments as they all use the same document</p><formula xml:id="formula_7">8 logit( ) = log( 1-)</formula><p>set. Hence, these values should not be used to evaluate the quality of the model even if they are high (e.g. 2 ≈ 0.95 in Figure <ref type="figure">1</ref>) but the linear regression is still valid. Although there may exist more precise extrapolation techniques, our intention is to have a simple yet realistic approximation of the accuracy for larger vocabularies for the sake of our discussion.</p><p>Frequency of keyword conjunctions. Figure <ref type="figure">2</ref> shows the frequency of a keyword conjunction occurring in D similar for ∈ {1, 2, 3}, where keyword conjunction rank is lowest for the most frequent keyword conjunction. We observe the behavior of using keyword conjunctions instead of a single-keyword, i.e. the frequency of the most frequent keyword conjunction becomes smaller with higher and the frequency of the least frequent keyword conjunction reaches almost zero. This is to be expected, since the larger vocabulary size the higher the probability that certain keywords from a keyword conjunction do not appear in any document together, i.e. considering the vocabulary is generated with the most frequent keywords first. Note however, that the frequency for rank between 200 and 3600 part is higher for = 2 relative to = 1, which is due to the fact that obtaining 4000 keyword conjunctions requires a smaller vocabulary size of 90 for = 2, and it is still the case that the most frequent keywords occur together. Nevertheless, the same does not hold for = 3 relative to = 2, where we actually observe a decrease in keyword conjunction frequency. Here it already is the case that the most frequent keywords used to create a keyword conjunction of 3 keywords do not have to necessarily occur together in a document.  CKWS-adapted refined score attack using similar-documents. Figure <ref type="figure" target="#fig_1">3</ref> shows the accuracy of the CKWS-adapted refined score attack using similar-documents with = 2 and varying vocabulary size. Also, the plot shows an extrapolation of the accuracies for vocabulary sizes larger than 130 (and smaller than 50). From the extrapolation of the accuracies for varying vocabulary sizes we clearly see a rapid decrease in accuracy with larger vocabulary sizes. We conclude that, when we consider the results with 30 known queries we can still reach a reasonable recovery rate above 50% for vocabulary size 300 to 400 keywords. However, the results are far from the single-keyword search set up presented in <ref type="bibr" target="#b5">[6]</ref> achieving up to 85% recovery rate for vocabulary size of 1000.</p><p>In <ref type="bibr" target="#b5">[6]</ref>, they discussed how the 'quality' of a known query influences the accuracy. A known query is more qualitative if the underlying keyword occurs more frequently. We remind that in the CKWS-adapted setting, it is a way to reduce the number of known queries needed. A lower rank of a keyword conjunction in Figure <ref type="figure">2</ref> the query for the keyword-conjunction is considered more qualitative.</p><p>Figure <ref type="figure" target="#fig_2">4</ref> shows the accuracy of the CKWS-adapted refined score attack using similar-documents with = 2 and varying number of known queries. The plot shows that the standard deviation of the accuracy, assuming 5 or 10 known queries, is relatively high compared to the standard deviation for 15, 30, or 60 known queries. For 5 known queries the standard deviation is 0.15, which is at least 3 times higher than the standard deviation for 15 known queries (≈ 0.05). The accuracy increases and standard deviation decreases with a higher number of known queries, since it becomes more likely to pick more qualitative queries (u.a.r.). This also explains why we observe this noisy behavior of the accuracy in the plot. CKWS-adapted refined score attack using -known-documents. Since we have shown in Section 5.2 that the CKWS-adapted refined score attack does provide limited scaling with having &gt; 1, we explore how well the attack performs assuming known-documents as the attacker's knowledge. Figure <ref type="figure">5</ref> shows the accuracy of the attack using known-documents with varying knowndocuments rates of 0.05 ≤ ≤ 0.8 and steps of 0.05. We observe that with the initial | | = 10 setting the attack achieves higher accuracies faster for lower known-documents rates compared to an attack setting having | | = 5 initially. Also, with known-documents rates ≥ 0.7 the accuracy of the attack becomes constant and reaches near 100% accuracy for both 5 and 10 known queries. However, we do note that having a vocabulary size of real = 130 is a rather limited setting. In the next section we explore the attack using knowndocuments with larger vocabularies.</p><p>CKWS-adapted refined score attack using 0.7-known-documents. In the previous result with varying known-documents rates we observed that the accuracy of the attack using known-documents reaches near 100% for knowndocuments rate = 0.7 for both 5 and 10 known queries. Here we explore the accuracy of the attack by fixing the known-documents rate to = 0.7 with vocabulary sizes 250 and 500. Figure <ref type="figure">6</ref> shows a bar plot for both these results with error bar describing the standard deviation of the accuracy over 50 experiments. We observe that for vocabulary size 250 the difference with an attack using 5 known queries compared to 10 known queries is small. Also, the standard deviation in both settings is small. However, for the 500 keyword setting we clearly see a decrease in accuracy using 5 known queries and a large standard deviation. Whereas for 10 known queries the attack still reaches above 93% accuracy and standard deviation is small. We do note however that in this case an attacker has great advantage, since it knows at least 70% of the whole indexed dataset and 10 known queries. In comparison, previous passive query-recovery attacks <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10]</ref> on single-keyword search did not exceed 40% accuracy assuming known-documents rate of 0.8. Runtime and memory usage. Figure <ref type="figure" target="#fig_4">7</ref> describes the average runtime of the attack using known-documents over 50 repetitions in function of real for = 2. We observe that the runtime is high for considerably small vocabulary sizes, which is to be expected considering the time complexity described in Section 4.5. We only show the runtime of the attack using known-documents, however, runtime of the attack using similar-documents is similar. Although our runtime can further benefit from using multiple GPUs and even our code is written in such fashion, we found that using two GPUs does not necessarily speed up our attack due to large overhead.</p><p>The overall memory usage is dominated by the size of co-occurrence matrices ckw and td . Therefore, we can define the main memory usage of the attack by the size of these two matrices as a function of the vocabulary size and the number of queries observed. In our experiments we always assume the attacker observes |Q| = 0.15 • real queries. As a result an accurate estimation of the bytes used by one experiment is given by numberOfBytes( real , ) = 2 • (0.15 + 0.15 2 ) • real 2 • sizeof (float), where sizeof (•) returns the number of bytes used by the system to store a certain data type. Filling in for real = 500, = 2 and using 64 bit float, numberOfBytes(500, 2) ≈ 40 GiB, whereas the GPU used in our experiments fits at most 16 GB, meaning batching intermediate results is already required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>Runtime. Although requiring large co-occurrence matrices for the extended refined score attack is cumbersome, if the adversary has sufficient memory resources these large matrices will not be her only concern. Her main concern will be the runtime of the attack because without being able to parallelize our attack to multiple GPUs our attack is difficult to run for vocabulary sizes &gt; 500 and becomes infeasible for vocabulary sizes &gt; 1000, whereas the added time complexity using our extension strategy is relatively small.</p><p>Observed queries. Furthermore, the question arises whether it is realistic for an attacker to observe 15% of all possible queries. With only single-keyword search we believe this can be achieved. However, with = 2 the number of keyword conjunctions to be observed is big, i.e. 0.15 • real . Although a smaller percentage could be considered more realistic and would even decrease the runtime of the attack, larger |Q| is still desired, since it will result in better estimators for prediction and thus higher accuracies.</p><p>Query distribution. In our experiments we only sampled queries using a uniform distribution. However, it is likely that this is unrealistic for keyword conjunctions, since certain keywords might be more likely to be used in a query together whereas other possible conjunctions might not be queried at all. Having knowledge of whether certain keywords are more likely to be searched for in conjunction would decrease the complexity of the attack, since one can then only consider the top most likely keyword conjunctions.</p><p>Countermeasure. Previous query-recovery attacks on single-keyword search also describe a countermeasure against their attack. In our work we focus on the question if a generic extension is possible. However, because of our generic extension strategy, countermeasures tested in <ref type="bibr" target="#b5">[6]</ref> will be applicable but were not explored. Also, most introduced countermeasures do not actually leak less information, they make the leakage unusable by the attack proposed in the corresponding work (e.g. adding false positives in the result set).</p><p>Generic extension. Although we described an adapted version of the refined score attack by <ref type="bibr" target="#b5">[6]</ref> to a conjunctive keyword setting since it is good performing with low runtimes for single-keywords, our generic extension strategy using keyword conjunction sets is also valid for other attacks <ref type="bibr">([10, 3, 2]</ref>) and even other types of attacks (e.g. attacks using query frequency <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b15">16]</ref>). However, we expect similar runtime issues due to the large query space. Blackstone et al. <ref type="bibr" target="#b1">[2]</ref> has a particular algorithm using cross-filtering that could be helpful to be an attack specifically against conjunctive keyword search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this work we presented a generic extension strategy to adapt any passive query-recovery attack to a conjunctive keyword search setting. We specifically explored its applicability using the refined score attack proposed by Damie et al. <ref type="bibr" target="#b5">[6]</ref> to a conjunctive keyword search setting. It is the first study of passive query-recovery attacks in the conjunctive keyword search setting. We showed that our attack using documents that are similar, but otherwise different from the indexed documents on the server, does only achieve accuracy of 32% as attack on conjunctive keyword search. However, applying the adapted attack using known-documents can still perform with a low number of known queries and vocabulary size of 500 and achieves a recovery rate similar to previous passive query-recovery attacks <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b14">15]</ref> against single-keyword search.</p><p>Further, we discussed that the time complexity of the adapted attack grows combinatorial with the number of keywords in the conjunctive search query. Also, the storage required to perform the attack is dominated by the size of the co-occurrence matrices computed from the attacker's knowledge which also increases combinatorial.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 . 3 Fig. 2 .</head><label>132</label><figDesc>Fig. 1. Score attack using similardocuments for varying vocabulary sizes and initially known queries with = 2, |D real | = 18 , |D similar | = 12 , |Q| = 0.15 • real .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Accuracy plot of the CKWSadapted refined score attack with = 2 extrapolated and varying vocabulary size. With |D real | = 18 , |D similar | = 12 , |Q| = 0.15 • real .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Accuracy plot of the CKWSadapted refined score attack with = 2 and varying number of known queries. With |D | = 18 , |D | = 12 , |Q| = 0.15 • .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>10 Fig. 5 . 10 Fig. 6 .</head><label>105106</label><figDesc>Fig. 5. Accuracy of the CKWS-adapted refined score attack using known-data for varying known-data rates with = 2 and = = 130.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Runtime of the CKWS-adapted refined score attack using known-documents w.r.t. to vocabulary size, with = 2 and = 0.7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Notation</figDesc><table><row><cell cols="2">Notation Meaning</cell><cell>Size notation</cell></row><row><cell>Q</cell><cell>Set of observed trapdoors by the adversary</cell><cell></cell></row><row><cell></cell><cell>Document identifiers for each observed td ∈ Q</cell><cell></cell></row><row><cell cols="2">KnownQ Known (td, ckw)-pairs by the adversary</cell><cell></cell></row><row><cell>ckw</cell><cell>Set of distinct keywords used in a conjunctive keyword query</cell><cell></cell></row><row><cell></cell><cell>ckw-ckw co-occurrence matrix created</cell><cell>similar × similar</cell></row><row><cell>ckw</cell><cell>from D similar or D -known</cell><cell>or known × known</cell></row><row><cell>td</cell><cell>td-td co-occurrence matrix created from</cell><cell>×</cell></row><row><cell>D real</cell><cell>Real (indexed) document set</cell><cell></cell></row></table><note><p>real D similar Similar document set similar D -known -Known document set (0 &lt; ≤ 1) known (= • real ) W real Vocabulary of keywords extracted from D real real W similar Vocabulary of keywords extracted from D similar similar W known Vocabulary of keywords extracted from D -known known K real Set containing possible conjunctions of keyword combinations generated from W real real = real K similar Set containing possible conjunctions of keyword combinations generated from W similar similar = similar K known Set containing possible conjunctions of keyword combinations generated from W known known = known</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>https://trends.google.com/trends</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>Note: = 1 refers to a single-keyword search scheme.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>denotes the transpose of matrix A.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_3"><p>Our code is available at https://github.com/marcowindt/passive-ckws-attack</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tensorflow: A system for large-scale machine learning</title>
		<author>
			<persName><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Devin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Irving</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th {USENIX} symposium on operating systems design and implementation</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Revisiting leakage abuse attacks</title>
		<author>
			<persName><forename type="first">L</forename><surname>Blackstone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moataz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="page">2019</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Leakage-abuse attacks against searchable encryption</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Grubbs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSAC conference on computer and communications security</title>
		<meeting>the 22nd ACM SIGSAC conference on computer and communications security</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Highlyscalable searchable symmetric encryption with support for boolean queries</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Roşu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual cryptology conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">online search query size in</title>
		<author>
			<persName><forename type="first">J</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName><forename type="first">:</forename><forename type="middle">U</forename></persName>
		</author>
		<ptr target="https://www.statista.com/statistics/269740/number-of-search-terms-in-internet-research-in-the-us/" />
		<imprint>
			<date type="published" when="2020-08">2020. Aug 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A highly accurate query-recovery attack against searchable encryption using non-indexed documents</title>
		<author>
			<persName><forename type="first">M</forename><surname>Damie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Peter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th USENIX Security Symposium (USENIX Security 21)</title>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2021-08">Aug 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Symmetric key encryption with conjunctive field free keyword search scheme</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Fairouz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Advances in Mathematics and Computer Science</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Secure conjunctive keyword search over encrypted data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Golle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Staddon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on applied cryptography and network security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Forward secure conjunctive-keyword searchable encryption</title>
		<author>
			<persName><forename type="first">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Access pattern disclosure on searchable encryption: ramification, attack and mitigation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kuzu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kantarcioglu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Citeseer</publisher>
			<biblScope unit="volume">20</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Symmetric searchable encryption with efficient conjunctive keyword search</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Jho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KSII Transactions on Internet &amp; Information Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Introducing the enron corpus</title>
		<author>
			<persName><forename type="first">B</forename><surname>Klimt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CEAS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Result pattern hiding searchable encryption for conjunctive queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Patranabis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sakzad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mukhopadhyay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Steinfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">F</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zuo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Search pattern leakage in searchable encryption: Attacks and new construction</title>
		<author>
			<persName><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">A</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">265</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Passive attacks against searchable encryption</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">C</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hiding the access pattern is not enough: Exploiting search pattern leakage in searchable encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Oya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kerschbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th {USENIX} Security Symposium ({USENIX} Security 21)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Forward and backward private conjunctive searchable symmetric encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Patranabis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mukhopadhyay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Practical volume-based attacks on encrypted databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Poddar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 IEEE European Symposium on Security and Privacy (EuroS&amp;P)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An efficient conjunctive keyword and phase search scheme for encrypted cloud storage systems</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE 8th International Conference on Cloud Computing</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">An algorithm for suffix stripping</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Porter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
	<note type="report_type">Program</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The shadow nemesis: Inference attacks on efficiently deployable, efficiently searchable encryption</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pouliot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">V</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC conference on computer and communications security</title>
		<meeting>the 2016 ACM SIGSAC conference on computer and communications security</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Practical techniques for searches on encrypted data</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Perrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding 2000 IEEE Symposium on Security and Privacy</title>
		<meeting>eeding 2000 IEEE Symposium on Security and Privacy<address><addrLine>S&amp;P</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Catch you if you lie to me: Efficient verifiable conjunctive keyword search over large dynamic encrypted cloud data</title>
		<author>
			<persName><forename type="first">W</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">T</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Conference on Computer Communications (INFOCOM)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Practical volume-based attacks on encrypted databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Poddar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="page">2019</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Toward forward secure sse supporting conjunctive keyword search</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Vbtree: forward secure conjunctive queries over encrypted data for cloud computing</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Privacy-preserving and dynamic multi-attribute conjunctive keyword search over encrypted cloud data</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Access</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">All your queries are belong to us: The power of file-injection attacks on searchable encryption</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th {USENIX} Security Symposium ({USENIX} Security 16)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
