<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computing the Shapley Value of Facts in Query Answering</title>
				<funder ref="#_WQYsqJu">
					<orgName type="full">Israel Science Foundation</orgName>
					<orgName type="abbreviated">ISF</orgName>
				</funder>
				<funder ref="#_ZHx227U">
					<orgName type="full">European Union</orgName>
				</funder>
				<funder ref="#_4RGR6kx">
					<orgName type="full">German Research Foundation (DFG)</orgName>
				</funder>
				<funder>
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2022-01-02">2 Jan 2022</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
							<email>danielde@post.tau.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Nave</forename><surname>Frost</surname></persName>
							<email>navefrost@mail.tau.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
							<email>bennyk@cs.technion.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Mika√´l</forename><surname>Monet</surname></persName>
							<email>mikael.monet@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Tel Aviv University Blavatnik School of Computer Science</orgName>
								<address>
									<settlement>Tel Aviv</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Tel Aviv University Blavatnik School of Computer Science</orgName>
								<address>
									<settlement>Tel Aviv</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Faculty of Computer Science</orgName>
								<orgName type="institution">Technion -Israel Institute of Technology</orgName>
								<address>
									<settlement>Haifa</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution">Centrale Lille</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">CRIStAL</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Computing the Shapley Value of Facts in Query Answering</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2022-01-02">2 Jan 2022</date>
						</imprint>
					</monogr>
					<idno type="MD5">CB09C462A2C6E0B0454B4D683F9E39C0</idno>
					<idno type="arXiv">arXiv:2112.08874v2[cs.DB]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The Shapley value is a game-theoretic notion for wealth distribution that is nowadays extensively used to explain complex data-intensive computation, for instance, in network analysis or machine learning. Recent theoretical works show that query evaluation over relational databases fits well in this explanation paradigm. Yet, these works fall short of providing practical solutions to the computational challenge inherent to the Shapley computation. We present in this paper two practically effective solutions for computing Shapley values in query answering. We start by establishing a tight theoretical connection to the extensively studied problem of query evaluation over probabilistic databases, which allows us to obtain a polynomial-time algorithm for the class of queries for which probability computation is tractable. We then propose a first practical solution for computing Shapley values that adopts tools from probabilistic query evaluation. In particular, we capture the dependence of query answers on input database facts using Boolean expressions (data provenance), and then transform it, via Knowledge Compilation, into a particular circuit form for which we devise an algorithm for computing the Shapley values. Our second practical solution is a faster yet inexact approach that transforms the provenance to a Conjunctive Normal Form and uses a heuristic to compute the Shapley values. Our experiments on TPC-H and IMDB demonstrate the practical effectiveness of our solutions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Explaining query answers has been the objective of extensive research in recent years <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30]</ref>. A prominent approach is to devise an explanation based on the facts that were used for deriving the answers; these facts are often termed provenance or lineage of the query answer. For illustration, consider a query asking whether there exists a route from the USA to France with at most one connection over a database of airports and flights. The answer is Boolean, and upon receiving a positive answer one may seek explanations of why it is so. The basis for such explanations would include all details of qualifying routes that are used in the derivation of the answer. Unfortunately, the number of relevant routes might be huge (specifically, quadratic in the database size). Moreover, it is conceivable that different facts differ considerably in their importance to the answer at hand; for instance, some flights may be crucial to enabling the USA-France connection, while others may be easily replaced by alternatives.</p><p>To address these issues, there have been several proposals for principled ways of quantifying the contribution of input facts to query answers <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30]</ref>. We focus here on the recent approach of Livshits et al. <ref type="bibr" target="#b19">[20]</ref> that applies to this setting the notion of Shapley values <ref type="bibr" target="#b31">[32]</ref>-a game-theoretic function for distributing the wealth of a team in a cooperative game. This function has strong theoretical justifications <ref type="bibr" target="#b27">[28]</ref>, and indeed, it has been applied across various fields such as economics, law, environmental science, and network analysis. It has also been used for explanations in data-centric paradigms such as knowledge representation <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b38">39]</ref> and machine learning <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>. In the context of relational databases, given a query ùëû( x), a database ùê∑, an input fact ùëì ‚àà ùê∑ and a tuple t of same arity as x, the Shapley value of ùëì in ùê∑ for query ùëû( x) and tuple t intuitively represents the contribution of ùëì to the presence (or absence) of t in the query result.</p><p>Livshits et al. <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref> initiated the study of the computational complexity of calculating Shapley values in query answering. They showed mainly lower bounds on the complexity of the problem, with the exception of the sub-class of self-join free SPJ queries called hierarchical, where they gave a polynomial-time algorithm. The results are more positive if imprecision is allowed, as they showed that the problem admits a tractable approximation scheme (FPRAS, to be precise) via Monte Carlo sampling. The state of affairs is that the class of known tractable cases (namely the hierarchical conjunctive queries) is highly restricted, and the approximation algorithms with theoretical guarantees are impractical in the sense that they require a large number of executions of the query over database subsets (the samples). Hence, the theoretical analysis of Livshits et al. <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref> does not provide sufficient evidence of practical feasibility for adopting the Shapley value as a measure of responsibility in query answering. Moreover, the results of Livshits et al. <ref type="bibr" target="#b19">[20]</ref> imply that, for self-join free SPJ queries the class of tractable queries for computing Shapley values coincides with the class of tractable queries in probabilistic tuple-independent databases <ref type="bibr" target="#b6">[7]</ref>. Yet, no direct connection has been made between these two problems and, theoretically speaking, it has been left unknown whether algorithms for probabilistic databases can be used for Shapley computation.</p><p>Recently, Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> and Arenas et al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> investigated the computational complexity of the SHAP-score <ref type="bibr" target="#b21">[22]</ref>, a notion used in machine learning for explaining the predictions of a model. While both are based on the general notion of Shapley value, the SHAP-score for machine learning and Shapley values for databases are different. In the latter case, the players are the tuples of the database and the game function that is used is simply the value of the query on a subset of the database, while in the former case, the players are the features of the model and the game function is a conditional expectation of the model's output (see Section 6.2 for a more formal definition of the SHAP-score). Remarkably, Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> have shown that computing the SHAP-score is equivalent (in terms of polynomial-time reductions) to the problem of computing the expected value of the model. One of our contributions is to show that the techniques developed by <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b35">36]</ref> can be adapted to the context of Shapley values for databases. For instance, by adapting to our context the proof of Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> that computing the SHAP-score reduces to computing the expected value of the model, we resolve the aforementioned open question affirmatively: we prove that Shapley computation can be efficiently (polynomial-time) reduced to probabilistic query answering. Importantly, this applies not only to the restricted class of SPJ queries without self-joins, but to every database query. Hence, extending theory to practice, one can compute the Shapley values using a query engine for probabilistic databases.</p><p>In turn, a common approach that was shown to be practically effective for probabilistic databases is based on Knowledge Compilation <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref>. In a nutshell, the idea is to first compute the Boolean provenance of a given output tuple in the sense of Imielinski and Lipski <ref type="bibr" target="#b16">[17]</ref>, and then to "compile" the provenance into a particular circuit form that is more favorable for probability computation. Specifically, the target class of this compilation is that of deterministic and decomposable circuits (d-D). In our case, rather than going through probabilistic databases, we devise a more efficient approach that computes the Shapley values directly from the d-D circuit. This is similar to how Arenas at al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> directly prove that the SHAP-score can be computed efficiently over such circuits, without using the more general results of <ref type="bibr" target="#b35">[36]</ref>. By adapting the proof of <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, we show how, given a d-D circuit representing the provenance of an output tuple, we can efficiently compute the Shapley value of every input fact. While the aforementioned properties of the circuit are not guaranteed in general (beyond the class of hierarchical queries), we empirically show the applicability and usefulness of the approach even for non-hierarchical queries.</p><p>Our experimental results (see below) indicate that our exact computation algorithm is fast in most cases, but is too costly in others. For the latter cases, we propose a heuristic approach to retrieve the relative order of the facts by their Shapley values, without actually computing these values. Indeed, determining the most influential facts is in many cases already highly useful, even if their precise contribution remains unknown. The solution that we propose to this end is termed CNF Proxy; it is based on a transformation of the provenance to Conjunctive Normal Form (CNF) and using it to compute proxy values intuitively based on (1) the number of clauses in which a variable occur and (2) its alternatives in each clause. These are two aspects that are correlated with Shapley values. The proxy values may be very different from the real Shapley values, and yet, when we order facts according to their proxy values we may intuitively get an ordering that is similar to the order via Shapley. Our experiments validate that this intuition indeed holds for examined benchmarks.</p><p>We have experimented with multiple queries from the two standard benchmarks TPC-H and IMDB. Our main findings are as follows. In most cases (98.67% of the IMDB output tuples and 83.83% for TPC-H), our exact computation algorithm terminates in 2.5 seconds or less, given the provenance expression. In the vast majority of remaining cases the execution is very costly, typically running out of memory already in the Knowledge Compilation step. By contrast, our inexact solution CNF Proxy is extremely fast even for these hard cases -it typically terminates in a few milliseconds with the worst observed case (an outlier) being 4 seconds. In fact, it is faster by several orders of magnitude than sampling-based approximation techniques (the Monte Carlo sampling proposed in <ref type="bibr" target="#b19">[20]</ref> as well as a popular sampling-based solution for Shapley values in Machine Learning (Kernel SHAP <ref type="bibr" target="#b21">[22]</ref>). To measure quality, we use CNF Proxy to rank the input tuples, and compared the obtained ranked lists to ranking by actual Shapley values (in cases where exact computation has succeeded), using the standard measures of nDCG and Precision@k. Our solution outperforms the competitors in terms of quality as well.</p><p>We then propose a simple hybrid approach: execute the exact algorithm until it either terminates or a timeout elapses. If we have reached the timeout, resort to executing CNF Proxy and rank the facts based on the obtained values. We show experiments with different timeout values, justifying our choice of 2.5 seconds.</p><p>Hence, our contributions are both of a theoretical and practical nature and can be summarized as follows.</p><p>‚Ä¢ By adapting the proof technique of <ref type="bibr" target="#b35">[36]</ref>, we establish a fundamental result about the complexity of computing Shapley values over relational queries: Shapley values can be computed in polynomial time-in data complexity-whenever the query can be evaluated in polynomial time over tupleindependent probabilistic databases (Proposition 3.1). This holds for every query. ‚Ä¢ By adapting the proof technique of <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, we devise a novel algorithm for computing Shapley values for query evaluation via compilation to a deterministic and decomposable circuit (Proposition 4.4). We show that this algorithm is practical and has the theoretical guarantee of running in polynomial time in the size of the circuit. ‚Ä¢ We present a novel heuristic, CNF Proxy, that is fast yet inexact, and is practically effective if we are interested in ranking input facts by their contribution rather than computing exact Shapley values (Section 5). ‚Ä¢ We describe a thorough experimental study of our algorithms over realistic data and show their efficiency (Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work.</head><p>Existing models for explaining database query results may roughly be divided in two categories: (1) models that are geared for tracking/presenting provenance of output tuples, e.g., the set of all input facts participating in their computation <ref type="bibr" target="#b5">[6]</ref>, possibly alongside a description of the ways they were used, in different granularity levels (e.g., <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b13">14]</ref>); (2) models that quantify contributions of input facts <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30]</ref>, which is the approach that we follow here. Works in the latter context often have connections with the influential line of work on probabilistic databases <ref type="bibr" target="#b32">[33]</ref>, and we show that this is the case for Shapley computation as well.</p><p>As already mentioned, an important point of comparison is the work of Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> and that of Arenas et al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> on the SHAP-score. While we show that the proof techniques developed in this area can be adapted to the context of relational databases, we point out that the two sets of results obtained (for SHAP-score and for Shapley values for databases) seem incomparable, as we do not see a way of proving results for Shapley value for query answering using the results on the SHAP-score, or vice-versa. In fact, this adaptation only works up to a certain point. For instance, the efficiency axiom of the Shapley value immediately implies that computing the expected value of a model can be reduced in polynomial time to computing the SHAP-score of its features; in contrast, this axiom does not seem to yield any clear such implication in our context (see our Open Problem 1 and the discussion around it).</p><p>Paper organization. We formalize the notion of Shapley values for query answering in Section 2. In Section 3 we present the theoretical connection to probabilistic databases and its implications. Our exact computation algorithm is presented in Section 4 and our heuristic in Section 5. Experimental results are presented in Section 6 and we conclude in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE SHAPLEY VALUE OF FACTS</head><p>We define here the main notion and illustrate it with an example.</p><p>Relational databases and queries. Let Œ£ = {ùëÖ 1 , . . . , ùëÖ ùëõ } be a signature, consisting of relation names ùëÖ ùëñ each with its associated arity ar(ùëÖ ùëñ ) ‚àà N, and Const be a set of constants. A fact over (Œ£, Const) is simply a term of the form ùëÖ(ùëé 1 , . . . , ùëé ar(ùëÖ) ), for ùëÖ ‚àà Œ£ and ùëé ùëñ ‚àà Const. A (Œ£, Const)-database ùê∑, or simply a database ùê∑, is a finite set of facts over (Œ£, Const). We assume familiarity with the most common classes of query languages and refer the reader to <ref type="bibr" target="#b0">[1]</ref> for the basic definitions. In particular, we recall the equivalence between relational algebra and relational calculus <ref type="bibr" target="#b0">[1]</ref>, and the fact that Select-Project-Join-Union (SPJU) queries are equivalent to unions of conjunctive queries (UCQs). Depending of the context and for consistency with relevant past publications, we will use terminology of either relational calculus or relational algebra. What we call a Boolean query is a query ùëû that takes as input a database ùê∑ and outputs ùëû(ùê∑) ‚àà {0, 1}. If ùëû( x) is a query with free variables x and t is a tuple of constants of same length as x, we denote by ùëû[ x/ t] the Boolean query defined by: ùëû[ x/ t] (ùê∑) = 1 if and only if t is in the output of ùëû( x) on ùê∑.</p><p>Shapley values of facts. Following <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref>, we use the notion of Shapley values <ref type="bibr" target="#b31">[32]</ref> to attribute a contribution to facts of an input database. In this context, the database ùê∑ is traditionally partitioned into two sets of facts: a set ùê∑ x of so-called exogenous facts, and a set ùê∑ n of endogenous facts. The idea is that exogenous facts are considered as given, while endogenous facts are those to which we would like to attribute contributions. Let ùëû be a Boolean query and ùëì ‚àà ùê∑ n be an endogenous fact. The Shapley value of ùëì in ùê∑ for query ùëû, denoted Shapley(ùëû, ùê∑ n , ùê∑ x , ùëì ), is defined as</p><formula xml:id="formula_0">Shapley(ùëû, ùê∑ n , ùê∑ x , ùëì ) def =<label>(1)</label></formula><formula xml:id="formula_1">‚àëÔ∏Å ùê∏ ‚äÜùê∑ n \{ùëì } |ùê∏|!(|ùê∑ n | -|ùê∏| -1)! |ùê∑ n |! ùëû(ùê∑ x ‚à™ ùê∏ ‚à™ {ùëì }) -ùëû(ùê∑ x ‚à™ ùê∏) .</formula><p>Notice that here, |ùê∏|!(|ùê∑ n | -|ùê∏| -1)! is the number of permutations of ùê∑ n with all endogenous facts in ùê∏ appearing first, then ùëì , and finally, all the other endogenous facts. Intuitively then, the value Shapley(ùëû, ùê∑ n , ùê∑ x , ùëì ) represents the contribution of ùëì to the query's output: the higher this value is, the more ùëì helps in satisfying ùëû.</p><p>For non-Boolean queries ùëû( x), we are interested in the Shapley value of the fact ùëì for every individual tuple t in the output <ref type="bibr" target="#b19">[20]</ref>. The extension to non-Boolean ùëû( x) is then straightforward: the Shapley value of the fact ùëì for the answer t to ùëû( x) is the value Shapley(ùëû[ x/ t], ùê∑ n , ùê∑ x , ùëì ). Therefore, the computational challenge reduces to that of the Boolean query ùëû [ x/ t]. Hence, in the theoretical analysis we focus on Boolean queries, and we go back to considering non-Boolean queries when we study the implementation aspects (starting in Section 4.2).</p><p>Example 2.1. Consider the database ùê∑ and the Boolean query ùëû from Figures <ref type="figure" target="#fig_1">1a</ref> and<ref type="figure" target="#fig_1">1c</ref>. All facts in table Flights are endogenous, while facts in Airports are exogenous. To alleviate the notation we write, e.g., ùëé 1 for Flights(JFK, CDG). The query ùëû checks if there are routes from "USA" to "FR" with one or less connecting flights. Let us compute the Shapley value of all endogenous facts. First, we notice that fact ùëé 8 is not part of any valid route, so Shapley(ùëû, ùê∑ n , ùê∑ x , ùëé 8 ) = 0 by Equation <ref type="bibr" target="#b0">(1)</ref>. Next, let us focus on ùëé 1 . Since ùëé 1 is a valid route on its own, adding it to any subset of (endogenous) facts ùê∏ such that ùê∏ does not contain a valid route results in ùëû(ùê∑ x ‚à™ ùê∏ ‚à™ {ùëé 1 }) -ùëû(ùê∑ x ‚à™ ùê∏) = 1 (for all other subsets the difference will be 0). The relevant subsets are the empty set, all singletons {ùëé ùëñ } for 2 ‚â§ ùëñ ‚â§ 8 (7 singletons), all the pairs of tuples from ùëé 2 , . . . , ùëé 8 excluding the pairs {ùëé 2 , ùëé 4 }, {ùëé 2 , ùëé 5 }, {ùëé 3 , ùëé 4 }, {ùëé 3 , ùëé 5 }, and {ùëé 6 , ùëé 7 } (so 7  2 -5 = 16 pairs), the quadruples {ùëé 2 , ùëé  </p><formula xml:id="formula_2">Shapley(ùëû, ùê∑ n , ùê∑ x , ùëé 1 ) = 1 ‚Ä¢ 0! ‚Ä¢ 7! 8! + 7 ‚Ä¢ 1! ‚Ä¢ 6! 8! + 16 ‚Ä¢ 2!5! 8! + 14 ‚Ä¢ 3!4! 8! + 4 ‚Ä¢ 4!3! 8! = 43</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">REDUCTION TO PROBABILISTIC DATABASES</head><p>In this section we investigate the complexity of computing Shapley values. As explained in the previous section, the non-Boolean setting of the problem may be reduced to that of Boolean queries, so we will study the following problem for a given Boolean query ùëû.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROBLEM: Shapley(ùëû)</head><p>INPUT: A database ùê∑ = ùê∑ x ‚à™ ùê∑ n and an endogenous fact ùëì ‚àà ùê∑ n . OUTPUT: The value Shapley(ùëû, ùê∑ n , ùê∑ x , ùëì ).</p><p>Note that for the sake of complexity analysis, the query ùëû is assumed to be fixed, so that each query gives rise to a different computational problem; we are then considering what is called the data complexity <ref type="bibr" target="#b36">[37]</ref>. This assumption is motivated by the fact that in practice, the queries are much smaller than the databases.</p><p>The complexity of this problem has been studied in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref>, where in particular a dichotomy has been obtained for self-join-free Boolean conjunctive queries (sjfbcqs). There, the authors show that, for every sjfbcq ùëû, either ùëû is hierarchical (we will not need to define this notion here) and Shapley(ùëû) can be solved in polynomial time, or ùëû is not hierarchical and then Shapley(ùëû) is intractable (specifically, FP Routes from "USA" to "FR" with one or less connecting flights</p><formula xml:id="formula_3">ùëû 1 = ‚àÉùë•, ùë¶ : Airports(ùë•, "USA") ‚àß Airports(ùë¶, "FR") ‚àß Flights(ùë•, ùë¶) ùëû 2 = ‚àÉùë•, ùë¶, ùëß : Airports(ùë•, "USA") ‚àß Airports(ùëß, "FR") ‚àß Flights(ùë•, ùë¶) ‚àß Flights(ùë¶, ùëß) ùëû = ùëû 1 ‚à® ùëû 2 (c) ùëû is a Boolean union of conjunctive queries (UCQ) (ùëé 1 ‚àß ùëè 1 ‚àß ùëè 8 ) ùëû 1 provenance ‚à® (ùëé 2 ‚àß ùëé 4 ‚àß ùëè 2 ‚àß ùëè 8 ) ‚à® (ùëé 2 ‚àß ùëé 5 ‚àß ùëè 2 ‚àß ùëè 7 ) ‚à® (ùëé 3 ‚àß ùëé 4 ‚àß ùëè 3 ‚àß ùëè 8 ) ‚à® (ùëé 3 ‚àß ùëé 5 ‚àß ùëè 3 ‚àß ùëè 7 ) ‚à® (ùëé 6 ‚àß ùëé 7 ‚àß ùëè 5 ‚àß ùëè 7 ) ùëû 2 provenance (d)</formula><p>The lineage Lin(ùëû, ùê∑) as a formula in Disjunctive Normal Form (DNF) Figure <ref type="figure" target="#fig_1">1</ref>: The database, query ùëû and its lineage used for our running example is obtained-being hierarchical-is exactly the same as in the context of probabilistic query evaluation (PQE); see, e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. In fact, the main result of this section is that this is not a coincidence: we prove that, for every Boolean query ùëû (not just for sjfbcqs), if PQE is tractable for ùëû then so is the problem Shapley(ùëû). Since PQE has been intensively studied already, our result allows us to vastly extend the tractable cases identified in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref>. We now proceed with the definitions and proof of this result, and explain its consequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Probabilistic query evaluation.</head><p>A tuple-independent (TID) database is a pair consisting of a database ùê∑ and a function ùúã mapping each fact ùëì ‚àà ùê∑ to a probability value ùúã (ùëì ) ‚àà [0, 1]. The TID (ùê∑, ùúã) defines a probability distribution Pr ùúã on ùê∑ ‚Ä≤ ‚äÜ ùê∑, where</p><formula xml:id="formula_4">Pr ùúã (ùê∑ ‚Ä≤ ) def = ùëì ‚ààùê∑ ‚Ä≤ ùúã (ùëì ) √ó ùëì ‚ààùê∑\ùê∑ ‚Ä≤ (1 -ùúã (ùëì ))</formula><p>. Given a Boolean query ùëû, the probability that ùëû is satisfied by (ùê∑, ùúã) is Pr(ùëû, (ùê∑, ùúã))</p><formula xml:id="formula_5">def = ùê∑ ‚Ä≤ ‚äÜùê∑ s.t. ùëû (ùê∑ ‚Ä≤ )=1 Pr ùúã (ùê∑ ‚Ä≤ ).</formula><p>The probabilistic query evaluation problem for ùëû, PQE(ùëû) for short, is then defined as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROBLEM: PQE(ùëû)</head><p>INPUT: A tuple-independent database (ùê∑, ùúã). OUTPUT: The value Pr(ùëû, (ùê∑, ùúã)).</p><p>For two computational problems ùê¥ and ùêµ, we write ùê¥ ‚â§ p T ùêµ to assert the existence of a polynomial-time Turing reduction from ùê¥ to ùêµ. We are ready to state the main result of this section. This result implies that for any query ùëû for which PQE(ùëû) is tractable then so is Shapley(ùëû). Dalvi and Suciu <ref type="bibr" target="#b7">[8]</ref> showed a dichotomy for unions of conjunctive queries: for every such query ùëû, either PQE(ùëû) is solvable in polynomial time, in which case ùëû is called safe<ref type="foot" target="#foot_0">1</ref> , or PQE(ùëû) is FP #P -hard (and ùëû is called unsafe). Therefore, we obtain as a direct corollary of Proposition 3.1 that Shapley(ùëû) can be solved in polynomial time for all safe queries. Corollary 3.2. If ùëû is a safe UCQ then Shapley(ùëû) can be solved in polynomial time.</p><p>In particular, this corollary generalizes the tractability result obtained in <ref type="bibr" target="#b19">[20]</ref>, to account for CQs with self-joins and even unions of such queries. We now prove Proposition 3. Then, by grouping by size the terms ùê∏ from Equation 1 we obtain</p><formula xml:id="formula_6">Shapley(ùëû, ùê∑ n , ùê∑ x , ùëì ) = |ùê∑ n |-1 ‚àëÔ∏Å ùëò=0 ùëò!(|ùê∑ n | -ùëò -1) |ùê∑ n | (2) #Slices(ùëû, ùê∑ x ‚à™ {ùëì }, ùê∑ n \ {ùëì }, ùëò) -#Slices(ùëû, ùê∑ x , ùê∑ n \ {ùëì }, ùëò) .</formula><p>All arithmetical terms (such as ùëò! or |ùê∑ n |!) can be computed in polynomial time. Therefore, to prove that Shapley(ùëû) ‚â§ p T PQE(ùëû), it is enough to show that, given an oracle to the problem PQE(ùëû), we can compute in polynomial time the quantities #Slices(ùëû, ùê∑ x , ùê∑ n , ùëò), for some arbitrary ùê∑ = ùê∑ x ‚à™ ùê∑ n and ùëò ‚àà {0, . . . , |ùê∑ n |}. This is what we do next.</p><p>The proof is similar to that of <ref type="bibr" target="#b35">[36,</ref><ref type="bibr">Theorem 2]</ref> in the context of SHAP-score for machine learning (but, as explained in the Introduction, the two results seem to be incomparable).</p><p>We wish to compute #Slices(ùëû, ùê∑ x , ùê∑ n , ùëò), for some database ùê∑ = ùê∑ x ‚à™ùê∑ n and integer ùëò ‚àà {0, . . . |ùê∑ n |}. Let ùëõ = |ùê∑ n | be the number of endogenous facts of ùê∑. For ùëß ‚àà Q, we define a TID database (ùê∑ ùëß , ùúã ùëß ) as follows: ùê∑ ùëß contains all the facts of ùê∑, and for an exogenous fact ùëì of ùê∑ we define ùúã ùëß (ùëì ) def = 1 while for an endogenous fact ùëì of ùê∑ we define ùúã ùëß (ùëì ) def = ùëß 1+ùëß . It is then routine to show that the following relation holds:</p><formula xml:id="formula_7">(1 + ùëß) ùëõ Pr(ùëû, (ùê∑ ùëß , ùúã ùëß )) = ùëõ ‚àëÔ∏Å ùëñ=0 ùëß ùëñ #Slices(ùëû, ùê∑ x , ùê∑ n , ùëñ).</formula><p>This suffices to conclude the proof. Indeed, we now call an oracle to PQE(ùëû) on ùëõ + 1 databases ùê∑ ùëß 0 , . . . , ùê∑ ùëß ùëõ for ùëõ + 1 arbitrary distinct values ùëß 0 , . . . , ùëß ùëõ , forming a system of linear equations as given by the relation above. Since the corresponding matrix is a Vandermonde with distinct coefficients, it is invertible, so we can compute in polynomial time the value #Slices(ùëû, ùê∑ x , ùê∑ n , ùëò). ‚ñ°</p><p>A intriguing natural question is whether the converse of Proposition 3.1 is true, that is, whether we also have PQE(ùëû) ‚â§ p T Shapley(ùëû). This is true when ùëû is a self-join-free conjunctive query: indeed, by the results of <ref type="bibr" target="#b19">[20]</ref>, either ùëû is hierarchical and then both PQE(ùëû) and Shapley(ùëû) can be solved in polynomial time (hence PQE(ùëû) ‚â§ p T Shapley(ùëû)), or ùëû is not hierarchical and then Shapley(ùëû) is FP #Phard (which, together with the fact that PQE(ùëû) ‚àà FP #P , implies PQE(ùëû) ‚â§ p T Shapley(ùëû)). However, to the best of our knowledge, the existence of such a reduction in the general case is unknown.</p><p>Open problem 1. Do we have PQE(ùëû) ‚â§ p T Shapley(ùëû) for every Boolean query ùëû?</p><p>Interestingly, we note that this direction is trivial in the setting of SHAP-scores. Indeed, this is directly implied by the efficiency axiom of the Shapley value; see, e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">Lemma 4.2]</ref> or <ref type="bibr" target="#b35">[36,</ref><ref type="bibr">Equation 5</ref>]. In our case, this axiom only gives us the following equality:</p><formula xml:id="formula_8">‚àëÔ∏Å ùëì ‚ààùê∑ n Shapley(ùëû, ùê∑ n , ùê∑ x , ùëì ) = ùëû(ùê∑ n ‚à™ ùê∑ x ) -ùëû(ùê∑ x ),</formula><p>which does not seem to help in showing PQE(ùëû) ‚â§ p T Shapley(ùëû).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXACT COMPUTATION THROUGH KNOWLEDGE COMPILATION</head><p>Motivated by the connection to PQE that we have seen in Section 3, we now investigate whether an approach using knowledge compilation can be used for computing Shapley values. Indeed, a common method to compute the probability that a probabilistic database (ùê∑, ùúã) satisfies a Boolean query ùëû is to first compute the lineage of ùëû on ùê∑ in a formalism from knowledge compilation, and then to use the good properties of said formalism to compute Pr(ùëû, (ùê∑, ùúã)) in linear time <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b32">33]</ref>. Recently, Arenas and others <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> showed that this approach is also viable for the notion of SHAP-score used in machine learning, by proving that SHAPscores can be computed in polynomial time when the models are given as circuits from knowledge compilation. By reusing some of these techniques, we can show that this method can also be used in our setting for computing Shapley values of database facts. Again, to the best of our knowledge, the two results are incomparable, i.e., we are not aware of a reduction in either direction between the two problems. We start by formally defining the notions of lineage and the relevant circuit classes from knowledge compilation. Boolean functions and query lineages. Let ùëã be a finite set of variables. An assignment ùúà of ùëã is a subset ùúà ‚äÜ ùëã of ùëã . We denote by 2 ùëã the set of all assignments of ùëã . A Boolean function ùúë over ùëã is a function ùúë : 2 ùëã ‚Üí {0, 1}. An assignment ùúà ‚äÜ ùëã is satisfying if ùúë (ùúà) = 1. We denote by SAT(ùúë) ‚äÜ 2 ùëã the set of all satisfying assignments of ùúë, and by #SAT(ùúë) the size of this set. For ùëò ‚àà N, we define SAT ùëò (ùúë)</p><formula xml:id="formula_9">‚àß ‚àß ¬¨ ¬¨ ¬¨ ùëé 3 ùëé 5 ùëé 1 ¬¨ ¬¨ ‚àß ‚àß ùëé 7 ‚àß ùëé 6 ùëé 4 ùëé 2 ‚à® ‚à® ¬¨ ¬¨ ¬¨</formula><formula xml:id="formula_10">def = SAT(ùúë) ‚à© {ùúà ‚äÜ ùëã | |ùúà | = ùëò }, that</formula><p>is, the set of satisfying assignments of ùúë of Hamming weight ùëò, and let #SAT ùëò (ùúë) be the size of this set.</p><p>Let ùëû be a Boolean query and ùê∑ be a database. The lineage Lin(ùëû, ùê∑) is the (unique) Boolean function whose variables are the facts of ùê∑, and that maps each sub-database ùê∑ ‚Ä≤ ‚äÜ ùê∑ to ùëû(ùê∑ ‚Ä≤ ). This definition extends straightforwardly to queries with free variables as follows: if ùëû( x) is a query with free variables x and t is a tuple of constants of the appropriate size, then Lin(ùëû[ x/ t]), ùê∑) is the lineage for the tuple t.</p><p>Example 4.1. Consider again the database ùê∑ and the Boolean query ùëû from Figures <ref type="figure" target="#fig_1">1a</ref> and<ref type="figure" target="#fig_1">1c</ref>. In Figure <ref type="figure" target="#fig_1">1d</ref>, the lineage Lin(ùëû, ùê∑) is represented as a formula in disjunctive normal form (DNF).</p><p>For our purposes, we will use a refinement of this lineage that accounts for the nature of exogenous tuples; specifically, these tuples should be considered as always being part of the database. Let ùê∑ = ùê∑ n ‚à™ ùê∑ x be a database with endogenous tuples ùê∑ n and exogenous tuples ùê∑ x , and let ùëû be a Boolean query. Then the endogenous lineage ELin(ùëû, ùê∑ x , ùê∑ n ) is the (unique) Boolean function whose variables are ùê∑ n and that maps every set ùê∏ of endogenous facts to ùëû(ùê∑ x ‚à™ ùê∏). In other words, ELin(ùëû, ùê∑ x , ùê∑ n ) can be obtained from Lin(ùëû, ùê∑) by fixing all variables in ùê∑ x to the value 1. Again, we extend this definition to queries with free variables by using the function ELin(ùëû[ x/ t], ùê∑ x , ùê∑ n ).</p><p>Example 4.2. Continuing the previous example, the endogenous lineage ELin(ùëû, ùê∑ n , ùê∑ x ) can be represented as a DNF by</p><formula xml:id="formula_11">ùëé 1 ‚à® (ùëé 2 ‚àß ùëé 4 ) ‚à® (ùëé 2 ‚àß ùëé 5 ) ‚à® (ùëé 3 ‚àß ùëé 4 ) ‚à® (ùëé 3 ‚àß ùëé 5 ) ‚à® (ùëé 6 ‚àß ùëé 7 ) .</formula><p>In the last two examples, lineages were represented with Boolean formulas in DNF. Since a lineage is a Boolean function, it can be represented with any formalism that allows to represent Boolean functions. We next review some classes of circuits from the field of knowledge compilation that will be relevant for our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Knowledge compilation classes.</head><p>Let ùê∂ be a Boolean circuit, featuring ‚àß, ‚à®, ¬¨, and variable gates, with the usual semantics. 2  The output gate, for instance, is a deterministic ‚à®-gate: indeed, its left child requires ùëé 1 to be 1, whereas its right child requires ùëé 1 to be 0. The right child of the output gate is a decomposable ‚àß-gate: indeed, for its left child ùëî 1 we have Vars(ùëî 1 ) = {ùëé 1 }, whereas for its right child ùëî 2 we have Vars(ùëî 2 ) = {ùëé 2 , ùëé 3 , ùëé 4 , ùëé 5 , ùëé 6 , ùëé 7 }, and these are indeed disjoint. The reader can easily check that all other ‚à®gates are deterministic, and that all other ‚àß-gates are decomposable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Algorithm</head><p>The main result of this section is then the following. Proof of Proposition 4.4. Let ùê∂ be a deterministic and decomposable circuit representing ELin(ùëû, ùê∑ n , ùê∑ x ), and let ùëì ‚àà ùê∑ n . First, we complete the circuit ùê∂ so that all variables of ùê∑ n appear in ùê∂. Indeed, it could be the case that Vars(ùê∂) ‚ää ùê∑ n : this happens for instance with the deterministic and decomposable circuit in Figure <ref type="figure" target="#fig_2">2</ref>, where the endogenous fact ùëé 8 does not appear in the circuit. To do this, we conjunct ùê∂ with the conjunction ùëì ‚Ä≤ ‚ààùê∑ n \Vars(ùê∂) (ùëì ‚Ä≤ ‚à® ¬¨ùëì ‚Ä≤ ). Note that this does not change the semantics of the circuit (as this conjunction always evaluates to 1) and that the resulting circuit is still deterministic and decomposable. Now, let ùê∂ 1 (resp., ùê∂ 2 ) be the Boolean circuit obtained from ùê∂ by replacing all variable gates corresponding to the fact ùëì by a constant 1-gate (resp., by a constant 0-gate). Observe then that the variables of ùê∂ 1 and ùê∂ 2 are exactly ùê∑ n \ {ùëì }, and moreover that ùê∂ 1 and ùê∂ 2 are still deterministic and decomposable. By definition of the endogenous lineage, we can rewrite Equation (2) into the following. 2 We allow unbounded-fanin ‚àßand ‚à®-gates, and also allow constant 1-gates and constant 0-gates as, respectively, ‚àß-gates with no input and ‚à®-gates with no inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Shapley(ùëû, ùê∑</head><formula xml:id="formula_12">n , ùê∑ x , ùëì ) = |ùê∑ n |-1 ‚àëÔ∏Å ùëò=0 ùëò!(|ùê∑ n | -ùëò -1) |ùê∑ n |<label>(3)</label></formula><p>#SAT ùëò (ùê∂ 1 ) -#SAT ùëò (ùê∂ 2 ) .</p><p>Proposition 4.4 will thus directly follow from the next lemma. First of all, we preprocess ùê∂ so that the fanin of every ‚à®and ‚àß-gate is exactly 0 or 2; this can simply be done by rewriting every ‚àß-gate of fanin ùëö &gt; 2 with ùëö -1 ‚àßgates of fanin 2 (same for ‚à®-gates), and adding a constant gate of the appropriate type to every ‚à®and ‚àß-gate of fan-in 1. We then compute, for every gate ùëî of ùê∂, the set of variables Vars(ùëî) upon which the value of ùëî depends. For a gate ùëî of ùê∂, let us denote by ùúë ùëî the Boolean function over the variables Vars(ùëî) that is represented by this gate. For a gate ùëî and an integer ‚Ñì ‚àà {0, . . . , |Vars(ùëî)|}, we define ùõº ‚Ñì ùëî def = #SAT ‚Ñì (ùúë ùëî ), i.e. the number of assignments of size ‚Ñì to Vars(ùëî) that satisfy ùúë ùëî . We will show how to compute all the values ùõº ‚Ñì ùëî for every gate ùëî of ùê∂ and ‚Ñì ‚àà {0, . . . , |Vars(ùëî)|} in polynomial time. This will conclude the proof since, for the output gate ùëî output of ùê∂, we have that ùõº ùëò ùëî output = #SAT ùëò (ùëì ). We will need the following notation: for two disjoint sets of variables ùëã 1 , ùëã 2 and two subsets ùëÜ 1 ‚äÜ 2 ùëã 1 , ùëÜ 2 ‚äÜ 2 ùëã 2 of assignments to ùëã 1 and ùëã 2 , we denote by </p><formula xml:id="formula_13">ùëÜ 1 ‚äó ùëÜ 2 ‚äÜ 2 ùëã 1 ‚à™ùëã 2 the set of assignments of ùëã 1 ‚à™ ùëã 2 defined by ùëÜ 1 ‚äó ùëÜ 2 def = {ùúà 1 ‚à™ ùúà 2 | ùúà 1 ‚àà ùëÜ 2 ,</formula><formula xml:id="formula_14">SAT(ùúë ùëî ) = (SAT(ùúë ùëî 1 ) ‚äó 2 ùëÜ 1 ) ‚à™ (SAT(ùúë ùëî 2 ) ‚äó 2 ùëÜ 2 )</formula><p>with the union being disjoint. By intersecting with the assignments of Vars(ùëî) of size ‚Ñì, we obtain:</p><formula xml:id="formula_15">SAT ‚Ñì (ùúë ùëî ) = (SAT(ùúë ùëî 1 ) ‚äó 2 ùëÜ 1 ) ‚à© {ùúà ‚äÜ Vars(ùëî) | |ùúà | = ‚Ñì } ‚à™ (SAT(ùúë ùëî 2 ) ‚äó 2 ùëÜ 2 ) ‚à© {ùúà ‚äÜ Vars(ùëî) | |ùúà | = ‚Ñì }</formula><p>with again the middle union being disjoint, therefore: </p><formula xml:id="formula_16">#SAT ‚Ñì (ùúë ùëî ) =|(SAT(ùúë ùëî 1 ) ‚äó 2 ùëÜ 1 ) ‚à© {ùúà ‚äÜ Vars(ùëî) | |ùúà | = ‚Ñì }| + |(SAT(ùúë ùëî 2 ) ‚äó 2 ùëÜ 2 ) ‚à© {ùúà ‚äÜ Vars(ùëî) | |ùúà | = ‚Ñì }|</formula><formula xml:id="formula_17">‚àëÔ∏Å ùëñ = max(0, ‚Ñì-|ùëÜ 1 |) ùõº ùëñ ùëî 1 √ó |ùëÜ 1 | ‚Ñì -ùëñ .</formula><p>Decomposable ‚àß-gate. If ùëî is a decomposable ‚àß-gate with no input then ùúë ùëî is the Boolean function on variables Vars(ùëî) = ‚àÖ that is always true, hence ùõº 0 ùëî = 1. Otherwise, let ùëî 1 and ùëî 2 be the two input gates of ùëî. Since ùëî is decomposable we have Vars(ùëî) = Vars(ùëî 1 ) ‚à™ Vars(ùëî 2 ) with the union being disjoint. But then we have:</p><formula xml:id="formula_18">SAT(ùúë ùëî ) = SAT(ùúë ùëî 1 ) ‚äó SAT(ùúë ùëî 2 )</formula><p>We now intersect with the set of assignments of Vars(ùëî) of size ùëô to obtain</p><formula xml:id="formula_19">ùõº ‚Ñì ùëî = #SAT ‚Ñì (ùúë ùëî ) = min(‚Ñì, |Vars(ùëî 1 ) |) ‚àëÔ∏Å ùëñ = max(0, ‚Ñì-|Vars(ùëî 2 ) |) ùõº ùëñ ùëî 1 √ó ùõº ‚Ñì-ùëñ ùëî 2</formula><p>This concludes the proof of the lemma, as well as the proof of Proposition 4. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This function computes values ùõº ‚Ñì</head><p>ùëî by bottom-up induction on ùê∂ just as in the proof of Lemma 4.5, by using the appropriate equations depending on the type of each gate. Then, Lines 1-5 in the algorithm simply follow the part of the proof that starts at the beginning of this section until Lemma 4.5. For instance, the returned value on Line 5 corresponds to Equation <ref type="bibr" target="#b2">(3)</ref>. A quick inspection of Algorithm 1 reveals that, if one ignores the complexity of performing arithmetic operations (i.e., considering that additions and multiplications take constant time), the running time is ùëÇ (|ùê∂ | ‚Ä¢ |ùê∑ n | 2 ). If one wishes to compute the Shapley value of every endogenous fact (as will be done in the experiments), then the overall complexity is ùëÇ (|ùê∂ | ‚Ä¢ |ùê∑ n |<ref type="foot" target="#foot_1">3</ref> ). Last, we point out that, in the case of non-Boolean queries, this cost is incurred for each potential output tuple that one wants to analyze.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementation Architecture</head><p>In this section, we present our architecture for implementing the knowledge compilation approach over realistic datasets. The relevant parts, for now, are the middle and top part of Figure <ref type="figure" target="#fig_8">3</ref>, which we next explain. Given a database ùê∑ = ùê∑ x ‚à™ ùê∑ n , a query ùëû( x), a tuple t of the same arity as x, and an endogenous fact ùëì ‚àà ùê∑ n , we want to compute Shapley(ùëû[ x/ t], ùê∑ x , ùê∑ n , ùëì ). We use two existing tools to help us with this task: ProvSQL <ref type="bibr" target="#b30">[31]</ref> and the knowledge compiler c2d <ref type="bibr" target="#b9">[10]</ref>. ProvSQL is a tool integrated into PostgreSQL that can perform provenance (lineage) computation in various semirings. For our purposes, a knowledge compiler is a tool that takes as input a Boolean function in CNF and outputs an equivalent Boolean function into another formalism. The target formalism that we will use is the so-called "d-DNNF". A d-DNNF is simply a deterministic and decomposable Boolean circuit such that negation gates are only applied to variables (NNF stands for negation normal form). <ref type="foot" target="#foot_2">4</ref>In our case, we use ProvSQL as follows: we feed it the database ùê∑, query ùëû( x) and tuple t, and ProvSQL computes Lin(ùëû [ x/ t], ùê∑) as a Boolean circuit, called ùê∂ in Figure <ref type="figure" target="#fig_8">3</ref>. We note here that for SPJU queries, ùê∂ can be computed in polynomial-time data complexity. We then set to 1 all the exogenous facts to obtain a Boolean circuit ùê∂ ‚Ä≤ for ELin(ùëû[ x/ t], ùê∑ x , ùê∑ n ). Then, ideally, we would like to use the knowledge compiler to transform ùê∂ ‚Ä≤ into an equivalent d-DNNF, in order to be able to apply Algorithm 1. Unfortunately, every knowledge compiler that we are aware of takes as input Boolean formulas in conjunctive normal form (CNF), and not arbitrary Boolean circuits. To circumvent it, we use the Tseytin transformation <ref type="bibr" target="#b34">[35]</ref> to transform the circuit ùê∂ ‚Ä≤ into a CNF ùúë def = Tseytin(ùê∂ ‚Ä≤ ), whose size is linear in that of ùê∂ ‚Ä≤ . This CNF ùúë has the following properties: (1) its variables are the variables of ùê∂ ‚Ä≤ plus a set ùëç of additional variables; (2) for every valuation ùúà ‚äÜ Vars(ùê∂ ‚Ä≤ ) that satisfies ùê∂ ‚Ä≤ , there exists exactly one valuation ùúà ‚Ä≤ ‚äÜ ùëç such that ùúë (ùúà ‚à™ ùúà ‚Ä≤ ) = 1; and (3) for every valuation ùúà ‚äÜ Vars(ùê∂ ‚Ä≤ ) that does not satisfy ùê∂ ‚Ä≤ , there is no valuation ùúà ‚Ä≤ ‚äÜ ùëç such that ùúë (ùúà ‚à™ ùúà ‚Ä≤ ) = 1. We then feed ùúë to the knowledge compiler, which produces a d-DNNF ùê∂ ‚Ä≤‚Ä≤ equivalent to ùúë (the variables of ùê∂ ‚Ä≤‚Ä≤ are again Vars(ùê∂ ‚Ä≤ ) ‚à™ ùëç ). We note here that there is no theoretical guarantee that this step is efficient; indeed, the task of transforming a CNF into an equivalent d-D circuit is FP #P -hard in general; see Section 6 for an experimental analysis of its tractability in practice. Next, we need to eliminate the additional variables ùëç in order to be able to apply Algorithm 1. To this end, we use the following Lemma. Lemma 4.6. Given as input a d-DNNF ùê∂ ‚Ä≤‚Ä≤ that is equivalent to Tseytin(ùê∂ ‚Ä≤ ) for a Boolean circuit ùê∂ ‚Ä≤ , we can compute in time ùëÇ (|ùê∂ ‚Ä≤‚Ä≤ |) a d-DNNF ùê∂ ‚Ä≤‚Ä≤‚Ä≤ that is equivalent to ùê∂ ‚Ä≤ (in particular, the variables of ùê∂ ‚Ä≤‚Ä≤‚Ä≤ are the same as the variables of ùê∂ ‚Ä≤ ; in our case, they consist only of endogenous facts).</p><p>Proof sketch. Let ùëç be the additional variables coming from the Tseytin transformation. First, we remove all the gates of ùê∂ ‚Ä≤‚Ä≤ that are not satisfiable, and then we remove all the gates that are not connected to the output gate. Now, let ùê∂ ‚Ä≤‚Ä≤‚Ä≤ be the circuit that is obtained from this intermediate circuit by replacing every literal ùëß or ¬¨ùëß for ùëß ‚àà ùëç by a constant 1-gate. We return ùê∂ ‚Ä≤‚Ä≤‚Ä≤ . The proof that this algorithm is correct uses the properties (1-3) of the Tseytin transformation, and is omitted due to lack of space. ‚ñ°</p><p>Using this lemma, we obtain a d-DNNF ùê∂ ‚Ä≤‚Ä≤‚Ä≤ for the endogenous lineage ELin(ùëû[ x/ t], ùê∑ x , ùê∑ n ), to which we can finally apply Algorithm 1 to obtain the value Shapley(ùëû[ x/ t], ùê∑ x , ùê∑ n , ùëì ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">INEXACT COMPUTATION</head><p>As we will show in the experimental section, the exact computation algorithm that we have proposed performs well in most cases but is too costly in others. In the latter cases, we may wish to resort to methods that do not necessarily compute exact Shapley values, if their results still typically suffice to determine the order of facts according to their Shapley contribution. In this section we propose CNF Proxy, a heuristic solution that is very efficient, and we will experimentally show that the ranking of facts based on CNF Proxy tends to match the ranking based on the exact Shapley values.</p><p>At a high level, CNF Proxy is based on the observation that having a high Shapley score is correlated (albeit in a complex manner) with (1) appearing many times in the provenance and (2) having few "alternatives," that is, facts that could compensate for the absence of the given fact. The first factor (number of occurrences) may be directly read from the CNF obtained by applying the Tseytin transformation to the provenance circuit (ùê∂ ‚Ä≤ in Figure <ref type="figure" target="#fig_8">3</ref>). It is also easy to read from the CNF partial information about the second factor (number of alternatives), namely the number of alternatives in each clause (ignoring intricate dependencies between clauses). Next, we present the details of CNF Proxy.</p><p>We will start with an auxiliary definition, denoting the Shapley value of a general function ‚Ñé : 2 ùëã ‚Üí R and a variable ùë• ‚àà ùëã as</p><formula xml:id="formula_20">Shapley(‚Ñé, ùë•) def = ‚àëÔ∏Å ùëÜ ‚äÜùëã \{ùë• } |ùëÜ |!(|ùëã | -|ùëÜ | -1)! |ùëã |! ‚Ñé(ùëÜ ‚à™ {ùë• }) -‚Ñé(ùëÜ) .</formula><p>Naturally, if ‚Ñé = ELin(ùëû, ùê∑ n , ùê∑ x ), i.e., the endogenous lineage, and ùë• is a fact in ùê∑ n , then Shapley(‚Ñé, ùë•) = Shapley(ùëû, ùê∑ n , ùê∑ x , ùë•). ùëõ ùúì ùëñ (ùúà). Intuitively, a fact that appears in many clauses of the CNF ùúë will occur in many summands of ùúë, and when we compute Shapley values with respect to ùúë, the number of alternatives in each clause will be reflected in decreased value of the respective summands.</p><p>Example 5.1. Consider the CNF formula ùúë = (ùë• 1 ‚à® ùë• 2 ) ‚àß (ùë• 1 ‚à® ùë• 3 ‚à® ùë• 4 ). The Shapley values of ùë• 1 , ùë• 2 , ùë• 3 , ùë• 4 are 7  12 , 3 12 , 1 12 , 1 12 respectively. Note that ùë• 1 has the highest influence, which intuitively may be attributed to its appearance in two clauses whereas each other variable appears only in a single clause. The variable ùë• 2 has more influence than ùë• 3 and ùë• 4 , intuitively since it has less alternatives. These comparative features are preserved in ùúë = (ùë• 1 ‚à® ùë• 2 ) + (ùë• 1 ‚à® ùë• 3 ‚à® ùë• 4 ), and indeed the Shapley values of ùë• 1 , ùë• 2 , ùë• 3 , ùë• 4 with respect to ùúë are 5  6 , 1 2 , 1 3 , 1 3 respectively. Observe that although the values assigned to the variables are very different from their actual Shapley values, their order remains intact in this case.</p><p>Due to the linearity of Shapley values, their computation with respect to ùúë is much more efficient, as implied by the following lemma (whose proof we omit for space reasons): Lemma 5.  </p><formula xml:id="formula_21">Œ¶(ùúì ùëñ , ùë•) = Ô£± Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£≤ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£¥ Ô£≥ 1 (ùëé ùëñ +ùëè ùëñ ) ‚Ä¢( ùëé ùëñ +ùëè ùëñ -1 ùëè ùëñ ) if ùë• appears in ùúì ùëñ in positive form; -1 (ùëé ùëñ +ùëè ùëñ ) ‚Ä¢( ùëé ùëñ +ùëè ùëñ -1 ùëé ùëñ</formula><p>)</p><p>if ùë• appears in ùúì ùëñ in negative form;</p><formula xml:id="formula_22">0 otherwise.</formula><p>Algorithm 2 then describes the operation of CNF Proxy, computing Shapley values of ùúë according to Lemma 5.2. The input to the algorithm is a CNF formula ùúë and the set of endogenous facts ùê∑ n . In Line 1, CNF Proxy counts the number ùëõ of clauses of ùúë, and in Line 2 it initializes the contribution of every variable of ùúë to zero. Then, it iterates over the clauses (Line 3). For each clause, it counts the number ùëö of literals, and identifies the set of positive and negative literals, ùëùùëúùë† and ùëõùëíùëî respectively (Lines 4-7). In Lines 9 and 12 we add (resp., subtract) quantities for each variable in a positive (resp., negative) literal according to Lemma 5.2 (note that ùëö corresponds to ùëé ùëñ + ùëè ùëñ as denoted in the lemma). Finally, in Line 15 the algorithm returns the contribution value of each fact ùë• ‚àà ùê∑ n based on Shapley( ùúë, ùë•). Observe that CNF Proxy runs in linear time in the size of ùúë (which itself, being the Tseytin transformation of the provenance circuit ùê∂ ‚Ä≤ from Figure <ref type="figure" target="#fig_8">3</ref>, is linear in ùê∂ ‚Ä≤ ).</p><p>Example 5.3. Recall the queries ùëû 1 , ùëû 2 , ùëû and their lineages depicted in Figure <ref type="figure" target="#fig_1">1</ref>. Using endogenous lineages, we have:</p><formula xml:id="formula_23">‚Ä¢ ELin(ùëû 1 , ùê∑ n , ùê∑ x ) = ùëé 1 ‚Ä¢ ELin(ùëû 2 , ùê∑ n , ùê∑ x ) = (ùëé 2 ‚àß ùëé 4 ) ‚à® (ùëé 2 ‚àß ùëé 5 ) ‚à® (ùëé 3 ‚àß ùëé 4 ) ‚à® (ùëé 3 ‚àß ùëé 5 ) ‚à® (ùëé 6 ‚àß ùëé 7 ) ‚Ä¢ ELin(ùëû, ùê∑ n , ùê∑ x ) =ùëé 1 ‚à® (ùëé 2 ‚àß ùëé 4 ) ‚à® (ùëé 2 ‚àß ùëé 5 ) ‚à® (ùëé 3 ‚àß ùëé 4 ) ‚à® (ùëé 3 ‚àß ùëé 5 ) ‚à® (ùëé 6 ‚àß ùëé 7 )</formula><p>The lineage of ùëû 1 is a CNF with a single variable, thus the contribution of ùëé 1 to ùëû 1 as computed by Algorithm 2 is 1, which is indeed equal to Shapley(ùëû 1 , ùê∑ n , ùê∑ x , ùëé 1 ). Applying the Tseytin transformation to the lineage of ùëû 2 introduces 6 new variables ({ùëß ùëñ } 6 ùëñ=1 ) and results in the following equisatisfiable CNF:</p><formula xml:id="formula_24">(ùëß 1 ) ‚àß (ùëß 1 ‚à® ùëß 2 ) ‚àß (ùëß 1 ‚à® ùëß 3 ) ‚àß (ùëß 1 ‚à® ùëß 4 ) ‚àß (ùëß 1 ‚à® ùëß 5 ) ‚àß (ùëß 1 ‚à® ùëß 6 ) ‚àß (ùëß 1 ‚à® ùëß 2 ‚à® ùëß 3 ‚à® ùëß 4 ‚à® ùëß 5 ‚à® ùëß 6 ) ‚àß (ùëß 2 ‚à® ùëé 2 ) ‚àß (ùëß 2 ‚à® ùëé 4 ) ‚àß (ùëß 2 ‚à® ùëé 2 ‚à® ùëé 4 ) ‚àß (ùëß 3 ‚à® ùëé 2 ) ‚àß (ùëß 3 ‚à® ùëé 5 ) ‚àß (ùëß 3 ‚à® ùëé 2 ‚à® ùëé 5 ) ‚àß (ùëß 4 ‚à® ùëé 3 ) ‚àß (ùëß 4 ‚à® ùëé 4 ) ‚àß (ùëß 4 ‚à® ùëé 3 ‚à® ùëé 4 ) ‚àß (ùëß 5 ‚à® ùëé 3 ) ‚àß (ùë• 5 ‚à® ùëé 5 ) ‚àß (ùëß 5 ‚à® ùëé 3 ‚à® ùëé 5 ) ‚àß (ùëß 6 ‚à® ùëé 6 ) ‚àß (ùëß 6 ‚à® ùëé 7 ) ‚àß (ùëß 6 ‚à® ùëé 6 ‚à® ùëé 7 )</formula><p>Algorithm 2 iterates over the above clauses, and computes the contribution of the endogenous facts ùê∑ n over the proxy function. Note that the facts ùê∑ n appear in clauses of two forms. The first form is ùëß ùëó ‚à® ùëé ùëñ ; appearance in this type of clause adds</p><formula xml:id="formula_25">1 22‚Ä¢2‚Ä¢( 1 1 ) = 1 44 to the contribution of ùëé ùëñ . The second form is ùëß ùëó ‚à® ùëé ùëñ ‚à® ùëé ‚Ñé , which adds -1 22‚Ä¢3‚Ä¢( 2 1 ) = -1</formula><p>132 . Note that each of ùëé 2 , ùëé 3 , ùëé 4 , ùëé 5 has two appearances in clauses of the first form, and one appearance in clauses of the second form. Thus, according to Algorithm 2 the contribution of ùëé 2 , ùëé 3 , ùëé 4 , ùëé 5 is 5 132 ‚âà 0.038. In contrast, ùëé 6 and ùëé 7 each have a single appearance in a clause of the first form and a single appearance in a clause of the second form, thus their contribution is 1 66 ‚âà 0.015. We note that the values calculated by Algorithm 2 are very different from the actual Shapley values, as</p><formula xml:id="formula_26">Shapley(ùëû 2 , ùê∑ n , ùê∑ x , ùëé ùëñ ) = 11 60 ‚âà 0.183 for ùëé ùëñ ‚àà {ùëé 2 , ùëé 3 , ùëé 4 , ùëé 5 } and Shapley(ùëû 2 , ùê∑ n , ùê∑ x , ùëé ùëñ ) = 2</formula><p>15 ‚âà 0.133 for ùëé ùëñ ‚àà {ùëé 6 , ùëé 7 }. However, the facts ùëé 2 , ùëé 3 , ùëé 4 , ùëé 5 , are correctly determined to be more influential than ùëé 6 and ùëé 7 .</p><p>Our experimental evaluation indicates that in most cases, the ordering of facts according to the values assigned to them by Algorithm 2 agrees with the order obtained by using the actual Shapley values. There is however no theoretical guarantee that this will always be the case, as shown by the following example.</p><p>Example 5.4. Applying the Tseytin transformation over the lineage of ùëû will result in a CNF similar to that obtained for ùëû 2 , with a new variable (ùëß 7 ) and the new clauses (ùëß 1 ‚à® ùëß 7 ) ‚àß (ùëß 7 ‚à® ùëé 1 ) ‚àß (ùëß 7 ‚à® ùëé 1 ). In addition, the disjunct ‚à®ùëß 7 will be added to the clause (ùëß 1 ‚à® ùëß 2 ‚à® ùëß 3 ‚à® ùëß 4 ‚à® ùëß 5 ‚à® ùëß 6 ). Similarly to the case of ùëû 2 , the contributions of ùëé 2 , ùëé 3 , ùëé 4 , and ùëé 5 are correctly determined to be larger than those of ùëé 6 and ùëé 7 . As for ùëé 1 , its contribution according to Algorithm 2 is 0 while in fact it is the most influential fact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS</head><p>Our system is implemented in Python 3.6 and using the PostgreSQL 11.10 database engine, and the experiments were performed on a Linux Debian 14.04 machine with 1TB of RAM and an Intel(R) Xeon(R) Gold 6252 CPU @ 2.10GHz processor. ProvSQL <ref type="bibr" target="#b30">[31]</ref> was used to capture the provenance. For knowledge compilation we have used the c2d compiler <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. The source code of our implementation is available in <ref type="bibr" target="#b12">[13]</ref>.</p><p>Since no standard benchmark for our problem exists, we have created such a benchmark of 40 queries over the TPC-H (1.4GB) and IMDB (1.2GB) databases.The TPC-H queries are based on the ones in <ref type="bibr" target="#b33">[34]</ref>, where we have only removed nested queries (which ProvSQL does not handle) and aggregation operations (for which provenance is not Boolean). The queries for the IMDB database are based on the join queries in <ref type="bibr" target="#b18">[19]</ref>, where for each query we have added a (last) projection operation over one of the join attributes to make provenance more complex and thus more challenging for our algorithms. The resulting queries are quite complex: in particular, only 4 out of the 40 are hierarchical. See <ref type="bibr" target="#b12">[13]</ref> for details of the obtained queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Exact computation</head><p>We have evaluated our solution for exact Shapley computation, presented in Section 4.2, on each of the 40 queries. In total, we have obtained 95,803 output tuples along with their provenance expressions (computed with ProvSQL). We have then transformed each provenance expression into a d-DNNF structure using the c2d <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref> knowledge compiler. In this experiment, for both the knowledge compilation (KC) and Shapley evaluation steps we have set a timeout of one hour (in fact, as we show below, a much shorter timeout of 2.5 seconds typically suffices). In case the compilation completed successfully within this timeframe, we have computed the Shapley values using Algorithm 1. Table <ref type="table" target="#tab_5">1</ref> presents the execution times of our solution for 16 representative queries; next we will overview different aspects of the results.</p><p>Success rate. We report here the rate of successful executions. The IMDB queries resulted in 95,636 output tuples; the KC step completed successfully for 95,599 out of them, where all 37 failures were the result of insufficient memory. For each of the IMDB output tuples that were successfully compiled into a d-DNNF, we have executed Algorithm 1; only a single execution failed in this step (due to a timeout of one hour). Overall, the exact computation of Shapley values was successful for 95,598 out of the 95,636 IMDB output tuples (i.e., 99.96% success rate). The TPC-H queries resulted in 167 output tuples; the KC step has completed successfully for 141 out of them, again all 26 failures were the result of insufficient memory. For all TPC-H outputs that compiled successfully Algorithm 1 was successful, yielding an overall 84.43% success rate.</p><p>Execution time. For each of the 40 queries, we have measured the execution time of each step of the computation. First, we have measured (in the column "Execution time") the execution time in PostgreSQL, which includes provenance generation for every output tuple using ProvSQL. Then, for each tuple t in the output of the query, we have measured the KC execution time and the execution time of Algorithm 1 to compute the contribution of all input facts with respect to the output tuple t. For the latter two algorithms, the execution times varied significantly for the different output tuples, and thus we report the execution times for different percentiles (mean, p25, p50, p75 and p99). Observe that the computation is typically efficient; outliers include q11d for which the execution time of Algorithm 1 was over 96 seconds in average.     In contrast, Figure <ref type="figure" target="#fig_15">5b</ref> depicts 4 query outputs for which the exact computation failed to complete over the full TPC-H database. We observe that the algorithm does succeed in these cases if we execute the queries over subsets of the input database, though its execution time may still be high: e.g., if we take a "slice" of the lineitem table consisting of 480,097 facts, then computation of the contribution of all input facts w.r.t. "Q9 ALGERIA" takes 556sec.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Inexact computation</head><p>As observed above, computing exact Shapley values using our solution for a given output tuple is typically fast, but may be costly or even fail in some cases. In this section we evaluate inexact computation alternatives.</p><p>Algorithms. We compare three algorithms: CNF Proxy (Section 5) and two existing baselines: Monte Carlo, and Kernel SHAP.</p><p>Monte Carlo. This is a well-known sampling algorithm <ref type="bibr" target="#b22">[23]</ref> for approximating Shapley values in general. To employ the Monte Carlo algorithm in our setting, we feed it a provenance expression ‚Ñé containing ùëõ distinct input facts, and a budget of ùëü ‚Ä¢ ùëõ samples, for some ùëü ‚àà Z + . The Shapley value of each fact ùëì is approximated by sampling ùëü permutations (ùúã 1 , . . . , ùúã ùëü ) of the input facts, and then outputting 1  ùëü ‚Ä¢ ùëü ùëñ=1 ‚Ñé(ùëÜ ùúã ùëñ ,&lt;ùëì ‚à™ {ùëì })‚Ñé(ùëÜ ùúã ùëñ ,&lt;ùëì ) , where ùëÜ ùúã ùëñ ,&lt;ùëì is the coalition of all facts preceding ùëì in the permutation ùúã ùëñ .</p><p>Kernel SHAP. Lundberg and Lee <ref type="bibr" target="#b21">[22]</ref> have defined the notion of SHAP values in the context of ML explainability. Given a function ‚Ñé : R ùëë ‚Üí R (the model whose decisions we want to explain), a probability distribution D on R ùëë (the inputs), and an input vector ƒì ‚àà R ùëë , SHAP values were defined to measure the contribution of ƒì's features to the outcome ‚Ñé( ƒì). To overcome the issue that ‚Ñé does not operate over subsets of features, the notion of SHAP-score has been defined as follows</p><formula xml:id="formula_27">SHAP(‚Ñé, ƒì, ùë•) def = ‚àëÔ∏Å ùëÜ ‚äÜùëã \{ùë• } |ùëÜ |!(|ùëã | -|ùëÜ | -1)! |ùëã |! (‚Ñé ƒì (ùëÜ ‚à™{ùë• })-‚Ñé ƒì (ùëÜ)),</formula><p>where ùëã is the set of ùëë features, ùë• is a specific feature whose contribution we wish to assess, and ‚Ñé ƒì : 2 ùëã ‚Üí R is defined by</p><formula xml:id="formula_28">‚Ñé ƒì (ùëÜ) def = E z‚àºD [‚Ñé( z) | ƒìùëÜ = zùëÜ ],</formula><p>where ƒìùëÜ and zùëÜ denote the vectors ƒì and z restricted to the features in ùëÜ.</p><p>In <ref type="bibr" target="#b21">[22]</ref> the authors have proposed a method for approximating SHAP values, called Kernel SHAP. Kernel SHAP assumes feature independence and estimates the probability by multiplying the marginal distributions ùëñ‚àâùëÜ Pr(ùëß ùëñ ). The marginal probabilities Pr(ùëß ùëñ ) in turn are estimated from a background data ùëá . To approximate SHAP values, Kernel SHAP then samples ùëö coalitions ùëÜ 1 , . . . , ùëÜ ùëö of features, and trains a linear model ùëî : 2 ùëã ‚Üí R by minimizing the weighted loss ùëö ùëñ=1 ùë§ ùëñ ‚Ä¢ (ùëî(ùëÜ ùëñ ) -ƒ• ƒì (ùëÜ ùëñ )) 2 , where ùë§ ùëñ is proportional to the size of ùëÜ ùëñ and ƒ• ƒì is the estimation of ‚Ñé ƒì using the feature independence assumption. The coefficient associated with a feature ùë• in the trained model ùëî is the approximated SHAP value of ùë•.</p><p>We adapt Kernel SHAP to our setting and use it to approximate the Shapley values of facts, as follows. The features are the input facts of the database, we set ‚Ñé to be the Boolean function representing the (endogenous) provenance; the vector of interest, ƒì, has the value 1 for all facts, and the background data ùëá contains a single example with value 0 in all its entries. Note that for such ƒì and ùëá , Kernel SHAP estimates ‚Ñé ƒì (ùëÜ) as the result of applying ‚Ñé to a vector with ones in ùëÜ features and zeros in the remaining entries.</p><p>The input of both Monte Carlo and Kernel SHAP includes a budget of ùëö samples; for provenance expressions containing ùëõ distinct facts we have experimented with ùëö ‚àà {10ùëõ, 20ùëõ, 30ùëõ, 40ùëõ, 50ùëõ}.</p><p>Accuracy metrics To evaluate the performance of the above methods we have used various metrics, specified below. All metrics were computed with respect to the ground truth values obtained by the knowledge compilation approach, and thus these experiments are confined to the cases where the exact computation succeeded.</p><p>‚Ä¢ nDCG is the normalized discounted cumulative gain score <ref type="bibr" target="#b37">[38]</ref>, used to compare the ordering based on the inexact solution to the ordering based on the ground truth. ‚Ä¢ Precision@k is the number of facts that appears in the top-ùëò of both the inexact and exact solutions, divided by ùëò. This was evaluated for ùëò ‚àà {1, 3, 5, 10}. ‚Ä¢ L1 and L2 are the mean absolute error and squared error, respectively, of the results of an inexact computation method    with respect to the ground truth (i.e. how different the results are from the actual Shapley values).</p><p>Execution time. Figure <ref type="figure" target="#fig_17">6a</ref> depicts the execution time of the above methods as a function of the sampling budget. The execution times of Monte Carlo and Kernel SHAP are rather similar, while the CNF Proxy method (which does not rely on sampling) is substantially faster, with a median of 0.72 milliseconds and a mean of 2.06 milliseconds for a single query output. Figures <ref type="figure" target="#fig_19">7a</ref> and<ref type="figure" target="#fig_19">7b</ref> depict the distribution and worst-case running times of the three methods (for Monte Carlo and Kernel SHAP we used a budget of 20 samples per fact) as function of the number of distinct facts in the provenance expressions. CNF Proxy is substantially faster than its competitors: in most cases CNF Proxy completes in few milliseconds and 4 seconds in the worst case, whereas Monte Carlo and Kernel SHAP median execution time for circuits with 101-200 distinct input facts are 59 and 62 seconds respectively and may take up to 1,539 seconds.</p><p>Recall our analysis of the execution time of the exact solution in Section 6.1. The computation of Shapley values (KC plus Algorithm 1) takes 27,600 seconds if performed for all output tuples of query q8d in the IMDB dataset; for comparison, the CNF Proxy method has (inexactly, see quality analysis below) computed the Shapley value of the proxy functions for all query outputs within 95 seconds, which is 0.3% of the exact computation time. Surprisingly, the execution time of the exact computation was comparable to Monte Carlo and Kernel SHAP, and even faster for large sampling budgets; For example, Kernel SHAP with ùëö = 10ùëõ (where ùëõ is the number of distinct facts in the provenance) has completed computation for all output tuples of the query q8d in 16,447 seconds, which is 59% of the exact computation time. For ùëö = 50ùëõ, Kernel SHAP required 58,161 seconds for completion of this computation, which is 210% of the exact computation time. This means that using such a sampling budget for Kernel SHAP is impractical in this setting, and we will use it to obtain upper bounds on Kernel SHAP's quality. Quality analysis. Figures <ref type="figure" target="#fig_17">6b</ref> and<ref type="figure" target="#fig_17">6c</ref> depict the ranking quality of the above methods as a function of the sampling budget. The rankings were compared for output tuples where the exact computation succeeded, so we have the ground truth. Recall that CNF Proxy does not rely on sampling, and so it remains constant throughout the different budgets. Naturally, as the sampling budget grows, Monte Carlo and Kernel SHAP quality improves. Most notable is Monte Carlo improvement in terms of nDCG (Figure <ref type="figure" target="#fig_17">6b</ref>), where its median (resp., mean) nDCG with budget of 10 samples per fact is 0.9669 (resp., 0.9435), while with budget of 50 samples per fact it is 1.0 (resp., 0.9923). Comparison between the two sampling methods (Monte Carlo and Kernel SHAP) reveals that Kernel SHAP is superior w.r.t all metrics, across the entire budgets range. In terms of nDCG, all methods achieve rather high scores, but CNF Proxy performs best. Indeed, the median (resp., mean) nDCG of CNF Proxy is 1.0 (resp., 0.9989), while Kernel SHAP requires 50 samples per fact to get a median (resp., mean) nDCG of 1.0 (resp., 0.9986); as previously noted such budget leads to slower execution than that of the exact computation. It is worth mentioning that also when looking at nDCG@k for ùëò ‚àà {1, 3, 5, 10}, CNF Proxy performs better than Monte Carlo and Kernel SHAP, even when allowing a budget of 50 samples per fact. In terms of identifying the top influential facts (i.e., Precision@k), CNF Proxy also outperforms the other methods. For example, CNF Proxy's median (resp., mean) Precision@10 are 1.0 (resp., 0.9688), while Kernel SHAP reaches 1.0 (resp., 0.9611) with 50 samples per fact. Similarly, CNF Proxy outperforms Monte Carlo and Kernel SHAP in terms of Precision@k for ùëò ‚àà {1, 3, 5}.</p><p>Finally, Table <ref type="table" target="#tab_8">2</ref> zooms in on the results when fixing the budgets of Monte Carlo and Kernel SHAP to 50 samples per fact, which is the highest budget tested (already for this budget, computation of Monte Carlo and Kernel SHAP is slower than for the exact algorithm). Note that CNF Proxy is much faster then the other methods, while still being superior in terms of ranking (nDCG and Precision@k). As explained above, ranking of facts is indeed the use case we recommend for CNF Proxy. Unsurprisingly, Kernel SHAP achieves better distance from the exact Shapley values (L1 and L2), at the cost of being slower by several orders of magnitude.</p><p>Dependency on the provenance size. Figure <ref type="figure" target="#fig_19">7</ref> depicts the performance of Monte Carlo, Kernel SHAP, and CNF Proxy as a function of the number of facts in the provenance expression. The results are aggregated over all output tuples of all queries. Figure <ref type="figure" target="#fig_19">7c</ref> presents the quality of facts ranking (nDCG) as a function of the number of distinct provenance facts. CNF Proxy performs the best, and its quality remains steady regardless of the number of facts in the provenance expression. For example, with 1-10 facts the CNF Proxy median (resp., mean) nDCG is 1.0 (resp., 0.9999), and with 201-400 facts it is 0.9977 (resp., 0.9924). Kernel SHAP has a minor deterioration, where it drops from median (resp., mean) nDCG of 1.0 (resp., 0.9998) with 1-10 facts to 0.9906 (resp., 0.9888) with 201-400 facts. Figure <ref type="figure" target="#fig_19">7d</ref> zooms in on the aggregated results over the worst case expressions of all output tuples for all queries, and shows that even the worst case CNF Proxy is superior to the alternatives, and that the error in terms of nDCG is small (0.92 in the worst case evaluated). Figure <ref type="figure" target="#fig_19">7e</ref> depicts the dependency of Precision@10 on the number of provenance facts. Both Monte Carlo and Kernel SHAP suffer from a massive drop of median (resp., mean) Precision@10, down to 0.4 (resp., 0.476) and 0.6 (resp., 0.6253) respectively with 201-400 facts, while CNF Proxy remains at 0.8 (resp., 0.8293) median and mean Precision@10. A similar trend is observed for Precision@5, whereas for Precision@3 and Precision@1 the drop is less significant. Here again, Figure <ref type="figure" target="#fig_19">7f</ref> zooms in on the worst case and again shows the superiority of CNF Proxy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Hybrid computation</head><p>Recall that in Section 6.1 we have measured the success rate of the exact computation: for IMDB the success rate was 99.96% and for TPC-H the success rate was 84.43%. We saw in Section 6.2 that the inexact method CNF Proxy is very efficient and that the ranking of tuples based on CNF Proxy is typically close to the ranking obtained based on the real Shapley values.</p><p>In this section we consider a hybrid approach that works as follows. First, we start by running the exact computation, that is, the knowledge compilation step and Algorithm 1. If the exact computation completes successfully within less than ùë° seconds (where ùë° is configurable) we return its result. Otherwise, we terminate the exact computation and execute the inexact method CNF Proxy, returning only a ranking of input tuples rather than their Shapley values. Figure <ref type="figure" target="#fig_21">8a</ref> depicts the success rate of the exact computation given different timeouts. Note that given a timeout of 2.5 seconds, the exact computation succeed for 98.67% of the IMDB output tuples, and 83.83% for TPCH-H. Increasing the timeout has a rather minor impact on the success rate: having a 15 seconds timeout increases the success rate for IMDB to 99.52%, while the success rate for TPC-H remains unchanged. Recall that having a timeout of one hour results in success rates of 99.96% and 84.43% for IMDB and  TPC-H respectively. Figure <ref type="figure" target="#fig_21">8b</ref> depicts the mean execution time of the hybrid approach as a function of the chosen timeout ùë°. Observe that given a timeout of 2.5 seconds the mean hybrid execution time is 0.31 seconds and 0.67 seconds for IMDB and TPC-H respectively. The mean execution time of the hybrid approach grows very moderately w.r.t. the timeout for IMDB (since most cases do not reach the timeout); it grows faster for TPC-H, where the difficult cases for which timeout is reached have a more significant effect on the overall mean execution time.</p><p>Main conclusions. Our experimental results indicate that for most output tuples (98.67% for IMDB and 83.83% for TPC-H) exact computation of Shapley values terminates within 2.5 seconds. When it does not, we propose an alternative of ranking facts according to CNF Proxy values, which typically only takes several milliseconds (up to 4 seconds for an outlier case). Experimental evidence shows that the ranking obtained via CNF Proxy is both much faster to compute and more accurate (in terms of nDCG and Precision@k, measured in cases where exact computation does succeed, and so we have the ground truth) than the alternative of only using sampling to approximate the actual Shapley values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>We have proposed in this paper a first practical framework for computing the contributions of database facts in query answering, quantified through Shapley values. The framework includes an exact algorithm that computes the contribution of input facts, and a faster algorithm that is practically effective in ranking contributions of input facts, while producing inexact Shapley values. Our practical implementation is currently designed for SPJU queries (that is, to the class of queries supported by ProvSQL). In addition to these practical contributions, we have also established a theoretical connection between the problem of computing Shapley values and that of probabilistic query evaluation, by showing that, for every query, the former can be reduced in polynomial time to the latter.</p><p>We leave it open to determine whether there is also a reduction in the other direction (Open Problem 1). Other interesting directions would be to study further constructs such as aggregates and negation, or to extend the framework to bag semantics. Concerning bag semantics we observe that, by differentiating each copy of a same tuple in a bag database (for instance, adding an identifier attribute), our framework can be used as-is. Nevertheless, it would be interesting to see how one could adapt the definitions in order to consider fact multiplicities in a more elaborate way.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Proposition 3 . 1 .</head><label>31</label><figDesc>For every Boolean query ùëû, we have that Shapley(ùëû) ‚â§ p T PQE(ùëû).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1 .</head><label>1</label><figDesc>Proof of Proposition 3.1. For a Boolean query ùëû, database ùê∑ = ùê∑ x ‚à™ ùê∑ n , and integer ùëò ‚àà {0, . . . , |ùê∑ n |}, define #Slices(ùëû, ùê∑ x , ùê∑ n , ùëò) def = |{ùê∏ ‚äÜ ùê∑ n | |ùê∏| = ùëò and ùëû(ùê∑ x ‚à™ ùê∏) = 1}|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Deterministic and decomposable circuit for ELin(ùëû, ùê∑ x , ùê∑ n ) from the running example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Proposition 4 . 4 .</head><label>44</label><figDesc>Given as input a deterministic and decomposable circuit ùê∂ representing ELin(ùëû, ùê∑ n , ùê∑ x ) for a database ùê∑ = ùê∑ x ‚à™ ùê∑ n and Boolean query ùëû, and an endogenous fact ùëì ‚àà ùê∑ n , we can compute in polynomial time (in |ùê∂ |) the value Shapley(ùëû, ùê∑ n , ùê∑ x , ùëì ).Next, we prove Proposition 4.4 and present the algorithm, and then explain in Section 4.2 the architecture of the implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Lemma 4 . 5 .</head><label>45</label><figDesc>Given as input a deterministic and decomposable Boolean circuit ùê∂ and an integer ùëò ‚àà {0, . . . , |Vars(ùê∂)|}, we can compute in polynomial time the quantity #SAT ùëò (ùê∂). Proof. Our proof is similar to that of [3, Section 3.2]. Let ùëã def = Vars(ùê∂) and ùëõ def = |ùëã |.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>We now explain how to compute the first term, that is, |(SAT(ùúë ùëî 1 ) ‚äó 2 ùëÜ 1 ) ‚à© {ùúà ‚äÜ Vars(ùëî) | |ùúà | = ‚Ñì }|; the second term is similar. This is equal3 to min(‚Ñì, |Vars(ùëî 1 ) |)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>4. ‚ñ° Algorithm. Algorithm 1 depicts the solution underlying Proposition 4.4. The subroutine ComputeAll#SAT ùëò takes as input a d-D circuit ùê∂ and outputs all the values #SAT 0 (ùê∂), . . . , #SAT |Vars(ùê∂) | (ùê∂).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 2 : 4 L 5 ùëö ‚Üê |L|; 6 ùëùùëúùë† 7 ùëõùëíùëî 8 for ‚Ñì ‚àà ùëùùëúùë† ‚à© ùê∑ n do 9 ùë£</head><label>2456789</label><figDesc>CNF ProxyInput : CNF ùúë and a set of endogenous facts ùê∑ n . Output : The value Shapley( ùúë, ùë•) for each ùë• ‚àà ùê∑ n .1 ùëõ ‚Üê |ùúë.ùëêùëôùëéùë¢ùë†ùëíùë† ()|; 2 ùë£ ‚Üê 0 |ùê∑ n | ;// As an array3 for ùúì ‚àà ùúë.ùëêùëôùëéùë¢ùë†ùëíùë† () do ‚Üê ùúì .ùëôùëñùë°ùëíùëüùëéùëôùë† (); ‚Üê {‚Ñì ‚àà L | ‚Ñì is positive}; ‚Üê {‚Ñì ‚àà L | ‚Ñì is negative}; [‚Ñì.ùë£ùëéùëü ()] ‚Üê ùë£ [‚Ñì.ùë£ùëéùëü (ùëõùëíùëî ‚à© ùê∑ n do 12 ùë£ [‚Ñì.ùë£ùëéùëü ()] ‚Üê ùë£ [‚Ñì.ùë£ùëéùëü ()] -Now, note that for a CNF formula ùúë = ùëõ ùëñ=1 ùúì ùëñ (where each ùúì ùëñ is a disjunction of literals) and an assignment ùúà it holds that ùúë (ùúà) = ùëõ ùëñ=1 ùúì ùëñ (ùúà). Instead of calculating the Shapley values of a CNF formula ùúë (which may be a hard problem), CNF Proxy computes Shapley values with respect to a proxy function, denoted ùúë. The proxy function of ùúë is defined as the sum (instead of the product) of the clauses of ùúë, i.e., ùúë (ùúà)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Our implementation architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 4</head><label>4</label><figDesc>depicts the running time of the KC step and of the computation of Shapley values from the d-DNNF as a function of different features of the provenance, such as the number of facts appearing in the provenance, the number of clauses in its CNF representation, and the number of gates in its d-DNNF representation. Scalability. To evaluate the scalability of Algorithm 1 we have further looked at different scales of the TPC-H database.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>5</head><label>5</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Running times of knowledge compilation and computation of Shapley values from the d-DNNF as function of the number of distinct facts, CNF clauses, and d-DNNF size</figDesc><graphic coords="11,322.76,255.02,115.31,72.85" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 5a depicts 4</head><label>4</label><figDesc>representative query outputs, for which the running time takes a few milliseconds, e.g., for "Q3 23426" (result 23426 of query ùëÑ3) and the full TPC-H dataset, the computation of Shapley values for all relevant input facts complete in 4.3ms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>(a) Representative outputs (b) "Difficult" outputs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Alg. 1 running time for various TPC-H query outputs as function of table lineitem size</figDesc><graphic coords="11,321.64,570.18,115.32,89.35" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Comparing various metrics for inexact methods as a function of the sampling budget; CNF Proxy does not rely on sampling, thus remains constant for all budgets.</figDesc><graphic coords="13,55.08,200.28,117.72,64.49" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>(a) Running time distribution (b) Worst case running time (c) nDCG Distribution (d) Worst case nDCG (e) Precision@10 distribution (f) Worst case Precision@10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Comparing inexact methods as a function the number of distinct facts in the provenance (ùëõ). Sampling methods (Kernel SHAP and Monte Carlo) presented with sampling budget of ùëö = 20ùëõ; different budgets led to similar trends.</figDesc><graphic coords="13,55.08,358.63,117.72,64.99" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>(a) Exact computation success rate as function of the computation timeout (b) Mean execution time of the hybrid approach as a function of the computation timeout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Hybrid approach performance</figDesc><graphic coords="14,440.64,83.69,115.32,98.42" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>3 , ùëé 6 , ùëé 8 }, {ùëé 2 , ùëé 3 , ùëé 7 , ùëé 8 }, {ùëé 4 , ùëé 5 , ùëé 6 , ùëé 8 }, and {ùëé 4 , ùëé 5 , ùëé 7 , ùëé 8 }, and overall 14 triplets (left to the reader). Summing it all up results in</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>ùê∑ n , ùê∑ x , ùëé ùëñ ) = 23 210 ‚âà 0.1095, and that for ùëé ùëñ ‚àà {ùëé 6 , ùëé 7 } we have Shapley(ùëû, ùê∑ n , ùê∑ x , ùëé ùëñ ) = 8 105 ‚âà 0.0762.</figDesc><table><row><cell></cell><cell></cell><cell>‚âà 0.4095.</cell></row><row><cell></cell><cell></cell><cell>105</cell></row><row><cell cols="3">Similarly one can compute the Shapley value of the remaining facts,</cell></row><row><cell>and find that for ùëé ùëñ</cell><cell>‚àà</cell><cell>{ùëé 2 , ùëé 3 , ùëé 4 , ùëé 5 } it holds that</cell></row><row><cell>Shapley(ùëû,</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>#P -hard). It turns out that the tractability criterion that</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>ùëé 6</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>LAX</cell><cell cols="2">MUC</cell><cell></cell></row><row><cell cols="2">Flights (endo)</cell><cell></cell><cell cols="2">Airports (exo)</cell><cell></cell><cell></cell><cell></cell><cell>ùëé</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>7</cell></row><row><cell>Src</cell><cell>Dest</cell><cell></cell><cell cols="2">Name Country</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ùëé 1 ùëé 2 EWR JFK</cell><cell>CDG LHR</cell><cell cols="2">ùëè 1 ùëè 2 EWR JFK</cell><cell>USA USA</cell><cell>BOS</cell><cell>3 ùëé</cell><cell>ùëé 8</cell><cell>ùëé 5</cell><cell>ORY</cell></row><row><cell>ùëé 3 BOS</cell><cell>LHR</cell><cell>ùëè 3</cell><cell>BOS</cell><cell>USA</cell><cell></cell><cell cols="2">LHR</cell><cell></cell></row><row><cell>ùëé 4 LHR</cell><cell>CDG</cell><cell>ùëè 4</cell><cell>LAX</cell><cell>USA</cell><cell></cell><cell>ùëé 2</cell><cell></cell><cell></cell></row><row><cell>ùëé 5 LHR</cell><cell>ORY</cell><cell>ùëè 5</cell><cell>LHR</cell><cell>EN</cell><cell>EWR</cell><cell></cell><cell></cell><cell>ùëé 4</cell></row><row><cell>ùëé 6 LAX</cell><cell>MUC</cell><cell cols="2">ùëè 6 MUC</cell><cell>GR</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>ùëé 7 MUC</cell><cell>ORY</cell><cell>ùëè 7</cell><cell>ORY</cell><cell>FR</cell><cell></cell><cell>ùëé 1</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>JFK</cell><cell></cell><cell></cell><cell></cell><cell>CDG</cell></row><row><cell>ùëé 8 LHR</cell><cell>MUC</cell><cell>ùëè 8</cell><cell>CDG</cell><cell>FR</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">(b) Flights in graph view. Dark</cell></row><row><cell cols="4">(a) Database of flights and airports</cell><cell></cell><cell cols="5">and light gray depict "USA"</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">and "FR" airports respectively</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>For a gate ùëî of ùê∂, we denote by Vars(ùëî) the set of variables that have a directed path to ùëî. An ‚àß-gate ùëî of ùê∂ is decomposable if for every two input gates ùëî 1 ‚â† ùëî 2 of ùëî we have Vars(ùëî 1 ) ‚à© Vars(ùëî 2 ) = ‚àÖ. We call ùê∂ decomposable if all ‚àß-gates are. An ‚à®-gate ùëî of ùê∂ is deterministic if the Boolean functions captured by each pair of distinct input gates of ùëî are pairwise disjoint; i.e., no assignment satisfies both. We call ùê∂ deterministic if all ‚à®-gates in it are. A deterministic and decomposable (d-D [26]) Boolean circuit is a Boolean circuit that is both deterministic and decomposable. If ùê∂ is a Boolean circuit we write Vars(ùê∂) to denote the set of variables that appear in it. Example 4.3. Recall ELin(ùëû, ùê∑ n , ùê∑ x ) from Example (4.2) represented as a DNF. Figure 2 depicts a d-D circuit for ELin(ùëû, ùê∑ n , ùê∑ x ).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>=</head><label></label><figDesc>ùúà 2 ‚àà ùëÜ 2 }. We next show how to compute the values ùõº ‚Ñì ùëî by bottom-up induction on ùê∂. Variable gate. If ùëî is a variable gate corresponding to some variable ùë¶, then Vars(ùëî) = {ùë¶}. Then, ùõº 0 ùëî is 0 and ùõº 1 ùëî is 1. ¬¨-gate. If ùëî is a ¬¨-gate with input gate ùëî ‚Ä≤ , then ùõº ‚Ñì ùëî = Deterministic ‚à®-gate. If ùëî is a deterministic ‚à®-gate with no input then ùúë ùëî is the Boolean function on variables Vars(ùëî) = ‚àÖ that is always false, hence ùõº 0 ùëî = 0. Otherwise ùëî has exactly two input gates; let us denote them ùëî 1 and ùëî 2 . Observe that Vars(ùëî) = Vars(ùëî 1 ) ‚à™ Vars(ùëî 2 ) by definition. De-Vars(ùëî 2 ) \Vars(ùëî 1 ) and similarly ùëÜ 2 def = Vars(ùëî 1 ) \ Vars(ùëî 2 ). Since ùëî is deterministic, we have:</figDesc><table><row><cell></cell><cell>|Vars(ùëî) | ùëô</cell><cell>-</cell></row><row><cell>ùõº ‚Ñì</cell><cell></cell></row><row><cell>ùëî fine ùëÜ 1</cell><cell>def</cell></row></table><note><p>‚Ä≤ for every ‚Ñì ‚àà {0, . . . , |Vars(ùëî)|}.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Algorithm 1 :</head><label>1</label><figDesc>Shapley values from deterministic and decomposable Boolean circuits Input : Deterministic and decomposable Boolean circuit ùê∂ with output gate ùëî output representing ELin(ùëû, ùê∑ x , ùê∑ n ) and an endogenous fact ùëì ‚àà ùê∑ n . Output : The value Shapley(ùëû, ùê∑ x , ùê∑ n , ùëì ). Complete ùê∂ so that Vars(ùëî output ) = ùê∑ n ; 2 Compute ùê∂ 1 = ùê∂ [ùëì ‚Üí 1] and ùê∂ 2 = ùê∂ [ùëì ‚Üí 0]; // Partial evaluations of ùê∂ by setting ùëì to 1 and to 0 ‚àà {0, . . . , |Vars(ùëî)|} by bottom-up induction on ùê∂ using the inductive relations from the proof of Lemma 4.5;</figDesc><table><row><cell cols="4">3 Œì = ComputeAll#SAT ùëò (ùê∂ 1 );</cell><cell>// As an array</cell></row><row><cell cols="4">4 Œî = ComputeAll#SAT ùëò (ùê∂ 2 );</cell><cell>// As an array</cell></row><row><cell></cell><cell></cell><cell>|ùê∑ n |-1</cell><cell></cell></row><row><cell cols="2">5 return</cell><cell>‚àëÔ∏Å</cell><cell></cell></row><row><cell>10</cell><cell cols="2">return [ùõº 0 ùëî output , . . . , ùõº</cell><cell>|Vars(ùê∂) | ùëî output</cell><cell>];</cell></row></table><note><p><p><p>1 ùëò=0 ùëò! (|ùê∑ n | -ùëò -1)! |ùê∑ n |! ‚Ä¢ (Œì [ùëò] -Œî[ùëò]); 6 Def ComputeAll#SAT ùëò (C):</p>7</p>Preprocess ùê∂ so that each ‚à®-gate and ‚àß-gate has fan-in exactly 0 or 2; 8 Compute the set Vars(ùëî) for every gate ùëî in ùê∂; 9 Compute values ùõº ‚Ñì ùëî for every gate ùëî in ùê∂ and ‚Ñì</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>2. Let ‚Ñé = ùëõ ùëñ=1 1 ùëõ ùúì ùëñ , where each ùúì ùëñ is a Boolean function representing a disjunction of literals. Without loss of generality let us assume that for each ùúì ùëñ there is no variable that appears in more than one literal of ùúì ùëñ . Denote by ùëé ùëñ and ùëè ùëñ the number of positive and negative literals in ùúì ùëñ respectively. Then, for every variable ùë•, it holds Shapley(ùëû[ x/t], ùê∑ x , ùê∑ n , ùëì ) The Shapley value Algorithm 1 d-DNNF ùê∂ ‚Ä≤‚Ä≤‚Ä≤ for ELin(ùëû[ x/t], ùê∑ x , ùê∑ n )</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">Lemma 4.6</cell><cell cols="2">d-DNNF ùê∂ ‚Ä≤‚Ä≤ (w/ extra vars)</cell></row><row><cell></cell><cell></cell><cell>(w/o extra vars)</cell><cell></cell><cell></cell><cell cols="2">equivalent to ùúë</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Knowledge</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>compiler</cell></row><row><cell>Database ùê∑ = ùê∑ x ‚à™ ùê∑ n</cell><cell></cell><cell>Partial eval: set</cell><cell></cell><cell></cell><cell>Tseytin</cell></row><row><cell>Query ùëû( x) Fact ùëì ‚àà ùê∑ n Answer t ProvSQL</cell><cell>for Lin(ùëû[ x/t], ùê∑) Boolean circuit ùê∂</cell><cell>exo vars to 1</cell><cell cols="2">ELin(ùëû[ x/t], ùê∑ x , ùê∑ n ) Bool. circuit ùê∂ ‚Ä≤ for</cell><cell>transform</cell><cell>CNF formula ùúë (w/ extra vars) Proxy</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>formula</cell></row><row><cell>Input</cell><cell></cell><cell cols="2">The value Shapley( ùúë, ùëì )</cell><cell cols="2">Algorithm 2</cell><cell>ùúë (w/ extra vars)</cell></row><row><cell></cell><cell></cell><cell cols="2">(heuristics)</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 1 :</head><label>1</label><figDesc>Statistics on the exact computation of Shapley values for 16 representative queries</figDesc><table><row><cell></cell><cell></cell><cell>#Joined</cell><cell>#Filter</cell><cell>Execution</cell><cell>#Output</cell><cell>Success</cell><cell cols="4">KC execution times [sec]</cell><cell></cell><cell></cell><cell cols="3">Alg. 1 execution times [sec]</cell></row><row><cell cols="2">Dataset Query</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>tables</cell><cell>conditions</cell><cell>time [sec]</cell><cell>tuples</cell><cell>rate</cell><cell cols="4">Mean p25 p50 p75</cell><cell>p99</cell><cell>Mean</cell><cell>p25</cell><cell>p50</cell><cell>p75</cell><cell>p99</cell></row><row><cell></cell><cell>3</cell><cell>3</cell><cell>5</cell><cell>20980.71</cell><cell>100</cell><cell>100%</cell><cell>0.06</cell><cell cols="3">0.04 0.07 0.08</cell><cell>0.13</cell><cell>0.00</cell><cell>0.00</cell><cell>0.00</cell><cell>0.00</cell><cell>0.01</cell></row><row><cell></cell><cell>5</cell><cell>6</cell><cell>9</cell><cell>48.67</cell><cell>5</cell><cell>0%</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell></row><row><cell>TPC-H</cell><cell>7 10 11</cell><cell>6 4 6</cell><cell>8 6 7</cell><cell>30.57 4.72 0.13</cell><cell>4 10 10</cell><cell>0% 100% 100%</cell><cell>-0.14 0.09</cell><cell cols="3">-0.13 0.13 0.14 --0.08 0.08 0.08</cell><cell>-0.19 0.13</cell><cell>-0.01 0.01</cell><cell>-0.01 0.00</cell><cell>-0.01 0.00</cell><cell>-0.01 0.01</cell><cell>-0.01 0.03</cell></row><row><cell></cell><cell>16</cell><cell>3</cell><cell>5</cell><cell>1.25</cell><cell>10</cell><cell>100%</cell><cell>0.26</cell><cell cols="3">0.13 0.18 0.33</cell><cell>0.57</cell><cell>0.18</cell><cell>0.01</cell><cell>0.03</cell><cell>0.29</cell><cell>0.88</cell></row><row><cell></cell><cell>18</cell><cell>4</cell><cell>3</cell><cell>37.31</cell><cell>10</cell><cell>100%</cell><cell>0.13</cell><cell cols="3">0.08 0.08 0.18</cell><cell>0.23</cell><cell>0.01</cell><cell>0.00</cell><cell>0.01</cell><cell>0.01</cell><cell>0.03</cell></row><row><cell></cell><cell>19</cell><cell>2</cell><cell>21</cell><cell>2.04</cell><cell>1</cell><cell>100%</cell><cell>1.20</cell><cell cols="3">1.20 1.20 1.20</cell><cell>1.20</cell><cell cols="4">156.06 156.06 156.06 156.06</cell><cell>156.06</cell></row><row><cell></cell><cell>1a</cell><cell>5</cell><cell>10</cell><cell>0.25</cell><cell>35</cell><cell>100%</cell><cell>0.17</cell><cell cols="3">0.08 0.08 0.13</cell><cell>2.10</cell><cell>5.92</cell><cell>0.01</cell><cell>0.01</cell><cell>0.01</cell><cell>206.72</cell></row><row><cell></cell><cell>6b</cell><cell>5</cell><cell>8</cell><cell>2.61</cell><cell>1</cell><cell>100%</cell><cell>0.44</cell><cell cols="3">0.44 0.44 0.44</cell><cell>0.44</cell><cell>0.08</cell><cell>0.08</cell><cell>0.08</cell><cell>0.08</cell><cell>0.08</cell></row><row><cell></cell><cell>7c</cell><cell>8</cell><cell>21</cell><cell>77.33</cell><cell>2415</cell><cell>99%</cell><cell>0.82</cell><cell cols="3">0.18 0.28 0.63</cell><cell>9.44</cell><cell>24.28</cell><cell>0.02</cell><cell>0.05</cell><cell>0.39</cell><cell>787.12</cell></row><row><cell>IMDB</cell><cell>8d 11a</cell><cell>7 8</cell><cell>10 18</cell><cell>145.10 3.20</cell><cell>44517 10</cell><cell>99.9% 100%</cell><cell>0.26 0.75</cell><cell cols="3">0.13 0.18 0.29 0.18 0.48 1.14</cell><cell>1.09 2.15</cell><cell>0.36 23.34</cell><cell>0.01 0.01</cell><cell>0.02 0.13</cell><cell>0.05 1.27</cell><cell>2.28 151.99</cell></row><row><cell></cell><cell>11d</cell><cell>8</cell><cell>16</cell><cell>56.99</cell><cell>210</cell><cell>98.1%</cell><cell>0.99</cell><cell cols="3">0.19 0.32 0.78</cell><cell>5.97</cell><cell>96.19</cell><cell>0.02</cell><cell>0.06</cell><cell>0.48</cell><cell>1650.72</cell></row><row><cell></cell><cell>13c</cell><cell>9</cell><cell>19</cell><cell>2.44</cell><cell>14</cell><cell>100%</cell><cell>0.22</cell><cell cols="3">0.13 0.18 0.28</cell><cell>0.53</cell><cell>0.02</cell><cell>0.01</cell><cell>0.01</cell><cell>0.01</cell><cell>0.06</cell></row><row><cell></cell><cell>15d</cell><cell>9</cell><cell>18</cell><cell>24.25</cell><cell>207</cell><cell>97.6%</cell><cell>1.89</cell><cell cols="4">0.24 0.48 1.28 10.01</cell><cell>70.05</cell><cell>0.06</cell><cell>0.30</cell><cell>3.52</cell><cell>1821.13</cell></row><row><cell></cell><cell>16a</cell><cell>8</cell><cell>15</cell><cell>5.56</cell><cell>173</cell><cell>100%</cell><cell>0.18</cell><cell cols="3">0.13 0.14 0.20</cell><cell>0.53</cell><cell>0.02</cell><cell>0.01</cell><cell>0.01</cell><cell>0.02</cell><cell>0.12</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 2 :</head><label>2</label><figDesc>Median (resp., mean) performance. Monte Carlo and Kernel SHAP use 50 ‚Ä¢ #facts samples</figDesc><table><row><cell></cell><cell cols="2">Monte Carlo Kernel SHAP</cell><cell>CNF Proxy</cell></row><row><cell cols="2">Execution time 0.079 (1.875)</cell><cell cols="2">0.127 (1.978) 7e-4 (0.002)</cell></row><row><cell>L1</cell><cell cols="3">0.439 (0.448) 0.110 (0.109) 0.317 (0.315)</cell></row><row><cell>L2</cell><cell>0.03 (0.034)</cell><cell cols="2">0.001 (0.002) 0.010 (0.014)</cell></row><row><cell>nDCG</cell><cell>1.0 (0.992)</cell><cell>1.0 (0.998)</cell><cell>1.0 (0.999)</cell></row><row><cell>Precision@5</cell><cell>1.0 (0.955)</cell><cell>1.0 (0.961)</cell><cell>1.0 (0.989)</cell></row><row><cell>Precision@10</cell><cell>1.0 (0.953)</cell><cell>1.0 (0.961)</cell><cell>1.0 (0.968)</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This notion of safety is distinct from the "usual" notion of query safety<ref type="bibr" target="#b0">[1]</ref> that ensures domain independence.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>This comes from the fact that, for disjoint ùëã 1 , ùëã 2 and assignments ùúà 1 of ùëã 1 and ùúà 2 of ùëã 2 we have |ùúà 1 ‚à™ ùúà 2 | = |ùúà 1 | + |ùúà 2 |, and Vars(ùúë ùëî 1 ) and ùëÜ 1 are disjoint.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>This additional NNF restriction is not important here, but, as far as we know, no knowledge compiler has the more general "deterministic and decomposable circuits" (without NNF) as a target. It is currently unknown whether d-DNNFs and deterministic and decomposable circuits are exponentially separated or not<ref type="bibr" target="#b10">[11,</ref> Table 7].</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This research has been partially funded by the <rs type="funder">European Research Council (ERC)</rs> under the <rs type="funder">European Union</rs>'s <rs type="programName">Horizon 2020 research and innovation programme</rs> (Grant agreement No. <rs type="grantNumber">804302</rs>). The work of <rs type="person">Benny Kimelfeld</rs> was supported by the <rs type="funder">Israel Science Foundation (ISF)</rs>, Grant <rs type="grantNumber">768/19</rs>, and the <rs type="funder">German Research Foundation (DFG)</rs> Project <rs type="grantNumber">412400621</rs> (<rs type="programName">DIP program</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_ZHx227U">
					<idno type="grant-number">804302</idno>
					<orgName type="program" subtype="full">Horizon 2020 research and innovation programme</orgName>
				</org>
				<org type="funding" xml:id="_WQYsqJu">
					<idno type="grant-number">768/19</idno>
				</org>
				<org type="funding" xml:id="_4RGR6kx">
					<idno type="grant-number">412400621</idno>
					<orgName type="program" subtype="full">DIP program</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<ptr target="http://webdam.inria.fr/Alice/" />
	</analytic>
	<monogr>
		<title level="m">Foundations of Databases</title>
		<title level="s">Addison-Wesley Reading</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barcel√≥</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mika√´l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2104.08015" />
		<title level="m">On the complexity of SHAP-score-based explanations: Tractability via knowledge compilation and non-approximability results</title>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The tractability of SHAP-score-based explanations over deterministic and decomposable Boolean circuits</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barcel√≥</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mika√´l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2007.14045" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI</title>
		<meeting>AAAI</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Curated databases</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang-Chiew</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
		<ptr target="https://homepages.inf.ed.ac.uk/opb/papers/inv.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tan</forename><surname>Wang-Chiew</surname></persName>
		</author>
		<ptr target="https://repository.upenn.edu/cgi/viewcontent.cgi?article=1209&amp;context=cis_papers" />
	</analytic>
	<monogr>
		<title level="m">ICDT. Springer</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="316" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Tracing the lineage of view data in a warehousing environment</title>
		<author>
			<persName><forename type="first">Yingwei</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janet</forename><forename type="middle">L</forename><surname>Wiener</surname></persName>
		</author>
		<ptr target="http://ilpubs.stanford.edu:8090/252/1/1997-3.pdf" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="227" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient query evaluation on probabilistic databases</title>
		<author>
			<persName><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://homes.cs.washington.edu/~suciu/vldbj-probdb.pdf" />
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="523" to="544" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The dichotomy of probabilistic inference for unions of conjunctive queries</title>
		<author>
			<persName><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://homes.cs.washington.edu/~suciu/jacm-dichotomy.pdf" />
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1" to="87" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the tractable counting of theory models and its application to truth maintenance and belief revision</title>
		<author>
			<persName><forename type="first">Adnan</forename><surname>Darwiche</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/cs/0003044" />
	</analytic>
	<monogr>
		<title level="j">J. Applied Non-Classical Logics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1" to="2" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">New advances in compiling CNF to decomposable negation normal form</title>
		<author>
			<persName><forename type="first">Adnan</forename><surname>Darwiche</surname></persName>
		</author>
		<ptr target="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.178.2262" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of ECAI. Citeseer</title>
		<meeting>ECAI. Citeseer</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="328" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A knowledge compilation map</title>
		<author>
			<persName><forename type="first">Adnan</forename><surname>Darwiche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Marquis</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1106.1819" />
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="229" to="264" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Explaining natural language query results</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nave</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Gilad</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2007.04454" />
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="485" to="508" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nave</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mika√´l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://github.com/navefr/ShapleyForDbFacts" />
		<title level="m">Shapley for database facts source code</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">Grigoris</forename><surname>Todd J Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><surname>Tannen</surname></persName>
		</author>
		<ptr target="https://repository.upenn.edu/cgi/viewcontent.cgi?article=1022&amp;context=db_research" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The semiring framework for database provenance</title>
		<author>
			<persName><forename type="first">J</forename><surname>Todd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><surname>Tannen</surname></persName>
		</author>
		<idno type="DOI">10.1145/3034786.3056125</idno>
		<ptr target="https://dl.acm.org/doi/10.1145/3034786.3056125" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="93" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the measure of conflicts: Shapley inconsistency values</title>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Hunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S√©bastien</forename><surname>Konieczny</surname></persName>
		</author>
		<ptr target="http://www.cril.univ-artois.fr/~konieczny/papers/aij10a.pdf" />
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">174</biblScope>
			<biblScope unit="page" from="1007" to="1026" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Incomplete Information in Relational Databases</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Witold</forename><surname>Lipski</surname><genName>Jr</genName></persName>
		</author>
		<idno type="DOI">10.1145/1634.1886</idno>
		<ptr target="https://doi.org/10.1145/1634.1886" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984">1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Knowledge compilation meets database theory: compiling queries to decision diagrams</title>
		<author>
			<persName><forename type="first">Abhay</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00224-012-9392-5</idno>
		<ptr target="https://link.springer.com/article/10.1007/s00224-012-9392-5" />
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="403" to="440" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">How good are query optimizers, really?</title>
		<author>
			<persName><forename type="first">Viktor</forename><surname>Leis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atanas</forename><surname>Mirchev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfons</forename><surname>Kemper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
		<ptr target="https://www.vldb.org/pvldb/vol9/p204-leis.pdf" />
	</analytic>
	<monogr>
		<title level="j">Proceedings of the VLDB Endowment</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="204" to="215" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Shapley value of tuples in query answering</title>
		<author>
			<persName><forename type="first">Ester</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><forename type="middle">E</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><surname>Sebag</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1904.08679" />
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">From local explanations to global understanding with explainable AI for trees</title>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Scott M Lundberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugh</forename><surname>Erion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><surname>Degrave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bala</forename><surname>Jordan M Prutkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronit</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nisha</forename><surname>Himmelfarb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Su-In</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><surname>Lee</surname></persName>
		</author>
		<ptr target="https://arxiv.org/pdf/1905.04610.pdf" />
	</analytic>
	<monogr>
		<title level="j">Nature machine intelligence</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2522" to="5839" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A unified approach to interpreting model predictions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Su-In</forename><surname>Lundberg</surname></persName>
		</author>
		<author>
			<persName><surname>Lee</surname></persName>
		</author>
		<ptr target="http://papers.nips.cc/paper/7062-a-unified-approach-to-interpreting-model-predictions.pdf" />
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="4765" to="4774" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Values for large games, IV: Evaluating the Electoral College by Monte Carlo Techniques</title>
		<author>
			<persName><forename type="first">Irwin</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName><surname>Shapley</surname></persName>
		</author>
		<idno>2651</idno>
		<ptr target="https://www.rand.org/pubs/research_memoranda/RM2651.html" />
		<imprint>
			<date type="published" when="1960">1960. 1960</date>
			<publisher>The Rand Corporation</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Research Memorandum</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The complexity of causality and responsibility for query answers and non-answers</title>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Gatterbauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katherine</forename><forename type="middle">F</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://www.vldb.org/pvldb/vol4/p34-meliou.pdf" />
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="34" to="45" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Causality and explanations in databases</title>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/pvldb/vol7/p1715-meliou.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB)</title>
		<meeting>the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1715" to="1716" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Solving a Special Case of the Intensional vs Extensional Conjecture in Probabilistic Databases</title>
		<author>
			<persName><forename type="first">Mika√´l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1912.11864" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="149" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The impact of negation on the complexity of the Shapley value in conjunctive queries</title>
		<author>
			<persName><forename type="first">Alon</forename><surname>Reshef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ester</forename><surname>Livshits</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1912.12610" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="285" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">Alvin</forename><forename type="middle">E</forename><surname>Roth</surname></persName>
		</author>
		<ptr target="http://www.library.fa.ru/files/Roth2.pdf" />
		<title level="m">The Shapley Value: Essays in Honor of Lloyd S. Shapley</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Explaining query answers with explanation-ready databases</title>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurel</forename><forename type="middle">J</forename><surname>Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/pvldb/vol9/p348-roy.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB)</title>
		<meeting>the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="348" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Quantifying causal effects on query answering in databases</title>
		<author>
			<persName><forename type="first">Babak</forename><surname>Salimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><forename type="middle">E</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><surname>Van Den Broeck</surname></persName>
		</author>
		<ptr target="http://web.cs.ucla.edu/~guyvdb/papers/SalimiTaPP16.pdf" />
	</analytic>
	<monogr>
		<title level="m">TaPP. USENIX Association</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Provsql: Provenance and probability management in postgresql</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Jachiet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-01851538/file/p976-senellart.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB)</title>
		<meeting>the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="2034" to="2037" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A value for n-person games</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><surname>Shapley</surname></persName>
		</author>
		<ptr target="http://www.library.fa.ru/files/Roth2.pdf#page=39" />
	</analytic>
	<monogr>
		<title level="j">Contributions to the Theory of Games</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="307" to="317" />
			<date type="published" when="1953">1953. 1953</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Probabilistic Databases</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>R√©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<idno type="DOI">10.2200/S00362ED1V01Y201105DTM016</idno>
		<ptr target="https://www.morganclaypool.com/doi/abs/10.2200/S00362ED1V01Y201105DTM016" />
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Morgan &amp; Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<ptr target="http://www.tpc.org/tpc_documents_current_versions/pdf/tpc-h_v2.17.2.pdf" />
		<title level="m">Transaction Processing Performance Council (TPC)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>TPC-H benchmark</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On the complexity of derivation in propositional calculus</title>
		<author>
			<persName><surname>Grigori S Tseitin</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-81955-1_28</idno>
		<ptr target="https://link.springer.com/chapter/10.1007/978-3-642-81955-1_28" />
	</analytic>
	<monogr>
		<title level="m">Automation of reasoning</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="466" to="483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On the tractability of shap explanations</title>
		<author>
			<persName><forename type="first">Guy</forename><surname>Van Den Broeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anton</forename><surname>Lykov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maximilian</forename><surname>Schleich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2009.08634" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI</title>
		<meeting>AAAI</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The complexity of relational query languages</title>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<ptr target="http://www.dis.uniroma1.it/~degiacom/didattica/semingsoft/SIS05-06/materiale/1-query-congiuntive/riferimenti/vardi-1982.pdf" />
	</analytic>
	<monogr>
		<title level="m">STOC. ACM</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A theoretical analysis of NDCG ranking measures</title>
		<author>
			<persName><forename type="first">Yining</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liwei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuanzhi</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Di</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tie-Yan</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.680.490&amp;rep=rep1&amp;type=pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of COLT</title>
		<meeting>COLT</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Inconsistency Measures for Repair Semantics in OBDA</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srdjan</forename><surname>Vesic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madalina</forename><surname>Croitoru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bisquert</surname></persName>
		</author>
		<ptr target="https://www.ijcai.org/proceedings/2018/0273.pdf" />
	</analytic>
	<monogr>
		<title level="m">IJCAI. ijcai.org</title>
		<imprint>
			<date type="published" when="1977">2018. 1977-1983</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
