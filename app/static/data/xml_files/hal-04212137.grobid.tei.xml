<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Do Repeat Yourself: Understanding Sufficient Conditions for Restricted Chase Non-Termination (Technical Report)</title>
				<funder>
					<orgName type="full">Center for Advancing Electronics Dresden (cfaed)</orgName>
				</funder>
				<funder ref="#_bvWWzuQ">
					<orgName type="full">DAAD (German Academic Exchange Service)</orgName>
				</funder>
				<funder ref="#_gA2tc5g">
					<orgName type="full">and Composite AI)</orgName>
				</funder>
				<funder ref="#_kFWezjs">
					<orgName type="full">Center for Perspicuous Systems)</orgName>
				</funder>
				<funder>
					<orgName type="full">Bundesministerium für Bildung und Forschung (BMBF, Federal Ministry of Education and Research)</orgName>
				</funder>
				<funder ref="#_wPEsw85">
					<orgName type="full">BMBF</orgName>
				</funder>
				<funder ref="#_htcdyUk">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_xSMFNHB">
					<orgName type="full">Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)</orgName>
				</funder>
				<funder ref="#_3qWRkrv">
					<orgName type="full">European ITEA</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Lukas</forename><surname>Gerlach</surname></persName>
							<email>lukas.gerlach@tu-dresden.de</email>
							<affiliation key="aff0">
								<orgName type="department">Knowledge-Based Systems Group</orgName>
								<orgName type="institution">TU Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<email>david.carral@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Do Repeat Yourself: Understanding Sufficient Conditions for Restricted Chase Non-Termination (Technical Report)</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">2996960126B22D0C0B04D9DF80DDDCF8</idno>
					<idno type="DOI">10.24963/kr.2023/30</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The disjunctive restricted chase is a sound and complete procedure for solving boolean conjunctive query entailment over knowledge bases of disjunctive existential rules. Alas, this procedure does not always terminate and checking if it does is undecidable. However, we can use acyclicity notions (sufficient conditions that imply termination) to effectively apply the chase in many real-world cases. To know if these conditions are as general as possible, we can use cyclicity notions (sufficient conditions that imply non-termination). In this paper, we discuss some issues with previously existing cyclicity notions, propose some novel notions for non-termination by dismantling the original idea, and empirically verify the generality of the new criteria.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The (disjunctive) chase <ref type="bibr" target="#b2">(Bourhis et al. 2016</ref>) is a sound and complete bottom-up materialization procedure to reason with knowledge bases (KBs) featuring (disjunctive existential) rules. In some cases, we can apply the chase to determine if a conjunctive query or a fact is a consequence of a KB under standard first-order semantics. Example 1. Consider the KB K = ⟨R, D⟩ where R is the rule set {(1-4)} and D is the database {Engine(d)}.</p><p>Engine(x) → ∃v.IsIn(x, v) ∧ Bike(v) ∨ Spare(x) (1) Bike(x) → ∃w.Has(x, w) ∧ Engine(w)</p><p>(2) IsIn(x, y) → Has(y, x)</p><p>(3) Has(x, y) → IsIn(y, x) (4)</p><p>We can apply the chase procedure to verify if the fact Spare(c) follows from K. In this case, the restricted chase produces a universal model set with two models for K; namely, {Engine(d), Spare(d)} and {Engine(d), IsIn(d, f v (d)), Bike(f v (d)), Has(f v (d), d)}, where f v (d)) is a fresh term introduced to satisfy the existential quantifier in (1). Since the second model does not contain Spare(d), this fact is not entailed by K.</p><p>Since boolean conjunctive query entailment is undecidable <ref type="bibr" target="#b1">(Beeri and Vardi 1981)</ref>, the chase may not always terminate. Even worse, we cannot decide if the chase terminates on a particular KB or if a rule set R is acyclic <ref type="bibr" target="#b8">(Gogacz and Marcinkowski 2014;</ref><ref type="bibr" target="#b9">Grahne and Onet 2018)</ref>; that is, if the chase terminates for every KB with R. We can still verify rule set termination in practice using acyclicity notions; that is, sufficient conditions that imply termination <ref type="bibr" target="#b5">(Fagin et al. 2005;</ref><ref type="bibr" target="#b12">Marnette 2009</ref>; <ref type="bibr" target="#b11">Krötzsch and Rudolph 2011;</ref><ref type="bibr" target="#b4">Cuenca Grau et al. 2013;</ref><ref type="bibr" target="#b3">Carral, Dragoste, and Krötzsch 2017;</ref><ref type="bibr" target="#b0">Baget et al. 2014;</ref><ref type="bibr" target="#b10">Karimi, Zhang, and You 2021)</ref>. However, if an acyclicity notion is not able to classify a rule set R as terminating, we never know if this notion is just not "general enough" or if the rule set is indeed non-terminating.</p><p>To address this issue, we study cyclicity notions, which imply non-termination. As a long-term motivation, these approaches can also help to fix potential modelling mistakes. To the best of our knowledge, only one such notion has been proposed for the restricted chase variant, namely Restricted Model Faithful Cyclicity (RMFC). Alas, many non-terminating rule sets with disjunctions are not classified as such by this notion <ref type="bibr" target="#b3">(Carral, Dragoste, and Krötzsch 2017)</ref>. Worse still, the correctness proof of RMFC does not hold in its presented form (see Section 7). Recently, Gerlach and Carral have also proposed Disjunctive Model Faithful Cyclicity (DMFC) for the skolem chase. Note however that a cyclicity notion for the skolem chase is not directly a valid condition for restricted non-termination since the former variant terminates less often than the latter.</p><p>In this paper, our overarching goal is to improve our understanding of existing cyclicity notions such as RMFC and DMFC. We reconsider the underlying ideas and dismantle them into an extensible framework. We provide examples to explain how these notions work and clarify why certain technical details are necessary. As more tangible contributions, (i) we come up with novel cyclicity notions named restricted prefix cyclicity (RPC) and deterministic RPC (DRPC), and (ii) we empirically evaluate the generality of these two.</p><p>To this aim, the key points of the sections are as follows:<ref type="foot" target="#foot_0">1</ref> S3. Cyclicity sequences that guarantee never-termination by making use of g-unblockability. S4. Checkable conditions that ensure g-unblockability. S5. Cyclicity prefixes that allow cyclicity sequences. S6. The notion (D)RPC that guarantees a cyclicity prefix. S7. Detailed relations to DMFC and RMFC in particular. S8. Empirical evaluation of the generality of (D)RPC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We define Preds, Funs, Cons, and Vars to be mutually disjoint, countably infinite sets of predicates, function symbols, constants, and variables, respectively. Every s ∈ Preds ∪ Funs is associated with an arity ar(s) ≥ 1. The set Terms ⊇ Cons ∪ Vars contains f (t 1 , . . . , t n ) for every n ≥ 1, every f ∈ Funs with ar(f ) = n, and every t 1 , . . . , t n ∈ Terms. For some X ∈ {Preds, Funs, Cons, Vars, Terms} and an expression ϕ, we write X(ϕ) to denote the set of all elements of X that syntactically occur in ϕ.</p><p>A term t / ∈ Vars ∪ Cons is functional. For a term t; let depth(t) = 1 if t is not functional, and depth(t) = 1 + max(depth(s 1 ), . . . , depth(s n )) if t is of the form f (s 1 , . . . , s n ). We write lists t 1 , . . . , t n of terms as t and often treat these as sets. A term s is a subterm of another term t if t = s, or t is of the form f (s) and s is a subterm of some term in s. For a term t, let subterms(t) be the set of all subterms of t. A term is cyclic if it has a subterm of the form f (s) with f ∈ Funs(s).</p><p>An atom is an expression of the form P(t) with P a predicate and t a list of terms such that ar(P) = |t|. A fact is a variable-free atom. For a formula υ, we write υ(x) to denote that x is the set of all free variables that occur in υ. Definition 1. A (disjunctive existential) rule is a constantand function-free first-order formula of the form</p><formula xml:id="formula_0">∀w, x.[β(w, x) → n i=1 ∃y i .η i (x i , y i )]<label>(5)</label></formula><p>where n ≥ 1; w, x, y 1 , . . . , and y n are pairwise disjoint lists of variables; n i=1 x i = x; and β, η 1 , . . . , and η n are non-empty conjunctions of atoms.</p><p>We omit universal quantifiers when writing rules and often treat conjunctions as sets. The frontier of a rule ρ such as (5) is the variable set frontier(ρ) = x. Moreover, let body(ρ) = β, let head i (ρ) = η i for every 1 ≤ i ≤ n, and let branching(ρ) = n. The rule ρ is deterministic if n = 1, generating if y i is non-empty for some 1 ≤ i ≤ n, and datalog if it is deterministic and non-generating.</p><p>A (ground) substitution is partial function from variables to ground terms; that is, to variable-free terms. We write [x 1 /t 1 , . . . , x n /t n ] to denote the substitution mapping x 1 , . . . , x n to t 1 , . . . , t n , respectively. For an expression ϕ and a substitution σ, let ϕσ be the expression that results from ϕ by uniformly replacing every syntactic occurrence of every variable x by σ(x) if the latter is defined.</p><p>For a rule ρ such as (5), let σ ρ be the substitution mapping y to f ρ i,y (x) for every 1 ≤ i ≤ n and every y ∈ y i with f ρ i,y a fresh function symbol unique for ⟨ρ, i, y⟩. If y uniquely identifies the tuple ⟨ρ, i, y⟩, we also write f y (x). (This is the case in all our examples.) The skolemization sk(ρ) of ρ is the expression β → (</p><formula xml:id="formula_1">n i=1 η i )σ ρ . For every 1 ≤ i ≤ n, let head i (sk(ρ)) = η i σ ρ .</formula><p>A trigger λ is a pair ⟨ρ, σ⟩ with ρ a rule and σ a substitution with domain Vars(body(ρ)). A trigger is loaded for a fact set F if body(ρ)σ ⊆ F. It is obsolete for F if there is a substitution τ that extends σ such that head i (ρ)τ ⊆ F for some 1 ≤ i ≤ branching(ρ). Let out i (λ) = head i (sk(ρ))σ for every 1 ≤ i ≤ branching(ρ), and out(λ Consider a rule set R. An R-term is a term defined using the function symbols that occur in sk(R), some constants, and some variables. A substitution is an R-substitution if its range is a set of R-terms. An R-trigger is a trigger with a rule from R and an R-substitution.</p><formula xml:id="formula_2">) = {out i (λ) | 1 ≤ i ≤ branching(ρ)}. Engine(d) . . . , Spare(d)⟨(1), [x/d]⟩ . . . , IsIn(d, f v (d)), Bike(f v (d))⟨(1), [x/d]⟩ . . . , Has(f v (d), d)⟨(3), [x/d, y/f v (d)]⟩</formula><p>A fact set F satisfies a rule ρ if all triggers with ρ are not loaded or obsolete for F. A knowledge base (KB) is a pair K = ⟨R, D⟩ of a rule set R and a database D; that is, a function-free fact set. The restricted chase on input K exhaustively applies the outputs of triggers that are loaded and not obsolete in a tree with root D branching on disjunctions.</p><p>Restricted Chase We present a variant of the disjunctive chase <ref type="bibr" target="#b2">(Bourhis et al. 2016)</ref> where the application of rules is restricted; that is, rules are only applicable if their heads are not obsolete with respect to previously derived facts. Moreover, we impose an order of rule applications that prioritises the application of (triggers with) datalog rules. Definition 2. A chase tree T = ⟨V, E, fct, trg⟩ for a KB ⟨R, D⟩ is a directed tree where V is a set of vertices, E is a set of edges, fct is a function mapping vertices to fact sets, and trg is a function mapping every non-root vertex to a trigger. Moreover, the following hold: 1. For the root r ∈ V of T , we have that fct(r) = D. 2. For every non-leaf vertex v ∈ V ; there is an R-trigger λ = ⟨ρ, σ⟩ that is loaded and not obsolete for fct(v) such that (i) the set fct(v) satisfies all datalog rules in R if the rule in λ is not datalog, (ii) v has exactly n = branching(ρ) children c 1 , . . . , c n (via E) with fct(c i ) = fct(v) ∪ out i (λ) and trg(c i ) = λ for each 1 ≤ i ≤ n. 3. For every leaf vertex v ∈ V , the set fct(v) satisfies all of the rules in R. For every R-trigger λ that is loaded for fct(v) for some v ∈ V , there is a k ≥ 0 such that λ is obsolete for fct(u) for each u ∈ V reachable from v by a path of length k. That is, fairness.</p><p>We refer to fct(v) and trg(v) for some v ∈ V as the factand trigger-label of v, respectively. Informally, we say that a trigger (resp. a rule) is applied in a chase tree to signify that some vertex in the tree is labelled with this trigger (resp. a trigger with this rule). Example 2. The KB from Example 1 only admits one chase tree, which is depicted in Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>A branch of a chase tree T = ⟨V, E, fct, trg⟩ is a maximal path in T starting at the root; that is, a vertex sequence B = v 1 , v 2 , . . . where v 1 is the root, ⟨v i , v i+1 ⟩ ∈ E for every 1 ≤ i &lt; |B|, and the last element of B is a leaf if B is finite. The result of T is the set { v∈B fct(v) | B a branch of T }; chase results can be used to solve query entailment: Proposition 1. Consider the result R of some (arbitrarily chosen) chase tree of a K. Then, K entails a query γ = ∃y.β iff F |= γ for every F ∈ R iff for every F ∈ R there is a substitution σ with βσ ⊆ F.</p><p>Therefore, it is interesting to know if a rule set admits finite chase trees. A rule set R terminates if every chase tree of every KB with R is finite, it sometimes-terminates if every KB with R admits a finite chase tree, and it neverterminates if some KB with R that has no finite chase trees.</p><p>We use skolem function names to backtrack the facts along which a term t appears in the chase; that is, the birth facts of t. For a constant c, let BirthF R (c) = ∅; for a rule set R and an R-term t of the form</p><formula xml:id="formula_3">f ρ i,v (s), let BirthF R (t) = out i (⟨ρ, σ⟩) ∪ s∈s BirthF R (s) where σ is a substitution with frontier(ρ)σ = s. For a trigger ⟨ψ, τ ⟩, let BirthF R (⟨ψ, τ ⟩) = x∈frontier(ψ) BirthF R (τ (x)). The term-skeleton skeleton R (⟨ψ, τ ⟩) of ⟨ψ, τ ⟩ consists of Terms(BirthF R (⟨ψ, τ ⟩)) and every constant c with c = τ (x) for an x ∈ frontier(ψ). Example 3. Let R = {(1), (2)} and λ = ⟨(2), [x/f v (d)]⟩. We have BirthF R (λ) = {IsIn(d, f v (d)), Bike(f v (d))} and skeleton R (λ) = {d, f v (d)}. (Note again that f v = f (1)</formula><p>1,v .)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Cyclicity Sequences</head><p>In this section, we introduce the notion of a cyclicity sequence Λ for a KB K = ⟨R, D⟩ (see Definition 6) and show that its existence implies that K only admits infinite chase trees (see Theorem 1). Intuitively, Λ is an infinite sequence of R-triggers that are applied in some (infinite) branch of every chase tree of K. To identify these branches, we consider the following notion from <ref type="bibr">(Gerlach and Carral 2023b</ref>). Definition 3. A head-choice for a rule set R is a function hc that maps every rule ρ ∈ R to an element of {1, . . . , branching(ρ)}. For a rule ρ ∈ R and a trigger λ with ρ, we write head hc (ρ) and out hc (λ) instead of head hc(ρ) (ρ) and out hc(ρ) (λ), respectively. For a chase tree T = ⟨V, E, fct, trg⟩ of a KB with R, we define branch(T, hc) = v 1 , v 2 , . . . as the branch of T such that fct(v i+1 ) = fct(v i ) ∪ out hc (trg(v i+1 )) for every 1 ≤ i &lt; |branch(T, hc)|; note that every branch starts with the root. Cyclicity sequences must satisfy three requirements (see Definition 6); let's start with the first two: Definition 4. Consider a KB K = ⟨R, D⟩, a head-choice hc for R, and a sequence Λ = λ 1 , λ 2 , . . . of R-triggers.</p><formula xml:id="formula_4">• Let F 0 (K, hc, Λ) = D, and let F i+1 (K, hc, Λ) = F i (K, hc, Λ) ∪ out hc (λ i+1 ) for every 0 ≤ i &lt; |Λ|. • The sequence Λ is loaded for K and hc if λ i+1 is loaded for F i (K, hc, Λ) for every 0 ≤ i &lt; |Λ|.</formula><p>• The sequence Λ is growing for K and hc if, for every 0 ≤ i &lt; |Λ|, there is some j &gt; i and a term that occurs in F j (K, hc, Λ) but not in F i (K, hc, Λ). Note that Λ is infinite if this requirement is satisfied.</p><p>For some variants of the chase, existence of a loaded and growing sequence of R-triggers for a KB and a head-choice may suffice to witness non-termination. This is not the case for the restricted chase:</p><p>Example 4. Consider the KB K = ⟨R, D⟩ from Example 1, and the head-choice hc that maps every rule in R to 1. Moreover, consider the infinite sequence Λ = λ 1 , λ 2 , . . . of triggers such that:</p><formula xml:id="formula_5">• Let t 0 = d, let t i = f v (t i-1</formula><p>) for every odd i ≥ 1, and let t i = f w (t i-1 ) for every even i ≥ 1.</p><formula xml:id="formula_6">• For every i ≥ 1; let λ i = {(1), [x/t i-1 ]} if i is odd, and λ i = {(2), [x/t i-1</formula><p>]} otherwise. The (infinite) sequence Λ is loaded and growing; however, the KB K terminates! Note that this KB only admits one chase tree, which is finite (see Example 2).</p><p>The issue in the previous example is that the second trigger of Λ cannot be applied in any chase tree of K; this is because we must apply datalog triggers with (3) before we apply triggers with (2). To address this issue, we introduce a third requirement for cyclicity sequences (see Definition 6): Definition 5. Consider a KB K = ⟨R, D⟩, a head-choice hc for R, and a sequence of R-triggers Λ = λ 1 , λ 2 , . . . • An R-trigger λ is g-unblockable<ref type="foot" target="#foot_1">2</ref> for K and hc if, for every chase tree T = ⟨V, E, fct, trg⟩ and every v in branch(T, hc) such that λ is loaded for fct(v), there is some u in branch(T, hc) with out hc (λ) ⊆ fct(u). Intuitively, if λ is loaded for a vertex in the hc-branch of a chase tree T of K, then its output according to hc eventually appears in this branch. • If every trigger in Λ is g-unblockable, then this sequence is g-unblockable for K and hc.</p><p>The sequence Λ in Example 4 is not g-unblockable because its second trigger does not satisfy this property. However, Λ is g-unblockable for a slightly different input KB: Example 5. Consider the rule set R = {(1), (2)}; and the database D, the head-choice hc, and the sequence Λ from Example 4. Since R contains neither (3) nor (4), the sequence Λ is g-unblockable for ⟨R, D⟩ and hc. Note that the KB ⟨R, D⟩ only admits one chase tree, which is infinite, and hence, R is never-terminating.</p><p>We are ready to define cyclicity sequences: Definition 6. A sequence Λ = λ 1 , λ 2 , . . . of R-triggers is a cyclicity sequence of a KB K = ⟨R, D⟩ and a head-choice hc if Λ is (infinite,) loaded, growing, and g-unblockable. Note that Λ is infinite if it is growing. Theorem 1. A rule set R never-terminates if there is a cyclicity sequence for a KB with R and some head-choice.</p><p>Proof. Assume that there is a cyclicity sequence Λ = λ 1 , λ 2 , . . . of some KB such as K = ⟨R, D⟩ and some head-choice hc, and consider some chase tree T = ⟨V, E, fct, trg⟩ of ⟨R, D⟩ and the sequence branch(T, hc) = v 1 , v 2 , . . . To show the theorem, we prove that the fact set F(T, hc) = i≥0 fct(v i ) is infinite, which implies that both branch(T, hc) and T are infinite. This holds by infinity of i≥0 F i (K, hc, Λ) (since Λ is growing) and F i (K, hc, Λ) ⊆ F(T, hc) for every i ≥ 0 (which follows by induction since Λ is loaded and g-unblockable.)</p><p>Theorem 1 provides a blueprint to show never-termination of a rule set R: One "simply" has to show that R admits a cyclicity sequence (see Section 6). To show that such sequences exist, we have developed techniques to find infinite sequences of triggers that are g-unblockable. This is a rather challenging task; note that we cannot even decide if a single trigger is g-unblockable (by reduction from fact entailment <ref type="bibr" target="#b1">(Beeri and Vardi 1981)</ref>): Theorem 2. The problem of deciding if a trigger is gunblockable for a KB and a head-choice is undecidable.</p><p>In this section, we first discuss ways to detect if a trigger is g-unblockable in some cases. Then, we devise strategies to show that some infinite sequences of triggers are gunblockable, i.e. that unblockability "propagates".</p><p>Detecting Unblockability To detect if a trigger λ is gunblockable, we make use of chase over-approximations before the application of λ: Definition 7. Consider a rule set R, a head-choice hc, and some R-trigger λ = ⟨ρ, σ⟩. A fact set F is an overapproximation of R and hc before λ if there is a function h over the set of terms such that (i) h(σ(x)) = σ(x) for each x ∈ frontier(ρ) and, (ii) for every u ∈ branch(T, hc) in every chase tree T = ⟨V, E, fct, trg⟩ of every KB ⟨R, D⟩ with out hc (λ) ⊈ fct(u), we have that h(fct(u)) ⊆ F.</p><p>Intuitively, a chase over-approximation such as F above for R and hc before λ is some sort of "upper-bound" of all of the facts that can possibly occur in the label of a vertex in the hc-branch if this label does not include the output of λ. If λ is not obsolete for F, its output eventually appears in the hc-branch of the chase: Lemma 1. If λ is not obsolete for some over-approximation of a rule set R and a head-choice hc before λ, then λ is g-unblockable for hc and every KB with R.</p><p>Proof. To show the contrapositive, we assume that λ = ⟨ρ, σ⟩ is not g-unblockable for some ⟨R, D⟩ and hc. Then, there exists a chase tree T = ⟨V, E, fct, trg⟩ of ⟨R, D⟩ and hc such that (i) λ is loaded for some v ∈ branch(T, hc) and (ii) out hc (λ) ⊈ fct(u) for every u ∈ branch(T, hc). Moreover, λ is obsolete for fct(w) for some w ∈ branch(T, hc) by Definition 2. By Definition 7, we find h(fct(w)) ⊆ F for every over-approximation F of R and hc before λ with term mapping h. Then, ⟨ρ, h • σ⟩ is obsolete for F; hence so is λ since h • σ and σ agree on all frontier variables of ρ.</p><p>Lemma 1 provides a strategy to detect g-unblockability for a given trigger λ: Compute some over-approximation F and then check if λ is obsolete for F. We consider two alternative ways of computing these over-approximations: Definition 8. For a trigger λ, let h ⋆ λ be the function over the set of terms that maps every t ∈ skeleton R (λ) to itself and every other term to the special constant ⋆. Moreover, let h uc λ be another such function that maps every functional term f (t) / ∈ skeleton R (λ) to a fresh constant c f , every term in skeleton R (λ) and every constant of the form c f to itself, and every other term to ⋆.</p><p>For a rule set R, a head-choice hc, some R-trigger λ = ⟨ρ, σ⟩, and some h ∈ {h ⋆ λ , h uc λ }; let O(R, hc, λ, h) be the minimal fact set that 1. contains every fact that can be defined using a predicate occurring in R and constants in skeleton R (λ) ∪ {⋆}, 2. includes BirthF R (λ), and 3. includes h(out hc (λ ′ )) for every R-trigger λ ′ such that λ ′ is loaded for O(R, hc, λ, h) and out hc (λ ′ ) ̸ = out hc (λ). Moreover, we define O(R, λ, h) as the minimal fact set that satisfies (1) and (2) above, and includes h( out(λ ′ )) for every R-trigger</p><formula xml:id="formula_7">λ ′ = ⟨ψ, τ ⟩ such that λ ′ is loaded for O(R, λ, h) and if ψ = ρ, then out i (λ ′ ) ̸ = out i (λ) for some 1 ≤ i ≤ branching(ρ).</formula><p>Intuitively, O(R, λ, h) views outputs as if disjunctions were replaced by conjunctions in rules. Example 6. For the rule set R = {(1), (2)}, the head-choice hc 1 : R → {1}, some constant d, and the trigger</p><formula xml:id="formula_8">λ = ⟨(2), [x/f v (d)]⟩; the set O(R, hc 1 , λ, h uc λ ) equals {Engine(s), Bike(s), Spare(s), IsIn(s, t) | s, t ∈ {⋆, d}} ∪ BirthF R (λ) ∪ {IsIn(⋆, c v ), Bike(c v ), Has(⋆, c w ), Has(d, c w ), Engine(c w ), IsIn(c w , c v ), Has(c v , c w )}.</formula><p>In the above, we write c v and c w to refer to the fresh constants unique for f v and f w , respectively. Note that</p><formula xml:id="formula_9">O(R, hc 1 , λ, h uc λ ) does not contain IsIn(d, c v ) since h uc λ maps f v (d) to itself, or Has(f v (d), c w ) since this fact is in the output of a trigger excluded by Item 3 in Definition 8. The set O(R, λ, h uc λ ) includes O(R, hc 1 , λ, h uc λ ) and addi- tionally contains Spare(c w ). If we replace all occurrences of c v and c w in O(R, hc 1 , λ, h uc λ ) (resp. O(R, λ, h uc λ )) with ⋆, we obtain O(R, hc 1 , λ, h ⋆ λ ) (resp. O(R, λ, h ⋆ λ )</formula><p>). Lemma 2. For a rule set R, a head-choice hc, an R-trigger λ = ⟨ρ, σ⟩, and some h ∈ {h ⋆ λ , h uc λ }; O(R, hc, λ, h) and O(R, λ, h) are over-approximations of R and hc before λ.</p><p>Proof. We show a more general claim; namely, we consider any h such that (a) h(σ(x)) = σ(x) for each x ∈ frontier(ρ), (b) h(f (h(s))) = h(f (s)) for every functional term f (s), (c) h • h = h, and (d) h maps every constant that may occur in a database to a constant in skeleton R (λ)∪{⋆}. Note that the above hold for h ⋆ λ and h uc λ by Definition 8. We show that O(R, hc, λ, h) is an over-approximation of R and hc before λ. The first condition of Definition 7 holds for h by assumption (a). For every u ∈ branch(T, hc) in every chase tree T of every KB ⟨R, D⟩, we can verify the second condition via induction on the path from the root of T to u assuming that out hc (λ) ⊈ fct(u) and invoking (b-d).</p><p>For the second part of the claim, O(R, λ, h) is an overapproximation of R and hc before λ since O(R, hc, λ, h) ⊆ O(R, λ, h) by Definition 8.</p><p>Using the over-approximations from Definition 8, we define two different types of unblockability: Definition 9. Consider a rule set R and an R-trigger λ. Then, λ is ⋆-unblockable for R if it features a datalog rule or it is not obsolete for O(R, λ, h ⋆ λ ). Moreover, it is ucunblockable for R and some hc if it features a datalog rule or it is not obsolete for O(R, hc, λ, h uc λ ).</p><p>Example 7. Consider the rule set R = {(1), (2)} and the head-choice hc 1 mapping all rules to 1. The trigger</p><formula xml:id="formula_10">λ = ⟨(2), [x/f v (d)]⟩ is uc-unblockable for R and hc 1 ; it is not for R ′ = R ∪ {(3)} and hc 1 . Note that O(R ′ , hc 1 , λ, h uc λ ) includes O(R, hc 1 , λ, h uc λ ) ∪ {Has(f v (d), d)} (among other facts). Therefore, λ is obsolete for O(R ′ , hc 1 , λ, h uc λ ) but not for O(R, hc 1 , λ, h uc λ )</formula><p>. By Theorem 2, we cannot decide if a trigger λ is gunblockable. However, we can effectively check ⋆or ucunblockability; both properties imply g-unblockability:</p><p>Lemma 3. If an R-trigger λ is ⋆-unblockable for a rule set R, it is uc-unblockable for R and every head-choice. If λ is uc-unblockable for R and some head-choice hc, then it is g-unblockable for R and hc.</p><p>Proof. The first implication holds since</p><formula xml:id="formula_11">O(R, λ, h ⋆ λ ) in- cludes h(O(R, hc, λ, h uc λ )</formula><p>) with h the function that maps every fresh constant in the range of h uc λ to ⋆. For the second, note that a trigger λ with a datalog rule is g-unblockable. For the non-datalog case, we can apply Lemmas 1 and 2.</p><p>By Lemma 3, a trigger is g-unblockable if it is ⋆unblockable; we can also prove this directly with Lemmas 1 and 2. By Lemma 3, uc-unblockability is more general than ⋆-unblockability; the other direction does not hold:</p><p>Example 8. Consider the following rule set R:</p><formula xml:id="formula_12">R(x, y) → ∃u.R(y, u) (6) R(x, y) → ∃v.S(y, v) (7) R(x, y) → ∃w.T (y, w) (8) S(x, y) ∧ T (x, y) → R(x, y)<label>(9)</label></formula><p>The trigger ⟨(6), [x/c y , y/f u (c y )]⟩ is uc-unblockable but not ⋆-unblockable: We find S(f u (c y ), ⋆), T (f u (c y ), ⋆) and therefore R(f u (c y ), ⋆) in O(R, hc, λ, h ⋆ λ ). On the other hand, we only find S(f u (c y ), c v ) and T (f u (c y ), c w ) but no fact of the form R(f u (c y ), . . . ) in O(R, hc, λ, h uc λ ). Carral, Dragoste, and Krötzsch and Gerlach and Carral introduce similar notions to ⋆-unblockability in ( <ref type="formula">2017</ref>) and (2023b). Here, we not only present a more general criterion (see Definition 9), but a blueprint to produce more comprehensive notions (see Definitions 7, 8 and Lemmas 1, 2).</p><p>Propagating Unblockability A key feature of uc/⋆unblockability is that these properties propagate across a reversible constant-mappings: (Gerlach and Carral 2023b) Definition 10. A constant mapping g is a partial function mapping constants to terms. For an expression ϕ, let g(ϕ) be the expression that results from replacing all syntactic occurrences of every constant c in the domain of g with g(c).</p><p>Consider a (possibly finite) set T of terms that contains every subterm of every t ∈ T . A constant mapping g is reversible for T if the following hold:</p><p>1. The function g is defined for every constant in T . 2. For every t, s ∈ T with t ̸ = s, we have that g(t) ̸ = g(s). 3. For every constant c ∈ T , every subterm s of g(c), and every functional term u ∈ T ; we have that g(u) ̸ = s.</p><p>Lemma 4. Consider a rule set R, a head-choice hc, an Rtrigger λ = ⟨ρ, σ⟩, and a constant mapping g reversible for skeleton R (λ). If ⟨ρ, g • σ⟩ is an R-trigger and ⟨ρ, σ⟩ is uc/⋆-unblockable for R [and hc], then so is ⟨ρ, g • σ⟩.</p><p>Proof. We define g -1 as follows: For a term t, let g -1 (t) = s if there is a term s that occurs in skeleton R (λ) with g(s) = t, g -1 (t) = t otherwise if t is a constant that does not occur in Cons(skeleton R (⟨ρ, g • σ⟩)) (i.e. g -1 is the identity on fresh constants introduced by h uc ... ), and g -1 (t) = ⋆ otherwise. Note that g -1 is well-defined because g is reversible (cond. 2) for skeleton R (λ).</p><p>Consider the sets F ′ and G ′ of all facts that can be defined using any predicate in R and the constants in Cons(skeleton R (λ)) ∪ {⋆} and Cons(skeleton R (⟨ρ, g • σ⟩)) ∪ {⋆}, respectively. Moreover, consider the fact sets:</p><formula xml:id="formula_13">F = BirthF R (λ) ∪ F ′ and G = BirthF R (⟨ρ, g • σ⟩) ∪ G ′ . Also, let the functions ⟨h F , h G ⟩ be from {⟨h ⋆ λ , h ⋆ ⟨ρ,g•σ⟩ ⟩, ⟨h uc λ , h uc ⟨ρ,g•σ⟩ ⟩}. First claim: g -1 (G) ⊆ F. Since g -1 (G ′ ) ⊆ F</formula><p>follows trivially, we only show g -1 (BirthF R (t)) ⊆ F for every t ∈ Terms(G) via induction over the structure of terms. If t is a constant, then g -1 (BirthF R (t)) = ∅; hence, the base case trivially holds. Regarding the induction step, consider a term t that is of the form f ψ ℓ,y (s): Let z be the list of existentially quantified variables in head ℓ (ψ). Let τ be a substitution with frontier(ψ)τ = s. Moreover, let H = head ℓ (ψ)τ . We only need to show that g -1 (H) ⊆ F to verify the induction step. We observe:</p><formula xml:id="formula_14">If g -1 (f ψ ℓ,z (s)) is functional for some z ∈ z, then g -1 (f ψ ℓ,z ′ (s)) = f ψ ℓ,z ′ (g -1 (s))</formula><p>for each z ′ ∈ z ( †). Now, we perform a case by case analysis on g -1 (t): If g -1 (t) is a functional term, then g -1 (H) = g -1 (head ℓ (ψ)τ ) = head ℓ (ψ)(g -1 • τ ) ⊆ F (by †). If g -1 (t) ∈ Cons \ {⋆}, then g -1 (f ψ ℓ,z (s)) must be a constant for every z ∈ z (by †). Since g is reversible for skeleton R (λ) (cond. 3), g -1 (s) is also a constant (possibly ⋆) for every s ∈ s. Hence,</p><formula xml:id="formula_15">g -1 (H) ⊆ F ′ ⊆ F. If g -1 (t) = ⋆ and g -1 (t ′ ) is a constant (or ⋆) for every t ′ ∈ Terms(H), then g -1 (H) ⊆ F ′ ⊆ F.</formula><p>The remaining case of g -1 (t) = ⋆ and g -1 (t ′ ) / ∈ Cons for a t ′ ∈ Terms(H), contradicts reversibility of g (cond. 3) since then, there must be a constant c with t ′ ∈ subterms(g(c)).</p><p>Second claim: The set g</p><formula xml:id="formula_16">-1 (O(R, [hc, ]⟨ρ, g • σ⟩, h G )) is a subset of O(R, [hc, ]λ, h F ).</formula><p>There exists a finite list of triggers ⟨ψ 1 , τ 1 ⟩, . . . , ⟨ψ m , τ m ⟩ that yields O(R, [hc, ]⟨ρ, g • σ⟩, h G ) from G according to Definition 8. With the first claim as a base case, we can show via induction that the triggers ⟨ψ 1 , g</p><formula xml:id="formula_17">-1 • τ 1 ⟩, . . . , ⟨ψ m , g -1 • τ m ⟩ can be used in the construction of O(R, [hc, ]λ, h F ).</formula><p>We conclude that ⟨ρ, g • σ⟩ is uc/⋆-unblockable for R [and hc] as follows: Suppose for a contradiction that ⟨ρ, g • σ⟩ is not uc/⋆-unblockable. Then, ρ is not datalog and ⟨ρ, g</p><formula xml:id="formula_18">• σ⟩ is obsolete for O(R, ⟨ρ, g • σ⟩, h ⋆ ⟨ρ,g•σ⟩ ) [resp. O(R, hc, ⟨ρ, g • σ⟩, h uc ⟨ρ,g•σ⟩ )]</formula><p>. By the second claim above, we obtain that λ is obsolete for</p><formula xml:id="formula_19">O(R, λ, h ⋆ λ ) [resp. O(R, hc, λ, h uc λ )]</formula><p>. Hence, λ is not uc/⋆-unblockable which contradicts the premise of the lemma.</p><p>Condition 2 in Definition 10 admits an "inverse" of g on term-level. Lemma 4 breaks without it: Example 9. Consider the rule set R = {(10-13)} and the head-choice hc 1 mapping all rules to 1.</p><formula xml:id="formula_20">P (x, y) → ∃u.R(x, u) ∧ S(y, u) (10) R(x, y) → ∃v.T (y, v) (11) R(x, y) ∧ S(x, y) → T (y, x) (12) T (x, y) → P (y, y)<label>(13)</label></formula><p>Consider the substitution σ = [x/c x , y/f u (c x , c y )]; the trigger ⟨(11), σ⟩, which is uc-unblockable for R and hc 1 ; and the constant mapping g that maps c x and c y to f v (f u (c x , c y )), which does not satisfy (2) in Definition 10 for T = skeleton R (⟨(11), σ⟩). Indeed, ⟨(11), g • σ⟩ is not uc-unblockable! Intuitively, rule (12) "blocks" rule (11) if rule (10) is applied with a substitution that maps x and y to the same term, which is the case for g • σ.</p><p>Lemma 4 also breaks without condition 3: Example 10. Consider the head-choice hc 1 mapping all rules to 1, and the rule set R containing the following:</p><formula xml:id="formula_21">A(x) → ∃u.P (x, u) B(x) → ∃v.Q(x, v) C(x) → ∃w.S(x, w) Q(x, y) → T (x) P (x, y) → T (y) ∨ ∃z.R(x, y, z)<label>(14)</label></formula><p>The trigger ⟨( <ref type="formula" target="#formula_21">14</ref>), [x/c, y/f u (d)]⟩ is uc-unblockable; the constant mapping g that maps c to f w (f v (f u (d))) and d to itself satisfies conditions (1) and (2) in Definition 10 for</p><formula xml:id="formula_22">T = skeleton R (⟨(14), [x/c, y/f u (d)]⟩). Con- dition (3) is violated because f u (d) is a subterm of g(c) and g(f u (d)) = f u (d). Indeed, ⟨(14), g • [x/c, y/f u (d)]⟩ is not uc-unblockable! Intuitively, this is because the birth facts feature Q(f u (d), f v (f u (d))</formula><p>), which yields T (f u (d)), thus "blocking" the trigger ⟨( <ref type="formula" target="#formula_21">14</ref>), [x/f w (f v (f u (d))), y/f u (d)]⟩.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Cyclicity Prefixes</head><p>Our high-level strategy to show that a rule set R neverterminates is to find a cyclicity sequence (see Definition 6 and Theorem 1), which is challenging because it is infinite by definition. Instead, we construct a cyclicity prefix for R, which is finite and still yields a cyclicity sequence. Intuitively, a cyclicity prefix is a (finite) list of ucunblockable triggers that, if subsequently applied to a starting database D, produce an isomorphic copy of D that contains at least one new term. We can then repeat the prefix to obtain a cyclicity sequence. To limit the number of starting databases, we only consider minimal databases for that some trigger with a generating rule in R is loaded. Definition 11. The rule-database of a rule ρ is the database D ρ = body(ρ)σ uc where σ uc is a substitution that maps every variable x to a fresh constant c x unique for x.</p><p>Assume that rule ρ can indeed be applied twice when starting on D ρ and that the second application yields a cyclic term. If the triggers applied in between the first and last application of ρ are uc-unblockable, then this finite sequence of triggers is a cyclicity prefix, which can be extended into a cyclicity sequence by applying Lemma 4. Definition 12. A cyclicity prefix for a rule set R, a headchoice hc, and a rule ρ is a (finite) list of R-triggers Λ = ⟨ρ 0 , σ 0 ⟩, . . . , ⟨ρ n , σ n ⟩ such that:</p><p>• Both ρ 0 = ρ and σ 0 agrees with σ uc on frontier(ρ).</p><p>• The sequence Λ is loaded for ⟨R, D ρ ⟩ and hc.</p><p>• Each trigger ⟨ρ i , σ i ⟩ with 1 ≤ i ≤ n is uc-unblockable and ⟨ρ 0 , σ 0 ⟩ is g-unblockable.</p><p>• Both ρ n = ρ and out hc (⟨ρ n , σ n ⟩) features a ρ-cyclic term; that is, a term t that of the form f (s) with f ∈ Funs(sk(ρ)) and f ∈ Funs(s), • The constant mapping g Λ with g Λ • σ 0 = σ n exists and is reversible for skeleton R (⟨ρ i , g j Λ • σ i ⟩) for every 1 ≤ i ≤ n and every j ≥ 0. Note that g 0 Λ is the identity function over constants, and</p><formula xml:id="formula_23">g i Λ = g Λ • g i-1 Λ for every i ≥ 1.</formula><p>We can extend a cyclicity prefix such as Λ above into an infinite sequence of triggers that are defined via composition with the constant-mapping g Λ ; afterwards, we show that this extension is a cyclicity sequence.</p><p>Definition 13. Given a cyclicity prefix Λ = ⟨ρ 0 , σ 0 ⟩, . . . , ⟨ρ n , σ n ⟩ for a rule set R, a head-choice, and a rule in R; let Λ ∞ be the (infinite</p><formula xml:id="formula_24">) sequence ⟨ρ 0 , σ 0 ⟩, ⟨ρ 1 , σ 1 1 ⟩, . . . , ⟨ρ n , σ 1 n ⟩, ⟨ρ 1 , σ 2 1 ⟩, . . . , ⟨ρ n , σ 2 n ⟩, . . . of R-triggers with σ j i = g j-1 Λ • σ i for every 1 ≤ i ≤ n and j ≥ 1.</formula><p>Example 11. The finite trigger sequence</p><formula xml:id="formula_25">⟨(1), [x/c x ]⟩, ⟨(2), [x/f v (c x )]⟩, ⟨(1), [x/f w (f v (c x ))</formula><p>]⟩ is a cyclicity prefix for the rule set {(1), (2)}, head-choice hc 1 , and (1).</p><p>Theorem 3. If Λ is a cyclicity prefix for a rule set R, a headchoice hc, and some ρ ∈ R; then Λ ∞ is a cyclicity sequence for ⟨R, D ρ ⟩ and hc and hence, R never-terminates.</p><p>Proof. Assume that there is a cyclicity prefix Λ = ⟨ρ 0 , σ 0 ⟩, . . . , ⟨ρ n , σ n ⟩ for R, ρ, and hc; and consider the constant-mapping g Λ introduced in Definition 12. To prove Theorem 3, we show that Λ ∞ is a cyclicity sequence of the KB K = ⟨R, D ρ ⟩ and hc. Namely, we argue that Λ ∞ is (a) loaded, (b) growing, and (c) g-unblockable.</p><p>(a): We show that the trigger ⟨ρ i , σ j i ⟩ is loaded in Λ ∞ for every 1 ≤ i ≤ n via induction on j ≥ 1. The base case holds since Λ is loaded. The induction step from j -1 to j holds since g Λ (F</p><formula xml:id="formula_26">(j-1)×n+i (K, hc, Λ ∞ )) is included in F j×n+i (K, hc, Λ ∞ ). (b): Since out hc (⟨ρ n , σ n ⟩) features a ρ-cyclic term, there is some x ∈ frontier(ρ) such that σ n (x) = g Λ (σ 0 (x)) is functional. Note that σ 0 (x) is a constant c, depth(c) = 0 and depth(g Λ (c)) ≥ 1. Furthermore, g Λ (c) features c as a subterm. Hence, g k Λ (c) &gt; g k-1 Λ (c) for every k ≥ 1. But then, by construction of Λ ∞ , g k Λ (c) occurs in F j (K, hc, Λ ∞</formula><p>) for some j ≥ 0. Thus, Λ must be growing.</p><p>(c): We already know by assumption that ⟨ρ 0 , σ 0 ⟩ is gunblockable. We can show via induction over j ≥ 1 that ⟨ρ i , σ j i ⟩ is uc/⋆-unblockable for every 1 ≤ i ≤ n. For the base case with j = 1, the claim holds by assumption. For the induction step from j to j + 1, the claim follows from Lemma 4 since g λ is reversible for skeleton R (⟨ρ i , σ j i ⟩). By Lemma 3, the sequence Λ ∞ is g-unblockable.</p><p>In practice, it is infeasible to compute RPC membership because of the exponential number of head-choices. While this does not influence the complexity bounds (see Theorem 7), this exponential effort manifests often in practice. Instead, we check RPC s that considers far fewer headchoices but still explores a meaningful portion of the search space by using each head-disjunct of each rule at least once: Definition 15. For some i ≥ 1, let hc i be the head-choice such that, for every rule ρ: If i ≤ branching(ρ), then hc i (ρ) = i. Otherwise, hc i (ρ) = branching(ρ). For a rule set R, let branching(R) be the smallest number such that branching(R) ≥ branching(ρ) for every ρ ∈ R.</p><p>A rule set R is RPC s if there is some 1 ≤ i ≤ branching(R), some (generating) ρ ∈ R, and some ρ-cyclic term that occurs in RPC(R, hc i , ρ).</p><p>By Definitions 14 and 15, a rule set R is RPC if it is RPC s . Therefore, the following follows from Theorem 4: Theorem 5. If a rule set is RPC s , then it never-terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deterministic Restricted Prefix Cyclicity</head><p>We introduce deterministic RPC as a less general version of RPC; our goal here is to produce a notion that is similar to RMFC (Carral, Dragoste, and Krötzsch 2017) (see Section 7). It is therefore our baseline in the evaluation (see Section 8). For example, the rule set {(1), (2)} is RPC but not DRPC. Definition 16. For a rule set R and a deterministic rule ρ ∈ R, let DRPC(R, ρ) be a fact set that includes the database D ρ , the set out 1 (⟨ρ, σ uc ⟩), and out 1 (λ) for every deterministic R-trigger λ = ⟨ψ, τ ⟩ such that • there are no cyclic terms in the range of τ , • the trigger λ is loaded for DRPC(R, ρ),</p><p>• the trigger λ is ⋆-unblockable for R, and</p><formula xml:id="formula_27">• the substitution σ is injective if ψ = ρ.</formula><p>A rule set R is deterministic restricted prefix-cyclic (DRPC) if there is some deterministic (generating) rule ρ ∈ R and some ρ-cyclic term that occurs in DRPC(R, ρ). Theorem 6. If a rule set R is DRPC, it never-terminates.</p><p>Proof. By Lemma 3, every ⋆-unblockable trigger is also uc-unblockable for every head-choice. Therefore, we find DRPC(R, ρ) ⊆ RPC(R, hc, ρ) for every deterministic rule ρ ∈ R and every head-choice hc. Hence, if R is DRPC, it is RPC (even RPC s ) and the claim follows by Theorem 4.</p><p>Complexity The complexity of checking cyclicity is dominated by the double-exponential number of (non-cyclic) terms that may occur during the check. That is, checking RPC, RPC s , or DRPC requires at most a doubleexponential number of steps of which each is possible in double-exponential time. Hardness follows similarly to MFA (Cuenca <ref type="bibr">Grau et al. 2013, Theorem 8</ref>): We extend Σ 3 to Σ 4 by adding a fresh atom P ψ (y) to the head of every ψ ∈ Σ 3 where y is the list of all body variables in ψ. By this, we make sure that unblockability does not interfere with the original proof idea. The set Ω is then defined as</p><formula xml:id="formula_28">Σ 4 ∪ {ρ = R(w, x) ∧ B(x) → ∃y.R(x, y) ∧ A(y)}. We find that ⟨Σ 4 , {A(a)}⟩ |= B(a) iff Ω is RPC, RPC s , or DRPC. Theorem 7. Checking (D)RPC (s) is 2EXPTIME-complete.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Our main goal in this paper is to develop very general cyclicity notions for the disjunctive restricted chase. To the best of our knowledge, the only such existing notion is restricted model faithful cyclicity (RMFC), which was introduced by <ref type="bibr" target="#b3">Carral, Dragoste, and Krötzsch in (2017)</ref>. While trying to extend RMFC, we noticed that the proof of Theorem 11 in (2017),<ref type="foot" target="#foot_2">4</ref> which states that RMFC rule sets do not terminate, is incorrect; correctness of the theorem remains open. Example 12. Consider the rule set R = {(15-20)}.</p><p>Cl</p><formula xml:id="formula_29">1 (x) ∧ Cl 2 (y) → ∃u.Red(x, u) ∧ Red(y, u) (15) Cl 1 (x) ∧ Red(x, z) → ∃v.Gr(x, v) ∧ Blu(z, v) (16) Red(y, z) ∧ Blu(z, w) ∧ Gr(x, w) → Gr(y, y) (17) Red(y, z) ∧ Blu(z, w) ∧ Gr(x, w) → Blu(z, y) (18) Red(y, z) ∧ Blu(z, w) ∧ Gr(x, w) → Cl 1 (y) (19) Cl 2 (y) ∧ Gr(y, w) → Cl 2 (w)</formula><p>(20) By Definition 11 in (2017), the rule set R is RMFC because the fact set F (15) features a (15)-cyclic term. As per the proof of Theorem 11 in (2017), the chase of ⟨R, I (15) ⟩ should "contain infinitely many applications of (15)". This is not the case; in fact, the result of the only chase tree of ⟨R, I (15) ⟩ is the set {F} of fact sets where:</p><formula xml:id="formula_30">F ={Cl 1 (c x ), Cl 2 (c y ), Red(c x , t), Red(c y , t), Gr(c x , s), Blu(t, s), Gr(c x , c x ), Blu(t, c x ), Gr(c y , c y ), Blu(t, c y )} In the above, t = f (15) 1,u (c x , c y ) and s = f (16) 1,v (c x , t).</formula><p>The problem stems from issues with Lemma 10 in ( <ref type="formula">2017</ref>), which states that some triggers will eventually be applied if they are loaded for some vertex in the chase. Example 13. By Definition 10 in (2017), a trigger such as λ = ⟨( <ref type="formula">16</ref>), [x/c y , z/f (15)  1,u (c x , c y )]⟩ with c x , c y ∈ Cons is unblockable for the rule set R = {(15-20)}. One can verify that Lemma 10 in (2017) does not hold for this trigger and the KB ⟨R, {Cl 1 (c x ), Cl 2 (c y )}⟩. To do so, simply note that this trigger is loaded for the fact set F defined at the end of Example 12; however, F does not include out 1 (λ). Also, note that λ is not uc/⋆-unblockable.</p><p>We have sought to "repair" RMFC by introducing DRPC. We believe that both coincide for most real-world rule sets.</p><p>Another point of reference for us is our previous work <ref type="bibr">(Gerlach and Carral 2023b)</ref>, where we have introduced Disjunctive Model Faithful Cyclicity (DMFC) for the (disjunctive) skolem chase. We reuse many key ideas (also for the proofs) from this work, e.g. the main results for unblockability and reversiblity. A necessary but straightforward change is the definition of obsoleteness. While the idea of cyclicity sequences and prefixes was used in the proofs in spirit, a proper formalisation had not been presented. Furthermore, uc-unblockability was not considered for DMFC. Let us also stress that a cyclicity notion for the skolem chase is not a sufficient condition for restricted non-termination. There are (many) rule sets that terminate for the restricted chase but not for the skolem chase.</p><p>We have made available all evaluation materials online 5 including source code, rule sets, result files, and scripts used to obtain the counts. In our experiments, we make use of a well-known sufficient condition for restricted chase termination to obtain an upper bound for the cyclicity notions. Definition 17. A term is k-cyclic for some k ≥ 1 if it features k + 1 nested occurrences of the same function symbol. For instance, f (f (a)) is 1-cyclic but g(f (a), f (b)) is not.</p><p>A rule set R is RMFA k for some k ≥ 1 if there are no k-cyclic terms in the fact set RMFA(R), which is introduced in Definition 7 of <ref type="bibr" target="#b3">(Carral, Dragoste, and Krötzsch 2017)</ref>. Theorem 8. RMFA k rule sets (with k ≥ 1) terminate.</p><p>The above result follows from the proof of Theorem 7 in <ref type="bibr" target="#b3">(Carral, Dragoste, and Krötzsch 2017)</ref>.</p><p>Test Suite We consider rule sets from the evaluation of <ref type="bibr">(Gerlach and Carral 2023b)</ref>, which were obtained from OWL ontologies via normalization and translation; see Section 6 in (Cuenca <ref type="bibr" target="#b4">Grau et al. 2013</ref>) for more details. OWL axioms with "at-most restrictions" and "nominals" are dropped because their translation requires the use of equality. The ontologies come from the Oxford Ontology Repository (OXFD) 6 and the Manchester OWL Corpus (MOWL) <ref type="bibr" target="#b13">(Matentzoglu et al. 2014)</ref>. We ignore rule sets without generating rules since these are trivially terminating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results</head><p>For every rule set R in our test suite; we checked if R is RMFA 2 , DRPC, and RPC s using our implementations; we ran each check with a 4h timeout on a cloud instance with 8 threads and 32GB of RAM (comparable to a modern laptop). We present our results in Table <ref type="table" target="#tab_0">1</ref>. We split the rule sets that are purely deterministic (∧) from the ones containing disjunctions (∨). We further split by the number of generating rules #∃ and present the total number of rule sets # for each bucket. For example, in the third row of the table, we indicate that there are 27 deterministic rule sets in OXFD with at least 20 and at most 99 generating rules of which 23 are RMFA 2 , 2 are DRPC, and 3 are RPC s When conidering RMFA 2 together with DRPC or RPC s , the percentages of rule sets that cannot be characterised as either terminating or non-terminating drop from DRPC to RPC s . For MOWL ∧, OXFD ∨, and MOWL ∨, the drops are from 5% to 3%, 37% to 6%, and 45% to 5%, respectively; for OXFD ∧ the percentage is around 21% for both. Our improvements are significant on the datasets with disjunctions; for these, RPC is considerably more general than DRPC, (which we introduced as a replacement for RMFC).</p><p>While many of the non-classified rule sets simply result from timeouts, there are 38 rule sets in OXFD for which both RMFA 2 and DRPC finished without capturing the rule set. Analogously, with RPC s , we find 7 rule sets. For MOWL the numbers are 1505 and 110. This indicates that there is still room for improvement on the theoretical side but also that timeouts are indeed a big issue, which happens often when we consider large datasets. We make three tangible contributions: (i) We define RPC; a very general cyclicity notion tailored for rule sets with disjunctions. (ii) We discovered problems with RMFC and defined DRPC as a "repaired" version of this notion. (iii) We present an evaluation to demonstrate the usefulness of our work. Beyond these three, we believe that our efforts provide a framework for interesting future work.</p><p>Extending Cyclicity Notions Despite the fact that RPC is more general than existing criteria, there are many rule sets in our evaluation that remain open; that is, rule sets cannot be characterised as terminating or non-terminating.</p><p>Our work provides three different main strategies to achieve possible extensions. The first one is to produce "weaker" over-approximations and thus a more general strategy to detect g-unblockability; even g-unblockability itself can be relaxed. The second is to generalize cyclicity prefixes; perhaps by checking loadedness from slightly different databases. For instance, the rule set R from Example 12 is neither DRPC nor RPC (as intended) but actually it is never-terminating; note that ⟨R, {Cl 1 (c), Cl 2 (c)}⟩ does not admit finite chase trees. The third one is to develop more comprehensive search strategies to find cyclicity prefixes; for instance, we can relax the condition in the first item of Definition 14 to look a bit further.</p><p>Explaining Cyclicity In many real-world use-cases, the existence of infinite universal models highlights a modelling mistake. We can use RPC and DRPC as methods to explain the loss of termination. For instance, a cyclicity prefix as defined in Section 5 constitutes a small and clear explanation of one way of loosing termination. In the future, we aim to automatically compute minimal sets of rules that can be removed (or added!) to deactivate a cyclicity prefix.</p><p>skeleton R (ρ, σ) with g(g -1 (t ′ )) = t ′ , which contradicts reversibility of g.</p><p>Proof (Second claim extended). Namely, we show that g</p><formula xml:id="formula_31">-1 (O(R, [hc, ]⟨ρ, g • σ⟩, h G )) ⊆ O(R, [hc, ]λ, h F ).</formula><p>Consider a finite list of triggers λ 1 , . . . , λ m such that all of the following hold:</p><formula xml:id="formula_32">• O(R, [hc, ]⟨ρ, g • σ⟩, h G ) = G ∪ m i=1 h G (O i ) with O i = out(λ i ) [resp. O i = out hc (λ i )]. • λ i is loaded for G ∪ i-1 j=1 h G (O j ). • Let ⟨ψ i , τ i ⟩ = λ i . We have ψ i ̸ = ρ or out k (⟨ρ, g • σ⟩) ̸ = out k (λ i ) for some 1 ≤ k ≤ branching(ρ). [Resp.: We have out hc (⟨ρ, g • σ⟩) ̸ = out hc (λ i ).] We show that g -1 (G ∪ i j=1 h G (O j )) is a subset of O(R, [hc, ]λ, h F ) via induction over 0 ≤ i ≤ m. We have already shown the base case with i = 0, i.e. g -1 (G) ⊆ F ⊆ O(R, [hc, ]λ, h F ).</formula><p>Assume for the induction hypothesis that g</p><formula xml:id="formula_33">-1 (G ∪ i j=1 h G (O j )) is a subset of O(R, [hc, ]λ, h F ) for some i ≥ 1.</formula><p>To verify the induction step we only need to show that g</p><formula xml:id="formula_34">-1 (h G (O i+1 )) ⊆ O(R, [hc, ]λ, h F ).</formula><p>a. For the trigger ⟨ψ i+1 , τ i+1 ⟩ = λ i+1 , we find that the fact sets g</p><formula xml:id="formula_35">-1 (h G ( out(⟨ψ i+1 , τ i+1 ⟩))) and h F ( out(⟨ψ i+1 , g -1 • τ i+1 ⟩)) are equal. [Respec- tively: The fact sets g -1 (h G (out hc (⟨ψ i+1 , τ i+1 ⟩))) and h F (out hc (⟨ψ i+1 , g -1 • τ i+1 ⟩)) are equal.] b. By ind.-hypothesis, the trigger ⟨ψ i+1 , g -1 • τ i+1 ⟩ is loaded for O(R, [<label>hc</label></formula><p>, ]λ, h F ). c. Assume for a contradiction that ψ i+1 = ρ and that for every 1 ≤ k ≤ branching(ρ), we obtain equality of out k (λ) and out k (⟨ψ i+1 , g -1 • τ i+1 ⟩). [Resp.: Assume that out hc (λ) = out hc (⟨ψ i+1 , g -1 • τ i+1 ⟩).] Then, the output equalities also hold for ⟨ρ, g • σ⟩ and ⟨ψ i+1 , g • g -1 • τ i+1 ⟩. Furthermore, the respective outputs of ⟨ψ i+1 , g • g -1 • τ i+1 ⟩ and ⟨ψ i+1 , τ i+1 ⟩ are equal. Therefore, we find a contradiction to the definition of λ 1 , . . . , λ m above. d. By (a), (b), and (c): the induction step holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Proof of Theorem 3</head><p>We ellaborate on (a):</p><p>Proof ((a) extended). We show via induction over j ≥ 1 that ⟨ρ i , σ j i ⟩ is loaded for every 1 ≤ i ≤ n. The base case with j = 1 holds since Λ is loaded. We show the induction step from j to j + 1. By induction hypothesis, ⟨ρ i , σ j i ⟩ is loaded for F (j-1)×n+i (K, hc, Λ ∞ ). By construction, ⟨ρ i , σ j+1 i ⟩ is loaded for g Λ (F (j-1)×n+i (K, hc, Λ ∞ )). Furthermore, we have g Λ (F (j-1)×n+i (K, hc, Λ ∞ )) ⊆ F j×n+i (K, hc, Λ ∞ ) by an inductive argument over the construction of Λ ∞ with the base case of having g Λ (F 1 (K, hc, Λ ∞ )) ⊆ F n+1 (K, hc, Λ ∞ ). Note that the latter holds since ρ n = ρ and g Λ • σ 0 = σ n . Hence, ⟨ρ i , σ j+1 i ⟩ is loaded for F j×n+i (K, hc, Λ ∞ ), which yields the induction step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F Proof of Theorem 4</head><p>We ellaborate on the last part of (B):</p><p>Proof (last part of (B) extended). We show in more detail that h(out hc (⟨ψ i , h • g Λ • τ i ⟩)) ⊆ O for every 1 ≤ i ≤ m. First, we show h(g Λ (fct(v 0 )) = h(body(ρ)(g Λ • σ uc )) ⊆ O by making use of the triggers in Λ: a. We have that h(out hc (⟨ρ, σ uc ⟩)) = out hc (⟨ρ, σ uc ⟩) ⊆ BirthF R (⟨ρ, g Λ • σ uc ⟩). Also, h(D ρ ) is contained in the set of all facts that can be defined using any predicate and constants from Cons(skeleton R (⟨ρ, g Λ • σ uc ⟩)) ∪ {⋆}. b. By (a) and since Λ is loaded, the trigger ⟨ρ i , h • σ i ⟩ is loaded for h(F i-1 (⟨R, D ρ ∪ out hc (⟨ρ, σ uc ⟩)⟩, hc, Λ)) for every 1 ≤ i ≤ n. c. Since ⟨ρ, g Λ • σ uc ⟩ is the first trigger that yields a ρ-cyclic term, out hc (⟨ρ, g Λ • σ uc ⟩) ̸ = out hc (⟨ρ i , h • σ i ⟩) for every 1 ≤ i ≤ n -1. d. By (a), (b), (c), we find h(out hc (⟨ρ i , h • σ i ⟩)) ⊆ O for every 1 ≤ i ≤ n -1, which with (b) concludes the claim. Now, h(out hc (⟨ψ i , h</p><formula xml:id="formula_36">• g Λ • τ i ⟩)) ⊆ O for 1 ≤ i ≤ m.</formula><p>a. We find that each trigger ⟨ψ i , h • g Λ • τ i ⟩ is loaded for h(body(ρ)(g Λ •σ uc ))∪ i-i j=1 h(out hc (⟨ψ j , h • g Λ • τ j ⟩)). b. Since out hc (⟨ρ, σ uc ⟩) ⊈ fct(w), we necessarily have that out hc (⟨ψ i , τ i ⟩) ̸ = out hc (⟨ρ, σ uc ⟩). But then also, out hc (⟨ψ i , h • g Λ • τ i ⟩) ̸ = out hc (⟨ρ, g Λ • σ uc ⟩). c. The claim follows from (a), (b), and the first claim shown in the previous enumeration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G Proof of Theorem 7</head><p>Proof. Membership. The number of rules to consider is linear in R. The number of head-choices to consider is (at most) exponential in R. The number of non-cyclic terms and therefore the number of triggers that need to be considered for any rule and head-choice is double-exponentially bounded in the size of R. In particular, checking that a trigger is loaded and uc/⋆-unblockable takes at most doubleexponential time. All together, checking (D)RPC (s) requires at most a double-exponential number of steps of which each is possible in double-exponential time.</p><p>Hardness. Following the hardness result for MFA (Cuenca <ref type="bibr">Grau et al. 2013, Theorem 8)</ref>, we use a reduction from the problem of conjunctive query entailment over weakly acyclic rule set R (which is called Σ in the original proof). Let R ′ be the weakly-acyclic rule set that results from R such that R ′′ = R ′ ∪ {ρ = R(w, x) ∧ B(x) → ∃y.R(x, y) ∧ A(y)} is MFA iff ⟨R ′ , {A(a)}⟩ ̸ |= B(a) according to the construction by Cuenca Grau et al. In the original proof R ′ corresponds to Σ 3 (Cuenca <ref type="bibr">Grau et al. 2013, Theorem 8)</ref>. In turn, the rule set R ′′ corresponds to Ω (Cuenca <ref type="bibr">Grau et al. 2013, Lemma 7)</ref>. Note that R ′ is weakly-acyclic and thus also MFA and that no atom with R occurs in R ′ . We further extend every rule ψ ∈ R ′ to obtain R ′′′ by adding a fresh atom P ψ (y) to the head of ψ where y is the list of all universally quantified variables in ψ. Then, similar to R ′′ , we set R ′′′′ = R ′′′ ∪ {ρ}. Again, R ′′′ is weakly-acyclic and MFA. Since R ′′′′ is deterministic, we consider the head-choice hc that maps all rules to 1.</p><p>For (D)RPC (s) , out hc (⟨ρ, σ uc ⟩) already includes R(c x , f ρ 1,y (c x )) and A(f ρ 1,y (c x )). Since R ′′′ is MFA, there are no cyclic terms in the (D)RPC (s) construction that do not feature a term from out hc (⟨ρ, σ uc ⟩). Therefore, if ⟨R ′′′ , {A(a)}⟩ ̸ |= B(a), then no other trigger for ρ is loaded and thus, R ′′′′ is not (D)RPC (s) . For any other rule ψ ∈ R ′′′ , the (D)RPC (s) construction fails because R ′′′ is MFA and ρ can never be applied because the predicate R only occurs in ρ. Hence, R ′′′′ is not (D)RPC (s) . Otherwise, if ⟨R ′′′ , {A(a)}⟩ |= B(a), we show that the sequence of R ′′′ -triggers that can derive B(a) from A(a) can be used in the construction of (D)RPC (s) . Since R does not occur in R ′′′ and B only occurs in a rule head in R ′′′ , A(f ρ 1,y (c x )) is the only usable fact when starting to construct the chase derivation for (D)RPC (s) . Hence, every trigger that becomes loaded in the contruction features a functional term in the image of its substitution. Since every rule in R ′′′ contains a head-atom featuring all universal variables, each of the loaded triggers is also uc/⋆-unblockable. Since R ′′′ is MFA, every loaded trigger does not feature cyclic terms. By that, we obtain, if ⟨R ′′′ , {A(a)}⟩ |= B(a), then B(f ρ 1,y (c x )) occurs in the construction of (D)RPC (s) . The trigger ⟨ρ, [w/c x , x/f ρ 1,y (c x )]⟩ has an injective substitution. Therefore we obtain a ρ-cyclic term in A(f ρ 1,y (f ρ 1,y (c x ))) and thus, R is (D)RPC (s) .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Chase Tree for Example 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>5 https://doi.org/10.5281/zenodo.8005904 Gerlach and Carral 6 https://www.cs.ox.ac.uk/isg/ontologies/ Restricted Chase Termination: Generating Rule Sets 9 Conclusions and Future Work</figDesc><table><row><cell></cell><cell>#∃</cell><cell cols="3"># tot. RMFA 2 DRPC</cell><cell>RPC s</cell></row><row><cell>OXFD ∧</cell><cell cols="2">1-19 20-99 100-999 109 58 27 1-999 194</cell><cell>58 23 61 142</cell><cell>0 2 8 10</cell><cell>0+0 2+1 8+1 10+2</cell></row><row><cell>MOWL ∧</cell><cell>1-19 20-99 100-999 1-999</cell><cell>1139 269 363 1771</cell><cell>866 228 271 1365</cell><cell>239 27 46 312</cell><cell>239+12 27+5 46+21 312+38</cell></row><row><cell>OXFD ∨</cell><cell cols="2">1-19 20-99 100-999 147 37 18 1-999 102</cell><cell>32 4 8 44</cell><cell>0 7 13 20</cell><cell>0+5 7+7 13+20 20+32</cell></row><row><cell>MOWL ∨</cell><cell cols="2">1-19 20-99 100-999 1150 1361 894 1-999 3405</cell><cell>806 196 500 1502</cell><cell>48 171 136 355</cell><cell>48+405 171+496 136+470 355+1371</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This report features additional proof details in the appendix.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The "g-" prefix stands for "general-"; we introduce more specific unblockability notions in the following section.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>Henceforth, we simply use (2017) as an abbreviation of (Carral, Dragoste, and Krötzsch 2017).</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>Lukas is / has been funded by <rs type="funder">Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)</rs> in project <rs type="grantNumber">389792660</rs> (<rs type="grantNumber">TRR 248</rs>, <rs type="funder">Center for Perspicuous Systems)</rs>, by the <rs type="funder">Bundesministerium für Bildung und Forschung (BMBF, Federal Ministry of Education and Research)</rs> under <rs type="funder">European ITEA</rs> project <rs type="grantNumber">01IS21084</rs> (<rs type="projectName">InnoSale</rs>, <rs type="projectName">Innovating Sales and Planning of Complex Industrial Products Exploiting Artificial Intelligence</rs>), by <rs type="funder">BMBF</rs> and <rs type="funder">DAAD (German Academic Exchange Service)</rs> in project <rs type="grantNumber">57616814</rs> (<rs type="projectName">SECAI</rs>, <rs type="projectName">School of Embedded</rs> <rs type="funder">and Composite AI)</rs>, and by the <rs type="funder">Center for Advancing Electronics Dresden (cfaed)</rs>.</p><p>David is funded by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_xSMFNHB">
					<idno type="grant-number">389792660</idno>
				</org>
				<org type="funding" xml:id="_kFWezjs">
					<idno type="grant-number">TRR 248</idno>
				</org>
				<org type="funded-project" xml:id="_3qWRkrv">
					<idno type="grant-number">01IS21084</idno>
					<orgName type="project" subtype="full">InnoSale</orgName>
				</org>
				<org type="funded-project" xml:id="_wPEsw85">
					<orgName type="project" subtype="full">Innovating Sales and Planning of Complex Industrial Products Exploiting Artificial Intelligence</orgName>
				</org>
				<org type="funded-project" xml:id="_bvWWzuQ">
					<idno type="grant-number">57616814</idno>
					<orgName type="project" subtype="full">SECAI</orgName>
				</org>
				<org type="funded-project" xml:id="_gA2tc5g">
					<orgName type="project" subtype="full">School of Embedded</orgName>
				</org>
				<org type="funded-project" xml:id="_htcdyUk">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Novel Cyclicity Notions</head><p>Theorem 3 provides a blueprint to show non-termination of a rule set R: One simply has to show that R admits a (finite) cyclicity prefix. In this section, we present two different ways to do so, namely RPC and DRPC, which we then use to define several cyclicity notions.</p><p>Restricted Prefix Cyclicity We introduce restricted prefix-cyclicity as the most general notion that we can define using our previous considerations: Definition 14. For a rule set R, a head-choice hc, and a rule ρ ∈ R; let RPC(R, hc, ρ) be the fact set that includes the database D ρ , the set out hc (⟨ρ, σ uc ⟩), and out hc (λ) for every R-trigger λ = ⟨ψ, τ ⟩ such that</p><p>• there are no cyclic terms in the range of τ ,</p><p>• the trigger λ is loaded for RPC(R, hc, ρ),</p><p>• the trigger λ is uc-unblockable for R and hc, and</p><p>A rule set R is restricted prefix-cyclic (RPC) if there is some head-choice hc, some (generating rule) ρ ∈ R, and some ρ-cyclic term that occurs in RPC(R, hc, ρ).</p><p>The first restriction ensures that RPC(R, hc, ρ) is finite. The second and third are necessary by Definition 12. Note that ⟨ρ, σ uc ⟩ also needs to be g-unblockable but it is not uc-unblockable by definition. We show later that gunblockability for ⟨ρ, σ uc ⟩ still follows if we can find a ρcyclic term. The fourth restriction ensures that we can find a reversible constant mapping for the cyclicity-prefix. Example 9 shows a rule set that is terminating but would be wrongly marked as RPC if we omit the fourth restriction.</p><p>Theorem 4. If a rule set R is RPC, then it never-terminates.</p><p>Proof. By Definition 14, there exists a finite trigger sequence Λ = ⟨ρ, σ uc ⟩, λ 1 = ⟨ρ 1 , σ 1 ⟩, . . . , λ n = ⟨ρ n , σ n ⟩ that yields a (first) ρ-cyclic term in RPC(R, hc, ρ) with ρ n = ρ and no cyclic term in the image of every substitution σ i for 1 ≤ i ≤ n, and a constant mapping g Λ for that we find g Λ • σ uc = σ n . Furthermore, Λ is loaded for ⟨R, D ρ ⟩ and hc, and the triggers λ 1 , . . . , λ n are uc-unblockable.</p><p>To prove that Λ is a cyclicity-prefix for R, hc, and ρ, it only remains to show that (A) g Λ is reversible for skeleton R (⟨ρ i , g j Λ • σ i ⟩) for each 1 ≤ i ≤ n and j ≥ 0 and that (B) ⟨ρ, σ uc ⟩ is g-unblockable.</p><p>(A): Considering Definition 10, we show conditions (1), (2), and (3). Since Cons(skeleton R (⟨ρ i , g j Λ • σ i ⟩)) may only feature constants from D ρ , (1) holds. For (2) and (3), we make the following observations:</p><p>The substitutions of the triggers in Λ do not feature cyclic terms. Hence, for every constant c in D ρ , the term g Λ (c) does not feature nested function symbols from sk(ρ). 3 We show that, for any functional term t in skeleton R (⟨ρ i , g j Λ • σ i ⟩) (for any j and i), the term g(t)</p><p>3 Consider the rule ρ = A(x) → ∃y, z.R(x, y) ∧ S(x, z). Then, f y (f z (c)) features nested function symbols from sk(ρ) but f w (f y (d), f z (c)) does not (assuming w occurs in another rule).</p><p>features nested function symbols from sk(ρ): Every nondatalog trigger without functional terms in frontier positions is not uc-unblockable. Hence, t must have a subterm of the form f (c) such that f occurs in sk(ρ) and c = σ uc (frontier(ρ)). Also, for some x ∈ frontier(ρ n ), g Λ (σ uc (x)) is a functional term from out hc (⟨ρ, σ uc ⟩). Thus, f (g Λ (c)) ∈ subterms(g(t)) features nested function symbols from sk(ρ).</p><p>By Definition 14, g Λ • σ uc is injective and in turn g Λ is injective on the constants in D ρ . We show (2) that g Λ (t) ̸ = g Λ (s) for every t, s in skeleton R (⟨ρ i , g j Λ • σ i ⟩) with t ̸ = s: If t and s are constants, then g Λ (t) ̸ = g Λ (s) since g Λ is injective. If t is a constant and s is functional (or vice versa), then g Λ (s) features nested function symbols from sk(ρ) and g Λ (t) does not (or vice versa) by the above observations. If t and s are functional terms of the form f (t) and h(s), respectively, with f ̸ = h; then g Λ (t) ̸ = g Λ (s) holds. If t and s are functional terms (of finite depth) of the form f (t 1 , . . . , t n ) and f (s 1 , . . . , s n ), respectively; then t i ̸ = s i for some 1 ≤ i ≤ n since t ̸ = s and we can recurse into one of the cases for t i , s i .</p><p>For (3), consider c ∈ Cons(skeleton R (⟨ρ i , g j Λ • σ i ⟩)) ⊆ Cons(D ρ ) and some s ∈ subterms(g Λ (c)). If there was a functional term u ∈ skeleton R (⟨ρ i , g j Λ • σ i ⟩) with g Λ (u) = s, we obtain a contradiction from the above observations, as s ∈ subterms(g Λ (c)) does not feature nested function symbols from sk(ρ) but g Λ (u) = s does. Thus, (A) holds.</p><p>(B): In the remainder of the proof, we show that ⟨ρ, σ uc ⟩ is g-unblockable for ⟨R, D ρ ⟩ and hc. Suppose for a contradiction that ⟨ρ, σ uc ⟩ is not g-unblockable. We obtain the contradiction by showing that ⟨ρ, g Λ • σ uc ⟩ is not uc-unblockable.</p><p>There exists a chase tree T = ⟨V, E, fct, trg⟩ for ⟨R, D ρ ⟩ and hc such that out hc (⟨ρ, σ uc ⟩) ⊈ fct(u) for each u ∈ branch(T, hc). Note that ⟨ρ, σ uc ⟩ is loaded for fct(v) for every v ∈ branch(T, hc) since it is loaded for D ρ . There must exists a (first) w ∈ branch(T, hc) such that ⟨ρ, σ uc ⟩ is obsolete for fct(w). Consider the path v 0 , . . . , v m in T with v 0 the root and v m = w. Let ⟨ψ 1 , τ 1 ⟩, . . . , ⟨ψ m , τ m ⟩ = trg(v 1 ), . . . , trg(v m ). We aim to show that h(out hc (⟨ψ i , h</p><p>Then, we find that ⟨ρ, g Λ • σ uc ⟩ is not uc-unblockable, i.e. the desired contradiction.</p><p>First, we find that h(g</p><p>) is contained in the set of all facts that can be defined using any predicate and constants from Cons(skeleton R (⟨ρ, g Λ • σ uc ⟩)) ∪ {⋆}. Since Λ is loaded, we can now show that h(out hc (⟨ρ i , h</p><p>The latter is the case since out hc (⟨ρ, σ uc ⟩) ⊈ fct(w). Therefore, ⟨ρ, g Λ • σ uc ⟩ is not ucunblockable; contradiction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proof of Theorem 1</head><p>We ellaborate on the last part of the proof:</p><p>Proof (Last part extended). To prove that F(T, hc) is infinite, we verify that (A) i≥0 F i (K, hc, Λ) is infinite and that (B) F i (K, hc, Λ) ⊆ F(T, hc) for every i ≥ 0.</p><p>• Claim (A) follows from the fact that Λ is growing. This requirement implies that, for every i ≥ 0, there is some j &gt; i such that F i (K, hc, Λ) ⊂ F j (K, hc, Λ). • We show Claim (B) via induction on i ≥ 0. The base case holds since F(T, hc) includes D = fct(v 1 ). Regarding the induction step, consider some i ≥ 1 and assume that the induction hypothesis holds; that is, that F(T, hc) includes F i-1 (K, hc, Λ). Therefore, there is some j ≥ 1 such that F i-1 (K, hc, Λ) ⊆ fct(v j ) and hence, λ i is loaded for fct(v j ). Since λ i is g-unblockable, out hc (λ i ) ⊆ fct(v k ) for some k ≥ 1 and hence,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Proof of Theorem 2</head><p>Proof. We present a reduction from the undecidable problem of checking if a deterministic KB ⟨R, D⟩ entails a fact P(c) <ref type="bibr" target="#b1">(Beeri and Vardi 1981)</ref>. Consider the head-choice hc 1 that maps all rules to 1, and the rule set R ′ = R∪{ρ} where ρ = P(x) → ∃y.P(y); note that R and R ′ are equivalent since ρ is tautological. We show that ⟨R, D⟩ |= P(c) iff λ = ⟨ρ, [x/c]⟩ is not g-unblockable for R ′ and hc 1 :</p><p>The trigger λ is obsolete for a fact set when it is loaded. Hence, if ⟨R, D⟩ entails P(c), then λ is not g-unblockable for ⟨R ′ , D⟩ and hc 1 . If ⟨R, D⟩ ̸ |= P(c), then λ is never loaded in any fact-label of a chase tree of ⟨R ′ , D⟩ and therefore trivially g-unblockable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Proof of Lemma 2</head><p>Proof (Second condition of Definition 7). Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, D⟩. Moreover, consider a vertex u ∈ branch(T, hc) in T such that out hc (λ) ⊈ fct(u). To verify the lemma, we show that h(fct(u)) ⊆ O(R, hc, λ, h). More precisely, we show via induction that h(fct(u i )) ⊆ O(R, hc, λ, h) for every vertex u i in the path u 1 , . . . , u n in T that starts with the root and ends in u.</p><p>• The base case holds by Condition (d) for h. Note that O(R, hc, λ, h) includes h(D) by ( <ref type="formula">1</ref>) in Definition 8. • Regarding the induction step, consider some i ≥ 2.</p><p>By induction hypothesis, h(fct(u i-1 )) ⊆ O(R, hc, λ, h) and hence, ⟨ψ, h • τ ⟩ is loaded for O(R, hc, λ, h) where trg(u i ) = ⟨ψ, τ ⟩. Since out hc (λ) ⊈ fct(u), we have that out hc (trg(u i )) ̸ = out hc (λ). By Definition 8, we have that h(out hc (⟨ψ, h • τ ⟩)) ⊆ O(R, hc, λ, h).Therefore, by assumptions (b-c), h(fct(u i )) ⊆ O(R, hc, λ, h) holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Proof of Lemma 4</head><p>We elaborate on the first and second claims made in the main part of the proof.</p><p>Proof (First claim extended). We show that g -1 (G) is a subset of F. Since g -1 (G ′ ) ⊆ F follows trivially, we only have to show that g -1 (BirthF R (t)) ⊆ F for every t ∈ Terms(G); we do so via induction over the structure of terms. If t is a constant, then g -1 (BirthF R (t)) = ∅; hence, the base case trivially holds. Regarding the induction step, consider a term t that is of the form f ψ ℓ,y (s):</p><p>a. By ind.-hyp.: g -1 (BirthF R (s)) ⊆ F for every s ∈ s. b. Let z be the list of existentially quantified variables in head ℓ (ψ). Let τ be a substitution with frontier(ψ)τ = s. Moreover, let H = head ℓ (ψ)τ . c. By definition: BirthF R (t) = H ∪ s∈s BirthF R (s).</p><p>d. By (a) and (c): We only need to show that g -1 (H) ⊆ F to verify the induction step. In fact, g -1 (H) ⊆ F follows from (f), (g), (h), and (i), which amount to a comprehensive case-by-case analysis.</p><p>e. We observe:</p><p>) is a constant for every z ∈ z by (e). Since g is reversible for skeleton R (λ), g -1 (s) is also a constant (possibly ⋆) for every s ∈ s. Therefore, g -1 (H) ⊆ F ′ ⊆ F. h. If g -1 (t) = ⋆ and g -1 (t ′ ) is a constant (or ⋆) for every t ′ ∈ Terms(H), then g -1 (H) ⊆ F ′ ⊆ F. i. We show that assuming g -1 (t) = ⋆ and g -1 (t ′ ) / ∈ Cons for some t ′ ∈ Terms(H) results in a contradiction: Note that t ′ is necessarily functional because g -1 (t ′ ) is. By (e), t ′ can only occur in s. Therefore, we have that, t ′ ̸ = t is a subterm of t such that g -1 (t ′ ) is functional. At the same time, for t to occur in skeleton R (⟨ρ, g • σ⟩), there needs to be a constant c that occurs in the image of σ restricted to frontier(ρ) such that t occurs in BirthF R (g(c)). Suppose for a contradiction that no such constant exists, i.e. there exists a functional term u that occurs in the image of σ restricted to frontier(ρ) such that t occurs in BirthF R (g(u)) but t does not occur in BirthF R (g(u ′ )) for any subterm u ′ of u with u ′ ̸ = u. Since g -1 (t) is not functional, t must occur in BirthF R (q) for a subterm q of g(u) with q ̸ = g(u) by (e). But then, there exists a subterm u ′ of u with u ′ ̸ = u that occurs in the image of σ restricted to frontier(ρ) with g(u ′ ) = q since u is functional. Since t occurs in BirthF R (g(u ′ )), we obtain the desired contradiction and know that a constant c of the desired form must exist. But then for c ∈ Cons(skeleton R (ρ, σ)), we have t ′ ∈ subterms(g(c)) and there is a functional term g -1 (t ′ ) ∈</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Extending acyclicity notions for existential rules</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Garreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st European Conference on Artificial Intelligence (ECAI 2014)</title>
		<title level="s">Frontiers in Artificial Intelligence and Applications</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Schaub</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Friedrich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>O'sullivan</surname></persName>
		</editor>
		<meeting>the 21st European Conference on Artificial Intelligence (ECAI 2014)<address><addrLine>Czech Republic</addrLine></address></meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">263</biblScope>
			<biblScope unit="page" from="39" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The implication problem for data dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Colloquium on Automata, Languages and Programming (ICALP</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">O</forename><surname>Kariv</surname></persName>
		</editor>
		<meeting>the 8th International Colloquium on Automata, Languages and Programming (ICALP<address><addrLine>Israel</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1981">1981. 1981</date>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="73" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Guarded-based disjunctive tuple-generating dependencies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Morak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions On Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Restricted chase (non)termination for existential rules with disjunctions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Joint Conference on Artificial Intelligence (IJCAI 2017)</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Sierra</surname></persName>
		</editor>
		<meeting>the 26th International Joint Conference on Artificial Intelligence (IJCAI 2017)<address><addrLine>Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="922" to="928" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Acyclicity notions for existential rules and their application to query answering in ontologies</title>
		<author>
			<persName><forename type="first">Cuenca</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kupke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Magka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Resesearch (JAIR)</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="741" to="808" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Data exchange: semantics query answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Gerlach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<idno type="DOI">10.5281/zenodo.8005904</idno>
		<ptr target="https://doi.org/10.5281/zenodo.8005904" />
		<title level="m">Do repeat yourself: Understanding sufficient conditions for restricted chase nontermination: Evaluation materials</title>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">General acyclicity and cyclicity notions for the disjunctive skolem chase</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gerlach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Seventh AAAI Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Williams</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Neville</surname></persName>
		</editor>
		<meeting>the Thirty-Seventh AAAI Conference on Artificial Intelligence<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2023">2023. 2023</date>
			<biblScope unit="page" from="6372" to="6379" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">All-instances termination of chase is undecidable</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gogacz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marcinkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st International Colloquium on Automata, Languages, and Programming (ICALP 2014)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Fraigniaud</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Husfeldt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Koutsoupias</surname></persName>
		</editor>
		<meeting>the 41st International Colloquium on Automata, Languages, and Programming (ICALP 2014)<address><addrLine>Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8573</biblScope>
			<biblScope unit="page" from="293" to="304" />
		</imprint>
	</monogr>
	<note>Part II</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Anatomy of the chase</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Onet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Restricted chase termination for existential rules: A hierarchical approach and experimentation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Karimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>You</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory and Practice of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="4" to="50" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Extending decidable existential rules by joining acyclicity and guardedness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI 2011)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI 2011)<address><addrLine>Spain</addrLine></address></meeting>
		<imprint>
			<publisher>IJCAI/AAAI</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="963" to="968" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Generalized schema-mappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">B</forename><surname>Marnette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS 2009)</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</editor>
		<meeting>the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS 2009)<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The manchester OWL repository: System description</title>
		<author>
			<persName><forename type="first">N</forename><surname>Matentzoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Semantic Web Conference (ISWC 2014), Posters &amp; Demonstrations Track</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Horridge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rospocher</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Ossenbruggen</surname></persName>
		</editor>
		<meeting>the 13th International Semantic Web Conference (ISWC 2014), Posters &amp; Demonstrations Track<address><addrLine>Italy</addrLine></address></meeting>
		<imprint>
			<biblScope unit="volume">1272</biblScope>
			<biblScope unit="page" from="285" to="288" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
