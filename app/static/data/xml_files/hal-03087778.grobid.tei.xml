<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">F ROM D IAGRAM TO C ODE : A W EB -BASED I NTERACTIVE G RAPH E DITOR FOR F AUST DSP D ESIGN AND C ODE G ENERATION</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Shihong</forename><surname>Ren</surname></persName>
							<email>renshihong@hotmail.com</email>
						</author>
						<author>
							<persName><forename type="first">Laurent</forename><surname>Pottier</surname></persName>
							<email>laurent.pottier@univ-st-etienne.frmichel.buffa@univ-cotedazur.fr</email>
						</author>
						<author>
							<persName><forename type="first">Michel</forename><surname>Buffa</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Jean Monnet Université Jean Monnet Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">INRIA Saint-Etienne</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Saint-Etienne</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Sophia Antipolis</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">F ROM D IAGRAM TO C ODE : A W EB -BASED I NTERACTIVE G RAPH E DITOR FOR F AUST DSP D ESIGN AND C ODE G ENERATION</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D8464C55119F9CE5058CBEB1CC29D15F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>F AUST , as a domain-specific language (DSL) initially designed to represent block-diagram algebra [1], is efficient through its syntax to describe DSPs because of its structural similarity to physical signal processing devices. This approach allows the F AUST compiler to generate an equivalent graphical representation of the coded algorithm as a block-diagram. Considering the nature of the language, the reverse should be possible as well (compiling an equivalent F AUST DSP code from a block-diagram). This paper discusses the possibility to achieve this process and proposes a web-based block-diagram graph editor for designing F AUST DSP.</p><p>1.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INTRODUCTION</head><p>Many visual programming languages (VPLs) such as Max <ref type="bibr" target="#b1">[2]</ref> or PureData <ref type="bibr" target="#b2">[3]</ref> provide a graphic canvas to allow developers to connect functions or data between them. This canvas with connected objects, also known as a patcher <ref type="bibr" target="#b3">[4]</ref>, is basically a graph, meant to be interpreted as dataflow computation <ref type="bibr" target="#b4">[5]</ref> by the system. These visual languages are user-friendly as they seem closer to the way things work in our physical world, especially in the audio processing field. Connecting signal processors using audio cables to produce sounds and effects is a common practice even though we can now bring this practice to the digital world. This is one of the reasons for the design of the F AUST programming language, that represents its code with its patcher-like graph called block-diagram algebra (BDA) <ref type="bibr" target="#b5">[6]</ref>.</p><p>By adopting the BDA as the core of the language, the drawbacks of the graph representation and dataflow model <ref type="bibr" target="#b6">[7]</ref> are discussed mainly due to the complexity and difficulty on the performance optimization aspect and the lack of an explicit semantic of the algorithm written. As a result, F AUST is designed to be closer to machine-friendliness. It is, in the end, a text-based language that can be represented as a BDA that is optimized and transformed into a high-performance low-level code.</p><p>So, even if the BDA is "flattened" internally, the F AUST code is always represented by a graph that leaves the possibility to generate code from an equivalent graph. To understand or design a DSP, a patcher or a block-diagram is often more illustrative for audio developers than mere source code, the visual representation looks like electric/electronic diagrams and hides all the "plumbery," the developer does not have to master the details of the implementation language. In addition, some VPLs can group subgraphs into blocks and provide zoomable views of the diagram logic, making it easier to find errors. This is why we think that an editor for such diagrams would be a desirable addition/improvement to an Integrated Development Environment (IDE) for F AUST <ref type="bibr" target="#b7">[8]</ref>. A graph-to-code approach would help writing DSP algorithms, boosting the design while not impacting the performance.</p><p>Since Max and PureData, patcher-like VPLs are massively developed especially on the web. WebPd is a web-based 1 PureData patcher interpreter using JavaScript and the WebAudio 2 API. Cables.gl is a video-oriented patcher editor on the web that 3 also handles WebAudio nodes. WebAudio Visual Editor, 4 WebAudioDesigner, Mosaicode <ref type="bibr" target="#b8">[9]</ref> and Olos are web-oriented VPLs for audio processing. Still, using F AUST as the graph-to-code compilation target will bring as well the advantage of being able to export efficient and robust DSPs to any supported platform including Max, PureData and WebAudio.</p><p>Along with the development of the F AUST compiler, the presented work may be considered as a universal DSP design tool for many DSP platforms.</p><p>In the next sections, we will take a look at Gen, one of the 8 most popular existing graph-to-code generators for DSP, then discuss the possible implementations of F AUST 's different features in a graph editor. Finally, we will propose a web-based application that implements the first version of the editor and the code generator.</p><p>the GenExpr code is interpreted to a lower-level code to get higher performance. The GenExpr code that the system compiles to is available to users who can also write directly GenExpr code as a part of the program. This makes the language rather similar to F AUST and serves as inspiration. In the presented work, we follow certain paradigms from Gen to offer developers a consistent experience across platforms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Inlets, Outlets, Inputs and Outputs</head><p>When a Gen patcher is compiled, the boxes and lines in the patcher are analyzed to generate the GenExpr code. The boxes with different text on them represent different functions. They have a certain number of inlets and outlets as their function parameters and results (inputs and outputs). The text on the box can be followed by arguments to override its parameters and to suppress the inlets (Figure <ref type="figure">1</ref>). Unconnected inlets will be replaced by 0 while compiled.</p><p>Figure <ref type="figure">1</ref> Gen example: the "+" function has two inlets by default, one will be suppressed by adding an argument When a DSP diagram is built by a Gen patcher, it should have at least one output. Outputs are the starting points of the analysis. Inputs are involved in the code generation only if a path from input to output can be found. Inputs and outputs are represented as boxes named in and out . For example, Figure <ref type="figure">2</ref> will be compiled to: out1 = in1 + in2; out2 = in2; out3 = 0;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2 Gen example: inputs and outputs</head><p>Figure <ref type="figure">2</ref> also shows that when two lines merge into one inlet, they will be added together. When two lines are coming from the same outlet, they will represent the same signal and be named identically in the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Subprocess and Identifiers</head><p>A Gen patcher can contain multiple Gen patchers or GenExpr code blocks. They can be considered as reusable user-defined functions. This approach is similar to defining a reusable function in Faust. A sub-patcher in Gen will have the same number of inlets and outlets as the amount of in and out objects used; the code block is also connectable when the code is properly written and compiled. For example, the patcher in Figure <ref type="figure">3</ref> has one code block and one sub-patcher that represent the same function. So, the resulting code is: expr_1 = max(in1, in2); out1 = expr_1; max_2 = max(in1, in2); gen_3 = max_2; out2 = gen_3;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 3 Gen example: sub-patcher and code block</head><p>In this example, we also understand that each result of a function is named with an identifier formed by the concatenation of the name of the function or outlet, an underscore, and a unique number. These identifiers are thereby unique and will be reused if the result is passed to other functions. Although the system can add some redundancy, it allows the developer to easily find out the relation between the graph and the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Loops</head><p>Dealing with loops is a common and critical issue in DSP language design. In Gen, it is possible to create a loop only if a delay of at least one sample appears in the loop. The graph is similar to the block-diagram that a F AUST recursive composition produces, which creates automatically a one-sample delay. Figure <ref type="figure">4</ref> is an example of simple feedback with a one-sample delay function history .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 4 Gen example: a feedback with one-sample delay</head><p>The graph is compiled to the following code:</p><formula xml:id="formula_0">History history_1(0); add_2 = in1 + history_1; out1 = add_2; history_1_next_3 = fixdenorm(add_2); history_1 = history_1_next_3;</formula><p>The loop with the history object generates the code differently, as the delay is declared explicitly on the top, with an extra fixdenorm function to replace the denormal values by 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Explicit and Implicit</head><p>F AUST is a functional language that can be used to build concisely a graph. This allows us to create new functions by chaining defined functions. However, once a new function is written, it becomes difficult to tell its exact number of inputs and outputs until the code is compiled. The same implication happens when we compose blocks using operators: it is not possible to tell before compilation how each input and output are connected without deep information of blocks. We chose to adopt in the work presented in this paper Gen's graph representation which is explicit in terms of I/Os and connections, as one inlet or outlet represents exactly one signal. This, on one hand, may raise some limitations when one needs to connect a large amount of I/Os or need to create a function with a variable number of arguments (like pattern-matching in F AUST <ref type="bibr" target="#b9">[10]</ref>), but, on the other hand, brings an easily understandable graph that matches the block-diagram being compiled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>C OMPILE A G RAPH TO F AUST</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Functions</head><p>Basically, in F AUST , each block (or box in the graph) can be transformed into a f(x) expression (with some exceptions) <ref type="bibr" target="#b10">[11]</ref>.</p><p>The expression (prefix application syntax) is widely used in F AUST even for algebra symbols. As an example, a -b is equivalent to -(a, b) . This feature allows us to generalize the way a functional box can be transformed into F AUST code.</p><p>Table <ref type="table" target="#tab_0">1</ref> shows how we generate expressions from an unconnected, no-argument box with different numbers of I/Os.  The generation rules are:</p><p>1. Inlets and outlets are filled by 0 if not connected.</p><p>2. If the number of inlets is 0, which means the function has no input, then no parameter will appear in the code. 3. The outlets are named from the function name, box's unique identifier number and the outlet index. 4. If the function has multiple outputs, an intermediate expression will be generated before splitting to each outlet.</p><p>In Gen, the arguments attached after the function name in the box will be used to replace some function inputs by constant values.</p><p>To achieve this, we added more generation rules: 5. The arguments defined will be completely or partially applied to the beginning of available function inputs except for infix operators and their relatives. For these 14 11 ma.SR has 0 input, 1 output. 12 en.ar has 3 inputs, 1 output. 13 os.oscrq has 1 input, 2 outputs. 14 Functions that arguments are applied to the end of inputs in our implementation (the list is slightly different from Faust's infix operators): +, -, *, /, ^, %, &amp;, |, xor, @, &lt;, &lt;=, exceptions, the arguments will be applied at the end of the available function inputs. 6. The _ (also known as identity block ) is used in F AUST to bypass a signal. We consider it as a placeholder in arguments to keep the inlet available.</p><p>Examples of unconnected boxes with arguments (Table <ref type="table" target="#tab_1">2</ref>): Now more rules about inlets: (Figure <ref type="figure" target="#fig_2">5</ref>) 7. If an inlet is connected by one line, the identifier of the related outlet will be assigned to the function input. 8. If connected by more than one line, the outlets related will be merged into one signal before being assigned to the function input. 9. Inlets are one by one assigned to function inputs from start, skipping which is already replaced by arguments.  For pattern-matching functions, the number of I/Os is variable. To make these functions usable in the graph, we allow setting the number of function I/Os explicitly using Gen's attribute syntax. For example, si.bus 5 @ins 6 @outs 5 declares that the function has 6 inputs and 5 outputs, then creates 5 inlets for the box as it already has one argument.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Main Process and Loops</head><p>The graph representation for loops in F AUST 's block-diagram or Gen is straightforward and intuitive. But compiling the graph to F AUST code is problematic. Indeed, if the loop is on the same level as other functions, the graph of the loop (recursion) is determined by the available number of I/Os of the process within the loop. In code generation, the recursive composition sign cannot be correctly placed unless the subprocess is compiled without any other loops. So, it is better to analyze these recursions with a higher priority and place them on an upper &gt;, &gt;=, &lt;&lt;, &gt;&gt;, ==, !=, pow, atan2, fmod, remainder, rdtable, rwtable.</p><p>This is an example of a parallel iteration which has 3 outputs (Figure <ref type="figure" target="#fig_3">10</ref>), the fourth outlet is the local variable. The par box will look for a graph above its first inlet to take as its sub-process. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">UI Components</head><p>As F AUST offers some primitives for UI description (checkbox, button, sliders, etc.), we implement them in the graph. Here is an example (Figure <ref type="figure">11</ref>):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 11 Graph with UI descriptors</head><p>The graph is similar to a F AUST block-diagram. The UI component name is optional. If omitted, it will be named using its box identifier. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">W EB -BASED G RAPH E DITOR</head><p>The F AUST compiler is available altogether with an IDE on the Web platform since 2015 <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>. Recently, W3C Web standards such as WebAudio, WebMIDI, WebAssembly,</p><p>15 16</p><p>opens a considerable potential for the F AUST ecosystem. For example. a ready-to-use JavaScript module named faust2webaudio has been developed in 2019, which allows us to evaluate F AUST DSP code and to compile to WebAssembly/WebAudio code that can run directly in a browser <ref type="bibr" target="#b13">[14]</ref>. Web and web browsers, thanks to their accessibility and their increasing performance, became an attractive environment to develop F AUST -related tools.</p><p>Consequently, a modern web development tool-chain has been used to develop our editor, to ensure the efficiency of coding and compatibility across browsers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Tool-chain</head><p>We are using TypeScript as our main development language 18 which provides an additional level of maintainability compared to JavaScript. It also supports multiple tools that we are working with: React, a framework we used mainly for the UI layer; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Data Structure</head><p>Inspired by Max and Gen's patcher structure, a patcher is basically an augmented graph with lines and boxes. They can be described in the form "Map" data structures: sets of key-value pairs (or more precisely key-objects). Their key/identifiers (IDs) are generated automatically using auto-incrementing numbers so that lines and boxes can be arranged by their creation order.</p><p>interface Patcher { lines: Record&lt;string, Line&gt;; boxes: Record&lt;string, Box&gt;; } Lines have some properties, such as their source and destination box. Boxes hold more information: number of I/Os, text content, position, dimensions, behavior, etc. The FaustOp object controls the lifecycle of the box: determines what to do when the box is created, connected, disconnected, destroyed, etc. It is also designed to output a part of F AUST code when requested. We will discuss this aspect in further subsections.</p><p>Patchers, lines, and boxes are all event emitters that fire different events when things happen. This mechanism allows us to separate them from the UI system in terms of data structure (loose coupling). UI components, since their creation, subscribe to these events to properly react to data changes. For example, each time the graph changes (is being edited), a new F AUST code will be generated (Figure <ref type="figure">12</ref>).</p><p>Figure <ref type="figure">12</ref> The generated code can be previewed in real-time on the right panel (synchronized to the graph)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">F AUST Standard Library Analysis</head><p>The faust2webaudio module which is included in the web version of the F AUST compiler comes with the F AUST 's standard library stdfaust.lib . <ref type="bibr" target="#b14">[15]</ref> To use the functions from the library, we need to get a full list of available functions. All these library functions are well documented with a shared common format. To get a full list of available functions, a single traversal with a parser returns all the function names, and this result can be used both for syntax highlighting and for auto-completion in the code editor (also known as "IntelliSense features").</p><p>As the I/Os of these functions are implicit, the patcher needs to evaluate a function with the F AUST compiler to get their number of I/Os and to create box inlets and outlets. This is achieved by using a predefined method of faust2webaudio .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Graph Analysis</head><p>Code generation is the main task of the presented system. It regenerates the code by analyzing the graph in real time. The analysis is performed from bottom to top, more precisely, from each out box as the root of the tree traversal. This first full traversal is meant to find out all the boxes that are connected in the graph and to name their outlets using a unique F AUST identifier. A map is then created, that holds the relationship between lines and identifiers of their source outlet. Then a second traversal is performed: we call a method on all the boxes with the map as an argument, this method returns for each box the corresponding expression. These expressions are concatenated to the final code without any particular order. Indeed, most of the time, the F AUST compiler does not care about the order of expressions. For rare ones it does care, in an extra step, we locate them to the top of the code.</p><p>As an example, here (Figure <ref type="figure">13</ref>) is a graph with one output.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 13 Code generation steps example</head><p>Our first traversal brings back a map and visited boxes. The boxes are (Table <ref type="table" target="#tab_4">4</ref>): The map looks like that (Table <ref type="table" target="#tab_5">5</ref>): Then we get the expressions from the boxes. They are (Table <ref type="table" target="#tab_6">6</ref>): As ma.SR generated a special expression import(...); that should be included only once in the final code, we put it at the top.</p><p>Then we wrap the rest together with the main process using the out 's identifier: import("stdfaust.lib"); process = Out_1 with { ma_SR_3_0 = ma.SR; Const_4_0 = 1; Div_2_0 = /(Const_4_0, ma_SR_3_0); Out_1 = Div_2_0; };</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">C OMPILE A G EN P ATCHER TO F AUST</head><p>Since we are using the Gen approach to design the F AUST graph-to-code compiler, it is, therefore, possible to parse a Gen patcher and compile it to the F AUST code.</p><p>To achieve this process, we implemented all the Gen operators with F AUST functions in a separate F AUST library file gen2faust.lib which will be imported as a dependency of the generated F AUST code. Using this library file, we can interpret Gen boxes as F AUST expressions according to their box texts.</p><p>There are some differences in the interpretation of the box texts compared to the F AUST ones:</p><p>1. When Gen boxes are compiled to GenExpr, unconnected inputs can have their default value instead of 0. 2. Attributes (additional properties) can change the box's behavior. For example, the Gen cycle box has one input and two modes defined by the attribute @index . If the mode is set to freq , its input is 440 by default. We prepared two F AUST functions cycle and cycle_phase for these two modes (Table <ref type="table" target="#tab_7">7</ref>). By implementing these features to the editor, we managed to transform some Gen patchers to the F AUST code. However, some Gen operators which manipulate Max buffers remain difficult to interpret as F AUST 's audio import is not supported yet in the WebAssembly version of the F AUST compiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>The traditional workflow, when developing DSP code with F AUST , is firstly to have a graph in mind, then transform it into code, then check if the code matches the original graph by comparing it visually with the diagram output by the compiler. The graph-to-code system presented in this paper sort of reverses this workflow: design graphically the graphic DSP algorithm, then generate the F AUST code. No need to check if the code matches the graph anymore. In addition, for pedagogical purposes, it can help beginners to easily build their DSP from scratch and to understand how F AUST works. Furthermore, thanks to modern web technology such as WebAssembly and the WebAudio API, we are able to compile, debug and run F AUST DSP just-in-time in a web browser. This can transform our system into another more graphical oriented, online IDE-like tool. For the moment, there are still some features in F AUST that are not yet implemented in the project; but, eventually, using such a patcher system, we will be able to manipulate between multiple F AUST DSPs or even with other WebAudio-compatible DSPs in a single workspace.</p><p>The graph editor with the code generator is being developed as an open-source project and is functional online with a video demonstration. It can save and load patchers as a JSON file.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>26</head><p>Thanks to faust2webaudio and loose decoupling, it is possible to compile a graph file to F AUST code or to a WebAudio F AUST DSP automatically without any UI involved. So, the system can be integrated into F AUST IDEs or any WebAudio applications such as the WASABI Pedalboard. We are also developing a 27 web-based VPL for music composition and performance that use this project as its module.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">R EFERENCES</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>.ar(0, 0, 0); os.oscrq 13 os_oscrq_1 = os.oscrq(0); os_oscrq_1_0 = os_oscrq_1 : _, !; os_oscrq_1_1 = os_oscrq_1 : !, _;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5</head><label>5</label><figDesc>Figure 5 Graphs of Table3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 10 par</head><label>10</label><figDesc>Figure 10 par iteration graph example</figDesc><graphic coords="6,120.85,146.37,94.58,78.82" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>import("stdfaust.lib"); process = Out_1 with { HBargraph_2_0 = VGroup_3_0 : hbargraph("monitor", -1, 1); Checkbox_7_0 = checkbox("Checkbox_7"); HSlider_8_0 = hslider("freq", 440, 20, 2000, 0.1); os_osc_6_0 = os.osc(HSlider_8_0); Mul_5_0 = *(os_osc_6_0, Checkbox_7_0); VGroup_3_0 = vgroup("VGroup_3", Mul_5_0); Attach_4_0 = attach(VGroup_3_0, HBargraph_2_0); Out_1 = Attach_4_0; };</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>19</head><label></label><figDesc>Babel, a set of JavaScript compilation utilities to keep our code 20 runnable on different browser versions; Webpack, a production 21 tool that manages code dependencies, etc. For the UI components based on React, we are using the React version of Semantic UI for the overall look and feel; the 22 Monaco source code editor, SCSS for page layout design, etc.23 24</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Code</figDesc><table /><note><p>generated from unconnected functional boxes text code</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2</head><label>2</label><figDesc></figDesc><table><row><cell cols="2">Code generated from unconnected functional</cell></row><row><cell></cell><cell>boxes with arguments</cell></row><row><cell>text</cell><cell>code</cell></row><row><cell>+ 1</cell><cell>Add_1_0 = +(0, 1);</cell></row><row><cell>@ 10</cell><cell>Delay_1_0 = /(0, 10);</cell></row><row><cell>en.ar _ 0.1</cell><cell>en_ar_1_0 = en.ar(0, 0.1, 0);</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3</head><label>3</label><figDesc>Code</figDesc><table /><note><p>generated from connected functional boxes text code</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4</head><label>4</label><figDesc>Boxes visited    </figDesc><table><row><cell>box ID</cell><cell>box text</cell></row><row><cell>1</cell><cell>out 1</cell></row><row><cell>2</cell><cell>/</cell></row><row><cell>3</cell><cell>ma.SR</cell></row><row><cell>4</cell><cell>c 1 25</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5</head><label>5</label><figDesc>Line map</figDesc><table><row><cell>line ID</cell><cell>F AUST code identifier</cell></row><row><cell>line-1</cell><cell>Div_2_0</cell></row><row><cell>line-2</cell><cell>ma_SR_3_0</cell></row><row><cell>line-3</cell><cell>Const_4_0</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 6</head><label>6</label><figDesc>Expressions generated</figDesc><table><row><cell>box text</cell><cell>expressions</cell></row><row><cell>out 1</cell><cell>Out_1 = Div_2_0;</cell></row><row><cell>/</cell><cell>Div_2_0 = /(Const_4_0, ma_SR_3_0);</cell></row><row><cell>ma.SR</cell><cell>import("stdfaust.lib"); ma_SR_3_0 = ma.SR;</cell></row><row><cell>c 1</cell><cell>Const_4_0 = 1;</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 7</head><label>7</label><figDesc>Compile Gen boxes</figDesc><table><row><cell>box text</cell><cell></cell><cell>expressions</cell></row><row><cell cols="2">cycle @index freq</cell><cell>cycle(440);</cell></row><row><cell>cycle phase</cell><cell>@index</cell><cell>cycle_phase(0);</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Proceedings of the 2 nd International Faust Conference (IFC-20), Maison des Sciences de l'Homme Paris Nord, Saint-Denis, France, December<ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref> 2020   </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_1"><p>https://mosaicode.github.io/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_2"><p>https://www.jasonsigal.cc/portfolio/olos .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_3"><p>https://docs.cycling74.com/max8/vignettes/gen_overview</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_4"><p>https://fr0stbyter.github.io/jspatcher/dist/?mode=faust</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_5"><p>https://docs.cycling74.com/max8/vignettes/gen_genexpr</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_6"><p>https://www.w3.org/TR/webmidi</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_7"><p>https://webassembly.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_8"><p>https://github.com/grame-cncm/faust2webaudio</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_9"><p>https://www.typescriptlang.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="19" xml:id="foot_10"><p>https://reactjs.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="20" xml:id="foot_11"><p>https://babeljs.io/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="21" xml:id="foot_12"><p>https://webpack.js.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_13"><p>https://react.semantic-ui.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="23" xml:id="foot_14"><p>https://microsoft.github.io/monaco-editor/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="24" xml:id="foot_15"><p>https://sass-lang.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="25" xml:id="foot_16"><p>c represents a constant value.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>level. As a result, these recursions are set aside and our main process will have a part of its I/Os dedicated to them.</p><p>For example, a process that has no input, 3 outputs and contains one recursion will be restructured as following (Figure <ref type="figure">6</ref>):  We are now able to compile the following graph (Figure <ref type="figure">7</ref>): </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Subprocess</head><p>Three subprocess design patterns are proposed: code in the graph, sub-patcher, F AUST iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1.">Code Block</head><p>F AUST offers several λ-function style syntaxes to facilitate the encapsulation of a subprocess. To integrate a separate F AUST DSP into a new process, we need the environment{...} syntax to ensure its independence and use its main process as our subprocess. This approach causes fewer problems as the F AUST compiler only allows using import syntax in a new environment.</p><p>The example below (Figure <ref type="figure">8</ref>) shows how to integrate an independent F AUST code into the graph. In this example, the patcher already evaluated the code block to create two inlets and one outlet. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2.">Sub-patcher</head><p>A patcher with outputs can be included in another patcher as a subprocess. We use F AUST 's with {...} expression which creates a local scope.</p><p>If we put the patcher of Figure <ref type="figure">8</ref> in a new patcher (Figure <ref type="figure">9</ref>): </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3.">Iterations</head><p>F AUST offers four iteration functions: par, sum, prod and seq . Compared to other functions, they work with a variable that is local to their scope, which needs to be accessible in a local graph as a subprocess.</p><p>We propose a loop-like graph, using the same box to provide this scoped variable and to retrieve the sub-process graph. The iteration box will take from its inlet the sub-graph to repeat.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Syntactical and Semantical Aspects of Faust</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fober</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Letz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Soft Computing</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Max/msp</title>
		<author>
			<persName><forename type="first">M</forename><surname>Puckette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zicarelli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Cycling</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Pure Data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Puckette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Computer Music Conference</title>
		<meeting>the International Computer Music Conference<address><addrLine>Thessaloniki</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The patcher</title>
		<author>
			<persName><forename type="first">M</forename><surname>Puckette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Computer Music Conference</title>
		<meeting>the International Computer Music Conference<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Dataflow process networks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Parks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="773" to="801" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An algebra for block diagram languages</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fober</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Letz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Computer Music Conference</title>
		<meeting>the International Computer Music Conference<address><addrLine>Gothenburg</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A survey of stream processing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Stephens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="491" to="541" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Faust Online Compiler: a Web-Based IDE for the Faust Programming Language</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
		<ptr target="https://youtu.be/vYgqjakKYwo27https://mainline.i3s.unice.fr/Wasabi-Pedalboard/" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Linux Audio Conference</title>
		<meeting>the Linux Audio Conference<address><addrLine>Stanford</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Web Audio application development with Mosaicode</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Schiavoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">L</forename><surname>Gonçalves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">L N</forename><surname>Gomes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Brazilian Symposium on Computer Music</title>
		<meeting>the Brazilian Symposium on Computer Music<address><addrLine>São Paulo</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Audio signal processing in Faust</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">O</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
		<ptr target="https://ccrma.stanford.edu/jos/aspf" />
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">FAUST : an Efficient Functional Approach to DSP Programming</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fober</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Letz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Computational Paradigms for Computer Music</title>
		<meeting><address><addrLine>E. D. France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="65" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Composing a Web of Audio Applications</title>
		<author>
			<persName><forename type="first">S</forename><surname>Denoux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Letz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fober</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Web Audio Conference</title>
		<meeting>the Web Audio Conference<address><addrLine>Paris</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Faust audio DSP language in the Web</title>
		<author>
			<persName><forename type="first">S</forename><surname>Letz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Denoux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fober</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Linux Audio Conference</title>
		<meeting>the Linux Audio Conference<address><addrLine>Mainz</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">FAUST online IDE: dynamically compile and publish FAUST code as WebAudio Plugins</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Letz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Michon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fober</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Buffa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ammari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lebrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Web Audio Conference</title>
		<meeting>the Web Audio Conference<address><addrLine>Trondheim</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">New Signal Processing Libraries for Faust</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Orlarey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Linux Audio Conference</title>
		<meeting>the Linux Audio Conference<address><addrLine>Saint-Etienne</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
