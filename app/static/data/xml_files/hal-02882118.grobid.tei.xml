<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Successor-Invariant First-Order Logic on Classes of Bounded Degree</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Julien</forename><surname>Grange</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">PSL</orgName>
								<orgName type="institution" key="instit1">ENS Paris</orgName>
								<orgName type="institution" key="instit2">INRIA</orgName>
								<orgName type="institution" key="instit3">CNRS LICS</orgName>
								<address>
									<postCode>2020</postCode>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Successor-Invariant First-Order Logic on Classes of Bounded Degree</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">862690AB68CE4FD08051E97817154092</idno>
					<idno type="DOI">10.1145/3373718.3394767</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study the expressive power of successor-invariant first-order logic, which is an extension of first-order logic where the usage of an additional successor relation on the structure is allowed, as long as the validity of formulas is independent on the choice of a particular successor.</p><p>We show that when the degree is bounded, successor-invariant firstorder logic is no more expressive than first-order logic.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>First order logic, FO, is the standard formalism to express properties of finite structures. Its expressive power is well known, and very restrained, as it can only express properties that are local, which roughly means that it can only talk about the immediate surroundings of a small number of elements, and it is unable to count.</p><p>A number of logics with higher expressivity can be defined with FO as a building block, such as MSO, in which quantification over sets is allowed, and LFP, which adds a fixpoint operator to FO. These additions break the local character of the logic.</p><p>Another way to define logics from FO is through the addition, in an invariant way, of arithmetic predicates on the structure that are exterior to the vocabulary. This amounts to arbitrarily identifying the universe of the structure with an initial segment of the integers, and allowing some arithmetic on them. However, we want these extensions to define properties of the structures, and not to depend on a particular ordering on their elements: thus we focus on invariant extensions of FO.</p><p>If the only predicate allowed is the order, we get order-invariant first-order logic, &lt; -inv FO. Restricting a bit the additional relation, we get successorinvariant first-order, Succ-inv FO. In this formalism, we only grant an access to the successor relation derived from the order, provided that the evaluation of a sentence using this successor relation is independent of the choice of a particular successor.</p><p>The problem of determining whether an FO-sentence using an order or a successor relation is invariant wrt. this relation is undecidable, by reduction from Trakhtenbrot's theorem <ref type="bibr" target="#b9">[10]</ref>. Hence we use here the term "logic" somewhat liberally, since having a recursive syntax is a usual requirement for a logic.</p><p>The study of these two formalisms finds its motivation, among other topics such as descriptive complexity, in database theory. As databases are commonly stored on disk that implicitly order their memory segments, when one wishes to express a query in FO, one has access to an additional order on the elements of the database. However, making use of this order without care could result in queries that evaluate differently on two implementations of the same database, which is clearly an undesirable behavior. We want to use this order only in an invariant way; this way, the result of a query depends only on the database it is run on, and not on the way the data is stored on disk. This amounts exactly to the definition of &lt; -inv FO, or Succ-inv FO if we restrict the way this order can be accessed.</p><p>It is straightforward that &lt; -inv FO is at least as expressive as Succ-inv FO, which in turn can express any FO-definable property. Gurevich constructed a class of finite structures that can be defined by an &lt; -inv FO sentence, but which is not FO-definable. Though this construction wasn't published by Gurevich, it can be found e.g. in Section 5.2 of <ref type="bibr" target="#b7">[8]</ref>. Rossman extended this result, and proved in <ref type="bibr" target="#b8">[9]</ref> that on finite structures, Succ-inv FO is strictly more expressive than FO.</p><p>Grohe and Schwentick <ref type="bibr" target="#b6">[7]</ref> proved that these logics were Gaifman-local, giving an upper bound to their power of expression. Other upper bounds were given by Benedikt and Segoufin <ref type="bibr" target="#b0">[1]</ref>, who proved that &lt; -inv FO, and hence Succ-inv FO, are included in MSO on classes of bounded treewidth and on classes of bounded degree. Elberfeld, Frickenschmidt and Grohe <ref type="bibr" target="#b2">[3]</ref> extended the first inclusion to a broader setting, that of decomposable structures. Whether these logics are included in MSO in general is still an open question.</p><p>The classes of structures involved in the separating examples by Gurevich and Rossman are dense, and no other example is known on classes that are sparse. Far from it, &lt; -inv FO and a fortiori Succ-inv FO are known to collapse to FO on several sparse classes. Benedikt and Segoufin <ref type="bibr" target="#b0">[1]</ref> proved the collapse on trees; Eickmeyer, Elberfeld and Harwarth <ref type="bibr" target="#b1">[2]</ref> obtained an analogous result on graphs of bounded tree-depth; Grange and Segoufin <ref type="bibr" target="#b5">[6]</ref> proved the collapse on hollow trees.</p><p>Whether &lt; -inv FO or Succ-inv FO collapse to FO on classes of graphs of bounded treewidth (or even bounded pathwidth) are still open questions. We go in another direction in this paper, and prove that Succ-inv FO collapses to FO on classes of structures of bounded degree. To do this, we show how to construct successors on two FO-similar structures of bounded degree, such that the two structures remain FO-similar when considering the additional successor relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related work:</head><p>The general method used in <ref type="bibr" target="#b1">[2]</ref> to prove that &lt; -inv FO collapses to FO when the tree-depth is bounded is the same as ours: starting from two FO-similar structures, they show how to construct orders that maintain the similarity. However, the techniques we use to construct our successors are nothing like the ones used in <ref type="bibr" target="#b1">[2]</ref>, as the settings are very different.</p><p>Instead of directly constructing similar orders on two similar structures, [1] and <ref type="bibr" target="#b5">[6]</ref> exhibit a chain of intermediate structures and intermediate orders that are pairwise similar, in order to prove the collapse on trees and hollow trees. Once again, our construction differs wildly from these ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>The remainder in the division of n ∈ N by m &gt; 0 is denoted n[m].</p><p>A binary relation on a finite set X is a successor relation on X if it is the graph of a circular permutation of X, i.e. a bijective function from X to X with a single orbit. This differs from the standard notion of successor in that there is neither minimal nor maximal element. However, this doesn't have any impact on our result, as discussed at the end of the present Section.</p><p>We use the standard definition of first-order logic FO(Σ) over a signature Σ composed of relation and constant symbols. We only consider finite Σstructures, which are denoted by calligraphic upper-case letters, while their universes are denoted by the corresponding standard upper-case letters; for instance, A is the universe of the structure A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1 (Succ-inv FO).</head><p>A sentence ϕ ∈ FO(Σ ∪ {S}), where S is a binary relation symbol, is said to be successor-invariant if for every Σ-structure A, and every successor relations S 1 and S 2 on A, (A, S 1 ) |= ϕ iff (A, S 2 ) |= ϕ. We can then omit the interpretation for the symbol S, and if (A, S 1 ) |= ϕ for any (every) successor S 1 , we write A |= ϕ.</p><p>The set of successor-invariant sentences on Σ is denoted Succ-inv FO(Σ).</p><p>Given two Σ-structures A and B, and L being either Succ-inv FO(Σ) or FO(Σ), we write A ≡ L k B if A and B satisfy the same L-sentences of quantifier rank at most k. For FO(Σ) as well as for Succ-inv FO(Σ), we omit Σ when it is clear from the context. Definition 2.2 (Gaifman graph). The Gaifman graph G A of a Σ-structure A is defined as (A, V ) where (x, y) ∈ V iff x and y appear in the same tuple of a relation of A. In particular, if a graph is seen as a relational structure on the vocabulary {E}, its Gaifman graph is the unoriented version of itself. By dist A (x, y), we denote the distance between x and y in G A . The degree of A is the degree of its Gaifman graph, and a class C of Σ-structures is said to be of bounded degree if there exists some d ∈ N such that the degree of every A ∈ C is at most d.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.3 (Types)</head><p>. We now give the definition of the type of an element. Beware that this has a different meaning in classical model theory, where it denotes the set of sentences with one free variable that are satisfied by this element. Here, the type of an element describes its surroundings in the structure.</p><p>Let c be a constant symbol that doesn't appear in Σ.</p><p>For k ∈ N and x ∈ A, the k-neighborhood N k A (x) of x is the (Σ ∪ {c})structure whose Σ-restriction is the substructure of A induced by {y ∈ A : dist A (x, y) ≤ k}, and where c is interpreted as x.</p><p>The k-type τ = tp k A (x) is the isomorphism class of its k-neighborhood. We say that τ is a type over Σ, and that x is an occurrence of τ . |A| τ denotes the number of occurrences of τ in A, and we write</p><formula xml:id="formula_0">[[A]] r = t [[B]</formula><p>] r to mean that for every r-type τ , |A| τ and |B| τ are either equal, or both larger than t.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.4 (Path and cycles).</head><p>A cycle of length l ≥ 2 in the Σ ∪ {S}structure A is a sequence (x 0 , . . . , x l-1 ) of distinct vertices of A such that for every 0 ≤ i &lt; l, x i and x i+1[l] appear in the same tuple of some relation of A (in other words, it is a cycle in G A ). If furthermore (x i , x i+1[l] ) ∈ S for every i, then we say that it is an S-cycle. If for some i,</p><formula xml:id="formula_1">(x i , x i+1[l] ) ∈ S or (x i+1[l] , x i ) ∈ S,</formula><p>then we say that the cycle goes through an S-edge. A path is defined similarly, without the requirement on x l-1 and x 0 , and its length is l -1 instead of l.</p><p>From now on, we assume that Σ is purely relational (i.e. contains only relation symbols) and doesn't contain the binary symbol S. The reverse inclusion, i.e. FO ⊆ Succ-inv FO, always holds and needs no verification.</p><p>We are now ready to state our main result:</p><p>Theorem 2.5. For every vocabulary Σ and for every class C of Σ-structures of bounded degree,</p><formula xml:id="formula_2">Succ-inv FO = FO on C .</formula><p>Let's first state a corollary of this result. Gajarský, Hliněný, Obdržálek, Lokshtanov and Ramanujan <ref type="bibr" target="#b4">[5]</ref> characterized the graph classes which are FOinterpretable in a class of graphs of bounded degree as the near-uniform graph classes.</p><p>Let D be such a class of graphs, which is FO-interpretable in a class of graphs of bounded degree C . The construction from the aforementioned paper exhibits a class C of graphs of bounded degree (which may be larger that the degree of C ) and an FO-interpretation I such that every H ∈ D is isomorphic to I(G) for some G ∈ C, and such that I admits a converse which preserves FOsimilarity (although the converse is not an FO-interpretation itself); namely, for every k ∈ N, there exists k ∈ N such that for every H, H ∈ D such that</p><formula xml:id="formula_3">H ≡ FO k H then there exist G, G ∈ C such that H I(G) ∧ H I(G ) ∧ G ≡ FO k G .</formula><p>Theorem 2.5 can then be lifted to near-uniform graph classes, and we get the following corollary:</p><p>Corollary 2.6. Let D be a near-uniform class of graphs, i.e. a class of graphs FO-interpretable in a class of graphs of bounded degree. Then</p><formula xml:id="formula_4">Succ-inv FO = FO on D .</formula><p>The proof of Theorem 2.5 is given in Section 4, and constitutes the core of this paper. We give here a sketch of this proof; this will motivate the definitions given in Section 3.</p><p>Proof overview. Our goal is, given two structures G 1 and G 2 of degree at most d that are FO-similar (that is, such that G 1 ≡ FO n G 2 for a large enough n), to construct a successor relation S 1 on G 1 and S 2 on G 2 such that (G 1 , S 1 ) and (G 2 , S 2 ) stay FO-similar. This will entail that ≡ FO refines ≡ Succ-inv FO when the degree is bounded. From there, a standard finite-model-theoretic argument (namely, that ≡ FO n has finite index and that each one of its classes is FOdefinable) gives the inclusion Succ-inv FO ⊆ FO on classes of bounded degree.</p><p>It thus remains to construct suitable successor relations S 1 and S 2 . First, we separate the types occurring in G 1 and G 2 into two categories:</p><p>• on the one hand, the rare types, which have few occurrences in G 1 and G 2 (and thus, that have the same number of occurrences in both structures, by FO-similarity)</p><p>• on the other hand, the frequent types, which have many occurrences both in G 1 and G 2 .</p><p>In order to make the proof of FO-similarity of (G 1 , S 1 ) and (G 2 , S 2 ) as simple as possible, we want an element of G 1 (and similarly for G 2 and S 2 ) and its successor by S 1 to have the same type in G 1 as much as possible, and to be far enough in G 1 , in order for the types occurring in (G 1 , S 1 ) to be as "regular" as possible. As long as there are at least two different types, the first constraint obviously cannot be satisfied, but we will construct S 1 as close as possible to satisfying it.</p><p>For instance, suppose that G 1 contains three frequent types τ 0 , τ 1 and τ 2 , and one rare type χ with two occurrences. At the end of the construction, S 1 will (mostly) look like in Figure <ref type="figure">1</ref>, where the relations of G 1 have been omitted and the arrows represent S 1 , which is indeed a circular successor.</p><p>Note that all the elements of type τ 1 form a segment wrt. S 1 , as well as all the elements of type τ 2 . τ 0 , the first frequent type, has a special role in that it is used to embed all the elements of rare type (here, χ). Furthermore, and this is not apparent in the figure, two successive elements for S 1 are always distant in G 1 .</p><formula xml:id="formula_5">τ 0 τ 0 τ 0 χ χ τ 1 τ 2 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • Figure 1:</formula><p>Illustration of S 1 when there are three frequent types (τ 0 , τ 1 , τ 3 ) and one rare type (χ) in G 1 . The elements of rare type are surrounded by occurrences of the first frequent type, τ 0 . Junction elements are circled.</p><p>Keeping this idea in mind, S 1 (and similarly, S 2 ) is constructed iteratively, by adding S-edges to the initial structures one at a time. For practical reasons, we will start the construction of S 1 around occurrences of rare types: for each element x of rare type, we find two elements of type τ 0 that are far apart in G 1 , and far from x. Then we add two S-edges in order for those two elements to become the S 1 -predecessor and the S 1 -successor of x. We repeat this process for every element of rare type (and actually, for every element that belongs to the neighborhood of a rare element) until each one is protected by a ball of elements of frequent type. This is possible because there are few elements of rare type, and many elements of any frequent type; since the degree is bounded, those elements of frequent type are spread across the structure, and can be found far from the current construction.</p><p>Once this is done, we apply a similar construction around elements of fre-quent types that will, in the end, be the S 1 -predecessor or S 1 -successor of an element of another frequent type -that is, elements that will be at the border of the segments (for S 1 ) of a given frequent type. Such elements are circled in Figure <ref type="figure">1</ref>. We must choose only a small number of such elements (two for each frequent type, of which there are few due to the degree boundedness hypothesis), hence we can find enough far-apart elements of frequent type to embed them. Once again, degree boundedness is crucial. After these two steps, S 1 has been constructed around all the singular points. It only remains to complete S 1 by adding edges between the remaining elements (all of which are occurrences of frequent types), in such a way that elements of a same frequent type end up forming a segment for S 1 , and such that S 1 brings together elements that were far apart in the initial structure G 1 . Once again, the high number of occurrences of each frequent type allows us to do so.</p><p>Applying the same construction to G 2 , we end up with two structures (G 1 , S 1 ) and (G 2 , S 2 ) that cannot be distinguished by FO-formulas of small (wrt. the initial FO-similarity index between G 1 and G 2 ) quantifier rank, which concludes the proof.</p><p>We have given a global overview of the construction process of S 1 ; however, there are technical difficulties to take care of, which are dealt with in Section 4. For that, we need the definitions given in Section 3, which formalize the notion of regularity of a type in (G 1 , S 1 ) and (G 2 , S 2 ).</p><p>Let's now prove that our decision to consider circular successors instead of the more traditional linear ones (with a minimal and a maximal element) bears no consequence on this result. If we define LinSucc-inv FO in the same way as Succ-inv FO, but where the invariant relation is a linear successor S, we get: Lemma 2.7. For every vocabulary Σ, LinSucc-inv FO and Succ-inv FO define the same properties of Σ-structures.</p><p>Proof. Given ϕ ∈ Succ-inv FO, let's prove that there exists a formula ψ ∈ LinSucc-inv FO such that ψ is equivalent to ϕ (i.e. for every Σ-structure A, A |= ϕ iff A |= ψ).</p><p>Let ψ be defined as ϕ in which every atom S(x, y) has been replaced with S(x, y) ∨ ¬∃z( S(x, z) ∨ S(z, y)).</p><p>Let A be a Σ-structure and S be a linear successor on A. Then (A, S) |= ψ iff (A, S) |= ϕ, where S is the circular successor obtained from S by adding an edge from the maximal element to the minimal one.</p><p>This guarantees that ψ ∈ LinSucc-inv FO, and that ψ and ϕ are equivalent.</p><p>Conversly, let ψ ∈ LinSucc-inv FO and let ϕ be the formula ∃ min, Cut(ψ), where Cut(ψ) is obtained by replacing in ψ every S(x, y) with S(x, y)∧¬y = min.</p><p>Let A be a Σ-structure, let S be a circular successor on A, and let min ∈ A. Then (A, S, min) |= Cut(ψ) iff (A, S) |= ψ, where S is the linear successor obtained from S by removing the edge pointing to min. Hence (A, S) |= ϕ iff there exists a linear successor S obtained from S by an edge removal such that (A, S) |= ψ, that is iff A |= ψ.</p><p>This ensures that ϕ ∈ Succ-inv FO and that ϕ and ψ are equivalent.</p><p>Note that although LinSucc-inv FO and Succ-inv FO have the same expressive power, one may be more concise than the other, in terms of quantifier rank.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Fractal types and layering</head><p>To prove Theorem 2.5, we will start from two structures G 1 and G 2 that are FOsimilar, and construct successor relations S 1 and S 2 on their universes so that the structures remain FO-similar when we take into account these additional successor relations.</p><p>We want to construct S , for ∈ {1, 2}, in a way that makes tp k (G ,S ) (a) as regular as possible for every a ∈ G , in order to ease the proof of FO-similarity of (G 1 , S 1 ) and (G 2 , S 2 ).</p><p>Ideally, the S -successors and S -predecessors of any element should have the same k-type in G as this element. On top of that, there should not be any overlap between the k-neighborhoods in G of elements that are brought closer by S (this "independence" is captured by the layering property, introduced in Definition 3.2).</p><p>If we now try to visualize what tp k (G ,S ) (a) would look like in those perfect conditions, we realize that it reminds of a fractal (although the patterns -that is, the types -are obviously repeated only a finite number of times). This is why we introduce in Definition 3.1 the fractal type [τ ] k . Aside from a small number of exceptions (namely, for types that don't occur frequently enough, and around the transitions between frequent types), every element of k-type τ in G will have the fractal type [τ ] k in (G , S ).</p><p>If N is a representative of a type τ , c N is called the center of N . Recall from Definition 2.3 that c is the constant symbol added to Σ when considering types to pinpoint the central element of a neighborhood. Definition 3.1 (Fractal types). We define by induction on k ∈ N, for every k-type τ over Σ, the k-types</p><formula xml:id="formula_6">[τ ] k , [τ ] + k and [τ ] - k over Σ ∪ {S}. For k = 0, [τ ] 0 = [τ ] + 0 = [τ ] - 0 = τ (meaning that S is interpreted as the empty relation in [τ ] 0 , [τ ] + 0 and [τ ] - 0 )</formula><p>. Starting from a representative N of center a of the isomorphism class τ , we construct N as follows.</p><p>For every</p><formula xml:id="formula_7">x ∈ N at distance d ≤ k -1 from a, let M + x and M - x be structures of respective isomorphism type [χ] + k-d-1 and [χ] - k-d-1</formula><p>, where χ is the (k -d-1)type of x in N , and of respective center x + and x -.</p><p>N is defined as the disjoint union of N and all the M + x and the M - x , for x = a, together with all the edges S(x, x + ) and S(x -, x).</p><p>From there, N + (resp. N -) is defined as the the disjoint union of N and M + a (resp. M - a ) together with the edge S(a, a + ) (resp. S(a -, a)). Likewise, N +/-is defined as the disjoint union of N , M + a and M - a together with the edges S(a, a + ) and S(a -, a). In each case, a is taken as the center.</p><p>Now, [τ ] k , [τ ] + k and [τ ] - k are defined respectively as the isomorphism type of N +/-, N + and N -.</p><p>An illustration of this definition is given in Figure <ref type="figure">2</ref>.</p><formula xml:id="formula_8">a • a + • a - • x • x + • τ τ |k-1 τ |k-1 χ |k-d-1 d Figure 2: Partial representation of N +/-, of type [τ ] k .</formula><p>Here, χ is the (k -d)type of the element x, at distance d from a in τ . The dashed arrows represent S-edges.</p><p>Definition 3.2 (Layering). We say that an r-neighborhood N over Σ ∪ {S, c} is layered if it doesn't contain any cycle going through an S-edge. Every [τ ] r is obviously layered by construction. We say that a structure over Σ ∪ {S} satisfies the property (Layer[r]) iff all the r-neighborhoods of this structure are layered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>It turns out (Layer[r]</head><p>) can be reformulated in a way that doesn't involve the r-neighborhoods of the structure:</p><formula xml:id="formula_9">Lemma 3.3. A structure G over Σ ∪ {S} satisfies (Layer[r]</formula><p>) if and only if it contains no cycle of length at most 2r + 1 going through an S-edge.</p><p>Proof. If G contains a cycle of length at most 2r + 1 going through an S-edge, then the r-neighborhood of any vertex of this cycle contains the whole cycle, thus (Layer[r]) doesn't hold in G.</p><p>Conversly, suppose that there exists x ∈ G such that N r G (x) contains a cycle going through an S-edge, and let S(y, z) be such an edge.</p><p>For any u ∈ N r G (x), we define the cone C u at u as the set of elements v ∈ N r G (x) such that every shortest path from x to v in N r G (x) goes through u. There are two cases, depending on the relative position of y, z and their cones:</p><formula xml:id="formula_10">• If z /</formula><p>∈ C y and y / ∈ C z , let p y→x (resp. p x→z ) be a path of minimal length from y to x, not going through z (resp. from x to z, not going through y).</p><p>Let X be the set of nodes appearing both in p y→x and p x→z . X is not empty, as x ∈ X, and y, z / ∈ X. Let v ∈ X such that dist G (x, v) is maximal among the nodes of X, and let p y→v (resp. p v→z ) be the segment of p y→x (resp. of p x→z ) from y to v (resp. from v to z).</p><p>Then p v→z • (z, y) • p y→v is a cycle going through an S-edge, and is of length ≤ 2r + 1. This is illustrated in Figure <ref type="figure" target="#fig_1">3</ref>. Let the initial cycle be (z,</p><formula xml:id="formula_11">v 1 , • • • , v m-1 , y), with the notation v 0 = z and v m = y.</formula><p>Let i be the minimal integer such that v i / ∈ C z . Let p x→vi be a shortest path from x to v i : by definition, it doesn't intersect C z , and has length at most r. Thus, there exists a path p y→vi = p y→x • p x→vi from y to v i of length at most r + d going only through nodes outside of C z .</p><p>Since v i-1 ∈ C z , there exists a path p vi-1→z from v i-1 to z of length at most r -(d + 1) going only through nodes of C z .</p><p>Hence p y→vi • (v i , v i-1 ) • p vi-1→z • (z, y) is a cycle going though an S-edge, and its length is at most 2r + 1. This is depicted in Figure <ref type="figure">4</ref>. We are now ready to prove Theorem 2.5. Recall the sketch of proof from Section 2. We proceed in several steps: Section 4.1 details the general framework of the proof. In Section 4.2, we divide the types into rare ones and frequent ones.</p><formula xml:id="formula_12">y • z • v i-1 • v i • Cz S</formula><p>We then begin the construction of S 1 : Section 4.3 is dedicated to the construction of S 1 around the occurrences in G 1 of rare types. Then, in Section 4.4, we keep constructing S 1 around the occurrences (two for each type) of frequent types that are designed to make, when the construction is complete, the S 1junction between two frequent types.</p><p>At this point, S 1 will be fully built around the singular points of G 1 . Section 4.5 deals with the transfer of this partial successor relation S 1 over to G 2 : this will result in a partial S 2 , built in a similar way around the singular points of G 2 .</p><p>In Section 4.6, S 1 and S 2 are completed independently, to cover G 1 and G 2 . These expansions do not need to be coordinated, since at this point, the elements that are not already covered by S 1 and S 2 are occurrences of frequent types and their resulting types will be regular (i.e. fractal) both in (G 1 , S 1 ) and (G 2 , S 2 ).</p><p>We then give some simple examples in Section 4.7, before establishing properties of S 1 and S 2 in Section 4.8, and concluding the proof in Section 4.9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">General method</head><p>Let C be a class of Σ-structures of degree at most d. We show the following: for every α ∈ N, there exists some</p><formula xml:id="formula_13">f (α) ∈ N such that, given G 1 , G 2 ∈ C, if G 1 ≡ FO f (α) G 2 then G 1 ≡ Succ-inv FO α G 2 .</formula><p>For that, we will exhibit successor relations S 1 and S 2 such that (G 1 , S 1 ) ≡ FO α (G 2 , S 2 ). More precisely, using the notations from Definition 2.3, we will show that</p><formula xml:id="formula_14">[[(G 1 , S 1 )]] r = t [[(G 2 , S 2 )]</formula><p>] r where r and t depend on α and are large enough to ensure that (G 1 , S 1 ) ≡ FO α (G 2 , S 2 ). The existence of such r and t follows from the well-known Hanf threshold theorem, whose finite version is given in <ref type="bibr" target="#b3">[4]</ref>.</p><p>We will construct S 1 and S 2 iteratively in a way that ensures, at each step, that the property (Layer[r]) holds in (G 1 , S 1 ) and in (G 2 , S 2 ). (Layer[r]) is obviously satisfied in (G 1 , ∅). Each time we add an S 1 -edge or an S 2 -edge, we will make sure that we are in the right conditions to call upon Lemma 3.4, so that (Layer[r]) is preserved. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Separation between rare and frequent types</head><p>Knowing the values of r and t as defined in Section 4.1, we are now able to divide the r-types into two categories: the rare types and the frequent types. The intent is that the two structures have the same number of occurrences of every rare type, and that frequent types have many occurrences (wrt. the total number of occurrences of rare types) in both structures. This "many occurrences wrt." is formalized through a function g which is to be specified later on.</p><p>More precisely, Lemma 4.2. Given d, r ∈ N and an increasing function g : N → N, there exists p ∈ N such that for every</p><formula xml:id="formula_15">Σ-structures G 1 , G 2 ∈ C d satisfying G 1 ≡ FO p G 2 ,</formula><p>we can divide the r-types over Σ of degree at most d into rare types and frequent types, such that</p><p>• every rare type has the same number of occurrences in G 1 and in G 2</p><p>• both in G 1 and in G 2 , every frequent type has at least g(β) occurrences, where β is the number of occurrences of all the rare types in the structure</p><p>• if there is no frequent type, then G 1 and G 2 are isomorphic.</p><p>Proof. Let χ 1 , • • • , χ n be an enumeration of all the r-types over Σ of degree at most d, ordered in such a way that ∀i &lt; j, |G 1 | χi ≤ |G 1 | χj . Note that n is a function of d and r.</p><p>The classification of types between rare ones and frequent ones is done through Algorithm 1.</p><p>Algorithm 1 Separation between rare and frequent types At the end of Algorithm 1, we call χ 1 , • • • , χ i-1 the rare types, and χ i , • • • , χ n the frequent ones.</p><formula xml:id="formula_16">1: β ← 0 2: i ← 1 3: while i ≤ n and |G1|χ i &lt; g(β) do 4: β ← β + |G1|χ i 5:</formula><p>Note that β indeed counts the total number of occurrences of rare types in G 1 .</p><p>We now define the integers (a i ) 1≤i≤n as a 1 := g(0) and</p><formula xml:id="formula_17">a i+1 := max{a i , g(ia i )} .</formula><p>As g is monotone, it is easy to show by induction that for each rare type χ j with j &lt; i,</p><formula xml:id="formula_18">|G 1 | χj &lt; a j .</formula><p>As long as p is chosen large enough so that</p><formula xml:id="formula_19">G 1 ≡ FO p G 2 entails [[G 1 ]] r = an [[G 2 ]</formula><p>] r , we have by construction that every rare type has the same number of occurrences (which is smaller that a n ) in G 1 and in G 2 . Furthermore, in G 1 as in G 2 , if β denotes the total number of occurrences of rare types, every frequent type has at least g(β) occurrences.</p><p>We just need to make sure that the two structures are isomorphic when all the types are rare. If this is the case, then</p><formula xml:id="formula_20">|G 1 | = |G 2 | ≤ n(a n -1). Hence, as long as p ≥ n(a n -1), G 1 ≡ FO p G 2 implies G 1</formula><p>G 2 when all the types are rare.</p><p>Let τ 0 , • • • , τ m-1 be the frequent types. From now on, we suppose that m ≥ 1: there is nothing to do if m = 0, since G 1 and G 2 are isomorphic. Let β be the total number of occurrences of rare types in G 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Construction of S 1 around elements of rare type</head><p>To begin with, let's focus on G 1 , and start the construction of S 1 around occurrences of rare types. Algorithm 2 deals with this construction.</p><p>For a given occurrence x of some rare type, we choose as its S 1 -successor and S 1 -predecessor two occurrences of type τ 0 (the first frequent type), far apart from one another and from x. The existence of those elements relies on the bounded degree hypothesis. This is done on lines 8 and 11.</p><p>When line 14 is reached, every occurrence of rare type has an S 1 -predecessor and an S 1 -successor of type τ 0 .</p><p>It is not enough, however, only to deal with the occurrences of rare types. We need to "protect" them up to distance r in (G 1 , S 1 ). For that purpose, we construct the subsets R k of G 1 , for 0 ≤ k ≤ r. In the following, R ≤k denotes 0≤j≤k R j .</p><p>For each k, the subset R k is constructed in order to be the set of elements at distance exactly k in (G 1 , S 1 ) from the set of occurrences of rare types. Until we have reached k = r (that is, distance r from occurrences of rare types), every element of R k is given an S 1 -successor (line 21) and/or an S 1 -predecessor (line 26) of its type, if it doesn't already have one. Once again, those elements are required to be far (i.e. at distance greater than 2r + 1) from what already has been constructed.</p><p>Provided that g is large enough, it is always possible to find x + and x -on lines 8, 11, 21 and 26. Indeed, all the types considered are frequent ones, and the size of the (2r + 1)-neighborhood of R ≤k+1 is bounded by a function of d, r and β (the total number of occurrences of rare types in G 1 ). More precisely, at any point of the construction, (G 1 , S 1 ) has degree at most d + 2. Hence, the (2r + 1)-neighborhood of R r has size at most βN (d + 2, 3r + 1) (recall the definition of N from Definition 4.1), and it is enough to make sure that g(β) ≥ βN (d + 2, 3r + 1) + 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Construction of S 1 around the junctions between two frequent types</head><p>Recall that there is a second kind of singular elements: those which will be at the junction between two successive frequent types. That is, elements of type τ i that will, in the final structure (G 1 , S 1 ), have an S 1 -successor of type τ i+1[m] , or an S 1 -predecessor of type</p><formula xml:id="formula_21">τ i-1[m] .</formula><p>Those junction elements need to be treated in a similar way as the occurrences of rare types in Section 4.3. This construction is done throughout Algorithm 3.</p><p>The idea of Algorithm 3 is very similar to that of Algorithm 2. We start by picking two elements x + i and x - i for every frequent type τ i (for loop line 2), that are far from each other and from the previous construction.</p><p>Then we build m S 1 -edges between those elements on line 9: these edges are intended to be at the junction between the frequent types in the final structure.</p><p>The set P 0 of those 2m elements will have the same role as the set R 0 of occurrences of rare types for Algorithm 2: we build S 1 -edges at depth r around it. This is done through the subsets P k of G 1 , for 0 ≤ k ≤ r, P k being the set of elements at distance k from P 0 in (G 1 , S 1 ). Once again, P ≤k denotes 0≤j≤k P j .</p><p>For the same reason as for Algorithm 2, it is always possible to find elements x + and x -on lines 17 and 22.</p><p>Note that if m = 1, there is obviously no transition elements: we simply construct an S 1 -edge between x + 0 and x - 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Carrying S 1 over to G 2</head><p>In Sections 4.3 and 4.4, S 1 has been constructed around the singular points of G 1 , i.e. occurrences of rare types and elements that are to make the junction between two S 1 -segments of frequent types. Before we extend S 1 to the remaining elements (all of them being occurrences of frequent types) of G 1 , we carry it over to G 2 . This transfer is possible under the starting hypothesis that G 1 and G 2 are FO-similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let</head><p>A 1 := R ≤r ∪ P ≤r</p><formula xml:id="formula_22">B := {x ∈ G 1 : dist (G1,S1) (x, A 1 ) ≤ r}</formula><p>Algorithm 2 Construction of S 1 around elements of rare type</p><formula xml:id="formula_23">1: S1 ← ∅ 2: R0 ← {x ∈ G1 : tp r G 1 (x) is rare} 3: R1, • • • , Rr ← ∅ 4: for all x ∈ R0 do 5:</formula><p>for all neighbor y / ∈ R ≤1 of x in G1 do 6:</p><formula xml:id="formula_24">R1 ← R1 ∪ {y} 7:</formula><p>end for 8:</p><formula xml:id="formula_25">find x + such that tp r G 1 (x + ) = τ0 and dist (G 1 ,S 1 ) (x + , R ≤1 ) &gt; 2r + 1</formula><p>We pick a node at distance greater than 2r + 1 in compliance with Lemma 3.4, so that neighborhoods stay layered.</p><p>Recall that τ0 is the first frequent type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>R1 ← R1 ∪ {x + } 10:</p><formula xml:id="formula_26">S1 ← S1 ∪ {(x, x + )} 11: find x -such that tp r G 1 (x -) = τ0 and dist (G 1 ,S 1 ) (x -, R ≤1 ) &gt; 2r + 1 12: R1 ← R1 ∪ {x -} 13: S1 ← S1 ∪ {(x -, x)} 14: end for</formula><p>At this point, every element of rare type has an S1-predecessor and an S1successor of type τ0 15: for k from 1 to r -1 do 16: </p><formula xml:id="formula_27">for all x ∈ R k do tp k G 1 (x)</formula><formula xml:id="formula_28">find x + such that tp r G 1 (x + ) = tp r G 1 (x) and dist (G 1 ,S 1 ) (x + , R ≤k+1 ) &gt; 2r + 1 22: R k+1 ← R k+1 ∪ {x + } 23: S1 ← S1 ∪ {(x, x + )} 24: end if 25:</formula><p>if x doesn't have a predecessor by S1 then 26:</p><formula xml:id="formula_29">find x -such that tp r G 1 (x -) = tp r G 1 (x) and dist (G 1 ,S 1 ) (x -, R ≤k+1 ) &gt; 2r + 1 27: R k+1 ← R k+1 ∪ {x -} 28: S1 ← S1 ∪ {(x -, x)} 29: end if 30:</formula><p>end for 31: end for Algorithm 3 Construction of S 1 around the junctions between two frequent types   h defines an isomorphism from</p><formula xml:id="formula_30">1: P0, • • • , Pr ← ∅ 2: for i from 0 to m -1 do 3: find x + i such that tp r G 1 (x + i ) = τi and dist (G 1 ,S 1 ) (x + i , R ≤r ∪ P0) &gt; 2r + 1 4: P0 ← P0 ∪ {x + i } 5: find x - i such that tp r G 1 (x - i ) = τi and dist (G 1 ,S 1 ) (x - i , R ≤r ∪ P0) &gt; 2r + 1 6: P0 ← P0 ∪ {x - i } 7: end for 8: for i from 0 to m -1 do 9: S1 ← S1 ∪ {(x - i , x + i+1[m] )}</formula><formula xml:id="formula_31">find x + such that tp r G 1 (x + ) = tp r G 1 (x) and dist (G 1 ,S 1 ) (x + ,</formula><formula xml:id="formula_32">find x -such that tp r G 1 (x -) = tp r G 1 (x) and dist (G 1 ,S 1 ) (x -, R ≤r ∪ P ≤k+1 ) &gt; 2r + 1 23: P k+1 ← P k+1 ∪ {x -} 24: S1 ← S1 ∪ {(x -, x)}</formula><formula xml:id="formula_33">G 1 | B to G 2 | Im(h) . Let A 2 := h(A 1 )</formula><p>. By taking f (α) one higher than required, to make sure that Im(h) covers the rneighborhood in G 2 of every element of A 2 , we have that for every</p><formula xml:id="formula_34">x ∈ A 1 , tp r G2 (h(x)) = tp r G1 (x). We set S 2 := {(h(x), h(y)) : (x, y) ∈ S 1 }. h now defines an isomorphism from (G 1 , S 1 )| B to (G 2 , S 2 )| Im(h) ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and for every</head><formula xml:id="formula_35">x ∈ A 1 , tp r (G2,S2) (h(x)) = tp r (G1,S1) (x).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Completion of S 1 and S 2</head><p>Now that S 1 and S 2 are constructed around all the singular points both in G 1 and G 2 , it remains to extend their construction to all the other elements of the structures. Recall that all the remaining elements are occurrences of frequent types.</p><p>From (G , S ) ( ∈ {1, 2}) at any point in the construction, let's define the partial function S * : G → G that maps x ∈ G to the (unique) y that is S -reachable (while taking the orientation into account) from x and that doesn't have an S -successor. This function is defined on every element that doesn't belong to an S -cycle (and in particular, on every element without an S -predecessor).</p><p>Likewise, we define S - * by reversing the arrows of S . At this point, for every x / ∈ A 1 , S * 1 (x) = S - * 1 (x) = x, and for every x / ∈ A 2 , S * 2 (x) = S - * 2 (x) = x. We now run Algorithm 4. We first treat G 1 , and then apply a similar method to G 2 , replacing x + i and x - i by h(x + i ) and h(x - i ). The idea is, for every frequent type τ i , to insert all its remaining occurrences between (in the sense of S 1 ) x + i and x - i . The first approach (the loop at line 2) is greedy: while constructing S on nodes of type τ i , we choose as the successor of the current node any occurrence of τ i that is at distance greater than 2r + 1 from the current node s and the closing node of type τ i , S - * (x - i ). This, together with Lemma 3.4, ensures that (Layer[r]) holds after every addition. The conditions line 11 also ensure that the final edge addition, line 15, doesn't break (Layer[r]).</p><p>Once we cannot apply this greedy approach anymore, we know that only a small number (which can be bounded by 2N (d + 2, 2r + 1)) of nodes of type τ i remain without S 1 -predecessor. The loop at line 17 considers one such node x at a time. As long as g is large enough, we have constructed S 1 around enough elements of type τ i in the greedy approach to ensure the existence of some S 1 (y, z), with y, z of type τ i and at distance greater than 2r + 1 from x; x is inserted between y and z (line 20). For that, it is enough to have constructed at least 2N (d + 2, 2r + 1) + 1 S 1 -edges in the greedy phase. This is the case in particular when there are at least 4N (d + 2, 2r + 1) + 1 elements of type τ i without S 1 -predecessor at the beginning of Algorithm 4, which can be ensured by having</p><formula xml:id="formula_36">g(β) ≥ |A 1 | + 4N (d + 2, 2r + 1) + 1 .</formula><p>This holds in particular when</p><formula xml:id="formula_37">g(β) ≥ (β + 2t d r )N (d + 2, r) + 4N (d + 2, 2r + 1) + 1 .</formula><p>We will prove in Lemma 4.6 that all these insertions preserve (Layer[r]).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 Completion of S</head><p>1: for from 1 to 2 do 2:</p><p>for i from 0 to m -1 do</p><formula xml:id="formula_38">3: if = 1 then 4: s ← S * 1 (x + i ) 5:</formula><p>t ← S - *</p><p>s ← S *</p><p>t ← S - *</p><p>end if 10:</p><p>while such an x exists do 11:</p><p>find x with no S -predecessor, such that tp r G (x) = τi, dist (G ,S ) (s, x) &gt; 2r + 1, dist (G ,S ) (x, t) &gt; 2r + 1 and dist (G ,S ) (S * (x), t) &gt; 2r + 1 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Examples of construction</head><p>Before we give the proof of correctness of these algorithms, let us see how they apply in some simple cases Example 4.3. Suppose that there are no occurrences of rare types, and only one frequent type τ 0 , and assume r = 2.</p><p>In this case, Algorithm 2 is irrelevant, and all Algorithm 3 does is pick x - 0 and x + 0 far from each other, and start building S 1 around those nodes in order to construct their complete r-neighborhood in (G 1 , S 1 ). In order to make the figure more readable, let us consider that x - 0 and x + 1 have only one neighbor. In Figure <ref type="figure" target="#fig_7">5</ref>, the plain lines represent edges in G 1 , and the dashed arrows represent S 1 . We now apply Algorithm 4. The first step is to add elements between (in the sense of S 1 ) S * 1 (x + 0 ) and S - * 1 (x - 0 ) in order to join them, in a greedy fashion. Once this is done, there only remain a few elements that haven't been assigned an S 1 -predecessor. This is depicted in Figure <ref type="figure" target="#fig_4">6</ref>.</p><formula xml:id="formula_42">x - 0 • x + 0 • • • • • • • • • • •</formula><formula xml:id="formula_43">x - 0 x + 0 x S * 1 (x) • • • • • • • • • • • • • • • • • • • • Figure 6:</formula><p>After the greedy part of Algorithm 4, with one frequent type Now we consider one by one each of the elements that don't have an S 1predecessor: let's start with x in Figure <ref type="figure" target="#fig_4">6</ref>. Our goal is to insert it in the S 1 -cycle while still respecting (Layer[r]). For that, we find two successive elements y, z of the cycle that are far from x and S * 1 (x), and we insert x between them, as shown in Figure <ref type="figure" target="#fig_8">7</ref>.</p><p>We treat all the elements without an S 1 -predecessor in the same way, until S 1 is fully built. The procedure is very similar: in Algorithm 3, we build the r-neighborhood in (G 1 , S 1 ) of the four nodes x - 0 , x + 0 , x - 1 and x + 1 . After the greedy part of Algorithm 4, S 1 looks like in Figure <ref type="figure">8</ref>, where occurrences of τ 0 are represented as • and occurrences of τ 1 as •. The remaining of Algorithm 4 is as unchanged.</p><formula xml:id="formula_44">x - 0 x + 0 y z x S * 1 (x) • • • • • • • • • • • • • • • • • • • •</formula><formula xml:id="formula_45">x - 0 x + 1 x - 1 x + 0 x S * 1 (x) • • • • • • • • • • • • • • • • • • • • Figure 8:</formula><p>After the greedy part of Algorithm 4, with two frequent types Note that if there existed some occurrences of rare types, they would be embedded in the τ 0 part of the S 1 -cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">Properties of S 1 and S 2</head><p>We are now ready to show that, after the successive run of Algorithms 2, 3 and 4:</p><p>• S 1 and S 2 are indeed successor relations (Lemma 4.5)</p><p>• (G 1 , S 1 ) and (G 2 , S 2 ) satisfy (Layer[r]) (Lemma 4.6)</p><p>• A singular element (around a rare or a junction element) of (G 1 , S 1 ) and its corresponding element via h in (G 2 , S 2 ) have the same r-type (Lemma 4.9), while any other element in both structures has a regular (i.e. fractal) rtype (Lemma 4.8)</p><p>These properties will allow us to prove in Section 4.9 that (G 1 , S 1 ) and (G 2 , S 2 ) have the same number of occurrences of every r-type, up to a threshold t. Proof. This result is rather transparent, but a rigorous proof requires the usage of a somewhat cumbersome invariant.</p><p>Let us focus on G 1 : the proof is the same for G 2 , replacing every x + i and x - i with h(x + i ) and h(x - i ). Let a ∈ G 1 be defined as S - * 1 (x - m-1 ) at the beginning of Algorithm 4. By construction, tp r G (a) = τ m-1 and a has no S 1 -predecessor as of now. We show that at any point before line 15 of the loop iteration i = m -1 of Algorithm 4,</p><formula xml:id="formula_46">(i). S - * 1 (s) = a (ii). S - * 1 (x - m-1 ) = a (iii). let y, z / ∈ A 1 such that (y, z) ∈ S 1 and tp r G1 (y) = tp r G1 (z) = τ j</formula><p>for some j; then S - * 1 (y) = a (iv). for every i, (x - i , x + i+1[m] ) ∈ S 1 (v). there is no S 1 -cycle (vi). for every j &gt; i, tp r G1 (S - * 1 (x - j )) = τ j This is obviously satisfied at the beginning of Algorithm 4: there are not yet such y, z as in (iii), and s = S * 1 (x + 0 ) is S 1 -reachable from x - m-1 (since (x - m+1 , x + 0 ) ∈ S 1 ) hence (i) holds. Line 4 preserves the invariant. Indeed, the new value of s is S 1 -reachable from its previous value (this is guaranteed by (iv)), which means that they have the same image through S - * 1 , namely a. Let's prove that line 12 preserves the invariant. (i) and (ii) still hold since x = a: indeed, for i &lt; m -1, x and a don't share the same type, while for i = m -1, a = t (because of (ii)) and the distance condition prohibits x = a. (iii) still holds, as the only new possibility for such a couple (y, z) is (s, x), which is such that S - * 1 (y) = a (because of (i)). (iv) obviously holds, as does (v), since the only way for an S 1 -cycle to have been created is if x = S - * 1 (s), that is x = a. We have seen that this is absurd. (vi) is satisfied, as the only way for it to fail is for x to be some S - * 1 (x - j ), for j &gt; i, which is impossible due to type requirements. Now, let's move to line 13. Only (i) needs verification, and the argument is the same as for line 4.</p><p>Finally, let's look at line 15, for i &lt; m -1. t = a since their types are different, hence (i), (ii) and (v) still hold. (iii) still holds, as the only new possibility for such a couple (y, z) is (s, t), which is such that S - * 1 (y) = a because of (i) (actually, (s, t) doesn't even fit the condition, since t ∈ A 1 ). (iv) is still satisfied. (vi) holds, as the only way for it to fail is for t to be some S - * 1 (x - j ), for j &gt; i, which is impossible due to type requirements. We now prove that from line 17 until the end of Algorithm 4, there is exactly one S 1 -cycle, which contains every y, z / ∈ A 1 such that (y, z) ∈ S 1 and tp r G1 (y) = tp r G1 (z) = τ j for some j. This is true after line 15 of the loop iteration m -1, which creates the first S 1 -cycle, as (i) and (ii) ensure t = a = S - * 1 (s). (iii) guarantees that this newly created S 1 -cycle contains all the couple (y, z) satisfying the condition.</p><p>It remains to show that line 20 preserves this property: by hypothesis, y and z belong to the S 1 -cycle. After line 20, there is still exactly one S 1 -cycle, which corresponds to the previous one where the S 1 -edge has been replaced by the S 1 -segment [x, S * 1 (x)]. The only S 1 -edges that have been added belong to the S 1 -cycle, hence the second part of the property still holds.</p><p>In the end, every element of G 1 has a predecessor by S 1 , hence S 1 is a permutation of G 1 . We've shown that it has a single orbit. We focus on Algorithm 4, and we use Lemma 3.4 to prove that (Layer[r]) remains valid in (G , S ) throughout its run. There are three edge additions we have to prove correct:</p><p>• For the edge addition of line 12, this follows directly from Lemma 3.4.</p><p>• For the edge addition of line 15, we show that the invariant dist (G ,S ) (s, t) &gt; 2r + 1 is satisfied at the beginning and at the end of the while line 10. This invariant, together with Lemma 3.4, will be enough to conclude.</p><p>The invariant holds before the first execution of the while loop (except for m = 1, where it only bootstraps after two executions of the loop).</p><p>Working towards a contradiction, suppose that the invariant is broken during an execution of the loop. We use the pre notations. There must exists a path from S * (x) (which is to become the new value of s at the end of the loop) to t in (G , S ∪ {(s, x)}) of length at most 2r + 1; consider a shortest one. As is cannot be valid in (G , S ) by choice of x, it must go through the newly added edge (s, x). This means that in (G , S ), either there exist paths of length at most 2r + 1 from S * (x) to s and from x to t, or paths of length at most 2r + 1 from S * (x) to x and from s to t. The former is absurd considering the way x was chosen, and the latter contradicts the previous invariant.</p><p>• Let's prove that the addition of the two S -edges of line 20 doesn't break (Layer[r]). By choice of y, we know that dist (G ,S ) (y, x) &gt; 2r + 1.</p><p>A fortiori, we must have dist (G ,S \{(y,z)}) (y, x) &gt; 2r + 1, and Lemma 3.4 ensures that (G , S \ {(y, z)} ∪ {(y, x)}) satisfies the property (Layer[r]).</p><p>Now, to the second addition: let's prove that, at the beginning of line 20, dist (G ,S \{(y,z)}∪{(y,x)}) (S * (x), z) &gt; 2r + 1 .</p><p>We then conclude with Lemma 3.4. Suppose it's not the case and consider a shortest path from S * (x) to z, which must be of length at most 2r + 1. This path cannot be valid in (G , S ), thus it has to go through the new edge (y, x). Since there cannot exist a path of length at most 2r from S * (x) to y in (G , S ) (as this would contradict dist (G ,S ) (S * (x), z) &gt; 2r + 1), it has to borrow the edge from x to y.</p><p>Then in (G , S \ {(y, z)}), there is a path of length at most 2r from y to z, which contradicts (Layer[r]) in (G , S ).</p><p>The following Lemma states that the only time S joins two nodes that have different r-types in G is when one of them is an occurrence of a rare type (in which case its S -predecessor and S -successor are of type τ 0 ) or when they are the elements which make the transition between two frequent types (that is, one is x - i and the other is x + i+1[m] , for some i &lt; m):</p><p>Lemma 4.7. ∀x, y ∈ G 1 such that (x, y) ∈ S 1 and (x / ∈ R 0 and y / ∈ R 0 ) and (x / ∈ P 0 or y / ∈ P 0 ), then tp r G1 (x) = tp r G1 (y) ∀x, y ∈ G 2 such that (x, y) ∈ S 2 and (x / ∈ h(R 0 ) and y / ∈ h(R 0 )) and (x / ∈ h(P 0 ) or y / ∈ h(P 0 )), then tp r G2 (x) = tp r G2 (y)</p><p>Proof. The property clearly holds at the end of Algorithm 2 and Algorithm 3.</p><p>For any i from 0 to m -1, the only S 1 -edges (resp. S 2 -edges) that are added during the i-th loop are between two nodes of type τ i .</p><p>Recall the discussion at the beginning of Section 3. We now prove that, as long as an element is far from any occurrence of a rare type and from the elements that make the transition between two frequent types, its type in (G , S ) is the fractal of its type in G :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have shown that Succ-inv FO collapses to FO on any class of bounded degree, as well as on classes of graphs which are FO-interpretable in graph classes of bounded degree, namely near-uniform graph classes as defined in <ref type="bibr" target="#b4">[5]</ref>. Our proof gives a constructive translation from Succ-inv FO to FO on classes of bounded degree. The quantifier rank of the translated sentence is tripleexponential in the quantifier rank of the original formula. It is an easy exercise to prove that the blowup is at least exponential, but we do not know if an exponential translation is at all possible.</p><p>Similar considerations arise when we take into account the length of the sentences instead of their quantifier rank -in this regard, our construction is even non-elementary, and all we know is that the blowup is at least exponential.</p><p>An interesting task would be to improve the succinctness of the translation, or to give tighter lower bounds on such constructions.</p><p>Apart from these considerations, there are two main directions in which one could look to extend the present result. One possibility would be to keep looking at classes of bounded degree while climbing up in the ladder of expressivity, and ask whether &lt; -inv FO collapses to FO as well on these classes of structures. New techniques would be needed, as contrary to what was the case with a successor, the addition of an order doesn't preserve the bounded degree property. Furthermore, even if &lt; -inv FO = FO in this setting, it is not clear whether such orders can be directly constructed. It may be necessary to construct, as in <ref type="bibr" target="#b0">[1]</ref>, a chain of intermediate structures and orders.</p><p>Alternatively, we could change the setting, and study the expressivity of Succ-inv FO on other sparse classes of structures, e.g. on classes of bounded treewidth. If showing the collapse of Succ-inv FO to FO on these classes proved itself to be out of reach, a possibility would be to aim at proving that Succ-inv FO is Hanf-local (which would be stronger than the known Gaifmanlocality). In that case, the starting hypothesis on the structures G 1 and G 2 would be stronger, as the existence of a k-type-preserving bijection between the two structures would be assumed.</p><p>These tasks are much harder without any bound on the degree, which was what guaranteed that we could find elements of a given frequent type far from each other.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>For a class C of Σ-structures, we say that Succ-inv FO = FO on C if the properties of C definable in Succ-inv FO and in FO are the same. In other words, if for every ϕ ∈ Succ-inv FO, there exists some φ ∈ FO such that ∀A ∈ C, A |= ϕ iff A |= φ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Existence of a short cycle joining y, z and v</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :Lemma 3 . 4 .</head><label>434</label><figDesc>Figure 4: Existence of a short cycle joining y, z, v i-1 and v i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 4 . 1 . 1 d- 2 + 1</head><label>41121</label><figDesc>Note that the size of any r-neighborhood of degree at most d is bounded by a function N of d and r; namely by N (d, r) := d • (d-1) r -if d = 2, and by N (2, r) := 2r + 1 if d = 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>i++ 6 :</head><label>6</label><figDesc>end while If i ≤ n, χi is the frequent type with the least occurrences in G1. If i = n + 1, all the types are rare.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>If we let t d r be the number of r-types of degree at most d over Σ, we must have that m ≤ n thus |A 1 | can be bounded by(β + 2t d r )N (d + 2, r) .Similarly, the size of B can be bounded by(β + 2t d r )N (d + 2, 2r) , which is a function of β, r and d. Hence as long as f (α) is larger than that number, the Duplicator has a winning strategy in the Ehrenfeucht-Fraïssé game between G 1 and G 2 in which the Spoiler chooses every element of B. Let h : B → G 2 be the function resulting from such a strategy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Sfor i from 0 to m -1 do 18 :</head><label>18</label><figDesc>← S ∪ {(s, x)} 13: s ← S * (x) 14: end while At this point, only a bounded number of elements of type τi are left without an S -predecessor 15: S ← S ∪ {(s, t)} for all x without S -predecessor, s.t. tp r G (x) = τi do 19:find y, z / ∈ A such that tp r G (y) = tp r G (z) = τi, (y, z) ∈ S , dist (G ,S ) (y, x) &gt; 2r + 1 and dist (G ,S ) (S * (x), z) &gt; 2r + 1 20:S ← S \ {(y, z)} ∪ {(y, x), (S * (x), z)}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: After Algorithm 3, with one frequent type</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Inserting x in the S 1 -cycle, as in the second part of Algorithm 4, with one frequent type</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Lemma 4 . 5 .</head><label>45</label><figDesc>S 1 (resp. S 2 ) is a successor relation on G 1 (resp. G 2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Lemma 4 . 6 .</head><label>46</label><figDesc>(Layer[r]) holds in (G , S ), for ∈ {1, 2} Proof. This property is guaranteed by the distance conditions of the form dist (G ,S ) (., .) &gt; 2r + 1 imposed throughout Algorithms 2, 3 and 4, and by Lemma 3.4. One can very easily verify that (Layer[r]) is guaranteed by Lemma 3.4 to hold in (G , S ) prior to the run of Algorithm 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>10: end for 11: for k from 0 to r -1 do</figDesc><table><row><cell>12:</cell><cell>for all x ∈ P k do</cell></row><row><cell>13:</cell><cell>for all neighbor y / ∈ P ≤k+1 of x in G1 do</cell></row><row><cell>14:</cell><cell>P k+1 ← P k+1 ∪ {y}</cell></row><row><cell>15:</cell><cell>end for</cell></row><row><cell>16:</cell><cell></cell></row></table><note><p>if x doesn't have a successor by S1 then 17:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>R ≤r ∪ P ≤k+1 ) &gt; 2r + 1</figDesc><table><row><cell>18:</cell><cell>P k+1 ← P k+1 ∪ {x + }</cell></row><row><cell>19:</cell><cell>S1 ← S1 ∪ {(x, x + )}</cell></row><row><cell>20:</cell><cell>end if</cell></row><row><cell>21:</cell><cell>if x doesn't have a predecessor by S1 then</cell></row><row><cell>22:</cell><cell></cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Lemma 4.8. For ∈ {1, 2} and for every 0 ≤ k ≤ r and x / ∈ R ≤k ∪ P ≤k (if = 1) or x / ∈ h(R ≤k ∪ P ≤k ) (if = 2),</p><p>Proof. We prove the result by induction on k. For k = 0, there is nothing to do but note that no edge S (x, x) has been created. Suppose that we've proven the result for some k &lt; r, and let When we first defined h, it preserved r-types by construction. The last step before we are able to conclude the proof of Theorem 2.5 is to make sure that h still preserves r-types, taking into account the S -edges added during the run of Algorithm 4:</p><p>Proof. We prove by induction on 0</p><p>There is nothing to prove for k = 0. Moving from k to k + 1, let x ∈ A 1 and let y be such that dist G1 (x, y) = d, for some 1 ≤ d ≤ k + 1. Note that y ∈ B, hence it has an image by h.</p><p>If y ∈ A 1 , the induction hypothesis allows us to conclude that</p><p>Else, Lemma 4.8 ensures that:</p><p>In both cases, tp k+1-d (G2,S2) (h(y)) = tp k+1-d (G1,S1) (y). Because of (Layer[r]), it only remains to show that the S -successors of x and h(x), as well as their S -predecessors, have the same k-type in (G , S ). Let's prove this for the successors, respectively named x + and h(x) + . If x + ∈ A 1 , then by construction h(x) + = h(x + ), and the induction hypothesis allows us to conclude.</p><p>Otherwise, neither x + nor h(x) + belongs to A 1 . Under this hypothesis, Lemma 4.7 ensures that tp r G2 (h(x)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.9">Conclusion of the proof</head><p>We are now able to conclude the proof. Recall that we want to prove that</p><p>Let τ be an r-type over Σ ∪ {S} which occurs in (G 1 , S 1 ). There are two cases to consider:</p><p>• if τ occurs outside of A 1 , then Lemma 4.8 ensures that τ = [χ] r for some frequent r-type χ. We can choose g so that χ is guaranteed to have at least t occurrences in G 1 outside of A 1 , and in G 2 outside of A 2 . This is ensured as long as</p><p>and in particular when</p><p>Lemma 4.8 then ensures that τ occurs at least t times both in (G 1 , S 1 ) and in (G 2 , S 2 ).</p><p>• if τ occurs only in A 1 , then it cannot occur in (G 2 , S 2 ) outside of A 2 (for the same reasons as above).</p><p>Lemma 4.9 guarantees that τ has the same number of occurrences in A 1 and in A 2 , hence in (G 1 , S 1 ) and in (G 2 , S 2 ).</p><p>Thus, by Hanf threshold theorem, we have shown that for every α ∈ N, there exists some f (α) ∈ N such that for any Σ-structures G 1 , G 2 of degree at most d,</p><p>This means that on the class of Σ-structures of degree at most d, any equivalence class C for ≡ Succ-inv FO α is a finite union of equivalence classes for ≡ FO f (α) , and is consequently definable by an FO-sentence ϕ C of quantifier rank f (α).</p><p>Let P be a property of structures of degree at most d definable by a sentence of Succ-inv FO of quantifier rank at most α. It is a finite union i C i of equivalence classes for ≡ Succ-inv FO α . Hence, the FO[f (α)]-sentence i ϕ Ci defines P.</p><p>This proves the inclusion Succ-inv FO ⊆ FO on structures of degree at most d.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards a characterization of orderinvariant queries over tame graphs</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symb. Log</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Expressivity and succinctness of order-invariant logics on depth-bounded structures</title>
		<author>
			<persName><forename type="first">Kord</forename><surname>Eickmeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Elberfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frederik</forename><surname>Harwath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Foundations of Computer Science (MFCS) -39th International Symposium</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Order invariance on decomposable structures</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Elberfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marlin</forename><surname>Frickenschmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science</title>
		<meeting>the 31st Annual ACM/IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<publisher>LICS</publisher>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On monadic NP vs. monadic co-np</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><forename type="middle">J</forename><surname>Stockmeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A new perspective on FO model checking of dense graph classes</title>
		<author>
			<persName><forename type="first">Jakub</forename><surname>Gajarský</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petr</forename><surname>Hlinený</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Lokshtanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Obdrzálek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ramanujan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Order-Invariant First-Order Logic over Hollow Trees</title>
		<author>
			<persName><forename type="first">Julien</forename><surname>Grange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th EACSL Annual Conference on Computer Science Logic (CSL 2020)</title>
		<imprint>
			<publisher>Schloss Dagstuhl</publisher>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Locality of order-invariant firstorder formulas</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schwentick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Log</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Elements of Finite Model Theory</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Texts in Theoretical Computer Science. An EATCS Series</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Successor-invariant first-order logic on finite structures</title>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Rossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symb. Log</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Impossibility of an algorithm for the decision problem in finite classes</title>
		<author>
			<persName><forename type="first">Boris</forename><forename type="middle">A</forename><surname>Trakhtenbrot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Doklady Akademii Nauk SSSR</title>
		<imprint>
			<date type="published" when="1950">1950</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
