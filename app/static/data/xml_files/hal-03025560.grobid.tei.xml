<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4134A6A15569B95ABF2D351E5B1826BE</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Declarative mining of negative sequential patterns</head><p>Philippe Besnard 1 and Thomas Guyet 2   Abstract. Declarative pattern mining consists in using declarative frameworks to solve pattern mining tasks. In this article, we address the task of mining negative sequential patterns in Answer Set Programming (ASP). A negative sequential pattern is specified by means of a sequence consisting of events to occur and of other events, called negative events, to be absent. For instance, containment of the pattern a ¬b c arises with an occurrence of a and a subsequent occurrence of c but no occurrence of b in between. Recent results shed light on the ambiguity of such a seemingly intuitive notation, exhibited three semantics of the negative events and proposed alternative notations for them. In this article, we propose Answer Set Programming encodings of these three semantics in order to extract frequent negative sequential patterns from a set of sequences. It relies on previous encodings of frequent sequential pattern mining. We experiment with our encoding on synthetic data and compare the numbers of extracted patterns and the computing time obtained for each kind of negation. Surprisingly, the semantics that has the best algorithmic properties for pattern mining is not associated to an encoding that is the most efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Pattern mining <ref type="bibr" target="#b10">[11]</ref> is a data mining task that consists in extracting interesting structured patterns from a set of structured examples. The standard pattern mining tasks are itemset mining, sequence mining and graph mining. The interestingness measure of a pattern is, in most of the algorithms, the number of its occurrences in the set of examples. Given a threshold k, interesting patterns are those that occur at least in k examples. In this case, the task is known as frequent pattern mining for which many algorithms have been proposed. Most of the efficient algorithmic solutions rely on an antimonotonicity property of the support: the larger the pattern, the fewer it occurs.</p><p>Declarative pattern mining aims at encoding pattern tasks in a declarative framework, and more specifically the frequent pattern mining tasks. Declarative pattern mining addressed the tasks of frequent itemset mining <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b11">12]</ref>, frequent sequential patterns <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b0">1]</ref> or frequent graph mining <ref type="bibr" target="#b5">[6]</ref>. Different declarative frameworks have been explored: Constraint Programming (CP) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b5">6]</ref>, SAT <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b0">1]</ref> and Answer Set Programming (ASP) <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b1">2]</ref>. Declarative pattern mining does not expect to be competitive with dedicated algorithms, but to take advantage of the versatility of declarative frameworks to propose pattern mining tools that could exploit background knowledge during the mining process to extract less but meaningful patterns.</p><p>In this work, we explore negative sequential patterns <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b16">17]</ref>. Standard sequential pattern mining algorithms <ref type="bibr" target="#b13">[14]</ref> extract sequential patterns that frequently occur in a set of sequences. A sequential 1 CNRS / IRIT, France, email: besnard@irit.fr 2 Institut Agro / IRISA UMR6074, France, email: thomas.guyet@irisa.fr pattern is a sequence of events or items. For example, the sequential pattern a c d is read as "a occurs and then c occurs and finally d occurs". Negative sequential patterns are sequential patterns that also specify non-occurring events. Intuitively, the syntax of a simple negative sequential pattern is as follows: a ¬b c . This pattern is read as "a occurs and then c occurs, but b does not occur in between". A negative sequential pattern can also be the premise of a rule. Guyet and Besnard <ref type="bibr" target="#b7">[8]</ref> highlighted that ¬ symbol has several semantics but only few of them have good properties for pattern mining.</p><p>In this article, we propose an ASP encoding of the mining of frequent negative sequential patterns. Our encoding relies on previous work on frequent sequential pattern mining in ASP <ref type="bibr" target="#b8">[9]</ref>. The objective of this article is also to illustrate the semantics of negative sequential patterns through declarative encodings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Sequential pattern mining</head><p>Our terminology on sequence mining follows the one in <ref type="bibr" target="#b14">[15]</ref>. Throughout this article, [n] = {1, . . . , n} denotes the set of the first n positive integers.</p><p>Let Σ be the set of items (alphabet).</p><formula xml:id="formula_0">An itemset A = {a1, a2, • • • , am} ⊆ Σ is a finite set of items. The size of A, de- noted |A|, is m. A sequence s is of the form s = s1 s2 • • • sn</formula><p>where each si is an itemset. n is the length of the sequence.</p><p>A database D is a multiset of sequences over Σ.A sequence s = s1 . . . sm with si ∈ Σ is contained in a sequence t = t1 . . . tn with m ≤ n, written s t, if si ⊆ te i for 1 ≤ i ≤ m and an increasing sequence (e1 . . . em) of positive integers ei ∈ [n], called an embedding of s in t. For example, we have a (cd) a b (cde) relative to embedding <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b2">3)</ref>. (cd) denotes the itemset made of items c and d.</p><p>Given a database D, the cover of a sequence p is the set of sequences in D that contain p: cover (p, D) = {t ∈ D | p t}. The number of sequences in D containing p is called its support, that is, support(p, D) = |cover (p, D)|. For an integer k, frequent sequence mining is about discovering all sequences p such that support(p, D) ≥ k. We often call p a (sequential) pattern, and k is also referred to as the (minimum) frequency threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Answer set programming</head><p>A logic program is a set of rules of the form a0 :-a1; . . . ; am; not am+1; . . . ; not an.</p><p>(</p><formula xml:id="formula_1">)<label>1</label></formula><p>where each ai is a propositional atom for 0 ≤ i ≤ n and not stands for default negation. If n = 0, rule (1) is called a fact. If a0 is omitted, (1) represents an integrity constraint. Semantically, a seq(1,1,d). seq <ref type="bibr">(1,2,a)</ref>. seq <ref type="bibr">(1,2,b)</ref>. seq <ref type="bibr">(1,3,c)</ref>. seq(2,1,a). seq(2,2,c). seq <ref type="bibr">(2,3,b)</ref>. seq <ref type="bibr">(2,4,c)</ref>. seq <ref type="bibr">(3,1,a)</ref>. seq <ref type="bibr">(3,2,b)</ref>. seq <ref type="bibr">(3,2,c)</ref>. seq <ref type="bibr">(3,3,a)</ref>. seq(4,1,a). seq <ref type="bibr">(4,1,b)</ref>. seq(4,2,c). seq <ref type="bibr">(5,1,a)</ref>. seq <ref type="bibr">(5,2,c)</ref>. seq <ref type="bibr">(6,1,b)</ref>. seq(7,1,c).</p><p>Listing 1. Facts specifying a database of sequences logic program induces a collection of so-called answer sets, which are distinguished models of the program determined by answer sets semantics; see <ref type="bibr" target="#b3">[4]</ref> for details. To facilitate the use of ASP in practice, several extensions have been developed. First of all, rules with variables are viewed as shorthands for the set of their ground instances. Further language constructs include conditional literals and cardinality constraints <ref type="bibr" target="#b15">[16]</ref>. The former are of the form a : b1, . . . , bm, the latter can be written as s {c1, . . . , cn} t, where a and bi are possibly default negated literals and each cj is a conditional literal; s and t provide lower and upper bounds on the number of satisfied literals in a cardinality constraint. The practical value of both constructs becomes more apparent when used in conjunction with variables. For instance, a conditional literal like a(X) : b(X) in a rule's antecedent expands to the conjunction of all instances of a(X) for which the corresponding instance of b(X) holds. Similarly, 2 {a(X) : b(X)} 4 holds whenever between two and four instances of a(X) (subject to b(X)) are true. Specifically, we rely in the sequel on the input language of the ASP system clingo <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ASP-based Sequence Mining</head><p>In this section, we introduce the sequential pattern mining tasks in ASP. The following programs correspond to the notion of skip-gaps encodings in <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7]</ref>. Gebser et al. <ref type="bibr" target="#b1">[2]</ref> uses a different encoding strategy for frequent sequential pattern that is not suitable for negative patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Fact format</head><p>We represent a database D in terms of facts seq(t,p,e), saying that item e occurs at position p in a sequence t. For instance, Listing 1 specifies a database of seven sequences: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Mining frequent sequences: basic encoding</head><p>The encoding principle for frequent sequence mining follows the one of <ref type="bibr" target="#b12">[13]</ref>, that is, each answer set comprises a single pattern of interest. In contrast to itemset mining, however, we need to take the order of items in a pattern into account to determine its support and check its frequency.</p><p>Listing 2 provides our basic encoding of frequent sequence mining borrowed from <ref type="bibr" target="#b8">[9]</ref>. It relies on two parameters: max determines a maximum length for patterns of interest, and k specifies the minimal frequency threshold. An answer set then represents a frequent pattern p = p1 . . . pm such that m ∈ [max] by atoms pat(m,p1), 1 item(I) :-seq(T,P,I).</p><p>3 slot(1). 4 { slot(X+1) } :-slot(X); X&lt;max. 5 1{ pat(X,E) : item(E) } :-slot(X).</p><p>7 patlen(L) :-pat(L,_); not pat(L+1,E):item(E). 9 emb(T,P,1) :-seq(T,P,E):pat(1,E); seq(T,P,_). 10 emb(T,P,X+1) :-emb(T,Q,X); seq(T,P,_); Q&lt;P; 11 seq(T,P,E):pat(X+1,E); 12 patlen(L); X&lt;L.</p><p>14 cover(T) :-patlen(L); emb(T,_,L).</p><p>16 :-not k { cover(T) }. A complete specification of atoms used in our ASP encodings along with their meanings is given in Table <ref type="table" target="#tab_0">1</ref>. In more detail, the rule in Line 1 of Listing 2 provides items occurring in a given database D. Lines 3 and 4 provides the slots for the itemset of a pattern with a varying length m ∈ [max]. Line 7 evaluates the concrete length of the candidate pattern. The (choice) rule in line 5 allows for picking a subset of Σ per slot to build a pattern. As a result, the rules from lines 1 to 5 establish a unique representation for a candidate pattern whose frequency remains to be checked.</p><p>To this end, the rules from Line 9 to 12 traverse each sequence t = t1 . . . tn in D to derive atoms of the form emb(t,p,x) which represent all the embeddings of the pattern in a sequence. As noted in Table <ref type="table" target="#tab_0">1</ref>, for p ∈ [n] and x ∈ [max], such an atom expresses that it exists ( i)i∈[p-1] such that pi ⊆ t i for all i ∈ [p -1] and px ⊆ tp, where p ∈ [n] and x ∈ [m]. Thus, it also means that p1 . . . px t1 . . . tp . Line 9 locates the occurrences of the first itemset in the sequence. The expression seq(t,p,e):pat(1,e) ensures that every e ∈ p1 must hold at position p of the sequence t. Line 10 finds out locations for px, the x-th itemset of the pattern, from a position q such that q ≥ i for all i ∈ [p -1], where ( i)i∈[p-1] is an embedding of p1 . . . px-1. The atoms emb(t,p,x) are further inspected, line 14, to determine the cover of a candidate pattern p. In these lines, the sequence is covered when a complete embedding has been built, i.e. up to the length of the pattern. The frequency of p is then checked in Line 16, where the cardinality constraint "k { cover(t) }" over atoms cover(t), signaling s t, expresses that at least the frequency threshold k many sequences t must include s.</p><p>Example 1. For the database in Listing 1, the pattern a (bc) leads to atoms emb(3,1,1), emb(3,1,3) and emb(3,2,2) among which emb(3,2,2) in turn yields cover(3) for the sequence a (bc) a denoted by 3. There is not any sequence for which a complete embedding can be built, and a (bc) turns out to not be frequent, given the threshold k = 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Negative sequential patterns</head><p>In this section, we introduce the notion of negative sequential pattern by giving their syntax and semantics borrowed from <ref type="bibr" target="#b7">[8]</ref>. </p><formula xml:id="formula_2">= p1 ¬q1 p2 ¬q2 • • • pn-1 ¬qn-1 pn is a finite sequence where pi ∈ 2 Σ \ {∅} for all i ∈ [n] and qi ∈ 2 Σ for all i ∈ [n -1].</formula><p>p + = p1 . . . pn is called the positive part of the NSP.</p><p>It can be noticed that Definition 1 introduces syntactic limitations on negative sequential patterns that are commonly encountered in the state of the art <ref type="bibr" target="#b16">[17]</ref>: 1) a pattern can neither start or finish by a negative itemset, 2) a pattern cannot have two successive negative itemsets. But a pattern can have successive positive itemsets considering that a negative itemsets can be empty. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Semantics of negative sequential patterns</head><p>The semantics of negative sequential patterns relies upon negative containment: a sequence s contains pattern p iff s contains a subsequence s such that every positive itemset of p is included in some itemset of s in the same order and for any negative itemset ¬qi of p, qi is not included in any itemset occurring in the sub-sequence of s located between the occurrence of the positive itemset preceding ¬qi in p and the occurrence of the positive itemset following ¬qi in p.</p><p>It turns out that the notion of negative containment has different semantics depending on the definition of "not included" itemsets and on the itemsets of the sequence to consider.</p><p>We introduce two relations comparing two itemsets P ∈ 2 Σ \ {∅} and I ∈ 2 Σ :</p><p>• partial non inclusion: P ⊆G I ⇔ ∃e ∈ P , e / ∈ I • total non inclusion: P ⊆D I ⇔ ∀e ∈ P, e / ∈ I Partial non-inclusion means that P \ I is non-empty while total noninclusion means that P and I are disjoint. By convention, ∅ ⊆D I and ∅ ⊆G I for all I ⊆ Σ.</p><p>In the sequel, we denote the general form of itemset non-inclusion by the symbol ⊆ * , meaning either ⊆G or ⊆D.</p><p>Intuitively, partial non-inclusion identifies the itemset P with a disjunction of negative constraints, i.e. at least one of the items (of P ) has to be absent from I, and total non-inclusion consider the itemset P as a conjunction of negative constraints: all items (of P ) have to be absent from I.</p><p>Choosing one non-inclusion interpretation or the other has consequences on extracted patterns as well as on pattern search. Let us illustrate this with the following dataset of sequences:</p><formula xml:id="formula_3">D =          s1 = (bc) f a s2 = (bc) (cf ) a s3 = (bc) (df ) a s4 = (bc) (ef ) a s5 = (bc) (cdef ) a          .</formula><p>Table <ref type="table" target="#tab_1">2</ref> compares the support of patterns under the two semantics of itemset non-inclusion. Since the positive part of p2 is in s2, p2 occurs in the sequence iff (cd) ⊆ * (cf ). As for total non-inclusion, it is false that (cd) ⊆D (cf ) because c occurs in (cf ), and thus p2 does not occur in s2. As for partial non-inclusion, it is true that (cd) ⊆G (cf ), because d does not occur in (cf ), and thus p2 occurs in s2. under the total and partial non-inclusion relations. Each pattern has the form b ¬q i a where q i are itemsets such that q i ⊂ q i+1 . partial total non-inclusion non-inclusion ⊆G ⊆D</p><formula xml:id="formula_4">p1 = b ¬c a {s1, s3, s4} {s1, s3, s4} p2 = b ¬(cd) a {s1, s2, s3, s4} {s1, s4} p3 = b ¬(cde) a {s1, s2, s3, s4} {s1} p4 = b ¬(cdeg) a {s1, s2, s3, s4, s5}<label>{s1}</label></formula><p>Now, we formulate the notions of sub-sequence, non-inclusion and absence by extending the concept of embedding (see Section 2.1) to negative patterns.</p><p>Definition 2 (Strict and soft embeddings of negative patterns). Let s = s1 . . . sn be a sequence and p = p1 ¬q1 . . . ¬qm-1 pm be a negative sequential pattern.</p><p>An increasing</p><formula xml:id="formula_5">3 tuple = ( i)i∈[m] ∈ [n]</formula><p>m is a soft-embedding of pattern p in sequence s iff:</p><formula xml:id="formula_6">• pi ⊆ se i for all i ∈ [m] • qi ⊆ * sj, for all j ∈ [ei + 1, ei+1 -1] and for all i ∈ [m -1] An increasing 3 tuple e = (ei) i∈[m] ∈ [n] m is a strict-embedding of pattern p in sequence s iff: • pi ⊆ se i for all i ∈ [m] • qi ⊆ * j∈[e i +1,e i+1 -1] sj for all i ∈ [m -1]</formula><p>Intuitively, the constraint of a negative itemset qi is checked on the sequence's itemsets at positions in interval [ei + 1, ei+1 -1], i.e. between occurrences of the two positive itemsets surrounding the negative itemset in the pattern. A soft embedding considers individually each of the sequence's itemsets of [ei + 1, ei+1 -1] while a strict embedding consider them as a whole. Let us now give some lemmata about the relations between the different types of embedding. 4   Lemma 1. In the case that ⊆ * is ⊆D, e is a soft-embedding iff e is a strict-embedding</p><formula xml:id="formula_7">Lemma 2. Let p = p1 ¬q1 . . . ¬qn-1 pn ∈ N such that |qi| ≤ 1 for all i ∈ [n -1]</formula><p>, then e is a soft-embedding iff e is a strictembedding.</p><p>At this point, we have exhibited four semantics for negative pattern embeddings. Lemmata 1 and 2 concluded to the equivalence of soft and strict-embeddings when the itemset non-inclusion relation is ⊆D.</p><p>In <ref type="bibr" target="#b7">[8]</ref>, we proposed notations to disambiguate syntactically the different types of negation (¬(a1, . . . , a l i ) or ¬{a1, . . . , a l i } or ¬|a1, . . . , a l i |). ]l, u[ denotes the interval of integers [l + 1, u -1].</p><p>• ¬(a1, . . . , a l i ) is evaluated as {a1, . . . , a l i } ⊆G sj, ∀j ∈]ei, ei+1[ for all i ∈ [m -1] (2) Intuitively, you check that, in between se i (i.e., a match for pi) and se i+1 (i.e., a match for pi+1), none of these sj include all of a1, . . . , a l i .</p><p>• ¬{a1, . . . , a l i } is evaluated as {a1, . . . , a</p><formula xml:id="formula_8">l i } ⊆G j∈]e i ,e i+1 [ sj for all i ∈ [m -1]<label>(3)</label></formula><p>Intuitively, we check that there exists some item in a1, . . . , a l i that does not occur at all in between se i (i.e., a match for pi) and se i+1 (i.e., a match for pi+1).</p><p>• ¬|a1, . . . , a l i | is evaluated as {a1, . . . , a l i } ⊆D sj, ∀j ∈]ei, ei+1[ for all i ∈ [m -1] (4) Intuitively, we check that every item in a1, . . . , a l i fails to occur in between se i (i.e., a match for pi) and se i+1 (i.e., a match for pi+1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Multiple occurrences</head><p>Another point that determines the semantics of negative containment concerns the multiple occurrences of some pattern in a sequence: should at least one or should all occurrences of the pattern positive part in the sequence satisfy the non-inclusion constraints? 4 Proofs of these Lemmata can be found in the extended version of <ref type="bibr" target="#b7">[8]</ref>.</p><p>The strong containment relation states that a negative pattern p occurs in a sequence s iff there exists at least one occurrence of the positive part of pattern p in sequence s and every such occurrence satisfies the negative constraints; the strong containment relation states p occurs in a sequence s iff there exists at least one occurrence of the positive part of pattern p in sequence s and at least one of these occurrences satisfies the negative constraints.</p><p>Example 4 (Strong vs weak occurrence semantics). Let p = a b ¬c d be a pattern, s1 = a b e d and s2 = a b c a d e b d be two sequences. Thus, p + = a b d occurs once in s1 hence there is no difference for occurrences of p in s1 under the two semantics. However, p + occurs four times in s2 through embeddings (1, 2, 5), <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">8)</ref>, <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8)</ref> and (4, 7, 8). The first two occurrences do not satisfy the negative constraint (¬c) but the last two occurrences do. Under the weak occurrence semantics, pattern p occurs in sequence s2 whereas it fails to do so under the strong occurrence semantics. The following choice rule illustrates the generation of negative itemsets of kind ¬| • |. Similar rules yield the negative part of a candidate pattern for the two other kinds of negations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ASP encodings of negative sequential patterns</head><p>{ negpat(X,E): item(E), not pat(X,E) } :slot(X), X&lt;L, patlen(L).</p><p>Note that we assume that it is not possible to have several different kinds of negated itemsets at the same position. For instance, pattern a¬|b|¬{c}d is not possible.</p><p>In the next section, we give the rules for negative constraints. A negative constraint denotes a constraint upon an embedding ( i)i∈ <ref type="bibr">[n]</ref> of the positive part that is expressed by a negated itemset in the candidate negative pattern. If all negative constraints are satisfied, then ( i)i∈[n] is an embedding of the negative pattern. Then, it is further used to evaluate the containment of the candidate pattern p in a sequence t.</p><p>The core of the encoding relies on the construction of an embedding. We adapt the definition of the predicate emb/3 to negative sequential patterns as follow: let p = p1 ¬q1 . . . pm be a negative sequential pattern, t = t1 . . . tn be a sequence, and ν a Boolean value, then emb(t,ρ,x,ν) means that ∃(ei</p><formula xml:id="formula_9">) i∈[x-1] such that x ∈ [m], ρ ∈ [n] and 1. pi ⊆ te i for all i ∈ [x -1], 2. px ⊆ tρ, 3. ∃y ∈ [x -1] s.t. qy is not satisfied for the partial embedding (ei) i∈[p-1] if ν is true, 4. ∀y ∈ [x -1] s.t. qy is satisfied for the partial embedding (ei) i∈[p-1] if ν is false,</formula><p>Note that "qy is not satisfied for the partial embedding (ei) i∈[p-1] " refers to the semantics of negation (see previous section) whatever the kind of occurrence (weak or strong).</p><p>1 emb(T,P,1,0) :-seq(T,P,E):pat(1,E); seq(T,P,_).</p><p>3 emb(T,P,X+1,1) :-emb(T,Q,X,1); Q&lt;P; 4 seq(T,P,E):pat(X+1,E); seq(T,P,_); 5 patlen(L); X&lt;L.</p><p>7 emb(T,P,X+1,0) :-emb(T,Q,X,0); 8 seq(T,P,E):pat(X+1,E); seq(T,P,_); P&gt;Q; 9 #count{ R : not seq(T,R,Ep), csnegpat(X,Ep), R=(Q+1)..(P-1)}=(P-Q-1); 10 patlen(L); X&lt;L.</p><p>12 emb(T,P,X+1,1) :-emb(T,Q,X,0); 13 seq(T,P,E):pat(X+1,E); seq(T,P,_); P&gt;Q; 14 #count{ R : not seq(T,R,Ep), csnegpat(X,Ep), R=(Q+1)..(P-1)}!=(P-Q-1); 15 patlen(L); X&lt;L. ν is a Boolean value that stores the information for an embedding of the positive part that these embedding satisfies or not the negative constraints.</p><p>With this definition it happens that if there is an atom of the embedding emb(t,p,l,ν) where l is the size of the positive part of the pattern whatever the ν value, then the positive part occurs in the sequence t. If ν is false, this means that there exists an embedding for the negative sequential pattern, thus p weakly occurs in t. If there is no embedding such that ν is true, then it means that no embedding of the positive part is an embedding of the negative sequential pattern. Thus p strongly occurs in t if it is not the case. The following rules encode the rules of pattern covering for the two different definitions of weak and strong occurrences of a candidate pattern. weakcover(T) :-patlen(L); emb(T,_,L,0). strongcover(T) :-patlen(L); emb(T,_,L,_); #count{ T : emb(T,_,L,1) }=0.</p><p>Then, depending on the kind of covering considered, line 16 of Listing 2 is adapted to the minimal occurrence number constraint.</p><p>The remainder of this section details the encoding for each semantics of negative itemsets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Encoding of ¬(•) negative constraints</head><p>Listing 3 gives the encoding yielding the emb/4 atoms considering patterns with ¬(•)/csnegpat/2 negative itemsets.</p><p>In this encoding, the Line 1 states that 1 of an embedding is a position p in the sequence t such p1 ⊆ tp. For the first pattern itemset, there are no negative constraints at previous position. Thus, ν is false (0).</p><p>The rule in lines 3-5 is similar to the rule in lines 10-12 of Listing 2. They yield the x+1 of an embedding of the positive part of the pattern where ( i)i∈[x] is an embedding of p1 ¬q1 . . . px s.t. there exists y ∈ [x -1] s.t. qy is not satisfied (ν is true). In this case, ( i)i∈[x+1] is an embedding of p1 ¬q1 . . . px+1 that neither satisfies all the negative constraints. Thus, the truth value of ν is propagated.</p><p>The rules in lines 7-15 consider the case of an embedding ( i)i∈[x] of the negative pattern p1 ¬q1 . . . px such that all the negative constraints are satisfied. Then, there are two cases for the embedding</p><formula xml:id="formula_10">( i)i∈[x+1].</formula><p>If there exists a position p in the sequence t such that px+1 ⊆ tp and the negative constraint qx is satisfied, then the atom emb(t,p,l,ν) is yielded with ν set to false (0). That is, the rule in lines 7-10. But, if there exists a position p, p &gt; x in the sequence t such that px+1 ⊆ tp and the negative constraint qx is not satisfied, then the atom emb(t,p,l,ν) is yielded with ν set to true <ref type="bibr" target="#b0">(1)</ref>. That is, the rule in lines 12-15. Note that these two rules could be factorised to avoid redundancies. For sake of readability, we prefer to present this redundant syntax.</p><p>Let us now detail how to evaluate the negative constraint qx (i.e., the set of atoms csnegpat(x,e)). According to Equation 2, the negative constraint qx is satisfied iff ∀r ∈] i, i+1[, ∃e ∈ qx, s.t. e ∈ tr. It is equivalent to evaluate whether |{r ∈] i, i+1[|∃e ∈ qx, e ∈ tr}| is equal to i+1i + 1. This latter constraint is encoded line 9 and its opposite is encoded line 14. The #count is an aggregate to compute the number of different R values satisfying conditions after the colon.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Encoding of ¬| • | negative constraints</head><p>The negative constraints qx with ¬| • |/negpat/2 is satisfied iff ∀r ∈] i, i+1[, ∀e ∈ qx, e ∈ tr (see Equation <ref type="formula">4</ref>). This means that it is not satisfied iff {r ∈] i, i+1[|e ∈ qx ∧ e ∈ tr} is empty.</p><p>Listing 4 yields atoms of predicate emb/4 with the same principle of Listing 3. The lines 3 or 8 evaluate |{r ∈] i, i+1[|e ∈ qx∧ ∈ 1 negislen(X,N) :-X=1..(L-1); patlen(L); N=#count{E : cnegpat(X,E)}.</p><p>3 emb(T,P,X+1,1) :-emb(T,Q,X,0); Q&lt;P; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experiments and results</head><p>The previous section exhibited the ease of modeling of the different semantics of negative sequential patterns in order to extract the frequent ones. It is worth noticing that only few of these semantics have properties to design algorithms that are both efficient and complete <ref type="bibr" target="#b7">[8]</ref>. More precisely, the anti-monotonicity property holds with weak occurrences of ¬| • |, and weaker versions of anti-monotonicity hold with the strong occurrences of ¬| • |.</p><p>The question investigated in these experiments is whether the solver takes advantage of these properties to achieve the mining task within a lower computation time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental setting</head><p>We conducted experiments on synthetic sets of sequences generated with the generator of <ref type="bibr" target="#b1">[2]</ref>, without hidden patterns (pure random sequences).</p><p>The usage of synthetic sets of sequences allows us to control and analyze the most important characteristics of data wrt the computing time. To be more precise, we randomly generated sets of 100 sequences. Each sequence contains 10 itemsets. Each itemset is of size 2. Items are randomly generated according to a Gaussian law (some items are more frequent than others) over a vocabulary of 20 items. For each data point, we then give average computing times over five similar sets of sequences.</p><p>All the experiments have been using the clingo solver 5 on a desktop computer with enough memory to prevent from using cache 5 clingo version 5.3.1 memory and ran with a single thread. A timeout was set up to 5 minutes.</p><p>For sake of better interpretability of the results and of computation time, the negative sequential patterns contain only one kind of negated itemset (¬| • |, ¬(•) or ¬{•}), the length of the positive part of a pattern is at most 3, and the size of negated itemsets is limited to 2 items.</p><p>Note that we do not compare our approach with dedicated algorithms, e.g. <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b16">17]</ref> that are undoubtly significantly more efficient for this task. We remind that declarative pattern mining aims at achieving reasonable computation time for mid-sized set of examples. Thus, it can be used to inject some expert knowledge in the mining process to reduce the number of patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Results</head><p>Figure <ref type="figure" target="#fig_6">1</ref> compares the number of patterns that are extracted through the different semantics of negative patterns. Note that it is very interesting to have this study as no algorithm can extract a complete set of frequent negative sequential patterns for all negation semantics.</p><p>The figures take into account only the number of patterns for runs ended before timeout (5 minutes). It explains that there are only few results for ¬{•} which is often out of the timeout.</p><p>The results illustrated in Figure <ref type="figure" target="#fig_6">1</ref> are consistent with theoretical results <ref type="bibr" target="#b7">[8]</ref>. First, we notice that there are more patterns extracted with weak-occurrences than with strong-occurrences. For identical settings, there are in average 2.80 ± 2.13 times more patterns with weak-occurrences than with strong-occurrences. Second, ¬| • | is the strongest negative constraint after ¬{•} and finally ¬(•) is the weakest. As a consequence, there are more extracted patterns for ¬(•), than for ¬| • |. The number of patterns for ¬{•} is in-between when available. We can first notice that extracting negative sequential patterns with ¬{•} lacks efficiency and the mining tasks does not finish before timeout in most cases.</p><p>Then, despite the larger number of occurrences of weakoccurrences, evaluating weak occurrences is more efficient that evaluating the strong ones. It is unsurprising. Indeed, as soon as a weakoccurrence has been found, the atom cover(t) is proved to be true without necessarily exploring the other embeddings of the positive part of the pattern. For strong occurrences, it is mandatory to evaluate negative patterns for every embedding of the positive part of the candidate pattern. q q q q q q q q q q q -{.  q q q q q q q q q -{.  The surprising result of this experiment is in the comparison between ¬(•) and ¬| • |. It turns out that mining negative sequential patterns with ¬(•) is significantly more efficient than with ¬| • |. This result is enhanced by the fact that there are many more patterns to extract with ¬(•) than with ¬| • |. So there are more patterns but more efficiently extracted. The opposite outcome was expected due to our theoretical results that exhibited anti-monotonicity for ¬| • |, but not for ¬(•).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>This article extends the framework of mining sequential patterns with Answer Set Programming to negative sequential patterns. We encoded the three different semantics of absent events proposed in <ref type="bibr" target="#b7">[8]</ref>. The first interest of the approach is to evaluate the impact of the choice of one of the semantics on the set of extracted patterns. In this article, we focused on the size of this set. Deeper experiments on real datasets would be interesting to identify the differences between these sets of patterns.</p><p>Our experiments on synthetic data show that the kind of negated itemset for which the encoding is the most efficient is not the expected one. Indeed, we expected to have better efficiency with ¬| • |. A possible explanation of this observation may be that there are also anti-monotonicity properties of ¬(•) for partial orders that are not usually investigated for pattern mining algorithms <ref type="bibr" target="#b9">[10]</ref>. More inves-tigation is required to confirm this intuition. But it encourages us to think that there are potentially better encodings for ¬| • |. One of our perspectives is to investigate saturation programming techniques that may be suitable and efficient to encode weak-occurrences of negative sequential patterns.</p><p>In addition, these encodings may be used to characterize what patterns can still be mined by incomplete mining heuristics. Wang et al. <ref type="bibr" target="#b16">[17]</ref> reviewed such algorithms but they do not characterise the extracted patterns among the complete set of patterns. Comparing their outputs with the outputs of our encodings makes it possible to investigate this question.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Seq. d (ab) c a c b c a (bc) a (ab) c a c b c Considering the minimal frequency threshold k = 2, one can check that a , b , c , a b , (ab) , a c , b c , and (ab) c are the frequent patterns of the database.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Listing 2 .</head><label>2</label><figDesc>Basic encoding of frequent sequence mining . . . , pat(1,pm). That is, the first argument expresses the positions of items. For instance, the atoms pat(1,a), pat(2,b), and pat(2,c) stand for the (frequent) pattern a (bc) of the database given in Listing 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 2 .</head><label>2</label><figDesc>This example illustrates the notations introduced in Definition 1. Consider Σ = {a, b, c, d} and p = a ¬(bc) (ad) d ¬(ab) d . Let p1 = {a}, p2 = {ad}, p3 = {d}, p4 = {d} and q1 = {bc}, q2 = ∅, q3 = {ab}. p + = a (ad) d d .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 3 (</head><label>3</label><figDesc>Itemset absence semantics). Let p = a ¬(bc) d be a pattern and consider four sequences as follows: Sequence ⊆D ⊆D ⊆G ⊆G strict soft strict soft s1 = a c b e d s2 = a (bc) e d s3 = a b e d s4 = a e dNotice that each sequence contains a unique occurrence of p + = a d , the positive part of pattern p. Considering soft-embedding and partial non-inclusion ( ⊆ * := ⊆G), p occurs in s1, s3 and s4 but not in s2. Considering strict-embedding and partial non-inclusion, p occurs in s3 and s4. Indeed, items b and c occur between occurrences of a and d in s1 and s2. Considering total non-inclusion ( ⊆ * := ⊆D) and either type of embeddings, the absence of an itemset is satisfied if any of its items is absent. Hence, p occurs only in s4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>In the following, we introduce new facts to encode negations in negative sequential patterns. The pat(x,e) atom now represents the positive part of a negative sequential pattern. The negated itemsets are encoded by terms of three predicates: negpat/2 (for ¬| • |), cnegpat/2 (for ¬{•}) and csnegpat/2 (for ¬(•)). For instance, the pattern a¬|b|a¬(bd)c is encoded by the facts pat(1,a), pat(2,a), pat(3,c), negpat(1,b), csnegpat(2,b) and csnegpat(2,d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2</head><label>2</label><figDesc>Figure 2 compares computing times of ASP-based negative sequential pattern mining with different semantics of negative patterns.We can first notice that extracting negative sequential patterns with ¬{•} lacks efficiency and the mining tasks does not finish before timeout in most cases.Then, despite the larger number of occurrences of weakoccurrences, evaluating weak occurrences is more efficient that evaluating the strong ones. It is unsurprising. Indeed, as soon as a weakoccurrence has been found, the atom cover(t) is proved to be true without necessarily exploring the other embeddings of the positive part of the pattern. For strong occurrences, it is mandatory to evaluate negative patterns for every embedding of the positive part of the candidate pattern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Boxplots of the numbers of patterns for computing all frequent negative sequential patterns wrt different thresholds (24, 27 and 30) using ASP. Each plot corresponds to one specific semantic, from left to right ¬{•}, ¬| • | and ¬(•). Blue (resp. red) boxplots correspond to weak (resp. strong) occurrences).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Boxplots of times for computing all frequent negative sequential patterns wrt different thresholds (24, 27 and 30) using ASP. Each plot corresponds to one specific semantic, from left to right ¬{•}, ¬| • | and ¬(•). Blue (resp. red) boxplots correspond to weak (resp. strong) occurrences).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Atoms representing a pattern p = p i 1≤i≤m , where 1 ≤ m ≤ max, and a given multiset D of sequences t = t j 1≤j≤n Atom Meaning slot(x) 1 ≤ x ≤ m refers to the position x of an item sx in p pat(x,e) px = e is the item at position x in p, where x ∈ [m] item(e) item e belongs to some t ∈ D cover(t) p1 . . . pm t1 . . . tn , that is, p t emb(t,p,x) ∃(ei) i∈[p-1] such that pi ⊆ te i for all i ∈ [p -1] and px ⊆ tp, where p ∈ [n] and x ∈ [m].</figDesc><table><row><cell>Definition 1 (Negative sequential patterns (NSP)). A negative se-</cell></row><row><cell>quential pattern p</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Lists of sequences in D supported by negative patterns (p i ) i=1..4</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Encoding for embedding with ¬{•}/cnegpat/2 negative itemsets tr}|. It is compared to 0 to assign the truth value to ν for x+1 (if exists, i.e., px+1 ⊆ t x+1 ).5.3 Encoding of ¬{•} negative constraintsFinally, the negative constraint qx with ¬{•}/cnegpat/2 is satisfied iff ∃e ∈ qx, e ∈ r∈] i , i+1 [ tr (see Equation3). This means that it is not satisfied iff ∀e ∈ qx, e ∈ r∈] i , i+1 [ tr or in other words that |{e ∈ qx|e∈ r∈] i , i+1 [ tr}| = |qx-1|.Listing 5 yields atoms of predicate emb/4 with the same principle of Listing 3. Line 1 evaluates the size of negative itemsets. negislen(x,n) states that |qx| = n. Lines 6 and 12 evaluate |{e ∈ qx|e ∈ r∈] i , i+1 [ tr}|. It is compared to |qx| to assign the truth value to ν for x+1 (if exists, i.e., px+1 ⊆ t x+1 ).</figDesc><table><row><cell>4</cell><cell>seq(T,P,E):pat(X+1,E); seq(T,P,_);</cell></row><row><cell>5</cell><cell>negislen(X,N);</cell></row><row><cell>6</cell><cell>N=#count{ Ep : seq(T,R,Ep), cnegpat(X,Ep), Q&lt;R, R&lt;P};</cell></row><row><cell>7</cell><cell>patlen(L); X&lt;L.</cell></row><row><cell cols="2">9 emb(T,P,X+1,0) :-emb(T,Q,X,0); Q&lt;P;</cell></row><row><cell>10</cell><cell>seq(T,P,E):pat(X+1,E); seq(T,P,_);</cell></row><row><cell>11</cell><cell>negislen(X,N);</cell></row><row><cell>12</cell><cell>N!=#count{ Ep : seq(T,R,Ep), cnegpat(X,Ep), Q&lt;R, R&lt;P};</cell></row><row><cell>13</cell><cell>patlen(L); X&lt;L.</cell></row><row><cell></cell><cell>Listing 5.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>By an increasing tuple e, we mean a tuple such that i &lt; i+1 (in particular, repetitions are not allowed).</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A SAT-based approach for discovering frequent, closed and maximal patterns in a sequence</title>
		<author>
			<persName><forename type="first">Emmanuel</forename><surname>Coquery</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Said</forename><surname>Jabbour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lakhdar</forename><surname>Sais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yakoub</forename><surname>Salhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Artificial Intelligence</title>
		<meeting>the European Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">242</biblScope>
			<biblScope unit="page" from="258" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Knowledge-based sequence mining with ASP</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Guyet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">René</forename><surname>Quiniou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Romero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Torsten</forename><surname>Schaub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Join Conference on Artificial Intelligence</title>
		<meeting>International Join Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1497" to="1504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Clingo = ASP + Control: Preliminary report</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Gebser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roland</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Torsten</forename><surname>Schaub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Technical Communications of the Thirtieth International Conference on Logic Programming</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Classical negation in logic programs and disjunctive databases</title>
		<author>
			<persName><forename type="first">Mickael</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New Generation Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="365" to="385" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Miningzinc: A declarative framework for constraint-based mining</title>
		<author>
			<persName><forename type="first">Tias</forename><surname>Guns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anton</forename><surname>Dries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siegfried</forename><surname>Nijssen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guido</forename><surname>Tack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raedt</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">244</biblScope>
			<biblScope unit="page" from="6" to="29" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On declarative modeling of structured pattern mining</title>
		<author>
			<persName><forename type="first">Tias</forename><surname>Guns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergey</forename><surname>Paramonov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Negrevergne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshops at the Thirtieth AAAI Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Enhancing sequential pattern mining with time and reasoning</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Guyet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
		<respStmt>
			<orgName>Université de Rennes</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Habilitation à diriger des recherches</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Semantics of negative sequential patterns</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Guyet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Besnard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Artificial Intelligence (ECAI)</title>
		<meeting>European Conference on Artificial Intelligence (ECAI)<address><addrLine>Santiago de Compostela, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficiency analysis of ASP encodings for sequential pattern mining tasks</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Guyet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yves</forename><surname>Moinard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">René</forename><surname>Quiniou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Torsten</forename><surname>Schaub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Knowledge Discovery and Management</title>
		<editor>
			<persName><forename type="first">Bruno</forename><surname>Pinaud</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fabrice</forename><surname>Guillet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bruno</forename><surname>Cremilleux</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Cyril</forename><surname>De</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Runz</forename></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="41" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">NegPSpan: efficient extraction of negative sequential patterns with embedding constraints</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Guyet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">René</forename><surname>Quiniou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="563" to="609" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Frequent pattern mining: current status and future directions</title>
		<author>
			<persName><forename type="first">Jiawei</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hong</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="86" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Decomposition based SAT encodings for itemset mining problems</title>
		<author>
			<persName><forename type="first">Saïd</forename><surname>Jabbour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lakhdar</forename><surname>Sais</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yakoub</forename><surname>Salhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific-Asia Conference on Knowledge Discovery and Data Mining</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="662" to="674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Itemset mining as a challenge application for answer set enumeration</title>
		<author>
			<persName><forename type="first">Matti</forename><surname>Järvisalo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on Logic Programming and Nonmonotonic Reasoning</title>
		<meeting>the conference on Logic Programming and Nonmonotonic Reasoning</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="304" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Sequential pattern miningapproaches and algorithms</title>
		<author>
			<persName><forename type="first">Carl</forename><forename type="middle">H</forename><surname>Mooney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">F</forename><surname>Roddick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Survey</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Constraint-based sequence mining using constraint programming</title>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Negrevergne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tias</forename><surname>Guns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Integration of AI and OR Techniques in Constraint Programming</title>
		<meeting>International Conference on Integration of AI and OR Techniques in Constraint Programming</meeting>
		<imprint>
			<publisher>CPAIOR</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="288" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Extending and implementing the stable model semantics</title>
		<author>
			<persName><forename type="first">Patrik</forename><surname>Simons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilkka</forename><surname>Niemelá</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timo</forename><surname>Soininen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="181" to="234" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Negative sequence analysis: A review</title>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Longbing</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Survey</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="32" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
