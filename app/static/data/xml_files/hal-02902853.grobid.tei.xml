<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Linear high-order deterministic tree</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Paul</forename><forename type="middle">D</forename><surname>Gallot</surname></persName>
							<email>paul.gallot@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Aurélien</forename><surname>Lemay</surname></persName>
							<email>aurelien.lemay@univ-lille.fr</email>
						</author>
						<author>
							<persName><forename type="first">Sylvain</forename><surname>Salvati</surname></persName>
							<email>sylvain.salvati@univ-lille.fr</email>
						</author>
						<author>
							<persName><forename type="first">Colis</forename><forename type="middle">Aurélien</forename><surname>Lemay</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Colis</forename><surname>Sylvain</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">Université de Lille</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Université de Lille</orgName>
								<orgName type="institution" key="instit2">INRIA</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Université de Lille</orgName>
								<orgName type="institution" key="instit2">INRIA</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Linear high-order deterministic tree</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C32CEEAF3A266B1ADB41D32E6ECCBC05</idno>
					<idno type="DOI">10.4230/LIPIcs.MFCS.2020.34</idno>
					<note type="submission">Submitted on 18 Sep 2020</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>2012 ACM Subject Classification Theory of computation → Transducers</term>
					<term>Theory of computation → Lambda calculus</term>
					<term>Theory of computation → Tree languages Transducers,λ-calculus,Trees Digital Object Identifier 10.4230/LIPIcs.MFCS.2020.34</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Tree Transducers formalize transformations of structured data such as Abstract Syntax Trees, XML, JSON, or even file systems. They are based on various mechanisms that traverse tree structures while computing an output: Top-Down and Bottom-Up tree transducers <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b3">4]</ref> which are direct generalizations of deterministic word transducers <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b2">3]</ref>, but also more complex models such as macro tree transducers <ref type="bibr" target="#b10">[11]</ref> (MTT) or streaming tree transducers <ref type="bibr" target="#b0">[1]</ref> (STT) to cite a few.</p><p>Logic offers another, more descriptive, view on tree transformations. In particular, Monadic Second Order (MSO) logic defines a class of tree transformations (MSOT) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> which is expressive and is closed under composition. It coincides with the class of transformations definable with MTT enhanced with a regular look-ahead and restricted to finite copying <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>, and also with the class of STT <ref type="bibr" target="#b0">[1]</ref>.</p><p>We argue here that simply typed λ-calculus gives a uniform generalisation of all these different models. Indeed, they can all be considered as classes of programs that read input tree structures, and, at each step, compose tree operations which in the end produce the final output. Each of these tree operations can be represented using simply typed λ-terms.</p><p>In this paper, we define top-down tree transducers that follow the usual definitions of such machines, except that rules can produce λ-terms of arbitrary types. We call these machines, High-Order Top-down tree transducers, or High-Order Deterministic Tree Transducers (HODT) in the deterministic case. This class of transducers naturally contains top-down tree transducers, as they are HODT of order 0 (the output of rules are trees), but also MTT, which are HODT of order 1 (outputs are tree contexts). They also contain STT, which can be translated directly into HODT of order 3 with some restricted continuations. Also, STT traverse their input tree represented as a string in a leftmost traversal (a stream). This constraint could easily be adapted to our model but would yield technical complications that are not the focus of this paper. Finally, our model generalizes High Level Tree Transducers defined in <ref type="bibr" target="#b11">[12]</ref>, which also produce λ-term, but restricted to the safe λ-calculus case.</p><p>In this paper we focus on the linear and almost linear restrictions of HODT. In terms of expressiveness, linear HODTR (HODTR lin ) corresponds to the class of MSOT. This links our formalism to other equivalent classes of transducers, such as finite-copying macro-tree transducers <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>, with an important difference: the linearity restriction is a simple syntactic restriction, whereas finite-copying or the equivalent single-use-restricted condition are both global conditions that are harder to enforce. For STT, the linearity condition corresponds to the copyless condition described in <ref type="bibr" target="#b0">[1]</ref> and where the authors prove that any STT can be made copyless.</p><p>The relationship of HODTR lin to MSOT is made via a transformation that reduces the order of transducers. We indeed prove that for any HODTR lin , there exists an equivalent HODTR lin whose order is at most 3. This transformation allows us to prove then that HODTR lin are equivalent to Attribute Tree Transducers with the single use restriction (ATT sur ). In turn, this shows that HODTR lin are equivalent to MSOT <ref type="bibr" target="#b1">[2]</ref>.</p><p>One of the main interests of HODTR lin is that λ-calculus also offers a simple composition algorithm. This approach gives an efficient procedure for composing two HODTR lin . In general, this procedure raises the order of the produced transducer. In comparison, composition in other equivalent classes are either complex or indirect (through MSOT). In any case, our procedure has a better complexity. Indeed, it benefits from higher-order which permits a larger number of implementations for a given transduction. The complexity of the construction is also lowered by the use of a notion of determinism slightly more liberal than usual that we call weak determinism.</p><p>The last two results allow us to obtain a composition algorithm for other equivalent classes of tree transducer, such as MTT or STT: compile into HODTR lin , compose, reduce the order, and compile back into the original model. The advantage of this approach over the existing ones is that the complex composition procedure is decomposed into two simpler steps (the back and forth translations between the formalisms are unsurprising technical procedures). We believe in fact that existing approaches <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b0">1]</ref> combine in one step the two elements, which is what makes them more complex.</p><p>The property of order reduction also applies to a wider class of HODT, almost linear HODT (HODTR al ). Again here, this transformation allows us to prove that this class of tree transformations is equivalent to that of Attribute Tree Transducers which is known to be equivalent to MSO tree transformations with unfolding <ref type="bibr" target="#b1">[2]</ref>, i.e. MSO tree transduction that produce Directed Acyclic Graphs (i.e. trees with shared sub-trees) that are unfolded to produce a resulting tree. We call these transductions Monadic Second Order Transductions with Sharing (MSOTS). Note however that HODTR al are not closed under composition.</p><p>Section 2 presents the technical definitions used throughout the paper. In particular, it gives the definitions of the various notions of transducers studied in the paper and also the notion of weak determinism. Section 3 studies the expressivity of linear and almost linear higher-order transducer by relating them to MSOT and MSOTS. It focuses more specifically on the order reduction procedure that is at the core of the technical work. Section 4 presents the composition algorithm for linear higher-order transducers. This algorithm is based on Girard's coherence spaces and can be interpreted as a form of partial evaluation for linear higher-order programs. Finally we conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Definitions</head><p>This section presents the main formalisms we are going to use throughout the paper, namely simply typed λ-calculus, finite state automata and high-order transducers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">λ-calculus</head><p>Fix a finite set of atomic types A, we then define the set of types over A, types(A), as the types that are either an atomic type, i.e. an element of A, or a functional type (A → B), with</p><p>A and B being in types(A). The operator → is right-associative and</p><formula xml:id="formula_0">A 1 → • • • → A n → B denotes the type (A 1 → (• • • → (A n → B) • • • )).</formula><p>The order of a type A is inductively defined by order(A) = 0 when A ∈ A, and order(A → B) = max(order(A) + 1, order(B)).</p><p>A signature Σ is a triple (C, A, τ ) with C being a finite set of constants, A a finite set of atomic types, and τ a mapping from C to types(A), the typing function.</p><p>We allow ourselves to write types(Σ) to refer to the set types(A). The order of a signature is the maximal order of a type assigned to a constant (i.e. max{order(τ (c)) | c ∈ C}). In this work, we mostly deal with tree signatures which are of order 1 and whose set of atomic types is a singleton. In such a signature with atomic type o, the types of constants are of the form</p><formula xml:id="formula_1">o → • • • → o → o.</formula><p>We write o n → o for an order-1 type which uses n + 1 occurrences of o,</p><formula xml:id="formula_2">for example, o 2 → o denotes o → o → o.</formula><p>When c is a constant of type A, we may write c A to make explicit that c has type A. Two signatures</p><formula xml:id="formula_3">Σ 1 = (C 1 , A 1 , τ 1 ) and Σ 2 = (C 2 , A 2 , τ 2 )</formula><p>so that for every c in C 1 ∩ C 2 we have τ 1 (c) = τ 2 (c) can be summed, and we write We assume that for every type A, there is an infinite countable set of variables of type A.</p><formula xml:id="formula_4">Σ 1 + Σ 2 for the signature (C 1 ∪ C 2 , A 1 ∪ A 2 , τ ) so that if c is in C 1 , τ (c) = τ 1 (c) and if c is in C 2 , τ<label>(</label></formula><p>When two types are different the set of variables of those types are of course disjoint. As with constants, we may write x A to make it clear that x is a variable of type A.</p><p>When Σ is a signature, we define the family of simply typed λ-terms over Σ, denoted</p><formula xml:id="formula_5">Λ(Σ) = (Λ A (Σ)) A∈types(Σ)</formula><p>, as the smallest family indexed by types(Σ) so that:</p><formula xml:id="formula_6">if c A is in Σ, then c A is in Λ A (Σ), x A is in Λ A (Σ), if A = B → C and M is in Λ C (Σ), then (λx B .M ) is in Λ A (Σ), if M is in Λ B→A (Σ) and N is in Λ B (Σ), then (M N ) is in Λ A (Σ).</formula><p>The term M is a pure λ-term if it does not contain any constant c A from Σ. When the type is irrelevant we write M ∈ Λ(Σ) instead of M ∈ Λ A (Σ). We drop parentheses when it does not bring ambiguity. In particular, we write λx 1 . . . x n .M for (λx 1 (. . . (λx n .M ) . . . )), and</p><formula xml:id="formula_7">M 0 M 1 . . . M n for ((. . . (M 0 M 1 ) . . . )M n ).</formula><p>The set fv(M ) of free variables of a term M is inductively defined on the structure of M : For example, given a tree signature Σ 1 with one atomic type o and two constants f of type</p><formula xml:id="formula_8">fv(c) = ∅, fv(x) = {x}, fv(M N ) = fv(M ) ∪ fv(N ), fv(λx.M ) = fv(M ) -{x}.</formula><formula xml:id="formula_9">o 2 → o and a of type o, the term M = (λy 1 y 2 .f y 1 (f a y 2 )) a (f x a) with free variable x of type</formula><p>o is linear because each variable (y 1 , y 2 and x) occurs exactly once in M . The term M contains a β-redex so:</p><formula xml:id="formula_10">(λy 1 y 2 .f y 1 (f a y 2 )) a (f x a) → β (λy 2 .f a (f a y 2 )) (f x a) → β f a (f a (f x a)).</formula><p>The term f a (f a (f x a)) has no β-redex so it is the β-normal form of M . We call a term almost linear when it is β-convertible to a syntactically almost linear term. Almost linear terms are characterized also by typing properties (see <ref type="bibr" target="#b14">[15]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Tree Automata</head><p>We present here the classical definition of deterministic bottom-up tree automaton (BOT) adapted to our formalism. A BOT A is a tuple (Σ P , Σ, R) where:</p><formula xml:id="formula_11">Σ = (C, {o}, τ</formula><p>) is a first-order tree signature, the input signature, Σ P = (P, {o}, τ P ) is the state signature, and is such that for every p ∈ P , τ P (p) = o.</p><p>Constants of P are called states, R is a finite set of rules of the form a p 1 . . . p n → p where:</p><formula xml:id="formula_12">p,p 1 , . . . , p n are states of P , a is a constant of Σ with type o n → o.</formula><p>An automaton is said deterministic when there is at most one rule in R for each possible left hand side. It is non-deterministic otherwise.</p><p>Apart from the notation, our definition differs from the classical one by the fact there are no final states, and hence, the automaton does not describe a language. This is due to the fact that BOT will be used here purely for look-ahead purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">High-Order Deterministic top-down tree Transducers</head><p>From now on we assume that Σ i is a tree signature for every number i and that its atomic type is o i .</p><p>A Linear High-Order Deterministic top-down Transducer with Regular look-ahead</p><formula xml:id="formula_13">(HODTR lin ) T is a tuple (Σ Q , Σ 1 , Σ 2 , q 0 , R, A)</formula><p>where:</p><formula xml:id="formula_14">Σ 1 = (C 1 , {o 1 }, τ 1</formula><p>) is a first-order tree signature, the input signature,</p><formula xml:id="formula_15">Σ 2 = (C 2 , {o 2 }, τ 2</formula><p>) is a first-order tree signature, the output signature,</p><formula xml:id="formula_16">Σ Q = (Q, {o 1 , o 2 }, τ s )</formula><p>is the state signature, and is such that for every q ∈ Q, τ s (q) is of the form o 1 → A q where A q is in types(Σ 2 ). Constants of Q are called states,</p><formula xml:id="formula_17">q 0 ∈ Q is the initial state,</formula><p>A is a BOT over the tree signature Σ 1 , the look-ahead automaton, with set of states P , R is a finite set of rules of the form</p><formula xml:id="formula_18">q(a - → x ) - → p → M (q 1 x 1 ) . . . (q n x n )</formula><p>where: </p><formula xml:id="formula_19">q, q 1 , . . . , q n ∈ Q are states of Σ Q , a is a constant of Σ 1 with type o n 1 → o 1 , - → x = x 1 , . . . ,</formula><formula xml:id="formula_20">M is a linear term of type A q1 → • • • → A qn → A q built on signature Σ 2 + Σ Q .</formula><p>there is one rule per possible left-hand side (determinism).</p><p>Notice that we have given states a type of the form o 1 → A where A ∈ types(o 2 ). The reason why we do this is to have a uniform notation. Indeed, a state q is meant to transform, thanks to the rules in R, a tree built in Σ 1 into a λ-term built on Σ 2 with type A q . So we simply write q M N 1 . . . N n when we want to transform M with the state q and pass N 1 ,. . . , N n as arguments to the result of the transformation. We write Σ T for the signature However, we consider as well that transducers may produce programs instead of first order terms.</p><formula xml:id="formula_21">Σ 1 + Σ 2 + Σ Q . Notice</formula><p>The linearity constraint on M affects both bound variables and the free variables</p><p>x 1 , . . . , x n , meaning that all of the subtrees x 1 , . . . , x n are used in computing the output. That will be important for the composition of two transducers because if the first transducer fails in a branch of its input tree then the second transducer, applied to that tree, must fail too. This restriction forcing the use of input subtrees does not reduce the model's expressivity because we can always add a state q which visits the subtree but only produces the identity function on type o 2 (this state then has type</p><formula xml:id="formula_22">A q = o 1 → o 2 → o 2 ).</formula><p>Almost linear high-order deterministic top-down transducer with regular look-ahead (HODTR al ) are defined similarly, with the distinction that a term M appearing as a righthand side of a rule should be almost linear.</p><p>As we are concerned with the size of the composition of transducers, we wish to relax a bit the notion of HODTR lin . Indeed, when composing HODTR lin we may have to determinize the look-ahead so as to obtain a HODTR lin , which may cause an exponential blow-up of the look-ahead. However if we keep the look-ahead non-deterministic, the transducer stays deterministic in the weaker sense that only one rule of the transducer can apply when it is actually run. For this we adopt a slightly relaxed notion of deterministic transducer that we call high-order weakly deterministic top-down transducer with regular look-ahead (HOWDTR lin ). They are similar to HODTR lin but they can have nondeterministic automata as look-ahead with the proviso that when q(a x 1 . . .</p><formula xml:id="formula_23">x n ) p 1 , . . . , p n → M [x 1 , . . . , x n ] and q(a x 1 . . . x n ) p 1 , . . . , p n → M [x 1 , . . . ,</formula><p>x n ] are two distinct rules of the transducer then it must be the case that for some i there is no tree that is recognized by both p i and p i . This property guarantees that when transforming a term at most one rule can apply for every possible state. Notice that it suffices to determinize the look-ahead so as to obtain a HODTR lin from a HOWDTR lin , and therefore the two models are equivalent.</p><p>Given a HODTR lin , a HODTR al or a HOWDTR lin T , we write T :: Σ 1 -→ Σ 2 to mean that the input signature of T is Σ 1 and its output signature is Σ 2 .</p><p>A transducer T induces a notion of reduction on terms. A T -redex is a term of the form Given a term M built on Σ T , we write |M | T to denote its normal form modulo = β,T .</p><formula xml:id="formula_24">q(a M 1 . . . M n ) if and only if q(a x 1 . . . x n ) p 1 , . . . , p n → M [x 1 , . . . , x n ]</formula><p>Then we write rel(T ) for the relation:</p><formula xml:id="formula_25">{(M, |q 0 M | T ) | M is a closed term of type o 1 and |q 0 M | T ∈ Λ(Σ 2 )} .</formula><p>Notice that when |q 0 M | T contains some states of T , as it is usual, the pair (M,</p><formula xml:id="formula_26">|q 0 M | T )</formula><p>is not in the relation.</p><p>Given a finite set of trees L 1 on Σ 1 and L 2 included in Λ Aq 0 , we respectively write T (L 1 )</p><p>and T -1 (L 2 ) for the image of L 1 by T and the inverse image of L 2 by T .</p><p>P. D. Gallot, A. Lemay and S. Salvati 34:7</p><p>We give an example of a HODTR lin T that computes the result of additions of numeric expressions (numbers being represented in unary notation). For this we use an input tree signature with type o 1 , and constants Z o1 , S o1 and add o1→o1→o1 which respectively denote zero, the successor function and addition. The output signature is similar but different to avoid confusion: it uses the type o 2 and constants O o2 , N o2→o2 which respectively denote zero and successor.</p><p>We do not really need the look-ahead automaton for this computation, so we omit it for this example. We could have a blank look-ahead automaton A with one state l and rules:</p><p>A(Z) = l, A(S l) = l, A(add l l) = l; which would not change the result of the transducer.</p><p>The transducer has two states: q 0 of type o 1 → o 2 (the initial state), and q i of type</p><formula xml:id="formula_27">o 1 → o 2 → o 2 .</formula><p>The rules of the transducer are the following:</p><formula xml:id="formula_28">q 0 (Z) → O, q 0 (S x) → N (q i x O),</formula><p>q 0 (add x y) → q i x (q i y O), q i (Z) → λx.x, q i (S x) → λy.N (q i x y), q i (add x y) → λz.q i x (q i y z),</p><p>As an example, we perform the transduction of the following term add(S(S Z))(S(S(S Z))): q 0 (add(S(S Z))(S(S(S Z)))) → T (q i (S(S Z)))(q i (S(S(S Z)))O) * → T (λy 1 .N ((λy 2 .N ((λx.x)y 2 ))y 1 ))((λy 3 .N ((λy 4 .N ((λy 5 .N ((λx.x)y 5 ))y 4 ))</p><formula xml:id="formula_29">y 3 ))O) * → β N (N (N (N (N O))))</formula><p>The state q i transforms a sequence of n symbols S into a λ-term of the form λx.N n (x), and the add maps both its children into such terms and composes them. The state q 0 simply applies O to the resulting term.</p><p>Note that our reduction strategy here has consisted in first computing the T -redices and then reducing the β-redices. This makes the computation simpler to present. As we mentioned above a head-reduction strategy would lead to the same result.</p><p>The order of the HODTR lin T is max{order(A q ) | q ∈ Q}. Before going further, we want to discuss how our framework relates to other transduction models. More specifically how the notion of order of transformations generalizes the DTOP and MTT transduction models:</p><p>if we relax the constraint of linearity of our transducers, then DTOP and MTT can be seen as non-linear transducers of order 0 and 1 respectively. In contrast of these, we chose to study the constraint of linearity instead of the constraint of order and, in this paper, we will explore the benefits of this approach. Firstly we will explain why increasing the order beyond order 3 does not increase the expressivity of neither HODTR lin nor HODTR al .</p><p>Next we will show how HODTR lin and HOWDTR lin both capture the expressivity of tree transformations defined by monadic second order logic. Lastly, we will prove that, contrary to MTT, the class of HODTR lin transformations is closed under composition, we will give an algorithm for computing the composition of HODTR lin and HOWDTR lin , and explain why using HOWDTR lin avoids an exponential blow-up in the size of the composition transducer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Order reduction and expressiveness</head><p>In this section we outline a construction that transforms a transducer of HODTR lin or HODTR al into an equivalent linear or almost linear transducer of order ≤ 3. These two constructions are similar and central to proving that HODTR lin and HODTR al are respectively equivalent to Monadic Second Order Transductions from trees to trees (MSOT) and to Monadic Second Order Transductions from trees to terms (i.e. trees with sharing) (MSOTS).</p><p>We will later show that there are translations between HODTR lin of order 3 and attribute tree M F C S 2 0 2 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>34:8</head><p>Linear High-Order Deterministic Tree transducers with Regular look-ahead transducers with the single use restriction and between HODTR al of order 3 and attribute tree transducers. These two models are known to be respectively equivalent to MSOT and MSOTS <ref type="bibr" target="#b1">[2]</ref>.</p><p>The central idea in the construction consists in decomposing λ-terms M into pairs M , σ</p><p>where M is a pure λ-term and σ is a substitution of variables with the following properties:</p><formula xml:id="formula_30">M = β M .σ,</formula><p>the free variables of M have at most order 1, for every variable x, σ(x) is a closed λ-term, the number of free variables in M is minimal.</p><p>In such a decomposition, we call the term M a template. In case M is of type A, linear or almost linear, it can be proven that M can be taken from a finite set <ref type="bibr" target="#b13">[14]</ref>. The linear case is rather simple, but the almost linear case requires some precaution as one needs first to put M in syntactically almost linear form and then make the decomposition. Though the almost linear case is more technical the finiteness argument is the same in both cases and is based on proof theoretical arguments in multiplicative linear logic which involves polarities in a straightforward way.</p><p>The linear case conveys the intuition of decompositions in a clear manner. One takes the normal form of M and then delineates the largest contexts of M , i.e. first order terms that are made only with constants and that are as large as possible. These contexts are then replaced by variables and the substitution σ is built accordingly. The fact that the contexts are chosen as large as possible makes it so that no introduced variable can have as argument a term of the form x M 1 . . . M n where x is another variable introduced in the process. Therefore, the new variables introduced in the process bring one negative atom and several (possibly 0) positive ones and all of them need to be matched with positive and negative atoms in the type of M as, under these conditions, they cannot be matched together.</p><p>This explains why there are only finitely many possible templates for a fixed type.</p><p>Theorem 1. For all type A built on tree signature Σ, the set of templates of closed linear (or almost linear) terms of type A is finite.</p><p>Moreover, the templates associated with a λ-term can be computed compositionally (i.e.</p><p>from the templates of its parts). As a result, templates can be computed by the look-ahead of HODTR lin or of HODTR al . When reducing the order, we enrich the look-ahead with template information while the substitution that is needed to reconstruct the produced term is outputted by the new transducer. The substitution is then performed by the initial state used at the root of the input tree which then outputs the same result as the former transducer.</p><p>The substitution can be seen as a tuple of order 1 terms. It is represented as a tuple using Church encoding, i.e. a continuation. This makes the transducer we construct be of order 3.</p><p>Theorem 2. Any HODTR lin (resp. HODTR al ) has an equivalent HODTR lin (resp.</p><p>HODTR al ) of order 3.</p><p>The proof of this result shows that every HODTR lin (or HODTR al ) can be seen as mapping trees to tuples of contexts and combining these contexts in a linear (resp. almost linear)</p><p>way. This understanding of HODTR lin and of HODTR al allows us to prove that they are respectively equivalent to Attribute Tree Transducers with Single Use Restriction (ATT sur );</p><p>and to Attribute Tree Transducers (ATT). Then, using <ref type="bibr" target="#b1">[2]</ref>, we can conclude with the following expressivity result:</p><p>Theorem 3. HODTR lin are equivalent to MSOT and HODTR al are equivalent to MSOTS.</p><p>P. D. Gallot, A. Lemay and S. Salvati</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>34:9</head><p>The full proofs of these are rather technical and are not detailed here, but they appear in the full version of the article. The proof that HODTR lin are equivalent to MSOT could have been simpler by using the equivalence with MTT with the single-use restricted property instead of ATT, but we would still need to use ATT to show that HODTR al are equivalent to MSOTS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Composition of HODTR lin</head><p>As we are interested in limiting the size of the transducer that is computed, and even though our primary goal is to compose HODTR lin , this section is devoted to the composition of HOWDTR lin . Indeed, working with non-deterministic look-aheads allows us to save the possibly exponential cost of determinizing an automaton.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Semantic analysis</head><p>Let</p><formula xml:id="formula_31">T 1 = (Σ Q , Σ 1 , Σ 2 , q 0 , R 1 , A 1 ) and T 2 = (Σ P , Σ 2 , Σ 3 , p 0 , R 2 , A 2 ) be two Linear High-Order</formula><p>Weakly Deterministic tree Transducers with Regular look-ahead. The rules of T 1 can be written: q(a -→ x ) -→ → M (q 1 x 1 ) . . . (q n x n ) where q, q 1 , . . . , q n ∈ Q are states of T 1 ,</p><formula xml:id="formula_32">- → = 1 , . . . , n are states of A 1 and the λ-term M is of type A q1 → • • • → A qn → A q .</formula><p>Our goal is to build a HOWDTR lin T :: Σ 1 → Σ 3 that does the composition of T 1 and T 2 , so we want to replace a rule such as that one with a new rule which corresponds to applying T 2 to the term M .</p><p>In order to do so, we need, for each o 2 tree in M , to know the associated state ∈ L 2 of T 2 's look-ahead, and the state p ∈ P of T 2 which is going to process that node. So with any such tree we associate the pair (p, ). In this case we call (p, ) the token which represents the behavior of the tree. In general, we want to associate tokens not only with trees, but also with λ-terms of higher order. For example, we map an occurrence of a symbol </p><formula xml:id="formula_33">a ∈ Σ 2 of type o 2 → o 2 → o 2 ,</formula><formula xml:id="formula_34">o 2 = {(p, ) | p ∈ P, ∈ L 2 } A → B = {f g | f ∈ A , g ∈ B }</formula><p>Naturally, the semantic token associated with a λ-term M of type A built on atomic type o 2 will depend on the context where the term M appears. For example a tree of atomic type o 2 can be processed by any state p ∈ P of T 2 , and a term of type A → B can be applied to any argument of type A. But for any such M taken out of context, there exists a finite set of possible tokens for it. For example, a given tree of type o 2 can be processed by any state p ∈ P depending on the context, but it has always the same look-ahead ∈ L 2 .</p><p>In order to define the set of possible semantic tokens for a term, we use a system of derivation rules. The following derivation rules are used to derive judgments that associate a term with a semantic token. So a judgment Γ M : f associates term M with token f , where Γ is a substitution which maps free variables in M to tokens. The rules are:</p><formula xml:id="formula_35">p(a - → x ) 1 , . . . , n T2 -→ M (p 1 x 1 ) . . . (p n x n ) A 2 (a ( 1 , . . . , n )) = a : (p 1 , 1 ) • • • (p n , n ) (p, ) Γ 1 M : f g Γ 2 N : f Γ 1 , Γ 2 M N : g Γ, x A : f M : g Γ λx A .M : f g f ∈ A x A : f x A : f</formula><p>Using this system we can derive, for any term M A , all the semantic tokens that correspond to possible behaviours of M A when it is processed by T 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Unicity of derivation for semantic token judgements</head><p>We will later show that we can compute the image of M from the derivation of the judgement M : f , assuming that f is the token that represents the behaviour of T 2 on M . But before that we need to prove that for a given term M and token f the derivation of the judgement M : f is unique: Theorem 5. For every type A, for every term M of type A and every token f ∈ A , there is at most one derivation D :: M : f . This theorem relies in part on the fact that tokens form a coherent space, as introduced by Girard in <ref type="bibr" target="#b12">[13]</ref>. The full proof of this theorem is not detailed here but can be found in the full version of the article on Hal. Now that we have shown that there is only one derivation per judgement M : f , we are going to see how to use that derivation in order to compute the term N that is the image of M by transducer T 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Collapsing of token derivations</head><p>We define a function (we call it collapsing function) which maps every derivation D :: M : f to a term D which corresponds to the output of transducer T 2 on term M assuming that M has behaviour f . Definition 6. Let D be a derivation. We define D by induction on D, there are different cases depending on the first rule of D:</p><formula xml:id="formula_36">If D is of the form: p(a - → x ) 1 , . . . , n T2 -→ N (p 1 x 1 ) . . . (p n x n ) A 2 (a ( 1 , . . . , n )) = a : (p 1 , 1 ) • • • (p n , n ) (p, ) then D = N ,</formula><p>if D is of the form:</p><formula xml:id="formula_37">D 1 :: Γ 1 N 1 : f g D 2 :: Γ 2 N 2 : f Γ 1 , Γ 2 N 1 N 2 : g then D = D 1 D 2 ,</formula><p>if D is of the form:</p><formula xml:id="formula_38">D 1 :: Γ, x A : f N : g Γ λx A .N : f g then D = λx.D 1 ,</formula><p>if D is of the form:</p><formula xml:id="formula_39">f ∈ A x A : f x A : f then D = x f .</formula><p>We can check that, for all derivation D :: M : f , the term D is of type f given by: (p, ) = A p and f g = f → g.</p><p>Now that we have associated, with any pair (M, f ) such that f is a semantic token of term M , a term N = D which represents the image of M by T 2 , we need to show that replacing M with N in the computation of transducers leads to the same results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Construction of the transducer which realizes the composition</head><p>We recall some notations:</p><formula xml:id="formula_40">T 1 = (Σ Q , Σ 1 , Σ 2 , q 0 , R 1 , A 1 ) and T 2 = (Σ P , Σ 2 , Σ 3 , p 0 , R 2 , A 2 ) are</formula><p>two HOWDTR lin , Q = {q 1 , . . . , q m } is the set of states of T 1 and, for every state q i ∈ Q, we note A qi the type of q i (t) when t is a tree of type o 1 . For all type A built on o 2 , the set of tokens of terms of type A is noted A and is finite.</p><p>Previously, we saw how to apply transducer T 2 to terms M of type A built on the atomic type o 2 , so we can apply T 2 to terms which appear on the left side of rules of T 1 :</p><formula xml:id="formula_41">q(a - → x ) - → → M (q i1 x 1 ) . . . (q in x n ) .</formula><p>In a rule such as this one, in order to replace term M with term N = D where D is the unique derivation of the judgement M : f , we need to know which token f properly describes the behaviour of T 2 on M . The computation of that token is done in the look-ahead automaton A of T .</p><p>We define the set of states of A as:</p><formula xml:id="formula_42">L = L 1 × A q1 × • • • × A qm</formula><p>With any tree t (of type o 1 ) we want to associate the look-ahead of T 1 on t and, for each state q i ∈ Q of T 1 , a token of q i (t). The transition function of the look-ahead automaton A is defined by, for all ( 1 , f → and, for all state q i ∈ Q, f i is such that in T 1 there exists a rule q i (a -→ x ) 1 , . . . , n T1 → M (q i1 x 1 ) . . . (q in x n ) and a derivation of the judgement M : f 1,i1</p><p>• • • f n,in f i . Note that this look-ahead automaton is non-deterministic in general, but the transducer is weakly deterministic in the sense that, at each step, even if several look-ahead states are possible, only one rule of the transducer can be applied.</p><p>We define the set of states Q of transducer T by:</p><formula xml:id="formula_43">Q = {(q, f ) | q ∈ Q, f ∈ A q } ∪ {q 0 }</formula><p>Then we define the set R of rules of transducer T as the set of rules of the form:</p><formula xml:id="formula_44">(q, f )(a - → x ) ( 1 , f 1,1 , . . . , f 1,m ), . . . T → D ((q i1 , f 1 ) x 1 ) . . . ((q in , f n ) x n )</formula><p>such that there exists in T 1 a rule: q(a -→ x ) 1 , . . .</p><formula xml:id="formula_45">T1 → M (q i1 x 1 ) . . . (q in x n ) and D is a derivation of the judgement M : f 1,i1 • • • f n,in f .</formula><p>Because of Theorem 5 that set of rules is weakly deterministic.</p><p>To that set R we then add rules for the initial state q 0 , which simply replicate the rules of states of the form (q 0 , (p 0 , )): for all a ∈ Σ 1 , all ( 1 , f 1,1 , . . . , f 1,m ), . . . , ( n , f n,1 , . . . , f n,m ) ∈ L and all rule in R of the form:</p><formula xml:id="formula_46">(q 0 , (p 0 , l))(a - → x ) ( 1 , f 1,1 , . . . , f 1,m ), . . . T → M ((q 1 , f 1 ) x 1 ) . . . ((q n , f n ) x n )</formula><p>where p 0 is the initial state of T 2 and l ∈ L 2 is a state of the look-ahead automaton of T 2 , we add the rule :</p><formula xml:id="formula_47">q 0 (a - → x ) ( 1 , f 1,1 , . . . , f 1,m ), . . . T → M ((q 1 , f 1 ) x 1 ) . . . ((q n , f n ) x n )</formula><p>This set R of rules is still weakly deterministic according to Theorem 5.</p><p>We have thus defined the HOWDTR lin T = (Σ Q , Σ 1 , Σ 3 , q 0 , R, A). It is important to note that the set A q of tokens of type A q is where HOWDTR lin and HODTR lin differ in their complexity: the deterministic alternative to the weakly deterministic T would require to store with the state not a single token, but a set of two-by-two coherent tokens, that would bring the size of Q to 1 + Σ q∈Q 2 | Aq | which would be exponential in the size of T 2 and doubly exponential in the size of types of T 1 .</p><p>Then there is the look-ahead automaton: its set of states is</p><formula xml:id="formula_48">L = L 1 × A q1 × • • • × A qm . So the number of states is in O(|L 1 | (|P | |L 2 |) Σ q∈Q |Aq|</formula><p>). The size of the set of rules of the look-ahead automaton is in O(Σ a (n) ∈Σ1 |L| n+1 ) where n is the arity of the constant a (n) .</p><p>Finally there is the set R of rules of T . For every judgement M : With a fixed input signature Σ 1 , the time complexity of the algorithm computing T is a polynomial in the sizes of T 1 and T 2 , with only the sizes of types of states of T 1 as exponents.</p><formula xml:id="formula_49">f 1,i1 • • • f n,in</formula><p>Note that, as our model generalizes other classes of transducers, it is possible to perform their composition in our setting. Thanks to results of Theorem 2, it is then possible to reduce the order of the result of the composition, and obtain a HODTR lin that can be converted back in those other models. This methods gives an important insight on the composition procedure for those other formalisms.</p><p>In comparison, the composition algorithms for equivalent classes of transductions are either not direct or very complex as they essentially perform composition and order reduction at once. For instance, composition of single used restricted MTT is obtained through MSO ( <ref type="bibr" target="#b10">[11]</ref>). High-level tree transducers <ref type="bibr" target="#b11">[12]</ref> go through a reduction to iterated pushdown tree transducers and back. The composition algorithm for Streaming Tree Transducers described in <ref type="bibr" target="#b0">[1]</ref> is direct, but made complex by the fact that the algorithm hides this reduction of order.</p><p>The double-exponential complexity of composition of HODTR lin compares well to the non-elementary complexity of composition in equivalent non-MSOT classes of transducers.</p><p>Although the simple exponential complexity of composition in MSOT is better, we should account for the fact that the MSOT model does not attempt to represent the behavior of programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion and future work</head><p>In this paper we have presented a new mechanical characterization of Monadic Second Order</p><p>Transductions. This characterization is based on simply typed λ-calculus which allows us to generalize with very few primitives most of the mechanisms used to compute the output in the transducer literature. The use of higher-order allows us to propose an arguably simple algorithm for computing the composition of linear higher-order transducers which coincide with MSOT. The correctness of this algorithm is based on denotation semantics (coherence P. D. Gallot, A. Lemay and S. Salvati 34:13 spaces) of λ-calculus and the heart of the proof uses logical relations. Thus, the use of λ-calculus allows us to base our work on standard tools and techniques rather than developing our own tools as is often the case when dealing with transducers. Moreover, this work sheds some light on how composition is computed in other formalisms. Indeed, we argue that for M T T sur , STT, or ARR sur , the composition must be the application of our composition algorithm followed by the order reduction procedure that we use to prove the equivalence with logical transductions.</p><p>The notion of higher-order transducer has already been studied <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b15">16]</ref>, however, there is still some work to be done to obtain direct composition algorithms. We plan to generalize our approach of the linear case to the general one and devise a semantic based partial evaluation for the composition of higher-order transducers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>4 Linear</head><label>4</label><figDesc>c) = τ 2 (c). The sum operation over signatures being associative and commutative, we write Σ 1 + • • • + Σ n to denote the sum of several signatures. M F C S 2 0 2 0 34:High-Order Deterministic Tree transducers with Regular look-ahead</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Another example: the term M 2 = (λy.f y y) (x a) with free variable x of type o → o is syntactically almost linear because the variable y which occurs twice in the term is of the atomic type o. It β-reduces to the term M 2 = f (x a) (x a) which is not syntactically almost linear, so β-reduction does not preserve syntactical almost linearity. P. D. Gallot, A. Lemay and S. Salvati 34:5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>is a rule of T and (the β-normal forms of) M 1 , . . . , M n are respectively accepted by A with the states p 1 , . . . , p n . In that case, a T -contractum of q(a M 1 . . . M n ) is M [M 1 , . . . , M n ]. Notice that T -contracta are typed terms and that they have the same type as their corresponding T -redices. The relation of T -contraction relates a term M and a term M when M is obtained from M by replacing one of its T -redex with a corresponding T -contractum. We write M → T M when M T -contracts to M . The relation of β-reduction is confluent, and so is the relation of T -reduction as transducers are deterministic, moreover, the union of the two relations is terminating. It is not hard to prove that it is also locally confluent and thus confluent. It follows that → β,T (which is the union of → β and → T ) is confluent and strongly normalizing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>whose arguments x 1 Definition 4 .</head><label>14</label><figDesc>and x 2 (of type o 2 ) respectively have look-ahead states 1 and 2 and are processed by states p 1 and p 2 ∈ P of T 2 , to the token(p 1 , 1 ) (p 2 , 2 ) (p, )where (p, ) is the token of the tree a x 1 x 2 (of type o 2 ). We formally define tokens as follows: The set of semantic tokens A over a type A built on atomic type o 2 is defined by induction:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>M F C S 2 0 2 0 34: 12 2 ,</head><label>0122</label><figDesc>Linear High-Order Deterministic Tree transducers with Regular look-aheadTheorem 7. T = T 2 • T 1Finally, we will analyze the complexity of this algorithm and show that using the algorithm on HOWDTR lin instead of HODTR lin avoids an exponential blow-up of the size of the produced transducer.First the set of statesQ of T is of size |Q | = 1 + Σ q∈Q | A q | where | A q | is the number of tokens of type A q . | A q | = (|P | |L 2 |)|Aq| where |P | is the number of states of transducer T |L 2 | is the number of states of the look-ahead automaton of transducer T 2 and |A q | is the size of the type A q . So the size ofQ is O(Σ q∈Q (|P | |L 2 |) |Aq| ), that is a polynomial in the size of T 2 to the power of the size of types of states of T 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>f</head><label></label><figDesc>, finding a derivation D of that judgement and computing the correspondingD is in O(|M | 2 ) time where |M | is the size of M . The number of possible rules is in O(Σ a (n) ∈Σ1 (|Q |) n+1 ). So computing R is done in time O(|R| 2 Σ a (n) ∈Σ1 (|Q |) n+1) where R is the set of rules of T 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Terms which have no free variables are called closed. We write M [x 1 , . . . , x k ] to emphasize that fv(M ) is included in {x 1 , . . . , x k }. When doing so, we write M [N 1 , . . . , N k ] for the capture avoiding substitution of variables x 1 , . . . , x k by the terms N 1 , . . . , N k . In other contexts, we simply use the usual notation M [N 1 /x 1 , . . . , N k /x k ]. Moreover given a substitution θ, we write M.θ for the result of applying this (capture avoiding) substitution and we write θ[N 1 /x 1 , . . . , N k /x k ] for the substitution that maps the variables x i to the terms N i but is otherwise equal to θ. Of course, we authorize such substitutions only when the λ-term N i has the same type as the variable x i .</figDesc><table><row><cell>We take for granted the notions of β-contraction, noted → β , β-reduction, noted</cell><cell>*  → β ,</cell></row><row><cell>β-conversion, noted = β , and β-normal form for terms.</cell><cell></cell></row><row><cell cols="2">Consider closed terms of type o that are in β-normal form and that are built on a tree</cell></row><row><cell>signature, they can only be of the form a t 1 . . . t</cell><cell></cell></row></table><note><p><p>n where a is a constant of type o n → o and t 1 , . . . , t n are closed terms of type o in β-normal form. This is just another notation for ranked trees. So when the type o is meant to represent trees, types of order 1 which have the form o → • • • → o → o represent functions from trees to trees, or more precisely tree contexts. Types of order 2 are types of trees parametrized by contexts. The notion of order captures the complexity of the operations that terms of a certain type describe.</p>A term M is said linear if each variable (either bound or free) in M occurs exactly once in M . A term M is said syntactically almost linear when each variable in M of non-atomic type occurs exactly once in M . Note that, through β-reduction, linearity is preserved but not syntactic almost linearity.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>x n are variables of type o 1 , they are the child trees of the root labeled a,</figDesc><table /><note><p>-→ p = p 1 , . . . , p n are in P (the set of states of the look-ahead A),</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Linear High-Order Deterministic Tree transducers with Regular look-ahead the first argument of a state in Σ Q . Finally, remark that we did not put any requirement on the type of the initial state. So as to restrict our attention to transducers as they are usually understood, it suffices to add the requirement that the initial state is of type o 1 → o 2 .</figDesc><table><row><cell>34:6</cell></row><row><cell>M F C S 2 0 2 0</cell></row></table><note><p>also that the right-hand part of a rule is a term that is built only with constants of Σ 2 , states from Σ Q and variables of type o 1 . Thus, in order for this term to have a type in types(Σ 2 ), it is necessary that the variables of type o 1 only occur as</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>1,1 , . . . , f 1,n ), . . . , ( n , f m,1 , . . . , f m,n ) ∈ L: a ( 1 , f 1,1 , . . . , f 1,m ) . . . ( n , f n,1 , . . . , f n,m )</figDesc><table /><note><p><p>A → ( , f 1 , . . . , f m )</p>where a 1 . . . n A1</p></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Streaming tree transducers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Antoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="31" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A comparison of tree transductions defined by monadic second order logic and by attribute grammars</title>
		<author>
			<persName><forename type="first">Roderick</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joost</forename><surname>Engelfriet</surname></persName>
		</author>
		<idno type="DOI">10.1006/jcss.1999.1684</idno>
		<ptr target="https://doi.org/10.1006/jcss.1999.1684,doi:10.1006/jcss.1999.1684" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="50" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A generalization of Ginsburg and Rose&apos;s characterisation of g-s-m mappings</title>
		<author>
			<persName><forename type="first">C</forename><surname>Choffrut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 79</title>
		<imprint>
			<publisher>SV</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="88" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Tree Automata Techniques and Applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://tata.gforge.inria.fr/" />
		<imprint>
			<date type="published" when="2007-10-12">October, 12th, 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Monadic second-order definable graph transductions: a survey</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="53" to="75" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Handbook of Graph Grammars and Computing by Graph Transformations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Graph Grammars</title>
		<editor>
			<persName><surname>Rozenberg</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
	<note>Foundations</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Automata, Languages and Machines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Eilenberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Acad. Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On relations defined by generalized finite automata</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Elgot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mezei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM J. of Res. and Dev</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="88" to="101" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Macro tree transducers, attribute grammars, and mso definable tree translations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Engelfriet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maneth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="34" to="91" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The equivalence problem for deterministic MSO tree transducers is decidable</title>
		<author>
			<persName><forename type="first">J</forename><surname>Engelfriet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Maneth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="206" to="212" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Macro tree transducers</title>
		<author>
			<persName><forename type="first">J</forename><surname>Engelfriet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Vogler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="71" to="146" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">High level tree transducers and iterated pushdown tree transducers</title>
		<author>
			<persName><forename type="first">Joost</forename><surname>Engelfriet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiko</forename><surname>Vogler</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF02915449</idno>
		<ptr target="https://doi.org/10.1007/BF02915449,doi:10.1007/BF02915449" />
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="131" to="192" />
			<date type="published" when="1988-10">Oct 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Linear logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1" to="102" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Distributional learning and context/substructure enumerability in nonlinear tree grammars</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kanazawa</surname></persName>
		</author>
		<author>
			<persName><surname>Yoshinaka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Grammar</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="94" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Almost affine lambda terms</title>
		<author>
			<persName><forename type="first">Makoto</forename><surname>Kanazawa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>National Institute of Informatics</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Higher-order multi-parameter tree transducers and recursion schemes for program verification</title>
		<author>
			<persName><forename type="first">Naoki</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naoshi</forename><surname>Tabuchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hiroshi</forename><surname>Unno</surname></persName>
		</author>
		<idno type="DOI">10.1145/1707801.1706355</idno>
		<idno>doi:10.1145/ 1707801.1706355</idno>
		<ptr target="http://doi.acm.org/10.1145/1707801.1706355" />
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="495" to="508" />
			<date type="published" when="2010-01">January 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Generalized Finite Automata Theory With an Application to a Decision Problem of Second-Order Logic</title>
		<author>
			<persName><forename type="first">J</forename><surname>Thatcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Systems Theory</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="81" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Xml type checking using high-level tree transducer</title>
		<author>
			<persName><forename type="first">Akihiko</forename><surname>Tozawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Functional and Logic Programming</title>
		<editor>
			<persName><forename type="first">Masami</forename><surname>Hagiya</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Philip</forename><surname>Wadler</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="81" to="96" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
