<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Oracle simulation: a technique for protocol composition with long term shared secrets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2020-08-10">August 10, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Hubert</forename><surname>Comon</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Charlie</forename><surname>Jacomme</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LSV</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">ENS Paris-Saclay</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<orgName type="institution" key="instit4">Université Paris</orgName>
								<orgName type="institution" key="instit5">Saclay</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Guillaume</forename><surname>Scerri</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Université Versailles Saint-Quentin &amp; Inria</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Oracle simulation: a technique for protocol composition with long term shared secrets</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2020-08-10">August 10, 2020</date>
						</imprint>
					</monogr>
					<idno type="MD5">D8D79FA6D88C76B4CE2FB5FB5844D997</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We provide a composition framework together with a variety of composition theorems allowing to split the security proof of an unbounded number of sessions of a compound protocol into simpler goals. While many proof techniques could be used to prove the subgoals, our model is particularly well suited to the Computationally Complete Symbolic Attacker (CCSA) model.</p><p>We address both sequential and parallel composition, with state passing and long term shared secrets between the protocols. We also provide with tools to reduce multi-session security to single session security, with respect to a stronger attacker. As a consequence, our framework allows, for the first time, to perform proofs in the CCSA model for an unbounded number of sessions.</p><p>To this end, we introduce the notion of O-simulation: a simulation by a machine that has access to an oracle O. Carefully managing the access to long term secrets, we can reduce the security of a composed protocol, for instance P Q, to the security of P (resp. Q), with respect to an attacker simulating Q (resp. P ) using an oracle O. As demonstrated by our case studies the oracle is most of the time quite generic and simple.</p><p>These results yield simple formal proofs of composed protocols, such as multiple sessions of key exchanges, together with multiple sessions of protocols using the exchanged keys, even when all the parts share long terms secrets (e.g. signing keys). We also provide with a concrete application to the SSH protocol with (a modified) forwarding agent, a complex case of long term shared secrets, which we formally prove secure.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Part I</head><p>The Framework</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>This paper is concerned with the security proofs of composed protocols. This topic has been widely studied in the last two decades. For instance, Universal Composability (UC) and simulation based reductions <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref> and other game-based composition methods <ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref> address this issue. While the former proceed in a more bottom-up manner (from secure components in any environment, construct secure complex protocols), the latter proceed in a more top-down way: from the desired security of a complex protocol, derive sufficient security properties of its components. Such "top-down" proofs design allows more flexibility: the security requirements for a component can be weaker in a given environment than in an arbitrary environment. The counterpart is the lack of "universality": the security of a component is suitable for some environments only.</p><p>We follow the "top-down" approach. While we aim at designing a general methodology, our target is the management of formal security proofs in the Computationally Complete Symbolic Attacker (CCSA) model <ref type="bibr" target="#b10">[11]</ref>. As a side result of our work, we provide with a way of proving the security of an arbitrary number of sessions (that may depend on the security parameter) in the CCSA model.</p><p>When trying to (de-)compose security properties, the main difficulty comes from the fact that different protocols may share some secrets. This is typically the case for multiple sessions of the same protocol, or for key exchange protocols, which result in establishing a shared secret that will be later used in another protocol. Protocols may also share long term secrets, for instance the same signing key may be used for various authentication purposes. Another example is the SSH protocol with the agent forwarding feature <ref type="bibr" target="#b11">[12]</ref>, which we will consider later. The forwarding feature allows to obtain, through previously established secure SSH connections, signatures of fresh material required to establish new connections. It raises a difficulty, as signatures with a long term secret key are sent over a channel established using the same long term secret key.</p><p>As far as we know, the existing composition results that follow the "top-down" approach cannot be used in situations where there is both a "state passing", as in key exchange protocols, and shared long term secrets. For instance, in the nice framework of <ref type="bibr" target="#b9">[10]</ref>, the same public key cannot be used by several protocols, a key point for reducing security of multiple sessions to security of one session.</p><p>When decomposing the security of a composed protocol into the security of its components, we would like to break a complex proof into simpler proofs, while staying in the same proof framework. This is also a difficulty since the attacker on a protocol component might use the other components: we need a proof with respect to a stronger attacker. In <ref type="bibr" target="#b9">[10]</ref>, such a strong attacker can be simulated by a standard one, because there is no shared long term secret.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our contributions</head><p>We provide with a composition framework that reduces the security of a compound protocols to the security of its components. We allow both state passing and shared long term secrets. We stay in the same proof framework of the CCSA model.</p><p>The starting idea is simple: if we wish to prove the security of a composed protocol P Q, it is sufficient to prove the security of P against an attacker that may simulate Q, maybe with the help of an oracle. If n are the secrets shared by P and Q, this simulation has to be independent of the distribution of n. This is actually an idea that is similar to the key-independence of <ref type="bibr" target="#b7">[8]</ref>.</p><p>Therefore, we first introduce the notion of O-simulation, in which an oracle O holds the shared secrets: if Q is O-simulatable and P is secure against an attacker that has access to O, then P Q is secure. Intuitively, O defines an interface through which the secrets can be used (e.g. obtaining signatures of only well tagged messages). O simulatable protocols conform to this interface.</p><p>We extend this basic block to arbitrary parallel and sequential compositions, as well as replication of an unbounded number of copies of the same protocol. In the latter case, the security of a single copy of P against an attacker that has access to an oracle allowing to simulate the other copies, requires to distinguish the various copies of a same protocol. In the universal composability framework, this kind of properties is ensured using explicit session identifiers. We rather follow a line, similar to <ref type="bibr" target="#b12">[13]</ref>, in which the session identifiers are implicit.</p><p>Our main composition Theorems are generic: the classical game based setting can be used to prove the subgoals. They are also specially well-suited for the CCSA model, which allows to complete computational proofs of real life protocols <ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>, while only relying on first order logic and cryptographic axioms. Many such axioms can easily be generalized so as to be sound with respect to an attacker that has access to oracles (we will see examples later).</p><p>A proof using such axioms is valid for an attacker who has access to an environment, while abstracting all the details of the environment and its interactions with the attacker. Moreover, as our reductions from one session to multiple sessions are uniform, we may now complete proofs in the CCSA model for a number of session that is parameterized by the security parameter. This was a limitation (and left as an open issue) in all previous CCSA papers.</p><p>We illustrate our composition results showing how to split the security of any (multi-session with shared long term secret) composed key exchange into smaller proofs. We then complete the formal proof of security of a Diffie-Hellman key exchange (ISO 9798-3 <ref type="bibr" target="#b16">[17]</ref>) for any number of sessions in parallel.</p><p>We generalize the application to key exchanges performing key confirmations, i.e. using the derived key in the key exchange (as in TLS). The generalization is simple, which is a clue of the usability of our framework.</p><p>To illustrate the usability of our framework, we use all our results to prove the security of the SSH <ref type="bibr" target="#b11">[12]</ref> protocol with a modified agent forwarding, a complex example of key exchange, with both key confirmation and long term shared secrets. The modification, which consists in the addition of a tag to specify if the signature was performed remotely, is necessary for the protocol to satisfy some natural security properties related to the agent forwarding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Works</head><p>We introduce the composition problem through a process algebra: protocols are either building blocks (defined,e.g, with a transition system) or composed using parallel and sequential composition, and replication. This prevents from committing to any particular programming language, while keeping a clean operational semantics. This approach is also advocated in <ref type="bibr" target="#b9">[10]</ref>, which follows a similar approach. Other works on composition (e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref>) rely on specific execution models.</p><p>Our starting idea, to prove a component w.r.t. a stronger attacker that has access to the context, is not new. This is the basis of many works, including <ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b17">18]</ref>. The main difference, that we wish to emphasize, is that these works do not support long term shared secrets, used in different components. Notably, the oracles of <ref type="bibr" target="#b9">[10]</ref> are only used to decompose protocols with state passing. Our notion of simulatability allows sharing long term secret by granting the attacker access to oracles that depend on the secrets (for instance, signing oracles). It also allows a symmetric treatment for proofs of a protocol and proofs of its context.</p><p>For several specific problems, typically key exchanges, there are composition results allowing to prove independently the key exchange protocol and the protocol that uses the exchanged key <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>. In such examples, the difficulty also comes from the shared secret, especially when there is a key confirmation step. In that case, the derived key is used for an integrity check, which is part of the key exchange. Then the property of the key exchange: "the key is indistinguishable from a random" does not hold after the key confirmation and thus cannot be used in the security proof of the protocol that uses this exchanged key. In <ref type="bibr" target="#b7">[8]</ref>, the authors define the notion of key independent reduction, where, if an attacker can break a protocol for some key distribution, he can break the primitive for the same distribution of the key. This is related to our notion of simulatability, as interactions with shared secrets are captured by an oracle for fixed values of the key, and thus attacks on the protocol for a fixed distribution are naturally translated into attacks against the primitive for the same distribution. Key exchanges with key confirmation are therefore a simple application of our composition results. Along the same line, <ref type="bibr" target="#b18">[19]</ref> extends <ref type="bibr" target="#b17">[18]</ref> to multi staged key exchanges, where multiple keys might be derived during the protocol. While we do not directly tackle this in our paper, our framework could be used for this case.</p><p>The authors of <ref type="bibr" target="#b8">[9]</ref> also provide results allowing for the study of key renewal protocols (which we capture with the sequential replication Theorem), and has the advantage to be inside a mechanized framework, while we only cast our results inside a mechanizable framework. It does not however consider key confirmations.</p><p>The UC framework initiated by <ref type="bibr" target="#b0">[1]</ref> and continued in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b5">6]</ref> is a popular way of tackling composition. As explained above, this follows a "bottom-up" approach, in which protocols must be secure in any context, which often yield very strong security properties, some of which are not met in real life protocols. Moreover, to handle multiple sessions of a protocol using a shared secret, joint-state theorems are required. This requires a tagging mechanism with a distinct session identifier (sid) for each session. Relaxing this condition, the use of implicit session identifiers was established in <ref type="bibr" target="#b19">[20]</ref> for the UC framework, ideas continued in <ref type="bibr" target="#b12">[13]</ref> for Diffie-Hellman key exchanges, where they notably provide a proof of the ISO 9798-3 <ref type="bibr" target="#b16">[17]</ref> protocol.</p><p>We do not consider a composition that is universal: it depends on the context. This allows us to relax the security properties regarding the protocol, and thus prove the compositional security of some protocols that cannot be proved secure in the UC sense. We also rely on implicit sids to prove the security of multiple sessions. Some limitations of the UC framework are discussed in <ref type="bibr" target="#b17">[18,</ref><ref type="bibr">Appendix A]</ref>.</p><p>In <ref type="bibr" target="#b4">[5]</ref>, the authors also address the flexibility of UC (or reactive simulatability) showing how to circumvent some of its limitations. The so-called "predicates" are used to restrict the order and contents of messages from environment and define a conditional composability. Assuming a joint-state conditional composability theorem, secret sharing between the environment and the protocol might be handled by restricting the accepted messages to the expected use of the shared secrets. However, the framework does not cover how to prove the required properties of (an instance of) the environment.</p><p>Protocol Composition Logic is a formal framework <ref type="bibr" target="#b20">[21]</ref> designed for proving, in a "Dolev-Yao model", the security of protocols in a compositional way. Its computational semantics is very far from the usual game-based semantics, and thus the guarantees it provides <ref type="bibr" target="#b21">[22]</ref> are unclear. Some limitations of PCL are detailed in <ref type="bibr" target="#b22">[23]</ref>.</p><p>The compositional security of SSH, in the sense of <ref type="bibr" target="#b17">[18]</ref>, has been studied in <ref type="bibr" target="#b23">[24]</ref>. They do not consider however the agent forwarding feature. It introduces important difficulties since the key exchange is composed with a second key exchange that uses both the first derived key and the same long term secrets. SSH has also been studied, without agent forwarding, in <ref type="bibr" target="#b24">[25]</ref>,</p><p>where the implementation is derived from a secure modelling in CryptoVerif <ref type="bibr" target="#b25">[26]</ref>.</p><p>Summing up, our work is strongly linked to previous composition results and captures analogues of the following notions in our formalism: implicit disjointness of local session identifiers <ref type="bibr" target="#b19">[20]</ref>, single session games <ref type="bibr" target="#b17">[18]</ref>, key-independent reductions <ref type="bibr" target="#b7">[8]</ref> and the classical proof technique based on pushing part of a protocol inside an attacker, as recently formalized in <ref type="bibr" target="#b9">[10]</ref>. We build on all these works and additionally allow sharing long term secrets, thanks to a new notion of O-simulatability. This fits with the CCSA model: the formal proofs of composed protocols are broken into formal proofs of components. All these features are illustrated by a proof of SSH with (a modified) agent forwarding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Protocols and Indistinguishability</head><p>We first recall some features of the CCSA model. Although this model is not used until the case studies, it may be useful for an easier understanding of the protocol semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Syntax and semantics of terms</head><p>To enable composition with long term shared secrets, we must be able to specify precisely the shared randomness between protocols. We use symbols from an alphabet of names, to represent the random samplings. The same symbol used twice represents the same (shared) randomness. Those names can be seen as pointers to a specific randomness, where all the randomness has been sampled upfront at the beginning of the protocol. This idea stems from the CCSA model <ref type="bibr" target="#b10">[11]</ref>, from which we re-use exactly the same term semantics. This is one of the reason why our results, while applicable in a broader context, fit naturally in the CCSA model. Let us recall the syntax and semantics of terms drawn from the CCSA model.</p><p>Syntax We use terms built over explicit names to denote messages computed by the protocol. The terms are defined with the following syntax:</p><formula xml:id="formula_0">t ::= n names | n i indexed names | x variable | f (t 1 , . .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. , t n ) operation of arity n</head><p>A key addition to the CCSA model is that some names can be indexed by sequences of index variables. This is necessary so that we may later on consider the replication of protocols. When a replicated protocol depends on a name n i , the first copy (session) of the protocol uses n 1 , the second n 2 , . . . . Names without index models randomness shared by all sessions of the protocol. Variables are used to model the attacker inputs, and function symbols allows to model the cryptographic computations.</p><p>Semantics Terms are interpreted as bitstrings. As in the computational model, the interpretation depends on some security parameter η. As we assume that all the randomness is sampled at the beginning, the interpretation depends on an infinitely long random tape ρ s . We then leverage the notion of a cryptographic library <ref type="foot" target="#foot_0">1</ref> , that provides an interpretation for all names and function symbols. A cryptographic library M f provides for each name n a Probabilistic Polynomial Time Turing Machine (PPTM for short) A n , that is given access to the random tape ρ s . As an additional input, all machines will always be given the security parameter in unary. Each A n extracts a bit-string of length η from the random tape. Different names extract non-overlapping parts of the random tape. In the interpretation, we give to all the PPTM the same random tape ρ s , so each name is always interpreted with the same value in any term (and thus any protocol), and all names are interpreted independently.</p><p>M f also provides for each function symbol f (encryption, signature,...) a PPTM A f , that must be deterministic. To model randomized cryptographic primitives, additional randomness must be given to the function symbol as extra names (cf. Example 2.1).</p><p>Given M f , the semantic mapping [[•]] η,σ ρs evaluates its argument, a formal term, given an assignment σ of its variables to bit-strings and a random tape ρ s . For instance, if n is a name, [[n]] η ρs = A n (1 η , ρ s ) (extracts a bit-string of length η from the random tape ρ s ) and [[sign(x, k)]] η,{x →m} ρs = A sign (m, A k (1 η , ρ s )). The details about the syntax and semantic of messages can be found in Appendix A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Syntax of the protocols</head><p>The summary of the protocol syntax is given in Figure <ref type="figure">1</ref>. An elementary protocol models a thread running on a specific computer. let denotes variable binding inside a thread, in(c, x) (resp. (out(c, m)) denotes an input (resp. an output) of the thread over the channel c, where all channels are taken out of a set C. For simplicity, channel identifiers are constants or indexed constants. In particular, they are known to the attacker. The if then else constructs denotes conditionals, 0 is a successfully terminated thread and ⊥ is an aborted thread.</p><p>For protocols, our goal is to state and prove general composition results: we first consider sequential composition (the ; operator), where 0; P reduces to P , while ⊥; P reduces to ⊥. In most cases, we will omit 0. We also consider parallel composition (the operator), a fixed number N of copies running concurrently i≤N , as well as an arbitrary number of copies running concurrently i . For instance, we can express a (two-parties) key-exchange consisting of an initiator I and a responder R with I R, the key exchange followed by a protocol using the exchanged key (I; P I ) (R; P R ), as well as any number of copies of the resulting protocol running in parallel: i ((I; P I ) (R; P R )). We can also consider an arbitrary iteration of a protocol, "; i ", which could be used for expressing, for instance, key renewal.</p><p>We provide in Appendix B a full definition of the protocol algebra. For generality, the full algebra is also parameterized by some atomic protocols, that can be used to easily extend the syntax.</p><p>We allow terms inside a protocol to depend on some free variables and, in this case, we denote P (x 1 , . . . , x n ) a protocol, which depends on free variables x 1 , . . . , x n . P (t 1 , . . . , t n ) denotes the protocol obtained when instantiating each x i by the term t i .</p><p>We denote N (P ) (resp C(P )) the set of names (resp. channel names) of P .</p><p>Example 2.1. Given a randomized encryption function enc, we let P (c, x 1 , x 2 ) be the protocol in(c, x).out(c, enc(x, x 1 , x 2 )). Given names sk, r representing respectively a secret key and a random seed, E N := i≤N P (c i , r i , sk) is then the protocol allowing the attacker to obtain cyphertexts for an unknown secret key sk. Unfolding the definitions, we get:</p><formula xml:id="formula_1">E N := P (c 1 , r 1 , sk) . . . P (c n , r n , sk)</formula><p>The generalization giving access to encryption for five secret keys is expressed with i j≤5 P (c j,i , r j,i , sk j ). </p><formula xml:id="formula_2">; Q, σ) -→ A φ , (P ; Q, σ ) φ, (0; Q, σ) -→ A φ, (Q, σ) φ, (P, σ) -→ A φ , (P , σ ) φ, (P, σ) E -→ A φ , (P , σ ) E Figure 2: Operational Semantics (excerpt)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Semantics of the protocols</head><p>We give here some essential features of the formal execution model, which we need to formalize our composition results. A (global) state of a protocol consists in a frame, which is a sequence of bit-strings modelling the current attacker knowledge, and a finite multiset of pairs (P, σ), where P is a protocol and σ is a local binding of variables. Intuitively, each of the components of the multiset is the current state of a running thread. We write such global states φ,</p><formula xml:id="formula_3">(P 1 , σ 1 ) • • • (P n , σ n ).</formula><p>The transition relation between global states is parameterized by an attacker A who interacts with the protocol, modelled as a PPTM with its dedicated random tape ρ r . The attacker chooses which of the threads is going to move and computes, given φ, the input to that thread. In the following, the configuration of the protocol and the security parameter are (also) always given to the attacker, which we do not make explicit for simplicity.</p><p>We give some of the rules describing the Structural Operational Semantics in Figure <ref type="figure">2</ref>. The full semantics can be found in Appendix B. The transition relation -→ A between configurations depends on the attacker A, the security parameter η and the random samplings ρ s (to interpret terms) and ρ r (the randomness of the attacker). In P ; Q, P has to be executed first. When it is completed (state 0), then the process can move to Q, inheriting the variable bindings from P . If P is not waiting for an input from the environment, it can move independently from any of the other parallel processes.</p><p>The semantics of inputs (not detailed for simplicity) reflects the interactions with the attacker. A computes the input to the protocol, given a frame φ and its own random tape ρ r . Therefore transitions depend not only on the attacker machines, but also<ref type="foot" target="#foot_1">2</ref> on the name samplings ρ s (secret coins) and ρ r (attacker's coins).</p><p>Example 2.2. Continuing Example 2.1, the initial configuration corresponding to E 2 is ∅, (P (c 1 , r 1 , sk), ∅) (P (c 2 , r 2 , sk), ∅), where the attacker knowledge is empty and no local variables are bound. We consider one of the possible reductions, for some attacker A that first sends a message over channel c 1 and then c 2 :</p><formula xml:id="formula_4">∅, (P (c 1 , r 1 , sk), ∅) (P (c 2 , r 2 , sk), ∅) -→ A ∅, (out(c 1 , enc(x, r 1 , sk), {x → m}) (P (c 2 r 2 , sk), ∅) m = A(∅, ρ r ) is the first input message computed by the attacker -→ A φ, (P (c 2 , r 2 , sk), ∅) φ = [[enc(x, r 1 , sk)]] η,{x →m} ρs</formula><p>is the interpretation of the output received by the attacker</p><formula xml:id="formula_5">-→ A φ, (out(c 2 , enc(x, r 1 , sk), {x → m 2 }) m 2 = A(φ, ρ r ) is the second input message computed by the attacker -→ A (φ, [[enc(x, r 2 , sk)]] η,{x →m 2 } ρs ), 0</formula><p>We assume action determinism of the protocols <ref type="bibr" target="#b26">[27]</ref>: given an input message on a given channel, if the current state is</p><formula xml:id="formula_6">φ, (P 1 , σ 1 ) • • • (P n , σ n ),</formula><p>at most one of the P i may move to a non-abort state. This means that each thread checks first that it is the intended recipient of the message. This also means that each output has to be triggered by an input signal: none of the P i starts with an output action. We remark that in practice, protocols are action determinate.</p><p>For replicated protocols i≤N P or i P , the names in P that are indexed by the variable i are renamed as follows: i≤N P is the protocol P {i → 1} . . . P {i → N } and φ,</p><formula xml:id="formula_7">( i P, σ) E -→ A φ, ( i≤A(ρr,φ) P, σ) E.</formula><p>In other words, the attacker chooses how many copies of P will be considered, which may depend, in particular, on the security parameter. A(ρ r , φ) must be a natural number in unary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Stateless Oracle Machines</head><p>For reasons that have been explained in the introduction, we wish to extend the semantics of protocols and their indistinguishability to attackers that have access to an additional stateless oracle. At this stage, we need stateless oracles in order to be compositional. Let us explain this. Assume we wish to prove a property of R in the context P Q R. The idea would be to prove R, interacting with an attacker that simulates P Q. This attacker is itself a composition of an attacker that simulates P and an attacker that simulates Q. The protocols P , Q, R share primitives and secrets, hence the simulation of P, Q requires access to an oracle that holds the secrets. If such an oracle were to be stateful, we could not always build a simulator for P Q from simulators of P, Q respectively, since oracle replies while simulating Q could depend on oracle queries made while simulating P , for instance.</p><p>The oracles depend on a security parameter η (that will not always be explicit), (secret) random values and also draw additional coins: as a typical example, a (symmetric key) encryption oracle will depend on the key k and use a random number r to compute enc(m, r, k) from its query m. Therefore, the oracles can be seen as deterministic functions that take two random tapes as inputs: ρ s for the secret values and ρ O for the oracle coins.</p><p>Formally, oracles take as input tuples (m, r, s) where m is a finite sequence of bitstrings, r is a handle for a random value and s is a handle for a secret value. r and s are respectively used to extract the appropriate parts of ρ O , ρ s respectively, in a deterministic way: the randomness extracted from ρ O is uniquely determined by m, r, s and the extractions for different values do not overlap.</p><p>In what follows, we only consider oracles that are consistent with a given cryptographic library M f . Such oracles only access ρ s through some specific names. This set of names is called the support of the oracle.</p><p>Example 2.3. An encryption oracle for the key k (corresponding to the handle "1"), successively queried with (m, 1, 1), (m , 2, 1), (m, 3, 1), (m, 1, 1), (m , 2, 2), . . . will produce respectively the outputs enc(m, r 1 , k), enc(m , r 2 , k), enc(m, r 3 , k), enc(m, r 1 , k), ⊥,. . . Here r 1 , r 2 , r 3 are non-overlapping parts of ρ O (each of length η). The support of this oracle is {k}.</p><p>The formal definition of stateless oracles is a bit involved, notably to formally specify the randomness extraction. This construction is required to ensure the determinism of the oracles. Determinism is required to build a single simulator for two parallel protocols from the individual simulators for the two protocols.</p><p>For instance, for an oracle performing randomized encryption, rather than always encrypting with a fresh nonce, this system allows multiple attackers to obtain an encryption of a message with the same random.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 ((Stateless) Oracle</head><p>). An oracle O is a triple of functions that have the following inputs • a sequence of bitstrings w ∈ ({0, 1} * ) n and two bitstrings r, s: the query, consisting of an input query w, an input tag r, an input key s;</p><p>• a random tape ρ s for the (secret) random values;</p><p>• the security parameter η;</p><p>• a random tape ρ O for the oracle's coins.</p><p>The first function assigns to each w, s, r an integer n(w, s, r) ∈ N and is assumed injective. n(w, s, r) is used to extract a substring e 1 (n(w, s, r), η, ρ O ) from ρ O , which is uniquely determined by the input. We assume that the length of the substring extracted by e 1 only depends on η, and substrings extracted with e 1 are disjoint for different values of n.</p><p>The second function e 2 assigns to each s a sequence p(s) of natural numbers, that are used to extract secret values from ρ s : e 2 (s, η, ρ s ) is a sequence of bitstrings. It is also assumed to be injective.</p><p>The third function takes η, w, r, s, e 1 (n(w, s, r), η, ρ O ), e 2 (s, η, ρ s ) as input and returns a result (a bitstring) or a failure message.</p><p>Example 2.4. Expanding upon Example 2.3, the encryption oracle is given by the triple of functions (e 1 , e 2 , e 3 ) such that:</p><formula xml:id="formula_8">• e 1 (n(w, s, r), η, ρ O ) extracts the substring r at position range [n(w, s, r) × η, (n(w, s, r) + 1) × η] from ρ O . • e 2 (s, η, ρ s ) = [[k]] η ρs if s = 1 0 else • e 3 (η, w, r, s, e 1 (n(w, s, r), η, ρ O ), e 2 (s, η, ρ s )) = [[enc(y, r, x)]] η {y →w,r →r,x →e 2 (s,η,ρs)</formula><p>Given η, and a sequence of bitstrings m, we call r 1 the sequence of bitstrings at position range</p><formula xml:id="formula_9">[n(m, 1, 1)×η, (n(m, 1, 1)+1)×η] from ρ O . Then, on input (m, 1, 1), e 1 (n(m, 1, 1), η, ρ O ) = r 1 , e 2 (1, η, ρ s ) = [[k]] η</formula><p>ρs and the oracle returns</p><formula xml:id="formula_10">e 3 (η, m, 1, 1, r 1 , [[k]] η ρs ) = [[enc(y, r, k)]] η y →m,r →r 1 .</formula><p>An oracle machine (PPTOM) is a PPTM, equipped with an additional tape, on which the queries to the oracle are written and from which the oracle replies are read. We often write explicitly the machine inputs, as in A O(ρs,ρ O ) (ω, ρ r ), where ω is the input data of A, ρ r is its random tape and ρ s , ρ O are the random tapes accessible to the oracle. These definitions extend to multiple oracles O 1 , . . . , O n , prefixing the query with an index in {1, . . . , n}. Definition 2. A Probabilistic Polynomial Time Oracle Machine (PPTOM) is a Turing machine denoted by A O and equipped with:</p><p>• an input/working/output tape (as usual; it is read/write);</p><p>• a read-only random tape ρ r (attacker's coins);</p><p>• an oracle input tape ρ O ;</p><p>• an oracle output tape, which is read-only.</p><p>• an oracle read-only random tape ρ s (not accessible by the Turing Machine); Note that once the oracle's random tape is fixed, we ensure that all our oracles are deterministic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Computational indistinguishability</head><p>To define the classical notion of indistinguishability, we describe how protocols may be seen as oracles, that an attacker can interact with. Given a protocol P and a cryptographic library M f , the oracle O P is an extension of the previous oracles: it takes as an additional input an history tape that records the previous queries. Given a query m with history h (now the components r, s are useless), the oracle replies what would be the output of P , given the successive inputs h, m. It also appends the query m to the history tape. The formal definition of protocol oracles can be found in Appendix B. <ref type="bibr" target="#b2">3</ref>.</p><p>The machines that interact with O P are also equipped with the history tape that is readonly: the history can only be modified by the oracle. Since P may use secret data, the oracle may access a secret tape ρ s ; this will be explicit.</p><p>An oracle may implement multiple parallel protocols: the oracle O P 1 ,...,Pn first checks which P i is queried (there is at most one such i, by action determinism) and then replies as</p><formula xml:id="formula_11">O P i .</formula><p>Finally, we may consider oracles that combine protocols oracles and stateless oracles. A O 1 ,...,Om , O P 1 ,...,O Pn is also written A O 1 ,...,Om,O P 1 ,...,O Pn . Definition 3. Given a cryptographic library M f , an oracle O and protocols P 1 , . . . , P n , Q 1 , . . . , Q n , we write A O,O P 1 ?Q 1 ,...,O Pn?Qn ≺ if for every polynomial time oracle Turing machine A O ,</p><formula xml:id="formula_12">|P ρs,ρr,ρ O {A O(ρs,ρ O ),O P 1 (ρs),...,O Pn (ρs) (ρ r , 1 η ) = 1} -P ρs,ρr,ρ O {A O(ρs,ρ O ),O Q 1 (ρs),...,O Qn (ρs) (ρ r , 1 η ) = 1}|</formula><p>is negligible in η. We will write</p><formula xml:id="formula_13">P ∼ = O Q for A O,O P ?Q ≺ .</formula><p>Example 2.5. For i ∈ {1, 2}, the protocol P i is defined with the single transition:</p><formula xml:id="formula_14">q, {x 1 , ..., x n } x n+1 =(m 1 ,m 2 ) ---------→ (q, enc(m i , sk), {x 1 , ..., x n , x n+1 })</formula><p>The protocol expects to receive a couple as input, and will output either the left message or the right message using some secret key. P 1 ∼ = O P 2 then captures the fact that an attacker with oracle O has a negligible probability to win the IND-CPA game.</p><p>By construction, indistinguishability is compatible with our constructions for protocols in parallel and multiple protocol oracles. Indeed the oracle protocol for P Q behaves exactly the same as the two oracle O P and O Q in parallel. Lemma 4. For protocols P, Q, A, B, an oracle O, and a list O l of protocol oracles,</p><formula xml:id="formula_15">A O,O (A P )?(B Q) ≺ ⇔ A O,O l ,O A?B ,O P ?Q ≺ 3 Simulatability</formula><p>We define a notion of "perfect" simulation, where a protocol depends on some secrets that the attacker can only access through an oracle, and an attacker must be able to produce exactly the same message as the protocol. This means that an attacker, given access O but not to a set of secrets n, can completely simulate the protocol P (using O to have a partial access to the secrets), i.e., produce exactly the same distribution of message.</p><p>Formally, given a set of names n, an oracle O and a protocol P . We say that νn.P is O-simulatable, if there exists a PTOM A O such that for any attacker B O , the sequences of messages produced by B O,O P has exactly the same probability distribution as the on produced by B O interacting with A O instead of O P .</p><p>Assume that Q ∼ = O R and νn.P is O-simulatable, where n contains the secrets shared by P, Q and R. Any distinguisher against Q ∼ = O R can also produce any message that would produce P in this context, and can therefore be transformed into a distinguisher against</p><formula xml:id="formula_16">Q P ∼ = O R P . In other terms, Q ∼ = O R and νn.P is O-simulatable implies that Q P ∼ = R P .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Protocol Simulation</head><p>The goal in the rest of the paper is to use this notion of simulatability to obtain composability results. Suppose one wants to prove P Q ∼ = P R, knowing that Q ∼ = O R and P is Osimulatable. The way to obtain a distinguisher for Q ∼ = O R from one on P Q ∼ = P R is to "push" the (simulated version) of P within the distinguisher. A protocol P is then simulatable if there exists a simulator A O that can be "pushed " in any distinguisher D. We formalize this construction below, where a protocol is simulatable if and only if any distinguisher D behaves in the same way if the protocol oracle O P is replaced by its simulator A O . We define formally  To define the central notion of O-simulatability, the distribution produced by any distinguisher interacting with the simulator must be the same as the distribution produced when it is interacting with the protocol. However, as we are considering a set of shared secrets n that might be used by other protocols, we need to ensure this equality of distributions for any fixed concrete value v of the shared secrets. Then, even if given access to other protocols using the shared secrets, no adversary may distinguish the protocol from its simulated version. Definition 6. Given an oracle O with support n, a cryptographic library M f , a protocol P , a sequence of names n, then, νn.P is O-simulatable if and only if there exists a PTOM A O P such that for every PTOM D O,O P , for every η, every v ∈ ({0, 1} η ) |n| , c ∈ {0, 1} ,</p><formula xml:id="formula_17">D[A O ] O the replacement of O P in D O,O P . Definition 5. Given an oracle O, a cryptographic library M f , a protocol P , PTOMs D O,O P (ρ r D , 1 η ) and A O (• • • , 1 η ), we define D[A O ] O (ρ r , 1 η )</formula><formula xml:id="formula_18">P ρs,ρr,ρ O {D O,O P (ρ r , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {D[A O P ] O (ρ r , 1 η ) = c | [[n]] η ρs = v}</formula><p>Note that our definition of simulatability is a very strong one as it requires a perfect equality of distributions, as opposed to computational indistinguishability. This is intuitively what we want: O-simulation expresses that P only uses the secrets in n as O does. This notion is not intended to capture any security property.</p><p>In practice, let us consider the security property P Q ∼ = P Q , where P is simulatable by A O P . The idea of the later composition result is that an attacker D that distinguishes between D O,O P ,O Q and D O,O P ,O Q can be turned into an attacker that distinguishes between</p><formula xml:id="formula_19">D[A O P ] O,O Q and D[A O P ] O,O Q .</formula><p>Notice that here, Q and P may share some secrets, and their distributions are not independent. The intuition is that Q is fixing a specific value for the shared name between P and Q, and P then needs to be simulatable for this fixed value. This is why the notion of simulatability asks that a protocol is simulatable for any fixed value of a set of secret names. The formalization of this proof technique is given by the following Proposition.</p><p>Proposition 7. Given an oracle O with support n, a cryptographic library M f , protocols P, Q such that N (P ) ∩ N (Q) ⊆ n, then, for any PTOM A O P , νn.P is O-simulatable with A O P if and only if for every PTOM D O,O P ,O Q , for every η, every v ∈ ({0, 1} η ) |n| , c ∈ {0, 1} ,</p><formula xml:id="formula_20">P ρs,ρr,ρ O {D O,O P ,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {D[A O P ] O,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v}</formula><p>It then implies that:</p><formula xml:id="formula_21">P ρs,ρr,ρ O {D O,O P ,O Q (ρ r , 1 η ) = c} = P ρs,ρr,ρ O {D[A O P ] O,O Q (ρ r , 1 η ) = c}</formula><p>While this Definition intuitively captures the proof technique used to allow composition, it does not provide insight about how to prove the simulatability. Another equivalent definition states that a protocol is simulatable if there exists a simulator that can produce exactly the same distribution of messages as the protocol interacting with any attacker. We formalize in the following this second Definition, and prove that the two Definitions are equivalent, which also yields the proof of Proposition 7.</p><p>For this second Definition of simulation to be realizable, we need to ensure that simulator's oracle calls and attacker's oracle calls use a disjoint set of random coins for the oracle randomness. We thus assume, w.l.o.g., that the random handles r of simulator's queries are prefixed by 1. This ensures that, as long as adversaries only make oracle calls prefixed by 0 (this can be assumed w.l.o.g. since it only constrains the part of the oracle's random tape where the randomness is drawn) the oracle randomness used by the simulator is not used by the adversary. We provide later in Example 3.2 a complete example illustrating both simulation and the need of the prefix and a formal definition of prefixed models. Definition 8. Given a cryptographic library M f , a sequence of names n, an oracle O and a protocol P , we say that νn.P is O-simulatable if the support of O is n and there is a PTOM A O (using random handles prefixed by 0) such that, for every c ∈ {0, 1} , for every v ∈ ({0, 1} η ) |n| , for every m ≥ 1, for every PTOM B O (using random handles prefixed by 1),</p><formula xml:id="formula_22">P ρs,ρr 1 ,ρr 2 ,ρ O {A O(ρs,ρ O ) (ρ r 1 , θ 1 m , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr 1 ,ρr 2 ,ρ O {O P (ρ s , θ 2 m ) = c | [[n]] η ρs = v} where φ 2 k+1 = φ 2 k , O P (ρ s , θ 2 k ) φ 1 k+1 = φ 1 k , A O(ρs,ρ O ) (ρ r 1 , θ 1 k , η) θ i k+1 = θ i k , B O(ρs,ρ O ) (ρ r 2 , η, φ i k+1 ) for 0 ≤ k &lt; m and φ 0 = ∅, θ 0 = B O(ρs,ρ O ) (ρ r 2 , η, ∅).</formula><p>The machine A O can be seen as the simulator, while B is an adversary that computes the inputs: the definition states that there is a simulator, independently of the adversary. We asks for equality of distributions, between the sequence of messages θ 2 , corresponding to the interactions of B O with O P , and the sequence of messages θ 1 , corresponding to the interactions of B O with A O .</p><p>Note that our definition of simulatability is a very strong one as it requires a perfect equality of distributions, as opposed to computational indistinguishability. This is intuitively what we want: O-simulation expresses that P only uses the shared secrets as O does. This notion is not intended to capture any security property.</p><p>The two definitions are indeed equivalent. To prove this, a first technical Lemma is required. It shows that O-simulation, whose definition implies the identical distributions of two messages produced either by the simulator or by the oracle, implies the equality of distributions of message sequences produced by either the oracle or the simulator. It is proved essentially via an induction on the length of the sequence of messages. For any sequence of names n and parameter η, we denote</p><formula xml:id="formula_23">D η n = {[[n]</formula><p>] η ρs |ρ s ∈ {0, 1} ω } the set of possible interpretations of n. We reuse the notations of Definition 8. Lemma 9. Given a cryptographic library M f , a sequence of names n, an oracle O with support n and a protocol P , that is O-simulatable with A O , we have, for every x, y, c, r 2 , r B ∈ {0, 1} , every v ∈ D η n , for every m ≥ 1, for every PTOM B O (using tags prefixed by 1): We now prove that Definition 8 implies Definition 5, i.e that the simulatability implies that we can replace a protocol oracle by its simulator.</p><formula xml:id="formula_24">P ρs,ρr 1 ,ρr 2 ,ρ O {θ 1 m = x, φ 1 m = y| [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 } = P ρs,ρr 1 ,ρr 2 ,ρ O {θ 2 m = x, φ 2 m = y| [[n]] η ρs = v, ρ B O = r B , ρ r 2 =</formula><p>Lemma 10. Given an oracle O (with support n), a cryptographic library M f , a sequence of names n , P, Q protocols, such that νn.P is O-simulatable in the sense of Definition 8 with A O P and N (P ) ∩ N (Q) ⊆ n then, for every PTOM D O,O P ,O Q (prefixed by 1), every η, every v ∈ D η n and every c ∈ {0, 1} ,</p><formula xml:id="formula_25">P ρs,ρr,ρ O {D O,O P ,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {D[A O P ] O,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v}</formula><p>The idea is to use the definition of O-simulatability, using a PTOM B O that behaves exactly as D when it computes the next oracle queries from the previous answers. The difficulty is that D may call the oracle O Q , while B has no access to this oracle. We know however that shared names are included in n, whose sampling can be fixed at once (thanks to the definition of O-simulation). The other randomness in Q can be drawn by B from ρ r , without changing the distribution of O Q 's replies.</p><p>Proof. Fix η and the interpretation [[n]] η ρs = v. Given D, we let D m be the machine that behaves as D, however halting after m calls to O P (or when D halts if this occurs before the mth call) and returning the last query to O P .</p><p>We have that D m first executes D m-1 , then performs the oracle call O P (ρ s , θ m-1 ), getting u m-1 and performs the computation of the next oracle call v m (if D makes another oracle call), updates the history θ m := (v 1 , . . . , v m ) and returns v m if there is one or the output of D otherwise.</p><formula xml:id="formula_26">D m [A O P ] first executes D m-1 [A O P ]</formula><p>, then performs the computation A O P (M f , ρ r 1 , θ m-1 ) of u m , computes the next oracle call v m (if one is performed), updates θ m := (v 1 , . . . , v m ) and outputs either v m of the output of D.</p><p>We wish to use the definition of O-simulation in order to conclude. However, we cannot directly use the O-simulation, as D has access to an extra oracle O Q .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Part 1</head><p>We first prove that, assuming A O P is a simulator of O P :</p><formula xml:id="formula_27">P ρs,ρr,ρ O {D O,O P (ρ r , 1 η ) = c} = P ρs,ρr,ρ O {D[A O P ] O (ρ r , 1 η ) = c}</formula><p>This is a straightforward consequence of Lemma 9. Writing respectively</p><formula xml:id="formula_28">p 1 1 (c) = P ρs,ρr,ρ O {D O,O P (ρ r , 1 η ) = c} and p 2 1 (c) = P ρs,ρr,ρ O {D[A O P ] O (ρ r , 1 η ) = c}, Using ρ r 1 , ρ r 2 as in Definition 5, we have p 1 1 (c) = r B ,r 2 P ρs,ρr,ρ O {D O,O P (ρ r , 1 η ) = c | ([[n]] η ρs , ρ B O , ρ r 2 ) = (v, r B , r 2 )} ×P ρs,ρr,ρ O {([[n]] η ρs , ρ B O , ρ r 2 ) = (v, r B , r 2 )} p 2 1 (c) = r B ,r 2 P ρs,ρr,ρ O {D[A O P ] O (ρ r , 1 η ) = c| ([[n]] η ρs , ρ B O , ρ r 2 ) = (v, r B , r 2 )} ×P ρs,ρr,ρ O {[[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 }</formula><p>We let</p><formula xml:id="formula_29">p 1 2 (r B , r 2 , v, c) = P ρs,ρr,ρ O {D O,O P (ρ r , 1 η ) = c| ([[n]] η ρs , ρ B O , ρ r 2 ) = (v, r B , r 2 )} and p 2 2 (r B , r 2 , v, c) = P ρs,ρr,ρ O {D[A O P ] O (ρ r , 1 η ) = c| ([[n]] η ρs , ρ B O , ρ r 2 ) = (v, r B , r 2 )}</formula><p>We use Definition 8 with B O (ρ r 2 , η, φ) as the machine that simulates D m for m = |φ| and using φ instead of querying the oracle. Let us define φ i m , θ i m for i = 1, 2 as in Definition 8. Note that with the definition of D, B uses prefixes for oracle calls, disjoint from those used in A P , hence randomness used for oracle calls in A and B are disjoint. Let v i m be the last message of θ i m . By definition of D and B we have</p><formula xml:id="formula_30">v 1 m = v m and v 2 m = v m .</formula><p>Choosing m such that D makes less than m oracle calls, we have</p><formula xml:id="formula_31">p i 2 (r B , r 2 , v, c) = x s.t. xm=c,ȳ P ρs,ρr 1 ,ρr 2 ,ρ O {θ i m = x, φ i m = y| ([[n]] η ρs , ρ B O , ρ r 2 ) = (v, r B , r 2 )}.</formula><p>Lemma 9 yields for all r B , r 2 , c that p 2 2 (r B , r 2 , c) = p 1 2 (r B , r 2 , c), which concludes part 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Part 2</head><p>We now prove that:</p><formula xml:id="formula_32">∀D. P ρs,ρr,ρ O {D O,O P (ρ r , 1 η ) = c} = P ρs,ρr,ρ O {D[A O P ] O (ρ r , 1 η ) = c} ⇒ ∀D. P ρs,ρr,ρ O {D O,O P ,O Q (ρ r , 1 η ) = c} = P ρs,ρr,ρ O {D[A O P ] O,O Q (ρ r , 1 η ) = c}<label>(1)</label></formula><p>We are thus going to show that, with the interpretation of n fixed, we can simulate O Q in some D by sampling in ρ r instead of ρ s . However, both computations of O P and O Q depend on ρ s . This is where we need the assumptions that n contains the shared secrets between P and Q, as well as the splitting of ρ r .</p><p>For any machine M O,O Q , we let [M] O n be the machine that executes M, simulating O Q for a fixed value v of n. The machine samples the names appearing in Q and not in n and hard codes the interpretation of n.</p><p>More precisely, we write</p><formula xml:id="formula_33">O Q (ρ s , θ) := O Q ((ρ s 0 , ρ s 1 , ρ s 2 ), θ)</formula><p>where ρ s 0 is used for the sampling of n, ρ s 1 for the sampling of other names in Q, and ρ s 2 for the reminder.</p><p>Then</p><formula xml:id="formula_34">[M] O n (ρ r , 1 η</formula><p>) is the machine that:</p><p>• Splits ρ r into two infinite and disjoints ρ sQ , ρ rM and initializes an extra tape θ to zero. . Now, we have that, for any c, by letting, for any X and U ,</p><formula xml:id="formula_35">P c,v X (U ) := P X {U = c | [[n]] η ρs = v}: P c,v ρs,ρr,ρ O (D O,O P (ρs 0 ,ρs 1 ,ρs 2 ),O Q (ρs 0 ,ρs 1 ,ρs 2 ) (ρ r , 1 η )) = 1 P c,v ρs,ρr,ρ O (D O,O P (ρs 0 ,ρs 1 ,ρs 2 ),O Q (ρs 0 ,ρs 1 ,0) (ρ r , 1 η )) = 2 P c,v</formula><p>ρs 1 ,ρs 2 ,ρr,ρ O (D O,O P (ρs 0 ,0,ρs 2 ),O Q (ρs 0 ,ρs 1 ,0) (ρ r , 1 η )) </p><formula xml:id="formula_36">= 3 P c,v ρs 1 ,ρs 2 ,ρr,ρ O (D O,O P (v,0,ρs 2 ),O Q (v,ρs 1 ,0) (ρ r , 1 η )) = 4 P c,v ρ sQ ,ρs,ρ rD ,ρ O (D O,O P (v,0,ρs),O Q (v,ρ sQ ,0) (ρ r , 1 η )) = 5 P c,v ρs,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Renaming of tapes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">By construction</head><p>And we also have similarly that, for any c:</p><formula xml:id="formula_37">P ρs,ρr,ρ O {D[A O P ] O,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {[D[A O P ]] O v (ρ r , 1 η ) = c | [[n]] η ρs = v} (iii)</formula><p>By applying the left-handside of (1) to</p><formula xml:id="formula_38">[D] O,O P (ρs) n (ρ r , 1 η ) and [D[A O P ] j ] O v (ρ r , 1 η</formula><p>), and using (ii) and (iii), we can conclude by transitivity. We conclude the proof of the lemma by putting Part 1 and Part 2 together.</p><p>We now prove the converse direction.</p><p>Lemma 11. Given an oracle O with support n, a cryptographic library M f , protocols P, Q such that N (P ) ∩ N (Q) ⊂ n, if there is a PTOM A O P such that, for every PTOM D O,O P ,O Q , for every η, every v ∈ D η n and every c ∈ {0, 1} ,</p><formula xml:id="formula_39">P ρs,ρr,ρ O {D O,O P ,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {D[A O P ] O,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v} then νn.P is O-simulatable.</formula><p>Proof. Let B be a PTOM, η, an interpretation v ∈ D η n and m ∈ N , we must prove that the output distribution of B will be the same whether it interacts m-th time with A O P or O P . We define D as follows. For i := 0 to m -1, D computes w i := B(α 1 , . . . , α i ). Then D calls O P with w i and let α i+1 be the reply. D finally outputs α m . We denote by w i and α i the corresponding values for</p><formula xml:id="formula_40">D[A O P ] O,O Q Let us denote φ 2 k+1 = φ 2 k , O P (ρ s , θ 2 k ) φ 1 k+1 = φ 1 k , A O(ρs,ρ O ) (M f , ρ r 1 , θ 1 k , η) θ i k+1 = θ i k , B O(ρs,ρ O ) (M f , ρ r 2 , η, φ i k ) for 0 ≤ k &lt; m and φ 0 = θ 0 = ∅.</formula><p>We have by construction of D for any c:</p><formula xml:id="formula_41">P ρs,ρr 1 ,ρr 2 ,ρ O {w m = c | [[n]] η ρs = v} = P ρs,ρr 1 ,ρr 2 ,ρ O {O P (ρ s , θ 2 m ) = c | [[n]] η ρs = v} and P ρs,ρr 1 ,ρr 2 ,ρ O {w m = c | [[n]] η ρs = v} = P ρs,ρr 1 ,ρr 2 ,ρ O {A O(ρs,ρ O ) (M f , ρ r 1 , θ 1 m , η) = c | [[n]] η ρs = v}</formula><p>The hypothesis gives us that :</p><formula xml:id="formula_42">P ρs,ρr 1 ,ρr 2 ,ρ O {w m = c | [[n]] η ρs = v} = P ρs,ρr 1 ,ρr 2 ,ρ O {w m = c | [[n]] η ρs = v}</formula><p>So we conclude that:</p><formula xml:id="formula_43">P ρs,ρr 1 ,ρr 2 ,ρ O {A O(ρs,ρ O ) (M f , ρ r 1 , θ 1 m , η) = c | [[n]] η ρs = v} = P ρs,ρr 1 ,ρr 2 ,ρ O {O P (ρ s , θ 2 m ) = c | [[n]] η ρs = v}</formula><p>We can finally conclude, as Lemmas 10 and 11 directly yields that Definition 8 is equivalent to Definition 8 simply by taking Q as the empty protocol.</p><p>Example 3.1. We fix first M f (in an arbitrary way). We consider the following handshake protocol, in which n, r, k, r are names:</p><formula xml:id="formula_44">A := in (c A , x 0 ).out(c A , enc(n, r, k)). in (c A , x). if dec(x, k) = n, 1 then out(c A , ok) B := in (c B , y).out(c B , enc( dec(y, k), 1 , r , k))</formula><p>We consider the oracle O enc,dec k that, when receiving t, m as input, answers enc(m, r o , k) if t = "enc", and dec(m, l) if t = "dec" (the oracle actually also expects an handle for the secret key and a tag to specify where to sample r o ). We can easily prove that νk.A is O enc,dec k -simulatable, as the attacker can sample an arbitrary n , use the oracle to compute enc(n , r o , k) (which has the same distribution as enc(n , r, k) for any fixed value of k) with the request "enc", n , and dec(x, k) with the request "dec", x .</p><p>Intuitively, the shared secret k is only used in A in ways that are directly simulatable with the oracle, and A is thus O-simulatable.</p><p>Thanks to the more intuitive Definition of simulatability (cf. Definition 8 for details), proving simulatability is in practice a syntactic verification. With O enc,dec k from the previous example, νk.P is O-simulatable for any P where all occurrences of k occurs at key position, and all encryptions use fresh randoms.</p><p>Let us explain why the previous examples illustrate the need for prefixed models.</p><p>Example 3.2. We take a more formal view on Example 3.1.</p><p>Let O be the encryption-decryption oracle: it expects an input "dec", m or "enc", m , a key s = 1 (only one encryption key is considered), an input tag t and a security parameter η and returns</p><p>• enc(m, r, k) if the query is prefixed by "enc", k is the secret value extracted from ρ s corresponding to the key 1, r is drawn from ρ O and associated with the tag t (via e 1 ).</p><p>• dec(m, k) if the query is prefixed by "dec", k is the secret value extracted from ρ s corresponding to the key 1</p><p>• an error message otherwise (either the primitives fail or the query does not have the expected format).</p><p>The goal is to show that νk.A is O-simulatable. (So, here, B is useless, and we let P be A).</p><p>O P is then defined as follows:</p><p>• On input w 1 , with an empty history, it outputs [[enc(n, r, k)]] η ρs and writes w 1 on the history tape.</p><p>• On input w 2 with a non empty history tape, it outputs</p><formula xml:id="formula_45">ok if [[dec(x, k)]] η,x →w 2 ρs = [[ n, 1 ]] η</formula><p>ρs and an error otherwise.</p><p>The machine A O (ρ r 1 , θ, η) is then defined as follows:</p><formula xml:id="formula_46">• If θ = {m 1 } 1.</formula><p>A draws α (for the value of n) from ρ r 1 and draws t from ρ r 1 2. calls O with ( "enc", α , 1, t) and gets back the bitstring</p><formula xml:id="formula_47">[[enc(n, r, z)]] η,z →[[k]] η ρs ρr 1 ,ρ O</formula><p>. The interpretation of k is indeed fixed at once since it belongs to the "shared" names bounded by ν.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">outputs</head><formula xml:id="formula_48">[[enc(x, r, z)]] η,x →α,z →[[k]] η ρs ρr 1 • If θ = (m 1 , m 2 ), 1. calls O with ( "dec", m 2 , 1, -) and gets back the bitstring w = [[dec(y, z)]] y →m 2 ,z →[[k]] η ρs</formula><p>or an error message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">checks whether</head><formula xml:id="formula_49">w = [[ n, 1 ]] η ρr 1 .</formula><p>If it is the case, then outputs ok. Now, consider an arbitrary PTOM B O .</p><p>•</p><formula xml:id="formula_50">φ 1 1 = [[enc(n, x, k)]] η,x →s 1 ρr 1</formula><p>where s 1 is the randomness used by O when queried with [[t]] ρr 1 (note: we will see that it does matter to be very precise here; we cannot simply claim that the value of x is just a randomness drawn by O).</p><formula xml:id="formula_51">• φ 2 1 = [[enc(n, r, k)]] η ρs • θ 1 i = w i , an arbitrary bitstring, computed by B O using the oracle O, φ 1 i and the random tape ρ r 2 . • φ 1 2 = φ 1 1 , ok if [[dec(y, z)]] y →w 1 ,z →[[k]] η ρs = [[ n,<label>1</label></formula><p>]] η ρr 1 and an error otherwise</p><formula xml:id="formula_52">• φ 2 2 = φ 2 1 , ok if [[dec(x, k)]] η,x →w 2 ρs = [[ n,<label>1</label></formula><p>]] η ρs and an error otherwise</p><formula xml:id="formula_53">A O-simulates νk.P iff, for every v = [[k]] ρs , P ρs,ρ r1 ,ρr 2 ,ρ O {[[dec(y, z)]] y →w 1 ,z →v = [[ n, 1 ]] η ρr 1 } = P ρs,ρr 1 ,ρ r2 ,ρ O {[[dec(x, k)]] η,x →w 2 ρs = [[ n, 1 ]] η ρs }</formula><p>First, the distributions of φ 1 1 and φ 2 1 are identical. φ 1 1 depends on ρ r 1 and ρ O , while φ 2 1 depends on ρ s only. The distributions of <ref type="bibr" target="#b0">1 ]</ref>] ρs are equal if the randomness used by B are disjoint from the random coins used in φ 1 1 , φ 2 1 . This is why there is an assumption that ρ r 1 and ρ r 2 are disjoint and why it should be the case that the random coins used in the oracle queries of B are distinct from the ones used in the oracle queries of A. This can be ensured by the disjointness of tags used by A and B respectively.</p><formula xml:id="formula_54">φ 1 1 , [[ n, 1 ]] ρr 1 and φ 2 1 , [[ n, 1 ]] ρs are also identical. Now the distributions w 1 = B O (φ 1 1 , ρ r 2 ), [[ n, 1 ]] ρr 1 and w 2 = B O (φ 1 2 , ρ r 2 ), [[ n,</formula><p>With these assumptions, we get the identity of the distributions of dec(w</p><formula xml:id="formula_55">1 , v), [[ n, 1 ]] ρs and dec(w 2 , v), [[ n, 1 ]] ρs , hence the desired result.</formula><p>Without these assumptions (for instance non-disjointness of tags used by B, A), B can query O with a random input and a random tag, say n , t . As above, we let s 1 be the random value drawn by O corresponding to the tag t . Then P{</p><formula xml:id="formula_56">[[n]] ρs = n ∧ [[r]] ρs = s 1 } = 1 2 2η while P{[[n]] ρr 1 = n ∧ [[r]] ρr 1 = s 1 } = 1 2 η P{[[t]] ρr 1 = [[t ]] ρr 2 ∨ ([[t]] ρr 1 = [[t ]] ρr 2 ∧ [[r]] ρr 1 = [[r ]] ρ O )} = 1 2 η × ( 1 2 η + 2 η -1 2 η × 1 2 η ) = 1 2 2η (2 -1 2 η )</formula><p>In other words, the collision is more likely to occur since it can result from either a collision in the tags or a collision in the randomness corresponding to different tags.</p><p>As demonstrated in the previous example, it is necessary to assume that oracle randomness used by the simulator queries and the attacker queries are disjoint. The simplest way of ensuring this is to force all tags of oracle calls to be prefixed. We show here that this assumption can be made without loss of generality.</p><p>Definition 12. Given a PTOM A O and a constant c. We define A O pref -c as a copy of A, except that all calls to the oracle of the form w, r, s are replaced with calls of the form w, c•r, s, where the • denotes the concatenation of bitstrings.</p><p>The following lemma shows that we can, w.l.o.g., consider models, in which the tags are prefixed.</p><p>Lemma 13. For any non-empty constant c and any PTOM A O , we haves</p><formula xml:id="formula_57">P ρs,ρr,ρ O {A O(ρs,ρ O ) (ρ r , 1 η ) = 1} = P ρs,ρr,ρ O {A O(ρs,ρ O ) pref -c (ρ r , 1 η ) = 1}</formula><p>Proof. We fix a constant c, for any oracle O (with functions n, e 1 , e 2 ), we define O pref -c (with mapping function n , e 1 , e 2 ) the copy of O such that:</p><formula xml:id="formula_58">n (w, s, r) = n(w, s, c|r)</formula><p>n is injective by definition, so n is injective too. For any v ∈ {0, 1} η , as all extractions of e 1 are unique for each value of n and their length only depends on η, we have for any w, r, s</p><formula xml:id="formula_59">P ρ O {e 1 (n(w, s, r), η, ρ O ) = v} = P ρ O {e 1 (n (w, s, r), η, ρ O ) = v}</formula><p>This implies that for any input, O and O pref -c will produce the same output distribution. So A O and A O pref -c will produce the same distributions for any input. We conclude by remarking that A O pref -c and A O pref -c behaves the same by construction. An immediate consequence of this Lemma is that for all indistinguishability results, we can, w.l.o.g., constrain attackers to only use prefixed oracle calls.</p><p>In particular it implies equivalence between indistinguishability in a computational model and indistinguishability for prefixed distinguishers in the prefixed computational model.</p><p>Thanks to the previous Definitions, simulatability is stable under composition operators. This is an important feature of the notion of simulatability, as it allows to reduce the simulation of large processes to the simulation of simpler processes.</p><p>Theorem 1. Given an oracle O, protocols P, Q, and</p><formula xml:id="formula_60">n = N (P ) ∩ N (Q), if • νn.P is O-simulatable • νn.Q is O-simulatable Then νn.P Q and νn.P ; Q are O-simulatable.</formula><p>Proof. Let D be an arbitrary PTOM. By Lemma 10, there is a machine A O P s.t.</p><formula xml:id="formula_61">P ρs,ρr,ρ O {D O,O P ,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {D[A O P ] O,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v}</formula><p>Applying once more the Lemma 10, there is a machine A O Q s. t., for every c ∈ {0, 1} ,</p><formula xml:id="formula_62">P ρs,ρr,ρ O {D O,O P ,O Q (ρ r , 1 η ) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {D[A O P ][A O Q ] O (ρ r , 1 η ) = c | [[n]] η ρs = v} We define A O P Q (M f , ρ r 1 , θ, 1 η , m)</formula><p>as the machine that behaves as</p><formula xml:id="formula_63">A O P (M f , ρ r 1 ,P , θ P , 1 η , m) (resp. A O Q (M f , ρ r 1 ,Q , θ Q , m))</formula><p>if m is a message supposed to be handled by P (resp. by Q) (use of action determinism) Then the result is appended to θ P (resp. θ Q ). This assumes (this is an invariant) that θ can be split into θ P and θ Q .</p><p>We note that D</p><formula xml:id="formula_64">[A O P ][A O Q ] O = D[A O P Q ] O .</formula><p>Then we use Lemma 11 to conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alternative notions of simulatability</head><p>We discuss here some variation on our notion of simulatability. First, let us note that our notion of simulatability assumes that models are prefixed. As demonstrated previously this is necessary in order to get an achievable notion of simulatability. We will therefore not consider models that are not prefixed. We may consider variants of simulatability, depending on the order of the quantifiers and sharing of randomness between simulator and distinguisher. We define simulatability as the existence of a simulator that works for all distinguishers. In other words our ordering of quantifier is:</p><formula xml:id="formula_65">∃A O (ρ r 1 )∀D(ρ r 2 )</formula><p>In a prefixed model, we believe that switching the quantifiers lead to the same notion:</p><formula xml:id="formula_66">∃A O (ρ r 1 )∀D(ρ r 2 ) ⇔ ∀D(ρ r 2 )∃A O (ρ r 1 )</formula><p>We provide no proof, but the intuition is that there exists a "universal" distinguisher, namely the PTOM D, which performs any possible queries with uniform probability. Now, considering any other distinguisher D , as the simulator A O for D has to provide the exact same distribution as the protocol for each query of D, as D performs all possible queries (with very small probability), A O will also be a correct simulator for D . Another alternative is to allow the simulator and the distinguisher to share the same randomness. Then, ∃A O (ρ r )∀D(ρ r ) seems to provide an unachievable definition. Indeed, if the simulator is not allowed to use private randomness while the protocol is, the simulator cannot mimic the probabilistic behavior of the protocol.</p><p>The last possibility however seems to offer an alternative definition for simulatability:</p><formula xml:id="formula_67">∀D(ρ r )∃A O (ρ r )</formula><p>This seems to be a weaker definition than ours as the choices of the simulator can depend on the ones of the distinguisher. It may simplify (slightly) the proofs for the main theorem, but it would create issues for the unbounded replication as it would break uniformity of reductions (since the runtime of the simulator may now depend on the environment it is running in).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generic Oracles for Tagged Protocols</head><p>In order for our definition of simulatability to be useful, the design of oracles is a key point. They need to be:</p><p>1. generic/simple, yet powerful enough so that protocols can be easily shown to be simulatable, 2. restrictive enough so that proving protocols in the presence of oracles is doable.</p><p>We provide here with examples of such oracles, namely generic tagged oracles for signature, that will be parameterized by arbitrary functions, together with security properties that are still true in the presence of tagged oracles.</p><p>In practice, protocols that use some shared secrets use tags, for instance string prefixes, to ensure that messages meant for one of the protocol cannot be confused with messages meant for the other one. These tags can ensure what is called "domain separation" of the two protocols, ensuring that the messages obtained from one cannot interfere with the security of the second protocol. These tags can be explicit, for instance by adding a fixed constant to the messages, or implicit, where each message of a protocol depend on some fresh randomness that can be used to define some kind of session identifier.</p><p>We define generic oracles for decryption and signatures, parameterized by an abstract tagging function T and a secret key sk, that allow to perform a cryptographic operation with the key sk, on any message m satisfying T (m). T can then simply check the presence of a prefix, or realize some implicit tagging, checking that the message depends on the randomness used by a specific session.</p><p>After defining those generic oracles, we define generic axioms, parameterized by T , that allow to perform proofs against attackers with access to the oracle. The generic axiom for signatures (or any other primitive) are implied by the classical cryptographic axioms.</p><p>We see tagging as a boolean function T computable in polynomial time over the interpretation of messages. For instance, if the messages of protocol P are all prefixed with the identifier id P , T is expressed as T (m) := ∃x.m = id P , x . In a real life protocol, id P could for instance contain the name and version of the protocol.</p><p>Intuitively tagged oracles produce the signature of any properly tagged message and allow to simulate P .</p><p>With these oracles, an immediate consequence of the composition Theorems found in Section 4 is the classical result that if two protocols tag their messages differently, they can be safely composed <ref type="bibr" target="#b27">[28]</ref>. Note that as our tag checking function is an arbitrary boolean function: tagging can be implicit, as illustrated in our applications in Section 6.</p><p>As an example, we provide two oracles, one for encryption and one for signing, that allow to simulate any protocol that only produces messages that are well tagged for T . Definition 14. Given a name sk and a tagging function T , we define the generic signing oracle O sign T,sk and the generic decryption oracle O dec T,sk as follows:</p><formula xml:id="formula_68">O sign T,sk (m) := if T (m) then output(sign(m, sk)) O dec T,sk (m) := if T (dec(m, sk)) then output(dec(m, sk))</formula><p>Any well-tagged protocol according to T , i.e., a protocol that only decrypts or signs well tagged messages, will be simulatable using the previous oracles. Hence we meet the goal 1 stated at the beginning of this section, as this can be checked syntactically on a protocol. We provide, as an example, the conditions for a tagged signature.</p><p>Example 3.3. Any protocol P whose signatures are all of the form if T (t) then sign(t, sk) for some term t (that does not use sk) is immediately νsk.P O sign T,sk -simulatable. Indeed, informally, all internal values of the protocol except sk can be picked by the simulator from its own randomness, while all terms using sk can be obtained by calls to the tagged signing oracle, as all signed terms in P are correctly tagged. Let us emphasize that the simulation holds for any specific value of sk, as the distribution of outputs is the same, whether it is the simulator that draws the internal names of P , except sk, or P itself.</p><p>As we need to perform cryptographic proofs in the presence of oracles, it is useful to define security properties that cannot be broken by attackers with access to these oracles (without having to consider the specific calls made to these oracles). The games defining these properties slightly differ from the classical security games. Consider the example of signatures and the usual EUF-CMA game. If the attacker is, in addition, equipped with an oracle O that signs tagged messages, they immediately win the EUF-CMA game, "forging" a signature by a simple call to O. We thus define a tagged unforgeability game (T-EUF-CMA), derived from the EUF-CMA game, where the adversary wins the game only if they are able to produce the signature of a message that is not tagged. Definition 15. A signature scheme (Sign, Vrfy) is T-EUF-CMA secure for oracle O and interpretation of keys A sk if, for any PTOM A, the game described in Figure <ref type="figure" target="#fig_1">3</ref> returns true with probability (over ρ r , ρ s , ρ O ) negligible in η. The main goal of the previous definition is to allow us to prove protocols in the presence of oracles (hence composed with simulated ones), reaching the goal 2 stated at the beginning of the section.</p><formula xml:id="formula_69">Game EUF-CMA Σ,A T,sk (η, ρ r , ρ s , ρ O ): List ← [] (pk, sk) ← ([[pk]] ρs , [[sk]] ρs ) (m, σ) ← A O(ρs,ρ O ),Sign (pk, η, ρ r ) Return ¬T (m) ∧ Vrfy(pk, m, σ) ∧ m ∈ List Oracle Sign(m): List ← (m : List) σ ← Sign(sk, m) Return σ</formula><p>More precisely, one can, for instance, simply design a classical game based proof, reducing the security of the protocol to the security of the T-EUF-CMA game rather than the classical EUF-CMA game. This reasoning is valid as EUF-CMA implies T-EUF-CMA even in the presence of the corresponding oracle. Remark that the base assumptions made about the cryptographic primitives are classical ones, and thus the final proof of the composed protocol only depends on some classical cryptographic hypotheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Main Composition Theorems</head><p>We distinguish between two complementary cases. First, Theorem 2 covers protocols composed in a way where they do not share states besides the shared secrets (e.g., parallel composition of different protocols using the same master secret key). Second, Theorem 4 covers protocols passing states from one to the other (e.g., a key exchange passing an ephemeral key to a secure channel protocol). We finally extend these composition results to self-composition, i.e., proving the security of multiple sessions from the security of a single one or the security of a protocol lopping on itself, for instance a key renewal protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Composition without State Passing</head><p>Essentially, if two protocols P, Q are indistinguishable, they are still indistinguishable when running in any simulatable context. The context must be simulatable for any fixed values of the shared names of P, Q and the context. The context can contain parallel or sequential composition as illustrated by the following example. </p><formula xml:id="formula_70">. P R ∼ = O Q R 2. R; P ∼ = O R; Q 3. (R; P ) S ∼ = O (R; Q) S</formula><p>We generalize the previous example to any simulatable context and to n protocols. For any integer n, we denote by C[_ 1 , . . . , _ n ] a context, i.e., a protocol built using the syntax of protocols and distinct symbols _ i , viewed as elementary processes. C[P 1 , . . . , P n ] is the protocol in which each hole _i is replaced with P i .</p><p>Example 4.2. In the three examples of Example 4.1, in order to apply the next theorem, we respectively use as contexts</p><formula xml:id="formula_71">• C[_ 1 ] := _ 1 R • C[_ 1 ] := R; _ 1 • C[_ 1 ] := (R; _ 1 ) S.</formula><p>In this first Theorem, no values (e.g., ephemeral keys) are passed from the context to the protocols. In particular, the protocols do not have free variables which may be bound by the context.</p><p>Theorem 2. Given a cryptographic library M f and an oracle O, let P 1 , . . . , P n , Q 1 , . . . , Q n be protocols and C[_ 1 , . . . , _ n ] be a context such that all their channels are disjoint, 0 some constant, n a sequence of names and c 1 , . . . , c n fresh channel names. If</p><formula xml:id="formula_72">1. N (C) ∩ N (P 1 , . . . , P n , Q 1 , . . . , Q n ) ⊆ n 2. νn.C[out(c 1 , 0), . . . , out(c n , 0)] is O-simulatable 3. P 1 . . . P n ∼ = O Q 1 . . . Q n Then C[P 1 , . . . , P n ] ∼ = O C[Q 1 , . . . , Q n ]</formula><p>Specifically<ref type="foot" target="#foot_2">3</ref> , there exists a polynomial p S (independent of C) such that, if p C is the polynomial bound on the runtime of the simulator for C, we have,</p><formula xml:id="formula_73">Adv C[P 1 ,...,Pn] ∼ =OC[Q1,...,Qn] (t) ≤ Adv P 1 ... Pn ∼ =OQ1 ... Qn p S t, n, |C|, p C (t)</formula><p>Note that the bound we obtain for the reduction is polynomial in the running time of the context. We denote by C the protocol C in which each _i is replaced with out(c i , 0).0, where c i is a channel name and 0 is a public value. Intuitively, C abstracts out the components P i , only revealing which P i is running at any time. The intuition behind the proof of the Theorem is then as follows. First, we show that C P 1 . . .</p><formula xml:id="formula_74">P n ∼ = O C Q 1 . . . Q n implies C[P 1 , . . . , P n ] ∼ = O C[Q 1 , . . . , Q n ]</formula><p>. This is done by a reduction, where we mainly have to handle the scheduling, which is possible thanks to the information leaked by C, and the action determinism of the protocols. In a sense, this means that indistinguishability for protocols in parallel implies indistinguishability for any scheduling of those protocols. Secondly, by simulating C thanks to Proposition 7, the two hypothesis of the Theorem imply</p><formula xml:id="formula_75">C P 1 . . . P n ∼ = O C Q 1 . . . Q n .</formula><p>The second part is where our notion of simulatability comes into play, and where it is essential to deal carefully with the shared secrets.</p><p>For our latter results, we must actually generalize slightly this Theorem. A use case is for instance when we want to prove that P Q ∼ = P P implies that ifbthenP elseQ ∼ = P for some boolean condition b. In this case, we actually need to rename the channels used by P and Q in the second protocol, so that both P and Q uses the same channels. We thus introduce a renaming on channels σ that allows us to compose components in an arbitrary way.</p><p>The generalized version of the Theorem is as follows.</p><p>Theorem 3. Let C[_ 1 , . . . , _ n ] be a context. Let P 1 , . . . , P n , Q 1 , . . . , Q n be protocols, and let σ :</p><formula xml:id="formula_76">C(P 1 , . . . , P n ) → C such that C P 1 . . . P n , C Q 1 . . . Q n , C[P 1 σ, . . . , P n σ], C[Q 1 σ, . . . , Q n σ] are protocols. Given a cryptographic library M f , an oracle O, if 1. n ⊇ N (C) ∩ N (P 1 , . . . , P n , Q 1 , . . . , Q n ) 2. νn.C is O-simulatable 3. P 1 . . . P n ∼ = O Q 1 . . . Q n Then C[P 1 σ, . . . , P n σ] ∼ = O C[Q 1 σ, . . . , Q n σ]</formula><p>Specifically, there exists a polynomial p S (independent of C) such that, if p C is the polynomial bound on the runtime of the simulator for C, we have,</p><formula xml:id="formula_77">Adv C[P 1 σ,...,Pnσ] ∼ =OC[Q1σ,...,Qnσ] (t) ≤ Adv P 1 ... Pn ∼ =OQ1 ... Qn p S t, n, |C|, |σ|, p C (t)</formula><p>Proof. Let A be an attacker against</p><formula xml:id="formula_78">C[P 1 σ, . . . , P n σ] ∼ = O C[Q 1 σ, . . . , Q n σ].</formula><p>In the scheduling part, we first build an attacker against</p><formula xml:id="formula_79">C P 1 . . . P n ∼ = O C Q 1 . . . Q n .</formula><p>We then remove the context C through the O-simulatability.</p><p>Scheduling part Let us construct B O,O C ,O R 1 ,...,O Rn with either for every i, R i = P i , or, for every i,</p><formula xml:id="formula_80">R i = Q i . B O,O C ,O R 1 ,.</formula><p>..,O Rn initially sets variables c 1 , . . . , c n to 0 (intuitively, c i records which processes have been triggered) and sets x to the empty list. It then simulates Rnσ] but, each interaction with O C[R 1 σ,...,Rnσ] and the corresponding request (c, m) is replaced with:</p><formula xml:id="formula_81">A O,O C[R 1 σ,...,</formula><p>• if there exist i such that c i = 1 and c ∈ C(R i σ) then</p><formula xml:id="formula_82">-query O R i with (cσ -1 , m) -if O R i returns ⊥, then, if contexts C 1 and C 2 are such that C[_ 1 , . . . , _ n ] = C 1 [_ i ; C 2 ], it adds to x the channels C(C 2 )</formula><p>. (This corresponds to the semantics of sequential composition: an error message disables the continuation).</p><p>else the answer (c , m ) is changed (c σ, m ) (and the simulation goes on)</p><formula xml:id="formula_83">• else if c ∈ C(C) and c / ∈ x then -query O C with (c, m) -if O C answers on channel γ i , set c i = 1 -else continue with the reply of O C</formula><p>This new attacker is basically simply handling the scheduling of the protocols, using the signals raised in the context to synchronize everything. The condition that there exists i such that c i = 1 and c ∈ C(R i ) is always satisfied by a unique i, otherwise C[P 1 σ, . . . , P n σ] or C[Q 1 σ, . . . , Q n σ] would not be well formed.</p><p>The execution time of B then only depends on the number of channels in C, the size of the channel substitution σ, the number of protocols n in addition to the cost of simulating A. Hence if t is the runtime of A, there exists p S 1 such that the runtime of B is bounded (uniformly in C, P 1 , . . . , P n , Q 1 , . . . Q n ) by p S 1 (n, t, |C|, |σ|):</p><formula xml:id="formula_84">Adv C[P 1 ,...,Pn] ∼ =C[Q1,...,Qn] A O (t) ≤ Adv P 1 ... Pn ∼ =Q1 ... Qn B O,O C (p S 1 (t, n, |C|, |σ|))</formula><p>Simulatability Now, with the fact that νn.C is O-simulatable, we have a simulator</p><formula xml:id="formula_85">A O C such that, thanks to Lemma 10, B[A O C ] O,O R behaves exactly as B O,O C ,O R .</formula><p>We have, for p C the polynomial bound on the runtime of A C , by Definition 5,</p><formula xml:id="formula_86">Adv P 1 ... Pn ∼ =Q1 ... Qn B O,O C (t) ≤ Adv P 1 ... Pn ∼ =Q1 ... Qn B[A O C ] O (q(p C (t) + t))</formula><p>and finally,</p><formula xml:id="formula_87">Adv C[P 1 σ,...,Pnσ] ∼ =C[Q1σ,...,Qnσ] A O (t) ≤ Adv P 1 ... Pn ∼ =Q1 ... Qn B[A O C ] O (q(p C • p S 1 (n, t, |C|, |σ|) + p S 1 (n, t, |C|, |σ|)))</formula><p>Given a protocol P and a context C, for Theorem 2 to be used, we need an oracle such that:</p><p>1. the context C is simulatable with the oracle O, 2. the protocol P is secure even for an attacker with access to O (P ∼ = O Q).</p><p>Our goal is to find an oracle that is generic enough to allow for a simple proof of indistinguishability of P and Q under the oracle, but still allows to simulate C. Notably, if we take as oracle the protocol oracle corresponding to the context itself, we can trivially apply Theorem 2 but proving</p><formula xml:id="formula_88">P ∼ = O Q amounts to proving C[P ] ∼ = C[Q].</formula><p>Application to tagged protocols We consider two versions of SSH, calling them SSH 2 and SSH 1 , assuming that all messages are prefixed respectively with the strings "SSHv2.0" and "SSHv1.0". Both versions are using the same long term secret key sk for signatures. We assume that both versions check the string prefix.</p><p>To prove the security of SSH 2 running in the context of SSH 1 , we can use Theorem 2. If we denote by I the idealized version of SSH 2 , the desired conclusion is <ref type="bibr">Definition 14)</ref> as SSH 1 does enforce the tagging checks. We thus let O be O sign</p><formula xml:id="formula_89">SSH 2 SSH 1 ∼ = I SSH 1 . Letting C[_ 1 ] = _ 1 SSH 1 , it is then sufficient to find an oracle O such that: 1. νsk.SSH 1 is O-simulatable (the simulatability of C directly follows), 2. SSH 2 ∼ = O I If we define the tagging function T SSH 1 that checks the prefix, SSH 1 is trivially O sign T SSH 1 ,sk - simulatable (see</formula><formula xml:id="formula_90">T SSH 1 ,sk .</formula><p>Assuming that sign verifies the classical EUF-CMA axiom, by Proposition 16, it also verifies the tagged version EUF-CMA T SSH 1 ,sk . To conclude, it is then sufficient to prove that SSH 2 ∼ = O I with a reduction to EUF-CMA T SSH 1 ,sk .</p><p>Application to encrypt and sign For performances considerations, keys are sometimes used both for signing and encryption, for instance in the EMV protocol. In <ref type="bibr" target="#b28">[29]</ref>, an encryption scheme is proven to be secure even in the presence of a signing oracle using the same key. Our Theorem formalizes the underlying intuition, i.e. if a protocol can be proven secure while using this encryption scheme, it will be secure in any context where signatures with the same key are also performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Composition with State Passing</head><p>In some cases, a context passes a sequence of terms to another protocol. If the sequence of terms is indistinguishable from another one, we would like the two experiments, with either sequences of terms, to be indistinguishable.</p><p>Example 4.3. Let us consider the protocol P (x 1 , x 2 ) := in(c, x).out(c, enc(x, x 1 , x 2 )). We assume that we have a function kdf, which, given a random input, generates a suitable key for the encryption scheme. Let a random name seed and let C[_ 1 ] := let sk = kdf(seed) in _ 1 . C[ i P (r i , sk)] provides an access to an encryption oracle for the key generated in C:</p><formula xml:id="formula_91">C[ i P (r i , sk)] := let sk = kdf(seed) in i (in(c, x).out(c, enc(x, r i , sk)))</formula><p>A classical example is a key exchange, used to establish a secure channel. The situation is dual with respect to the previous theorem: contexts must be indistinguishable and the continuation must be simulatable. Theorem 4. Let C, C be n-ary contexts such that each hole is terminal. Let P 1 (x), . . . , P n (x) be parameterized protocols, such that channel sets are pairwise disjoint. Given a cryptographic library M f , an oracle O , n ⊇ N (C) ∩ N (P 1 , . . . , P n ), t 1 , . . . , t n , t 1 , . . . , t n sequences of terms,</p><formula xml:id="formula_92">C := C[out(c 1 , t 1 ), . . . , out(c n , t n )] and C := C [out(c 1 , t 1 ), . . . , out(c n , t n )]. If C in(c 1 , x).P 1 (x) . . . in(c n , x).P n (x) is a protocol and: 1. C ∼ = O C 2. νn.in(c 1 , x).P 1 (x) . . . in(c n , x).P n (x) is O-simulatable then C[P 1 (t 1 ), . . . , P n (t n )] ∼ = O C [P 1 (t 1 ), . . . , P n (t n )]</formula><p>Specifically, there exists a polynomial p S (independent of P 1 , . . . , P n ) such that if p O is the polynomial bound on the runtime of the simulator for P := in(c 1 , x).P 1 (x) . . . in(c n , x).P n (x), we have,</p><formula xml:id="formula_93">Adv C[P 1 (t 1 ),...,Pn(tn)] ∼ =OC[P1(t 1 ),...,Pn(t n )] (t) ≤ Adv C ∼ =O C p S t, n, |P |, p P (t)</formula><p>C is the context, in which all the bound values (for instance the key derived by a key exchange) are outputted on distinct channels. C corresponds to the idealized version. We can pass those bound values to another protocol P , if this protocol P can be simulated for any possible value of the bound values.</p><p>Proof. The proof is very similar to Theorem 2.</p><p>Let us assume that we have an attacker such that = 0</p><formula xml:id="formula_94">Adv A O,O</formula><p>We denote</p><formula xml:id="formula_95">C 1 = C[out(c 1 , t 1 ), . . . , out(c n , t n )], C 2 = C[out(c 1 , t 1 ), . . . , out(c n , t n )], P 1 = in(1, x</formula><p>).P 1 (x), . . . , P n = in(n, x).P n (x). We first construct an attacker against:</p><formula xml:id="formula_96">C 1 P 1 . . . P n ∼ = C 2 P 1 . . . P n Let us consider B O,O D ,O P 1 ,...,O P n which simulates A O,O</formula><p>C[P 1 (t 1 ),...,Pn(tn)]?C[P 1 (t 1 ),...,Pn(t n )] but, after setting some variables d 1 , . . . , d n to 0 and some list x to the empty list, for every call to O C[P 1 (t 1 ),...,Pn(tn)]?C[P 1 (t 1 ),...,Pn(t n )] of the form (c, m):</p><formula xml:id="formula_97">• if there exist i such that d i = 1 and c ∈ C(P i ) then -query O P i with (cσ -1 , m) -if O P i terminates set c i = 0 and if it returns ⊥, then, with C and C such that C[_ 1 , . . . , _ n ] = C[_ i ; C ] it adds to x the channels C(C )</formula><p>else it forwards the answer (c , m ) as (c σ, m ) When we do so, we only assume that they are all distinct. The following example shows how Theorems 2 and 4 can be used to derive the security of one session of a key exchange composed with a protocol.</p><formula xml:id="formula_98">• else if c ∈ C(C 1 )</formula><p>Example 4.4. Let us consider a key exchange I R where x I (resp. x R ) is the key derived by the initiator I (resp. the responder R) in case of success. We denote by KE[_ 1 , _ 2 ] := I; _ 1 R; _ 2 the composition of the key exchange with two continuations; the binding of x I (resp. x R ) is passed to the protocol in sequence. Consider possible continuations P I (x I ), P R (x R ) that use the derived keys and ideal continuations (whatever "ideal" is)</p><formula xml:id="formula_99">Q I (x I ), Q R (x R ). We sketch here how to prove KE[P I (x I ), P R (x R )] ∼ = KE[Q I (x I ), Q R (x R )] (i.e.</formula><p>, the security of the channel established by the key exchange). This will be generalized to multi-sessions in Section 6. We use both Theorems 2 and 4.</p><p>Assume, with a fresh name k, that:</p><p>1. O ke is an oracle allowing to simulate the key exchange</p><formula xml:id="formula_100">2. O P,Q allows to simulate in(c I , x).P I (x) in(c R , x).P R (x) and in(c I , x).Q I (x) in(c R , x).Q R (x) 3. P I (k) P R (k) ∼ = O ke Q I (k) Q R (k) 4. KE[out(c I , x I ), out(c R , x R )] ∼ = O P,Q KE[out(c I , k), out(c R , k)]</formula><p>Hypothesis 3 captures the security of the channel when executed with an ideal key, and Hypothesis 4 captures the security of the key exchange. Both indistinguishability are for an attacker that can simulate the other part of the protocol. Using Theorem 2 with Hypothesis 1 and 3 yields</p><formula xml:id="formula_101">KE[P I (k), P R (k)] ∼ = KE[Q I (k), Q R (k)]</formula><p>Hypothesis 2 and 4 yield, with two applications of Theorem 4, one for P and one for Q, that</p><formula xml:id="formula_102">KE[P I (x I ), P R (x R )] ∼ = KE[P I (k), P R (k)] and KE[Q I (x I ), Q R (x R )] ∼ = KE[Q I (k), Q R (k)].</formula><p>Transitivity allows us to conclude that the key exchange followed by the channel using the produced key is indistinguishable from the key exchange followed by the ideal secure channel:</p><formula xml:id="formula_103">KE[P I (x I ), P R (x R )] ∼ = KE[Q I (x I ), Q R (x R )]</formula><p>In Theorem 4, the simulatability of</p><formula xml:id="formula_104">νn.in(c P , k); P (k) in(c Q , k); Q(k)</formula><p>may be a requirement too strong in some applications. This issue will be raised when we consider the forwarding agent of the SSH protocol, as detailed in Section 9.3, but we can avoid it in this specific case. For more complex applications, it might be interesting in the future to consider a weaker version of function applications where the produced key k always satisfies a condition H(k). We could then design an oracle O so that for all names satisfying condition H(k) we would have that</p><formula xml:id="formula_105">P (k) Q(k) is O-simulatable.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Unbounded Replication</head><p>An important feature of a compositional framework is the ability to derive the security of a multi session protocol from the analysis of a single session. To refer to multiple sessions of a protocol, we consider that each session uses some fresh randomness that we see as a local session identifier.</p><p>The main idea behind the Theorem is that the oracle will depend on a sequence of names of arbitrary length. This sequence of names represents the list of honest randomness sampled by each party of the protocol, and the oracle enables simulatability of those parties.</p><p>We provide bellow the Proposition that allows to put in parallel any number of replications of simulatable protocols. Proposition 17. Let O r be an oracle parameterized by a sequence of names s, and O an oracle. Let p be a sequence of names, P (x), R 1 i (x, y), . . . , R k i (x, y) and Q(x) be protocols, such that N l (R 1 i , . . . , R k i ) is disjoint of the oracle support. If we have, for sequences of names lsid 1 , . . . , lsid k , with s = {lsid j i } 1≤j≤k,i∈N :</p><p>1. ∀i, j ∈ N, νp, lsid</p><formula xml:id="formula_106">j i .R j i (p, lsid j i ) is O r -simulatable. 2. P (p) ∼ = Or Q(p) 3. s is disjoint of the support of O.</formula><p>Then, for any integers N 1 , . . . , N k :</p><formula xml:id="formula_107">P (p) i≤N 1 (R 1 i (p, lsid<label>1</label></formula><formula xml:id="formula_108">i ) . . . i≤N k R k i (p, lsid k i ) ∼ = O,Or Q(p) i≤N 1 R 1 i (p, lsid<label>1</label></formula><formula xml:id="formula_109">i ) . . . i≤N k R k i (p, lsid k i )</formula><p>Specifically, there exists a polynomial p S (independent of all R j ) such that if p R j is the polynomial bound on the runtime of the simulator for R j , we have,</p><formula xml:id="formula_110">Adv P (p) i≤N 1 (R 1 i (p,lsid 1 i ) ... i≤N k R k i (p,lsid k i ) ∼ =OQ(p) i≤N 1 R 1 i (p,lsid<label>1</label></formula><formula xml:id="formula_111">i ) ... i≤N k R k i (p,lsid k i ) (t) ≤ Adv P (p) ∼ =O,O r Q(p) p S t, N 1 , |R 1 |, . . . , N k , |R k |, p R 1 (t), . . . , p R k (t)</formula><p>In the previous proposition and following applications, we talk about sequences of names of the form s = {lsid j i } 1≤j≤k,i∈N . This does not have any practical meaning and is only a shortcut. In practice, we must have that the previous hypotheses hold for any polynomial p and any sequence s = {lsid j i } 1≤j≤k,1≤i≤p(η) . We will precisely define this in Section 12. Applying the previous Proposition with P and Q as R 1 and R 2 , we can obtain the Theorem for the unbounded replication of a protocol, where the number of sessions depends on the security parameter.</p><p>Theorem 5. Let O r , O be oracles both parameterized by a sequence of names s. Let p be a sequence of names, P i (x, y) and Q i (x, y) be parameterized protocols, such that N l (P, Q) is disjoint of the oracles support. If we have, for sequences of names lsid P , lsid Q , with s =</p><formula xml:id="formula_112">{lsid P i , lsid Q i } i∈N : 1. ∀ i ≥ 1, νp, lsid P i .P i (p, lsid P i ) is O r -simulatable. 2. ∀ i ≥ 1, νp, lsid Q i .Q i (p, lsid Q i ) is O r -simulatable.</formula><p>3. s is disjoint of the support of O.</p><p>4. P 0 (p, lsid</p><formula xml:id="formula_113">P 0 ) ∼ = Or,O Q 0 (p, lsid Q 0 ) then, || i P i (p, lsid P i ) ∼ = O || i Q i (p, lsid Q i )</formula><p>To prove this result, we use the explicit advantages that can be derived from our composition Theorems, which increases polynomially with respect to the number of sessions, and apply a classical hybrid argument to conclude.</p><p>In our applications (Section 6), the main idea is to first use Theorem 5 to reduce the multi-session security of a key exchange or a communication channel to a single session, and then use Theorems 2 and 4 to combine the multiple key exchanges and the multiple channels.</p><p>Remark, that in practice, to express the security properties of the protocols, we need to allow the protocols to use a predicate T (x) whose interpretation may depend on the list of honest randomness sampled by each party of the protocol. For instance, this predicate may be used to check whether a value received by a party corresponds to a randomness sent by another party, and we would have T (x) := x ∈ s. The two previous Theorems are in fact also valid in such cases, and we will use such notations in the application to key exchanges, but we delay to Section 12 the formalization of such predicates.</p><p>Proposition 18. Let O be an oracle, two parameterized processes P (x), Q(x), a set of names n = N g (P, Q) and fresh names k 0 , l. We assume that N l (P, Q) is disjoint of the support of O. If:</p><p>• νn.in(c P , x); P (x) in(c Q , x); Q(x) is O-simulatable, and</p><formula xml:id="formula_114">• P (k 0 ); out(c P , x) Q(k 0 ); out(c Q , x) ∼ = O P (k 0 ); out(c P , l) Q(k 0 ); out(c Q , l)</formula><p>then, for any N,</p><formula xml:id="formula_115">P (k 0 ); P (x) ;N ; out(c P , x) Q(k 0 ); Q(x) ;N ; out(c Q , x) ∼ = O P (k 0 ); P (x) ;N ; out(c P , l) Q(k 0 ); Q(x) ;N ; out(c Q , l)</formula><p>The main idea behind the proof is to perform as many function applications (Theorem 4) as needed, one for each replication of the protocol. Remark that compared to the previous replication, where we considered multiple sessions of the protocol and thus a notion of local session identifier was required, here we consider a single session looping on itself, and we do not need those identifiers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Part II</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Applications to Key Exchange 6 Application to Key Exchanges</head><p>Although our framework is not specifically tailored to key exchanges or any specific property, we choose to focus here on this application. We outline how our theorems may be used to prove the security of a protocol using a key derived by a key exchange in a compositional way. (Let us recall that the key exchange and the protocol using the derived key may share long term secrets).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Our Model of Key Exchange</head><p>In order to obtain injective agreement, key exchanges usually use fresh randomness for each session as local session identifiers. For instance in the case of a Diffie-Hellman key exchange, the group shares may be seen as local session identifiers.</p><p>As in Example 4.4, KE is a key exchange with possible continuations. In addition, we consider multiple copies of KE, indexed by i, and local session identifiers lsid for each copy:</p><formula xml:id="formula_116">KE i [_ 1 , _ 2 ] := I(lsid I i , id I ); _ 1 R(lsid R i , id R ); _ 2</formula><p>Here, id captures the identities of the parties and lsid captures the randomness that will be used by I and R to derive their respective local session identifiers. In the key exchange, I binds x I to the key that it computes, x I lsid to the value of lsid received from the other party and x I id to the received identity. Symmetrically, R binds the variables x R , x R lsid and x R id . If we denote by P I i (x I ) P R i (x R ) the continuation (e.g., a record protocol based on the derived secret key), KE i [P I i (x I ), P R i (x R )] is the composition of a session of the key exchange with the protocol where the values of x I , x R (computed keys) are passed respectively to</p><formula xml:id="formula_117">P I i (x I ) or P R i (x R ).</formula><p>With Q an idealized version of P (however it is defined), the security of the composed protocol is expressed as follows:</p><formula xml:id="formula_118">i KE i [P I i (x I ), P R i (x R )] ∼ = i KE i [Q I i (x I ), Q R i (x R )]</formula><p>Intuitively, from the adversary point of view, P is equivalent to its idealized version, even if the key is derived from the key exchange as opposed to magically shared. Equivalently, the security of the composed protocol can be proved if we have that the advantage against the following indistinguishability is polynomial in N (and of course negligible).</p><p>i≤N</p><formula xml:id="formula_119">KE i [P I i (x I ), P R i (x R )] ∼ = i≤N KE i [Q I i (x I ), Q R i (x R )]</formula><p>A Corollary formalizing the following discussion can be found in Appendix F.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Proofs of Composed Key Exchange Security</head><p>Following the same applications of Theorems 2 and 4 as in Example 4.4, we decompose the proof of the previous indistinguishability goals into the following goals:</p><p>1. find an oracle O P,Q to simulate multiple sessions of P or Q, 2. design an oracle O ke to simulate multiple sessions of KE 3. complete a security proof under O ke for multiple sessions of the protocol using fresh keys, 4. complete a security proof under O P,Q for multiple sessions of the key exchange.</p><p>We further reduce the security of the protocol to smaller proofs of single sessions of the various components of the protocols under well chosen oracles. The following paragraphs successively investigate how to simplify the goals (1),( <ref type="formula" target="#formula_206">2</ref>),(3),(4) above. For simplicity, we only consider here the case of two fixed honest identities.</p><p>In the following, we provide the conditions S-1,S-2,P-1,P-2,P-3,P-4,K-1,K-2,K-3 that must be satisfied, so that we can prove</p><formula xml:id="formula_120">i KE i [P I i (x I ), P R i (x R )] ∼ = i KE i [Q I i (x I ), Q R i (x R )]</formula><p>using our framework and the decomposition of Example 4.4. Corollary 2, that formalizes the following discussion and generalizes it to non fixed identities, can be found in Appendix F.1.</p><p>We denote p = {id I , id R } and assume that they are the only shared names between KE, P and Q and are the only names shared by two distinct copies P i , P j (resp. Q i , Q j ). We also denote by s = {lsid I i , lsid R i } i∈N the set of all copies of the local session identifiers.</p><p>Protocol simulatability For the simulation of the protocol, there must exists an oracle</p><formula xml:id="formula_121">O P,Q such that S-1 νp.in(c I , x I ).P I i (x I ) in(c R , x R ).P R i (x R ) is O P,Q -simulatable</formula><p>Indeed, if this condition is fulfilled (and a similar one replacing P with Q), then, thanks to Theorem 1, νp. i (in(c I , x I ).</p><formula xml:id="formula_122">P I i (x I ) in(c R , x R ).P R i (x R</formula><p>)) is O P,Q -simulatable (and similarly for Q). This meets the condition (2) of Theorem 4.</p><p>Key exchange simulatability For the simulation of the key exchange context, we need N (with N polynomial in the security parameter) copies of KE and, in each of them, the initiator (resp. the responder) may communicate with N possible responders (resp. initiators). We therefore use Theorem 2 with a context C with 2N 2 holes. C is the parallel composition of N contexts and, as above, we use Theorem 1 to get the condition (1) of Theorem 2. Let KE i be <ref type="foot" target="#foot_4">4</ref>KE i [ if</p><formula xml:id="formula_123">1≤j≤N x I lsid = lsid R j then out(c I , i, j ) else ⊥, if 1≤j≤N x R lsid = lsid I j then out(c R , i, j ) else ⊥]</formula><p>C is then i≤N KE i and C can be inferred by replacing each out( i, j ) with a hole. We output i, j so that we know that the full scheduling is simulatable. Then, the condition to be met by the key exchange is that</p><formula xml:id="formula_124">S-2 νp.KE i is O ke -simulatable</formula><p>We then get, thanks to Theorem 1 the condition (1) of Theorem 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Security of the protocol Our goal is</head><formula xml:id="formula_125">i P i (k i ) ∼ = O ke i Q i (k i ).</formula><p>Based on Theorem 5, we only need an oracle O r so that:</p><formula xml:id="formula_126">P-1) ∀ i ≥ 1, νp, k i .P 0 (k i ) is O r -simulatable, P-2) ∀ i ≥ 1, νp, k i .Q 0 (k i ) is O r -simulatable, P-3) s is disjoint of the support of O ke , P-4) P 0 (k 0 ) ∼ = Or,O ke Q 0 (k 0 ).</formula><p>We use the fresh names k i to model fresh magically shared keys, and use them as local sids for Theorem 5. The intuition is similar to the notion of Single session game of <ref type="bibr" target="#b17">[18]</ref>, where the considered protocols are such that we can derive the security of multiple sessions from one session. For instance, if the key is used to establish a secure channel, revealing the other keys does not break the security of one session, but allows to simulate the other sessions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Security of the key exchange</head><p>The security of the key exchange is more complicated to define, in the sense that it cannot simply be written with a classical replication. The partnering of sessions is not performed beforehand, so we must consider all possibilities. We may express the security of a key exchange by testing the real-or-random for each possible session key. We denote k i,j the fresh name corresponding to the ideal key that will be produced by the i-th copy of the initiator believing to be partnered with the j-th copy of the responder. The security of the key exchange is captured through the following indistinguishability:</p><formula xml:id="formula_127">i≤N KE i [out(x I ), out(x R )] ∼ = O P,Q i≤N KE i [ if 1≤j≤N x I lsid = lsid R j then out(k i,j ) else ⊥, if 1≤j≤N (x R lsid = lsid I j ) then out(k j,i ) else ⊥]</formula><p>where the advantage of the attacker is polynomial in N . Remark that we sometimes omit channels, when they only need to be distinct.</p><p>Using a classical cryptographic hybrid argument (detailed in Proposition 39), we reduce the security of multiple sessions to the security of one session in parallel of multiple corrupted sessions; the security of each step of the hybrid game is derived from Equation (1) using Theorem 4. It is expressed, with state</p><formula xml:id="formula_128">X i = x X , lsid X i , x X lsid , as i≤N KE i [out( state I i ), out( state R i )] ∼ = O P,Q i≤N -1 KE i [out( state I i ), out( state R i )] KE N [ if x I lsid = lsid R N then out( k, lsid I N , x I lsid ) else if x I lsid / ∈ {lsid R i } 1≤i≤N -1 then ⊥, else out( state I i ), if x R lsid = lsid I N then out( k, lsid R N , x R lsid ) else if x R lsid / ∈ {lsid I i } 1≤i≤N -1 then ⊥, else out( state R i )]<label>(1)</label></formula><p>The previous equivalence expresses that when we look at N sessions that all output their full state upon completion, the particular matching of the parties in KE N has a key that is real or random if they are indeed partnered together, and if they are not partnered together, they must be talking to another agent from the other KE i . We may see the other sessions as corrupted sessions, as they leak their states upon completion.</p><p>We further reduce the problem to proving the security of a single session even when there is an oracle simulating corrupted sessions. To this end, we need to reveal the dishonest local session's identifiers to the attacker, but also to allow him to perform the required cryptographic operations, e.g. signatures using the identities.</p><p>We define, for X ∈ {I, R}, s X as the set of copies of the local session identifiers of I or R, except a distinguished one (indexed 0 below) and s = s I ∪ s R . To obtain the security of multiple sessions of the key exchange, we use Proposition 17. <ref type="foot" target="#foot_5">5</ref> . To this end, we would need to design an oracle O r , such that the following assumptions are satisfied, where O P,Q corresponds to O of Proposition 17:</p><formula xml:id="formula_129">K-1) ∀1 ≤ i ≤ N, νlsid I i , id I , lsid R i , id R . KE i [out(x I ), out(x R )] out( lsid R i , lsid I i ) is O r simulatable. K-2) KE 0 [ out( x I , lsid I 0 , x I lsid ), out( x R , lsid R 0 , x R lsid )] ∼ = Or,O P,Q KE 0 [ if x I lsid = lsid R 0 then out( k, lsid I 0 , x I lsid ) else if x I lsid / ∈ s R then ⊥ else out( x I , lsid I 0 , x I lsid ), if x R lsid = lsid I 0 then out( k, lsid R 0 , x R lsid ) else if x R lsid / ∈ s I then ⊥ else out( x R , lsid R 0 , x R lsid )] K-3) s is disjoint of the support of O P,Q .</formula><p>Intuitively, if the initiator believes to be talking to the honest responder, then it outputs the ideal key, and if it is not talking to any simulated corrupted party, it raises a bad event.</p><p>Note that while the structure of the proof does not fundamentally change from other proofs of key exchanges, e.g. <ref type="bibr" target="#b17">[18]</ref>, each step of the proof becomes straightforward thanks to our composition results. Our proofs are also more flexible, as shown by the extension to key exchanges with key confirmation in Section 8. We outline here the application of our framework to the ISO 9798-3 protocol, a variant of the Diffie-Hellman key exchange. It is proven UC composable in <ref type="bibr" target="#b12">[13]</ref>. We use our result to extend the security proof to a context with shared long term secrets (which was not the case in the UC proof). We present the protocol in Figure <ref type="figure" target="#fig_4">4</ref>, and show how to instantiate the required values and oracles to perform the proof presented in Section 6.2. The formal proofs (using the CCSA model <ref type="bibr" target="#b10">[11]</ref>) are provided in Appendix C. Our decomposition and subsequent proofs show that the DDH key exchange can be used to securely derive a secret key for any protocol that does not rely on the long term secret used in the key exchange. Our proof is also modular, in the sense that it could be adapted to provide also the security when the continuation protocol uses the long term shared secret as well.</p><formula xml:id="formula_130">Initiator sk I , a i Receiver sk R , b i pk(sk I ), g a i pk(sk R ), g b i , sign((g a i , g b i , pk(sk I )), sk R ) sign((g b i , g a i , pk(sk R )), sk I )</formula><p>A high level view of the protocol is given in Figure <ref type="figure" target="#fig_4">4</ref>, and it is formally expressed in our algebra in Figure <ref type="figure" target="#fig_5">5</ref>, where _I and _R denote the possible continuations at the end of each party. We use pattern matching in the inputs to simplify the notations, where for instance in(c, m, x ) with m some constant only accepts inputs whose first projection is m, and then bind the variable x to the second projection. If the inputs are not of the given form, the protocols goes to an error branch.</p><p>Our goal is to apply the decomposition of Section 6.2, for some abstract continuations P and Q that are supposed to used the derived key. We need to find suitable identities and local session identifiers so that the Conditions from the decomposition of Section 6.2 are fulfilled. As we do not specify P and Q, we only discuss the conditions relative to the security of the key exchange, e.g., K-1,K-2 and K-3. Remark that those conditions are sufficient to derive a notion similar to the classical security of a key exchange, as for any P and Q that do not share long term shared secrets with the key exchange. The other conditions are trivial to derive or only rely on the security of the continuation when using an ideal key.</p><p>The identity of each party is its long term secret key, and thus, we use sk I and sk R as id I and id R . Each session of the key exchange instantiates a fresh Diffie-Hellman share, that can be seen as a local session identifier. We thus use g a i and g b i as lsid I i and lsid R i . These values can also be used as implicit tagging since any signed message either depends on a i or b i .</p><p>With those choices, we need to find a tagging function T that will provide a tagged oracle O T such that the Conditions K of Section 6.2 are satisfied. Those Conditions, reformulated with the current notations and with O T standing for O r , are expressed as follow:</p><formula xml:id="formula_131">K-1) ∀1 ≤ i ≤ N, νa i , sk I , b i , sk R . I i [out(k I )] R i [out(k R )] out( g a i , g b i ) is O T -simulatable.</formula><p>i (</p><formula xml:id="formula_132">I i := out( pk(sk I ), g a i ) in( x pk , x B , x m ).</formula><p>if verify(x m , x pk ) = g a i , x B , pk(sk I ) then out(sign( x B , g a i , x pk , sk I )) </p><formula xml:id="formula_133">let k I = x a i B in _ I R i := in( x pk , x A ). out( pk(sk R ), g b i , sign( x A , g b i , x pk , sk R ) ) in(x m ). if verify(x m , x pk ) = g b i , x A , pk(sk R ) then let k R = x b i A in _ R )</formula><formula xml:id="formula_134">I 0 [out( k I , g a 0 , x B )] R 0 [out( k R , g b 0 , x A )] ∼ = O T ,O P,Q I 0   if x B = g b 0 then out( x a 0 B , g a 0 , x B ) else if x B / ∈ {g b i } i≥1 then ⊥ else out( k I , g a 0 , x B )   R 0   if x A = g a 0 then out( x b 0 A , g b 0 , x A ) else if x A / ∈ {g a i } i≥1 then ⊥ else out( k R , g a 0 , x B )   K-3) {g a i , g b i } i≥1 is disjoint of the support of O P,Q .</formula><p>K-2 either corresponds to a matching conversation (i.e., all messages received by one were sent by the other) between the sessions with sids g a 0 , g b 0 , in which case the output is (twice) an ideal key k, or else it is a matching conversation with a simulated session, in which case it outputs the computed keys. It is neither of those cases, it should not happen, and we raise a bad event (denoted ⊥). The proof of the K-2 is thus a real-or-random proof of a honestly produced key. We do not provide the proof of K-2 in this section, it is provided in Appendix C.</p><p>We must define an implicit tagging that allows to both have the simulatability and the indistinguishability. Remark that first, we extend the tagging function T of Definition 14 so that it may depend on a second argument of arbitrary length, yielding T (m, s), the corresponding signing oracle being denoted O sign T,sk,s . This is required so that the implicit tagging may depend on all the possible local session identifiers. The exact definition of this extension is given in Section 12.</p><p>We define the implicit tagging functions T I and T R as</p><formula xml:id="formula_135">T I (m, {g a i , g b i } i≥1 ) := ∃s ∈ {a i } i≥1 , ∃m 1 , m 2 .m = (m 1 , g s , m 2 ) T R (m, {g a i , g b i } i≥1 ) := ∃s ∈ {b i } i≥1 , ∃m 1 , m 2 .m = (m 1 , g s , m 2 )</formula><p>This tagging function will suit our needs, as all messages signed by the two parties follow this pattern. Moreover, in the protocol, the value sent in the first message should match g a i in the last message. Therefore, when the protocol of Figure <ref type="figure" target="#fig_4">4</ref> is successfully completed, we can prove that if x B = g b 0 , then x B ∈ {g b i |i ≥ 1}, i.e., T R (x B , {g a i , g b i } i≥1 ) is true (and similarly for R).</p><p>Let s = {g a i , g b i } i≥1 , we finally define</p><formula xml:id="formula_136">O T = O sign T I ,sk I ,s , O sign T R ,sk R ,s , O s ,</formula><p>where O s simply reveals the elements in s, we do obtain the simulatability of multiple sessions of the key exchange (Hypothesis 1).</p><p>To adapt this proof to a concrete example, the security proof of K-2 would be performed under an oracle O P,Q that allows to simulate the continuation (Condition P-1 of Section 6.2). The continuation should then be proven secure when using an ideal key (Conditions P of Section 6.2). In some cases, this step is trivial. Indeed, let us consider a record protocol L := L I (x I ) L R (x R ), that exchanges encrypted messages using the exchanged key, and does not share any long term secret, i.e., does not use the signing keys of the key exchange. Without any shared secret, we do not need any oracle to simulate in(k); L I (k) in(k); L R (k), so we can choose a trivial O P,Q that does nothing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Extension to Key Confirmations</head><p>We present how our compositional framework can be used to prove the security of a key exchange, in which the key is derived in a first part of the protocol and then used (key confirmation) in the second part. Compared to <ref type="bibr" target="#b7">[8]</ref>, our method allows in addition sharing of long term secrets.</p><p>Consider a key exchange I(lsid I i , id I ) R(lsid R i , id R ). We further split I and R into I i := I 0 i (lsid I i , id I ); I 1 i (x I ) and R i := R 0 i (lsid R i , id r ); R 1 i (x R ), where I 0 i and R 0 i correspond to the key exchange up to, but not including, the first use of the secret key (x I or x R ), and I 1 i and R 1 i are the remaining parts of the protocol. The intuition behind the proof of security is that at the end of I 0 i and R 0 i , i.e. just before the key confirmation, either the sessions are partnered together and the derived key satisfies the real-or-random, or they are not, which means that the key confirmation performed by I 1 i and R 1 i will fail. We denote</p><formula xml:id="formula_137">KE i [_ 1 , _ 2 ] := I 0 i (lsid I i , id I ); I 1 i (x I ); _ 1 R 0 i (lsid R i , id R ); R 1 i (x R ); _ 2 and KE 0 i [_ 1 , _ 2 ] := I 0 i (lsid I i , id I ); _ 1 |R 0 i (lsid R j , id R ); _ 2</formula><p>We proceed as in Section 6, outlining how we may split the security proof into smaller proofs using our framework, using the same composition Theorems at each step. We thus provide the necessary Conditions S-1,S-2,P-1,K-1,K-2,K-3 so that, for some continuation</p><formula xml:id="formula_138">P I i (x I ) P R i (x R ) and its idealized version Q, i KE i [P I i (x I ), P R i (x R )] ∼ = i KE i [Q I i (x I ), Q R i (x R )]</formula><p>A formal Corollary can be found in Appendix F.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Proofs with Key Confirmations</head><p>Key exchange and protocol simulatability We modify slightly the conditions S-1 and S-2 of Section 6.2 to reflect the fact that we now consider the key confirmation to be part of the continuation: S-1) νp.in(x).I 1 (x); P I (x), in(x).R 1 (x); P R (x), in(x).I 1 (x);</p><formula xml:id="formula_139">Q I (x), in(x).R 1 (x); Q R (x) are O P,Q simulatable. S-2) νp. i≤N I 0 i (lsid I i , id I ); if 1≤i≤N x I lsid = lsid R j then out( i, j ) else I 1 i (x I ); ⊥ i≤N R 0 i (lsid R i , id R ); if 1≤i≤N x R lsid = lsid I j then out( i, j ) else R 1 i (x R ); ⊥ is O ke -simulatable.</formula><p>Security of the protocol Compared to Section 6.2, the continuation must be secure even in the presence of the messages produced during the key confirmation:</p><formula xml:id="formula_140">P-1) i≤N I 1 i (x I ); P I i (x I ) R 1 i (x R ); P R i (x R ) ∼ = Or,O k i≤N I 1 i (x I ); Q I i (x I ) R 1 i (x R ); Q R i (x R )</formula><p>We could once again split this goal into a single session proof using Theorem 5. We remark that to prove the security of the single session, we can further reduce the proof by using an oracle that may simulate I 1 and R 1 , as the security of P should not depend on the messages of the key confirmation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Security of the key exchange</head><p>We proceed in a similar way as in Section 6.2 and we use the same notations. The following Conditions are then suitable:</p><formula xml:id="formula_141">K-1) ∀i ≤ N, νlsid I i , id I , lsid R i , id R . KE 0 i [out(x I ), out(x R )] out( lsid R i , lsid I i ) is O T -simulatable K-2) s is disjoint of the support of O P,Q . K-3) KE 0 0 [if x I lsid / ∈ s R then I 1 0 (x I ) else out( x I , lsid I 0 , x I lsid ), if x R lsid / ∈ s I then R 1 0 (x R ) else out( x R , lsid R 0 , x R lsid )] ∼ = O KE ,O P,Q KE 0 0 [if x I lsid = lsid R 0 then out( k, lsid I 0 , x I lsid ) else if x I lsid / ∈ s R then I 1 0 (x I ); out(⊥) else out( x I , lsid I 0 , x I lsid ), if x R lsid = lsid I 0 then out( k, lsid R 0 , x R lsid ) else if x R lsid / ∈ s I then R 1 0 (x R ); out(⊥) else out( x R , lsid R 0 , x R lsid )]</formula><p>The indistinguishability expresses that, if the two singled out parties are partnered, i.e., x I lsid = lsid R 0 or x R lsid = lsid I 0 , then we test the real-or-random of the key. Else, it specifies that a party must always be partnered with some honest session, i.e., that x X lsid / ∈ s Y will never occur. To this end, on one side, when x X lsid / ∈ s Y we run the key confirmation, and on the other side we run the key confirmation followed in case of success by a bad event. Finally, when two honest parties are partnered, but are not the singled out parties, they leak their states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Application to SSH</head><p>SSH <ref type="bibr" target="#b11">[12]</ref> is a protocol that allows users to login onto a server from a remote platform. It is widely used in the version where signatures are used for authentication. An interesting feature Platform sk P , a i Server 1 sk S , b i , c i Server 2 sk T , d i g ai let sid = hash( g ai , g bi , g aibi ) let k=g aibi g bi , pk(sk S ), sign(sid, sk S ) enc(sign(sid, sk P ), k)</p><p>Successful login of the user on Server 1</p><formula xml:id="formula_142">g ci let sid 2 = hash( g ci , g di , g cidi ) let k 2 = g cidi g di , pk(sk T ), sign(sid 2 , sk T ) enc(sid 2 , k)</formula><p>enc(sign( sid 2 , "f orwarded" , sk P ), k) enc(sign( sid 2 , "f orwarded" , sk P ), k 2 ) Figure <ref type="figure">6</ref>: SSH with Forwarding Agent is forwarding agent: once a user u is logged on a server S, they may, from S, perform another login on another server T . As S does not have access to the signing key of u, it forwards a signature request to u's platform using the secure SSH channel between u and S. This represents a challenge for compositional proofs: we compose a first key exchange with another one, the second one using a signature key already used in the first.</p><p>We provide the decomposition of the security proof of SSH composed with one (modified) forwarding agent. We use multiple times in sequence our composition Theorems, that allow us to further simplify the required indistinguishability proofs. The corresponding indistinguishability proofs are performed in Appendix D and Appendix E.</p><p>There is a known weakness in this protocol: any privileged user on S can use the agents of any other user as a signing oracle. Thus, in order to be able to prove the security of the protocol, we only consider the case where there is no such privileged user. Figure <ref type="figure">6</ref> presents an example of a login followed by a login using the forwarding agent. For simplicity, we abstract away some messages that are not relevant to the security of the protocol.</p><p>In the current specification of the forwarding agent, it is impossible for a server to know if the received signature was completed locally by the user's platform, or remotely through the forwarding agent. As the two behaviors are different in term of trust assumptions, we claim that they should be distinguishable by a server. For instance, a server should be able to reject signatures performed by a forwarded agent, because intermediate servers are not trusted. To this end, we assume that the signatures performed by the agent are (possibly implicitly) tagged in a way that distinguishes between their use in different parts of the protocol. This assumption also allows for domain separation between the two key exchanges, and thus simplifies the proof.</p><p>We consider a scenario in which there is an unbounded number of sessions of SSH, each with one (modified) forwarding agent, used to provide a secure channel for a protocol P . Thanks to multiple applications of Theorems 2 and 4, we are able to break the proof of this SSH scenario into small ones, that are very close to the proof of a simple Diffie-Hellman key exchange. This assumes the decisional Diffie-Hellman (DDH) hypothesis for the group, EUF-CMA for the</p><formula xml:id="formula_143">P i := out(g a i ); in( x B , pk(sk S ), sign ) let k = x a i B in let sid = hash( g a i , x B , k ) in if verify(sign, pk(sk S )) = sid then out(enc(sign(sid, skP ), k)); _ P . S i := in(x A ); let k = x b i A in let sid = hash( x A , g b i , k ) in out( g b i , pk(sk S ), sign(sid, sk S ) ) in(enc(x sign , k)) if verify(x sign , pk(skP )) = sid then _ S . SSH := i (P i [0] S i [0])</formula><p>Figure <ref type="figure">7</ref>: Basic SSH Key Exchange signature scheme and that the encryption must ensure integrity of the cyphertexts (this last assumption is only required for the forwarded key exchange, where a signature is performed over an encrypted channel). P also has to satisfy the conditions of Section 8.1. In particular, it must be secure w.r.t. an attacker that has access to a hash that includes the exchanged secret key, since SSH produces such a hash. Note that the scenario includes multiple sessions, but only one forwarding. The extension would require an induction to prove in our framework the security for any number of chained forwardings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">The SSH Protocol</head><p>The basic SSH key exchange is presented in Figure <ref type="figure">7</ref>, with possible continuations at the end denoted by _P and _S. In this Section, we use a strong notion of pattern matching, where for instance in(enc(x sign , k)) is a syntactic sugar for in(x); let x sign = dec(x, k) in _.</p><p>As it is always the case for key exchanges that contain a key confirmation, the indistinguishability of the derived key is not preserved through the protocol. The difficulty of SSH is moreover that once a user has established a secure connection to a server, they can from this server establish a secure connection to another server, while using the secure channel previously established to obtain the user credentials. We provide in Figure <ref type="figure" target="#fig_6">8</ref> a model of the SSH with forwarding of agent (reusing the definitions of P and S from Figure <ref type="figure">7</ref>). After a session of P terminates successfully, a F orwardAgent is started on the computer. It can receive on the secret channel a signing request and perform the signature of it. In parallel, after the completion of a session of S, a distant session of P that runs on the same machine as S can be initiated by P Distant. It will request on the previously established secret channel the signature of the corresponding sid. Finally, as the forwarding can be chained multiple time, at the end of a successful P Distant, a F orwardServer is set up. It accepts to receive a signing request on the new secret channel of P Distant, forwards the request on the old secret channel, gets the signature and finally forwards it.</p><p>The forwarding agent implies a difficult composition problem: we sequentially compose a basic SSH exchange with a second one that uses the derived key and the same long term secret keys. Thus, to be able to prove the security of SSH with forwarding agent, we must be able to handle key confirmations and composition with shared long term secrets.</p><formula xml:id="formula_144">P Distant i (oldk) := out(g a i ); in( x B , pk(sk S ), sign ) let k = x a i B in let sid = hash( g a i , x B , kP ) in if verify(sign, pk(sk S )) = sid then out(enc(sid, oldk)) in(enc(sign, oldk)) out(enc(sign, k)) _ P D .</formula><p>F orwardAgent(k) := in(enc(sid, k)) out(enc(sign( sid, "fwd " , skP ), k)) </p><formula xml:id="formula_145">SF orward i := in(x A ); let k = x b i A in let sid = hash( x A , g b i , k ) in out( g b i , pk(sk S ), sign(sid, sk S ) ) in(enc(sign, k)) if verify(sign, pk(skP )) = sid, "fwd " then _ SF SSH F orward := i (P i [F orwardAgent(k)] SF orward i S i [P Distant i (k)])</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Security of SSH</head><p>We show how to prove the Conditions of Section 8 to the basic SSH protocol (without forwarding agent). We provide in Figure <ref type="figure">9</ref> the decomposition for key exchanges with key confirmation corresponding to the SSH protocol. We directly specify that P and S may only relate to each other by hard-coding the expected public keys in them. This is the classical behaviour of SSH where a user wants to login on a specific server, and the public key of the user was registered previously on the server. For some abstract continuation R P (x) R S (x) and its idealized version Q P (x) Q S (x), our goal would be to prove that</p><formula xml:id="formula_146">P 0 i := out(g a i ); in(x B ) let k = x a i B in 0. P 1 i (x B , k) := in( pk(sk S ), sign ) let sid = hash( g a , x B , k</formula><p>) in if verify(sign, pk(sk S )) = sid then out(enc(sign(sid, sk P ), k)) _P.</p><formula xml:id="formula_147">S 0 i := in(x A ); let k = x b i A in let sid = hash( x A , g b i , k ) in out(g b i ) S 1 i (sid, k) := out( pk(sk S ), g b i , sign(sid, sk S ) ) in(enc(sign, k))</formula><p>if verify(sign, pk(sk P )) = sid then _S.</p><p>Figure <ref type="figure">9</ref>: Divided SSH Key Exchange</p><formula xml:id="formula_148">P 0 i ; P 1 i (x B , k)[R P (k)] S 0 i ; S 1 i (sid, k)[R S (k)] ∼ = P 0 i ; P 1 i (x B , k)[Q P (k)] S 0 i ; S 1 i (sid, k)[Q S (k)]</formula><p>Without specifying the continuation, a first step toward the security of the basic SSH key exchange is to obtain Conditions K-1 and K-3 of Section 8. Recall that if a key exchange satisfies those Conditions, it can be seen as a secure key exchange in the classical sense as it can be composed with any continuation that do not share any long term secrets. The proofs only need to ne adapted when it is not the case.</p><p>The behaviour of the protocol is very similar to the signed DDH key exchange (Figure <ref type="figure" target="#fig_4">4</ref>) previously studied. We can once again see the DH shares {a i , b i } i∈N as local session identifiers that can be used to pair sessions. For each session and each party, the messages signed by this party always depend strongly on the DH share. We can thus make all SSH sessions simulatable with the following tagging functions and corresponding signing oracles.</p><formula xml:id="formula_149">T P (m, s) := ∃s ∈ {a i } i∈N , ∃m 1 , m = hash(g s , m 1 , m s 1 ) T S (m, s) := ∃s ∈ {b i } i∈N , ∃m 1 , m = hash(m 1 , g s , m s 1 )</formula><p>We have that the set of axioms Ax = EUF-CMA T P ,sk P ,s ∧EUF-CMA T S ,sk S ,s is O sign T P ,sk P ,s , O sign T S ,sk Q ,s , O a i ,b i sound thanks to Proposition 27. We use those axioms to perform the proof of K-3, where the tagging essentially implies the authentication property. However, the proof must be slightly stronger, when we consider that the continuations P, Q are instantiated with a second round of SSH with a forwarding agent that uses the same long term secrets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">SSH with Forwarding Agent</head><p>For concision, we write F A for F orwardAgent, SF for SF orward, and P D for P Distant. Let us consider an abstract continuation protocol, satisfying a security property of the form</p><formula xml:id="formula_150">R P (k) R S (k) ∼ = Q P (k) Q S (k)</formula><p>where k denotes a fresh name modelling an ideal key produced by a key exchange.</p><p>We once again assume that the agents are only willing to communicate with the honest identities, i.e., pk(sk S ) and pk(sk P ) are predefined in the processes. The goal is to prove the following equivalence.</p><p>i</p><formula xml:id="formula_151">(P i [F A(k)] S i [P D(k); R P (k P D )] SF [R S (k SF )]) ∼ = i (P i [F A(k)] S i [P D(k); Q P (k P D )] SF [Q S (k SF )])</formula><p>It corresponds to the fact that we should have R P (k) R S (k) ∼ = Q P (k) Q S (k), even if the ideal key k is replaced for each party by a key derived by a SSH key exchange (P D and SF ) using an forwarding agent (F A) based on a previous SSH key exchange (P and S).</p><p>We apply twice the decomposition of Section 8, once to show the security of the first key exchange (as done in the previous paragraph), and that we can thus prove the security of the second key exchange using an ideal key derived instead of the one derive by the first exchange. The second application is then used to prove the security of this second key exchange.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>First application</head><p>The first application is performed with the following Conditions (corresponding to the one of Section 8), which allow to derive the desired conclusion. K-3):</p><formula xml:id="formula_152">P 0 0 ; if x B / ∈ s then P 1 0 (x B , k); out(k) else out(k, g a 0 , x B ) S 0 0 ; if x A / ∈ s then S 1 i (x A , k); out(k) else out(k, g b 0 , x A ) ∼ = O P S ,O f orward P 0 0 ; if x B = g b 0 then out(k, g a 0 , x B ) else if x B / ∈ s then P 1 (x B , k); bad else out(k, g b 0 , x A ) S 0 0 ; if x A = g a 0 then out(k, g b 0 , x A ) else if x B / ∈ s then S 1 0 (x A , k); bad else out(k, g b 0 , x A ) P-1): i P 1 i (k)[F A(k)] S 1 i (k)[P D(k); R P ] SF [R S ] ∼ = O KE 1 i P 1 i (k)[F A(k)] S 1 i (k)[P D(k); Q P ] SF [Q S ]</formula><p>We use the following oracles:</p><p>• O P S allows to simulate (K-1) the other honest sessions of P and S, it corresponds to O sign T P ,F,sk S ,s , O sign T S ,F,sk P ,s , O a i ,b i of Section 9.2. • O forward allows to simulate (S-1) the continuation, i.e., protocols of the form in(k);</p><formula xml:id="formula_153">P 1 (k)[F A(k)] in(k); S 1 (k)[P D(k); R P ] SF [R Q ]</formula><p>• O KE 1 allows to simulate (S-2) i (P i S i ) (it is identical to O P S ).</p><p>All simulations are performed under νsk S , sk P . To define O forward , we need to settle an issue. Indeed, for hypothesis S-1, we need to provide an oracle that can simulate sessions of the forwarding protocols. However, in order to get the simulatability of in(k).F A(sk P , k), one must give a generic signing oracles to the attacker, which would obviously make the protocol insecure. Based on the assumption that the forwarded sessions perform signatures tagged with "fwd (as shown below), we can however provide a signing oracle for such messages only. It allows for the simulatability of the forwarding agent and of the forwarded client and server. More specifically, recall the the forwarding agent is of the form:</p><formula xml:id="formula_154">F A(sk P , k) := in(enc(sid, k)); out(enc(sign( sid, "fwd " , sk P ), k))</formula><p>We may obtain its simulatability with the following tagging function:</p><formula xml:id="formula_155">T for (m, s) := ∃m 1 . m = m 1 , "fwd "</formula><p>Then, O forward is simply O sign T for ,F,sk P ,s , O sign T for ,F,sk S ,s , O a i ,b i . We prove Condition K-3 under the corresponding EUF-CMA axioms in Appendix E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Second application</head><p>We further simplify Condition P-1 of the previous paragraph with a second application of the decomposition of Section 8. We now denote s = {a i , b i } i∈N . P D i and SF i are split into P D 0 i , P D 1 i and SF 0 i , SF 1 i similarly to the split of Figure <ref type="figure">9</ref> before and after the key confirmation. The tagging functions used are only slight variations of the tagging functions for the first SSH key exchange:</p><formula xml:id="formula_156">T P (m, s ) := ∃i, ∃X, m = hash(g a i , X, X a i ), "fwd " T S (m, s ) := ∃i, ∃X, m = hash(X, g b i , X b i ), "fwd "</formula><p>We then need to prove the Conditions: K-3):</p><formula xml:id="formula_157">P 1 0 (k); F A(k) S 1 0 (k); P D 0 0 (k); if x B / ∈ s then P D 1 0 (x B , k); out(k) else out(k, g a 0 , x B ) SF 0 0 ; if x A / ∈ s then SF 1 0 (x A , k); out(k) else out(k, g b 0 , x A ) ∼ = O KE 1 ,O k F P S ,O RQ P 1 0 (k); F A(k) S 1 0 (k); P D 0 0 ; if x B = g b 0 then out(k, g a 0 , x B ) else if x B / ∈ s then P D 1 0 (x B , k); bad else out(k, g b 0 , x A ) SF 0 0 ; if x A = g a 0 then out(k, g b 0 , x A ) else if x B / ∈ s then SF 1 0 (x A , k); bad else out(k, g b 0 , x A )</formula><p>Note that k is a fresh name that could be considered as a long term secret, i.e., in p.</p><p>And P-1):</p><formula xml:id="formula_158">i P D 1 i (k ); R P (k ) SF 1 0 (k ); R S (k ) ∼ = O KE 1 ,O F P S i P D 1 i (k ); Q P (k ) SF 1 i (k ); Q S (k )</formula><p>With the oracles:</p><p>• O k F P S allows to simulate (K-1) the other honest sessions of P D and SF , it corresponds to O sign T P ,sk S ,s , O sign T S ,sk P ,s , O a i ,b i of Section 9.2.</p><p>• O RQ allows to simulate (S-1) the continuation, i.e., protocols of the form</p><formula xml:id="formula_159">in(k); P D 1 (k); R P (k) in(k); SF 1 (k); R Q (k)</formula><p>We prove Condition K-3 under the corresponding EUF-CMA axioms in Appendix E. Remark that to ensure that the forwarding agent only signs the sid sent by P D, it is required that the encryption scheme is an authenticated encryption scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Part III</head><p>Composition in the CCSA logic 10 Oracles in the CCSA Logic</p><p>We extend the semantics of the CCSA logic so that it now refers to attackers that can have access to an extra oracle O. We then lift the notion of soundness for the axioms to support oracles, defining the notion of O-soundness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">Syntax and Semantics</head><p>While the cryptographic library of the CCSA logic stays as is, the computational model must now also depend on some oracle that is given to the attacker, and the corresponding random oracle tape. Definition 19. A computational model M is an extension of a cryptographic library M f , which provides an oracle O, and an additional PTOM A O g for each symbol g ∈ G, that takes as input an infinite random tape ρ r , a security parameter 1 η and a sequence of bitstrings.</p><p>We define the interpretation of extended terms as, given M, η, σ, ρ s , ρ O and ρ r :</p><p>•</p><formula xml:id="formula_160">[[n]] η,σ M,ρs,ρr,ρ O := A n (1 η , ρ s ) if n ∈ N • [[x]] η,σ M,ρs,ρr,ρ O = [[xσ]] η,σ M,ρs,ρr,ρ O if x ∈ X • [[f (u)]] η,σ M,ρs,ρr,ρ O = A f (1 η , [[u]] η,σ M,ρs,ρr,ρ O ) if f ∈ Σ • [[g(u)]] η,σ M,ρs,ρr,ρ O = A O(ρs,ρ O ) g ([[u]] η,σ M,ρs,ρr,ρ O , ρ r , 1 η ) if g ∈ G</formula><p>We also adapt the definition of the interpretation of ∼. Definition 20. Given a computational model M, including an oracle O, two sequences of terms t, u, and an assignment σ of the free variables of t, u to ground terms, we have M, σ |= O t ∼ u if, for every polynomial time oracle Turing machine A O ,</p><formula xml:id="formula_161">|P ρs,ρr,ρ O {A O(ρs,ρ O ) ([[t]] σ,η ρs;ρr;ρ O , ρ r , 1 η ) = 1} -P ρs,ρr,ρ O {A O(ρs,ρ O ) ([[u]] σ,η ρs;ρr;ρ O , ρ r , 1 η ) = 1}|</formula><p>is negligible in η. Here, ρ s , ρ r , ρ O are drawn according to a distribution such that every finite prefix is uniformly sampled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Oracle Soundness</head><p>To perform proofs in the logic, we need to design axioms that are sound w.r.t. an attacker that has access to O; we say that the axiom is O-sound in this case. They should be easy to verify for actual libraries, yet powerful enough for the proofs that we intend to complete. The purpose of this Section is to provide such axioms. We first extend the notion of soundness to oracles. </p><formula xml:id="formula_162">enc(0, r, k) ∼ enc(1, r, k) is • not sound (nor O-sound) in general,</formula><p>• sound but not O-sound for non randomized SPRP encryption,</p><p>• O-sound for IND-CPA encryption.</p><p>Note that the axioms that are designed in <ref type="bibr" target="#b10">[11]</ref> cannot be borrowed directly. For instance, n ∼ n , where n, n are names, is a standard axiom: two randomly generated numbers of the same length cannot be distinguished. However, if either n or n is in the support of O, some information on their interpretation can be leaked by the oracle. The axiom n ∼ n is sound, but not O-sound. We have to modify this axioms as follows:</p><p>Lemma 22. For any oracle O with support n, the axiom ∀k, k / ∈ n, k ∼ k is O-sound.</p><p>Proof. We are given a cryptographic library, and oracle O with support n, and two names k, k not in the support. We are also given A O which is a distinguisher over k ∼ k . We define a PTTM A which on input (m, ρ r , 1 η ):</p><p>• Splits ρ r into three distinct infinite tapes ρ so , ρ ra , ρ ro .</p><p>• Simulates A O(ρso,ρro) (m, ρ ra , 1 η ).</p><p>Let us a prove that A is a distinguisher over k ∼ k , which contradicts the unconditional soundness of this axiom when there is no oracle. We denote by π k (ρ s , η) the tapes where every bit of ρ s which does not correspond to a name of k is set to 0, and similarly π k c (ρ s , η) where all bits for k are set to 0. We then have for any PTOM A O :</p><formula xml:id="formula_163">P ρs,ρr,ρ O {A O(ρs,ρ O ) ([[k]] σ,η ρs , ρ r , 1 η ) = 1} = 1 P ρs,ρr,ρ O {A O(π k (ρs,η),ρ O ) ([[n]] σ,η π k c (ρs,η) , ρ r , 1 η ) = 1} = 2 P ρ s1 ,ρ s2 ,ρr,ρ O {A O(ρ s1 ,ρ O ) ([[n]] σ,η ρ s2 , ρ r , 1 η ) = 1} = 3 P ρso,ρs,ρra,ρro {A O(ρso,ρro) ([[k]] σ,η ρs , ρ ra , 1 η ) = 1} = 4 P ρs,ρr {A ([[k]] σ,η ρs , ρ r , 1 η ) = 1}</formula><p>1. Thanks to the definition of support, the oracle answers the same on π k (ρ s , η) and ρ s ;</p><p>2. we split ρ s in two, to replace independent tapes π k (ρ s , η) and π k c (ρ s , η);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">we rename random tapes;</head><p>4. by construction of A .</p><p>This shows that A has the same advantage as A O against k ∼ k , which concludes the proof.</p><p>Other axioms in <ref type="bibr" target="#b10">[11]</ref> can be extended without problem. For instance the transitivity of ∼ or the function application axiom:</p><formula xml:id="formula_164">Lemma 23. For any O, f ∈ F, terms t 1 , . . . , t n , u 1 , . . . , u n t 1 , . . . , t n ∼ u 1 , . . . , u n =⇒ f (t 1 , . . . , t n ) ∼ f (u 1 , . . . , u n ) is O sound.</formula><p>In general, what we have is that any axiom independent from the oracle support is sound.</p><p>Lemma 24. For any O, and terms t, s, such that all names in t, s do not appear in supp(O), we have that t ∼ s is sound if and only if t ∼ s is O-sound. This allows us to derive, given an oracle and a recursive set of axiom, the set of axioms which is sound w.r.t. an oracle.</p><p>For instance, the general DDH axiom is, for any names a, b, c, g a , g b , g ab ∼ g a , g b , g c . If we denote by s the support of some oracle, the O-sound DDH version is simply the set of formulas DDH s for all name a, b, c / ∈ s, g a , g b , g ab ∼ g a , g b , g c . Here, the notation g x corresponds to g(n) r(x) , where g is the function which extracts a group generator and r the function which evaluates names into exponents. We may consider that we have two interpretations of those function such that DDH holds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EUF-CMA</head><p>We define a CCSA version of the tagged EUF-CMA axiom. It is a direct adaptation of the CCSA EUF-CMA axiom to match the behaviour of the tagged EUF-CMA axiom (Figure <ref type="figure" target="#fig_1">3</ref>). Definition 25. Given a name sk and a function symbol T , we define the generic axiom scheme EUF-CMA T,sk as, for any term t such that sk is only in key position:</p><formula xml:id="formula_165">if ( checksign(t, pk(sk)))</formula><p>then T ( getmess(t))</p><p>. sign(x,sk)∈St(t) (t .</p><p>= sign(x, sk)) else</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>∼</head><p>The tagged signing oracles is defined as previously, only adding the extra argument to the tagging function. Proof. Let us assume that soundness is violated. We then have a term t and a computational model such that t does not satisfy EUF-CMA T,sk . It means that the formula on the left hand side holds. As in t the secret key sk only occurs in key positions, we can simulate t by sampling all names, performing applications of function symbols, and sometimes calling the oracle O sign sk to obtain a signature. t may also depend on attacker function symbols that have access to an oracle O sign T,sk . Thus, we can build a PTOM A O sign T,sk ,O sign sk that produces exactly the same distribution of t for any fixed value of sk.</p><p>Let B O sign sk be the PTOM which:</p><p>• simulates A O sign T,sk , by sampling all names itself, except sk;</p><p>• for every call made by A to O sign T,sk with input m, B checks that T (M ) holds, and if it is the case query the signing oracle to get the signature, else fails.</p><p>The probability distribution of B O sign sk is exactly the same as A O sign T,sk ,O sign sk , so B O sign sk also produces an output o which violates the EUF-CMA T,sk axiom. We thus have that o is a valid signature, and is either not well tagged or does not correspond to a sub-term of t.</p><p>As all calls to O sign sk made by B either correspond to a well tagged message or to a sub term of t, we know that o does not correspond to a signature produced by the signing oracle. B O sign sk is thus an attacker which given access to a signing oracle can produce a signature for a message not signed by the oracle, i.e., an attacker which can win the EUF-CMA axiom.</p><p>11 Computational Soundness of the logic</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.1">Protocols</head><p>Given a protocol P , we reuse from <ref type="bibr" target="#b10">[11]</ref> the definition of Φ(fold(P )) which we will denote t P . It is only needed for technical proofs. We remark here that with the notations of <ref type="bibr" target="#b10">[11]</ref>, we would have ρ 1 = ρ s and ρ 2 = ρ r .</p><p>The correction of the term representing a protocol with respect to the protocol oracles is given by the following Lemma.</p><p>Lemma 28. Given a protocol P (which is action deterministic), a functional model M f , an oracle O, a security parameter η ∈ N, an history tape θ = ∅, t P = t 1 P , . . . , t n P , σ := {x 1 → d 1 , . . . , x n → d n } an assignment of the free variables in t P to D, for every ρ s , ρ r , ρ O ,</p><formula xml:id="formula_166">[[t 1 P ]] σ,η ρs,ρr,ρ O , . . . , [[t n P ]] σ,η ρs,ρr,ρ O = O P (ρ s , ∅)(d 1 (ρ s , ρ r , η, ρ O )), . . . , O P (ρ s , d 1 (ρ s , ρ r , η, ρ O ), . . . , d n-1 (ρ s , ρ r , η, ρ O ))(d n (ρ s , ρ r , η, ρ O ))</formula><p>Proof. While straightforward, the proof relies on the definitions of protocol execution in a model defined in <ref type="bibr" target="#b10">[11]</ref> and the soundness of the folding, which we do not recall here. We extend M f into a computational model M in such a way that</p><formula xml:id="formula_167">[[g i ]]([[t 1 P ]] σ,η ρs,ρr,ρ O , . . . , [[t i-1 P ]] σ,η ρs,ρr,ρ O , ρ r ) = d i (ρ s , ρ r , η, ρ O ) for i = 1, . . . , n. We then have [[t P ]] M = [[t 1 P ]] σ,η ρs,ρr,ρ O , . . . , [[t n P ]] σ,η ρs,ρr,ρ O .</formula><p>Theorem 6. Given P, Q two protocols, O an oracle, A a set of axioms ,M f a cryptographic library we assume that:</p><formula xml:id="formula_168">• A is O-sound w.r.t F = {M ⊃ M f } • A |= t P ∼ t Q Then P ∼ = O Q Proof.</formula><p>Let us assume that we have a distinguisher on A O,O P ?Q and that A is O-sound.</p><p>With Lemma 29 we have a computational model M ⊃ M f such that M |= O t P ∼ t Q . As A is O-sound, we also have M |= O A, and this contradicts the fact that the formulas are inconsistent.</p><p>We reduce computational indistinguishability to an inconsistency proof on the one hand and a soundness proof of the axioms on the other hand.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">Extension to the Model for Unbounded Replication</head><p>Recall that for unbounded replications, we used notations such as x / ∈ s, for infinite sequences of names s. While the previous extension is enough to handle our composition results, we need for our applications to key exchanges to be able to express formally those predicates. To this end, for any name n of arity l, we give a formal interpretation to n, that intuitively models the sequence of names n 1,...,1 , . . . , n r 1 ,...,r l of length polynomial in the security parameter.</p><p>We define the syntax and provide variations of the axioms that can be used to reason in this context. We then provide the concrete semantics so that these axioms are sound as technical details.</p><p>We provide a way to support infinite sequences in the CCSA logic, but note that our composition framework does not always require infinite sequences. When considering basic key exchanges, it is enough to use cofinite sequences. Basically, if the property</p><formula xml:id="formula_169">KE 0 [if x I lsid = lsid R 0 then out(k) else out(x I 0 ), if x R lsid = lsid I 0 then out(k) else out(x R 0 )]</formula><p>holds even when the attacker can simulate corrupted sessions, it is enough to derive the security of multiple sessions. It is interesting, as this property does not rely on infinite sequences.</p><p>To understand this, let us briefly consider a basic unsigned Diffie Hellman key exchange. It must of course not verify the previous property. The exchange shares are g a 0 , g b 0 . To break the previous property, we can give as a share to I the correct g b 0 , I will then produce depending on the side k or g a 0 b 0 . If we provide R with g a 0 × g a 0 , R does not believe to be paired with I and it then always output as key g 2a 0 b 0 . One can then easily distinguish if the output of R is the square of the output of I.</p><p>Basically, this stems from the fact that always outputting the actual key leaks information to the attacker when agents are not paired together.</p><p>For key exchanges with key confirmation, we wish to test the real or random before we have any authentication (as the authentication may come from the key confirmation). So if we always leak the key of the agent, the property will not be verified. However, we do need to leak the key to enable to go from one session to multiple sessions (to give the attacker enough information for the simulatability). The idea is then, as expressed in the previous Theorems, to only leak the key when two "honest" parties are paired together. Else, we execute the key confirmation, which should fail. Here, we have an explicit need to be able to test which sessions are honest, whether they are corrupted or not, and this for an unbounded number of sessions. Hence the need for a test based on infinite sequences.</p><p>Syntax Recall that names are defined with an arity, where a name n of index arity l can be indexed by l integers, yielding a distinct copy of the name for each indexes. Moreover, in a protocol, the index variables occurring in names must all be bound through a parallel or a sequential binder, and thus once we consider the term corresponding to the protocol in the CCSA logic, all names appear without index variables.</p><p>For any name n of index arity l, the syntax of terms in the CCSA logic only contained all the copies n k 1 ,...,k l for k 1 , . . . , k l ∈ N as symbols of arity 0 (a constants of the term algebra). For each name n, we add to the syntax of terms the symbol seq n of arity 0. We also provide a function symbol ∈ using infix notation, so that t ∈ seq n is now in the syntax.</p><p>Axioms The classical α-renaming axiom still holds, but all copies of a name are renamed at once. Thus, for any sequences of terms t, and any names n, n of index arity l such that n does not occur in t, we have:</p><formula xml:id="formula_170">(1) t ∼ t{seq n → seq n } ∪ {n k 1 ,...,k l → n k 1 ,...,k l | k 1 , . . . , k l ∈ N}</formula><p>Furthermore, we also provide axioms that allow to reason about the membership predicate, defined as:</p><p>(2) n k 1 ,...,k l ∈ seq n ∼ true for any name n and all k 1 , . . . , k l ∈ N;</p><p>(3) n k 1 ,...,k l ∈ seq n ∼ false for any name n distinct of n and all k 1 , . . . , k l ∈ N.</p><p>Remark that as ∈ is a boolean function symbol, it is in contradiction with its negation and we trivially have that that for any term t and name n,</p><formula xml:id="formula_171">t ∈ seq n ∧ t / ∈ seq n ∼ false</formula><p>This is actually what is used in our proofs of indistinguishability, as tagged oracles in our applications provide messages m such that we have f (m) ∈ seq n for some function f , and the security property raises bad if f (m) / ∈ seq n .</p><p>Semantics The idea is that seq n should model all sequences seq n = {n 1 , . . . , n p(η) } for any polynomial p. Then, if an indistinguishability holds for all such sequences for all polynomials, it also holds when the polynomial is bigger than the running time of the distinguisher, and the sequence then models an infinite sequence. To model this, the interpretation of a term t may now depend on some polynomial p with one indeterminate and with positive integer coefficients given to the PTTMs, and the interpretation is denoted [[t]] η,σ M,p,ρs,ρr,ρ O . The indistinguishability predicate ∼ is now interpreted as indistinguishability for all distinguishers and all polynomials p. Definition 20 now becomes: Definition 30. Given a computational model M, including an oracle O, two sequences of terms t, u, and an assignment σ of the free variables of t, u to ground terms, we have M, σ |= O Proof. We have a term t, a computational model and a polynomial p such that the interpretation of t where all sequences seq n are of length p(η) contradicts the EUF-CMA T,sk axiom.</p><p>The proof is exactly the same as Proposition 27, as we can once again from t build a Turing Machine that samples all names but sk (and may thus sample p(η) names for each sequence), and is then able to simulate all operations of t.</p><p>This means that we can safely consider a version of EUF-CMA T,sk where for instance T (x) is of the form x ∈ seq n and still have the soundness of the axiom. Remark that this proof would hold similarly for other cryptographic axioms.</p><p>We however have to prove the soundness of the axioms that are specific to seq.</p><p>Proposition 32. Axioms (1),( <ref type="formula" target="#formula_206">2</ref>) and ( <ref type="formula">3</ref>) are sound in all models where the interpretation of ∈ is given by the machine A ∈ (1 η , x 1 , x 2 ) that checks if x 1 is a bitstring of length η and returns true if and only if x 1 is a sub-string of x 2 starting at a position which is a multiple of η.</p><p>Proof.</p><p>1. The alpha-renaming axiom is sound, unconditionally. This is similar to the classical CCSA logic alpha-renaming axiom, which holds as all randomness for a given name (of any arity) are completely independent and uniform. Replacing all occurrences of a name by a another fresh one thus yields exactly the same distribution. In essence, we replace in the interpretation of t all occurrences of A n and A seq n by A n and A seq n .</p><p>As the machines for n did not occur previously in the interpretation of t, we indeed have that the machines of n and of n produce the same independent distribution for the interpretation of t.</p><p>2. Given n k 1 ,...,k l and seq n , we have for any polynomial p strictly increasing that for η large enough, k i ≤ p(η) for 1 ≤ i ≤ l. Thus, for η large enough, the interpretation of seq n contains the result of A n (1 η , ρ s , k 1 , . . . , k l ) (simulated by A seq n ), and A ∈ always output true. The advantage of any attacker then becomes 0 which is negligible.</p><p>3. The probability of collision between two sequences of bitstrings of length η is 1 2 η . For any polynomial p, as seq n is a uniform sampling of length p(η) × η, and n k 1 ,...,k l is an independent uniform sampling of length η, the probability that n k 1 ,...,k l occurs in seq n at a position which is a multiple of η is the probability 1 -(1 -1 2 η ) p(η) . Thus, A ∈ will answer true with only a negligible probability.</p><p>As the interpretation A ∈ given in the previous proposition corresponds to the interpretation required in the application to key exchanges (Section 6), we can indeed use those axioms in proofs of key exchange security.</p><formula xml:id="formula_172">1. if n ∈ N , n is interpreted as the machine [[n]] M = A n that on input (1 η , ρ s ) extracts a</formula><p>word of length η from the tape ρ s . Different names should extract disjoint parts of the random tape.</p><formula xml:id="formula_173">2. if f ∈ F, then, with d 1 , ..., d n ∈ D n a sequence of messages, [[f ]] M (d 1 , . . . , d n ) is the machine such that, on input (1 η , ρ s ), [[f ]] M (d 1 , . . . , d n )(1 η , ρ s ) := A f (d 1 (1 η , ρ s , ρ O ), . . . , d n (1 η , ρ s ))</formula><p>Intuitively, we simply compose the machine, which represents f , with all the machines representing its inputs. f can only be deterministic, any randomness must be explicitly given as an argument.</p><p>Given an assignment σ of variables to messages in D, the random tape ρ s , and a security parameter η ∈ N, for each f ∈ F a Turing machine A f , the (evaluation of the) interpretation of a term t is inductively defined as follows:</p><p>•</p><formula xml:id="formula_174">[[n]] η,σ ρs := A n (1 η , ρ s ) if n ∈ N • [[x]] η,σ ρs = (xσ)(1 η , ρ s , ) if x ∈ X • [[f (u)]] η,σ ρs = A f ([[u]] η,σ ρs ) if f ∈ F</formula><p>Such an interpretation of terms of course depends on the functional model M f : we may add M f as an index of the semantic bracket if needed.</p><p>On the contrary, if the parameters are clear from the context we may simply write</p><formula xml:id="formula_175">[[]] for [[]] σ</formula><p>ρs , or provide with the relevant arguments only.</p><p>Example A.2. Let us consider N = {sk, m, r} and F = {enc}. We may define A enc as a TM implementing some encryption function, and A sk as the TM which extracts the η first bits of ρ s , and similarly for m and r with the following bits of ρ s . In this cryptographic library, the term enc(m, r, sk) will now be interpreted as the encryption of a random string by a random string.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Protocols</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1 Protocol Algebra</head><p>The precise syntax of our process algebra is defined in Figure <ref type="figure" target="#fig_8">10</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Formal definition of a protocol execution</head><p>A protocol state is a pair ϕ, (P 1 , σ 1 ) • • • (P n , σ n ), where each P i is a protocol, σ i is an environment binding variables to bit-strings (intuitively the attacker's inputs), ϕ is a sequence of bit-strings (intuitively the protocol outputs). The parallel operator is considered as associative and commutative. The semantics of elementary protocols assumes that, after an attacker input, the protocol moves immediately as much as possible until it stops or waits for another input. Formally, we define a relation -→ , that does not depend on the attacker, such that, for instance, φ, (out(c, t).P, σ) -→ φ (c, [[t]] η,σ ρs ), P, σ. σ ν is defined such that all previously defined terms:  In other words, in case of an output, we add to the frame the interpretation of t, given the current assignment of its variables and a (secret) random tape. We write ! -→ the reduction of a global state to its normal form w.r.t. -→ . Given an adversary A, a sampling ρ s of the names and a sampling ρ r the attacker's random coins, for composed protocols, the operational semantics is given in Figure <ref type="figure" target="#fig_9">11</ref> and Figure <ref type="figure" target="#fig_10">12</ref> in the SOS style.</p><formula xml:id="formula_176">t ::= n names | n i indexed names | x variable | f (t 1 , . . . ,</formula><p>Note that a protocol with free variables may not be executed alone, but only in a context where its variables have been defined. Given P a protocol with free variables x 1 , . . . , x k and n 1 , . . . , n k a sequence of names, we may write P (n 1 , . . . , n k ) as a short cut for let</p><formula xml:id="formula_177">x 1 = n 1 in . . . let x k = n k in P (x 1 , . . . , x k ).</formula><p>Definition 33 (Context). A context C[_ 1 , . . . , _ n ] is a protocol built over the protocol algebra, where some elementary protocols are replaced with holes. Each hole _ i can occur only once in the context. Given the (elementary) protocols P 1 , . . . , P n , C[P 1 , . . . , P n ] is then the protocol obtained when replacing each hole by the corresponding protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3 Formal definition of protocol oracles</head><p>Definition 34 (Protocol Oracle). A protocol oracle is defined as the previous stateless oracles, except that it has an additional history input, and only use w from its input (w, r, s). The protocol oracle machines also have an additional history tape, that cannot be accessed by the machine: it is only passed to the oracle, which also records the input queries on the history The interactions between a process P and processes running in parallel are computed by the attacker We may generalize in the natural way the definition of protocol oracle machines to support any number of oracles where each protocol oracle has a distinct additional history tape.</p><formula xml:id="formula_178">Elementary protocols if [[s]] η,σ ρs = [[t]] η,σ ρs ϕ, (if s = t then P else Q, σ) - → ϕ, P, σ if [[s]] η,σ ρs = [[t]] η,σ ρs ϕ, (if s = t then P else Q, σ) - → ϕ, Q, σ ϕ, P, σ {x → A(ρ r , ϕ)} ! - →<label>ϕ</label></formula><formula xml:id="formula_179">ϕ, P Q, σ -→ A ϕ, (P, σ) (Q, σ) ϕ, i≤N P, σ -→ A ϕ, P {i → 1} • • • P {i → N }, σ ϕ, ( i P ) E, σ -→ A ϕ, ( i≤A(ρr,ϕ) P ) E, σ</formula><p>We are now ready, given a protocol P , to define the protocol oracle O P .</p><p>Definition 35. Given a protocol P (which is action deterministic), a functional model M f , a security parameter η ∈ N and a random tape ρ s , O P is the protocol oracle, which, given ρ s and an history θ = {o 1 , ..., o n } ∈ ({0, 1} * ) n , on a query m:</p><p>• appends m to the history tape;</p><p>• executes the protocol P according to the semantics, using as inputs the history;</p><p>• return the final output produced by the protocol.</p><p>We extend the definition of PPTOM with:</p><p>• A protocol oracle input tape</p><p>• A protocol oracle history tape</p><p>• A protocol oracle output tape</p><p>The machine may call the protocol oracle O P by writing on its input tape some content m, and there is then a single move to the current configuration to a configuration in which the history tape has been extended with the content of the input tape, and the protocol oracle output tape has been set to the output of O P (ρ s , θ)(m).</p><p>By case disjunction g 2 (φ 1 ) = pk(sk R ), the negative one being trivial, we must prove: if checksign(g 4 (φ 1 ), pk(sk R )) ∧ g 3 (φ 1 ) = π 2 (getmess(g 4 (φ 1 ))) then if π 1 (getmess(g 4 (φ 1 ))) = g a ∧ π 3 (getmess(g 4 (φ 1 ))) = pk(sk</p><formula xml:id="formula_180">I ) then if g 3 (φ 1 ) = g b then ¬ i g 3 (φ 1 ) = g b i ∼ if checksign(g 4 (φ 1 ), pk(sk R )) ∧ g 3 (φ 1 ) = π 2 (getmess(g 4 (φ 1 ))) then if π 1 (getmess(g 4 (φ 1 ))) = g a ∧ π 3 (getmess(g 4 (φ 1 ))) = pk(sk I ) then if g 3 (φ 1 ) = g b then false</formula><p>We now apply EUF-CMA T R ,F,sk R ,s to g 4 (φ 1 ), so we either have g 4 (φ 1 ) = sign((g 0 (φ 0 ), g b , g 1 (φ 0 )), sk R ) (the honest signature), which is a contradiction with g 3 (φ 1 ) = g b and g 3 (φ 1 ) = π 2 (getmess(g 4 (φ 1 ))), or the signature comes from the oracle and g 4 (φ 1 ) = (A, g b i , A ), in contradiction with ¬ i g 3 (φ 1 ) = g b i . This conclude the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.3 Conclusion for Signed DDH</head><p>We thus have the security of the signed DDH protocol. If we want to use Corollary 2 to compose it with for instance a record protocol RP := RP I (k) RP R (k), which simply exchange encrypted messages using the exchanged key, and do not share any long term secret, it is trivial. Indeed, without any shared secret, in(k); RP I (k) in(k); RP R (k) is simulatable without any oracle, so we can take O p = ∅. This means that we have the first set of hypothesis. Now, RP would be proven secure with IND-CCA, and this can be proven easily, even if many other session of RP with distinct keys are in parallel. So we can simply set O r as the oracle which outputs all the k i,j and O k as the oracle which output p, and obtain the multi session security of RP , and the simulatability of the key exchange.</p><p>RP could be a single round trip enrypted exchange, or actually any number of round trip, easily proved secure using Proposition 18.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D An application to SSH</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.1 Presentation of SSH</head><p>We only show here how the proof of security of SSH could be split up into smaller proofs thanks to our framework, but we do not actually prove the smaller proofs. We will thus only provide a high level point of view of SSH, not going into too many implementations details, but rather focusing on the parts that represent a challenge for composition. SSH is a simple key exchange which can be used to set up an authenticated and secret channel between a user's computer and a server, with first an authentication of the server, and then an optional authentication of the user, either through a password or a secret key. We provide in Figure <ref type="figure" target="#fig_1">13</ref> the basic SSH key exchange, with authentication through secret keys.</p><p>We can see that the indistinguishability of the key is not preserved through the protocol. The difficulty of SSH is moreover that once a user has established a secure connection to a server, he can from this server establish a secure connection to another server, while using the Figure <ref type="figure" target="#fig_1">13</ref>: Basic SSH key exchange secure channel previously established to obtain the user credentials. We provide in Figure <ref type="figure" target="#fig_4">14</ref> a model of the SSH with forwarding of agent (reusing the definitions of P and S from Figure <ref type="figure" target="#fig_1">13</ref>), where after a P is ran successufully, a F orwardAgent is started on the computer which can receive on the secret channel a signing request and perform the signature of it. In parallel, after the completion of some S, a distant session of P can be initiated by P Distant, which will request on the previous secret channel the signature of the sid. Finally, as the forwarding can be chained multiple time, at the end of a successful P Distant, a F orwardServer is set up, which will accept to receive a signing request on the new secret channel of P Distant, forward the request on the old secret channel, get the signature and forward it.</p><p>With the agent forwarding, we are faced with the new problem which is that we sequentially compose a basic SSH exchange with other ones which use the same long term secret keys.</p><p>To summarize, to be able to prove the security of SSH with agent forwarding, we must be able to handle key confirmations and composition with shared long term secret.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.2 The security of the protocol without forwarding agent</head><p>We show how we may apply Corollary 3 to the basic SSH protocol.</p><p>We provide in Figure <ref type="figure" target="#fig_5">15</ref>, how we decompose the ssh protocols in order to prove its security. To simplify, we directly specify that P and S may only relate to each other by hard-coding the expected public keys inside them.</p><p>A first step is to obtain the hypothesis A-3, relating to the security of the basic SSH key exchange. We split this goal into two subgoals with a case study, the first one capturing the real or random of the key, P 0 (a, skP, pk(skS)); out(k) S 0 (b, skS, pk(skP )); out(k) ∼ = O P 0 (a, skP, pk(skS)); [if B = g b then out(k ) else out(k)] S 0 (b, skS, pk(skP ))[if A = g a then out(k ) else out(k)] and the second one the authentication: P 0 (a, skP, pk(skS)); if ¬( i B = g b i ) then P 1 (a, skP, pk(skS), B, k); out(k) S 0 (b, skS, pk(skP )); if ¬( i A = g a i ) then S 1 (b, skS, pk(skP ), sid, k); out(k) ∼ = O P 0 (a, skP, pk(skS)); if ¬( i B = g b i ) then P 1 (a, skP, pk(skS), B, k); bad S 0 (b, skS, pk(skP )); if ¬( i A = g a i ) then S 1 (b, skS, pk(skP ), sid, k); bad</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.3 Proof of real of random</head><p>We start by proving that:</p><p>Ax |= P 0 (a, skP, pk(skS)); out(k) S 0 (b, skS, pk(skP )); out(k) ∼ P 0 (a, skP, pk(skS));</p><formula xml:id="formula_181">[if B = g b then out(k ) else if B = g b i then out(k)] S 0 (b, skS, pk(skP ))[if A = g a then out(k ) else if A = g a i then out(k)]</formula><p>For this proof, we may use Ax = DDH s , where s does not contain a and b. We denote φ j i the i-eme term of the j-eme folding in the left game, and ψ j i for the right game. After splitting over each possible folding of actions, we have the sequence of terms: We apply the EQ that are true in the if branches, and we perform a case study on the first conditional of the sequence, yielding the four terms:</p><formula xml:id="formula_182">• φ 0 = g a ; φ 1 = φ 0 , g b , g 0 (φ 0 ) b ; φ 2 = φ 1 , g 1 (φ 1 ) a • φ 1 1 = φ 0 , g 0 (φ 0 ) a , ; φ 1 2 = φ 1 1 , g b , g 1 (φ 1 1 ) b • ψ 0 = φ 0 ; ψ 1 = ψ 0 , g b , if g 0 (φ 0 ) = g a then k else if g 0 (φ 0 ) = g a i then g 0 (φ 0 ) b ; ψ 2 = ψ 1 , if g 1 (ψ 1 ) = g b then k else if g 1 (ψ 1 ) = g b i then g 1 (ψ 1 ) a • ψ 1 1 = ψ 0 , if g 0 (φ 0 ) = g b then k else if g 0 (φ 0 ) = g b i then g 0 (ψ 0 ) a ; ψ 1 2 = ψ 1 1 , g b , if g 1 (ψ 1 1 ) = g a then k else if g 1 (ψ 1 1 ) = g a i then g 1 (ψ</formula><p>• ψ 1 = ψ 0 , g b , EQ(g 0 (φ 0 ), g a ), k</p><p>• ψ 1 = ψ 0 , g b , EQ(g 0 (φ 0 )), g a i ), g a i b</p><p>• φ 1 = φ 0 , g b , EQ(g 0 (φ 0 ), g a ), g ab</p><p>• φ 1 = φ 0 , g b , EQ(g 0 (φ 0 ),</p><formula xml:id="formula_183">g a i ), g a i b</formula><p>With DDH , we can replace g ab with k , and with transitivity, we have that</p><formula xml:id="formula_184">Ax |= φ 1 ∼ ψ 1 .</formula><p>Moreover, we trivially have</p><formula xml:id="formula_185">Ax |= φ 1 ∼ ψ 1</formula><p>The we also apply the EQand perform another case study on the second conditional, yielding eight terms:</p><formula xml:id="formula_186">• ψ 2 = ψ 1 , EQ(g 1 (ψ 1 ), g b ), k • ψ 2 = ψ 1 , EQ(g 1 (ψ 1 ), g b i ), g ab i • ψ 2 = ψ 1 , EQ(g 1 (ψ 1 ), g b ), k • ψ 2 = ψ 1 , EQ(g 1 (ψ 1 ), g b i ), g ab i • φ 2 = φ 1 , EQ(g 1 (φ 1 ), g b ), g ab • φ 2 = φ 1 , EQ(g 1 (φ 1 ), g b i ), g ab i • φ 2 = φ 1 , EQ(g 1 (φ 1 ), g b ), g ab • φ 2 = φ 1 , EQ(g 1 (φ 1 ), g b i ), g ab i</formula><p>From now on, we omit Ax. We then prove the four equivalence required to conclude:</p><formula xml:id="formula_187">1. φ 2 ∼ ψ 2</formula><p>We first use function application (FA) multiple times to get φ 2 ∼ ψ 1 , EQ(g 1 (ψ 1 ), g b ), g ab . Then, we use DDH to replace g ab with k and transitivity to conclude that:</p><formula xml:id="formula_188">φ 2 ∼ ψ 2 . 2. φ 2 ∼ ψ 2 FA* on φ 1 ∼ ψ 1 yields the conclusion φ 2 ∼ ψ 1 , EQ(g 1 (ψ 1 ), g b i ), g ab i .</formula><p>3. φ 2 ∼ ψ 2 FA* on φ 1 ∼ ψ 1 , yields φ 2 ∼ ψ 1 , EQ(g 1 (ψ 1 ), g b ), g ab . After expressing the fact that g a i b = (g b ) a i (i.e. all terms can be expressed as a context of g a , g b , g ab ), we use DDH to replace g ab with k and conclude.</p><p>4. φ 2 ∼ ψ 2 FA* on φ 1 ∼ ψ 1 yields the conclusion φ 2 ∼ ψ 1 , EQ(g 1 (ψ 1 ), g b i ), g ab i .</p><p>We thus have Ax |= φ 2 ∼ ψ 2 .</p><formula xml:id="formula_189">D.3.2 Proof of Ax |= φ 1 2 ∼ ψ 1 2</formula><p>We first note that EQ(g 0 (φ 0 ), g b ) ∼ false as φ 0 does not contain b. Thus, the positive branch can be eliminated and we get ψ 1 1 ∼ φ 1 1 . We then have</p><formula xml:id="formula_190">ψ 1 2 ∼ ψ 1 2 where ψ 1 2 = φ 1 1 , g b , if g 1 (φ 1 1 ) = g a then k else g 1 (φ<label>1</label></formula><p>1 ) b . We conclude once again with a case study, a DDH for one case, and trivial equality in the other case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.4 Proof for the authentication</head><p>We now prove that:</p><p>Ax |= P 0 (a, skP, pk(skS)); if ¬( i B = g b i ) then P 1 (a, skP, pk(skS), B, k); out(k) S 0 (b, skS, pk(skP )); if ¬( i A = g a i ) then S 1 (b, skS, pk(skP ), sid, k); out(k) ∼ P 0 (a, skP, pk(skS)); if ¬( i B = g b i ) then P 1 (a, skP, pk(skS), B, k); bad S 0 (b, skS, pk(skP )); if ¬( i A = g a i ) then S 1 (b, skS, pk(skP ), sid, k); bad</p><p>The proof is very similar to the proof of authentication of the signed DH key exchange, we only outline the arguments here.</p><p>T P (m, s) := ∃i, ∃X, m = hash(g a i , X, X a i ) T S (m, s) := ∃i, ∃X, m = hash(X, g b i , X b i )</p><p>We have that Ax = EUF-CMA T P ,skP,s ∧ EUF-CMA T S ,skS,s is O sign T P ,sk A ,s , O sign T S ,sk B ,s , O a i ,b i sound thanks to Proposition 27.</p><p>We prove that bad may never occur, either in P or S. For bad to occur, the signature checks must succeed in one of the process, while the session identifier is not an honest one. In this case, we prove that the signature checks will always fail, i.e that , for sign, B and A terms produced by the attacker:</p><formula xml:id="formula_191">¬( i B = g b i ) ∧ checksign(sign, pk(skS))) ∧ getmess(sign) = hash(&lt; g a , B, B a &gt;) ∼ false or ¬( i A = g a i ) ∧ checksign(sign, pk(skP )) ∧ getmess(sign) = hash(&lt; A, g b , A b &gt;) ∼ false</formula><p>If those two equivalences are true for all possible values of the term sign that can be taken depending on the traces, bad will never be raised. Let us for instance prove the first one. For all possible traces, the only honest signature by skS that might appear inside the message sign is of the form sign(hash(&lt; A, g b , A b &gt;), skS).</p><p>By using the EUF-CMA T S ,skS,s axiom, we obtain</p><formula xml:id="formula_192">¬( i B = g b i ) ∧ checksign(sign, pk(skS))) ∧ getmess(sign) = hash(&lt; g a , B, B a &gt;) ∼ ¬( i B = g b i ) ∧ (T s ( getmess(sign)) ∨ getmess(sign) = hash(&lt; A, g b , A b &gt;), skS)</formula><p>∧ getmess(sign) = hash(&lt; g a , B, B a &gt;) (T s ( getmess(sign)) is directly in contradiction with ¬( i B = g b i ), and the same goes for getmess(sign) = hash(&lt; A, g b , A b &gt;), skS), we do obtain the expected conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E SSH with forwarding agent</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1 Scheme of the proof</head><p>Here, we wish to compose SSH with another potential session of SSH using the forwarding agent. Then, a protocol which is secure if executed with a real or random key should be secure when using the key given by the SSH session using the forward agent.</p><p>We will write F A for F orwardAgent, SF for SF orward, and P D for P Distant. We consider a record protocol, satisfying a property of the form</p><formula xml:id="formula_193">Y (k) Z(k) ∼ = Y (k) Z (k).</formula><p>We also assume that the agents are only willing to communicate with the honnest identity, i.e pk(skS) and pk(skP ) are predefined inside the processes. This is usually the case for SSH, where the user is asked to either validate or insert himself some public key.</p><p>Our goal is then: 74 We split the proof using two applications of Corollary 3.</p><p>The P and S will use randomness of the form a i , b i , and P D and SF randomness of the form a i and b i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1.1 First application of Corollary 3</head><p>The application is performed with the following hypothesis, which allows to derive the desired conclusion.</p><p>A-3: All simulations are performed under νskS, skP . To define O f orward , we need to settle an issue. . Indeed, for hypothesis C-1, we need to provide an oracle that can simulates sessions of the forwarding protocols. However, in order to get the simulatability of in(k).F A(skP, k), one must give a generic signing oracles to the attacker, which would obviously make the protocol unsecure. Based on the assumption that the forwarded sessions perform signatures tagged with "forwarded", as shown below, we however can provide a signing oracle only for such messages, allowing for the simulatability of the forwarding agent, and of the forwarded client and server. More specifically, recall the the forwarding agent is of the form:</p><formula xml:id="formula_194">P 0 (a, skP ); if ¬T (B, s) then P 1 (a, skP, B a ); out(B a ) else out(B a , g a , B) S 0 (b, skS); if ¬T (A, s) then S 1 (b, skS, A b ); out(A b ) else out(A b , g b , A) ∼ = O P S ,O f orward P 0 (a, skP ); if B = g b then out(k, g a , B) else if ¬T (B, s) then P 1 (a, skP, B a ); bad else out(A b , g b , A) S 0 (b, skS); if A = g a then out(k, g b , A) else if ¬T (B, s) then S 1 (b, skS, A b ); bad else out(A b , g b , A) B-1: ! n 2 P 1 (k); F A(k) S 1 (k); P D(k); Y SF ; Z ∼ = O KE 1 ! n 2 P 1 (k); F A(k) S</formula><formula xml:id="formula_195">F A(skP, k) := in(enc(sid, k)) out(enc(sign(&lt; sid, "f orwarded" &gt;, skP ), k))</formula><p>forwarding agent ensure that any signed session identifier is honest, and the secrecy of the name k is not even required to perform the proof. This proof could also performed without the additional check added to the forwarding agent, but it would then require a cryptographic assumption regarding the encryption. And B-1:</p><formula xml:id="formula_196">P D 1 (k ); Y (k ) SF 1 (k ); Z(k ) ∼ = O KE 1 ,O KE k 2 P D 1 (k ); Y (k ) SF 1 (k ); Z (k )</formula><p>With the oracles:</p><p>• O k F P S allows to simulate (A-1) the other honnest sessions of P D and SF , it corresponds to O sign T P ,skS,s , O sign T S ,skP,s , O a i ,b i of Appendix D.4.</p><p>• O Y Z allows to simulate (C-1) the continuation, i.e the protocols of the form in(k);</p><formula xml:id="formula_197">P D 1 (k); Y (k) in(k); SF 1 (k); Z(k) • O KE k 2 allows to simulate (C-2) ! n 2 F A(k) P D(k) SF (it is similar to O F P S ).</formula><p>Here, we do not commit to any transport protocol used after the SSH key exchange. It would probably use some encryption using the fresh key. Then, if for instance IND-CCAis required to prove Y Z ∼ = Y Z , to prove B -1, we would need to assume that IND-CCAis still valid even when the attacker has access to the hash of a message containing the key used for encryption. This holds for instance in the random oracle model. A proof of B -1 could then be derived from the proof of Y Z ∼ = Y Z which would still be valid under an oracle producing hashes of the key, i.e an oracle which could simulate P D 1 and SF 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F Proofs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.1 Formal Corollary for Key Exchange</head><p>We denote p = {id I , id R } and s = {lsid I i , lsid R i } i∈N the set of all the copies of the local session identifiers.</p><p>Formalizing the previous Section, to prove the security of a key exchange, we can use the following Corollary of Theorem 5.</p><formula xml:id="formula_198">Corollary 1. Let O ke , O be oracles and KE i [_ 1 , _ 2 ] := I(lsid I i , id I ); _ 1 R(lsid R i , id R ); _ 2 a key exchange protocol, such that I binds x I , x I id , x I lsid , R binds x R , x R id , x R lsid and N l (KE) is disjoint of the oracle support. Let id I , id R be names and s I = {lsid I i } i∈N ,s R = {lsid R i } i∈N sets of names : 1. ∀i ≥ 1, (νlsid I i , id I , lsid R i , id R . KE i [out( x I , lsid I i , x I lsid , x I id ), out( x R , lsid R i , x R lsid , x R id )] out( lsid R i , lsid I i ) is O ke simulatable)).</formula><p>2. s is disjoint of the support of O.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>KE</p><formula xml:id="formula_199">0 [out( x I , lsid I 0 , x I lsid , x I id ), out( x R , lsid R 0 , x R lsid , x R id )] ∼ = O ke ,O KE 0 [ if x I lsid = lsid R 0 ∧ x I id = id R then out( k, lsid I 0 , x lsid , x id ) else if x I lsid / ∈ s R ∧ x I id = id R then ⊥ else out( x I , lsid I 0 , x I lsid , x I id ), if x R lsid = lsid I 0 ∧ x R id = id I then out( k, lsid R 0 , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then ⊥ else out( x R , lsid R 0 , x R lsid , x R id )</formula><p>] Then, for any N which depends on the security parameter:</p><formula xml:id="formula_200">i≤N KE i [out(x I ), out(x R )] ∼ = O i≤N KE i [ if (x I id = id R ) then if 1≤j≤N x I lsid = lsid R j ∧ x I id = id R then out(k i,j ) else out(x I ), if (x R id = id I ) then if 1≤j≤N x R lsid = lsid I j ∧ x R id = id I then out(k j,i ) else out(x R )]</formula><p>Then, building upon the previous Corollary and the sequential composition Theorems, the following Corollary shows the precise requirements to prove the security of a protocol which uses a key exchange, for an bounded number of session and with long term secrets shared between the key exchange and the protocol.</p><formula xml:id="formula_201">Corollary 2. Let O T , O ke , O r ,O P,Q be oracles and KE i [_ 1 , _ 2 ] := I(lsid I i , id I ); _ 1 R(lsid R i , id R ); _ 2 a key exchange protocol, such that I binds x I , x I id , x I lsid , R binds x R , x R id , x R lsid and N l (KE) is disjoint of the oracle support. Let id I , id R be names, s I = {lsid I i } i∈N ,s R = {lsid R i } i∈N and s = s I ∩ s R sets of names. Let p = {id I , id R }, P (x, y) = P 1 (x, y) P 2 (x, y) and Q(x, y, z) = Q 1 (x, y, z) Q 1 (x, y, z) be parameterized protocols, such that N l (P, Q) is disjoint of the oracle support. I-1 ∀i ≥ 1, (νlsid I i , id I , lsid R i , id R .KE i [out(x I ), out(x R )] out( lsid R i , lsid I i ) is O T -simulatable)). I-2 s is disjoint of the support of O P,Q . I-3 KE 0 [out( x I , lsid I 0 , x I lsid , x I id ), out( x R , lsid R 0 , x R lsid , x R id ) ∼ = O T ,O P,Q KE 0 [if x I lsid = lsid R 0 ∧ x I id = id R then out( k, lsid I 0 , x I lsid , x I id ) else if x I lsid / ∈ s R ∧ x I id = id R then ⊥ else out( x I , lsid I 0 , x I lsid , x I id ), if x R lsid = lsid I ∧ x R id = id I then out( k, lsid R 0 , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then ⊥ else out( x R , lsid R 0 , x R lsid , x R id )] and R-1 ∀ 1 ≤ i, j ≤ n, νp, k i,j .P 0 (p, k i,j ) is O r -simulatable. R-2 ∀ 1 ≤ i ≤ n, νp, k i,j .Q 0 (p, k i,j ) is O r -simulatable. R-3 s is disjoint of the support of O k . R-4 P 0 (p, k) ∼ = Or,O ke Q 0 (p, k) and C-1 νp.in(x I i ).P I i (x I i ) in(x R i ).P R i (x R i )is O P,Q -simulatable. 1. νp. i≤n KE i [ if (x I id = id R ) then if 1≤j≤n (x I lsid = lsid R j ∧ x I id = id R ) then out( i, j ) else P I i (x I i ), if (x R id = id I ) then if 1≤j≤n (x R lsid = lsid I j ∧ x R id = id I ) then out( i, j ) else P R i (x R i )] is O ke -simulatable.</formula><p>Then, for any n which may depend on the security parameter:</p><formula xml:id="formula_202">i≤n KE i [P I i (x I i ), P R i (x R i )] ∼ = i≤n KE i [if x I id = id R then Q I i (x I i ) else P I i (x I i ), if x R id = id I then Q R i (x R i ) else P R i (x R i )]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.2 Formal Corollary for Key Confirmations</head><p>The Theorem for those key exchanges is very similar to Corollary 2. The main difference is that now, instead of working on a key exchange KE := I(lsid I , id I )|R(lsid R , id R )[, we further split I and R, in I = I 0 ; I 1 and R := R 0 ; R 1 , where I 0 and R 0 will corresponds to the key exchange up to but not including the first use of the secret key, and I 1 and R 1 as the remainder of the protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now, if we define</head><formula xml:id="formula_203">O v,r B such that O v,r B = O(π n (ρ s , η), ρ B O ) when [[n]] η ρs = v and ρ B O = r B , we have that P ρs,,ρr 1 ,ρr 2 ,ρ O {v 1 m+1 = x m+1 | θ 1 m = x, φ 1 m = y, [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 } = 1 P ρs,ρr 1 ,ρr 2 ,ρ O {B O(π n (ρs,η),ρ B O ) (M f , ρ r 2 , η, φ 1 m ) = x m+1 | θ 1 m = x, φ 1 m = y, [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 } = 2 P ρs,ρr 1 ,ρr 2 ,ρ O {B O v,r B (M f , r 2 , η, y) = x m+1 | θ 1 m = x, φ 1 m = y, [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 } = 3 P ρs,ρr 1 ,ρr 2 ,ρ O {B O v,r B (M f , r 2 , η, y) = x m+1 } = 4 P ρs,ρr 1 ,ρr 2 ,ρ O {B O v,r B (M f , r 2 , η, y) = x m+1 | θ 2 m = x, φ 2 m = y, [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 } = 5 P ρs,ρr 1 ,ρr 2 ,ρ O {B O(π n (ρs,η),ρ B O ) (M f , ρ r 2 , η, φ 2 m ) = x m+1 | θ 2 m = x, φ 2 m = y, [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 }</formula><p>Justified with:</p><formula xml:id="formula_204">1. because O(ρ s , ρ O ) = O(π n (ρ s , η), ρ B O ); 2. O(π n (ρ s , η), ρ B O ) = O v,r B , and φ 1 m = y;</formula><p>3. the considered event does not depends on any of the conditional events removed;</p><p>4. the considered event does not depends on any of the conditional events added;</p><p>5. reversing the previous steps.</p><p>So we conclude that, as we also have the induction hypothesis:</p><formula xml:id="formula_205">P ρs,ρr 1 ,ρr 2 ,ρ O {θ 1 m+1 = x, φ 1 m = y| [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 } = P ρs,ρr 1 ,ρr 2 ,ρ O {θ 2 m+1 = x, φ 2 m = y| [[n]] η ρs = v, ρ B O = r B , ρ r 2 = r 2 } (i)</formula><p>We now define:</p><formula xml:id="formula_206">u 1 m+1 = A O(π n (ρs,η),ρ A O ) (M f , ρ r 1 , θ 1 m v 1 m+1 , η) u 2 m+1 = O P (ρ s , θ 2 m v<label>2</label></formula><p>m+1 ) We define the Turing machine B, such that:</p><formula xml:id="formula_207">B O(ρs,ρ O ) (M f , ρ r 2 , η, φ i m ) := if ∀j ≤ m + 1, B O(v,r B ) (M f , r 2 , η, φ i j ) = x j ∧φ i m = y then B O(v,r B ) (M f , r 2 , η, φ i m ) else ⊥</formula><p>We then define v m and θ m for B similarly as v m for B.</p><p>Proof. Let there be a cryptographic library M f , a sequence of names n, an oracle O with support n and a sequence of terms t O-simulatable. As the names of m do not appear in t, the probability of any event regarding t is independent from an event regarding m so we have for any PTOM A O , η, sequences c, v, w ∈ {0, 1} * , 1. ∀i, j ∈ N, νp, lsid</p><formula xml:id="formula_208">P ρs,ρr 1 ,ρr 2 ,ρ O {A O(ρs,ρ O ) (M f , m 1 , . . . , m k , ρ r 2 , η) = c | [[n]] η ρs = v, [[m]] η ρs = w} P ρs,ρr 1 ,ρr 2 ,ρ O {A O(ρs,ρ O ) (M f , m 1 , . . . , m k , ρ r 2 , η) = c | [[n]] η ρs = v} = P ρs,ρr,ρ O {[[t 1 , . . . , t n ]] η ρs,ρr,ρ O = c|[[n]] η ρs = v} = P ρs,ρr,ρ O {[[t 1 , . . . , t n ]] η ρs,ρr,ρ O = c|[[n]] η ρs = v, [[m]]</formula><formula xml:id="formula_209">j i .R j i (p, lsid j i ) is O r -simulatable. 2. P (p) ∼ = Or Q(p) 3. s is disjoint of the support of O.</formula><p>Then, for any integers N 1 , . . . , N k :</p><formula xml:id="formula_210">P (p) i≤N 1 (R 1 i (p, lsid<label>1</label></formula><formula xml:id="formula_211">i ) . . . i≤N k R k i (p, lsid k i ) ∼ = O,Or Q(p) i≤N 1 R 1 i (p, lsid<label>1</label></formula><formula xml:id="formula_212">i ) . . . i≤N k R k i (p, lsid k i )</formula><p>Specifically, there exists a polynomial p S (independent of all R j ) such that if p R j is the polynomial bound on the runtime of the simulator for R j , we have,</p><formula xml:id="formula_213">Adv P (p) i≤N 1 (R 1 i (p,lsid 1 i ) ... i≤N k R k i (p,lsid k i ) ∼ =OQ(p) i≤N 1 R 1 i (p,lsid<label>1</label></formula><formula xml:id="formula_214">i ) ... i≤N k R k i (p,lsid k i ) (t) ≤ Adv P (p) ∼ =O,O r Q(p) p S t, N 1 , |R 1 |, . . . , N k , |R k |, p R 1 (t), . . . , p R k (t)</formula><p>Rather than proving the previous Theorem, where we recall that the protocols may depend on a predicate T (x) whose interpretation depends on s, we prove the version where P directly depends on s.</p><p>Proposition 38. Let O r be an oracle parameterized by a sequence of names s. Let p be a sequence of names, P (x), R 1 i (x, y, z), . . . , R k i (x, y, z) and Q(x, y) be protocols, such that N l (R Then, for any integers N 1 , . . . , N k :</p><formula xml:id="formula_215">P (p) i≤N 1 (R 1 i (p, lsid 1 i , s) . . . i≤N k R k i (p, lsid k i , s) ∼ = Or Q(p, s) i≤N 1 R 1 i (p, lsid 1 i , s) . . . i≤N k R k i (p, lsid k i , s)</formula><p>Specifically, there exists polynomial p S (independent of all R j )such that if p R j is the polynomial bound on the runtime of the simulator for R j , we have,</p><formula xml:id="formula_216">Adv P (p) i≤N 1 (R 1 i (p,lsid 1 i ,s) ... i≤N k R k i (p,lsid k i ,s) ∼ =O r Q(p,s) i≤N 1 R 1 i (p,lsid 1 i ,s) ... i≤N k R k i (p,lsid k i ,s) (t) ≤ Adv P (p) ∼ =OQ(p,s) p S t, N 1 , |R 1 |, . . . , N k , |R k |, p R 1 (t), . . . , p R k (t)</formula><p>Proof. We prove the result for k = 1, denoting R 1 as R, as the generalization is immediate. Let there be an integer n.</p><p>Hypothesis 1 with Lemma 37 gives us that for</p><formula xml:id="formula_217">1 ≤ i ≤ N , νlsid i , p.R i (p, lsid i , s) is O R - simulatable.</formula><p>Moreover, with δ = {p, s}, N (R i (p, lsid i , s)) ∩ δ = {p, lsid i }, so thanks to Theorem 1, for</p><formula xml:id="formula_218">1 ≤ i ≤ N , νδ.R(p, lsid i , s) is O R -simulatable.</formula><p>Now, up to renaming of the local names of R (which is possible as they do not appear in the oracle support), we have that</p><formula xml:id="formula_219">∀1 ≤ i &lt; j ≤ N.N (R i (p, lsid i , s)) ∩ N (R j (p, lsid j , s)) ⊂ δ, so with Theorem 1 we have that i≤N R i (p, lsid i , s) is O R -simulatable.</formula><p>Note that if R is simulatable by a simulator bounded by a polynomial p R (t) on an input of size t, then i ≤ N R(p, lsid i , s) is simulatable by a simulator bounded by a polynomial q(n, p R (t)), where q is uniform in n and R.</p><p>Finally, we have that i≤N R i (p, lsid i , s) is O R -simulatable and P (p, lsid n ) ∼ = O Q(p, s), so we conclude with Theorem 2.</p><p>Instantiating the bound on the advantage from Theorem 2 with |C| = n|R| and p C (t) = q(n, p R (t)) yields the desired result.</p><p>Theorem 5. Let O r , O be oracles both parameterized by a sequence of names s. Let p be a sequence of names, P i (x, y) and Q i (x, y) be parameterized protocols, such that N l (P, Q) is disjoint of the oracles support. If we have, for sequences of names lsid P , lsid Q , with s =</p><formula xml:id="formula_220">{lsid P i , lsid Q i } i∈N : 1. ∀ i ≥ 1, νp, lsid P i .P i (p, lsid P i ) is O r -simulatable. 2. ∀ i ≥ 1, νp, lsid Q i .Q i (p, lsid Q i ) is O r -simulatable. 3. s is disjoint of the support of O. 4. P 0 (p, lsid P 0 ) ∼ = Or,O Q 0 (p, lsid Q 0 ) then, || i P i (p, lsid P i ) ∼ = O || i Q i (p, lsid Q i )</formula><p>We once again generalize with the explicit dependence in s.</p><p>Theorem 7. Let O r , O be oracles both parameterized by a sequence of names s. Let p be a sequence of names, P i (x, y) and Q i (x, y, z) be parameterized protocols, such that N l (P, Q) is disjoint of the oracles support. If we have, for sequences of names lsid P , lsid Q , with</p><formula xml:id="formula_221">s = {lsid P i , lsid Q i } i∈N : 1. ∀ i ≥ 1, νp, lsid P i .P i (p, lsid P i ) is O r -simulatable. 2. ∀ i ≥ 1, νp, lsid Q i .Q i (p, lsid Q i , s) is O r -simulatable.</formula><p>3. s is disjoint of the support of O.</p><p>4. P 0 (p, lsid</p><formula xml:id="formula_222">P 0 ) ∼ = Or,O Q 0 (p, lsid Q 0 , s) then, || i P i (p, lsid P i ) ∼ = O || i Q i (p, lsid Q i , s)</formula><p>Proof. By application of Theorem 5, we get that for all n 1 , n 2 ,</p><formula xml:id="formula_223">P 0 (p, lsid P 0 ) 1&lt;i≤N 1 P i (p, lsid P i ) 1&lt;i≤N 2 Q i (p, s, lsid Q i ) ∼ = Or,O Q 0 (p, s, lsid Q 0 ) 1&lt;i≤N 1 P i (p, lsid P i ) 1&lt;i≤N 2 Q i (p, s, lsid Q i )</formula><p>By weakening of the attacker, we get:</p><formula xml:id="formula_224">P 0 (p, lsid P 0 ) 1&lt;i≤N 1 P i (p, lsid P i ) 1&lt;i≤N 2 Q i (p, s, lsid Q i ) ∼ = O Q 0 (p, s, lsid Q 0 ) 1&lt;i≤N 1 P i (p, lsid P i ) 1&lt;i≤N 2 Q i (p, s, lsid Q i )</formula><p>Then, for a polynomial p (assumed without loss of generality increasing), any n = p(η), and all j &lt; n: P 0 (p, lsid P 0 ) 1&lt;i≤j-1 P i (p, lsid P i ) 1&lt;i≤N -j-1 Q i (p, s, lsid</p><formula xml:id="formula_225">Q i ) ∼ = O Q 0 (p, s, lsid Q 0 ) 1&lt;i≤j-1 P i (p, lsid P i ) 1&lt;i≤N -j-1 Q i (p, s, lsid Q i )</formula><p>Through the renaming of the lsid, which is possible as s is disjoint from the oracle support, we get that: P j (p, lsid  Thanks to Theorem 5, there exist polynomial p S such that, if p P and p Q are the polynomial bound on the runtime of the simulators for P or Q, for all j, we have that the advantage of any attacker running in time t against the previous indistinguishability, denoted D, is bounded by: Adv D p S t, j -1, |P |, . . . , p(η) -j -1, |q|, p P (t), . . . , p Q (t) Thus, for all j, the advantage of any attacker against the corresponding game is uniformly bounded by: Adv D p S t, p(η), |P |, . . . , p(η), |q|, p P (t), . . . , p Q (t)</p><p>We then conclude with an hybrid argument.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Then:</head><p>i≤N KE i [ if x I lsid / ∈ s R ∧ x I id = id R then S1(x I , lsid I , x I lsid , x I id ) else out( x I , lsid I , x I lsid , x I id ),</p><formula xml:id="formula_226">if x R lsid / ∈ s I ∧ x R id = id I then S 2 (x R , lsid R , x R lsid , x R id ) else out( x R , lsid R , x R lsid , x R id )] ∼ = O i≤N KE i [ if<label>1≤j≤N</label></formula><p>x I lsid = lsid R j ∧ x I id = id R then out( k i,j , lsid I i , x lsid , x id ) if x I lsid / ∈ s R ∧ x I id = id R then T 1 (x I , lsid I n , x lsid , x id ) else out( x I , lsid I , x I lsid , x I id ), if</p><formula xml:id="formula_227">1≤j≤N x R lsid = lsid I j ∧ x R id = id I ) then out( k j,i , lsid R i , x lsid , x id ) if x R lsid / ∈ s I ∧ x R id = id I then T 2 (x R , lsid R n , x lsid , x id ) else out( x R , lsid R , x R lsid , x R id )]</formula><p>Proof. We fix N and define an ordering (arbitrary) on the couples (i, j) 1≤i,j≤N . We then set:</p><p>G 0 (i,j) := r≤N KE r [ if (r,t)≥(i,j)</p><p>x I lsid = lsid R t ∧ x I id = id R then out( k r,t , lsid I r , x I lsid , x I id ) if (r,t)≥(i,j)</p><p>x I lsid / ∈ s R ∧ x I id = id R then T 1 (x I , lsid I r , x I lsid , x I id ) else if x I lsid / ∈ s R ∧ x I id = id R then S1(x I , lsid I , x I lsid , x I id ) else out( x I , lsid I , x I lsid , x I id ), if (t,r)≥(i,j)</p><p>x R lsid = lsid I t ∧ x R id = id I ) then out( k t,r , lsid R r , x R lsid , x R id ) if</p><formula xml:id="formula_228">(t,r)≥(i,j) x R lsid / ∈ s I ∧ x R id = id I then T 2 (x R , lsid R r , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then S 2 (x R , lsid R , x R lsid , x R id ) else out( x R , lsid R , x R lsid , x R id )]</formula><p>(r,s) =(i,j) I r (lsid I r , id I ); out( x I , lsid </p><formula xml:id="formula_229">) R j (lsid R j , id R )[ if x R lsid = lsid I i ∧ x R id = id I then out( k, lsid R i , x R lsid , x R id ) if x R lsid / ∈ s I ∧ x R id = id I then T 2 (x R , lsid R r , x R lsid , x R id ) else out( x R , lsid R i , x R lsid , x R id )</formula><p>We remark that, for any r: νs.in(x, y); if (r,t)&gt;(i,j)</p><p>x = lsid lsid R t ∧ x id = id R then out(k r,t , y) else out(x, y) and νs.in(x, y); if (t,r)&gt;(i,j)</p><p>x R lsid = lsid I t ∧ x id = id R then out(k t,r , y) else out(x, y) and (resp. with S 1 )</p><p>νs.in(y); if (r,t)&gt;(i,j)</p><p>x I lsid / ∈ s R ∧ x I id = id R then T 1 (y) and (resp. with S 2 )</p><p>νs.in(y); if (t,r)&gt;(i,j)</p><p>x R lsid / ∈ s I ∧ x R id = id I then T 2 (y)</p><p>are O s -simulatable by the attacker as all lsid R j , lsid I j are simulatable with O s They are then all simulatable in parallel at the same time (Theorem 1) and using function application (Theorem 4), we get: r≤N KE r [ if (r,t)&gt;(i,j)</p><p>x I lsid = lsid R t ∧ x I id = id R then out( k r,t , lsid I r , x I lsid , x I id ) if (r,t)&gt;(i,j)</p><p>x I lsid / ∈ s R ∧ x I id = id R then T 1 (x I , lsid I r , x I lsid , x I id ) else if x I lsid / ∈ s R ∧ x I id = id R then S1(x I , lsid I , x I lsid , x I id ) else out( x I , lsid I , x I lsid , x I id ), , if (t,r)&gt;(i,j)</p><p>x R lsid = lsid I t ∧ x R id = id I ) then out( k t,r , lsid R r , x R lsid , x R id ) if (t,r)&gt;(i,j)</p><p>x R lsid / ∈ s I ∧ x R id = id I then T 2 (x R , lsid R r , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then S 2 (x R , lsid R , x R lsid , x R id ) else out( x R , lsid R , x R lsid , x R id )] ∼ = O (r,s) =(i,j) I r (lsid r I , id I ); if (r,t)&gt;(i,j)</p><p>x I lsid = lsid R t ∧ x I id = id R then out( k r,t , lsid I r , x I lsid , x I id ) if (r,t)&gt;(i,j)</p><p>x I lsid / ∈ s R ∧ x I id = id R then T 1 (x I , lsid I r , x I lsid , x I id ) else if x I lsid / ∈ s R ∧ x I id = id R then S1(x I , lsid I , x I lsid , x I id ) else out( x I , lsid I , x I lsid , x I id )</p><p>R s (lsid s R , id R ); if (t,r)&gt;(i,j)</p><p>x R lsid = lsid I t ∧ x R id = id I ) then out( k t,r , lsid R s , x R lsid , x R id ) if (t,r)&gt;(i,j)</p><p>x R lsid / ∈ s I ∧ x R id = id I then T 2 (x R , lsid R s , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then S 2 (x R , lsid R s , x R lsid , x R id ) else out( x R , lsid R s , x R lsid , x R id ) I i (lsid i I , id I ); if (i,t)&gt;(i,j)</p><p>x I lsid = lsid R t ∧ x I id = id R then out( k r,t , lsid I i , x I lsid , x I id ) if x I lsid = lsid R j ∧ x I id = id R ) then out( k, lsid I i , x I lsid , x I id ) if (i,t)&gt;(i,j)</p><p>x I lsid / ∈ s R ∧ x I id = id R then T 1 (x I , lsid I i , x I lsid , x I id ) else if x I lsid / ∈ s R ∧ x I id = id R then S1(x I , lsid I i , x I lsid , x I id ) else out( x I , lsid I i , x I lsid , x I id ) R j (lsid j R , id R ); if (t,j)&gt;(i,j)</p><p>x R lsid = lsid I t ∧ x R id = id I ) then out( k t,r , lsid R j , x R lsid , x R id )</p><formula xml:id="formula_230">if x R lsid = lsid I i ∧ x R id = id I ) then out( k, lsid R j , x R lsid , x R id ) if (t,j)&gt;(i,j) x R lsid / ∈ s I ∧ x R id = id I then T 2 (x R , lsid R j , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then S 2 (x R , lsid R j , x R lsid , x R id ) else out( x R , lsid R j , x R lsid , x R id )<label>92</label></formula><p>After α-renaming k into k i,j , this is exactly G 1 (i,j) ∼ = G 0 (i,j) , which concludes the proof. Note that the advantage, for any (i, j), against G 1 (i,j) ∼ = G 0 (i,j) is bounded, using the bound from Theorem 4, by the the advantage against G 1 (0,0) ∼ = G 0 (0,0) , the case where the most things are simulated. is O ke simulatable)).</p><p>2. s is disjoint of the support of O.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>KE 0 [out( x I , lsid I 0 , x I lsid , x I id ), out( x R , lsid R 0 , x R lsid , x R id )] ∼ = O ke ,O KE 0 [ if x I lsid = lsid R 0 ∧ x I id = id R then out( k, lsid I 0 , x lsid , x id ) else if x I lsid / ∈ s R ∧ x I id = id R then ⊥ else out( x I , lsid I 0 , x I lsid , x I id ), if x R lsid = lsid I 0 ∧ x R id = id I then out( k, lsid R 0 , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then ⊥ else out( x R , lsid R 0 , x R lsid , x R id )] Then, for any N which depends on the security parameter:</p><formula xml:id="formula_231">i≤N KE i [out(x I ), out(x R )] ∼ = O i≤N KE i [ if (x I id = id R ) then if 1≤j≤N x I lsid = lsid R j ∧ x I id = id R then out(k i,j ) else out(x I ), if (x R id = id I ) then if 1≤j≤N</formula><p>x R lsid = lsid I j ∧ x R id = id I then out(k j,i ) else out(x R )]</p><p>Proof. Let us fix N , which may depend on the security parameter.</p><p>Ry direct application of Theorem 5, with P := I(lsid I , id I ); out( x I , lsid I , x I lsid , x I id ) R(lsid R , id R ); out( x R , l R := KE, and Q being the right handside of hypothesis (3), we get that: </p><formula xml:id="formula_232">i≤N KE i [</formula><formula xml:id="formula_233">if x R lsid = lsid I ∧ x R id = id I then out( k, lsid R , x R lsid , x R id ) else if x R lsid / ∈ s I ∧ x R id = id I then ⊥ else out( x R , lsid R , x R lsid , x R id )]</formula><p>This allows us to obtain the hypothesis of Proposition 39, where O s is instantiated with O ke . We thus conclude using Proposition 39.</p><p>Corollary 2. Let O T , O ke , O r ,O P,Q be oracles and KE i [_ 1 , _ 2 ] := I(lsid I i , id I ); _ 1 R(lsid R i , id R ); _ 2 a key exchange protocol, such that I binds x I , x I id , x I lsid , R binds x R , x R id , x R lsid and N l (KE) is disjoint of the oracle support. Let id I , id R be names, s I = {lsid I i } i∈N ,s R = {lsid R i } i∈N and s = s I ∩ s R sets of names. Let p = {id I , id R }, P (x, y) = P 1 (x, y) P 2 (x, y) and Q(x, y, z) = Q 1 (x, y, z) Q 1 (x, y, z) be parameterized protocols, such that N l (P, Q) is disjoint of the oracle support. I-1 ∀i ≥ 1, (νlsid I i , id x I lsid = lsid j R ∧ x I id = id R then out(k i,j ) else if x I lsid / ∈ s R ∧ x I id = id R then I 1 i (x I ); bad else out(x</p><formula xml:id="formula_234">I ) R 0 i (lsid R i , id R )[ if 1≤i≤N x R lsid = lsid j I ∧ x R id = id I then out(k j,i ) else if x R lsid / ∈ s I ∧ x R id = id I then R 1 i (x R ); bad else out(x R )</formula><p>Now, with this context, using twice using Theorem 4 with the simulatability of νp, lsid I i , lsid R i .D i (p) in(x).P i (x) in(x).I 1 i (x); P I i (x) in(x).R 1 i (x); P R i (x) from C-1, we may get that:</p><p>i≤N C i (p) D i (p) I 0 i (lsid I i , id I ); if x I lsid / ∈ s R ∧ x I id = id R then I 1 i (x I ); P I i (x I ) else I 1 i (x I );</p><formula xml:id="formula_235">P I i (x I ) R 0 i (lsid R i , id R ); if x R lsid / ∈ s I ∧ x id = id I then R 1 i (x R ); P R i (x R ) else R 1 i (x R ); P R i (x R ) ∼ = O P i≤N C i (p) D i (p) I 0 i (lsid I i , id I ); if 1≤j≤N x I lsid = lsid R j ∧ x I id = id R then I 1 i (k i,j ); P 1 i (k i,j ) else if x I lsid / ∈ s R ∧ x I id = id R then I 1 i (x I ); ⊥ else I 1 i (x I ); P I i (x I ) R 0 i (lsid R i , id R )[ if 1≤k≤m x R lsid = lsid I j ∧ x R id = id I then R 1 i (k j,i ); P R i (k j,i ) else if x R lsid / ∈ s I ∧ x R id = id I then R 1 i (x R ); ⊥ else R 1 i (x R ); P R i (x R )</formula><p>Proof. Let us write t P = t 0 P , . . . , t n P . Without loss of generality, we assume that every distinguisher makes exactly n calls to the oracle, if it is not the case we simply add dummy calls for the remaining ones.</p><p>We start by proving the top to bottom implication. Given a distinguisher B O,O P ?Q and η, ρ r , we let m 0 , . . . , m k (resp. m 0 , . . . , m k ) be the successive contents of the oracle input tape along the computation of A O(ρs,ρ O ),O P (ρs) (resp. A O(ρs,ρ O ),O Q (ρs) ). Let σ = {x 0 → m 0 , . . . , x k → m k } (resp. σ = {x 1 → m 1 , . . . , x k → m k }). Consider now the PPTOM A O g k , which, on input b 0 , . . . , b k , η, ρ r , executes the same code as B, however replacing the ith call to the oracle O P (resp. O Q ), i ≤ k, using b i instead of the oracle reply.</p><p>The )]] η ρs,ρr,ρ O ). We may now consider the PPTOM B O,O P ?Q , which :</p><p>• Set m 0 to the result of [[g 0 ()]] η ρs,ρr,ρ O .</p><p>• For i going from 0 to n -1:</p><p>set t i to the result of O P ?Q (m i )</p><p>set m i+1 to the result of [[g i+1 (t 0 , . . . , t i )]] σ P ,η ρs,ρr,ρ O )</p><p>• set t n to the result of O P ?Q (m n )</p><p>• outputs B O (t 0 , . . . , t n )</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>3 . 4 .</head><label>34</label><figDesc>Prefixes each random handle of an oracle call of D with 0 and random handle of an oracle call of A with 1. Outputs the final result of D. D[A O ] O must simulate A O and D so that they do not share randomness. To this end, D[A O ] O first splits its random tape ρ r into ρ r 1 (playing the role of ρ O ) and ρ r 2 (playing the role of ρ D ). The oracle queries are prefixed by distinct handles for the same reason. D O,O P has access to the shared secrets via both O and O P , while D[A O ] O only has access to them through the oracle O . Remark that if A O and D O,O P has a run-time polynomially bounded, so does D[A O ] O .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Game for Tagged Unforgeability (T-EUF-CMA)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Proposition 16 .</head><label>16</label><figDesc>If a signature scheme (Sign, Vrfy) is EUF-CMA secure for keys given by A sk , then (Sign, Vrfy) is T-EUF-CMA secure for the oracle O sign T,sk and the interpretation of keys A sk .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 4 . 1 .</head><label>41</label><figDesc>Let P, Q, R, S be protocols and O an oracle. Let n = N (P Q) ∩ N (R S). If P ∼ = O Q and νn.R S is O-simulatable, then some applications of Theorem 2 can yield 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: ISO 9798-3 Diffie Hellman Key Exchange</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: ISO 9798-3 Diffie Hellman Key Exchange in the Pi Calculus (omitted channels)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: SSH Key Exchange with Forwarding Agent</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Definition 26 .</head><label>26</label><figDesc>Given a name sk and a function T , we define the generic signing oracle O sign T,sk as follows: O sign T,sk (m) := if T (m) then output(sign(m, sk))) Proposition 27. For any computational model in which the interpretation of sign is EUF-CMA, any name sk, and any boolean function T , EUF-CMA T,sk is O sign T,sk -sound.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Protocol algebra</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Operational semantics of elementary protocols and sequential compositions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Operational Semantics of protocols</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>P</head><label></label><figDesc>(skP, pk(skS))[_] := new a; out(g a ); in(&lt; B, pk(skS), sign &gt;) let k = B a in let sid = hash(&lt; g a , B, k &gt;) in if checksign(sign, pk(skS)) ∧ getmess(sign) = sid then out(enc(sign(sid, skP ), k)) [_]. S(skS, pk(skP ))[_] := in(A); new b; let k = A b in let sid = hash(&lt; A, g b , k &gt;) in out(&lt; g b , pk(skS), sign(sid, skS) &gt;) in(enc(sign, k)) if checksign(sign, pk(skP )) ∧ getmess(sign) = sid then [_]. SSH :=!P (skP, pk(skS))[0] !S(skS, pk(skP ))[0]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>! n 2 P∼ =! n 2 P</head><label>22</label><figDesc>(skP, pk(skS)); F A(skP, k); S(skS, pk(skP )); P D(k, pk(skS)); Y (k P D ) SF (skS, pk(skP )); Z(k SF ) (skP, pk(skS)); F A(skP, k); S(skS, pk(skP )); P D(k, pk(skS)); Y (k P D ) SF (skS, pk(skP )); Z (k SF )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Pj</head><label></label><figDesc>) P 0 (p, lsid P 0 ) . . . P j-1 (p, lsidP j-1 ) Q j+1 (p, s, lsid Q j+1 ) . . . Q n (p, s, lsid Q n ) ∼ = O Q j (p, lsid Q j , s) P 0 (p, lsid P 0 ) . . . P j-1 (p, lsid P j-1 ) Q j+1 (p, s, lsid Q j+1 ) . . . Q n (p, s, lsid</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>as the PTOM that:1. Splits its random tape ρ r into ρ r 1 , ρ r 2 2. Simulates D O,O P (ρ r 2 , 1 η ) by replacing every call to O P with a computation of A O : each time D enters a state corresponding to a call to O P , D[A O ] appends the query m to a history θ (initially empty), executes the subroutine A O(ρs,ρ O ) (ρ r 1 , θ, 1 η ) and behaves as if the result of the subroutine was the oracle reply.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>• Simulates M(ρ rM , 1 η ) but every time M calls O Q with input u, the machine adds u to θ, and produces the output of O Q ((v, ρ rQ , 0), θ).</figDesc><table><row><cell>Such a machine runs in deterministic polynomial time (w.r.t. η). For any machine M O,O Q ,O P ,</cell></row><row><cell>we similarly define [M] O,O P n</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>* sends (i, t i ) to O P i and forwards the answer else forwards the answer of O D</figDesc><table><row><cell cols="3">With this construction, we do have</cell></row><row><cell>Adv B</cell><cell cols="2">O,O C 1 ?C 2 ,O P 1</cell><cell>,...,O P n = 0</cell></row><row><cell cols="4">Using Lemma 4, we get a distinguisher B such that:</cell></row><row><cell cols="2">Adv B</cell><cell cols="2">O,O C 1 ?C 2 ,O P 1 ... P n = 0</cell></row></table><note><p>and c / ∈ x then queries O D with (c, m) -if O D answers with some t i on channel i * set d i = 1 Now, with the fact that νn.P 1 . . . P n is O simulatable, we have a simulator A O P 1 ... P n such that thanks to Proposition 7, B [A O P 1 ... P n ] O,O D behaves exactly as B O,O P 1 ... P n ,O D . We finally have Adv B [A O P 1 ... P n ] O,O C 1 ?C 2 = 0 . The bound on the advantage is derived similarly to Theorem 2.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>With such a definition, if A is O-sound (w.r.t. F) and A |= φ (where φ is a closed formula), then, for every M ∈ F, M |= O φ. Example 10.1 (Function application). For any O, F, function f , terms t 1 , . . . , t n , u 1 , . . . , u n t 1 , . . . , t n ∼ u 1 , . . . , u n =⇒ f (t 1 , . . . , t n ) ∼ f (u 1 , . . . , u n ) is O sound. Example 10.2. Given a single key encryption oracle O for key k, the formula</figDesc><table /><note><p>Definition 21. Given a family of computational models F using oracle O, a set of first order formulas A is O-sound (w.r.t. F) if, for every ψ ∈ A, every M ∈ F, M |= O ψ.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>1 1 ) b And we have to prove that Ax |= φ 2 ∼ ψ 2 and Ax |= φ 1 2 ∼ ψ 1 2 .</figDesc><table><row><cell>D.3.1</cell><cell>Proof of Ax |= φ 2 ∼ ψ 2</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>With the oracles:• O P S allows to simulate (A-1) the other honnest sessions of P and S, it corresponds to O sign T P ,skS,s , O sign T S ,skP,s , O a i ,b i of Appendix D.4. • O f orward allows to simulate (C-1) the continuation, i.e the protocols of the form in(k); P</figDesc><table /><note><p><p>1 </p>(k); P D(k); Y SF ; Z 1 (k); F A(k) in(k); S 1 (k); P D(k); Y SF ; Z • O KE 1 allows to simulate (C-2) ! n 2 P S (it is similar to O P S ).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>η ρs = w} Thus νn ∪ m.t is O-simulatable. Proposition 17. Let O r be an oracle parameterized by a sequence of names s, and O an oracle. Let p be a sequence of names, P (x), R 1 i (x, y), . . . , R k i (x, y) and Q(x) be protocols, such that N l (R 1 i , . . . , R k i ) is disjoint of the oracle support. If we have, for sequences of names lsid 1 , . . . , lsid</figDesc><table /><note><p>k , with s = {lsid j i } 1≤j≤k,i∈N :</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>I r , x I lsid , x I id ) R s (lsid R s , id R ); out( x R , lsid R s , x R lsid , x R id ) I i (lsid I i , id I ); if x I lsid / ∈ s R ∧ x I id = id R then S1(x I , lsid I i , x I lsid , x I id ) else out( x I , lsid I i , x I lsid , x I id ), R j (lsid R j , id R )[ if x R lsid / ∈ s I ∧ x R id = id I then S 2 (x R , lsid R j , x R lsid , x R id ) else out( x R , lsid R j , x R lsid , x id ) ∼ = O,O s (r,s) =(i,j) I r (lsid I r , id I ); out( x I , lsid I r , x I lsid , x I id ) R s (lsid R s , id R ); out( x R , lsid R s , x R lsid , x R id ) I i (lsid I i , id I ); if x I lsid = lsid R j ∧ x I id = id R then out( k, lsid I i , x I lsid , x I id ) if x I lsid / ∈ s R ∧ x I id = id R then T 1 (x I , lsid Ir , x I lsid , x I id ) else out( x I , lsid I i , x lsid , x id</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>Corollary 1. Let O ke , O be oracles andKE i [_ 1 , _ 2 ] := I(lsid I i , id I ); _ 1 R(lsid R i , id R ); _ 2 a key exchange protocol, such that I binds x I , x I id , x I lsid , R binds x R , x R id , x R lsid and N l (KE) is disjoint of the oracle support. Let id I , id R be names and s I = {lsid I i } i∈N ,s R = {lsid R i } i∈N sets of names : 1. ∀i ≥ 1, (νlsid I i , id I , lsid R i , id R . KE i [out( x I , lsid I i , x I lsid , x I id ), out( x R , lsid R i , x R lsid , x R id )] out( lsid R i , lsid I i )</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head></head><label></label><figDesc>out( x I , lsid I i , x I lsid , x I id ), out( x R , lsid R i , x R lsid , x R id )] ∼ = O,O ke i≤N -1 KE i [out( x I , lsid I i , x I lsid , x I id ), out( x R , lsid R i , x R lsid , x R id )] KE 0 [ if x I lsid = lsid R ∧ x id = id R then out( k, lsid I , x lsid , x id ) else if x I lsid / ∈ s R ∧ x I id = id R then ⊥ else out( x I , lsid I , x I lsid , x I id ),</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16"><head></head><label></label><figDesc>I , lsid R i , id R .KE i [out(x I ), out(x R )] out( lsid R i , lsid I i ) is O T -simulatable)). I-2 s is disjoint of the support of O P,Q . KE 0 [out( x I , lsid I 0 , x I lsid , x I id ), out( x R , lsid R 0 , x R lsid , x R id ) ∼ = O T ,O P,Q KE 0 [if x I lsid = lsid R 0 ∧ x I id = id R then out( k, lsid I 0 , x I lsid , x I id ) else if x I lsid / ∈ s R ∧ x I id = id R then ⊥ else out( x I , lsid I 0 , x I lsid , x I id ), if x R lsid = lsid I ∧ x R id = id I then out( k, lsid R (p) I 0 i (lsid I i , id I ); if x I lsid / ∈ s R ∧ x I id = id R then I 1 i (x I ); out(x I ) else out(x I ) R 0 i (lsid R i , id R ); if x R lsid / ∈ s I ∧ x R id = id I then R 1 i (x R ); out(x R ) else out(x R ) ∼ = O P i≤N C i (p) I 0 i (lsid I i , id I ); if</figDesc><table><row><cell>1≤j≤N</cell></row><row><cell>I-3</cell></row><row><cell>0 , x R lsid , x R id ) ∈ s I ∧ x R lsid / else if x R id = id I then</cell></row><row><cell>⊥</cell></row><row><cell>else out( x R , lsid R 0 , x R lsid , x R id )]</cell></row></table><note><p><p>and</p>R-1 ∀ 1 ≤ i, j ≤ n, νp, k i,j .P 0 (p, k i,j ) is O r -simulatable. R-2 ∀ 1 ≤ i ≤ n, νp, k i,j .Q 0 (p, k i,j ) is O r -simulatable. R-3 s is disjoint of the support of O k . i≤N C i</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_17"><head></head><label></label><figDesc>result of A O g k is then what B would have queried at the k + 1 oracle call. It follows that A O g k (b 0 , . . . , b k , η, ρ r ) = m k (resp. m k ) if b i is the reply of O P (resp. O Q ) on the query m i , for i &lt; k. This defines an extension M of M f . Thanks to the Lemma 28, for every ρ s , ρ r , ρ O , for every i ≤ k, [[t i P ]] σ,η ρs,ρr,ρ O = O P (ρ s , m 0 , . . . , m i-1 ) and [[t i Q]] σ ,η ρs,ρr,ρ O = O Q (ρ s , m 1 , . . . , m i-1). Now, according to our definition of t P and thanks to the interpretation of g i , for every ρ s , ρ r , ρ O , for every i ≤ k, [[t i P ]] η ρs,ρr,ρ O = O P (ρ s , m 0 , . . . , m i-1 ) and [[ t i Q ]] η ρs,ρr,ρ O = O Q (ρ s , m 0 , . . . , m i-1). If we now consider the output of A O gn , we have that, for every ρ r , ρ O , A O gn ([[ t 0 P ]] η ρs,ρr,ρ O , . . . , [[ t k P ]] η ρs,ρr,ρ O , η, ρ r ) = B O,O P and A O gn ([[ t 0 Q ]] η ρs,ρr,ρ O , . . . , [[ t n Q ]] η ρs,ρr,ρ O , η, ρ r ) = B O,O Q . Thus, M f and A O gn form a distinguisher on t P ≈ M O t Q , which wins with the same probability as B. For the bottom to top direction, we are given a computational model M and a distinguisher B O on t P ≈ M O t Q . We consider φ P i and σ P as defined for t P , and φ Q i and σ Q as defined for t Q . Thanks to the Lemma 28, for every ρ s , ρ r , ρ O , for every i ≤ k, [[t i P ]] σ P ,η ρs,ρr,ρ O = O P (ρ s , [[g 0 ()]] σ P ,η ρs,ρr,ρ O , . . . , [[g i-1 (φ P i-1 )]] σ P ,η ρs,ρr,ρ O ) Then, with the definition of t P , we have for every ρ s , ρ r , ρ O , for every i ≤ k, [[ t i P ]] η ρs,ρr,ρ O = O P (ρ s , [[g 0 ()]] η ρs,ρr,ρ O , . . . , [[g i-1 (φ P i-1 )]] η ρs,ρr,ρ O ) and [[ t i Q ]] η ρs,ρr,ρ O = O Q (ρ s , [[g 0 ()]] η ρs,ρr,ρ O , . . . , [[g i-1 (φ Q i-1</figDesc><table><row><cell>and [[t i Q ]]</cell></row></table><note><p><p>σ Q ,η ρs,ρr,ρ O = O Q (ρ s , [[g 0 ()]] σ Q ,η ρs,ρr,ρ O , . . . , [[g i-1 (φ Q i-1 )]] σ Q ,η</p>ρs,ρr,ρ O ).</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This corresponds in the CCSA model to the notion of functional model.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>They actually also depend on the oracle's coins, when A is interacting with an external oracle, which we explain later.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>We provide, in this Theorem and the following ones, explicit advantages, as our constructions do not directly allow for unbounded replication. This will later be used to ensure that the advantage of the adversary only grows polynomially with respect to the number of sessions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>Unbounded Sequential ReplicationWe replicate a sequential composition where at each occurrence, a value produced by the protocol is transmitted to the next occurrence. This corresponds to the security of a protocol looping on itself, as it is the case for some key renewal protocols.Such protocols depend on an original key, and are thus parameterized process of the form P (x). As they renew the key stored in the variable x, they rebind x to some new value and thus contain a construct of the form let x = _ in .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>we denote if 1≤j≤N ci then ai else a := if c1 then a1 else if c2 • • • then an else a</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>We also use Theorem 1 to get the simulatability of N sessions in parallel from the simulatability of each session.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The folding soundness from <ref type="bibr" target="#b10">[11]</ref> implies that P ∼ M fold(P ). The proof actually implies pointwise equality of the executions of P and fold(P ) in M. If we denote ψ(P ) (resp ψ(fold(P ))) the sequence of outputs of the execution of P (resp fold(P )) in this model, we thus have that ψ(P ) = ψ(fold(P )).</p><p>We directly have by definition of the t P that [[t P ]] M = [[Φ(fold(P )]] M = ψ(fold(P )). Finally, by construction of O P which emulates exactly the execution of P we have ψ(P ) = O P (ρ s , ∅)(d 1 (ρ s , ρ r , η, ρ O )), . . . , O P (ρ s , d 1 (ρ s , ρ r , η, ρ O ), . . . , d n-1 (ρ s , ρ r , η, ρ O ))(d n (ρ s , ρ r , η, ρ O )) which concludes the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.2">Introduction of attacker's functions</head><p>As in <ref type="bibr" target="#b10">[11]</ref>, we may replace the variables occurring in the protocol P (or its folding t P ) with terms that include the attacker functions g ∈ G.</p><p>If t P = t 0 P , . . . , t n P , we let t P = t 0 P , . . . , t n P be the sequence of terms defined by:</p><p>• t 0 P = t 0 P {x 0 → g 0 ()} and φ P 0 = ∅</p><p>• t i+1 P = t i+1 P {x 0 → g 0 (), x 1 → g 1 (φ P 1 ), . . . , x i+1 → g i+1 (φ P i+1 )} and φ P i+1 = φ P i , t i+1 P</p><p>We then denote σ P the substitution {x 0 → g 0 (), x 1 → g 1 (φ P 1 ), . . . , x n → g n (φ P n )}. There is exactly one attacker function for every message produced by the protocol, and the function symbol are defined independently from the protocol.The functions are placeholder for the attacker actions, whom we give the previous answers he may have obtained in the protocol.</p><p>Example 11.1. We consider the protocol which for a given key sk, will allow the attacker to perform one decryption and will then output an encryption. We may have t P = dec(x, sk), enc(y, r, sk), where x and y are the two expected inputs. Then t P = dec(g 0 ()), sk), enc(g 1 (dec(g 0 ()), sk) When we interpret this term, the attacker can choose the evaluation of g 0 and g 1 . He can at first provide the protocol with a message and obtain its decryption, and can then compute a new message, maybe based on the previous decryption he obtained.</p><p>Once we have fixed the cryptographic library, and we consider two protocols P and Q, a computational such that t P ∼ t Q means that we have multiple PPTOMs which can compute messages so that in the end, a final PPTOM can distinguish the two protocols. We may from those machines reconstruct a single machine, which is an attacker against P ∼ = O Q. Conversely, an attacker against P ∼ = O Q may be split into multiple machines, so that a machine computes the next message given by the attacker to the protocol, those machines providing in the end a computational model such that t P ∼ t Q .</p><p>Formally, we have the computational soundness of our oracle indistinguishability.</p><p>Lemma 29. Given two protocols P, Q, random tapes ρ r , ρ s , a cryptographic library M f and an oracle O, we have:</p><p>We finally have a result of computational soundness. We write Ax |= φ if the set of formulas Ax and the formula ¬φ are inconsistent. M,p,ρs;ρr;ρ O , ρ r , 1 η ) = 1}| is negligible in η. Here, ρ s , ρ r , ρ O are drawn according to a distribution such that every finite prefix is uniformly sampled. So, we can now assume that the interpretation of terms may depend on a polynomial p. We previously assumed for a name n i , that the cryptographic library was providing a distinct Turing Machine for each copy of the name, i.e., a machine A n k for each k ∈ N. However, to build a machine that can interpret seq n , all the copies of the name must be extracted in a uniform way, so that it is possible to collect all of them in polynomial time. To this end, we now consider that a cryptographic library provides, for each name n i of index arity l, a Turing Machine A n that takes as input the security parameter, the random tape ρ S and l integers, and returns a sequence of bitstrings of length η extracted from ρ s . Then, the interpretation of the name n k 1 ,...,k l , with k 1 , . . . , k l ∈ N is, given M, η, σ, ρ s , ρ O and ρ r .</p><p>The set of all the A n should use distinct parts of the random tape ρ s , and each A n should return distinct parts of the tape for each sequence of integers given as integers. This can be done for instance if ρ s is seen as a folding of random tapes ρ s,n in a single tape, such that each A n only accesses bits corresponds to ρ s,n through the inverse folding (this essentially corresponding to bijective mappings from N k to N). Then, for each sequence of integers k 1 , . . . , k l , A n extracts from ρ s,n a unique sequence of bits by computing a bijection f from N l to N, and extracting the bitstrings of length η at position η × f (k 1 , . . . , k l ).</p><p>Using this new interpretation for names, we now define the semantics of seq n , for any name n of index arity l, as, given M (that now contains a polynomial p), η, σ, ρ s , ρ O and ρ r ,</p><p>where A seq n is the machine that:</p><p>• contains l nested loops over the l variables c 1 , . . . , c l all ranging from 1 to p(η);</p><p>• at each iteration, simulate A n (1 η , ρ s , c 1 , . . . , c l ) and appends its result to the output tape.</p><p>Remark that given a model M, and thus the machine A n , we completely fix the machine A seq n . Essentially, A seq n will produce the sequence of bitstring corresponding to the interpretation of n 1,...,1 , . . . , n p(η),...,p(η) .</p><p>The CCSA axioms presented previously are still sound in this semantics. Essentially, this is because when the axiom scheme does not depend on any seq n , all the occurrences of seq n in terms satisfying the guards of the scheme can be simulated by an attacker who samples p(η) randoms.</p><p>Lemma 31. For any computational model in which the interpretation of sign is EUF-CMA, any name sk, EUF-CMA T,sk is O sign T,sk -sound even for terms that may depend on some seq n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Messages</head><p>Protocols and oracles produce messages depending on names, randomness and some cryptographic primitives. We define here formally a syntax and a semantic for such messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Syntax of messages</head><p>We build terms over F a set of function symbols, which will represent the honest function symbols (encryption symbol, decryption), a set of variables X (unknown terms), and a set of names N , intended to denote respectively the secret and public names. Names may be sorted, for instance to capture what is a secret key and what is a randomness.</p><p>Example A.1. We define F := {enc/3, dec/2} an encryption scheme, N = {k, r} a secret key, a key and a randomness. Then, with mess an arbitrary term t 1 = enc(mess, k, r) represents the encryption of an arbitrary message, and dec(t 1 , k) represents its decryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Semantics of terms</head><p>We wish to describe protocols (i.e messages) as terms, whose interpretation must be fixed and deterministic. This allows us to obtain an interpretation, which is uniform, and we provide this interpretation with explicit randomness.</p><p>Messages will thus be interpreted as deterministic PPT, which takes as inputs:</p><p>• ρ s , a random tape for secret names (e.g secret keys)</p><p>• 1 η , the security parameter Let D be the set of such PPT, called messages.</p><p>A cryptographic library M f is a mapping [[•]] M f that interprets the function symbols, names and closed terms in the set of messages. The index M f is omitted unless there is some ambiguity, in order to avoid overloaded notations. [[•]] M is defined as follows:</p><p>We will often need to consider that we may have several protocol oracles for one PPTOM. We thus define a way to compose together oracles and protocol oracles. Protocol oracles can be merged together only if their respective protocols do not share input channels.</p><p>Definition 36. For any n and protocols P 1 , . . . , P n such that ∀1 ≤ i &lt; j ≤ n.C(P i )∩C(P j ) = ∅, we define the oracle &lt; O P 1 , . . . , O Pn &gt; (ρ s , θ) which on input query:</p><p>• check if its input is of the form query := (channel, mess);</p><p>• computes i such that channel ∈ C(P i ), and reject if there is no such i;</p><p>• computes θ i the projection of its history such that θ i = {(channel, mess) ∈ θ|channel ∈ C(P i )};</p><p>• return the value of O P i (ρ s , θ i )(mess).</p><p>We will often write A O P 1 ,...O Pn (ω, ρ r ) for A &lt;O P 1 ,...O Pn &gt; (ω, ρ r ).</p><p>We may then use PPTOM with multiple oracles and multiple protocol oracles, written</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C A case study : signed DDH</head><p>We apply our framework to the ISO 9798-3 protocol. It was proven UC composable in <ref type="bibr" target="#b12">[13]</ref>. With our framework, it could be composed even with an oracle which uses the same long term secret. We also note that our proof could be mechanized, as it is performed in a first order logic. With only one session and if we prioritise the outputs, there are three interleaving, with corresponding frames φ 3 , ψ 3 and χ 3 : φ 0 := pk(sk I ), g a φ 1 := φ 0 , (pk(sk R ), g b , sign((g 0 (φ 0 ), g b , g 1 (φ 0 )), sk R )) φ 2 := φ 1 , if checksign(g 4 (φ 1 ), g 2 (φ 1 )) ∧ g 3 (φ 1 ) = π 2 (getmess(g 4 (φ 1 ))) then if π 1 (getmess(g 4 (φ 1 ))) = g a ∧ π 3 (getmess(g 4 (φ 1 ))) = pk(sk I ) then sign((g 3 (φ 1 ), g a , g 2 (φ 1 )), sk I ),</p><p>if π 1 (getmess(g 5 (χ 2 ))) = g a ∧ π 3 (getmess(g 5 (χ 2 ))) = pk(sk I ) then sign((g 4 (χ 2 ), g a , g 3 (χ 2 )), sk I ), _ A</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1 Key exchange security</head><p>We show how to apply Corollary 1. We will use id I = sk I , id R = sk R , lsid I = g a and lsid R = g b . Then, for any n we set s = a 1 , b 1 , . . . , a n , b n . We define the functions:</p><p>where O s simply reveals the exponents of the elements in s.</p><p>We fix KE(sk</p><p>We remark that proving at the end of the protocol that (k I , g a , olsid, oid) is indistinguishable to (k, g a , olsid, oid) is equivalent to proving that k I is indistinguishable from k, as the other elements are public information.</p><p>To apply the Corollary, it remains to prove that:</p><p>3.</p><p>The simulatability also instantly follows from the definitions, as the attackers as access to the a i and b i , and can produce signatures on them (but only on them).</p><p>We only provide the proof for the most difficult frame φ 3 , where the attacker has the most knowledge for each computation. ψ 3 and χ 3 can be handled exactly the same way, except that on applications of the EUF-CMA axioms, the attacker does not have the honest signatures in the frame (as the order of the agents has been mixed up), which simplify the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 Proof for φ 3</head><p>We from now on omit Ax.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2.1 Real or random of the key</head><p>The real or random goal is:</p><p>There are by case disjunctions four possible cases, the first one being:</p><p>Note that a, b is not included in s, sk I , sk R , we can thus use the DDH axiom on them. Looking at φ 3 τ , we also see that all occurences of a and b are of the form g a or g b . Thus applying DDH directly gives us:</p><p>We conclude by renaming of g c into k.</p><p>The second case is:</p><p>Here, we actually prove that we never go into the branch which reveals either the g 3 (φ 1 ) a or the k, thus yielding the equivalence.</p><p>We thus prove that:</p><p>We have by application of the equalities:</p><p>We now apply EUF-CMA T R ,F,sk R ,s to g 4 (φ 1 ), so we either have g 4 (φ 1 ) = sign((g 0 (φ 0 ), g b , g 1 (φ 0 )), sk R ) (the honest signature), which is a contradiction with g 0 (φ 0 ) = g a and π 1 (getmess(g 4 (φ 1 ))) = g a , or the signature comes from the oracle and g 4 (φ 1 ) = (A, g b i , A ), in contradiction with g b = π 2 (getmess(g 4 (φ 1 ))).</p><p>We thus have:</p><p>And we conclude by transitivity.</p><p>Of the two remaining cases, one is symmetrical to the previous one, and the last one is trivial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2.2 Authentication</head><p>The goal is:</p><p>We prove that each condition is never true using the EUF-CMA axioms. The four cases are symmetrical, we only prove the first one:</p><p>SF orward(skS, pk(skP</p><p>SSH F orward := P (skP, pk(skS)); F orwardAgent(skP, k) SF orward(skS, pk(skP )) S(skS, pk(skP )); P Distant(k, pk(skS))</p><p>Figure <ref type="figure">14</ref>: SSH key exchange with agent forwarding</p><p>∧ getmess(sign) = sid then out(enc(sign(sid, skP ), k)) 0.</p><p>S 0 (b, skS, pk(skP</p><p>∧ getmess(sign) = sid then 0.. Then, we may obtain the simulatability with:</p><p>This difficulty actually stems from a well known weakness in the agent forwarding. When a user logs on a remote server, he set up on the server a socket which allows to ask for any signature. If another user has privileged access to the server, he may also use the socket, and obtain a signature for any session. In our model, we assume that only honest sessions of forwarder P can access an agent, which allows us to prove the security. Providing a proof of SSH without this modification still represent a challenge regarding composition. Now, the proof of A-3 is instantly derived from the proof performed in Appendices D.3 and D.4, where we replace for instance EUF-CMA T P ,skP,s with EUF-CMA T P ∨T P ,skP,s . The proofs will work as previously, based on the remark that T P ( getmess(sign), s) is incompatible for instance with getmess(sign) = hash(&lt; g a , B, B a &gt;).</p><p>The difficulty now lies in proving the security of what we do after the first SSH key exchange, i.e proving Hypothesis B-1. This is where we apply once again Corollary 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E.1.2 Second application of Corollary 3</head><p>We wish to prove that:</p><p>We use as hypothesis: A-3:</p><p>Note that the k used here is a fresh name, which could be considered as a long term secret, i.e inside p. We may prove this without considering P 1 and S 1 , and replacing them by oracles which can simulate them. The proof of A-3 can once again be derived from the proof performed in Appendices D.3 and D.4. Note that here, the proof is greatly simplified because our modified Corollary 3. Let O KE , O r ,O P,Q be oracles and</p><p>a key exchange protocol with I i (lsid I i , id I ) := I 0 i (lsid I i , id I );</p><p>) such that I 0 binds x I , x id , x lsid , R 0 binds x R , x id , x lsid and N l (KE) is disjoint of the oracles support. Let p = {id I , id R }, P i (x, y)</p><p>Let id I , id R be names,</p><p>and for any N which may depend on the security parameter:</p><p>Then, for any n:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.3 Oracle Simulation</head><p>We first show that O-simulation, whose definition implies the identical distributions of two messages produced either by the simulator of by the oracle, implies the equality of distributions of message sequences produced by either the oracle or the simulator.</p><p>Lemma 9. Given a cryptographic library M f , a sequence of names n, an oracle O with support n and a protocol P , that is O-simulatable with A O , we have, for every x, y, c, r 2 , r B ∈ {0, 1} , every v ∈ D η n , for every m ≥ 1, for every PTOM B O (using tags prefixed by 1): Proof. We proceed by induction on m. Let us fix x, y, c, r 2 , r B ∈ {0, 1} and v ∈ D η n . We assume that:</p><p>Using conditional probabilities, we have that:</p><p>We then have:</p><p>Justified with:</p><p>1. using the conditional probabilities; 2. by definition of B which produces x under the conditional events; 3. using conditional probabilities, as</p><p>4. by O simulatability on B; 5. using (i);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">using conditional probabilities, as</head><p>7. by definition of B which produces x under the conditional events; 8. using the conditional probabilities.</p><p>Combining the previous equality with equation (i) finally yields through conditional probabilities:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.4 Autocomposition Results</head><p>Proposition 18. Let O be an oracle, two parameterized processes P (x), Q(x), a set of names n = N g (P, Q) and fresh names k 0 , l. We assume that N l (P, Q) is disjoint of the support of O.</p><p>If:</p><p>• νn.in(c P , x); P (x) in(c Q , x); Q(x) is O-simulatable, and</p><p>then, for any N,</p><p>Proof. We proceed by induction on N . The result is exactly the first hypothesis for N = 0. Given some N &gt; 1, we assume that</p><p>In the following, we will write P (k i ) ;N -1 for P (k i ); P (k) ;N -2 and we will omit to mention the α-renaming made over the local names in N l (P, Q) between the different copies of P and Q. The renaming is however essential so that we may for instance have N l (P N -1 (k)) ∩ N l (P ) = ∅ when we wish to apply Theorem 4. This silent renaming is possible because N l (P, Q) is not contained in the support of O.</p><p>We obtain by application of Theorem 4 with A = P (k i ) ;N -1 , B = Q(k i ) ;N -1 , P 1 (x) := P (x) ;0 ; out(k) and P 2 (x) := Q(x) ;0 ; out(k):</p><p>Now, with Theorem 2 applied on P (l) ;0 ; out(k) Q(l) ;0 ; out(k) ∼ = O P (l) ;0 ; out(l ) Q(l) ;0 ; out(l ) with l a fresh name, with P := P (k i ) ;N -1 and Q := Q(k i ) ;N -1 , we obtain:</p><p>We also perform an application of Theorem 4 on (i) with</p><p>We conclude by transitivity with (I),(II) and (III).</p><p>Simulatability is stable by binding names that do not appear in the protocol, which means that we will be able simulate at the same times two simulatable protocol who do not share long term secret.</p><p>Lemma 37. Given a cryptographic library M f , a sequence of names n, an oracle O with support n and a sequence of terms t, if νn.t is O-simulatable , then for any sequence of names</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.5 Key Exchanges</head><p>We first prove a proposition which allows to reduce the security of n sessions in parallel to the security of one session with N -1 sessions in parallel. It is expressed in a more general way than required for basic key exchanges, so that we can reuse it for other results.</p><p>Proposition 39. Let O be an oracle and</p><p>Let T 1 (x),T 2 (x), S 1 (x),S 2 (x) be parametric processes with completely disjoint names. Let N be an integer (which may depend on η), and let</p><p>and</p><p>, that G 0 (0,0) is the game on the right hand side of the goal, and that G 0 (n,n) is the game on the left hand side of the goal. Thus, if we have uniformly that G 1 (i,j) ∼ = G 0 (i,j) , we can conclude with a classical hybrid argument.</p><p>We remark that G 1 (i,j) and G 0 (i,j) only differ in two places, where a conditional is added in I i and one in R j .</p><p>Let us fix (i, j), we define the substitution σ :</p><p>and denote s = sσ. We apply the substitution both to the oracle and the protocol, and the hypothesis allows us to get, for all N : R-4 P 0 (p, k) ∼ = Or,O ke Q 0 (p, k) and C-1 νp.in(x I i ).</p><p>1. νp.</p><p>is O ke -simulatable.</p><p>Then, for any n which may depend on the security parameter:</p><p>Proof. Using Corollary 1 on hypothesis A-1,A-2 and A-3, we get that, for all N :</p><p>Now, as νp, lsid I i , lsid R i .in(x).P (x) in(x).Q(x) is O p -simulatable (hypothesis C-1), using twice Theorem 4 we get that :</p><p>Moreover, using Theorem 5 on hypothesis B-1,B-2,B-3 and B-4, we get that</p><p>Combined with Theorem 2 on the O k simulatability of the key exchange (hypothesis C-2) we get:</p><p>We thus conclude with transitivity. </p><p>a key exchange protocol with I i (lsid I i , id I ) := I 0 i (lsid I i , id I );</p><p>) such that I 0 binds x I , x id , x lsid , R 0 binds x R , x id , x lsid and N l (KE) is disjoint of the oracles support. Let p = {id I , id R }, P i (x, y) = P I i (x, y) P R i (x, y),Q(x, y, z) = Q I i (x, y, z) Q R i (x, y, z), C i (z) and D i (z) be protocols, such that N l (P, Q, C, D) is disjoint of the oracles support.</p><p>Let id I , id R be names, s</p><p>and for any N which may depend on the security parameter:</p><p>Then, for any n:</p><p>Proof. Let N an integer, which may depend on the security parameter. Ry application of Theorem 5, with P and R as the left handside of hypothesis A-3, and Q being the right handside of hypothesis A-3, we get that:</p><p>We can simplify the left handside of the equivalence and get that:</p><p>Ry performing the same operation with Q, we can also get:</p><p>To conclude with transitivity, we must prove the equivalence between the two idealized version with either P or Q.</p><p>Combining Hypothesis B-1 with Theorem 2 on the O k simulatability of the key exchange (hypothesis C-2) we do get the necessary equivalence to conclude: i≤N C i (p) D i (p) I 0 i (lsid I i , id I ); if 1≤j≤N</p><p>x I lsid = lsid R j ∧ x id = id R then I 1 i (k i,j ); P 1 i (k i,j ) else if x I lsid / ∈ s R ∧ x I id = id R then I 1 i (x I ); bad else I 1 i (x I );</p><p>F.6 Computational soundness </p><p>The desired result then immediately follows.</p><p>Lemma Proof. We are given a cryptographic library, and oracle O with support n, and two names k, k not in the support. We are given a A O which is a distinguisher over k ∼ k . We define a PPTTM A which on input (m, ρ r , 1 η ) :</p><p>• Splits ρ r into three distinct infinite tapes ρ so , ρ ra , ρ ro</p><p>• Simulates A O(ρso,ρro) (m, ρ ra , 1 η )</p><p>Let us a prove that A is a distinguisher over k ∼ k , which contradicts the unconditional soundness of this axiom when there is no oracle. We denote π k (ρ s , η) the tapes where every bit of ρ s which does not correspond to a name of k is set to 0, and similarly π k c (ρ s , η) where all bits for k are set to 0. We then have for any PPTOM This shows that A has the same advantage as A O against k ∼ k , which concludes the proof.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Universally Composable Security: A New Paradigm for Cryptographic Protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2000/067" />
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Universal Composition with Joint State</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2003</title>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Boneh</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="265" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Reactive Simulatability (RSIM) Framework for Asynchronous Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Waidner</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ic.2007.05.002</idno>
		<ptr target="http://dx.doi.org/10.1016/j.ic.2007.05.002" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">205</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1685" to="1720" />
			<date type="published" when="2007-12">Dec. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">GNUC: A New Universal Composability Framework</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00145-013-9160-y</idno>
		<ptr target="https://doi.org/10.1007/s00145-013-9160-y" />
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="423" to="508" />
			<date type="published" when="2015-07">Jul. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Conditional reactive simulatability</title>
		<author>
			<persName><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dürmuth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hofheinz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Küsters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Inf. Sec</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="155" to="169" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">iUC: Flexible Universal Composability Made Simple</title>
		<author>
			<persName><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Krenn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Küsters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rausch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tech. Rep</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Constructive cryptography -A new paradigm for security definitions and proofs</title>
		<author>
			<persName><forename type="first">U</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">TOSCA, ser. Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">6993</biblScope>
			<biblScope unit="page" from="33" to="56" />
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Less is more: relaxed yet composable security notions for key exchange</title>
		<author>
			<persName><forename type="first">C</forename><surname>Brzuska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warinschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10207-013-0192-y</idno>
		<ptr target="https://doi.org/10.1007/s10207-013-0192-y" />
	</analytic>
	<monogr>
		<title level="j">International Journal of Information Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="267" to="297" />
			<date type="published" when="2013-08">Aug. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Composition Theorems for CryptoVerif and Application to TLS 1.3</title>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st IEEE Computer Security Foundations Symposium (CSF&apos;18)</title>
		<meeting><address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2018-07">Jul. 2018</date>
			<biblScope unit="page" from="16" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">State separation for code-based game-playing proofs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Brzuska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Delignat-Lavaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kohbrok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT (3)</title>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">11274</biblScope>
			<biblScope unit="page" from="222" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A computationally complete symbolic attacker for equivalence properties</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Comon-Lundh</surname></persName>
		</author>
		<ptr target="http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/BC-ccs14.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM Conference on Computer and Communications Security (CCS&apos;14)</title>
		<editor>
			<persName><forename type="first">G.-J</forename><surname>Ahn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">N</forename><surname>Li</surname></persName>
		</editor>
		<meeting>the 21st ACM Conference on Computer and Communications Security (CCS&apos;14)<address><addrLine>Scottsdale, Arizona, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2014-11">Nov. 2014</date>
			<biblScope unit="page" from="609" to="620" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The Secure Shell (SSH) Transport Layer Protocol</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ylonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lonvick</surname></persName>
		</author>
		<ptr target="https://tools.ietf.org/html/rfc4253" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Framework for Universally Composable Diffie-Hellman Key Exchange</title>
		<author>
			<persName><forename type="first">R</forename><surname>Küsters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Rausch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 38th Symposium on Security and Privacy (S&amp;P 2017)</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="881" to="900" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Analysis of Key Wrapping APIs: Generic Policies, Computational Security</title>
		<author>
			<persName><forename type="first">G</forename><surname>Scerri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-O</forename><surname>Ryan</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-01417123" />
		<imprint>
			<date type="published" when="2016-06">Jun. 2016</date>
			<publisher>IEEE Computer Society</publisher>
			<biblScope unit="page" from="281" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Formal Computational Unlinkability Proofs of RFID Protocols</title>
		<author>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Koutsos</surname></persName>
		</author>
		<ptr target="http://ieeexplore.ieee.org/document/8049714/" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th IEEE Computer Security Foundations Symposium (CSF&apos;17)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Köpf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Chong</surname></persName>
		</editor>
		<meeting>the 30th IEEE Computer Security Foundations Symposium (CSF&apos;17)<address><addrLine>Santa Barbara, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2017-08">Aug. 2017</date>
			<biblScope unit="page" from="100" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Formal Analysis of Vote Privacy Using Computationally Complete Symbolic Attacker</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chadha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Eeralla</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-98989-1_18</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-98989-1_18" />
	</analytic>
	<monogr>
		<title level="m">Computer Security -23rd European Symposium on Research in Computer Security, ESORICS 2018</title>
		<meeting><address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">September 3-7, 2018. 2018</date>
			<biblScope unit="page" from="350" to="372" />
		</imprint>
	</monogr>
	<note>Part II</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<idno>ISO/IEC 9798-3:2019</idno>
		<ptr target="https://www.iso.org/standard/67115.html" />
		<title level="m">IT Security techniques -Entity authentication -Part 3: Mechanisms using digital signature techniques</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Composability of Bellare-rogaway Key Exchange Protocols</title>
		<author>
			<persName><forename type="first">C</forename><surname>Brzuska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warinschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
		<idno type="DOI">10.1145/2046707.2046716</idno>
		<ptr target="http://doi.acm.org/10.1145/2046707.2046716" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Conference on Computer and Communications Security, ser. CCS &apos;11</title>
		<meeting>the 18th ACM Conference on Computer and Communications Security, ser. CCS &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="51" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Multi-Stage Key Exchange and the Case of Google&apos;s QUIC Protocol</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fischlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Günther</surname></persName>
		</author>
		<idno type="DOI">10.1145/2660267.2660308</idno>
		<ptr target="http://doi.acm.org/10.1145/2660267.2660308" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, ser. CCS &apos;14</title>
		<meeting>the 2014 ACM SIGSAC Conference on Computer and Communications Security, ser. CCS &apos;14<address><addrLine>New York, NY, USA; Scottsdale, Arizona, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1193" to="1204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Composition Theorems Without Pre-established Session Identifiers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Küsters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
		<idno type="DOI">10.1145/2046707.2046715</idno>
		<ptr target="http://doi.acm.org/10.1145/2046707.2046715" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Conference on Computer and Communications Security, ser. CCS &apos;11</title>
		<meeting>the 18th ACM Conference on Computer and Communications Security, ser. CCS &apos;11<address><addrLine>New York, NY, USA; Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A Compositional Logic for Proving Security Properties of Protocols</title>
		<author>
			<persName><forename type="first">N</forename><surname>Durgin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pavlovic</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=959088.959095" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Secur</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="677" to="721" />
			<date type="published" when="2003-07">Jul. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Probabilistic Polynomial-Time Semantics for a Protocol Security Logic</title>
		<author>
			<persName><forename type="first">A</forename><surname>Datta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Derek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Turuani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Caires</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">F</forename><surname>Italiano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">L</forename><surname>Monteiro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Palamidessi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Yung</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="16" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On the Protocol Composition Logic PCL</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cremers</surname></persName>
		</author>
		<idno type="DOI">10.1145/1368310.1368324</idno>
		<ptr target="http://doi.acm.org/10.1145/1368310.1368324" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 ACM Symposium on Information, Computer and Communications Security, ser. ASIACCS &apos;08</title>
		<meeting>the 2008 ACM Symposium on Information, Computer and Communications Security, ser. ASIACCS &apos;08<address><addrLine>New York, NY, USA; Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="66" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Analysis of the SSH Key Exchange Protocol</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptography and Coding</title>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="356" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">From Computationally-Proved Protocol Specifications to Implementations and Application to SSH</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cadé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Wireless Mobile Networks, Ubiquitous Computing, and Dependable Applications (JoWUA)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="4" to="31" />
			<date type="published" when="2013-03">Mar. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">CryptoVerif: A Computationally Sound Mechanized Prover for Cryptographic Protocols</title>
		<author>
			<persName><forename type="first">B</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Dagstuhl seminar &quot;Formal Protocol Verification Applied</title>
		<imprint>
			<date type="published" when="2007-10">Oct. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A method for proving observational equivalence</title>
		<author>
			<persName><forename type="first">V</forename><surname>Cortier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Delaune</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 22nd IEEE Computer Security Foundations Symposium</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="266" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Verifying Privacy-Type Properties in a Modular Way</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arapinis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Cheval</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Delaune</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 IEEE 25th Computer Security Foundations Symposium</title>
		<imprint>
			<date type="published" when="2012-06">Jun. 2012</date>
			<biblScope unit="page" from="95" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the Joint Security of Encryption and Signature, Revisited</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C N</forename><surname>Schuldt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thomson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -ASIACRYPT 2011</title>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="161" to="178" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
