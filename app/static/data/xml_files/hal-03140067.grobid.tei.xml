<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provenance-Based Algorithms for Rich Queries over Graph Databases</title>
				<funder>
					<orgName type="full">French government</orgName>
				</funder>
				<funder ref="#_mBkKNCT">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
							<email>yann.ramusat@ens.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
							<email>silviu.maniu@lri.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Universit√© Paris-Saclay</orgName>
								<orgName type="institution" key="instit2">LRI</orgName>
								<orgName type="institution" key="instit3">CNRS Gif-sur-Yvette</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
							<email>pierre@senellart.com</email>
							<affiliation key="aff2">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria &amp; IUF Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Provenance-Based Algorithms for Rich Queries over Graph Databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C6492FA613BFC0703EC9842E9369D81A</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we investigate the efficient computation of the provenance of rich queries over graph databases. We show that semiring-based provenance annotations enrich the expressiveness of routing queries over graphs. Several algorithms have previously been proposed for provenance computation over graphs, each yielding a trade-off between time complexity and generality. Here, we address the limitations of these algorithms and propose a new one, partially bridging a complexity and expressiveness gap and adding to the algorithmic toolkit for solving this problem. Importantly, we provide a comprehensive taxonomy of semirings and corresponding algorithms, establishing which practical approaches are needed in different cases. We implement and comprehensively evaluate several practical applications of the problem (e.g., shortest distances, top-ùëò shortest distances, Boolean or integer path features), each corresponding to a specific semiring and algorithm, that depends on the properties of the semiring. On several real-world and synthetic graph datasets, we show that the algorithms we propose exhibit large practical benefits for processing rich graph queries.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graph databases <ref type="bibr" target="#b31">[32]</ref> are part of the so-called NoSQL DBMS ecosystem, in which the information is not organized by strictly following the relational model. The structure of graph databases is well-suited to representing some types of relationships within the data, and their potential for distribution makes them appealing for applications requiring large-scale data storage and massively parallel data processing. Natural example applications of such database systems are social network analysis <ref type="bibr" target="#b12">[13]</ref> or the storage and querying of the Semantic Web <ref type="bibr" target="#b4">[5]</ref>.</p><p>Graph databases can be queried using several general-purpose navigational query languages, an abstraction of which is regular path queries (RPQs) <ref type="bibr" target="#b5">[6]</ref> (or generalizations thereof, such as C2RPQs) on paths in the graph. Recently, based on existing solutions to querying property graphs -such as Neo4j's Cypher <ref type="bibr" target="#b16">[17]</ref> query language or Oracle's PGQL <ref type="bibr" target="#b37">[38]</ref> -an upcoming international standard language for property graph querying, GQL <ref type="bibr" target="#b21">[22]</ref>, is being designed as a standalone language complementing SQL. GQL will notably incorporate support for RPQs.</p><p>In parallel with these recent developments, the notion of provenance of a query result <ref type="bibr" target="#b33">[34]</ref>, a familiar notion in relational databases, has recently been adapted to the context of graph databases <ref type="bibr" target="#b30">[31]</ref>, using the framework of provenance semirings <ref type="bibr" target="#b17">[18]</ref>. In this framework, edges of a graph are annotated, in addition to usual properties, with elements of a semiring; when evaluating a query, traversing the paths on the graph can generate new annotations depending on the semiring operators, resulting in a semiring value associated with every query result, called the provenance of the query result. By choosing different semirings, different information on the query result can be computed. For example, when edges are annotated with elements of the tropical semiring (nonnegative real numbers) expressing the distance between vertices, the provenance of the query result computes the shortest distance of paths that produce this result; when edges are annotated with elements of the counting semiring (natural integers) interpreted as multiplicity, the provenance of the query result computes the (possibly infinite in case of cycles) number of ways each query result can be obtained. Underlying properties of the semiring directly control how the information on graph edges is encoded, and also how efficient algorithms for query processing are. Beyond these simple examples of semirings, the framework of semiring provenance also allows modeling of intricate issues, e.g., when the problem of interest can be decomposed into several subproblems and when the resulting provenance does not necessarily correspond to a particular path in the graph.</p><p>Example 1.1. Consider the example of a road transportation network modeled as a directed graph with provenance annotations on edges. We can for example encode the presence of points of interests (such as gas stations, restaurants, or electrical charging stations) as Boolean features on edges, and road properties (e.g., maximal height or weight for a bridge or tunnel) as real-valued features.</p><p>We will show that, using semiring provenance, we can deal with graph queries that take into account multiple such features: a pair of vertices is valid for the queries if there exists at least one valid path for each restriction between the two locations. An application of this would be to ensure that different vehicle categories (say, a high-clearance truck and an electric car that requires charging on the way) can properly reach a common destination from the same origin.</p><p>Another possible semantics for semiring provenance is to check that all paths between two vertices verify (or exclude) some properties (e.g., absence of tolls, or presence of gas stations on the route) thus providing road administrators crucial information on the global state of the roads between two points. This is illustrated in Figure <ref type="figure" target="#fig_2">1</ref>, a road network where some road segments have restrictions on the height on vehicles; this is a first dimension of provenance. The second dimension records whether there exists an electrical charging station on the road segment -in our example, this is the case for only one edge.</p><p>In our previous preliminary research <ref type="bibr" target="#b30">[31]</ref>, we generalized three existing algorithms from a broad range of the computer science literature to compute the provenance of regular path queries over graph databases, in the framework of provenance semirings. Together, these three generalizations cover a large class of semirings used for provenance, each yielding a tradeoff between time complexity and generality. We also performed experiments suggesting these approaches are complementary and practical for various kinds of provenance indications, even on a relatively large transport network.</p><p>In this paper, we extend this work by: ‚Ä¢ Introducing a novel algorithm, MultiDijkstra, for commutative 0-closed (or absorptive) semirings. This algorithm, generalizing Dijkstra's algorithm and leveraging properties of distributive lattices, partially bridges a strong computational gap between two classes of semirings left untreated in our previous research. The complexity of the queries exemplified here belongs in this gap, and strongly motivated our interest to develop the algorithms in this paper. The experiments we performed demonstrate that our new algorithm can scale up to very large networks with dozens of millions of nodes, bringing a notable improvement with respect to the state of the art of provenance computation in graph databases. ‚Ä¢ Establishing a precise summary, in the form of a taxonomy, of the algorithms used in our context, along with their complexities and expected properties of the underlying semirings used for the provenance annotations. We also analyze similarities with classes of semirings which are used either for computing provenance of relational algebra queries <ref type="bibr" target="#b18">[19]</ref> or of Datalog programs <ref type="bibr" target="#b10">[11]</ref>. ‚Ä¢ Performing a comprehensive set of experiments on realworld data demonstrating the running time of provenance computation over graphs, over a wide variety of semirings and covering different use cases. We also observe that parameters depending on the topology of the graph, such as treewidth <ref type="bibr" target="#b26">[27]</ref> seem to have a higher impact on the efficiency of the algorithm than distance-based parameters such as the highway dimension <ref type="bibr" target="#b3">[4]</ref>. The implementation of all algorithms we use for these experiments is freely available at https://bitbucket.org/smaniu/graph-provenance/ src/master/. The paper is organized as follows. We start by introducing in Section 2 some preliminaries: graph databases enhanced by provenance annotations, a short overview of the algebraic theory of semirings, and an explanation on which semiring can be used for provenance annotations in a few selected practical applications. We revisit in Section 3 the algorithms we proposed in <ref type="bibr" target="#b30">[31]</ref> and discuss their limitations. Section 4 is a taxonomy summarizing classes of semirings and associated algorithms for graph provenance. In Section 5, we introduce MultiDijkstra and the mathematical theory behind distributive lattices, which Multi-Dijkstra relies on. We present experimental results comparing all algorithms in practice in Section 6 before discussing related work in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>The framework we are considering is that of graph databases enriched with semiring-based provenance annotations. We detail here the notation and definitions we previously introduced in <ref type="bibr" target="#b30">[31]</ref> and extend it with some additional concepts. We also introduce a large number of example semirings, to illustrate the generality of the problem considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Semirings</head><p>The framework for provenance in relational databases introduced by <ref type="bibr" target="#b17">[18]</ref> uses the algebraic structure of semirings to encode metainformation about tuples and query results. In what follows, we present the basic notions needed for this paper; for further details about the theory and applications of semirings, see <ref type="bibr" target="#b19">[20]</ref> and <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b33">34]</ref> for their applications to provenance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.1 (Semiring).</head><p>A semiring is an algebraic structure (K, ‚äï, ‚äó, 0, 1) where K is some set, ‚äï and ‚äó are binary operators over K, and 0 and 1 are elements of K, satisfying the following axioms:</p><formula xml:id="formula_0">‚Ä¢ (K, ‚äï, 0) is a commutative monoid: (ùëé ‚äïùëè) ‚äïùëê = ùëé ‚äï (ùëè ‚äïùëê), ùëé ‚äï ùëè = ùëè ‚äï ùëé, ùëé ‚äï 0 = 0 ‚äï ùëé = ùëé; ‚Ä¢ (K, ‚äó, 1) is a monoid: (ùëé ‚äó ùëè) ‚äó ùëê = ùëé ‚äó (ùëè ‚äó ùëê), 1 ‚äó ùëé = ùëé ‚äó 1 = ùëé; ‚Ä¢ ‚äó distributes over ‚äï: ùëé ‚äó (ùëè ‚äï ùëê) = (ùëé ‚äó ùëè) ‚äï (ùëé ‚äó ùëê); ‚Ä¢ 0 is annihilator for ‚äó: 0 ‚äó ùëé = ùëé ‚äó 0 = 0.</formula><p>Example 2.2. It is easy to check that the following structures are all semirings:</p><p>Tropical semiring. (R + ‚à™ {‚àû}, min, +, ‚àû, 0). Top-ùëò semiring. For ùëò ‚©æ 1 some integer,</p><formula xml:id="formula_1">((R + ‚à™ {‚àû}) ùëò , min ùëò , + ùëò , (‚àû, . . . , ‚àû), (0, ‚àû, . . . , ‚àû)),</formula><p>where min ùëò ((ùëé 1 , . . . , ùëé ùëò ), (ùëè 1 , . . . , ùëè ùëò )) = min ùëò {ùëé 1 , . . . , ùëé ùëò , ùëè 1 , . . . , ùëè ùëò } returns the ùëò smallest entries (with duplicates) among those in ùëé and ùëè, in increasing order, and</p><formula xml:id="formula_2">(ùëé 1 , . . . , ùëé ùëò ) + ùëò (ùëè 1 , . . . , ùëè ùëò ) = min ùëò {ùëé ùëñ + ùëè ùëó | 1 ‚©Ω ùëñ, ùëó ‚©Ω ùëò }.</formula><p>We further impose that only tuples that are in increasing order are valid elements of the semiring. Note that the top-1 semiring is the same as the tropical semiring. Example:</p><formula xml:id="formula_3">For ùëò = 2, (1, 2) ‚äï (1, 3) = min 2 {1, 1, 2, 3} = (1, 1) and (1, 2) ‚äó (1, 3) = min 2 {1 + 1, 1 + 3, 2 + 1, 2 + 3} = (2, 3).</formula><p>Counting semiring. (N ‚à™ {‚àû}, +, √ó, 0, 1), where</p><formula xml:id="formula_4">‚àÄùëé ‚àà N * ùëé + ‚àû = ùëé √ó ‚àû = ‚àû √ó ùëé = ‚àû and 0 + ‚àû = ‚àû, but 0 √ó ‚àû = ‚àû √ó 0 = 0. Boolean semiring. ({‚ä•, ‚ä§}, ‚à®, ‚àß, ‚ä•, ‚ä§), where ‚ä• (resp, ‚ä§)</formula><p>is interpreted as the Boolean false (resp., true) value. ùëò-feature semiring. For ùëò ‚©æ 1 some integer, ((R + ) ùëò , min, max, (‚àû, ‚àû, ‚àû), (0, 0, 0)) where min and max are applied pointwise; it also exists in dual form, with min and max exchanged.</p><p>Integer polynomial semiring. (N[ùëã ], +, √ó, 0, 1) where ùëã is a finite set of variables, and +, √ó, 0, 1 have their standard interpretations as polynomial operators and polynomial values. Shortest-path semiring.</p><p>((R + ‚à™ {‚àû}) √ó Œ£ * , ‚äï, ‚äó, (‚àû, ùúÄ), (0, ùúÄ))</p><p>with the following operators ‚äï and ‚äó:</p><formula xml:id="formula_5">‚Ä¢ (ùëë, ùúã) ‚äï (ùëë ‚Ä≤ , ùúã ‚Ä≤ ) = (min(ùëë, ùëë ‚Ä≤ ), ùúã ‚Ä≤‚Ä≤ ) where ùúã ‚Ä≤‚Ä≤ is ùúã if ùëë &lt; ùëë ‚Ä≤ , ùúã ‚Ä≤ if ùëë &gt; ùëë ‚Ä≤</formula><p>, and min(ùúã, ùúã ‚Ä≤ ) (in lexicographic order, assuming some order on</p><formula xml:id="formula_6">Œ£) if ùëë = ùëë ‚Ä≤ ; ‚Ä¢ (ùëë, ùúã) ‚äó (ùëë ‚Ä≤ , ùúã ‚Ä≤ ) = (ùëë +ùëë ‚Ä≤ , ùúã ‚Ä¢ ùúã ‚Ä≤ ) if neither ùëë nor ùëë ‚Ä≤ is ‚àû; and (ùëë, ùúã) ‚äó (ùëë ‚Ä≤ , ùúã ‚Ä≤ ) = (‚àû, ùúÄ) if either ùëë or ùëë ‚Ä≤ is ‚àû.</formula><p>As we shall see further, these examples all yield useful applications for provenance over graphs.</p><p>We now consider properties of semirings that will be of interest to develop specific algorithms -we will illustrate these properties on the example semirings of Example 2.2. Some of the properties are summarized in Figure <ref type="figure" target="#fig_5">2</ref>; ignore annotations for algorithms in blue for now.</p><p>A semiring is commutative if for all ùëé, ùëè ‚àà K, ùëé ‚äó ùëè = ùëè ‚äó ùëé. A semiring is idempotent if for all ùëé ‚àà K, ùëé ‚äï ùëé = ùëé. In an idempotent semiring we can introduce a natural order defined by ùëé ‚äë ùëè iff it exists ùëê ‚àà K such that ùëé ‚äï ùëê = ùëè. 1 Note that this order is compatible with the two binary operations of the semiring: for all ùëé, ùëè, ùëê ‚àà K, ùëé ‚äë ùëè implies ùëé ‚äï ùëê ‚äë ùëè ‚äï ùëê and ùëé ‚äó ùëê ‚äë ùëè ‚äó ùëê. An important property that we wish to use in our setting is that of k-closedness <ref type="bibr" target="#b28">[29]</ref>, i.e., a semiring is ùëò-closed if:</p><formula xml:id="formula_7">‚àÄùëé ‚àà K, ùëò+1 ùëñ=0 ùëé ùëñ = ùëò ùëñ=0 ùëé ùëñ .</formula><p>Here, by ùëé ùëñ we denote the repeated application of the ‚äó operation ùëñ times, i.e., ùëé ùëñ = ùëé ‚äó ùëé ‚äó ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚äó ùëé ùëñ . 0-closed semirings (i.e., those in which ‚àÄùëé ‚àà K, 1 ‚äï ùëé = 1) have also been called absorptive, bounded, or simple depending on the literature. Note that any 0-closed semiring is idempotent (indeed, ùëé ‚äï ùëé = ùëé ‚äó (1 ‚äï 1) = ùëé ‚äó 1 = ùëé) and therefore admits a natural order.</p><p>Example 2.3. All semirings in Example 2.2 are commutative except for the shortest-path semiring (indeed, concatenation is not a commutative operation).</p><p>All of them are idempotent, except for the top-ùëò, counting, and integer polynomial semirings.</p><p>The natural order of the tropical semiring is the total order ‚©æ (note that this is the reverse of the standard order on R + ‚à™ {‚àû}).</p><p>The tropical, Boolean, ùëò-feature, and shortest-path semirings are 0-closed. The top-ùëò semiring is (ùëò -1)-closed. The counting and integer polynomial semirings are not ùëò-closed for any ùëò.</p><p>Star semirings <ref type="bibr" target="#b13">[14]</ref>, also known as closed semirings, extend semirings with a unary * operator, having the following property: ùëé * = 1 ‚äï (ùëé ‚äó ùëé * ) = 1 ‚äï (ùëé * ‚äó ùëé). Note that, in 0-closed semirings, we necessarily have ùëé * = 1. Similarly, in ùëò-closed semirings, we can define ùëé * = ùëò ùëñ=0 ùëé ùëñ . Example 2.4. As just mentioned, since the tropical, Boolean, ùëò-feature, and shortest-path semirings are all 0-closed, we can simply define in all of them ùëé * = 1. Since the top-ùëò semiring is (ùëò -1)-closed, we can define ùëé * with the formula ùëé * = ùëò ùëñ=0 ùëé ùëñ . 1 In general semirings, this defines a preorder; antisymmetry of this relation can be shown when the semiring is idempotent.</p><p>In the counting semiring we can introduce a star operator with: 0 * = 1 and ùëé * = ‚àû for ùëé ‚â† 0.</p><p>It is not possible to simply add a star operator to the integer polynomial semiring (indeed, if the equation ùë• * = 1+ (ùë• √óùë• * ) had a solution ùë• * as a polynomial in ùë•, its degree would be different on the left-and right-hand sides of the equation). However, one can define a more general semiring, that of formal power series, in which a star operator can be defined. See <ref type="bibr" target="#b17">[18]</ref> for details on the semiring of formal power series, which are not important here.</p><p>We will later use the fact that a 0-closed semiring which is also multiplicatively idempotent (i.e., in which ùëé ‚äó ùëé = ùëé for every ùëé) turns out to satisfy the axioms of bounded distributive lattices [8, Theorem 10].</p><p>Example 2.5. The only 0-closed semirings that are multiplicatively idempotent from Example 2.2 are the Boolean and ùëò-feature semirings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Graph databases with provenance</head><p>We now introduce the notion of provenance in graph databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2.6 (Graph Database).</head><p>A graph database with provenance indication (ùëâ , ùê∏, ùúÜ, ùë§) over some semiring (K, ‚äï, ‚äó, 0, 1) is an edge-labeled directed graph (ùëâ , ùê∏, ùúÜ) together with a weight function ùë§ : ùê∏ ‚Üí K.</p><p>Given an edge ùëí = (ùë¢, ùë£) ‚àà ùê∏, we denote ùëõ[ùëí] = ùë¢ its destination (or next) vertex, and ùëù [ùëí] = ùë£ its origin (or previous vertex). By analogy we write its weight ùë§ [ùëí] instead of ùë§ (ùëí). Given a vertex ùë£ ‚àà ùëâ , we denote by ùê∏ [ùë£] the set of edges having ùë£ as origin.</p><p>A path Definition 2.7 (Path Provenance). Let ùê∫ be a graph database with provenance indication over some semiring K. The provenance between ùë• and ùë¶, for ùë• and ùë¶ two vertices of ùê∫ is defined as the (possibly infinite) sum:</p><formula xml:id="formula_8">ùúã = ùëí 1 ùëí 2 ‚Ä¢ ‚Ä¢ ‚Ä¢ ùëí ùëò in ùê∫ is</formula><formula xml:id="formula_9">prov K (ùê∫)(ùë•, ùë¶) ùë§ ùëÉ ùë• ùë¶ (ùê∫) = ùúã ‚ààùëÉ ùë• ùë¶ (ùê∫) ùë§ [ùúã].</formula><p>Several problems can be defined based on this. Given two vertices ùë† and ùë°, the single-pair provenance problem computes the provenance between ùë† and ùë°. Given a vertex ùë†, the singlesource provenance problem computes the provenance between ùë† and each vertex of the graph. Finally, the all-pairs provenance problem computes the provenance for all pairs of vertices.</p><p>A regular path query (RPQ) <ref type="bibr" target="#b5">[6]</ref> defines a set of admissible paths from some vertex ùë† through a regular language over edge labels. The notion of single-source provenance can be generalized to that of RPQ provenance in a straightforward manner, as we did in <ref type="bibr" target="#b30">[31]</ref>. We also showed in <ref type="bibr" target="#b30">[31]</ref> that computing such a provenance could be reduced in polynomial time to the single-source provenance problem; this works by constructing a product of the graph with the automaton describing the language of the query. Note that this construction can be done on-the-fly (avoiding generation of inaccessible vertices) and that the size of the automaton is usually quite small; thus, the overhead is usually affordable oven for large graphs as showed experimentally in <ref type="bibr" target="#b30">[31]</ref>. We will implicitly use this reduction throughout the paper, meaning that we only need to consider the single-source provenance problem in the rest of the paper. Consequently, we will also ignore edge labels and see a graph database as defined by its vertices, edges, and semiring weights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Semantics of path provenance</head><p>As defined, the provenance between two vertices in a graph database is in fact a (possibly infinite) sum over the provenances of all paths from the source vertex leading to the target vertex. As we observed in <ref type="bibr" target="#b29">[30]</ref>, the only possible source of non-finiteness in the sum is due to cycles in the graph, so that we only need to be able to sum all the powers of a given semiring value. For this to be semantically meaningful we need the semiring to be a star semiring, and we additionally need the star operator to verify for all semiring element ùëé: ùëé * = ‚àû ùëõ=0 ùëé ùëõ for some well-behaved infinitary sum operation (namely, associativity, and distributivity of ‚äó over this infinitary sum operator). This class of semirings is commonly known as countably complete star semirings, c-complete star semirings <ref type="bibr" target="#b23">[24]</ref>, or ùúî-complete star semirings.</p><p>Example 2.8. All star semirings identified in Example 2.4 are, indeed, c-complete star semirings. Note that, for ùëò-closed semirings, the infinitary sum ‚àû ùëõ=0 ùëé ùëõ is simply ùëò ùëõ=0 ùëé ùëõ , and the condition of being a c-complete star semiring is trivially satisfied by our choice of star operator. In the remaining cases (counting semiring, formal power series, formal language semiring) one can verify that a well-behaved infinitary sum operation can be introduced, and that it verifies ùëé * = ‚àû ùëõ=0 ùëé ùëõ . We also pointed out in <ref type="bibr" target="#b29">[30]</ref> that all-pairs graph provenance is equivalent to the computation of the asteration of the matrix corresponding to the graph representation with provenance tags as cell-values. With all these definitions in place, we observe that the semantics of provenance over specific semirings actually corresponds to a various number of problems of interest. Remember that using the construction of <ref type="bibr" target="#b30">[31]</ref> we can extend this to the provenance of arbitrary RPQs.</p><p>Example 2.9. Let ùê∫ be a graph database over some c-complete star semiring K, and ùë† and ùë° fixed source and target vertices in ùê∫. The provenance between ùë† and ùë° corresponds to the following notions, depending on the semiring K:</p><p>Tropical semiring: length of shortest path between ùë† and ùë°. Top-ùëò semiring: lengths of ùëò shortest paths between ùë† and ùë°.</p><p>Counting semiring: total number of paths between ùë† and ùë°, edge weights being interpreted as number of edges between two vertices. Boolean semiring: existence of a path between ùë† and ùë°, depending on the existence of edges denoted by their Boolean weights. ùëò-feature semiring: minimum feature value along each dimension of all paths between ùë† and ùë°; if min and max are exchanged, maximum feature value along some path from ùë† to ùë°. Formal power series: how-provenance, see <ref type="bibr" target="#b17">[18]</ref>. Shortest-path semiring: pair formed of a length ùëô and path label ùúã such that ùúã is the shortest path from ùë† to ùë°, of length ùëô (if there are multiple shortest paths, ùúã is the first in lexicographic order).</p><p>Example 2.10. Let us return to the example in Figure <ref type="figure" target="#fig_2">1</ref>. We model the charging station Boolean feature as an integer feature by simply setting ‚ä§ = 1 and ‚ä• = 0. We take the (max, min) definition of the ùëò-feature semiring where we compute the maximum value of each feature among some path from origin to destination, and we order heights in decreasing order (e.g., by taking their inverse) so that a higher feature value means a (more restrictive) lower height.</p><p>Consider two types of vehicles of interest that want to reach the vertex ùë° from the vertex ùë†: one has height between 3 and 4 meters, the second is a small (‚Ñé ‚©Ω 1.5) electric car that needs at least one charging station on the road to ùë°. In the presence of the edge from ùë¢ to ùë£, both of them can reach ùë° from ùë†; without that edge, only the electric car is able to. This is reflected in the provenance: prov(ùê∫)(ùë†, ùë°) = (4, charging station) while prov(ùê∫\{(ùë¢, ùë£)})(ùë†, ùë°) = (2.10, charging station).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXISTING ALGORITHMS</head><p>We now provide a review of three algorithms to solve the singlesource provenance problem, also previously described in <ref type="bibr" target="#b30">[31]</ref>. Each of these algorithms yields a different trade-off between time complexity and applicability to various types of semirings, as summarized in Table <ref type="table" target="#tab_0">1</ref>. for each neighbor ùëè of ùëé not in ùëÜ do 8:</p><formula xml:id="formula_10">w[ùëè] = w[ùëè] ‚äï (w[ùëé] ‚äó ùë§ [ùëéùëè]) 9:</formula><p>end for 10: end while 11: return w Dijkstra. Dijskstra's algorithm is generally used to solve shortest-distance problems in directed graphs. However, as shown also in <ref type="bibr" target="#b30">[31]</ref>, the algorithm readily generalizes to our semiring context, by placing some restrictions on the semirings used. For instance, the tropical semiring is exactly the semiring that allows to compute the shortest distance, as in the original algorithm. The general flow of the algorithm -using general semiring operations -is outlined in Algorithm 1, and Table <ref type="table" target="#tab_0">1</ref> indicates its running time (in terms of the graph size and the costs of the semiring operations ‚äï and ‚äó). Dijkstra's algorithm is known to be a very efficient algorithm. However, this efficiency comes from the fact that it uses a priority queue: once a value is extracted from it, we know that it is the correct one -this allows us to only visit each vertex in the graph once. This only works if we apply Dijkstra to semirings which are 0-closed (or absorptive) and in which an additional condition is satisfied: the natural order is a total order <ref type="bibr" target="#b30">[31]</ref>.</p><p>As we shall discuss later, there is a large complexity gap between Dijkstra on the one hand and the other two algorithms </p><formula xml:id="formula_11">(T ‚äï + T ‚äó )) O (|ùëâ | 3 ) NodeElimination c-complete star O (|ùëâ |T * + |ùëâ | 3 (T ‚äï + T ‚äó )) O (|ùëâ | 3 ) Mohri ùëò-closed Exponential Exponential MultiDijkstra 0-closed ‚äó-idempotent O (‚Ñì √ó (T ‚äï |ùëâ | log |ùëâ | + |ùê∏| (T ‚äï + T ‚äó ))) O (‚Ñì √ó (|ùëâ | log |ùëâ | + |ùê∏|)) Dijkstra 0-closed total ordered O (T ‚äï |ùëâ | log |ùëâ | + |ùê∏|(T ‚äï + T ‚äó )) O (|ùëâ | log |ùëâ | + |ùê∏|)</formula><p>we discuss in this section -NodeElimination and Mohrion the other. This is the main motivation to introduce the new algorithm we present in Section 5.</p><p>Algorithm 2 Mohri -single-source <ref type="bibr" target="#b28">[29]</ref> Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†) a graph database with provenance indication over K and the source ùë†. Output: Array w representing the single-source provenance from ùë† of the reachability query. end for 20: end while 21: w[ùë†] ‚Üê 1 22: return w Mohri. Mohri <ref type="bibr" target="#b28">[29]</ref> introduced an algorithm for computing single-source provenance for reachability queries over ùëò-closed semirings. Outlined in Algorithm 2, it performs, in a manner similar to the Bellman-Ford algorithm, step-by-step relaxations over the edges of the graph (lines 13-14), maintaining a queue to decide in which order the elements are inspected. The queue can be chosen in different ways: based on the topology of the graph, e.g., if the graph is acyclic; or a queue prioritized by weight when, e.g., one wishes to compute top-ùëò shortest paths using the top-ùëò semiring.</p><p>In the worst case, the theoretical complexity of this approach is exponential in the size of the graph <ref type="bibr" target="#b28">[29]</ref>, mainly due to the fact that the algorithm may have to visit the same cycle in the graph multiple times. However, the complexity heavily depends on the implementation of the queue. For instance, for top-ùëò shortest paths, implementing a priority queue allows for an efficient algorithm, having polynomial complexity. Indeed, as we shall detail later, for road transportation networks and top-ùëò shortest paths, experiments show an almost linear-time behavior in ùëò and the size of the graph.</p><p>In contrast, the algorithm may be much more inefficient in practice for other types of networks (such as social networks). As we conjecture in Section 6, this may be due to the fact that transport networks have relatively low treewidth <ref type="bibr" target="#b26">[27]</ref>. The treewidth is a parameter measuring how much a graph (or more generally any relational instance) resembles a tree. Many intractable problems over graphs have tractable solutions on instances of fixed treewidth. We confirm in Section 6 that many of the algorithms for provenance computation strongly benefit -in terms of running time -from low treewidth.</p><p>Another important graph parameter -stemming from the active research community around computing routing for, e.g, driving directions -the highway dimension <ref type="bibr" target="#b3">[4]</ref> has been introduced to provide a theoretical basis for the efficiency observed in practice in state-of-the-art heuristics for computing optimal transport paths. This parameter relies heavily on weights on the edges of the graphs and the distribution of shortest distances in the graph. In our experiments in Section 6, we evaluate whether this parameter also explains the practical efficiency of our algorithms for computing the provenance of routing queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 NodeElimination -single-pair</head><p>Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†, ùë°) a graph database with provenance indication over K, the source ùë†, and the target ùë°. Output: Single value w ùë† ‚Ä≤ ùë° ‚Ä≤ representing the single-pair provenance between ùë† and ùë° of the reachability query.</p><formula xml:id="formula_12">1: ùëâ ‚Ä≤ ‚Üê ùëâ ‚à™ {ùë† ‚Ä≤ , ùë° ‚Ä≤ } 2: ùê∏ ‚Ä≤ ‚Üê ùê∏ ‚à™ {(ùë† ‚Ä≤ , ùë†), (ùë°, ùë° ‚Ä≤ )} 3: for ùëñ ‚àà ùëâ ‚Ä≤ do 4:</formula><p>for ùëó ‚àà ùëâ ‚Ä≤ do 5:</p><formula xml:id="formula_13">w (0) ùëñ ùëó ‚Üê ùë§ [ùëñ ùëó] if ùëñ ‚â† ùëó, 1 ‚äï ùë§ [ùëñ ùëó] if ùëñ = ùëó 6:</formula><p>end for 7: end for 8: for ùëò in ùëâ do </p><formula xml:id="formula_14">w ùëùùëû ‚Üê w ùëùùëû ‚äï w ùëùùëò ‚äó w * ùëòùëò ‚äó w ùëòùëû 11:</formula><p>end for 12: end for 13: return w ùë† ‚Ä≤ ùë° ‚Ä≤ NodeElimination. The most general algorithm available is based on the idea of Brzozowski and McCluskey for obtaining a formal language expression (i.e., a regular expression) equivalent to the language of an automaton <ref type="bibr" target="#b8">[9]</ref>. The algorithm is outlined in Algorithm 3. The algorithm works by eliminating vertices one by one and computing the "shortcut" values for each vertex pair, until only the source and target vertices remain. This algorithm works for any ùëê-complete semiring over which a star operation is defined -this is necessary for the shortcuts computed in the algorithm to be correct. In general, the complexity of the algorithm is at least cubic in the number of vertices in the graph, which makes it practically unusable on large graphs. Importantly, however, it also can be shown that its complexity is closely related to the treewidth parameter of the graph. Following a simplicial elimination order (unfortunately not tractable to compute) one can rephrase the complexity shown in Table <ref type="table" target="#tab_0">1</ref> in terms of the treewidth parameter ùë§ by O (|ùëâ |T * + |ùëâ |ùë§ 2 (T ‚äï + T ‚äó )). Thus, if the treewidth is small over, e.g., transportation networks, one can benefit from heuristics for finding a suitable elimination order to optimize this algorithm. We dedicate a part of our experiments demonstrating the impact of some heuristics (for instance, focusing on vertices of higher degrees) on the running time of this algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related algorithms.</head><p>Star semirings are also known as closed semirings <ref type="bibr" target="#b1">[2]</ref> and the star operation is known as the closure operation. In this sense, all-pair computations correspond to matrix asteration. For instance, the NodeElimination algorithm can be used to compute the asteration <ref type="bibr" target="#b1">[2]</ref> of a matrix -but, if the semiring is not c-complete, there is no guarantee of a semantics compatible with the intuitive semantics of provenance over graph databases. Matrix asteration allows for a high degree of parallel computation <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">TAXONOMY</head><p>We present in Figure <ref type="figure" target="#fig_5">2</ref> a high-level view linking the properties and classes of semiring we presented in Section 2 and their associated algorithms, presented in Sections 3 and 5. The figure shows a clear hierarchy of classes of semirings, both in terms of the complexity of the algorithm and the expressive power of the semirings.</p><p>An important practical application that is similar to our setting is the provenance for Datalog queries introduced in <ref type="bibr" target="#b17">[18]</ref> and further optimized using circuits <ref type="bibr" target="#b10">[11]</ref>. Datalog <ref type="bibr" target="#b2">[3]</ref> is a language derived from Prolog, useful for infering new knowledge given existing facts and a set of inference rules. In the papers above, the semiring classes for which optimization of queries is possible are strikingly similar: PosBool(ùëã ) and Sorp(ùëã ) discussed in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref> correspond respectively to the positive fragment of the Boolean function semiring, and to the free (i.e., most general) 0-closed semiring. In that sense, algorithm optimizations discussed here apply directly to applications such as Datalog query optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ALGORITHM FOR 0-CLOSED SEMIRINGS</head><p>As explained in Section 3, Dijkstra requires a total natural order on the elements of a 0-closed semiring. This is quite a restrictive setting (among the examples from Example 2.2, only the tropical semiring fits), while using a more generally available algorithm such as Mohri can lead to practical inefficiency. The question we are addressing in this section is whether we can bridge this complexity gap and still obtain practical algorithms for 0-closed semiring without total orders.</p><p>First, we present an example semiring setting, with non-total natural order, where Dijkstra cannot be readily applied.</p><p>Example 5.1. Let us consider the 3-feature semiring ({0, 1} 3 , min, max, (1, 1, 1), (0, 0, 0)).</p><p>In the example graph below, the provenance between ùë† and ùë° is: min (max ((0, 0, 1), (0, 1, 0)) , (1, 0, 0)) = (0, 0, 0) and that between ùë† and ùëü is: min (max ((1, 0, 0), (0, 1, 0)) , (0, 0, 1)) = (0, 0, 0) s r t (0, 0, 1)</p><formula xml:id="formula_15">(0, 1, 0) (1, 0, 0)</formula><p>Assume there would be an order for which Dijkstra computes this provenance. Then, starting from ùë†, Dijkstra would select either ùëü and assign it provenance (0, 0, 1), which is wrong, or ùë° and assign it provenance (1, 0, 0), which is also wrong.</p><p>In the following, we address this problem and design a new algorithm, MultiDijkstra (for Multidimensional Dijkstra) that applies to the more general case of 0-closed semirings for which multiplication is idempotent (such as the ùëò-feature semiring, but also the Boolean function semiring used in probabilistic databases, see <ref type="bibr" target="#b33">[34]</ref>). As it turns out, such semirings satisfy the axioms of bounded distributive lattices <ref type="bibr" target="#b7">[8,</ref><ref type="bibr">Theorem 10]</ref>; this allows us to design an efficient algorithm for answering queries using these types of semirings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Mathematical Background</head><p>In the following we introduce basic notions about finite distributive lattices. We assume the lattices we use are finite because we are only ever using the subsemiring generated by edge annotations. As we shall see, this subsemiring is finite when both operations of the semiring are idempotent.</p><p>We refer the reader to <ref type="bibr" target="#b35">[36]</ref> for more details regarding the theory behind distributive lattices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Definitions and Notation.</head><p>A lattice (ùêø, &lt;) is a partially ordered set (poset) where every two elements have a unique infimum (their meet, ‚àß) and supremum (their join, ‚à®). A lattice embedding of a lattice ùêø into a lattice ùêæ is a one-to-one join and meet homomorphism from ùêø to ùêæ. In a poset, an element ùë¶ covers ùë• (denoted ùë• ‚ãñ ùë¶) if ùë• &lt; ùë¶ and there are no such ùëß such that ùë• &lt; ùëß &lt; ùë¶. A lattice embedding ‚Ñì is tight if ùë• ‚ãñ ùë¶ implies ‚Ñì (ùë•) ‚ãñ ‚Ñì (ùë¶). 2  An element ùë• of a lattice ùêø is join-irreducible if ùë• = ùëé ‚à® ùëè implies that ùë• = ùëé or ùë• = ùëè. The set of non-zero join-irreducible elements of ùêø is denoted ùêΩ (ùêø). It induces a subposet of ùêø which is also denoted by ùêΩ (ùêø).</p><p>For a subset ùëÜ of a lattice ùêø, we let ùëÜ = ùë• ‚ààùëÜ ùë• be the join of the elements of ùëÜ. We often write ùêø ùëÜ to specify that the join takes place in ùêø. A subset ùëÜ of a poset is a downset or ideal if ùë• ‚àà ùëÜ and ùë¶ ‚©Ω ùë• implies ùë¶ ‚àà ùëÜ. The minimum downset containing an element ùë• is denoted id ùë•. We note D (ùëÉ), for a poset ùëÉ, the family of downsets of ùëÉ ordered by inclusion.</p><p>A chain ùê∂ of length ùëõ in a poset ùëÉ is a subposet isomorphic to the linear order Z ùëõ on the ùëõ elements {0, 1, . . . , ùëõ -1}. A chain decomposition of a poset ùëÉ is a partition of its elements into a family C of chains ùê∂ 1 , . . . , ùê∂ ùëë . For a family C = {ùê∂ 1 , . . . , ùê∂ ùëë } of disjoint chains, the product C := ùëë ùëñ=1 ùê∂ ùëñ consists of all ùëëtuples ùë• = (ùë• 1 , . . . , ùë• ùëë ) where ùë• ùëñ ‚àà ùê∂ ùëñ for each ùëñ ‚àà {1, . . . , ùëë }. It is ordered by ùë• ‚©Ω ùë¶ if ùë• ùëñ ‚©Ω ùë¶ ùëñ for each ùëñ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Results</head><p>. A classical result from Birkhoff <ref type="bibr" target="#b6">[7]</ref> establishes an isomorphism between ùêø and D (ùêΩ (ùêø)): Theorem 5.2 ( <ref type="bibr" target="#b6">[7]</ref>). The map S : ùë• ‚Ü¶ ‚Üí id ùë• ‚à© ùêΩ (ùêø) is an isomorphism of ùêø to D (ùêΩ (ùêø)). Its inverse is ùëÜ ‚Ü¶ ‚Üí ùêø ùëÜ .</p><p>For a chain decomposition C of a poset, let C 0 be the family of chains we get from the chains in C by adding a new minimum element to each. In <ref type="bibr" target="#b11">[12]</ref>, Dilworth proved the following embedding theorem: Theorem 5.3 <ref type="bibr">([12]</ref>). For any chain decomposition C of a poset ùëÉ the map ùëÜ ‚Ü¶ ‚Üí ùëÉ ùëÜ is an embedding of D (ùëÉ) into ùëÉ = C 0 .</p><p>Then, we obtain the following corollary we will use later: Corollary 5.4. Given a chain decomposition C of a distributive lattice ùêø, there is a tight embedding of ùêø into C 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Application to Provenance Computation</head><p>Corollary 5.4 provides us with a way to compute provenance over distributive lattices using a multidimensional version of Dijkstra's algorithm. Because an embedding is a homomorphism, we can compute each component of C 0 independently. And because the homomorphism is one-to-one, we can easily recover the provenance at the end of the computation.</p><p>Example 5.5. If we take a look at distributive lattice of the divisors of 60 with greatest common divisor (gcd) and least common multiple (lcm) as join and meet operators, we notice that the divisors of 60 are either powers of 2, 3, 5 or an lcm 2 Implicitly from lattice notation to poset notation: ùë• ‚à® ùë¶ = ùë¶ means ùë• ‚©Ω ùë¶. of these integers. Thus, they can be represented using three dimensions representing the factorization of 60 along these prime numbers: decompose(4) = (2, 0, 0), recompose(0, 1, 0) = 3, and recompose(2, 1, 0) = 12. We can then compute independently each dimension of the result using Dijkstra's algorithm since each component is totally ordered; then, partial results are combined.</p><p>In other words, we can run separately, ‚Ñì times, Dijkstra's algorithm for each dimension of this product, where ‚Ñì is the number of chains in the chain decomposition. This gives us a parameterized algorithm, where ‚Ñì depends on the semiring. For example, for the semiring used in Example 5.1, ‚Ñì = 3. We outline the algorithm in pseudo-code in Algorithm 4. We need the following routines that are highly specific to the semiring: decompose(ùëí) takes as parameter an element ùëí of ùêø and returns its image ùë£ (ùëí) ‚àà P. For the opposite direction recompose(ùëë 1 , . . . , ùëë ùëõ ) = 0‚©Ωùëñ ‚©Ωùëõ ùëë ùëñ returns as expected an element of ùêø.</p><p>We use as a subroutine a slightly modified version of Dijkstra, parameterized by the semiring dimension and working with semirings having elements in vector form, corresponding to the decomposition. Dijkstra(s,t,i) ‚àà ùêΩ (ùêø) computes the provenance between ùë† and ùë° corresponding to the ùëñ th dimension of the decomposition.</p><p>Example 5.6. We describe the working of Algorithm 4 in the example presented in Example 5.1: first, each edge value is decomposed; this step is easy to follow as the 3-feature values are already presented in decomposed form. A second step consists in calculating values along each dimensions. Algorithm 1 is launched a first time over the graph with edge values corresponding to the first dimension: 0 for (ùë†, ùëü ) and (ùëü, ùë°), 1 for (ùë†, ùë°). The result is 0. Algorithm 1 is launched a second time over the graph with edge values corresponding to the second dimension: 0 for (ùë†, ùëü ) and (ùë†, ùë°), 1 for (ùëü, ùë°). The result is, again, 0. Finally, Algorithm 1 is launched a third time over the graph with edge values corresponding to the third dimension: 0 for (ùë†, ùë°), 1 for (ùë†, ùëü ) and (ùëü, ùë°). The result is 0. This ends the second step. The third step consists in recomposing partial values obtained by successive applications of Dijkstra's algorithm. This ends up to the final provenance value of (0, 0, 0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 MultiDijkstra -single-pair</head><p>Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†, ùë°) a graph database with provenance indication over K, the source ùë†, and the target ùë°. Output: Single-pair provenance of the reachability query from ùë† to ùë°. 1: for each edge ùëí ‚àà ùê∏ do ùëë ùëñ ‚Üê Dijkstra(ùë†, ùë°, ùëñ) 6: end for 7: return recompose(ùëë 1 , . . . , ùëë ùëõ )</p><p>For the sake of simplicity, we presented the single-pair version of our algorithm. To extend it to the single-source version one only needs to perform the recompose subroutine for each vertex in the graph.</p><p>To minimize accesses to the decompose subroutine -which can be very costly -we optimize MultiDijkstra by adopting a lazy approach, where the Dijkstra subroutine calls decompose only when needed, storing the decomposition across calls. This avoids scanning the whole graph when ùë† and ùë° are close.  Two other optimizations implemented are a stopping condition that ends the Dijkstra subroutine when a visited vertex has value 0, and lazy initialization of the priority queue. These two optimizations led to vastly improved computation times over the naive implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Practical Use Case</head><p>As exemplified in the Introduction, ùëò-feature semirings can be used to ensure that all paths from ùë† to ùë° verify a combination of features (they all go through a specific set of points of interests, or verify some road properties) or either ensure the existence of valid paths up to some collection of restrictions. We show in the experimental section that this is tractable for practical use cases (continental-sized areas, around 10 7 vertices). To the best of our knowledge, no solution for this that scales even to graphs of thousands of vertices has been previously proposed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS</head><p>We performed experiments on real-world graph data, using an Inria computing cluster running the OAR task manager. The individual vertices of the cluster have a minimum of 48 GB of RAM, and run Intel Xeon X5650 or E5-26xx CPUs.</p><p>We used datasets<ref type="foot" target="#foot_0">3</ref> from a variety of domains, mostly representing infrastructure networks: the OpenStreetMaps network of Paris (Paris), the Paris public transport network (Stif), and the power grid of the continental US (USPowerGrid). For comparison, we have also evaluated on other types of datasets: a small subset of the Facebook social network (Facebook) and the yeast protein-to-protein interaction network (Yeast). All these datasets come without provenance annotations, that we add in different ways depending on experiments. We also used a real weighted road transportation network dataset Rome99, with tropical semiring annotations, from the 9th DIMACS Implementation Challenge <ref type="foot" target="#foot_1">4</ref> . This dataset consists of a large portion of the directed road network of the city of Rome, Italy, from 1999. Basic information about the resulting graphs are summarized in Table <ref type="table" target="#tab_1">2</ref>.</p><p>For datasets without provenance annotations, unless specified differently, we randomly generate weights in the tropical semiring for benchmarks, uniformly between 1 and 3 000. To be able to compare the impact of the weights on the performance of the algorithms, we also use a constant-weight setting, where all weights equal to 1. Each experiment generally represents the average over 10 runs (random choices of origin and destination vertices).</p><p>Our experimental study is focused on comparing the four algorithms presented in this paper, over several semirings. We provide a comparison of all of our algorithms for the computation over the tropical semiring (shortest distance), since all algorithms can be used in this setting. We investigate the running time and the number of relaxation steps performed by Mohri and MultiDijkstra algorithm, using initial weights provided by the dataset Rome99, as well as custom weights (all identical and all random); we then study over all datasets the impact of the elimination order heuristic on the overall performance for NodeElimination. We then finish with the comparison between our new algorithm and previous solutions to demonstrate its efficiency.</p><p>Evaluating shortest distances. We start by evaluating how the algorithms deal with the shortest distance semiring, i.e., the tropical and top-ùëò semiring (by setting ùëò = 1). The properties of this semiring allow their implementation for the first three algorithms:  Dijkstra, Mohri, and NodeElimination, whereas MultiDijkstra reduces to Dijkstra in that case. We also implemented a breadth-first-search traversal for computing accessibility with no provenance information (BFS). This also allows us to compare the performance of algorithms against non-annotated graph databases.    Figure <ref type="figure" target="#fig_7">3</ref> shows, on a logarithmic scale, the result for our graphs, and for some settings of weights (original, random, or same weights). It is immediately clear from the figure that the choice of algorithm is crucial: we need the most specialized algorithm for the semiring we use: Dijkstra is more efficient than Mohri which is more efficient than NodeElimination. Even for Mohri, we notice that using it configured for the top-ùëò semiring with ùëò = 1 does introduce an overhead in execution; when using the tropical semiring directly the overhead is smaller. We also show the overhead introduced when using provenance annotations is quite limited, as the difference between Dijkstra and BFS is less than an order of magnitude for each dataset, and Dijkstra sometimes even outperforms BFS. Finally, NodeElimination is always several orders of magnitude slower than Dijkstra. Another encouraging result is that Mohri -which allows more classes of semirings than Dijkstra -has a reasonable running time in practice, despite the stated exponential complexity bound in the original paper. We turn to evaluating its performance next.</p><p>Mohri in practice. In Figure <ref type="figure" target="#fig_6">4</ref> and in Figure <ref type="figure">5</ref> we respectively study the impact of the factor ùëò on the running time and on the number of computations performed by the algorithm. Our results show that the computational time is linear in ùëò, though this is not the case for the number of relaxations, which increases sublinearly in ùëò. This means that for large values of ùëò the algorithm spends most of its time maintaining the queue.</p><p>We also compare the performance of the algorithm depending on weight assignment (original, random, same). It seems that considering random values instead of "real" values has almost no significant impact over the efficiency of the algorithm. This is a somewhat disappointing result because it rules out the possibility to parametrize the complexity of the algorithm through network parameters, for instance, in terms of the highway dimension [4]a graph parameter that has been successfully applied for understanding the efficiency of state-of-the-art shortest-distance algorithms in road networks. However, the performance increases significantly when all weights are uniform, which may be expected since computation of shortest distances become far simpler, and far more paths have equal distance.</p><p>As pointed out in Section 3 this algorithm performs extremely well over transportation networks. We wanted to provide a comparison of its working time for different kinds of graphs (especially graphs whose treewidth is large relative to their size). For this purpose we used a social network dataset: who-trustswhom network of people who trade using Bitcoin on a platform called Bitcoin Alpha <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref> (3 783 vertices and 24 186 edges). The algorithm times out after 48 hours.</p><p>What we can learn from this is that the key property making Mohri so efficient over transportation networks is not due to distance properties (e.g., highway dimension) -impacted by the weights of the connections -but rather by topological properties of the underlying graph (e.g., treewidth).</p><p>Ordering for NodeElimination. NodeElimination's perfomance, due to its main loop of creating "shortcuts" in the graph, is heavily dependent on the order in which the vertices are eliminated. This elimination ordering is strongly linked to the treewidth parameter of the graph. For instance, following a degree based elimination order gives an upper bound on this parameter.</p><p>Hence, we have compared different elimination orders for NodeElimination and found out that the minimum degree based elimination order (Degree) greatly improves the efficiency of this algorithm compared to having no such heuristic (Id). This improvement can be dramatic, as for the Yeast dataset where the algorithm is two orders of magnitude faster. As expected, weights over the edges doesn't impact the running time, as shown in Figure <ref type="figure" target="#fig_9">6</ref>. This is important in practice: running NodeElimination on low-treewidth graphs (e.g., infrastructure and transport networks) can be the difference between the algorithm being unusable and allowing reasonable running times. Taking into account that NodeElimination allows for a large class of semirings, this can have a significant real-world application impact.</p><p>MultiDijkstra. We now evaluate MultiDijkstra, our contribution to bridging the gap between absorptive semirings and more general ones. We compare it to Mohri and NodeElimination in the case of the ùëò-feature semiring, which is kind of the canonical semiring that is 0-closed and multiplicatively idempotent. Figure <ref type="figure" target="#fig_11">7</ref> showcases this on 3 datasets. In all cases, our new algorithm is between 3 and 4 orders of magnitude faster than NodeElimination, depending on the network we use, and significantly faster than Mohri.</p><p>We then performed an additional experiment (Figure <ref type="figure" target="#fig_12">8</ref>), examining the impact of the number of features and values actually used in each feature on the running time of both algorithms. We found out that when either one of the two criteria reaches 4, Mohri times out while MultiDijkstra keeps scaling.</p><p>Finally, Figure <ref type="figure" target="#fig_4">9</ref> presents a comparison between Mohri and MultiDijkstra on large Erd≈ës-R√©nyi random generated graphs (generated using Python networkx's fast_gnp_generation method, using an average of 1.7 edges per vertex) show that our new algorithm is still tractable for continental-sized graphs of millions of vertices. Interestingly, MultiDijkstra also exhibits a much smaller variance than that of Mohri, whose performance varies by more than one order of magnitude between runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>The idea of encapsulating operations carried along by graph algorithms in terms of semirings has been really common for decades. In <ref type="bibr" target="#b9">[10,</ref><ref type="bibr">Chapter 25]</ref> the authors presented two of the classical graph algorithms, Floyd-Warshall and transitive closure algorithm in terms of closed semirings. The APSP (All-Pairs Shortest-Path problem) is elegantly expressible using star semirings; hence, research focused on the links to linear algebra through matrix computations <ref type="bibr" target="#b0">[1]</ref>, allowing to speed up the response time using parallel computations. Recent work on semiring-based graph processing has provided to the community some tools such as GraphBLAS <ref type="bibr" target="#b22">[23]</ref>, a library of kernel functions dedicated to optimize linear algebra computations over sparse matrices. Unfortunately, this tool focuses essentially on matrix and vector products and is not amenable to express priority queue management such as those needed for Mohri, Dijkstra, MultiDijkstra. Only NodeElimination and the matrix asteration algorithms could benefit of a GraphBLAS implementation: this might increase their performance, even when retaining their higher asymptotic complexity with respect to other algorithms. Amongst many other fields, semirings have been successfully applied in constraint-solving programming <ref type="bibr" target="#b7">[8]</ref>, linguistic structure prediction <ref type="bibr" target="#b36">[37]</ref> and formal language theory <ref type="bibr" target="#b32">[33]</ref>. This algebraic structure is also perfectly suited to the modeling of dynamic programming <ref type="bibr" target="#b20">[21]</ref>.</p><p>The notion of provenance has also been initially developed using semirings <ref type="bibr" target="#b17">[18]</ref>, either for relational databases and Datalog programs, leading to practical systems such as <ref type="bibr" target="#b34">[35]</ref>, an extension to PostgreSQL adding the support for provenance. Many representation frameworks have been successfully applied to speed up the computation of the provenance for Datalog programs, most notably a circuit-based provenance approaches <ref type="bibr" target="#b10">[11]</ref> and the solving of fixed-point equations using derivation tree analysis <ref type="bibr" target="#b14">[15]</ref>. The latter approach led to a proof-of-concept implementation <ref type="bibr" target="#b15">[16]</ref> of the resolution of fixed-point equations over c-continuous semirings using the Newton method.</p><p>Compared to our work, relational databases lack the effective support for navigational queries (recursion is an issue) and Datalog programs are much more expressive than graphs (they are closely related to hypergraphs), so we suspect query answering in Datalog would be highly inefficient for the continental-sized road-network datasets we target, though we leave this investigation for future work.</p><p>Numerous notions of provenance co-exist in the literature and each target different usages. The notion we use in this paper considers the provenance to be computational rather than just informational: we can apply operations over our provenance values with different semantics depending on the underlying semiring. Some practical systems, such as <ref type="bibr" target="#b27">[28]</ref> rely on property graphs to represent provenance annotations, that are of an informational rather than computational nature. Those systems focus on the further querying of obtained provenance to derive additional information about the process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS</head><p>We presented in this paper a study on evaluating the provenance of rich graph queries using the semiring provenance framework. We established a taxonomy of semiring classes, based on their properties. This in turn allows us to find, for a set of important semiring classes, the most appropriate algorithm, enabling real-world applicability. We introduce a new algorithm, MultiDijkstra, which bridges the gap between algorithms for absorptive semirings and ones for more general classes.</p><p>Experimentally, on graph datasets from various domains, we showed that making sure that the appropriate algorithm is chosen for the semiring specialization is crucial; gains of several orders of magnitude are observed between algorithms on the same graph datasets. Moreover, we notice that algorithms for which their theoretical complexity is high perform well in practice, especially on graphs having relatively low treewidth.</p><p>We believe the link with classes of semiring for which an optimization for the computation of the provenance for Datalog queries exists is a key observation for optimizing computations in our framework. Investigating this further will allows us to benefit from the rich literature around Datalog provenance (in particular, <ref type="bibr" target="#b10">[11]</ref>) and to compare to our solutions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>4 ‚Ñé ‚©Ω 2 . 10 ‚ÑéFigure 1 :</head><label>42101</label><figDesc>Figure1: Example road network represented by a graph with provenance annotations along two dimensions: maximum height ‚Ñé (as a positive number) a vehicle must have to use the road segment, and a Boolean indicating the presence of an electrical charging station. When a dimension is not mentioned, the annotations are assumed to be, respectively, ‚Ñé ‚©Ω ‚àû and ¬¨(charging station).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>an element of ùê∏ * with consecutive edges: ùëõ[ùëí ùëñ ] = ùëù [ùëí ùëñ+1 ] for ùëñ = 1, . . . , ùëò -1. We extend ùëõ and ùëù to paths by setting ùëù [ùúã] ùëù [ùëí 1 ], and ùëõ[ùúã] ùëõ[ùëí ùëò ]. A cycle is a path starting and ending at the same vertex: ùëõ[ùëê] = ùëù [ùëê]. The weight function ùë§ can also be extended to paths by defining the weight of a path as the result of the ‚äó-multiplication of the weights of its constituent edges: ùë§ [ùúã] ùëò ùëñ=1 ùë§ [ùëí ùëñ ]; this can in fact be extended to any finite set of paths by ùë§ [{ùúã 1 , . . . , ùúã ùëõ }] ùëõ ùëñ=1 ùë§ [ùúã ùëñ ]. For any two vertices ùë• and ùë¶ of a graph ùê∫, we denote by ùëÉ ùë• ùë¶ (ùê∫) the set of paths from ùë• to ùë¶.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm 1</head><label>1</label><figDesc>Dijkstra -single-source Input: (ùê∫ = (ùëâ , ùê∏, ùë§), ùë†) a graph database with provenance indication over K and the source ùë†. Output: Array w representing the single-source provenance from ùë† of the reachability query. 1: ùëÜ ‚Üê ‚àÖ 2: w[ùëé] ‚Üê 0, ‚àÄùëé ‚àà ùëâ 3: w[ùë†] ‚Üê 1 4: while ùëÜ ‚â† ùëâ do 5: Select ùëé ‚àâ ùëÜ with minimal w[ùëé] 6: ùëÜ ‚Üê ùëÜ ‚à™ {ùëé} 7:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 :</head><label>1</label><figDesc>for ùëñ ‚àà {1, . . . , |ùëÑ |} do 2: w[ùëñ] ‚Üê ùëü [ùëñ] ‚Üê 0 3: end for 4: w[ùë†] ‚Üê ùëü [ùë†] ‚Üê 1 5: ùëÜ ‚Üê {ùë†} 6: while ùëÜ ‚â† ‚àÖ do for each ùëí ‚àà ùê∏ [ùëû] do 12: if w[ùëõ[ùëí]] ‚â† w[ùëõ[ùëí]] ‚äï (ùëü ‚Ä≤ ‚äó ùë§ [ùëí]) then 13: w[ùëõ[ùëí]] ‚Üê w[ùëõ[ùëí]] ‚äï (ùëü ‚Ä≤ ‚äó ùë§ [ùëí]) 14: ùëü [ùëõ[ùëí]] ‚Üê ùëü [ùëõ[ùëí]] ‚äï (ùëü ‚Ä≤ ‚äó ùë§ [ùëí]) 15: if ùëõ[ùëí] ‚àâ ùëÜ then 16: enqueue(ùëÜ, ùëõ[ùëí])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>9 :</head><label>9</label><figDesc>for each (ùëù, ùëû) s.t. (ùëù, ùëò), (ùëò, ùëû) ‚àà ùê∏ ‚Ä≤ do 10:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Taxonomy of the semirings used for graph provenance along with algorithms that work on them</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>4 :</head><label>4</label><figDesc>for each dimension ùëñ do 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Comparison between algorithms for shortest distances</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: Computation time for Mohri over the top-ùëò distances semiring, for varying values of ùëò and varying weight assignments (Rome99)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Comparison between elimination orders for NodeElimination algorithm (tropical semiring). Values greater than 100 000 s are timeouts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Comparison between NodeElimination, Mohri, and MultiDijkstra (3-feature semiring)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Computation time for Mohri and MultiDijkstra depending on the number of dimensions (Rome99)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Average computation time for Mohri and MultiDijkstra over random graphs depending on the number of nodes; shaded areas indicate minimum and maximum computation times observed (3-feature semiring)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Required semiring properties and asymptotic complexity for each studied algorithm, where T ‚Ä¢ is the complexity of the elementary semiring operation ‚Ä¢. The last column assumes constant cost for all semiring operations.</figDesc><table><row><cell>Name</cell><cell>Semiring property</cell><cell>Time complexity (with semiring op.) Time complexity</cell></row><row><cell cols="2">MatrixAsteration star</cell><cell>O (|ùëâ |T</cell></row></table><note><p>* + |ùëâ | 3</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Graph datasets: size and treewidth lower and upper estimates from<ref type="bibr" target="#b26">[27]</ref> </figDesc><table><row><cell>type</cell><cell cols="3">name # of vertices # of edges</cell><cell>tw</cell></row><row><cell>infrastructure</cell><cell>Paris</cell><cell>4 325 486</cell><cell>5 395 531</cell><cell>55-521</cell></row><row><cell></cell><cell>Stif</cell><cell>17 720</cell><cell>31 799</cell><cell>28-86</cell></row><row><cell></cell><cell>USPowerGrid</cell><cell>4 941</cell><cell>6 594</cell><cell>10-18</cell></row><row><cell></cell><cell>Rome99</cell><cell>3 353</cell><cell>4 831</cell><cell>5-50</cell></row><row><cell>social</cell><cell>Facebook</cell><cell>4 039</cell><cell cols="2">88 234 142-237</cell></row><row><cell>biology</cell><cell>Yeast</cell><cell>2 284</cell><cell>6 646</cell><cell>54-255</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>These datasets were used in<ref type="bibr" target="#b26">[27]</ref> for treewidth computation experiments, and are downloadable from https://github.com/smaniu/treewidth/; some of them originate from http://snap.stanford.edu/data/index.html.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>http://users.diag.uniroma1.it/challenge9/download.shtml</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This work has been funded by the <rs type="funder">French government</rs> under management of <rs type="funder">Agence Nationale de la Recherche</rs> as part of the "<rs type="programName">Investissements d'avenir" program</rs>, reference <rs type="grantNumber">ANR-19-P3IA-0001</rs> (<rs type="projectName">PRAIRIE 3IA Institute</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_mBkKNCT">
					<idno type="grant-number">ANR-19-P3IA-0001</idno>
					<orgName type="project" subtype="full">PRAIRIE 3IA Institute</orgName>
					<orgName type="program" subtype="full">Investissements d&apos;avenir&quot; program</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Parallel Computations in *-Semirings</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Kamal</forename><surname>Abdali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Algebra</title>
		<editor>
			<persName><forename type="first">Francis</forename><surname>Taylor</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Transitive closure and related semiring properties via eliminants</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Kamal</forename><surname>Abdali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Saunders</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(85)90170-7</idno>
		<ptr target="https://doi.org/10.1016/0304-3975(85)90170-7" />
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="257" to="274" />
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Highway Dimension, Shortest Paths, and Provably Efficient Algorithms</title>
		<author>
			<persName><forename type="first">Ittai</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amos</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Renato</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Werneck</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=1873601.1873665" />
	</analytic>
	<monogr>
		<title level="s">SODA. Society for Industrial and Applied Mathematics</title>
		<imprint>
			<biblScope unit="page" from="782" to="793" />
			<date type="published" when="2010">2010</date>
			<pubPlace>Philadelphia, PA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Querying semantic web data with SPARQL</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorge</forename><surname>P√©rez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="305" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Querying Graph Databases</title>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barcel√≥</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS. ACM</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="175" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Rings of sets</title>
		<author>
			<persName><forename type="first">Garrett</forename><surname>Birkhoff</surname></persName>
		</author>
		<idno type="DOI">10.1215/S0012-7094-37-00334-X</idno>
		<ptr target="https://doi.org/10.1215/S0012-7094-37-00334-X" />
	</analytic>
	<monogr>
		<title level="j">Duke Math. J</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="443" to="454" />
			<date type="published" when="1937">1937. 1937</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Semiring-based constraint satisfaction and optimization</title>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Bistarelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ugo</forename><surname>Montanari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesca</forename><surname>Rossi</surname></persName>
		</author>
		<idno type="DOI">10.1145/256303.256306</idno>
		<ptr target="https://doi.org/10.1145/256303.256306" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="201" to="236" />
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Signal Flow Graph Techniques for Sequential Circuit State Diagrams</title>
		<author>
			<persName><forename type="first">A</forename><surname>Janusz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><forename type="middle">J</forename><surname>Brzozowski</surname></persName>
		</author>
		<author>
			<persName><surname>Mccluskey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Electr. Comp. EC</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="67" to="76" />
			<date type="published" when="1963">1963. 1963</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">E</forename><surname>Cormen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clifford</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName><surname>Stein</surname></persName>
		</author>
		<title level="m">Introduction to Algorithms</title>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>2nd ed.</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Circuits for Datalog Provenance</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="201" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Decomposition Theorem for Partially Ordered Sets</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">P</forename><surname>Dilworth</surname></persName>
		</author>
		<ptr target="http://www.jstor.org/stable/1969503" />
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="161" to="166" />
			<date type="published" when="1950">1950. 1950</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Mining the network value of customers</title>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Domingos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Richardson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD. ACM</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="57" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Handbook of Weighted Automata</title>
		<author>
			<persName><forename type="first">Manfred</forename><surname>Droste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Kuich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiko</forename><surname>Vogler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Solving fixed-point equations by derivation tree analysis</title>
		<author>
			<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Luttenberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Algebra and Coalgebra in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">FP-soLvE: A Generic Solver for Fixpoint Equations Over Semirings</title>
		<author>
			<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Luttenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maximilian</forename><surname>Schlund</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-08846-4_1</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-08846-4_1" />
	</analytic>
	<monogr>
		<title level="j">International Journal of Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Cypher: An Evolving Query Language for Property Graphs</title>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andr√©s</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Rydberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<idno type="DOI">10.1145/3183713.3190657</idno>
		<idno>1433-1445</idno>
		<ptr target="https://doi.org/10.1145/3183713.3190657" />
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Provenance Semirings</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grigoris</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The Semiring Framework for Database Provenance</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<idno type="DOI">10.1145/3034786.3056125</idno>
		<ptr target="https://doi.org/10.1145/3034786.3056125" />
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>PODS. Association for Computing Machinery</publisher>
			<biblScope unit="page" from="93" to="99" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Semirings: Algebraic Theory and Applications in Computer Science</title>
		<author>
			<persName><forename type="first">Udo</forename><surname>Hebisch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hanns</surname></persName>
		</author>
		<author>
			<persName><surname>Weinert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>World Scientific</publisher>
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Advanced Dynamic Programming in Semiring and Hypergraph Frameworks</title>
		<author>
			<persName><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<idno>ISO SC32 / WG3</idno>
		<ptr target="https://www.gqlstandards.org/" />
		<title level="m">Graph Query Language GQL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Mathematical foundations of the GraphBLAS</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kepner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Aaltonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bulu√ß</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Franchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hutchison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lumsdaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Meyerhenke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zalewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mattson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Moreira</surname></persName>
		</author>
		<idno type="DOI">10.1109/HPEC.2016.7761646</idno>
		<ptr target="https://doi.org/10.1109/HPEC.2016.7761646" />
	</analytic>
	<monogr>
		<title level="m">IEEE High Performance Extreme Computing Conference (HPEC)</title>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Monoides et semi-anneaux complets</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Krob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semigroup Forum</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="323" to="339" />
			<date type="published" when="1987">1987. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Rev2: Fraudulent user prediction in rating platforms</title>
		<author>
			<persName><forename type="first">Srijan</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bryan</forename><surname>Hooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Disha</forename><surname>Makhija</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohit</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="333" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Edge weight prediction in weighted signed networks</title>
		<author>
			<persName><forename type="first">Srijan</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesca</forename><surname>Spezzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDM</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="221" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An Experimental Study of the Treewidth of Real-World Graph Data</title>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suraj</forename><surname>Jog</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2019.12</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2019.12" />
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<meeting><address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">ProvDB: A System for Lifecycle Management of Collaborative Analysis Workflows</title>
		<author>
			<persName><forename type="first">Hui</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Chavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amol</forename><surname>Deshpande</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1610.04963</idno>
		<ptr target="http://arxiv.org/abs/1610.04963" />
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Semiring Frameworks and Algorithms for Shortestdistance Problems</title>
		<author>
			<persName><forename type="first">Mehryar</forename><surname>Mohri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Lang. Comb</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="321" to="350" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Provenance-Based Routing in Probabilistic Graph Databases</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-2399/paper08.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB 2019 PhD Workshop</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Semiring Provenance over Graph Databases</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/tapp2018/presentation/ramusat" />
	</analytic>
	<monogr>
		<title level="m">TaPP</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Graph Databases</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Webber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emil</forename><surname>Eifrem</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>O&apos;Reilly Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Handbook of Formal Languages || Semirings and Formal Power Series: Their Relevance to Formal Languages and Automata</title>
		<author>
			<persName><forename type="first">Arto</forename><surname>Rozenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Grzegorz</surname></persName>
		</author>
		<author>
			<persName><surname>Salomaa</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-59136-5_9</idno>
		<idno>1007/978-3-642-59136-5</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-59136-5_9" />
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Provenance and Probabilities in Relational Databases: From Theory to Practice</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">ProvSQL: Provenance and Probability Management in PostgreSQL</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Jachiet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<idno type="DOI">10.14778/3229863.3236253</idno>
		<ptr target="https://doi.org/10.14778/3229863.3236253" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB)</title>
		<meeting>the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2018-08">2018. Aug. 2018</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="2034" to="2037" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">On the representation of finite distributive lattices</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Siggers</surname></persName>
		</author>
		<idno>arXiv 1412.0011</idno>
		<ptr target="http://arxiv.org/abs/1412.0011" />
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
	<note>math</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Linguistic Structure Prediction</title>
		<author>
			<persName><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
		<idno type="DOI">10.2200/S00361ED1V01Y201105HLT013</idno>
		<ptr target="https://doi.org/10.2200/S00361ED1V01Y201105HLT013" />
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Human Language Technologies</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="274" />
			<date type="published" when="2011-05">2011. May 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">PGQL: A Property Graph Query Language</title>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Oskar Van Rest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinha</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuming</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><surname>Chafi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2960414.2960421</idno>
		<ptr target="https://doi.org/10.1145/2960414.2960421" />
	</analytic>
	<monogr>
		<title level="m">GRADES</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>Article 7, 6</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
