<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Enabling Automatic Discovery and Querying of Web APIs at Web Scale using Linked Data Standards</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Franck</forename><surname>Michel</surname></persName>
							<email>franck.michel@cnrs.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<region>I3S</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Catherine</forename><surname>Faron-Zucker</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<region>I3S</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Corby</surname></persName>
							<email>olivier.corby@inria.fr</email>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<region>I3S</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
							<email>fabien.gandon@inria.fr</email>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<region>I3S</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Enabling Automatic Discovery and Querying of Web APIs at Web Scale using Linked Data Standards</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D4C080E21255C184A35D3BC99F4880AF</idno>
					<idno type="DOI">10.1145/3308560.3317073</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>SPARQL</term>
					<term>Web API</term>
					<term>discovery</term>
					<term>dataset</term>
					<term>Web service</term>
					<term>Linked Data</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>To help in making sense of the ever-increasing number of data sources available on the Web, in this article we tackle the problem of enabling automatic discovery and querying of data sources at Web scale. To pursue this goal, we suggest to (1) provision rich descriptions of data sources and query services thereof, (2) leverage the power of Web search engines to discover data sources, and (3) rely on simple, well-adopted standards that come with extensive tooling. We apply these principles to the concrete case of SPARQL micro-services that aim at querying Web APIs using SPARQL. The proposed solution leverages SPARQL Service Description, SHACL, DCAT, VoID, Schema.org and Hydra to express a rich functional description that allows a software agent to decide whether a microservice can help in carrying out a certain task. This description can be dynamically transformed into a Web page embedding rich markup data. This Web page is both a human-friendly documentation and a machine-readable description that makes it possible for humans and machines alike to discover and invoke SPARQL microservices at Web scale, as if they were just another data source. We report on a prototype implementation that is available on-line for test purposes, and that can be effectively discovered using Google's Dataset Search engine.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>datasets based on metadata, such as the manifold CKAN-based portals <ref type="foot" target="#foot_0">1</ref> like Datahub<ref type="foot" target="#foot_1">2</ref> and the data portals of European states and institutions. Some portals specialize in specific dataset formats or interface technologies. For instance, ProgrammableWeb.com <ref type="foot" target="#foot_2">3</ref>registers Web APIs, a loosely defined category of lightweight Web services also referred to as REST-like or Lo-REST <ref type="bibr" target="#b24">[25]</ref> services, while LODAtlas <ref type="bibr" target="#b25">[26]</ref> and SPARQLES <ref type="bibr" target="#b30">[31]</ref> focus on RDF datasets and SPARQL endpoints respectively.</p><p>Even though some of these portals have gained significant popularity due to the large number of datasets that they index, they suffer relentless flaws. Firstly, they are centralized registries with a somehow restricted scope. Consequently, potential data consumers may have to query several portals one by one, accommodating the various query interfaces, to discover suitable datasets. Secondly, in many cases, datasets are manually registered and annotated by dataset producers, thereby raising concerns about outdated metadata or deprecated services. Thirdly, metadata-based search results have a limited relevance. Typically, searching datasets by keywords and data formats is a first step in the discovery process, but a potential consumer needs deeper insight in the data themselves and the technical interfaces available to query the dataset. In this respect, WSDL-based semantic Web services (e.g. OWL-S <ref type="bibr" target="#b3">[4]</ref> or SAWSDL <ref type="bibr" target="#b7">[8]</ref>) tackled this question with a thorough description of the exchanged messages, yet often failing to describe the actual dataset being queried. Besides, they were better suited to the controlled environment of companies <ref type="bibr" target="#b19">[20]</ref> than the open environment of the Web. By contrast, the VoID vocabulary <ref type="bibr" target="#b0">[1]</ref> can help describe RDF datasets with regards to vocabularies, classes and properties used, links to other datasets, etc. But it does not address the description of what properties a resource may typically have nor how the resources relate to each other, which are key criteria in the discovery and selection of datasets.</p><p>To spur and enable automatic discovery and consumption of datasets at Web-scale, we believe that a few principles should drive future research and developments.</p><p>(1) Metadata-based search is not enough. As we pointed out above, metadata-based search using e.g. keywords, data formats, vocabularies or even classes and properties used in an RDF dataset, is just a first step in the discovery process.</p><p>For example, assume a biologist wants to develop a software agent capable of browsing Linked Data and gathering photos related to biological species. The agent may submit several queries to repositories such as LODAtlas looking for datasets whose textual description contains keywords "photo" and "biodiversity", or those whose VoID description (if any) mentions classes representing photographies and biological taxa. Within the matching datasets, however, nothing guarantees that photographic resources do actually depict biological species; photographies may well be scans of academic papers related to the species. Hence, the agent has no choice but to query the dataset in order to get insight into it and find out if it matches the search. This simple example illustrates the lack of in-depth semantic description of datasets, that would consist of the resources (what are the actual properties of photographic and taxonomic resources) along with their mutual relationships. <ref type="bibr" target="#b1">(2)</ref> The discovery of datasets at Web-scale should leverage the power of Web search engines. Major search engines such as Google, Yahoo and Bing crawl and index an unprecedented breadth of information every day. They already harvest the content of specialized open data portals, in particular by taking advantage of the growing use of the Schema.org vocabulary <ref type="bibr" target="#b11">[12]</ref>. Google has recently opened a beta service specifically dedicated to dataset search <ref type="foot" target="#foot_3">4</ref> . Therefore, despite concerns raised by the Web centralization effect of search engines, it is worth studying how we can take advantage of their services to enable the discovery and querying of datasets at Web scale. (3) The description of datasets and their query services should rely on well adopted (de-facto) standards. Enabling the automatic discovery and querying of datasets at Web-scale means that, at some point, a consensus should be reached with respect to technologies and practices. Such a consensus may emerge only if the selected approaches put little constraints on and require little efforts from those in charge of describing datasets, publishing and maintaining query services thereof. This means relying on existing, well-adopted standards or de-facto standards.</p><p>In terms of semantic description, existing vocabularies should be leveraged, ranging from mature and widely used W3C standards to de-facto standards such as Schema.org that benefits from a large and growing adoption even though it still lacks terms in many domains. Additionally, selected approaches should enjoy sufficient and appropriate tooling with APIs in various programming languages. Such tools should be relatively simple in the sense that (i) they should not require a long learning curve from developers, and (ii) they should be easy to deploy and maintain. In this respect, the example of WSDL-based semantic Web service frameworks is inspiring: their deployment and operation required significant efforts that only companies with solid IT services were ready to invest <ref type="bibr" target="#b24">[25]</ref>. But when seeking Web-scale adoption, such perceived complexity would have a counterproductive effect.</p><p>In a previous work, we defined the SPARQL Micro-Service architecture <ref type="bibr" target="#b22">[23]</ref> aimed at querying Web APIs using SPARQL <ref type="bibr" target="#b13">[14]</ref>, thus bridging the Linked Data and Web API worlds. We suggested that this approach could foster the emergence of an ecosystem of SPARQL services published by independent providers, allowing Linked Data-based applications to glean pieces of data from a wealth of distributed data sources, in a scalable and reliable manner.</p><p>In this article, we present further exploratory works aimed at applying the principles set out above, and thereby make SPARQL micro-services effectively discoverable and queryable at Web-scale. We describe and explain our architectural and modeling choices. Let us however underline that alternative choices may be figured out, driven by different incentives or trade-offs. We touch upon these considerations in the last section.</p><p>Envisaged use case. Figure <ref type="figure" target="#fig_0">1</ref> outlines the main steps of a typical use case as we see it, along with the main choices that we made. A SPARQL micro-service produces a Web page (step 1) whose primary goal, beyond providing developers with appropriate documentation and a testing interface, is to be processed by Web crawlers. It embeds rich markup data, notably based on Schema.org, to enhance indexing and help search engines yield more accurate results. The Web page is generated dynamically from the service self-description that consists of a SPARQL Service Description (SD) graph <ref type="bibr" target="#b32">[33]</ref> and a SHACL shapes graph <ref type="bibr" target="#b15">[16]</ref>. Together, they provide various metadata, a description of the graphs that the service typically spawns, the service inputs and outputs and the way they relate to one another. An application willing to carry out a certain task first queries search engines (step 2) for datasets matching certain keywords. From the search results, it extracts and looks up SPARQL endpoint URLs. SPARQL micro-services return an SD document that links to the shapes graph. In turn, the application fetches the shapes graph that allows verifying whether the service is indeed suited for the task (step 3). Based on the description of the service inputs, the application can submit an appropriate SPARQL query to the micro-service (step 4).</p><p>The rest of this article is organized as follows. Section 2 briefly summarizes the concepts of SPARQL micro-services and presents a quick example. Section 3 then presents the way we describe microservices in a machine-readable manner. Section 4 focuses on the way micro-services are made discoverable at Web scale. Related works are discussed in section 5 while the last section brings elements of discussion and suggests future leads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>In <ref type="bibr" target="#b21">[22]</ref>, we described the SPARQL Micro-Service architectural principles. Later on in <ref type="bibr" target="#b22">[23]</ref>, we extended this description and reported on several biodiversity-related use cases. In this section, we briefly summarize these previous works.</p><p>The SPARQL Micro-Service architecture addresses the problem of combining Linked Data with data from non-RDF Web APIs. A SPARQL micro-service is a lightweight SPARQL endpoint that provides access to a graph generated at run-time. This graph is shaped by the Web API service being wrapped, the arguments passed to the micro-service and the types of RDF triples it is designed to produce. How the arguments are passed to a SPARQL micro-service, and how the Web API response is transformed into a SPARQL result, are implementation choices.</p><p>In accordance with the micro-service architecture principles <ref type="bibr" target="#b23">[24]</ref>, a SPARQL micro-service is typically designed to be loosely coupled (it is deployed independently of other services, possibly using lightweight container technologies such as Docker <ref type="foot" target="#foot_4">5</ref> ) and fine-grained: it provides access to a small, resource-centric graph corresponding to a small fragment of the whole dataset served by the Web API.</p><p>Interestingly, this architecture can be used to assign dereferenceable URIs to Web API resources that do not have URIs in the first place: a micro-service responds to SPARQL queries by assigning URIs to Web API resources, while other micro-services are designed to dereference these URIs to RDF content. This entails an effective solution to bridge Web APIs, that are designed as closed worlds, with the open world of Linked Open Data.</p><p>Implementation. We implemented a lightweight PHP prototype available on GitHub<ref type="foot" target="#foot_5">6</ref> under the Apache 2.0 license. The prototype focuses on JSON-based Web APIs, and expects arguments of a micro-service to be passed as parameters of the service URL's query string. Figure <ref type="figure" target="#fig_1">2</ref> illustrates how a SPARQL micro-service S µ evaluates a SPARQL query Q. In step 1, S µ receives query Q and extracts the set Arд w of arguments from the HTTP query string. In step 2, it invokes the Web API with the arguments in Arд w , in addition to any other parameter required by the Web API. In step 3, S µ translates the JSON response into an RDF graph: it carries out a first mapping towards selected vocabularies by applying a JSON-LD profile <ref type="bibr" target="#b29">[30]</ref> to the response; the resulting graph G is loaded into a local triple store; if mappings are needed that JSON-LD cannot express, S µ runs a SPARQL INSERT query that enriches G with additional triples. Finally, S µ evaluates Q against G and returns the result to the client.</p><p>Alternative argument-passing method. In the method described above, the arguments of a SPARQL micro-service are passed as query string parameters rather than RDF terms. One advantage is that it spares creating new terms whenever a Web API-specific argument has no counterpart in existing vocabularies. Nevertheless, a downside is that the semantics of such a SPARQL micro-service differs from that of a standard SPARQL endpoint. Indeed, the SPARQL protocol treats a service URL as a black box, i.e. it does not identify nor interpret URL parameters apart from those specified in the SPARQL protocol itself. By contrast, in a SPARQL micro-service the query string parameters are meaningful arguments that shape the virtual graph being queried. Therefore, since one of our goals in this article is to comply with standards (principle 3), we have recently implemented an alternative method wherein arguments are passed as regular RDF terms of the SPARQL query graph pattern. To illustrate this, we now introduce an example that we shall reuse throughout the rest of this article.</p><p>Running example. Let us consider the service of Flickr's Web API that returns a list of photos matching some criteria <ref type="foot" target="#foot_7">7</ref> . We define S µf as a SPARQL micro-service<ref type="foot" target="#foot_8">8</ref> that wraps this Flickr service and returns photos of a given biological species. S µf takes as argument the species scientific (taxonomic) name, and searches photos matching this name. It abides by the convention that photos of a species should be tagged with the species scientific name formatted as taxonomy:binomial=&lt;scientific name&gt;<ref type="foot" target="#foot_9">9</ref> . S µf expects the scientific name argument to be passed as the object of the dwc:scientificName predicate.</p><p>Listing 1 depicts a query, Q 1 , that meets this requirement. It aims at retrieving photos depicting species Delphinus delphis, the common dolphin. When it evaluates Q 1 , S µf first extracts the scientific name argument from the graph pattern (highlighted line) and builds the following Web API invocation URL: Listing 2: Example graph produced by micro-service S µf to evaluate query Q 1 .</p><p>it evaluates Q 1 against this graph, yielding the response exemplified below in the SPARQL Query Results JSON format <ref type="bibr" target="#b27">[28]</ref>:</p><p>{ "head head head ": { " vars ": [ " title ", " img " ] }, "results results results ": { "bindings bindings bindings ": [ { " title ": { "type type type ": " literal ", "value value value ": " Delphinus delphis 5 (13 -7 -16 San Diego )" }, { " img ": { "type type type ": " uri ", "value value value ": " https :// farm6 . staticflickr . com /5718/ \ 31173091626 _88c410c3f2_z . jpg " } } ] } }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MACHINE-READABLE DESCRIPTION OF SPARQL MICRO-SERVICES</head><p>Building on the work presented in section 2, we aim at proposing a mechanism that enables a software agent to discover, select and invoke the SPARQL micro-services that are relevant for a certain task.</p><p>In section 1, we pointed out three principles that, we believe, should help pursue this goal: (1) have rich descriptions of data sources that go beyond common metadata, (2) leverage Web search engines to discover data sources, and (3) rely on well-adopted standards. This section presents the modeling choices we made with respect to principle (1), section 4 deals with principle (2) while principle (3) is transversal to both sections. A rich SPARQL micro-service description should span two distinct levels further detailed in this section. The high-level description consists of metadata about the data being queried (keywords, publisher, license, vocabularies, graphs, etc.), as well as metadata about the micro-service itself (supported operations, result formats, etc.). The functional description describes the actions the services carries out: what are the types of resources involved, what are their recommended/expected properties, what are the service arguments and how they relate to the resources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">High-level Description</head><p>To describe SPARQL micro-services, we use SPARQL Service Description (SD) <ref type="bibr" target="#b32">[33]</ref> which is both a vocabulary to describe SPARQL endpoints and a method requiring compliant endpoints to return an SD document when their URL is looked up.</p><p>Listing 3 depicts a snippet of the SD document (in the Turtle syntax) for the example service S µf introduced in section 2. The service is at the same time an instance of the SD Service class and the class of SPARQL micro-services sms:Service (line 17). Common metadata are provided lines 19 to 26, such as a name and description, keywords, supported SPARQL language and result formats. A VoID description can also be embedded here, as exemplified in line 29 (the default dataset is stated to be a void:Dataset) and lines 34 to 36 10 . Additional triples are not depicted here for conciseness, such as the service publisher and an example SPARQL query. Note that many more metadata could be provided, such as common dataset profile features <ref type="bibr" target="#b1">[2]</ref>. Furthermore, in the implementation we demonstrate here, we wrote the SD document manually. Future works could consider dataset profiling techniques to (at least partially) automate this generation.</p><p>The SD document is obtained by looking up the service URL. Content negotiation is supported such that a Web browser will obtain an HTML page, whereas a Linked Data application would typically require one of the supported RDF serialization syntaxes. The SD document itself is a named graph of the dataset served by the SPARQL micro-service (line 31). The interested reader may view the full range of metadata by looking up the named graph URI 11 in a Web browser (this will typically return an RDF/XML representation) or by issuing the following command on a standard Linux system: curl --header " Accept : text / turtle " \ http :// sms . i3s . unice . fr / sparql -ms / flickr / getPhotosByTaxon_sd /</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Functional Description</head><p>There exist various options to represent the functional description of a service. In section 5 we discuss some of them. As far as SPARQL micro-services are concerned, we choose to leverage several vocabularies for this purpose: SHACL <ref type="bibr" target="#b15">[16]</ref>, Schema.org and Hydra <ref type="bibr" target="#b18">[19]</ref>. SHACL Description of the Dataset. SHACL, the Shapes Constraint Language, is designed for the validation of RDF graphs (called data graphs) against a set of conditions expressed in the form of shapes graphs. In our context, instead of using a shapes graph G sh a posteriori to validate the data graph produced by a 10 As an alternative, a VoID description could be made available using the well-known URIs mechanism, at path /.well-known/void. Listing 3: Snippet of the Service Description of SPARQL micro-service S µf .</p><p>SPARQL micro-service, we consider G sh as a specification of the graphs that a SPARQL micro-service can generate. The shapes graph is linked to the SD document as follows: the default dataset has a default graph that is validated by the shapes graph (property shacl:shapesGraph lines 30). The shapes graph is itself one of the named graphs of the default dataset (line 32).</p><p>A short snippet of the shapes graph corresponding to service S µf is given in Listing 4. The interested reader may check the complete shapes graph on GitHub 12 or by dereferencing its URI 13 . It states that an instance of class dwc:Taxon (lines 4-5) should have 12 Complete shapes graph on GitHub: https://frama.link/we_EQWnC 13 Shapes graph URI: http://sms.i3s.unice.fr/sparql-ms/flickr/getPhotosByTaxon_sd/ ShapesGraph exactly three properties: rdf:type with object dwc:Taxon (lines 9-10), shacl:image whose object should be validated against another shape (lines 12-13) and property dwc:scientificName that should have exactly one literal object (lines <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref>. Notice that the graph pattern of query Q 1 (Listing 1) specifically matches these constraints.</p><p>Description of the Input Arguments. We now need to characterize the micro-service input arguments, how they are extracted from a SPARQL graph pattern, and how they map to parameters of the Web API wrapped by the micro-service. We define the Web API as the micro-service data source (line 39 of Listing 3). It is typed as a Schema.org WebAPI having one potential action of type SearchAction (lines 40-44). Note that an alternative is currently being discussed within the Schema.org community, that links EntryPoint objects to a WebAPI <ref type="bibr" target="#b26">[27]</ref>. The search action is also typed as a Hydra IriTemplate whose template string is the Web API invocation URL (lines 46-48). Each mapping (lines 50-58) maps a parameter used in the template string to a term of the SPARQL query by pointing to a specific property using hydra:property. In our example, the scientific name, denoted "{name}" in the template string (line 48), is mapped to property dwc:scientificName (line 57). Upon invocation, the service simply reads the value of property dwc:scientificName in the graph pattern, and substitutes it with "{name}" in the template string.</p><p>This solution is simple and concise, but it presents two downsides: (i) hydra:property only names a property but does not put any other constraint such as what is the subject of this property, or how many values are allowed; (ii) there is no explicit relationship between the input argument and the shapes graph. Hence, to specify the input arguments more precisely, an alternative is to map the parameter to a property shape of the shapes graph. In our example, this would be expressed by replacing line 57 with the following:</p><formula xml:id="formula_0">shacl : sourceShape &lt; ShapesGraph # NamePropertyShape &gt;;</formula><p>The referenced property shape is defined in Listing 4 (lines <ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref>. Not only it instructs that the scientific name should be given by property dwc:scientificName, but also that this property should be attached to an instance of the dwc:Taxon class and that there should be only one such property.</p><p>Advantages of using SHACL. We believe that using SHACL presents two advantages: (1) SHACL's expressiveness allows denoting complex relationships between resources (e.g. cardinality, predicate paths). Even though this description is schema-based, it is sufficient to enable SPARQL micro-service discovery and selection since, by construction, the shape of generated graphs is know at design time. By contrast, SPARQL federated query engines generally rely on dynamic instancebased statistics because the graphs being queried can hardly be characterized by a static SHACL description. For instance, it would be impossible to define a precise shapes graph of crowd-sourced graphs such as DBpedia.</p><p>(2) A SHACL shapes graph is itself an RDF graph. Therefore, a software agent can leverage existing tooling to reason upon it and verify whether the SPARQL micro-service fulfills the agent's goals. As an illustration, we are currently developing a SPARQL microservice federated query engine 14 . Given an input SPARQL query, the engine searches candidate SPARQL micro-services whose inputs 14 Beta version available at https://frama.link/VWG7r8PF. are satisfied by the query. It then selects those whose shapes graphs validate some triple patterns of the query, and finally rewrites the input query into a UNION of SERVICE clauses that invoke SPARQL micro-services. Each step of the processing (selection, matchmaking, query rewriting) is performed using SPARQL queries that involve the SD documents, the shapes graphs and the input query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Invocation</head><p>To process an incoming SPARQL query, a SPARQL micro-service needs to extract the input arguments from the query graph pattern.</p><p>For instance, when a client invokes S µf with query Q 1 (Listing 1), S µf must extract the object of property dwc:scientificName (Delphinus delphis) to perform the subsequent invocation of Flickr's Web API. This involves reasoning simultaneously on the query graph pattern, the SD document that describes the arguments mappings, and optionally the shapes graph if the mappings refer to property shapes. Since a SPARQL graph pattern is not represented in RDF, we first translate the incoming query into its SPIN representation <ref type="bibr" target="#b14">[15]</ref> that we load into the local triple store as a temporary graph. A major advantage of this approach is that extracting the input arguments can be carried out declaratively within a single SPARQL query rather than in custom code. This query is shown in Listing 5. The first member of the UNION clause (lines 4-11) matches the case where arguments are denoted with hydra:property: it retrieves the object of hydra:property (line 8), i.e. dwc:scientificName, and looks for it in the SPARQL query SPIN graph (line 11). By contrast, the second member (lines 15-34) matches the case where arguments are denoted with a property shape.</p><p>Once the arguments have been extracted, the rest of the SPARQL query evaluation is performed as illustrated in section 2.</p><p>Implementation. To implement this solution, we deployed Corese <ref type="bibr" target="#b6">[7]</ref>, an in-memory triple store, as the SPARQL engine underlying SPARQL micro-services. Corese implements the SPARQL Template Transformation Language (STTL) <ref type="bibr" target="#b4">[5]</ref> and comes with a built-in STTL SPARQL-to-SPIN transformation. For greater flexibility, our implementation allows passing arguments with VALUES or FILTER clauses, which entails a substantially more complicated query than the one depicted in Listing 5. In particular, it leverages the LDScript <ref type="bibr" target="#b5">[6]</ref> SPARQL extension to define functions able to parse the nested RDF lists entailed by the VALUES clause <ref type="foot" target="#foot_10">15</ref> .</p><p>From a more general perspective, the approach we propose considers the service as a coherent, self-contained, reflexive system where RDF and SPARQL are used internally for the service selfdescription and configuration, at run-time for the query processing, and as the service external interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">WEB-SCALE DISCOVERY OF SPARQL MICRO-SERVICES</head><p>In section 1, we suggested that Web search engines can play a key role in enabling the automatic discovery and querying of data sources at Web-scale. Applied to our context, this means that SPARQL micro-services should be published along with a dedicated Web page to be indexed by search engines. Furthermore, major search engines now recommend the inclusion of markup data in Web pages to enhance indexing and consequently yield more accurate results. Therefore, to spur Web-scale discovery while avoiding redundant work, we propose that SPARQL micro-services dynamically transform their service description into Web pages that embed rich markup data meant for search engines. Following content negotiation principles, the micro-service URL dereferences to this Web page if it is looked up by a Web browser, while it dereferences to the SPARQL SD document when requested with appropriate RDF media types.</p><p>To standardize such markup data, Google, Yahoo, Bing and Yandex support the Schema.org community project that has become a de-facto standard. In particular, Google's recently launched Dataset Search service 16 exploits Schema.org's Dataset term 17 as well as equivalent terms from the DCAT W3C recommendation <ref type="bibr" target="#b20">[21]</ref>. A Schema.org Dataset consists of a set of distributions represented by means of the DataDownload object that, unfortunately, is not suited to depict API resources such as SPARQL endpoints. Ongoing discussions are held within the Schema.org community regarding how to annotate a Dataset with the interfaces that allow access it 18 . Until a consensus be eventually adopted, a common workaround implemented by the CKAN data portal 19 is to associate to the DataDownload object the encoding format "api/sparql". Although semantically questionable ("api/sparql" is not a standard IANA media type 20 ), this practice is a trade-off between the need for valid semantic description and the need for effective Web-scale discovery means. Furthermore, given the popularity of CKAN for hosting data portals, this practice tends to spread out.</p><p>In the context of SPARQL micro-services, we mitigate this issue with a twofold approach. On the one hand, we comply with the DataDownload + "api/sparql" encoding format practice to ensure maximum discoverability. On the other hand, we embed additional DCAT Dataset and Distribution objects conveying similar information in a more semantically formal manner. Both ways are depicted in Listing 6, lines 24-30 and 38-49 respectively.</p><p>Results. The combination of standard content negotiation, semantic Web standards and current Linked Data practices fuels a human-friendly documentation and testing interface on one side and a machine-readable Linked Data description on another side. Furthermore, this combined use pushes "RDF in HTML" descriptions to Web crawlers and indexes in such a way that the described services can be effectively discovered and called by both humans and machines as if they were just another data source.</p><p>As an illustration, at the time of writing, the example service S µf can be discovered in Google Dataset Search using the keywords "biodiversity" and "photography". Figure <ref type="figure" target="#fig_2">3</ref> shows a snapshot of the result page. Notice that the available download format is appropriately set to SPARQL. Furthermore, adding keyword "sparql" returns the micro-service as the first result in the result page.</p><p>Implementation. The Web page generation is performed using the technologies already introduced in section 3.3. An STTL transformation 21 instantiates HTML templates with elements from the SPARQL SD document. The embedded markup data (exemplified in Listing 6) is generated by a SPARQL CONSTRUCT query whose result is passed to a generic built-in STTL transformation that serializes RDF data in JSON-LD. All these transformations are 16 Google Dataset Search: http://g.co/datasetsearch 17 Schema.org Dataset: https://schema.org/Dataset 18 https://github.com/schemaorg/schemaorg/issues/1423. Accessed Jan. 30th 2019. 19 The CKAN project: https://ckan.org/ 20 IANA media types: https://www.iana.org/assignments/media-types/ 21 The whole transformation code is available at: https://frama.link/hBDkM7ep. 1 { 2 " @context ": [ 3 " http :// schema . org ", 4</p><p>{ " dcat ": " http :// www . w3 . org / ns / dcat #" , 5</p><p>" frmt ": " http :// www . w3 . org / ns / formats /" } 6 ], 7 8 " @type ": "Dataset", 9 " identifier ": 10 " http :// sms . i3s . unice . fr / sparq -ms / flickr / getPhotosByTaxon_sd /" , 11 " name ": " Search for Flickr photos by scientific name ", 12 " description ": "..." , 13 " publisher ": { 14 " @type ": " Organization ", 15</p><p>" name ": " Universite Cote d ' Azur , CNRS , Inria , I3S ", 16 }, 17 " keywords ": [ " biodiversity ", " lifesciences ", " photography " ], 18 " isBasedOn ": { 19 " @type ": " CreativeWork ", 20 " @id ": " https :// www . flickr . com / services / api /" , 21</p><p>" name ": " Flickr Web API " 22 }, 23 24 "distribution": { 25 " @type ": "DataDownload", independent of any service and domain. The whole process happens at run-time upon look-up of the micro-service URL. A snapshot of the Web page generated by service S µf is displayed in Figure <ref type="figure" target="#fig_3">4</ref>, and the reader may access this page by pointing a Web browser at http://sms.i3s.unice.fr/sparql-ms/flickr/getPhotosByTaxon_sd/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATED WORKS</head><p>The work presented in this article addresses two fundamental questions that have been studied under many different perspectives: capturing the functionality of Web services on one side, and automating their discovering and consumption by software agents on the other side.</p><p>Works about semantic Web services, whether "big" WSDL-based (e.g. OWL-S <ref type="bibr" target="#b3">[4]</ref>, SAWSDL <ref type="bibr" target="#b7">[8]</ref>) or REST-based (e.g. WADL <ref type="bibr" target="#b12">[13]</ref>), have long tackled the question of capturing the functionality of a service through the semantic description of their inputs, outputs and the way they relate to one another. These models, that Clicking on the sms.i3s.unice.fr link opens the micro-service Web page depicted in Figure <ref type="figure" target="#fig_3">4</ref>. support automatic discovery, invocation and composition of Web services, usually entail the deployment of complex frameworks requiring advanced skills and tooling. Besides, service discovery is made possible using a centralized repository such as the Universal Description Discovery and Integration (UDDI) registry 22 . As a consequence, they are better suited to the controlled environment of 22 UDDI specification: http://uddi.org/pubs/uddi-v3.0.2-20041019.htm companies <ref type="bibr" target="#b19">[20]</ref> than the open, loosely constrained environment of the Web that we wish to address. By contrast, Web APIs are quite simple to deploy and interact with. Still, it is hardly possible to discover and invoke them automatically insofar as they commonly rely on proprietary vocabularies described in Web-based documentation with little concern for semantic interoperability. To fulfill this lack, some initiatives seek to enrich existing human-readable documentation of Web APIs with markup data so as to make it machine-processable. They rely on microformats (e.g. hRESTS <ref type="bibr" target="#b16">[17]</ref>) possibly joined to existing service ontologies (e.g. MicroWSMO <ref type="bibr" target="#b8">[9]</ref>), or RDFa (e.g. SA-REST <ref type="bibr" target="#b9">[10]</ref>). These methods are however more concerned with describing the service interface (operations, parameter types) than its actual functionality. Indeed, the description of the resources manipulated is delegated to domain ontologies that provide terms for classes and properties, but often put little constraints on how to use them. By contrast, we harness SHACL specifically to address this lack. SHACL can describe rich constraints on what can be stated, thus making it possible to specify in a comprehensive manner how resources relate to each other.</p><p>OpenAPI <ref type="foot" target="#foot_11">23</ref> takes the problem the other way round: it equips a Web APIs with a machine-readable documentation, that, in turn, can be compiled into a Web page. This is closer to our approach, yet, this description remains at a syntactic level essentially enabling the automatic generation of server-and clients-side stubs, very similar to what WSDLs enabled for "heavy" Web services.</p><p>Linked REST APIs (LRA) <ref type="bibr" target="#b28">[29]</ref> is a framework dedicated to the semantic annotation of Web APIs and the automatic specification of SPARQL query execution plans that invoke these Web APIs. The framework relies on a centralized repository that stores the Web APIs descriptions and offers search services. Several key differences with our work can be pointed out. With SPARQL micro-services, we seek to set up a totally distributed architecture wherein independent service providers may publish SPARQL micro-services that can be discovered using regular Web search engines, rather than a centralized repository. Furthermore, LRA describes a Web API by means of a custom vocabulary and relies on a SPARQL graph pattern to serve as a functional description. To spur large adoption, we instead stick to standard vocabularies, and we use SHACL to describe resources as it allows for more expressiveness than a sheer SPARQL graph pattern.</p><p>RESTdesc <ref type="bibr" target="#b31">[32]</ref> is a semantic description format for hypermedia APIs. It captures the functional description of APIs in Notation3 <ref type="bibr" target="#b2">[3]</ref>, a language extending RDF's data model with variables, existential and universal quantifiers, and logical implications. RESTdesc relies on the HTTP mechanisms and RESTful principles for the discovery and invocation of semantically described Web services. Starting from a known URI, an application can follow its nose by resolving links and making sense of Notation3 service descriptions. This is an elegant solution that however requires Notation3 reasoners able to interpret the advanced features of quantification and logical implications. Such reasoners exist but are far less common than SPARQL-based implementations available in many programming languages. Since we seek a solution that can be adopted easily by a large community of independent actors, leveraging more common standards such as regular RDF and SPARQL is probably more promising.</p><p>In line with our idea of leveraging Web search engines to discover relevant datasets and query services, SpEnD <ref type="bibr" target="#b33">[34]</ref> is a metacrawler designed to discover SPARQL endpoints. It first creates a list of keywords commonly found on Web pages advertising SPARQL endpoints, such as the pages of DataHub. It then looks for these keywords on search engines, explores the result Web pages looking for SPARQL endpoint URLs and looks up these URLs in search for VoID or SPARQL SD documents. This kind of approach is clearly what could be implemented to discover SPARQL micro-services at Web scale. We believe that the usage of well-adopted markup data could help enhance search results and, in this respect, dataset-search services such as Google Dataset Search could be more effective than generic Web search engines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION AND PERSPECTIVES</head><p>In this article, we address the problem of enabling automatic discovery and consumption of data sources at Web scale. We suggested that three principles should be considered to pursue this goal: (1) provision rich descriptions of data sources and query services, (2) leverage the power of Web search engines to discover data sources, and (3) rely on simple, well-adopted standards that come with extensive tooling. We applied these principles to the concrete case of SPARQL micro-services that aim at querying Web APIs using SPARQL. The proposed solution considers a SPARQL Service Description (SD) document as the description central point. It links to a SHACL shapes graph describing precisely the resources manipulated by the micro-service. It also connects the resources to the micro-service inputs, thereby coming up with a rich functional description that allows a software agent to decide whether this micro-service can help in carrying out a certain task. To enable accurate discovery using common Web crawlers, the SD document can be dynamically transformed into a Web page embedding rich markup data based on Schema.org's Dataset term and the DCAT vocabulary.</p><p>From a general perspective, the combination of standard content negotiation, semantic Web standards and Linked Data practices fuels a human-friendly documentation and machine-readable description that make it possible for humans and machines alike to discover and invoke SPARQL micro-services as if they were just another data source.</p><p>We showed that our approach is effective as our example SPARQL micro-service can be successfully discovered using the Google Dataset Search engine (as illustrated in Figure <ref type="figure" target="#fig_2">3</ref>). From this point on, a framework such as SpEnD (described in section 6) could be extended to accommodate the invocation of SPARQL micro-services. Service composition-based query answering systems could fetch the shapes graphs of candidate SPARQL micro-services, check the compatibility of their inputs and outputs with respect to the query to process, and finally compute and enact valid compositions. In particular, SPARQL query federation is a specific type of Web service composition wherein any piece of data in the federated graphs may play the role of either an input or an output. Existing federated query engines could be extended so as to reason on the description of SPARQL micro-services and come up with query plans that respect SPARQL micro-services' input requirements.</p><p>As pointed out in section 4, denoting a SPARQL endpoint using Schema.org terms is still quite unpractical at the moment. From a more general perspective, describing the multiple interfaces that a client may use to access a dataset is an increasingly pressing need. The Schema.org community is currently thinking this through with discussions revolving around the Dataset, WebAPI and EntryPoint terms. Concomitantly, the DCAT community is working out the next version of the W3C DCAT recommendation <ref type="bibr" target="#b10">[11]</ref> that defines the generic concept of DataService meant to serve dataset distributions. The term is flexible enough to accommodate various types of interfaces, providing notably a contract the interface conforms to and an out-of-band description that may typically be a SPARQL SD document in our context.</p><p>In the current state of our work, SHACL graphs are used as a specification of the graphs that a SPARQL micro-service can generate. We can think of two interesting leads for future works in this respect. Firstly, once a shapes graph is published with its own dereferenceable URI, it can be reused by SPARQL micro-services providers, thereby sparing time and making it possible to share common practices. A second lead could be to consider SHACL as a way for a client to request responses in a certain shape. This would amount to some sort of extended content negotiation where a client could express that it would prefer a response not only favoring a vocabulary over another, but also describing resources and their relationships according to a certain shape, as much as possible.</p><p>Finally, whether our approach succeeds in reaching principle (3) (rely on well-adopted standards) is debatable and possibly a matter of perspective and community. Some people contend that Semantic Web standards are not likely to be largely adopted by Web developers <ref type="bibr" target="#b17">[18]</ref> due to the perceived complexity of RDF and SPARQL, as compared to RESTful APIs for instance. Besides, SHACL is a rich language, yet perhaps too rich to gain large adoption. In the end however, we do believe that there will be room for different types of interfaces, suited to different contexts and scenarios. This article primarily intends to propose a research direction, not a ready-to-use solution. And we encourage the interested readers to explore alternative architectural and modeling choices.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Envisaged use case spanning the indexing, discovery and invocation of a SPARQL micro-service.</figDesc><graphic coords="3,116.85,83.69,378.33,108.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: SPARQL micro-service processing workflow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Google Dataset Search result page showing the example SPARQL micro-service S µf .Clicking on the sms.i3s.unice.fr link opens the micro-service Web page depicted in Figure4.</figDesc><graphic coords="9,142.07,83.69,327.86,188.92" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Web page automatically generated from the description of SPARQL micro-service S µf .</figDesc><graphic coords="9,154.68,318.56,302.67,249.97" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>prefix prefix prefix schema : &lt; http :// schema . org /&gt; prefix prefix prefix dwc :&lt; http :// rs . tdwg . org / dwc / terms /&gt; Listing 1: Query Q 1 can be submitted to SPARQL microservice S µf in order to retrieve photos of species Delphinus delphis.</figDesc><table><row><cell>SELECT SELECT SELECT ? title ? img WHERE WHERE WHERE {</cell></row><row><cell>? taxon a dwc : Taxon ;</cell></row><row><cell>dwc:scientificName "Delphinus delphis";</cell></row><row><cell>schema : image [</cell></row><row><cell>a schema : Photograph ;</cell></row><row><cell>schema : name ? title ;</cell></row><row><cell>schema : contentUrl ? img .</cell></row><row><cell>].</cell></row><row><cell>}</cell></row><row><cell>[] a dwc : Taxon ;</cell></row><row><cell>dwc : scientificName " Delphinus delphis ";</cell></row><row><cell>schema : image &lt; http :// example . org / ld / flickr / photo /31173091626 &gt;.</cell></row></table><note><p>&lt; http :// example . org / ld / flickr / photo /31173091626 &gt; a schema : Photograph ; schema : name " Delphinus delphis 5 (13 -7 -16 San Diego )"; schema : contentUrl &lt; https :// farm6 . staticflickr . com /5718/31173091626 _88c410c3f2_z . jpg &gt;; schema : mainEntityOfPage &lt; https :// flickr . com / photos /10770266 @N04 /31173091626 &gt;; schema : fileFormat " image / jpeg "; schema : author [ schema : identifier "10770266 @N04 "; schema : url &lt; https :// flickr . com / photos /10770266 @N04 &gt; ].</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Listing 5: Extraction of input argument predicates and values (variables ?predicate and ?value) from a SPARQL query submitted to a SPARQL micro-service. The default dataset contains the SPARQL query SPIN graph, the shapes graph and the SPARQL SD graph.</figDesc><table><row><cell cols="2">1 SELECT SELECT SELECT DISTINCT DISTINCT DISTINCT ? name ?predicate ?value</cell></row><row><cell cols="2">2 WHERE WHERE WHERE {</cell></row><row><cell>3 {</cell><cell></cell></row><row><cell>4</cell><cell># Predicate given with hydra : property</cell></row><row><cell>5</cell><cell>[] a sd : Service ;</cell></row><row><cell>6</cell><cell>dct : source [ schema : potentialAction [ hydra : mapping [</cell></row><row><cell>7</cell><cell>hydra : variable ? name ;</cell></row><row><cell>8</cell><cell>hydra:property ?predicate;</cell></row><row><cell>9</cell><cell>]]].</cell></row><row><cell>10</cell><cell></cell></row><row><cell>11</cell><cell>[] sp : predicate ?predicate; sp : object ?value.</cell></row><row><cell>12 }</cell><cell></cell></row><row><cell cols="2">13 UNION UNION UNION</cell></row><row><cell>14 {</cell><cell></cell></row><row><cell>15</cell><cell># Predicate given through a property shape</cell></row><row><cell>16</cell><cell>[] a sd : Service ;</cell></row><row><cell>17</cell><cell>dct : source [ schema : potentialAction [</cell></row><row><cell>18</cell><cell>hydra : mapping [</cell></row><row><cell>19</cell><cell>hydra : variable ? name ;</cell></row><row><cell>20</cell><cell>shacl : sourceShape ? propShape ;</cell></row><row><cell>21</cell><cell>]]].</cell></row><row><cell>22</cell><cell></cell></row><row><cell>23</cell><cell>? nodeShape a shacl : NodeShape ; shacl : property ? propShape .</cell></row><row><cell>24</cell><cell>? propShape a shacl : PropertyShape ; shacl:path ?predicate.</cell></row><row><cell>25</cell><cell>OPTIONAL OPTIONAL OPTIONAL {</cell></row><row><cell>26</cell><cell>? nodeShape shacl : property [</cell></row><row><cell>27</cell><cell>shacl : path rdf : type ; shacl : hasValue ? class</cell></row><row><cell>28</cell><cell>]</cell></row><row><cell>29</cell><cell>}</cell></row><row><cell>30</cell><cell></cell></row><row><cell>31</cell><cell>[] sp : subject ? subject ; sp : predicate ?predicate; sp : object ?value.</cell></row><row><cell>32</cell><cell>OPTIONAL OPTIONAL OPTIONAL {</cell></row><row><cell>33</cell><cell>[] sp : subject ? subject ; sp : predicate rdf : type ; sp : object ? class .</cell></row><row><cell>34</cell><cell>}</cell></row><row><cell>35 }</cell><cell></cell></row><row><cell>36 }</cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://ckan.org/about/instances/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://datahub.ckan.io/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>https://www.programmableweb.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>https://www.blog.google/products/search/making-it-easier-discover-datasets/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>https://www.docker.com</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>https://github.com/frmichel/sparql-micro-service/tree/0.3.1/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_6"><p>https :// api . flickr . com / services / rest /?format format format = json &amp;method method method = flickr . photos . search &amp; tags tags tags = taxonomy : binomial = Delphinus + delphis</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>https://www.flickr.com/services/api/flickr.photos.search.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_8"><p>The code of this service is available at https://frama.link/kVhhnE-v.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_9"><p>This is a common convention used on Flickr for biodiversity resources, in particular the Encyclopedia of Life group (https://www.flickr.com/groups/806927@N20) and the Biodiversity Heritage Library (https://www.flickr.com/photos/biodivlibrary).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_10"><p>The complete query is available at https://github.com/frmichel/sparql-micro-service/ tree/0.3.1/src/sparqlms/resources/read_input_from_gp.sparql.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="23" xml:id="foot_11"><p>https://github.com/OAI/OpenAPI-Specification</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Describing Linked Datasets with the VoID Vocabulary</title>
		<author>
			<persName><forename type="first">Keith</forename><surname>Alexander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Cyganiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Hausenblas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation</title>
		<imprint>
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">RDF Dataset Profilinga Survey of Features, Methods, Vocabularies and Applications. Semantic Web -Interoperability</title>
		<author>
			<persName><forename type="first">Mohamed</forename><surname>Ben Ellefi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zohra</forename><surname>Bellahsene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">G</forename><surname>Breslin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elena</forename><surname>Demidova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Dietze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julian</forename><surname>Szymański</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantin</forename><surname>Todorov</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-180294</idno>
		<ptr target="https://doi.org/10.3233/SW-180294" />
	</analytic>
	<monogr>
		<title level="j">Usability, Applicability</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="677" to="705" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Notation3 (N3): A Readable RDF Syntax</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Berners-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Connolly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">W3C Team Submission</title>
		<imprint>
			<date type="published" when="2011-03">2011. March 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">OWL-S: Semantic Markup for Web Services</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Burstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerry</forename><surname>Hobbs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ora</forename><surname>Lassila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Drew</forename><surname>Mcdermott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sheila</forename><surname>Mcilraith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srini</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Paolucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bijan</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Terry</forename><surname>Payne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evren</forename><surname>Sirin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naveen</forename><surname>Srinivasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katia</forename><surname>Sycara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">W3C Member Submission</title>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">STTL: A SPARQL-Based Transformation Language for RDF</title>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Corby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catherine</forename><surname>Faron-Zucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th International Conference on Web Information Systems and Technologies (ISWC)</title>
		<meeting><address><addrLine>Lison, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">LDScript: A Linked Data Script Language</title>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Corby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catherine</forename><surname>Faron-Zucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Semantic Web Conference (ISWC)</title>
		<meeting>the 16th International Semantic Web Conference (ISWC)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="208" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The KGRAM Abstract Machine for Knowledge Graph Querying</title>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Corby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catherine</forename><surname>Faron Faron-Zucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Web Intelligence and Intelligent Agent Technology (WI-IAT)</title>
		<meeting>the International Conference on Web Intelligence and Intelligent Agent Technology (WI-IAT)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="338" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Semantic Annotations for WSDL and XML Schema</title>
	</analytic>
	<monogr>
		<title level="j">W3C Recommendation</title>
		<editor>
			<persName><forename type="first">Joel</forename><surname>Farrell</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Holger</forename><surname>Lausen</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">MicroWSMO v2 -Defining the Second Version of MicroWSMO as a Systematic Approach for Rich Tagging</title>
		<author>
			<persName><forename type="first">Florian</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barry</forename><surname>Norton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">SA-REST: Semantic Annotation of Web Resources</title>
		<author>
			<persName><forename type="first">Karthik</forename><surname>Gomadam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ajith</forename><surname>Ranabahu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">W3C Member Submission</title>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Data Catalog Vocabulary (DCAT) -revised edition</title>
		<author>
			<persName><forename type="first">Alejandra</forename><surname>Gonzalez Beltran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Browning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simon</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Winstanley</surname></persName>
		</author>
		<ptr target="https://w3c.github.io/dxwg/dcat/Accessed:2019-02-01" />
		<imprint>
			<date type="published" when="2019-02">2019. February 2019. 2019</date>
		</imprint>
	</monogr>
	<note>W3C Editor&apos;s Draft 01</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Schema.Org: Evolution of Structured Data on the Web</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Brickley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steve</forename><surname>Macbeth</surname></persName>
		</author>
		<idno type="DOI">10.1145/2857274.2857276</idno>
		<ptr target="https://doi.org/10.1145/2857274.2857276" />
	</analytic>
	<monogr>
		<title level="j">ACM Queue -Strutured Data</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="10" to="10" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Web Application Description Language</title>
		<author>
			<persName><forename type="first">Marc</forename><surname>Hadley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">W3C Member Submission</title>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SPARQL 1.1 Query Language</title>
		<author>
			<persName><forename type="first">Steve</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andy</forename><surname>Seaborne</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/2013/REC-sparql11-query-20130321/" />
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">SPIN -SPARQL Syntax</title>
		<author>
			<persName><forename type="first">Holger</forename><surname>Knublauch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">W3C Member Submission</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Shapes Constraint Language (SHACL)</title>
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation</title>
		<editor>
			<persName><forename type="first">Holger</forename><surname>Knublauch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dimitris</forename><surname>Kontokostas</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">hRESTS: An HTML Microformat for Describing RESTful Web Services</title>
		<author>
			<persName><forename type="first">Jacek</forename><surname>Kopecky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Karthik</forename><surname>Gomadam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tomas</forename><surname>Vitvar</surname></persName>
		</author>
		<idno type="DOI">10.1109/WIIAT.2008.379</idno>
		<ptr target="https://doi.org/10.1109/WIIAT.2008.379" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE/WIC/ACM International Conference on Web Intelligence</title>
		<meeting>the IEEE/WIC/ACM International Conference on Web Intelligence<address><addrLine>WI-IAT</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="619" to="625" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Semantic Description Language for RESTful Data Services to Combat Semaphobia</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Lanthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Gütl</surname></persName>
		</author>
		<idno type="DOI">10.1109/DEST.2011.5936597</idno>
		<ptr target="https://doi.org/10.1109/DEST.2011.5936597" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Digital Ecosystems and Technologies</title>
		<meeting>the IEEE International Conference on Digital Ecosystems and Technologies</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="47" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Hydra: A Vocabulary for Hypermedia-Driven Web APIs</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Lanthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Gütl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Workshop on Linked Data on the Web (LDOW2013)</title>
		<meeting>the 6th Workshop on Linked Data on the Web (LDOW2013)</meeting>
		<imprint>
			<publisher>CEUR-WS</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Semantic Web Services in Corporate Memories</title>
		<author>
			<persName><forename type="first">Moussa</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICIW.2007.59</idno>
		<ptr target="https://doi.org/10.1109/ICIW.2007.59" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second International Conference on Internet and Web Applications and Services</title>
		<meeting>the Second International Conference on Internet and Web Applications and Services</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">Fadi</forename><surname>Maali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phil</forename><surname>Archer</surname></persName>
		</author>
		<title level="m">Data Catalog Vocabulary (DCAT). W3C Recommendation</title>
		<imprint>
			<date type="published" when="2014-01">2014. Jan. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">SPARQL Micro-Services: Lightweight Integration of Web APIs and Linked Data</title>
		<author>
			<persName><forename type="first">Franck</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catherine</forename><surname>Faron-Zucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Linked Data on the Web Workshop (LDOW2018)</title>
		<meeting>the Linked Data on the Web Workshop (LDOW2018)<address><addrLine>Lyon, France</addrLine></address></meeting>
		<imprint>
			<publisher>CEUR</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">2073</biblScope>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Integration of Web APIs and Linked Data Using SPARQL Micro-Services-Application to Biodiversity Use Cases</title>
		<author>
			<persName><forename type="first">Franck</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catherine</forename><surname>Zucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Gargominy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
		</author>
		<idno type="DOI">10.3390/info9120310</idno>
		<ptr target="https://doi.org/10.3390/info9120310" />
	</analytic>
	<monogr>
		<title level="j">Information</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">310</biblScope>
			<date type="published" when="2018-12">2018. Dec. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Building Microservices</title>
		<author>
			<persName><forename type="first">Sam</forename><surname>Newman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>O&apos;Reilly Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Big&quot; Web Services: Making the Right Architectural Decision</title>
		<author>
			<persName><forename type="first">Cesare</forename><surname>Pautasso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olaf</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Leymann</surname></persName>
		</author>
		<idno type="DOI">10.1145/1367497.1367606</idno>
		<ptr target="https://doi.org/10.1145/1367497.1367606" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International World Wide Web Conference (WWW2008)</title>
		<meeting>the 17th International World Wide Web Conference (WWW2008)<address><addrLine>Beijnig, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="805" to="814" />
		</imprint>
	</monogr>
	<note>RESTful Web Services vs</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Browsing Linked Data Catalogs with LODAtlas</title>
		<author>
			<persName><forename type="first">Emmanuel</forename><surname>Pietriga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hande</forename><surname>Gözükan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Caroline</forename><surname>Appert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie</forename><surname>Destandau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Šejla</forename><surname>Čebirić</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Semantic Web Conference (ISWC)</title>
		<meeting>the 17th International Semantic Web Conference (ISWC)<address><addrLine>Monterey, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">Mike</forename><surname>Ralphson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ivan</forename><surname>Goncharov</surname></persName>
		</author>
		<ptr target="https://webapi-discovery.github.io/rfcs/rfc0001.html" />
		<title level="m">WADG0001 WebAPI type extension</title>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Draft Community Group Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">SPARQL 1.1 Query Results JSON Format</title>
		<author>
			<persName><forename type="first">Andy</forename><surname>Seaborne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">W3C Recommen</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
	<note type="report_type">dation</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Linked REST APIs: A Middleware for Semantic REST API Integration</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Serrano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eleni</forename><surname>Stroulia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diana</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tinny</forename><surname>Ng</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICWS.2017.26</idno>
		<ptr target="https://doi.org/10.1109/ICWS.2017.26" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Web Services (ICWS)</title>
		<meeting>the IEEE International Conference on Web Services (ICWS)<address><addrLine>Honolulu, HI, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="138" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">JSON-LD 1.0. A JSON-based Serialization for Linked Data</title>
		<author>
			<persName><forename type="first">Manu</forename><surname>Sporny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dave</forename><surname>Longly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregg</forename><surname>Kellog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Lanthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niklas</forename><surname>Lindström</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2014/REC-json-ld-20140116/" />
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation</title>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">SPARQLES: Monitoring Public SPARQL Endpoints</title>
		<author>
			<persName><forename type="first">Pierre-Yves</forename><surname>Vandenbussche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jürgen</forename><surname>Umbrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Matteis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Buil-Aranda</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-170254</idno>
		<ptr target="https://doi.org/10.3233/SW-170254" />
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1049" to="1065" />
			<date type="published" when="2017-08">2017. Aug. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Description and Interaction of RESTful Services for Automatic Discovery and Execution</title>
		<author>
			<persName><forename type="first">Ruben</forename><surname>Verborgh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davy</forename><surname>Van Deursen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jos</forename><surname>De Roo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rik</forename><surname>Van De Walle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joaquim</forename><surname>Gabarro</surname></persName>
		</author>
		<author>
			<persName><surname>Vallés</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Advanced Future Multimedia Services</title>
		<meeting>the International Workshop on Advanced Future Multimedia Services<address><addrLine>Jeju, South Korea</addrLine></address></meeting>
		<imprint>
			<publisher>Future Technology Research Association International (FTRA)</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">SPARQL 1.1 Service Description</title>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Tood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Williams</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">W3C Recommendation</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">SpEnD: Linked Data SPARQL Endpoints Discovery Using Search Engines</title>
		<author>
			<persName><forename type="first">Semih</forename><surname>Yumusak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erdogan</forename><surname>Dogdu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Halife</forename><surname>Kodaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Kamilaris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre-Yves</forename><surname>Vandenbussche</surname></persName>
		</author>
		<idno type="DOI">10.1587/transinf.2016DAP0025</idno>
		<ptr target="https://doi.org/10.1587/transinf.2016DAP0025" />
	</analytic>
	<monogr>
		<title level="j">IEICE Transactions on Information and Systems E</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="758" to="767" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
