<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Schema-Based Automata Determinization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
							<email>joachim.niehren@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Momar</forename><surname>Sakho</surname></persName>
							<email>momar.sakho@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Al Serhali</surname></persName>
							<email>antonio.al-serhali@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Inria</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Université de Lille</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Inria</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Université de Lille</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Inria</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Université de Lille</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Schema-Based Automata Determinization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">FE0E57F15A42025DC6E2A16D4271AA1E</idno>
					<note type="submission">Submitted to: Gandalf 2022</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We propose an algorithm for schema-based determinization of finite automata on words and of stepwise hedge automata on nested words. The idea is to integrate schema-based cleaning directly into automata determinization. We prove the correctness of our new algorithm and show that it is always more efficient than standard determinization followed by schema-based cleaning. Our implementation permits to obtain a small deterministic automaton for an example of an XPath query, where standard determinization yields a huge stepwise hedge automaton for which schema-based cleaning runs out of memory.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Schemas and queries for nested words are definitions of languages of words, trees, unranked trees, and hedges. They can model and query structured text documents such as XML and JSON documents.</p><p>Regular queries and schemas can be defined by deterministic nested word automaton (NWA) <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b27">27]</ref>. An example for a regular schema is the XML data model and examples for regular queries are the forward navigational XPath queries on XML documents. Path queries can be seen as logical queries with a single free variable x. Such queries define languages of nested words containing exactly one occurrence of x. This property in turn, can be expressed by a schema one x over the alphabet extended by the query's variable x.</p><p>Stepwise hedge automata (SHAs) provide alternative definitions for regular schemas and queries on nested words <ref type="bibr" target="#b26">[26]</ref>. SHAs naturally subsume finite automata on words (NFAs) as well as stepwise tree automata for unranked trees <ref type="bibr" target="#b9">[10]</ref>. SHAs have the same expressive power as NWAs modulo P-time transformations. Furthermore, SHAs come with a notion of determinism that generalizes on the leftto-right determinism of NFAs and on the bottom-up determinism of tree automata. An algorithm for determinizing SHAs can be based on the usual subset construction in contrast to NWAs. This becomes possible since SHAs do not support any form of top-down determinism, which for NWAs can be ruled out by imposing the weak single-entry property.</p><p>There exist compilers from forward navigational XPath queries to NWAs <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b11">12]</ref> and to SHAs <ref type="bibr" target="#b26">[26]</ref>. The resulting automata can be determinized in, at most, exponential time. Deterministic automata are crucial for algorithmic tasks such as universality or inclusion checking. Both problems can be decided in P-time for the classes of deterministic SHAs or NWAs, but is DEXPTIME complete in the nondeterministic cases. For instance, universality checking is relevant for the earliest query answering of XPath queries on XML streams <ref type="bibr" target="#b16">[17]</ref>. It is also relevant for the efficient enumeration of the answer sets of regular queries <ref type="bibr" target="#b28">[28]</ref>. The need for deterministic automata in these applications motivates the question of how to determinize automata for nested words in practice.</p><p>Debarbieux et al. <ref type="bibr" target="#b11">[12]</ref> noticed that the usual determinization algorithm for NWAs often behaves badly when applied to NWAs obtained from XPath queries as simple as //a/b. As recalled in the survey of Okhotin and Salomaa <ref type="bibr" target="#b27">[27]</ref>, this determinization algorithm was first invented by von Braunmühl and Verbeek in the eighties in the journal version of <ref type="bibr" target="#b7">[8]</ref> and then rediscovered various times later on, for instance in <ref type="bibr" target="#b2">[3]</ref>. Niehren and Sakho <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b6">7]</ref> observed recently that the situation is different for the determinization of SHAs: It works out nicely for the SHA of //a/b and also for all other SHAs obtained by compilation from forward navigational XPath queries in the XPathMark benchmark <ref type="bibr" target="#b15">[16]</ref>. Even more surprisingly, the same good behaviour was observed for the determinization algorithm for NWA when restricted to NWAs with the weak-single entry property. This property failed for the NWAs considered by Derbarbieux, but can be established in quadratic time by compiling NWAs to SHAs forth and back.</p><p>We then observed, unfortunately, that the determinization algorithm for SHAs may still behave badly when applied to some forward navigational XPath queries, which arise in practice but not in the XPath-Mark benchmark <ref type="bibr" target="#b15">[16]</ref>. A typical killer example is the following XPath query:</p><formula xml:id="formula_0">(QN7) /a/b//(* | @* | comment() | text())</formula><p>It selects all nodes of an XML document that are descendants of a b-element below an a-element at the root. The nodes may have any XML type: element, attribute, comment, or text. The nondeterministic SHA has 145 states and an overall size of 348. Its determinization however leads to an automaton with 10.005 states and an overall size of 1.634.122. This size is way too big for many algorithms requiring deterministic automata. So one natural question is whether and how the size of deterministic automata can be reduced. One idea is to apply schema-based cleaning <ref type="bibr" target="#b26">[26]</ref> which keeps only those states and transition rules of the automaton, that are needed to recognize some nested word satisfying the schema. For automata for XPath queries, we can use a schema one x stating that a single node is selected by any solution, another schema defining the XML data model. When chosing the intersection of both of them as the schema, the schema-based cleaning of the deterministic SHA for QN7 indeed has only 74 states and 203 transitions. When applying SHA minimization <ref type="bibr" target="#b26">[26]</ref> afterwards, the size of the automaton goes down to 27 states and 71 transition rules.</p><p>So, the schema seems to play a crucial role. Our implementation of schema-based cleaning, however, runs out of memory for larger automata, say with more than 1000 states. Therefore, we cannot use it to reduce the sizes of the deterministic SHA obtained from QN7 as announced above. The same holds for our implementation of SHA minimization.</p><p>The question of how to produce small deterministic automaton for general queries that are as simple as QN7 remains thus open. Given that schemas are relevant, one approach could be to determinize the product of the automaton for the query with the schema. At a first glance, this may look questionable, given that the schema-product is usually bigger than the original automaton. So why could determinization become more efficient? But in the case of QN7, the determinization of the schema-product yields a deterministic automata with only 92 states and 325 transition rules, and can be computed efficiently. That looks promising. But we also notice that this is slightly bigger than what we announced for schema-based cleaning. The observations made at that example motivate three general questions.</p><p>1. Why are schemas so important for automata determinization? 2. Can this be shown by complexity result for the determinization of the schema-product? 3. Is there an efficient way to compute the schema-based cleaning of the determinization of an automaton? Clearly, schema-less determinization needs to be avoided.</p><p>Our main result is a novel algorithm for schema-based determinization of NFAs and SHAs, that integrates schema-based cleaning directly into the usual determinization algorithm, rather than applying it a posteriori. This algorithm answers question 3 positively. Its idea is to keep only those subsets of states of the automaton during the determinization, that can be aligned to some state of the schema. In our Theorem 2, we prove that schema-based determinization always produces the same deterministic automaton than schema-free determinization followed by schema-based cleaning. By schema-based determinization we obtained the schema-based cleaning of the determinization of QN7 in less than three seconds. In contrast, the schema-based cleaning of the determinization does not terminate after a few hours. In the general case, the worst case complexity of schema-based determinization is lower than of determinization followed by schema-based cleaning. We also provide a more precise complexity upper bound in <ref type="bibr">Proposition 12,</ref><ref type="bibr"></ref> showing that the maximal time for computing the schema-based determinization of a SHA is roughly the square of the number of its states. For NFAs it is the product of the number of states and the size of the alphabet. Schema-based determinization also helps to analyze the complexity of the determinization of the schema-product. Let A be a nondeterministic automaton and det(A) its determinization. Let schema S be a deterministic automata and A × S the schema-product. We first note that det(A × S) = det(A) × S since S is deterministic. <ref type="foot" target="#foot_0">1</ref> We second notice that det(A) × S may be way smaller than det(A). The reason is that for the many states Q = {q 1 . . . q n } of det(A) there may not exist any state s of S such that (Q, s) ∈ det(A) × S, because this requires all states q i can be aligned to s, i.e. that (q i , s) in A × S for all 1 ≤ i ≤ n. This is why the schema is so relevant for determinization, answering question 1. Third, it is not difficult to see that the schema-based determinization det S (A) is always smaller than det(A) × S. Furthermore, det(A) × S is equal to det S (A) × S, so that det(A × S) = det S (A) × S. Hence any size bound for the schema-based determinization det S (A) implies a size bound for the determinization of the schemaproduct. Furthermore, in our experiments det S (A) × S is only by a factor of 2 bigger than det S (A). So the size of the determinization of the schema-product is closely tied to the size of the schema-based determinization. This is the answer to question 2.</p><p>Outline. In Section 2, we recall the definition NFAs and discuss how to use them as schemas and queries on words. In Section 3, we recall schema-based cleaning for NFAs. In Section 4, we contribute our schema-based determinization algorithm in the case of NFAs and show its correctness. In Section 5, we recall the notion of SHAs for defining languages of nested words. In Section 6, we lift schema-based determinization to SHAs. Full proofs are given in the Appendix. It also contains a section on further related work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Finite Automata on Words, Schemas, and Queries</head><p>In this section, we discuss hwo to use NFAs for defining schemas and queries on words.</p><p>Let N be the set of natural numbers including 0. The set of words over a finite alphabet</p><formula xml:id="formula_1">Σ is Σ * = ∞ n∈N Σ n . A word (a 1 , . . . , a n ) ∈ Σ n is written as a 1 .</formula><p>. . a n . We denote by ε the empty word, i.e., the unique element of Σ 0 and by w 1 • w 2 ∈ Σ * the concatenation of two words w 1 , w 2 ∈ Σ * . For example, if Σ = {a, b} then aa</p><formula xml:id="formula_2">• bb = aabb = a • a • b • b. Definition 1. A NFA is a tuple A = (Σ, Q, ∆, I, F</formula><p>) such that Q is a finite set of states, the alphabet Σ is a finite set, I, F ⊆ Q are subsets of initial and final states, and</p><formula xml:id="formula_3">∆ ⊆ Q × Σ × Q is the set of transition rules.</formula><p>The size of a NFA is |A| = |Q| + |∆|. A transition rule (q, a, q ) ∈ ∆ is denoted by q a -→ q ∈ ∆. We define transitions q w -→ q wrt ∆ for arbitrary words w ∈ Σ * by the following inference rules:</p><formula xml:id="formula_4">q ∈ Q q ε - → q wrt ∆ q a - → q ∈ ∆ q a - → q wrt ∆ q 0 w 1 -→ q 1 wrt ∆ q 1 w 2 -→ q 2 wrt ∆ q 0 w 1 •w 2 ---→ q 2 wrt ∆</formula><p>The language of words recognized by a NFA then is L (A) = {w ∈ Σ * | q w -→ q wrt ∆, q ∈ I, q ∈ F}.</p><formula xml:id="formula_5">I A = / 0 I A ∈ I det(A) I A ∈ Q det(A) Q ∈ Q det(A) Q ∩ F A = / 0 Q ∈ F det(A) Q ∈ Q det(A) Q = {q ∈ Q A | q a - → q ∈ ∆ A , q ∈ Q} = / 0 Q a - → Q ∈ ∆ det(A) Q ∈ Q det(A) det(A) = (Σ, Q det(A) , ∆ det(A) , I det(A) , F det(A) )</formula><p>Figure <ref type="figure">1</ref>: The accessible determinization det(A) of NFA A. </p><formula xml:id="formula_6">A f o r q a - → q ∈ ∆ A such t h a t q ∈ Q do 10 i f h.get(a) = unde f then h.add(a, hashset.new( / 0)) 11 (h.get(a)).add(q ) 12 f o r (a, Q ) i n h.tolist() do Rules.add(Q a - → Q ) 13 i f not Store.member(Q ) then Store.add(Q ) Agenda.push(Q ) 14 l e t init det(A) = {Q | Q ∈ Store, Q ∩ init A = / 0} and F det(A) = {Q | Q ∈ Store, Q ∩ F A = / 0}</formula><p>15 r e t u r n (Σ, Store.toSet(), Rules.toSet(), init det(A) , F det(A) )</p><p>Figure <ref type="figure">2</ref>: A program computing the accessible determinization of an NFA A from Fig. <ref type="figure">1</ref>.</p><p>A NFA A is called deterministic or equivalently a DFA, if it has at most one initial state, and for every pair (q, a) ∈ Q × Σ there is at most one state q ∈ Q A such that q a -→ q ∈ ∆ A . Any NFA A can be converted into a DFA that recognizes the same language by the usual subset construction. The accessible determinization det(A) of A = (Σ, Q A , ∆ A , I A , F A ) is defined by the inference rules in Fig. <ref type="figure">1</ref>. It works like the usual subset construction, except that only accessible subsets are created. It is well known that L (A) = L (det(A)). Since only accessible subsets of states are added, we have Q det(A) ⊆ 2 Q A . Therefore, the accessible determinization may even reduce the size of the automaton and often avoid the exponential worst case where</p><formula xml:id="formula_7">Q det(A) = 2 Q A . Proposition 2. The accessible determinization det(A) of a NFA A can be computed in expected amortized time O(|Q det(A) | |∆ A | + |A|).</formula><p>Proof. An algorithm computing the fixed point of the inference rules for accessible determinization in Fig. <ref type="figure">1</ref> is presented in Fig. <ref type="figure">2</ref>. It uses dynamic perfect hashing <ref type="bibr" target="#b12">[13]</ref> for implementing hash sets, so that set inserting and membership can be done in randomized amortized time O <ref type="bibr" target="#b0">(1)</ref>. The algorithm has a hash set Store to save all discovered states Q det(A) and a hash set Rules to collect all transition rules. Furthermore, it has a stack Agenda to process all new states Q ∈ Q det(A) . For each Q popped from the stack Agenda, the algorithm uses a hash table h to compute all pairs (a,</p><formula xml:id="formula_8">Q ) such that Q a - → Q ∈ ∆ det(A)</formula><p>and Q = / 0. This is done by iterating of ∆ A so in time O(|∆ A |). By iterating over the hash table h, all transitions Q a -→ Q will be added to the set Rules and Q will be added to the stack Agenda and to the hash set Store if it wasn't there yet. The overall number of elements in the Agenda is |Q det(A) |. For each    As a running example, we consider the NFA A 0 for the regular expression (x + ε).(x.a) * that is drawn as a labeled digraph in Fig. <ref type="figure" target="#fig_0">3</ref>: the nodes of the graph are the states and the labeled edges represent the transitions rules. The initial states are indicated by an ingoing arrow and the final state are doubly circled. The graph of the DFA det(A 0 ) obtained by accessible determinization is shown in Fig. <ref type="figure" target="#fig_1">4</ref>. It is given up to a renaming of the states that is given in the caption. Note that only 4 out of the 2 3 = 8 subsets are accessible, so the size increases only by a single state and two transitions rules in this example.</p><p>A regular schema over Σ is a DFA with the alphabet Σ. We next show how to use automata to define regular queries on words. For this, any word is seen as a labeled digraph. The labeled digraph of the word aab, for instance, is drawn to the right. The set of nodes of the graph is the set of positions of the word pos(w) = {0, . . . , n} where n is the length of w. Position 0 is labeled by start, while all other positions are labeled by a single letter in Σ. A monadic query function on words with alphabet Σ is a total function Q that maps some words w ∈ Σ * to a subset of position Q(w) ⊆ pos(w). We say that a position π ∈ pos(w) is selected by</p><formula xml:id="formula_9">Q if w ∈ dom(Q) and π ∈ Q(w).</formula><p>Let us fix a single variable x. Given a position π of a word w ∈ Σ * let w * [π/x] be the word obtained from w by inserting x after position π. We note that all words of the form w * [π/x] contain a single occurrence of x. Such words are also called V -structures where V = {x} (see e.g <ref type="bibr" target="#b29">[29]</ref>).</p><p>The set of all V -structures can be defined by the schema words-one x Σ over Σ {x} in Fig. <ref type="figure" target="#fig_3">6</ref>. It is natural to identify any total monadic query function Q with the language of V -structures</p><formula xml:id="formula_10">L Q = {w * [π/x] | w ∈ Σ * , π ∈ Q(w)}.</formula><p>This view permits us to define a subclass of total monadic query functions by automata.</p><p>A (monadic) query automaton over Σ is a NFA A with alphabet Σ {x}. It defines the unique total monadic query function</p><formula xml:id="formula_11">Q such that L Q = L (A) ∩ L (words-one x Σ ).</formula><p>A position π of a word w ∈ Σ * is thus selected by the query Q on w if and only if the V -structure w * [π/x] is recognized by A, i.e.:</p><formula xml:id="formula_12">π ∈ Q(w) ⇔ w * [π/x] ∈ L (A)</formula><p>A query function is called regular if it can be defined by some NFA. It is well-known from the work of Büchi in the sixties <ref type="bibr" target="#b8">[9]</ref> that the same class of regular query functions can be defined equivalently by monadic second-order logic.</p><formula xml:id="formula_13">q ∈ I A s ∈ I S (q, s) ∈ I A×S (q, s) ∈ Q A×S q ∈ F A s ∈ F S (q, s) ∈ Q A×S (q, s) ∈ F A×S q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S (q 1 , s 1 ) ∈ Q A×S (q 1 , s 1 ) a - → (q 2 , s 2 ) ∈ ∆ A×S (q 2 , s 2 ) ∈ Q A×S Figure 7: Accessible product A × S = (Σ, Q A×S , I A×S , F A×S , ∆ A×S ).</formula><p>We note that only the words satisfying the schema words-one x Σ (the V -structures) are relevant for the query function Q of a query automaton A. The query automaton A 0 in Fig. <ref type="figure" target="#fig_0">3</ref> for instance, defines the query function that selects the start position of the words ε and a and no other positions elsewhere. This is since the subset of V -structures recognized by A 0 is x + x.a. Note that the words ε and xxa do also belong to L (A 0 ), but are not V -structures, and thus are irrelevant for the query function Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Schema-Based Cleaning</head><p>Schema-based cleaning was introduced only recently <ref type="bibr" target="#b26">[26]</ref> in order to reduce the size of automata on nested words. The idea is to remove all rules and states from an automaton that are not used to recognize any word satisfying the schema. Schema-based cleaning can be based on the accessible states of the product of the automaton with the schema. While this product may be larger than the automaton, the schema-based cleaning will always be smaller.</p><p>For illustration, the schema-based cleaning of NFA det(A 0 ) in Fig. <ref type="figure" target="#fig_1">4</ref> with respect to schema words-one x Σ is given in Fig. <ref type="figure" target="#fig_2">5</ref>. The only words recognized by both det(A 0 ) and words-one x Σ are x and xa. For recognizing these two words, the automaton det(A 0 ) does not need states 2 and 3, so they can be removed with all their transitions rules. Thereby, the word xxa violating the schema is no more recognized after schema-based cleaning, while it was recognized by det(A 0 ). Furthermore, note that the state 0 needs no more to be final after schema-based cleaning. Therefore the word ε, which is recognized by the automaton but not by the schema, is no more recognized after schema-based cleaning. So schema-based cleaning may change the language of the automaton but only outside of the schema.</p><p>Interestingly, the NFA A 0 in Fig. <ref type="figure" target="#fig_0">3</ref> is schema-clean for schema words-one x Σ too, even though it is not perfect, in that recognizes the words ε and xxa which are rejected by the schema. The reason is that for recognizing the words x and xa, which both satisfy the schema, all 3 states and all 4 transition rules of A 0 are needed. In contrast, we already noticed that the accessible determinization det(A 0 ) in Fig. <ref type="figure" target="#fig_1">4</ref> is not schema-clean for schema words-one x Σ . This illustrates that accessible determinization does not always preserve schema-cleanliness. In other words, schema-based cleaning may have a stronger cleaning effect after determinization than before.</p><p>The schema-based cleaning of an automaton can be defined based on the accessible product of the automaton with the schema. The accessible product A × S of two NFAs A and S with alphabet Σ is defined in Fig. <ref type="figure" target="#fig_8">7</ref>. This is the usual product, except that only accessible states are admitted. Clearly, L (A × S) = L (A) ∩ L (S). Let Π A (A × S) be obtained from the accessible product by projecting away the second component, as formally defined in Fig. <ref type="figure">19</ref>. The schema-based cleaning of A with respect to schema S is this projection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3. scl S (A) = Π A (A × S).</head><p>The fact that A × S is restricted to accessible states matches our intuition that all states of scl S (A) can be used to read some word in L (A) that satisfies schema S. This can be proven formally under the Figure <ref type="figure">8</ref>: A DFA that is schema-clean but not perfect for words-one x Σ .</p><p>Figure <ref type="figure">9</ref>:</p><p>The accessible product with words-one x Σ is schema-clean and perfect for words-one x Σ . Schema-clean deterministic automata may still not be perfect, in that schema-clean DFAs may recognize some words outside the schema. This happens if some state of a DFA is reached both, by a word satisfying the schema and another word that does not satisfy the schema. An example for a DFA that is schema-clean but not perfect for words-one x Σ is given in Fig. <ref type="figure">8</ref>. It is not perfect since it accepts the non V -structure xaxa. The problem is that state 1 can be reached by the words a and xa, so one cannot infer from being in state 1 whether some x was read or not. If one wants to avoid this, one can use the accessible product of the DFA with the schema instead. In the example, this yields the DFA in Fig. <ref type="figure">9</ref> that is schema-clean and perfect for words-one Proof. It is sufficient to show that the accessible product A × S can be computed in this time. An algorithm to compute the fixed points of the inference rules for the accessible product A × S in Fig. <ref type="figure" target="#fig_8">7</ref> can be organized such that only accessible states are considered (similarly to semi-naive datalog evaluation). This algorithm is presented in Fig. <ref type="figure">11</ref>. It dynamically generates the set of rules Rules by using perfect dynamic hashing <ref type="bibr" target="#b12">[13]</ref>. Testing set membership is in time O(1) and the addition of elements to the set is in expected amortized time O(1). The algorithm uses a stack, Agenda, to memoize all new pairs (q 1 , s 1 ) ∈ Q A×S that need to be processed, and a hash set Store that saves all processed states Q A×S . We aim not to push the same pair more than once in the Agenda. For this, membership to the Store is checked before an element is pushed to the Agenda. For each pair popped from the stack Agenda, the algorithm does the following: for each letter a ∈ Σ it computes the sets</p><formula xml:id="formula_14">Q = {q 2 | q 1 a - → q 2 ∈ ∆ A } and R = {s 2 | s 1 a - → s 2 ∈ ∆ S }</formula><p>and then adds the subset of states of Q × R that were not stored in the hash set Store to the agenda. Since A and S are deterministic, there is at most one such pair, so the time for treating one pair on the agenda is in expected amortized time O(|Σ|). The overall number of elements in the agenda will be |Q A×S |. Note that Q and R can be computed in O(1) after preprocessing A and S in time O(|A| + |S|). Therefore, we will have a total time of the algorithm in O(|Q A×S ||Σ| + |A| + |S|).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Schema-Based Determinization</head><p>Schema-based cleaning after determinization becomes impossible in practice if the automaton obtained by determinization is too big. We therefore show next how to integrate schema-based cleaning into automata determinization directly. i f init A = {q 0 } and init S = {s 0 } then Agenda.add((q 0 , s 0 ))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Schema-Based Determinization</head><p>w h i l e Agenda.notEmpty() do l e t (q 1 , s 1 ) = Agenda.pop()</p><formula xml:id="formula_15">f o r a ∈ Σ do l e t Q = {q 2 | q 1 a - → q 2 ∈ ∆ A } R = {s 2 | s 1 a - → s 2 ∈ ∆ S } f o r q 2 ∈ Q and s 2 ∈ R do<label>10</label></formula><p>Rules.add((q 1 , s 1 ) a -→ (q 2 , s 2 ))</p><formula xml:id="formula_16">11</formula><p>i f not Store.member((q 2 , s 2 ))</p><formula xml:id="formula_17">12</formula><p>then Store.add((q 2 , s 2 )) Agenda.push((q 2 , s 2 ))</p><p>13 l e t init A×S = {(q 0 , s 0 ) | (q 0 , s 0 ) ∈ Store} and</p><formula xml:id="formula_18">F A×S = {(q, s) | (q, s) ∈ Store, q ∈ F A , s ∈ F S }</formula><p>14 r e t u r n (Σ, Store.toSet(), Rules.toSet(), init A×S , F A×S )</p><p>Figure <ref type="figure">11</ref>: An algorithm computing the accessible product of DFAs A and S.</p><formula xml:id="formula_19">Q ∈ I det(A) I S = {s} Q ∈ I det S (A) Q ∼ s Q ∼ s Q ∈ Q det S (A) Q ∈ F det(A) s ∈ F S Q ∼ s Q ∈ F det S (A) Q a - → Q ∈ ∆ det(A) Q ∼ s s a - → s ∈ ∆ S Q a - → Q ∈ ∆ det S (A) Q ∼ s Figure 12: Schema-based determ. det S (A) = (Σ, Q det S (A) , ∆ det S (A) , I det S (A) , F det S (A) ).</formula><p>The schema-based determinization of A with respect to schema S extends on accessible determinization det(A). The idea is to run the schema S in parallel with det(A), in order to keep only those state Q ∈ Q det(A) that can be aligned to some state s ∈ Q S . In this case we write Q ∼ s.</p><p>The schema-determinization det S (A) is defined in Fig. <ref type="figure">12</ref>. The automaton det S (A) permits to go from any subset Q ∈ Q det(A) and letter a ∈ Σ to the set of states Q = a ∆ det(A) (Q), under the condition that there exists schema states s, s ∈ Q S such that Q ∼ s and s a -→ s . In this case Q ∼ s is inferred.</p><p>Theorem 1 (Correctness). det S (A) = scl S (det(A)) for any NFA A and DFA S with the same alphabet.</p><p>The theorem states that schema-based determinization yields the same result as accessible determinization followed by schema-based cleaning.</p><p>For preparing the correctness proof we first collapse the two systems of inference rules for accessible products and projection into a single rule system. This yields the rule systems for schema-based cleaning in Fig. <ref type="figure">20</ref>.</p><p>The rules there define the automaton scl S (A), that we annotate with a hat, in order to distinguish it from the previous automaton scl S (A). The rules also infer judgements (q, s) ∈ Q A ×S that we distinguish by a hat from the previous judgments (q, s) ∈ Q A×S of the accessible product. The next proposition shows that the system of collapsed inference rules indeed redefines the schema-based cleaning. </p><formula xml:id="formula_20">f o r a ∈ Σ do l e t P = {Q 2 | Q 1 a - → Q 2 ∈ ∆ det(A) } and R = {s 2 | s 1 a - → s 2 ∈ ∆ S } f o r Q 2 ∈ P and s 2 ∈ R do Rules.add(Q 1 a - → Q 2 ) 10 i f not Store.member(Q 2 ∼ s 2 ) 11 then Store.add(Q 2 ∼ s 2 ) Agenda.push(Q 2 ∼ s 2 ) 12 l e t init det S (A) = {Q | Q ∼ s ∈ Store, Q ∩ init A = / 0} and F det S (A) = {Q | Q ∼ s ∈ Store, Q ∩ F A = / 0}</formula><p>r e t u r n (Σ, Store.toSet(), Rules.toSet(), init det S (A) , F det S (A) )</p><p>Figure <ref type="figure" target="#fig_0">13</ref>: An algorithm for schema-based determinization det S (A) of an NFA A and a DFA schema S.</p><p>system for scl S (det(A)) with that for det S (A) in Fig. <ref type="figure">12</ref>, by identifying the judgements (Q, s) ∈ Q det(A) ×S with judgments Q ∼ s. After renaming the predicates, the inference rules for the corresponding judgments are the same. Hence scl S (det(A)) = det S (A), so that Proposition 6 implies scl S (det(A)) = det S (A). Proof. An algorithm computing the fixed points of the inference rules of schema-based determinization from Fig. <ref type="figure">12</ref> is given in Fig. <ref type="figure" target="#fig_0">13</ref>. It refines the algorithm computing the accessible product with on-the-fly determinization and projection. On the stack Agenda, the algorithm stores alignments Q ∼ s such that (Q, s) ∈ Q det(A)×S that were not considered before. Transition rules of det S (A) are collected in hash set Rules, using the dynamic perfect hashing aforementioned. The alignments Q 1 ∼ s 1 popped from the agenda are processed as follows: For any letter a ∈ Σ, the sets  ) the proposition shows that schema-based determinization is at most as efficient in the worst case as accessible determinization followed by schema-based cleaning. If |Q det(A)×S ||Σ| &lt; |Q det(A) ||∆ A | then it is more efficient, since schema-based determinization avoids the computation of det(A) all over. Instead, it only computes the accessible product det(A) × S, which may be considerably smaller, since exponentially many states of det(A) may not be aligned to any state of S. Sometimes, however, the accessible product may be bigger. In this case, schema-based determinization may be more costly than pure accessible determinization, not followed by schema-based cleaning.</p><formula xml:id="formula_21">R = {Q 2 | Q 1 a - → Q 2 ∈ ∆ det(A) } and P = {s 2 | s 1 a - → s 2 ∈ ∆ S }</formula><formula xml:id="formula_22">O(|Q det(A)×S ||Σ| + |Q det(A) | |∆ A |+|A|+|S|). Since Q det S (A) ⊆ Q det(A</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Stepwise Hedge Automata for Nested Words</head><p>We next recall SHAs <ref type="bibr" target="#b26">[26]</ref> for defining languages of nested words, regular schemas and queries. Nested words generalize on words by adding parenthesis that must be well-nested. While containing words natively, they also generalize on unranked trees, and hedges. We restrict ourselves to nested words with a single pair of opening and closing parenthesis and . Nested words over a finite alphabet Σ of internal letters have the following abstract syntax. A nested word of type tree has the form h . Note that dangling parentheses are ruled out and that labeled parentheses can be simulated by using internal letters. XML documents are labeled unranked trees, for instance: a name = "u f f " b isgaga d/ /b c/ /a . Labeled unranked trees satisfying the XML data model can be represented as nested words over an alphabet that contains the XML node-types (elem, attr,text, . . .), the XML names of the document (a, . . . , d, name), and the characters of the data values, say UTF8. For the above example, we get the nested word elem</p><formula xml:id="formula_23">• a • attr • name • u • f • f elem • b • text • i • s • g • a • g • a elem • d elem • c Definition 8. A SHA is a tuple A = (Σ, Q, ∆, I, F) where ∆ = (∆ , @ ∆ , ∆ ) such that (Σ, Q, ∆ , I, F) is a NFA, ∆ ⊆ Q is a</formula><p>set of tree initial states and @ ∆ ⊆ Q 3 a set of apply rules.</p><p>SHAs can be drawn as graphs while extending on the graphs of NFAs. A tree initial state q ∈ ∆ is drawn as a node -→ q with an incoming tree arrow. An applyrule (q 1 , q, q 2 ) ∈ @ ∆ is drawn as a blue edge q 1 q -→ q 2 that is labeled by a state q ∈ Q rather than a letter a ∈ Σ. It states that a nested word in state q 1 can be extended by a tree in state q and become a nested word in state q 2 .</p><p>For instance, the SHA one x Σ is drawn graphically in Fig. <ref type="figure" target="#fig_4">10</ref>. It accepts all nested words over Σ {x, ¬x} that contain exactly one occurrence of letter x. Compared to the NFA words-one x Σ {¬x} from Fig. <ref type="figure" target="#fig_3">6</ref>, the SHA one x Σ contains three additional apply rules (0, 0, 0), (0, 1, 1), (1, 0, 1) ∈ @ ∆ one x Σ for reading the states assigned to subtrees. The state 0 is chosen as the single tree initial state.</p><p>Transitions for NFAs on words can be lifted to transitions for SHAs of the form q w -→ q wrt ∆ where w ∈ N Σ and q, q ∈ Q. For this, we add the following inference rule to the previous inference rules for NFAs:</p><formula xml:id="formula_24">q ∈ ∆ q w -→ q wrt ∆ (q 1 , q, q 2 ) ∈ @ ∆ q 1 w --→ q 2 wrt ∆</formula><p>The rule says that a tree w can transit from a state q 1 to a state q 2 if there is an apply rule (q 1 , q, q 2 ) ∈ @ ∆ so that w can transit from some tree initial state q ∈ ∆ to q. Otherwise, the language L (A) of nested words accepted by a SHA A is defined as in the case of NFAs.</p><p>Definition 9. A SHA (Σ, Q, ∆, I, F) is deterministic or equivalently a dSHA, if it satisfies the following conditions:</p><p>• I and ∆ both contain at most one element,</p><p>• a ∆ is a partial function from Q to Q for all a ∈ Σ, and</p><formula xml:id="formula_25">∆ A = / 0 ∆ A ∈ Q det(A) Q 1 ∈ Q det(A) Q 2 ∈ Q det(A) Q = {q ∈ Q A | q 1 @q 2 → q ∈ ∆ A , q 1 ∈ Q 1 , q 2 ∈ Q 2 } = / 0 Q 1 @Q 2 → Q ∈ ∆ det(A) Q ∈ Q det(A)</formula><p>Figure <ref type="figure" target="#fig_1">14</ref>: Accessible determinization det(A) lifted from NFAs to SHAs.</p><p>Figure <ref type="figure" target="#fig_2">15</ref>: A one x Σ -cleaned minimal dSHA for the XPATH query QN7.</p><p>• @ ∆ is a partial function from Q × Q to Q. Note that if A is a dSHA and ∆ = (∆ , @ ∆ , ∆ ) then A = (Σ, Q, ∆ , I, F) is a DFA. Conversely any DFA A defines a dSHA with @ ∆ = / 0 and I = / 0. For instance, the SHA one x Σ in Fig. <ref type="figure" target="#fig_4">10</ref> contains the DFA words-one x Σ {¬x} from Fig. <ref type="figure" target="#fig_3">6</ref> with Σ instantiated by Σ {x}. A schema for nested words over Σ is a dSHA over Σ. Note that schemas for nested words generalize over schemas of words, since dSHAs generalize on DFAs. The rules for the accessible determinization det(A) of a SHA A in Fig. <ref type="figure" target="#fig_1">14</ref> extend on those for NFAs in Fig. <ref type="figure">1</ref>. As for words, det(A) is always determinstic, recognizes the same language as A, and contains only accessible states. The complexity of accessible determinization in case of SHA go similarly to DFA, however, the apply rules will introduce quadratic factor in the number of states. Proposition 10. The accessible determinization of a SHA can be computed in expected amortized time</p><formula xml:id="formula_26">O(|Q det(A) | 2 |∆ A | + |A|).</formula><p>The notions of monadic query functions Q can be lifted from words to nested words, so that it selects nodes of the graph of a nested word. For this, we have to fix one of manner possible manners to define identifiers for these nodes. The set of nodes of a nested word w is denoted by nod(w) ⊆ N.</p><p>For indicating the selection of node π ∈ nod(w), we insert the variable x into the sequence of letters following the opening parenthesis of π. If we don't want to select π, we insert the letter ¬x instead. For any nested word w with alphabet Σ, the nested word w[π/x] obtained by insertion of x or ¬x at a node π ∈ nod(w) has alphabet Σ {x, ¬x}. As before, we define</p><formula xml:id="formula_27">L Q = {w * [π/x] | w ∈ N Σ , π ∈ Q(w)}. q ∈ ∆ A s ∈ ∆ S (q, s) ∈ ∆ A×S (q, s) ∈ Q A×S (q 1 , s 1 ) ∈ Q A×S (q, s) ∈ Q A×S q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S</formula><p>(q 1 , s 1 )@(q, s) → (q 2 , s 2 ) ∈ ∆ A×S (q 2 , s 2 ) ∈ Q A×S  The notion of a query automata can now be lifted from words to nested words straightforwardly: a query automaton for nested words over Σ is a SHA A with alphabet Σ ∪ {x, ¬x}. It defines the unique total query Q such that L Q = L (A) ∩ L (one x Σ ). A deterministic query automaton for the XPATH QN7 on XML documents is given in Fig. <ref type="figure" target="#fig_2">15</ref>.</p><formula xml:id="formula_28">∆ S = {s} ∆ A ∈ ∆ det S (A) ∆ A ∼ s s 1 @s 2 → s ∈ ∆ S Q 1 ∼ s 1 Q 2 ∼ s 2 Q 1 @Q 2 → Q ∈ ∆ det(A) Q 1 @Q 2 → Q ∈ ∆ det S (A) Q ∼ s</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Schema-Based Determinization for SHAs</head><p>We can lift all previous algorithms from NFAs to SHAs while extending the system of inference rules. The additional rules concern tree initial states, that work in analogy to initial states, and also apply rules that works similarly as internal rules. The new inference rules for accessible products A × S are given in Fig. <ref type="figure" target="#fig_11">16</ref> and for projection Π A (A × S) in Fig. <ref type="figure" target="#fig_18">23</ref>. As before we define scl S (A) = Π A (A × S). The rules for schema-based determinization det S (A) are extended in Fig. <ref type="figure" target="#fig_12">17</ref> The proof extends on that for NFAs (Theorem 1) in a direct manner. Proposition 12. The schema-based determinization det S (A) of a SHA A with respect to a dSHA S can be computed in expected amortized time O(|Q</p><formula xml:id="formula_29">det(A)×S | 2 + |Q det(A)×S | |Σ| + |Q det S (A) | 2 |∆ A | + |A| + |S|).</formula><p>This proposition follows the result in Proposition 7 with an additional quadratic factor in the size of states of the product det(A) × S and the states of the schema-based determinized automaton. This is always due to the apply rules of type Q 3 .</p><p>By Propositions 10 and 11, computing scl S (det(A)) by schema-based cleaning after accessible determinization needs time in</p><formula xml:id="formula_30">O(|Q det(A)×S | 2 + |Q det(A)×S | |Σ| + |Q det(A) | 2 |∆ A | + |A| + |S|).</formula><p>This complexity bound is similar to that of schema-based determinization from Proposition 12. Since Q det S (A) ⊆ Q det(A) , Proposition 12 shows that the worst case time complexity of schema-based determinization is never worse than for schema-based cleaning after determinization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experiments</head><p>For studying the relevance of schemas in automata determinization experimentally we compare determinization, schema-based determinization and the determinization of the schema-product for a scalable collection of SHAs.  <ref type="figure">18</ref>: Automata statistics: size(#states)</p><p>In order to obtain scalable SHAs whose determinizations are too big to be schema-cleaned or minimized, we start from the following XPATH queries: where n ∈ {1, . . . , 3} and m ∈ {1, . . . , 4}. Query Qn.m selects all elements of an XML document, that are named by either of a0, . . ., an and have some descendant element named by either of b1, . . ., bm. We compile those XPATH queries to SHAs based on the compiler from <ref type="bibr" target="#b26">[26]</ref>. We note that these SHAs may also have typed else rules. As schema S we chose the product of one x with a dSHA for the XML data model (see Fig. <ref type="figure" target="#fig_24">28</ref> of the appendix).</p><p>All the experiments are conducted on a Dell laptop with the following specs: Intel® Core™ i7-10875H CPU @ 2.30 GHz,16 cores, and 32 GB of RAM. The statistics on the sizes and number of states of the various automata computed for these queries are presented in Table <ref type="table">18</ref>.</p><p>The SHA A in the first column is the automaton obtained from query Qn.m by the compiler from <ref type="bibr" target="#b26">[26]</ref>. The dSHA det(A) in the second column is obtained from A by accessible determinization. We notice that all SHAs Qn.m could be determinized within our timeout of 1000 seconds. The column scl S (det(A)) contains the schema-based cleaning of det(A) if it could be computed within the timeout of 1000 seconds. Otherwise the field is left blank, which is the case for 6 out of the 12 queries where the size of det(A) is too big.</p><p>In contrast, we can compute the determinization of the schema-product det(A × S) and the schemabased determinization det S (A) in all cases in less than 100 seconds. For instance, the highest computation time is for Q3.4 where det S (A Q3.4 ) took around 31 seconds, and det(A Q3.4 × S) needed 74 seconds. This shows that the schema is indeed essential for determinization of these automata. Furthermore, the automata obtained by schema-based determinization are always smaller than those obtained by determinizing the schema product.</p><p>We notice that the schema-based determinization det S (A) is always equal to schema-based cleaning of the accessible determinization scl S (det(A)), if both could be computed within the timeout. This confirms Theorem 2 on the correctness of schema-based determinization. Note that this theorem is not directly applicable since we are using a slightly enriched SHA model in our experiments.</p><p>Finally, we minimized all det(A × S) and det S (A). It turns out, that all mini(det(A × S)) have 41 states, while all mini(det S (A)) have 19 states (see Fig. <ref type="figure" target="#fig_25">29</ref> and Fig. <ref type="figure" target="#fig_26">30</ref> of the appendix for Q3.4). Only the number of transition rules grows with n and m. We notice that they are neither equal nor equivalent, since they recognize different languages outside schema S. But in any case, schema-based determinization produces smaller dSHAs even after minimization.</p><p>Conclusion and Future Work. We presented an algorithm for schema-based determinization for NFAs and SHAs and proved it to produce the same results as determinization followed by schema-based cleaning but with lower worst case complexity. This complexity result also gave us a bound on the size of the standard determinization of the query-schema product. We started with an example of an SHA for a regular XPATH query to lay out the risen problems, and for which schema-based determinization produces a dSHA of size &lt; 300, while schema-free determinization produces an dSHA of size &gt; 1.5 million and provided a scalable experiment denoting the performance of each approach and the size of their resulting automata. In a subsequent paper <ref type="bibr" target="#b0">[1]</ref>, we successfully applied our schema-based determinization algorithm on a practical benchmark of forward navigational XPATH queries <ref type="bibr" target="#b21">[22]</ref>, that Lick and Schmitz extracted from practical XSLT and XQuery programs. The results of our benchmark were highly promising and raises hope of providing the needed deterministic tools for many algorithms such as query answering and enumeration. An open line would be to improve the complexity and find an algorithm relying only on the transition set and therefore, possibly get rid of the quadratic factor in states and alphabet.</p><formula xml:id="formula_31">(q, s) ∈ I A×S q ∈ I Π A (A×S) (q, s) ∈ Q A×S q ∈ Q Π A (A×S) (q, s) ∈ F A×S q ∈ F Π A (A×S) (q 1 , s 1 ) a - → (q 2 , s 2 ) ∈ ∆ A×S q 1 a - → q 2 ∈ ∆ Π A (A×S) Figure 19: Projection Π A (A × S) = (Σ, Q Π A (A×S) , ∆ Π A (A×S) , I Π A (A×S) , F Π A (A×S) ).</formula><p>A Proofs for Section 1 (Introduction)</p><p>A.1 Further Related Work Nested regular path queries. <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b22">23]</ref> are formulas from propositional dynamic logic (PDL) <ref type="bibr" target="#b14">[15]</ref>. While applicable to general data graphs, they can also be restricted to nested words. They extend on usual regular expression by adding nested filters that are closed under the logical operators. Filters may test for the existence of nodes answering a nested regular path query. When XML documents, nested regular path queries can be identified with regular forward XPath queries <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b18">19]</ref>. t is folklore that nested regular path queries on data trees can be compiled to automata. MSO. For ranked trees, one can first compile path queries to the monadic second-order (MSO) formulas, and from there to tree automata that recognize so-called V-structures <ref type="bibr" target="#b31">[31,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b9">10]</ref>. V-structures are trees that are annotated with variables x satisfying words-one x Σ , saying where the any variable assignement has to assign a single node to variable x. In recent database terminology, languages of V-structures are called document spanners <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b28">28]</ref>. But since the compilation of path queries to MSO formulas eagerly introduces quantifier alternations, that are to be eliminated by repeated automata determinization, this approach leads to a large size blowup. Nested Regular Expressions. A more recent idea <ref type="bibr" target="#b6">[7]</ref> is to compile nested regular path queries to nested regular expressions in a first step, i.e., regular expressions for nested words that were introduced earlier under the name regular expression types by Hosoya and Pierce <ref type="bibr" target="#b19">[20]</ref>. Nested regular expressions support the usual operators of regular expressions and the nesting expressions e for defining languages of nested words. Furthermore, they support vertically recursive definitions based on µ-expressions µx.e, intersections e ∩ e , and complementation e. It is then possible to compile nested regular expressions to SHAs or NWAs, by lifting the usual automata constructions from standard regular to nested regular expressions. Forest Algebras. Nested words are very similar to forests, i.e., sequences of unranked trees. The transition relation of any SHA can be used to define a forest algebra <ref type="bibr" target="#b5">[6]</ref>. Hedge Automata. Stepwise hedge automata (SHAs) improve on classical hedge automata <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b10">11]</ref> in that they come with a satisfying notion of determinism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Proofs for Section 3 (Schema-Based Cleaning)</head><p>C Proofs for Section 4 (Schema-Based Determinization) Proposition 6. For any two NFAs A and S with the same alphabet:</p><formula xml:id="formula_32">scl S (A) = scl S (A) and Q A×S = Q A ×S</formula><p>Proof. The two equations are shown by the following four lemmas. The judgements with a hat there are to be inferred by the collapsed system of inference rules in Fig. <ref type="figure">20</ref>, while the other judgments are to be inferred with the rule system for accessible products in Fig. <ref type="figure" target="#fig_8">7</ref>.</p><formula xml:id="formula_33">q ∈ I A s ∈ I S q ∈ I scl S (A) (q, s) ∈ Q A ×S q ∈ F A s ∈ F S (q, s) ∈ Q A ×S q ∈ F scl S (A) (q, s) ∈ Q A ×S q ∈ Q scl S (A) q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S (q 1 , s 1 ) ∈ Q A ×S q 1 a - → q 2 ∈ ∆ scl S (A) (q 2 , s 2 ) ∈ Q A ×S scl S (A) = (Σ, Q scl S (A) , ∆ scl S (A) , I scl S (A) , F scl S (A) )</formula><p>Figure <ref type="figure">20</ref>: A collapsed rule systems for schema-based cleaning scl S (A).</p><p>Lemma 13. q ∈ I scl S (A) iff q ∈ I scl S (A) .</p><p>Proof. The rule systems of accessible product, projection, and the collapsed system can be used as following :</p><formula xml:id="formula_34">q ∈ I A s ∈ I S q ∈ I scl S (A) q ∈ I A s ∈ I S (q, s) ∈ I A×S q ∈ I scl S (A) Lemma 14. (q, s) ∈ Q A ×S iff (q, s) ∈ Q A×S .</formula><p>Proof. We proof for all n ≥ 0 that if (q, s) ∈ Q A ×S has a proof tree of size n then there exists a proof tree for (q, s) ∈ Q A×S . The proof is by induction on n.</p><p>In the case of the rules of the initial states, (q, s) ∈ Q A ×S is inferred directly whenever (q, s) ∈ Q A×S and vice versa, using the following:</p><formula xml:id="formula_35">q ∈ I A s ∈ I S (q, s) ∈ I A×S (q, s) ∈ Q A×S q ∈ I A s ∈ I S q ∈ I scl S (A) (q, s) ∈ Q A ×S</formula><p>If (q, s) ∈ Q A ×S is inferred by the internal rule of the collapsed rule system in Fig. <ref type="figure">20</ref>. Then the proof tree has the following form for some proof tree T 1 :</p><formula xml:id="formula_36">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A ×S (q 2 , s 2 ) ∈ Q A ×S</formula><p>This shows that there is a smaller proof tree T 1 for inferring (q 1 , s 1 ) ∈ Q A ×S . So by induction hypothesis applied to T 1 , there exists a proof tree T 1 for inferring (q 1 , s 1 ) ∈ Q A×S with the proof system of accessible products in Fig. <ref type="figure" target="#fig_8">7</ref>:</p><formula xml:id="formula_37">T 1 (q 1 , s 1 ) ∈ Q A×S</formula><p>Therefore, we also have the following proof tree for (q 2 , s 2 ) ∈ Q A×S with the internal rule for the accessible product:</p><formula xml:id="formula_38">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S (q 2 , s 2 ) ∈ Q A×S</formula><p>For the inverse direction, if (q, s) ∈ Q A×S is inferred by the internal rule of the accessible product rule system in Fig. <ref type="figure" target="#fig_8">7</ref>. Then the proof tree has the following form for some proof tree T 1 :</p><formula xml:id="formula_39">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S (q 2 , s 2 ) ∈ Q A×S</formula><p>This means that there is a smaller proof tree T 1 for inferring (q 1 , s 1 ) ∈ Q A×S . By induction hypothesis applied to T 1 , there exists a proof tree T 1 for inferring (q 1 , s 1 ) ∈ Q A ×S with the collapsed system in Fig. <ref type="figure">20</ref>:</p><formula xml:id="formula_40">T 1 (q 1 , s 1 ) ∈ Q A ×S</formula><p>which leads to the following proof tree for (q 2 , s 2 ) ∈ Q A×S with the internal rule for the collapsed system:</p><formula xml:id="formula_41">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A ×S (q 2 , s 2 ) ∈ Q A ×S Lemma 15. q 1 a - → q 2 ∈ ∆ scl S (A) iff q 1 a - → q 2 ∈ ∆ scl S (A) .</formula><p>Proof. We prove for all n ≥ 0 that, if q 1 a -→ q 2 ∈ ∆ scl S (A) has a proof tree of size n, then there exists a proof tree for q 1 a -→ q 2 ∈ ∆ scl S A and vice versa. The proof is by induction on n.</p><p>If q 1 a -→ q 2 ∈ ∆ scl S (A) is inferred by the internal rule of the collapsed system, the proof tree will have the following for some tree T 1 :</p><formula xml:id="formula_42">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A ×S q 1 a - → q 2 ∈ ∆ scl S (A)</formula><p>By Lemma 14 and the rule of internal rules of the accessible product rule system:</p><formula xml:id="formula_43">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S (q 1 , s 1 ) a - → (q 2 , s 2 ) ∈ ∆ A×S</formula><p>For the inverse direction, if q 1 a -→ q 2 ∈ ∆ scl S (A) is inferred by the internal rule of the accessible product, the proof tree will have the following for some tree T 1 :</p><formula xml:id="formula_44">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S (q 1 , s 1 ) a - → (q 2 , s 2 ) ∈ ∆ A×S q 1 a - → q 2 ∈ ∆ scl S (A) Q ∈ I det(A) s ∈ I S Q ∈ I scl S (det(A)) (Q, s) ∈ Q det(A) ×S Q ∈ F det(A) s ∈ F S (Q, s) ∈ Q det(A)×S Q ∈ F scl S (det(A)) (Q, s) ∈ Q det(A) ×S Q ∈ Q scl S (det(A)) Q 1 a - → Q 2 ∈ ∆ det(A) s 1 a - → s 2 ∈ ∆ S (Q 1 , s 1 ) ∈ Q det(A)×S Q 1 a - → Q 2 ∈ ∆ scl S (det(A)) (Q 2 , s 2 ) ∈ Q det(A) ×S</formula><p>scl S (det(A)) = (Σ, Q scl S (det(A)) , ∆ scl S (det(A)) , I scl S (det(A)) , F scl S (det(A)) ) By lemma 14 and the rule of internal rules of the collapsed system:</p><formula xml:id="formula_45">q 1 a - → q 2 ∈ ∆ A s 1 a - → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S q 1 a - → q 2 ∈ ∆ scl S (A)</formula><p>Lemma 16. q ∈ Q scl S (A) iff q ∈ Q scl S (A) and q ∈ F scl S (A) iff q ∈ F scl S (A) .</p><p>Proof. We start proving q ∈ Q scl S (A) iff q ∈ Q scl S (A) . By Lemma 14, and rules of construction of the accessible product, projection, and collapsed systems, this lemma holds for some proof trees T and T as follows:</p><formula xml:id="formula_46">T (q, s) ∈ Q A×S q ∈ Q scl S (A) T q ∈ Q scl S (A)</formula><p>Finally, we show q ∈ F scl S (A) iff q ∈ F scl S (A) . Using Lemma 14, there exists some proof trees T and T that infers (q, s) ∈ Q A×S and (q, s) ∈ Q A ×S in both ways and therefore having the following form of rules: Proof. An algorithm for computing the fixed points of the inference rules of accessible determinization of a SHA is presented in Fig. <ref type="figure">22</ref>. It extends on the case of NFAs with the same data structures. It uses dynamic perfect hashing for the hash sets. The additional treatment of apply rules, that dominates the complexity of the algorithm, works as follows: for each Q ∈ Q det(A) in the Agenda and each state Q1 ∈ Q det(A) in the Store, it computes the sets Q = {q | q@q 1 → q , q 1 ∈ Q 1 , q ∈ Q} and Q = {q | q 1 @q → f o r q a -→ q ∈ ∆ A such t h a t q ∈ Q do i f h.get(a) = unde f then h.add(a, hashset.new( / 0))</p><formula xml:id="formula_47">q ∈ F A s ∈ F S T (q, s) ∈ Q A ×S q ∈ F scl S (A) q ∈ F A s ∈ F S T (q, s) ∈ Q A×S (q, s) ∈ F A×S q ∈ F scl S (A)</formula><formula xml:id="formula_48">(h.get(a)).add(q ) f o r (a, Q ) i n h.tolist() do Rules.add(Q a - → Q ) i f not Store.member(Q ) then Store.add(Q ) Agenda.push(Q ) f o r Q 1 ∈ Store do l e t Q = {q | q@q 1 → q , q 1 ∈ Q 1 , q ∈ Q} i f Q = / 0 then Rules.add(Q@Q 1 → Q ) i f not Store.member(Q ) then Store.add(Q ) Agenda.push(Q ) l e t Q = {q | q 1 @q → q , q 1 ∈ Q 1 , q ∈ Q} i f Q = / 0 then Rules.add(Q 1 @Q → Q ) l e t init det(A) = {Q | Q ∈ Store, Q ∩ init A = / 0} and F det(A) = {Q | Q ∈ Store, Q ∩ F A = / 0}</formula><p>r e t u r n (Σ, Store.toSet(), Rules.toSet(), init det(A) , F det(A) )</p><p>Figure <ref type="figure">22</ref>: An algorithm for accessible determinization of SHAs. q , q 1 ∈ Q 1 , q ∈ Q} and puts all new non-empty sets in both the Agenda and the Store, while adding dynamically the generated apply rules in the hash set Rules. Again, the overall number of elements in the agenda will be |Q det The algorithm in Fig. <ref type="figure" target="#fig_1">24</ref> is obtained by lifting the algorithm for DFAs in Fig. <ref type="figure">11</ref> to SHAs. For the case of apply rules, we have to combine each pair (q 1 , s 1 ) ∈ Q A×S in the stack Agenda with all (q, s) ∈ Q A×S in the hash set Store, in both directions. The time to treat these pairs is O(|Q A×S | 2 ), so quadratic in the worst case. As before, no state (q 1 , s 1 ) will be processed twice, due to the set membership test before pushing a pair into the agenda. i f init A = {q 0 } and init S = {s 0 } then Agenda.add((q 0 , s 0 )) 5 w h i l e Agenda.notEmpty() do 6 l e t (q 1 , s 1 ) = Agenda.pop()</p><formula xml:id="formula_49">(q, s) ∈ ∆ A×S q ∈ ∆ Π A (A×S) (q 1 , s 1 )@(q, s) → (q 2 , s 2 ) ∈ ∆ A×S q 1 @q → q 2 ∈ ∆ Π A (A×S)</formula><formula xml:id="formula_50">7 f o r a ∈ Σ do 8 l e t Q = {q 2 | q 1 a - → q 2 ∈ ∆ A } and R = {s 2 | s 1 a - → s 2 ∈ ∆ S } 9 f o r q 2 ∈ Q and s 2 ∈ R do Rules.add((q 1 , s 1 ) a - → (q 2 , s 2 ))</formula><p>i f not Store.member((q 2 , s 2 ))</p><p>then Store.add((q 2 , s 2 )) Agenda.push((q 2 , s 2 ))</p><formula xml:id="formula_51">f o r (q, s) ∈ Store do l e t Q = {q 2 | q 1 @q → q 2 ∈ ∆ A } and R = {s 2 | s 1 @s → s 2 ∈ ∆ S } f o r q 2 ∈ Q and s 2 ∈ R do Rules.add((q 1 , s 1 ) (q,s) ---→ (q 2 , s 2 ))</formula><p>i f not Store.member((q 2 , s 2 ))</p><p>then Store.add((q 2 , s 2 )) Agenda.push((q 2 , s 2 ))</p><formula xml:id="formula_52">l e t Q = {q 2 | q@q 1 → q 2 ∈ ∆ A } and R = {s 2 | s@s 1 → s 2 ∈ ∆ S } f o r q 2 ∈ Q and s 2 ∈ R do Rules.add((q, s) (q 1 ,s 1 )</formula><p>----→ (q 2 , s 2 ))</p><p>i f not Store.member((q 2 , s 2 ))</p><p>then Store.add((q 2 , s 2 )) Agenda.push((q 2 , s 2 )) l e t init A×S = {(q 0 , s 0 ) | (q 0 , s 0 ) ∈ Store} and F A×S = {(q, s) | (q, s) ∈ Store, q ∈ F A , s ∈ F S } r e t u r n (Σ, Store.toSet(), Rules.toSet(), init A×S , F A×S )</p><p>Figure <ref type="figure" target="#fig_1">24</ref>: An algorithm computing the accessible product of dSHAs A and S.</p><p>on a stack Agenda and processed alignments in a hash set Store. It also collects transition rules in a hash set Rules. New alignments can now be produced by the the inference rule for apply transitions: for each alignment Q 1 ∼ s 1 on the Agenda and Q 2 ∼ s 2 in the Store, the algorithm computes the sets</p><formula xml:id="formula_53">{s | s 1 @s 2 → s ∈ ∆ S } and {Q | Q 1 @Q 2 → Q ∈ ∆ det(A)</formula><p>} and pushes all pairs Q ∼ s outside the Store to the Agenda. There may be at most one such pair since S and det(A) are deterministic. We also have to consider the symmetric case where Q 1 ∼ s 1 on the store and Q 2 ∼ s 2 on the Agenda. Thus, it is in time O(|Q det(A)×S | 2 ) which is quadratic in the worst case. Added to the latter, the cost of computing the transition of det(A) on the fly which is in worst case O(|Q det S (A) | 2 |∆ A | + |A|). Therefore, having the whole algorithm running, including the time for computing the internal rules, in</p><formula xml:id="formula_54">O(|Q det(A)×S | 2 + |Q det(A)×S | |Σ| + |Q det S (A) | 2 |∆ A | + |A| + |S|) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F Proof of Correctness Theorem 2</head><p>The proof extends on the proof of the case of words (Theorem 1) in a direct manner. We first lift the collapsed rule system for NFAs from Fig. <ref type="figure">20</ref> to SHAs inFig. 26, and then show that collapsed rules also redefine the schema-based cleaning scl S (A) = scl S (A) in the case of SHAs. Proposition 17. For any two SHAs A and S with the same alphabet:</p><formula xml:id="formula_55">Π A (A × S) = scl S (A) and Q A×S = Q A ×S</formula><p>Proof. The two equations are shown either by new lemmas or an extension of the lemmas from the proof of Theorem 1, whereas all unchanged existing lemmas hold(Lemmas 13, 15 and 16). then Store.add(Q 2 ∼ s 2 ) Agenda.push(Q 2 ∼ s 2 )</p><formula xml:id="formula_56">f o r (Q ∼ s) ∈ Store do l e t P = {Q 2 | Q 1 @Q → Q 2 ∈ ∆ det(A) } and R = {s 2 | s 1 @s → s 2 ∈ ∆ S } f o r Q 2 ∈ P and s 2 ∈ R do Rules.add(Q 1 @Q → Q 2 ) i f not Store.member(Q 2 ∼ s 2 )</formula><p>then Store.add(Q 2 ∼ s 2 ) Agenda.push(Q 2 ∼ s 2 )</p><formula xml:id="formula_57">l e t P = {Q 2 | Q@Q 1 → Q 2 ∈ ∆ det(A) } and R = {s 2 | s@s 1 → s 2 ∈ ∆ S } f o r Q 2 ∈ P and s 2 ∈ R do Rules.add(Q@Q 1 → Q 2 ) i f not Store.member(Q 2 ∼ s 2 )</formula><p>then Store.add(Q 2 ∼ s 2 ) Agenda.push(Q 2 ∼ s 2 )</p><formula xml:id="formula_58">l e t init det S (A) = {Q | Q ∼ s ∈ Store, Q ∩ init A = / 0} and F det S (A) = {Q | Q ∼ s ∈ Store, Q ∩ F A = / 0}</formula><p>r e t u r n (Σ, Store.toSet(), Rules.toSet(), init det S (A) , F det S (A) )</p><p>Figure <ref type="figure" target="#fig_2">25</ref>: An algorithm for schema-based determinization of an SHA A and a dSHA schema S q ∈ ∆ A s ∈ ∆ S q ∈ ∆ scl S (A) (q, s) ∈ Q A ×S q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S (q 1 , s 1 ) ∈ Q A ×S (q, s) ∈ Q A ×S q 1 @q → q 2 ∈ ∆ scl S (A) (q 2 , s 2 ) ∈ Q A ×S Lemma 18. q ∈ ∆ scl S (A) iff ∆ scl S (A)</p><p>Proof. The rule systems of accessible product, projection and the collapsed system can be used as following :</p><formula xml:id="formula_59">q ∈ ∆ A s ∈ ∆ S q ∈ ∆ scl S (A) q ∈ ∆ A s ∈ ∆ S (q, s) ∈ ∆ A×S q ∈ ∆ scl S (A)</formula><p>Lemma 19 (extends <ref type="bibr">Lemma 14)</ref>. (q, s) ∈ Q A ×S iff (q, s) ∈ Q A×S .</p><p>All proofs for initial states rules and internal rules from the previous lemma hold and we extend it for tree initial rules and apply rules:</p><p>Proof. Similarly, we prove for all n ≥ 0 that if (q, s) ∈ Q A ×S has a proof tree of size n then there exists a proof trees for (q, s) ∈ Q A×S . The proof is by induction on n.</p><p>In the case of tree initial rules, (q, s) ∈ Q A ×S is inferred directly whenever (q, s) ∈ Q A×S and vice versa, using the following: q ∈ ∆ A s ∈ ∆ S (q, s) ∈ ∆ A×S (q, s) ∈ Q A×S q ∈ ∆ A s ∈ ∆ S q ∈ scl S (A) (q, s) ∈ Q A ×S</p><p>In the same spirit, if (q, s) ∈ Q A ×S is inferred by the apply rule of the same system, then the proof tree has the following form for some proof trees T 1 and T :</p><formula xml:id="formula_60">q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A ×S T (q, s) ∈ Q A ×S (q 2 , s 2 ) ∈ Q A ×S</formula><p>This means that there are smaller proof trees T 1 and T for inferring respectively (q 1 , s 1 ) ∈ Q A ×S and (q, s) ∈ Q A ×S . Correspondingly, by induction hypothesis applied to T 1 and T , there exists T 1 , T for inferring (q 1 , s 1 ) ∈ Q A×S and (q, s) ∈ Q A×S : T 1 (q 1 , s 1 ) ∈ Q A×S T (q, s) ∈ Q A×S Thus allowing the following proof tree for (q 2 , s 2 ) ∈ Q A×S with the apply rule of the accessible product:</p><formula xml:id="formula_61">q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S T (q, s) ∈ Q A×S (q 2 , s 2 ) ∈ Q A×S</formula><p>For the inverse direction of the apply rules, and using the induction hypothesis, we will be able to infer (q 2 , s 2 ) ∈ Q A ×S with some T 1 and T and ending with the following proof tree: q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A ×S T (q, s) ∈ Q A ×S (q 2 , s 2 ) ∈ Q A ×S Lemma 20. q 1 @q → q 2 ∈ ∆ scl S (A) iff q 1 @q → q 2 ∈ ∆ scl S (A) .</p><p>Proof. Following the same logic in Lemma 15, this lemma holds by the following sequence of rules, for some proof trees T 1 , T , T 1 and T : q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A ×S T (q, s) ∈ Q A ×S q 1 @q → q 2 ∈ ∆ scl S (A) q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S T (q, s) ∈ Q A×S (q 1 , s 1 )@(q, s) → (q 2 , s 2 ) , ∆ scl S (det(A)) , I scl S (det(A)) , F scl S (det(A)) ).</p><formula xml:id="formula_62">∈ ∆ A×S Q ∈ ∆ det(A) s ∈ ∆ S Q ∈ ∆ scl S (det(A)) (Q, s) ∈ Q det(A) ×S Q 1 @Q → Q 2 ∈ ∆ det(A) s 1 @s → s 2 ∈ ∆ S (Q 1 , s 1 ) ∈ Q det(A) ×S (Q, s) ∈ Q det(A) ×S Q 1 @Q → Q 2 ∈ ∆ scl S (det(A)) (Q 2 , s 2 ) ∈ Q det(A) ×S</formula><p>(q 1 , s 1 )@(q, s) → (q 2 , s 2 ) ∈ ∆ A×S q 1 @q → q 2 ∈ ∆ scl S (A)</p><p>For the inverse direction, the sequence of rules, for some proof trees T 1 , T , T 1 and T will be: q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A×S T (q, s) ∈ Q A×S (q 1 , s 1 )@(q, s) → (q 2 , s 2 ) ∈ ∆ A×S q 1 @q → q 2 ∈ ∆ scl S (A) q 1 @q → q 2 ∈ ∆ A s 1 @s → s 2 ∈ ∆ S T 1 (q 1 , s 1 ) ∈ Q A ×S T (q, s) ∈ Q A ×S q 1 @q → q 2 ∈ ∆ scl S (A) Proof of Correctness of Theorem 2. For the proof of theorem for nested words with SHA, we extend the instantiation of the rule system for schema-based cleaning from Fig. <ref type="figure" target="#fig_22">26</ref> with det(A), yielding the rule system in Fig. <ref type="figure" target="#fig_23">27</ref>. The whole instantiation holds with the previous instantiation for words and we can still identify the rule system for scl S (det(A)) with the rule system det S (A). With the same identification of judgements and predicate renaming, the two systems are still exactly the same. Having scl S (det(A)) = det S (A) implies, by Proposition 17 scl S (det(A)) = det S (A).</p><p>G Proofs for Section 7 (Experiments)   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The NFA A 0 for the regular expression (x + ε).(x.a) *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4:The accessible determinization det(A 0 ) up to the renaming of states [{2, 4}/0,{2, 3}/1,{2}/2, {3}/3].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The schema-based cleaning of det(A 0 ) with schema words-one x Σ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Schema words-one x Σ with alphabet Σ {x}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: The dSHA one x Σ</figDesc><graphic coords="8,392.50,72.61,105.60,85.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>x Σ . Proposition 5. For any DFAs A and S with alphabet Σ the accessible product A×S and the schema-based cleaning scl S (A) can be computed in expected amortized time O(|Q A×S ||Σ| + |A| + |S|).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>fun A × S = l e t Store = hashset.new( / 0) l e t Agenda = list.new() and Rules = hashset.new( / 0)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Proposition 6 .</head><label>6</label><figDesc>For any two NFAs A and S with the same alphabet: scl S (A) = scl S (A) and Q A×S = Q A ×S Proof of Correctness Theorem 1. Instantiating the system of collapsed rules for schema-based cleaning from Fig. 20 with det(A) for A yields the rule system in Fig. 21. We can identify the instantiated collapsed fun d e t S ( A , S ) = l e t Store = hashset.new( / 0) l e t Agenda = list.new() and Rules = hashset.new( / 0) i f init A = / 0 and init S = {s 0 } then Agenda.add(init A ∼ s 0 ) w h i l e Agenda.notEmpty() do l e t (Q 1 ∼ s 1 ) = Agenda.pop()</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Proposition 7 .</head><label>7</label><figDesc>The schema-based determinization det S (A) for a NFA A and a DFA S over Σ can be computed in expected amortized time O(|Q det(A)×S ||Σ| + |Q det S (A) ||∆ A | + |A| + |S|).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>are computed. One then pushes all new pairs Q 2 ∼ s 2 with Q 2 ∈ P and s 2 ∈ R into the agenda, and adds Q 1 a -→ Q 2 to the set Rules. Since S and det(A) are deterministic there is at most one pair (Q, s) ∈ P × R for Q 1 and s 1 . So the time for treating one pair on the agenda is in O(|Σ|) plus the time for building the needed transition rules of det(A) from ∆ A on the fly. The time for the on the fly computation of transition rules of det(A) is in time O(|Q det S (A) ||∆ A |). The overall number of pairs on the agenda is at most |Q det(A)×S | so the main while loop of the algorithm requires time in O(|Q det(A)×S ||Σ|) apart from on the fly determinization. This will give us an overall complexity for the algorithm in O(|Q det(A)×S ||Σ| + |Q det S (A) ||∆ A | + |A| + |S|), with consideration of the preprocessing time of A and S. By Proposition 2, computing det(A) requires time O(|Q det(A) | |∆ A | + |A|). Therefore, with Proposition 5, the accessible product det(A) × S can be computed from A and S in time</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>w, w ∈ N Σ ::= ε | a | w | w • w where a ∈ Σ We assume that concatenation • is associative and that the empty word ε is a neutral element, that is w • (w • w ) = (w • w ) • w and ε • w = w = w • ε. Nested words can be identified with hedges, i.e., words of unranked trees and letters from Σ. Seen as a graph, the inner nodes are labeled by the tree constructor and the leafs by symbols in Σ or the tree constructor. For instance a • b • ε • c • d • ε corresponds to the hedge on the right.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Lifting accessible products to SHAs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 17 :</head><label>17</label><figDesc>Figure 17: Extension of schema-based determinization to SHAs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>. The next complexity upper bound, however, now become quadratic with fixed alphabet: Proposition 11. If A and S are dSHAs then the accessible product A × S and the schema-based cleaning scl S (A) can be computed in expected amortized time O(|Q A×S | 2 + |Q A×S ||Σ| + |A| + |S|). Theorem 2 (Correctness). det S (A) = scl S (det(A)). for any SHA A and dSHA S with the same alphabet.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>(</head><label></label><figDesc>Qn.m) //*[self::a0 or ... or self::an] [descendant::*[self::b0 or ... or self::bm]]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 21 :</head><label>21</label><figDesc>Figure 21: Instantiation of the collapsed rule system for schema-based cleaning from Fig. 20 with det(A).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>D</head><label></label><figDesc>Proofs for Section 5 (Stepwise Hedge Automata for Nested Words) Proposition 10. The accessible determinization of a SHA can be computed in expected amortized time O(|Q det(A) | 2 |∆ A | + |A|).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>7 l e t h be an empty h a s h t a b l e w i t h k e y s from Σ . 8 /</head><label>78</label><figDesc>Store = hashset.new( / 0) i f init A = / 0 then Agenda.add(init A ) 5 w h i l e Agenda.notEmpty() do 6 l e t (Q) = Agenda.pop() / t h e v a l u e s w i l l be n o n e m p t y h a s h s u b s e t s o f Q A 9</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 23 :</head><label>23</label><figDesc>Figure 23: Lifting projections Π A (A × S) to SHAs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>(A) |, requiring time in O(|Q det(A) | 2 |∆ A |). With a precomputation time of A in O(|A|), the total computation will be in O(|Q det(A) | 2 |∆ A | + |A|). E Proofs for Section 6 (Schema-Based Determinization for SHAs) Proposition 11. If A and S are dSHAs then the accessible product A × S and the schema-based cleaning scl S (A) can be computed in expected amortized time O(|Q A×S | 2 + |Q A×S ||Σ| + |A| + |S|).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Proposition 12 . 3 l</head><label>123</label><figDesc>The schema-based determinization det S (A) of a SHA A with respect to a dSHA S can be computed in expected amortized time O(|Qdet(A)×S | 2 + |Q det(A)×S | |Σ| + |Q det S (A) | 2 |∆ A | + |A| + |S|).Proof. Analogously to the case of NFAs on words. The algorithm in Fig.25computes the fixed point of the inference rules of schema-based determinization of SHAs. As for NFAs, it stores untreated alignments 1 fun A × S = 2 l e t Store = hashset.new( / 0) e t Agenda = list.new() and Rules = hashset.new( / 0) 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>1 7 f o r a ∈ Σ do 8 l e t P = {Q 2 | Q 1 a- → Q 2 ∈- → s 2 ∈ ∆ S } 9 f o r Q 2 ∈- → Q 2 )</head><label>78122922</label><figDesc>fun d e t S ( A , S ) = 2 l e t Store = hashset.new( / 0) i f init A = / 0 and init S = {s 0 } then Agenda.add(init A ∼ s 0 ) 5 w h i l e Agenda.notEmpty() do 6 l e t (Q 1 ∼ s 1 ) = Agenda.pop() ∆ det(A) } and R = {s 2 | s 1 a P and s 2 ∈ R do Rules.add(Q 1 a i f not Store.member(Q 2 ∼ s 2 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 26 :</head><label>26</label><figDesc>Figure 26: Lifting the collapsed rule system from NFAs to SHAs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Figure 27 :</head><label>27</label><figDesc>Figure27: Extending the instantiation of the alt. definition of schema-based cleaning: scl S (det(A)) = (Σ, Q scl S (det(A)) , ∆ scl S (det(A)) , I scl S (det(A)) , F scl S (det(A)) ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 28 :</head><label>28</label><figDesc>Figure 28: A schema for the intersection of XML data model with one x .</figDesc><graphic coords="27,137.63,112.06,336.75,223.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>Figure 29 :</head><label>29</label><figDesc>Figure 29: The automaton mini(det S (A)) of the query Q3.4.</figDesc><graphic coords="27,114.90,463.34,382.20,170.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Figure 30 :</head><label>30</label><figDesc>Figure 30: The automaton mini(det(A × S)) of the query Q3.4.</figDesc><graphic coords="28,79.23,114.00,505.50,518.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="12,143.63,150.23,324.75,251.75" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>If {(q 1 , s 1 ) . . . (q n , s n )} ∈ det(A × S) then there exists a tree that can go into all states q 1 . . . q n with A and into all states s 1 , . . . s n with S. Since S is deterministic, we have s 1 = . . . s n . So there exists a tree going into {q 1 , . . . , q n } with det(A) and also into all s i . So ({q 1 , . . . , q n }, s i ) is a state of det(A) × S.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Benchmark Collection of Deterministic Automata for XPath Queries</title>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Al</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Serhali</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-03527888.Technicalreport" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Marrying Words and Trees</title>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<idno type="DOI">10.1145/1265530.1265564</idno>
		<ptr target="http://dx.doi.org/10.1145/1265530.1265564" />
	</analytic>
	<monogr>
		<title level="m">26th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<imprint>
			<publisher>ACM-Press</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="233" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visibly pushdown languages</title>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">&amp;</forename><forename type="middle">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<ptr target="http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl=GUIDE&amp;id=1007390" />
	</analytic>
	<monogr>
		<title level="m">36th ACM Symposium on Theory of Computing</title>
		<imprint>
			<publisher>ACM-Press</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="202" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Adding nesting structure to words</title>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">&amp;</forename><forename type="middle">P</forename><surname>Madhusudan</surname></persName>
		</author>
		<idno type="DOI">10.1145/1516512.1516518</idno>
		<ptr target="http://doi.acm.org/10.1145/1516512.1516518" />
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="43" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Querying semantic web data with SPARQL</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the thirtieth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</title>
		<meeting>the thirtieth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="305" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Forest algebras</title>
		<author>
			<persName><forename type="first">Mikolaj</forename><surname>Bojanczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Walukiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Automata: History and Perspectives</title>
		<title level="s">Texts in Logic and Games</title>
		<editor>
			<persName><forename type="first">Jörg</forename><surname>Flum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Erich</forename><surname>Grädel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Wilke</surname></persName>
		</editor>
		<imprint>
			<publisher>Amsterdam University Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="107" to="132" />
		</imprint>
	</monogr>
	<note>in Honor of Wolfgang Thomas</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Nested Regular Expressions Can Be Compiled to Small Deterministic Nested Word Automata</title>
		<author>
			<persName><forename type="first">Iovka</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Momar</forename><surname>Sakho</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-50026-9_12</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-50026-9_12" />
	</analytic>
	<monogr>
		<title level="m">Computer Science -Theory and Applications -15th International Computer Science Symposium in Russia, CSR 2020</title>
		<title level="s">Proceedings, Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Henning</forename><surname>Fernau</surname></persName>
		</editor>
		<meeting><address><addrLine>Yekaterinburg, Russia</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020-06-29">2020. June 29 -July 3, 2020</date>
			<biblScope unit="volume">12159</biblScope>
			<biblScope unit="page" from="169" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Input Driven Languages are Recognized in log n Space</title>
		<author>
			<persName><forename type="first">Rutger</forename><surname>Burchard Von Braunmühl</surname></persName>
		</author>
		<author>
			<persName><surname>Verbeek</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0304-0208(08)73072-X</idno>
		<ptr target="http://www.sciencedirect.com/science/article/pii/S030402080873072X" />
	</analytic>
	<monogr>
		<title level="m">Topics in the Theory of Computation</title>
		<title level="s">North-Holland Mathematics Studies</title>
		<editor>
			<persName><forename type="first">Marek</forename><surname>Karplnski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">&amp;</forename><surname>Jan Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="1" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On a Decision Method in a Restricted Second Order Arithmetic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Büchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Internat. Congr. on Logic, Methodology and Philosophy of Science</title>
		<meeting>Internat. Congr. on Logic, Methodology and Philosophy of Science</meeting>
		<imprint>
			<publisher>Press</publisher>
			<date type="published" when="1960">1960</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Querying Unranked Trees with Stepwise Tree Automata</title>
		<author>
			<persName><forename type="first">Julien</forename><surname>Carme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://www.ps.uni-sb.de/Papers/abstracts/stepwise.html" />
	</analytic>
	<monogr>
		<title level="m">19th International Conference on Rewriting Techniques and Applications</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3091</biblScope>
			<biblScope unit="page" from="105" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Tree Automata Techniques and Applications</title>
		<author>
			<persName><forename type="first">Max</forename><surname>Hubert Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rémi</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christof</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florent</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://tata.gforge.inria.fr" />
		<imprint>
			<date type="published" when="1997">2007. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Early nested word automata for XPath query answering on XML streams</title>
		<author>
			<persName><forename type="first">Denis</forename><surname>Debarbieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohamed</forename><surname>Zergaoui</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2015.01.017</idno>
		<ptr target="http://dx.doi.org/10.1016/j.tcs.2015.01.017" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">578</biblScope>
			<biblScope unit="page" from="100" to="125" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Dynamic Perfect Hashing: Upper and Lower Bounds</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Dietzfelbinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><forename type="middle">R</forename><surname>Karlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Mehlhorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Friedhelm</forename><surname>Meyer Auf Der Heide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hans</forename><surname>Rohnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">&amp;</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Endre</forename><surname>Tarjan</surname></persName>
		</author>
		<idno type="DOI">10.1137/S0097539791194094</idno>
		<ptr target="https://doi.org/10.1137/S0097539791194094" />
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="738" to="761" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Document Spanners: A Formal Approach to Information Extraction</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frederick</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
		<idno type="DOI">10.1145/2699442</idno>
		<ptr target="https://doi.org/10.1145/2699442" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Propositional Dynamic Logic of Regular Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">E</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><surname>Ladner</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(79)90046-1</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(79)90046-1" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="194" to="211" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">Massimo</forename><surname>Franceschet</surname></persName>
		</author>
		<ptr target="https://users.dimi.uniud.it/~massimo.franceschet/xpathmark/PTbench.html" />
		<title level="m">XPathMark Performance Test</title>
		<imprint>
			<date type="published" when="2020-10-25">2020-10-25</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Earliest Query Answering for Deterministic Nested Word Automata</title>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Tison</surname></persName>
		</author>
		<ptr target="http://hal.inria.fr/inria-00390236/en" />
	</analytic>
	<monogr>
		<title level="m">17th International Symposium on Fundamentals of Computer Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5699</biblScope>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Monadic Queries over Tree-Structured Data</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th Annual IEEE Symposium on Logic in Computer Science</title>
		<meeting><address><addrLine>Copenhagen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="189" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The complexity of XPath query evaluation</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="179" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">XDuce: A statically typed XML processing language</title>
		<author>
			<persName><forename type="first">Haruo</forename><surname>Hosoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">&amp;</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pierce</surname></persName>
		</author>
		<idno type="DOI">10.1145/767193.767195</idno>
		<ptr target="https://doi.org/10.1145/767193.767195" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Internet Techn</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="117" to="148" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Querying Graph Databases with XPath</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><surname>Domagoj</surname></persName>
		</author>
		<idno type="DOI">10.1145/2448496.2448513</idno>
		<ptr target="https://doi.org/10.1145/2448496.2448513" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Database Theory, ICDT &apos;13</title>
		<meeting>the 16th International Conference on Database Theory, ICDT &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2013">Vrgoč. 2013</date>
			<biblScope unit="page" from="129" to="140" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Lick</surname></persName>
		</author>
		<ptr target="https://tel.archives-ouvertes.fr/tel-02276423" />
		<title level="m">Logique de requêtes à la XPath : systèmes de preuve et pertinence pratique</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
		<respStmt>
			<orgName>Université Paris-Saclay</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Theses</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Evaluation and Enumeration Problems for Regular Path Queries</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tina</forename><surname>Trautner</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2018.19</idno>
	</analytic>
	<monogr>
		<title level="m">21st International Conference on Database Theory (ICDT 2018), Leibniz International Proceedings in Informatics (LIPIcs) 98</title>
		<editor>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yael</forename><surname>Amsterdamer</surname></persName>
		</editor>
		<meeting><address><addrLine>Dagstuhl, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1" to="19" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title/>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2018.19</idno>
		<ptr target="http://drops.dagstuhl.de/opus/volltexte/2018/8594" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Pebbling Moutain Ranges and its Application of DCFL-Recognition</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Mehlhorn</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-10003-2_89</idno>
		<ptr target="https://doi.org/10.1007/3-540-10003-2_89" />
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming, 7th Colloquium</title>
		<title level="s">Proceedings, Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>De Bakker</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Van Leeuwen</surname></persName>
		</editor>
		<meeting><address><addrLine>Noordweijkerhout, The Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1980-07-14">1980. July 14-18, 1980</date>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="422" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">High-performance complex event processing over XML streams</title>
		<author>
			<persName><forename type="first">Barzan</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
		<idno type="DOI">10.1145/2213836.2213866</idno>
		<ptr target="http://dx.doi.org/10.1145/2213836.2213866" />
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<editor>
			<persName><forename type="first">K</forename><surname>Selc ¸uk Candan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yi</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Luis</forename><surname>Gravano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ariel</forename><surname>Fuxman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Selc ¸uk Candan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yi</forename><surname>Chen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Snodgrass</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Luis</forename><surname>Gravano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ariel</forename><surname>Fuxman</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="253" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Determinization and Minimization of Automata for Nested Words Revisited</title>
		<author>
			<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Momar</forename><surname>Sakho</surname></persName>
		</author>
		<idno type="DOI">10.3390/a14030068</idno>
		<ptr target="https://hal.inria.fr/hal-03134596" />
	</analytic>
	<monogr>
		<title level="j">Algorithms</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Complexity of input-driven pushdown automata</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Okhotin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kai</forename><surname>Salomaa</surname></persName>
		</author>
		<idno type="DOI">10.1145/2636805.2636821</idno>
		<ptr target="https://doi.org/10.1145/2636805.2636821" />
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="47" to="67" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A Purely Regular Approach to Non-Regular Core Spanners</title>
		<author>
			<persName><forename type="first">Markus</forename><forename type="middle">L</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicole</forename><surname>Schweikardt</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2021.4</idno>
		<ptr target="https://drops.dagstuhl.de/opus/volltexte/2021/13712" />
	</analytic>
	<monogr>
		<title level="m">24th International Conference on Database Theory (ICDT 2021), Leibniz International Proceedings in Informatics (LIPIcs)</title>
		<editor>
			<persName><forename type="first">Ke</forename><surname>Yi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">&amp; Zhewei</forename><surname>Wei</surname></persName>
		</editor>
		<meeting><address><addrLine>Dagstuhl, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">186</biblScope>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Finite Automata, Formal Logic, and Circuit Complexity</title>
		<author>
			<persName><forename type="first">H</forename><surname>Straubing</surname></persName>
		</author>
		<ptr target="https://books.google.fr/books?id=jLbH4LJbuDsC" />
	</analytic>
	<monogr>
		<title level="s">Progress in Computer Science and Applied Series</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>Birkhäuser</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Characterizing derivation trees of context-free grammars through a generalization of automata theory</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Science</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="317" to="322" />
			<date type="published" when="1967">1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Generalized finite automata with an application to a decision problem of second-order logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical System Theory</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="57" to="82" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m">l e t Agenda = list.new() and Rules = hashset.new( / 0) l e t Agenda = list.new() and</title>
		<imprint/>
	</monogr>
	<note>Rules = hashset.new( / 0</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
