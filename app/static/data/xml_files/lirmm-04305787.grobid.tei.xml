<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
				<funder ref="#_sRAwrY3">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Rodriguez</surname></persName>
							<email>olivier.rodriguez@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
							<email>federico.ulliana@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<email>marie-laure.mugnier@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ. Montpellier</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ. Montpellier</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ. Montpellier</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">4DFA7CF82D7A8136C4704D47FD4FA394</idno>
					<idno type="DOI">10.14778/3611479.3611481</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Data trees, typically encoded in JSON, are ubiquitous in data-driven applications. This ubiquity makes urgent the development of novel techniques for querying heterogeneous JSON data in a flexible manner. We propose a rule language for JSON, called constrained tree-rules, whose purpose is to provide a high-level unified view of heterogeneous JSON data and infer implicit information. As reasoning with constrained tree-rules is undecidable, we identify a relevant subset featuring tractable query answering, for which we design an automata-based query rewriting algorithm. Our approach consists of leveraging NoSQL document stores by means of a novel instance-aware query-rewriting technique. We present an extensive experimental analysis on large collections of several million JSON records. Our results show the importance of instance-aware rewriting as well as the efficiency and scalability of our approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Rule-based languages have been studied by the database community for more than four decades because of their importance in processing enterprise data and knowledge <ref type="bibr" target="#b7">[8]</ref>. In the recent years, companies like LogicBlox and Relational-AI commercialized fullfledged solutions for rule-based data processing and explainable AI <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b19">20]</ref>. At the same time, companies like Linkedin, Google, Facebook, and Samsung, among others, developed their own rule engines for reasoning on data <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b65">66,</ref><ref type="bibr" target="#b79">80]</ref>. The interest in such formalisms comes from declarativity and expressivity, which make rules a universal form of knowledge suitable for many tasks such as data-integration <ref type="bibr" target="#b45">[46]</ref>, recursive queries <ref type="bibr" target="#b7">[8]</ref>, ontologies and semantic constraints <ref type="bibr" target="#b34">[35]</ref>, data quality and data preparation for feeding machine learning and analytic tools <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b50">51]</ref>.</p><p>This work is licensed under the Creative Commons BY-NC-ND 4.0 International License. Visit https://creativecommons.org/licenses/by-nc-nd/4.0/ to view a copy of this license. For any use beyond those covered by this license, obtain permission by emailing info@vldb.org. Copyright is held by the owner/author(s). Publication rights licensed to the VLDB Endowment. Proceedings of the VLDB Endowment, Vol. <ref type="bibr" target="#b15">16</ref> The variety of data that can be handled by rule languages led to the design of solutions for reasoning on knowledge graphs and hypergraphs <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b67">68]</ref>. Nevertheless, in many practical cases, data exhibits a simpler structure. There is a sheer amount of semistructured data held by transactional systems, data warehouses, and data lakes, which takes the form of data trees. Today, this data is typically serialized as JSON. Beside this, data trees also permeate the whole Web, where JSON is exchanged at a massive rate. As a bottom line, JSON trees are ubiquitous in data-oriented applications, hence among the most practically relevant formats today. This ubiquity makes urgent the development of novel techniques for querying heterogeneous JSON data in a flexible manner.</p><p>Towards this aim, we study a rule language for JSON suitable to: (1) act as a mediating level to integrate heterogeneous JSON data; (2) allow one to enrich the querying vocabulary, hence to adapt it to specific use-cases and free the end-users from mastering the complexity and irregularity of data; (3) be equipped with reasoning capabilities, i.e., be able to infer information not explicitly stored in the data thereby bringing novel and pertinent answers to the user queries. In the quest for such language, a crucial requirement is that it must enable efficient and scalable query answering techniques. Our new approach is to use NoSQL document stores for query-answering over data-trees together with instance-aware query-rewriting techniques to build a scalable and efficient end-to-end framework for reasoning on JSON databases.</p><p>Example 1.1. Figure <ref type="figure" target="#fig_0">1</ref> shows three JSON trees (pictured in black solid lines) ùëá 1 , ùëá 2 , ùëá 3 holding GitHub data from the public archive <ref type="bibr" target="#b1">[2]</ref>. This collection built for data analysis contains 17 types of events stemming from user actions. Data is complex and irregular. For a data-scientist willing to exploit the archive, tasks like ùëñ) running short explorative queries or ùëñùëñ) extracting a training-set for machine learning algorithms can both be extremely time consuming, because of the time required to formulate the "right" queries to the data. To illustrate, a simple information such as the name (login) of a user can appear within different JSON keys (e.g., author for commits, actor for push, user for issues, and more) and within more than 60 different paths in the trees (e.g., actor.login, payload.commits, payload.issue, etc). Let us consider the query ùëû, which concerns the activity of Linus Torvalds (torvalds). It retrieves the id of the events where the user participated, through the answer variable x. This query is empty on all trees, as it has no matches. Indeed, to query the collection, one must first learn the irregular JSON structure. In contrast, rules ùëü 1 -ùëü 6 can be added (on benefit of all end-users) on top of data thereby providing a unified high-level vision of the JSON records. Rules ùëü 4 -ùëü 6 introduce the high-level notion of event from specific types of events (push, commit, issues), which is handy for queries. Rules ùëü 1 -ùëü 3 abstract on the structure of data to define high-level notions of the same types of events, including the id and the user involved. Altogether, the rules enable implicit inferences (pictured as red dashed edges and nodes) which provide answers to ùëû from ùëá 1 and ùëá 3 without requiring users to master the whole variability of data. Note that, as pictured, these are tree rules.</p><p>The left-hand-side (the body) encodes a tree structure to match, while the right-hand-side (the head) encodes the inferences. Nodes shared between the body and the head are linked by dotted lines.</p><p>Nodes that belong to the head only (in red), called existential nodes, extend the tree by introducing fresh nodes; they are necessary to restructure data. Further, as we shall see later, rules can be recursive.</p><p>As already said, querying heterogeneous JSON trees in a flexible manner is critical for many data processing and governance tasks. These include scenarios where one-of operations are executed, e.g., the preparation and extraction of training-sets from heterogeneous data <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b50">51]</ref>. These include scenarios where consecutive queries are run and users expect online answers, e.g., in goal-driven explorative queries <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b77">78]</ref>. In both cases, the solution is to use reasoning algorithms based on materialization and query-rewriting techniques <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b26">27]</ref>. These are different approaches complementing each other, for both theoretical and practical concerns <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b51">52]</ref>. First, each can handle only certain rule fragments; this, regardless of the applicative scenarios. Indeed, both suffer from non-termination issues for languages such as Datalog ¬± (a.k.a. existential rules or Tuple-Generating-Dependencies) <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b33">34]</ref>. This matters here, as tree rules like those of Example 1.1 are related to these formalisms. Second, assuming termination, every method best fits certain applicative scenarios and hardware constraints.</p><p>Materialization consists at extending the database with the inferences produced by rules, as illustrated by Figure <ref type="figure" target="#fig_0">1</ref>. In-memory materialization is regarded as the most effective approach. Systems based on this approach exhibit extremely high-performances because of their reasoning-oriented algorithms and data-structures <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b67">68</ref>]. Yet, in-memory materialization is tied to the capacity at storing inferences (or even loading data) in memory. Concretely, this may confine the use of the technique to powerful hardware even for medium size datasets. Materialization can also be realized with a DBMS backend but it can be much less performant <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>Rewriting consists at propagating the rules into the query thereby leaving the data untouched. The aim is to produce a set of queries whose evaluation on the data yields the same answers as the evaluation of the input query on the extended database. Figure <ref type="figure" target="#fig_2">2</ref> illustrates the rewriting of query ùëû from Example 1.1. In spirit, the rewriting process replaces parts of a query matching a rule head with the rule body itself. The advantages of query rewriting are multiple. First, it requires no additional space to store inferences. Second, it is insensitive to data updates. Third, it allows one to reason with read-only access rights on the database. The most important however is that rewriting can be deployed on top of existing database technology <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b63">64]</ref>. This has two main advantages: it makes the technique resilient to main-memory limitations, as data is stored on disk and inferences not stored at all, and it allows one to delegate query evaluation to the DBMS. On this matter, JSON has been adopted as a data model by several NoSQL document stores, often praised for their performances (e.g., MongoDB, CouchDB, ArangoDB, to cite a few). This opens up for the opportunity of building a novel family of reasoners relying on query rewriting and NoSQL database technology. Indeed, these systems come with adapted data layouts, indexes, query algorithms, buffering, scheduling, and concurrent data access mechanisms among others. All these components can work together to make reasoning on JSON both efficient and scalable. Note that aiming at materialization on top of document stores would almost inevitably lead to data blowups and no scalability because of the tree data-model of JSON <ref type="bibr" target="#b66">[67]</ref>. For these systems, query rewriting is the prominent way to go.</p><p>Contribution. Designing a rewriting-based reasoner on NoSQL document stores has been very little investigated so far <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b66">67]</ref>. This task poses significant technical challenges, namely identifying ùëñ) adequate languages for the task, together with ùëñùëñ) algorithms and optimizations to make query answering efficient and scalable.</p><p>Concerning the first point, to start with, one needs a query and rule language that is closed, i.e., it generates only rewritings that can be handled by the underlying NoSQL system. This is subtle, as NoSQL systems often ensure efficient access to data by reducing the expressivity of queries to rooted path-or tree-shaped queries or forbidding joins. Here, we shall present a language of constrained tree queries and rules enjoying this property. Then, the rewriting process must be finite, which can limit the use recursion in rules. Rewriting recursive rules (e.g., Datalog <ref type="bibr" target="#b7">[8]</ref>) is generally disregarded, and the typical solution is to restrict the language to ensure that the set of rewritings of any query is finite <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b37">38]</ref>. Here, we take another approach and rather try to cope with infinite rewriting sets, while encoding them finitely. Finally, query answering with the target rule language must have tractable data complexity (i.e., polynomial complexity in the size of the data) which is the minimum requirement for efficiency over large data <ref type="bibr" target="#b19">[20]</ref>.</p><p>Concerning the second point, to design algorithms and optimizations for efficient and scalable reasoning, we believe that query rewriting process cannot be agnostic to the underlying database. Therefore, our goal is to couple query rewriting with an innovative instance-aware evaluation strategy. This leverages on a combination of data-summaries, partitioning, and parallelization that allow us to achieve efficiency by distributing the evaluation of rewritings where the matching data is and at the same time achieving scalability on very large collections of JSON data thanks to the NoSQL facilities.</p><p>Summing up, our contributions are the following. 1. We introduce a novel language of constrained rules and queries for reasoning on JSON and present a (general) sound and complete query rewriting algorithm for this setting.</p><p>2. As reasoning with constrained rules is undecidable, we identify a relevant subset, made of relabeling and frontier-constrained rules, featuring decidable query answering with PTime data-complexity. We design an automata-based rewriting algorithm for such rules.</p><p>3. We propose a novel set of instance-aware evaluation techniques that -for a fixed database -allow one to efficiently evaluate large rewritings sets and also scale on large collections of data.</p><p>4. We present an extensive experimental analysis on large collections of several million JSON records showing the efficiency of our approach, and its scalability beyond state-of-the-art reasoners.</p><p>Paper Organization. We introduce our framework in Section 2 then give a high-level presentation of our query answering techniques (Sections 3 and 4). Sections 5 and 6 are devoted to formal developments on query rewriting algorithms. The experimental analysis is presented in Section 7. Section 8 discusses related work. Proofs and further details can be found in the technical report <ref type="bibr" target="#b68">[69]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">FRAMEWORK</head><p>We begin by presenting an abstract setting for reasoning on JSON. We start by posing the notion of tree which will be used throughout the paper. Then, we introduce a new language made of constrained tree rules and queries and define their semantics.</p><p>Briefly, a JSON record is a set of key-value pairs, where a value is recursively defined as a terminal value (constant or null), a sequence of values, or a record. We see a record as a rooted labeled unordered tree, in which edges are labeled by keys, leaves are labeled by constant or null values, and all the internal nodes are unlabeled. Note that a key-value pair (ùëò, ùë£) where ùë£ is a sequence is represented by edges labeled by ùëò leading to the nodes that represent the elements of ùë£. <ref type="foot" target="#foot_0">1</ref> Example 1.1 illustrates the tree vision of records.</p><p>Trees Let L and V be (infinite) sets of edge labels and (terminal) node values, respectively. A tree is a tuple ùëá = (N, E, ùë°, ùúÜ E , ùúÜ N ) where N is a node set and E ‚äÜ N 2 is a non-empty edge set such that (N, E) is a directed tree with root ùë° ‚àà N . Then, ùúÜ E : E ‚Üí L is a (total) edge labeling function (for JSON keys) and ùúÜ N : leaves(ùëá ) ‚Üí V ‚à™ {ùúñ} is a (total) leaf labeling function (for JSON terminal values), where leaves(ùëá ) ‚äÜ N is the set of leaves of the tree. We distinguish between valued leaves, which are those labeled by a value in V, and unvalued leaves labeled by ùúñ. The corresponding subsets are denoted by leaves V (ùëá ) and leaves ùúñ (ùëá ), respectively. Note that all edges are labeled, while only leaf nodes may be valued. Standard definitions about trees are extended in the obvious way. In particular, a subtree of a tree ùëá is a tree included in ùëá ; it is a roooted subtree of ùëá if it has the same root as ùëá .</p><p>Processing trees A leaf assignment of a tree ùëá is a function ùúà : leaves ùúñ (ùëá ) ‚Üí V whose application is defined as ùúà (ùëá ) = (N, E, ùë°, ùúÜ E , ùúà ‚äéùúÜ N ). Next, given a function ùëì , a set ùê¥ = {ùëé 1 , . . . , ùëé ùëô } and a sequence b = (ùëè 1 , . . . , ùëè ùëò ), we note ùëì (ùê¥) = {ùëì (ùëé 1 ), . . . , ùëì (ùëé ùëô )} and ùëì (b) = (ùëì (ùëè 1 ), . . . , ùëì (ùëè ùëò )). Let ùëá 1 and ùëá 2 be trees with ùëá ùëñ = (N ùëñ , E ùëñ , ùë° ùëñ , ùúÜ Eùëñ , ùúÜ Nùëñ ). A homomorphism from ùëá 1 to ùëá 2 is a total function ‚Ñé : N 1 ‚Üí N 2 such that: (i) for all ùëí ‚àà E 1 , ‚Ñé(ùëí) ‚àà E 2 and ùúÜ E 1 (ùëí) = ùúÜ E 2 (‚Ñé(ùëí)); and (ii) for all ùëõ ‚àà leaves V (ùëá 1 ), ùúÜ N 1 (ùëõ) = ùúÜ N 2 (‚Ñé(ùëõ)). A homomorphism ‚Ñé is rooted if ‚Ñé(ùë° 1 ) = ùë° 2 . A homomorphism ‚Ñé from ùëá 1 to ùëá 2 is an isomorphism if ‚Ñé -1 is also a homomorphism (from ùëá 2 to ùëá 1 ).</p><p>Instances and rules An instance is simply a tree (like ùëá 1 ,ùëá 2 ,ùëá 3 in Figure <ref type="figure" target="#fig_0">1</ref>). To distinguish, we will call collection a set of trees. In pictures, edges are always considered as oriented from the root (black node) to the leaves. The body and the head of a rule are both trees, which share their root and some leaves; moreover, leaves in the body may be constrained, which means that they must be mapped to valued nodes in the data. Formally, a constrained tree-rule (or simply rule) is a triple ùëü = (B, H, C) where B and H are trees representing the body and head of ùëü , also denoted by Body(ùëü ) and Head(ùëü ), and C ‚äÜ leaves(B) is a (possibly empty) subset of leaves, said constrained; C is also denoted Constrained(ùëü ); ùêµ and ùêª share the same root, and, beside the root, only leaves can be shared between B and H . The frontier of ùëü , denoted by frontier (ùëü ), is the set of nodes shared between B and H . Furthermore, frontier leaves (ùëü ) denotes the set of leaves of ùëü shared by B and H , i.e., frontier leaves (ùëü ) = leaves(B)‚à©leaves(H ) ‚äÇ frontier (ùëü ). In the formal development, w.l.o.g, we assume no constants in the rules (in contrast with data and queries), that is, leaves</p><formula xml:id="formula_0">V (B) = ‚àÖ = leaves V (H ).</formula><p>Consider again the rules in Figure <ref type="figure" target="#fig_0">1</ref>. Rule ùëü 1 defines a highlevel notion of a push event. First, it verifies if structural conditions defined by the body are met in the data. That is, that a key type with value PushEvent is present, as well as an event id and the login of the user who made the event. Then, it checks for constrained nodes (marked with $ in the picture). That is, it verifies that id and login are associated with terminal values of V. Finally, it computes the result by copying these values within a new structure associated with the key push. Rules ùëü 2 and ùëü 3 are similar. Rule ùëü 4 states that the key push is a particular case of event. This rule is called a relabeling rule. Rules ùëü 5 and ùëü 6 are similar. Note that all frontier leaves are constrained in ùëü 1 -ùëü 3 , and none in ùëü 4 -ùëü 6 . Finally, a key feature of rules is that they may have non-frontier nodes in the head, called existential nodes. This is the case for ùëü 1 -ùëü 3 in Figure <ref type="figure" target="#fig_0">1</ref>, where existential nodes are marked in red. These nodes allow to reorganize extracted values into new structures. In this, our framework is leaning towards Datalog¬±, which extends Datalog with existentially quantified variables <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b34">35]</ref>.</p><p>Rule Semantics As Figure <ref type="figure" target="#fig_0">1</ref> illustrates, the application of rules leads to an extended instance that we compactly see as a (rooted) acyclic graph. This is to simplify the formal development, in that acyclic graphs can always be unfolded into trees. Regardless, since we will focus on query rewriting, these extended instances never have to be computed, as they remain virtual. A trigger for a rule ùëü = (B, H, C) on an (extended) instance ùêº is a pair (ùëü, ‚Ñé) where ‚Ñé is a (not necessarily rooted) homomorphism from B to ùêº respecting the constrained nodes, i.e., such that ‚Ñé(C) ‚äÜ leaves V (ùêº ). The application of (ùëü, ‚Ñé) to ùêº results in ùêº ‚à™ ‚Ñé + (H ), where ‚Ñé + ‚äá ‚Ñé is an extension of ‚Ñé mapping every non-frontier node of H to a fresh node. Given a set of rules Œ†, we denote by ùõº (ùêº, Œ†) the instance obtained from ùêº by applying all triggers on ùêº in parallel, i.e., ùõº (ùêº, Œ†) = ùêº ‚à™ ‚ãÉÔ∏Å (ùëü,‚Ñé) ‚Ñé + (H ) where ùëü ‚àà Œ† and (ùëü, ‚Ñé) is a trigger on ùêº . Given an instance tree ùëá , we define Sat 0 (ùëá , Œ†) = ùëá and Sat ùëñ+1 (ùëá , Œ†) = ùõº (Sat ùëñ (ùëá , Œ†)). Finally, the saturation of ùëá is Sat (ùëá , Œ†) = ‚ãÉÔ∏Å ‚àû ùëñ=0 Sat ùëñ (ùëá , Œ†). This notion of saturation is also known as chase <ref type="bibr" target="#b7">[8]</ref> and is well-defined since the order in which the rule applications are performed has no incidence on the result (up to isomorphism).</p><p>Queries and Certain Answers A constrained tree-query is a triple ùëû = (ùëá , C, x) where ùëá is a tree, C ‚äÜ leaves(ùëá ) is a set of constrained leaves that must be mapped to valued nodes in the data, and x ‚àà C |x| is a sequence of answer nodes. We also denote C by Constrained(ùëû) and x by AnswerSeq(ùëû). We assume valued leaves are always constrained, i.e., leaves V (ùëá ) ‚äÜ C. To illustrate, consider the query ùëû in Figure <ref type="figure" target="#fig_0">1</ref>. The only constrained node is the answer node (marked by ùë•). Hence, this node must be mapped to constant values (here, "431" and "695"). A query ùëû is called Boolean if x = (). A tuple a ‚àà V |x| is an answer to a query ùëû over an extended instance ùêº if there is a rooted homomorphism ‚Ñé from ùëá to ùêº such that ùúÜ N ‚Ä¢ ‚Ñé (x) = a and ‚Ñé(C) ‚äÜ leaves V (ùêº ), i.e., the leaf constraint is fulfilled. The set of answers to ùëû on ùêº is denoted by Ans(ùëû, ùêº ). A tuple a is a (certain) answer to ùëû on ùêº and Œ† if it is an answer to ùëû on Sat (ùëá , Œ†). The set of all answers to ùëû on (ùêº, Œ†) is denoted by Ans(ùëû, ùêº, Œ†). A query ùëû is more general than a query ùëû ‚Ä≤ , denoted by</p><formula xml:id="formula_1">ùëû ‚â• ùëû ‚Ä≤ , if there is a rooted homomorphism ‚Ñé from ùëá ùëû to ùëá ‚Ä≤ ùëû such that ‚Ñé(C ùëû ) ‚äÜ C ùëû ‚Ä≤ and ‚Ñé(x ùëû ) = x ùëû ‚Ä≤ . A classical query containment property [8] holds here: ùëû ‚â• ùëû ‚Ä≤ iff Ans(ùëû ‚Ä≤ , ùêº ) ‚äÜ Ans(ùëû, ùêº ), for all ùêº .</formula><p>Query Rewritings. A sound and complete set of rewritings of ùëû wrt Œ† is a set of queries Q such that, for every instance ùêº , it holds that Ans(ùëû, ùêº, Œ†) = ‚ãÉÔ∏Å ùëû ‚Ä≤ ‚àà Q Ans(ùëû ‚Ä≤ , ùêº ); in this equality, ‚äá expresses soundness, and ‚äÜ completeness. In words, Q must embarck all possible ways in which a query ùëû can be satisfied via the rules of Œ†. For example, Figure <ref type="figure" target="#fig_2">2</ref> illustrates a sound and complete rewriting set for ùëû of Example 1.1, made by the queries ùëû, ùëû 1 , ùëû 2 , ùëû 3 , ùëû ‚Ä≤ 1 , ùëû ‚Ä≤ 2 , ùëû ‚Ä≤ 3 . In Section 3 we will show how our query rewriting algorithms exploit two features of rules. First, rules are tree-shaped, and this makes rewriting within the language of tree queries possible, thereby fitting the requirements of NoSQL APIs (a property one can loose beyond tree rules). Second, the applicability of a rule can be limited via constrained leaves, which, as shown later, will pave the way to decidability. As a last remark, note that, as the definition states, a sound and complete set of rewritings Q is independent of any input instance. This may lead to useless rewritings not matching the data, like ùëû, ùëû 1 , ùëû 2 , ùëû 3 over the trees in Figure <ref type="figure" target="#fig_0">1</ref>. In Section 4 we will present an instance-aware mechanism to prune these efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">NEW QUERY REWRITING ALGORITHMS</head><p>As a first step towards effective query answering on NoSQL stores, we give a query rewriting algorithm for (general) constrained treerules. We revisit techniques developed for existential rules, based on so-called piece-unifiers <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b60">61]</ref>, also reminiscent of view-based query rewriting <ref type="bibr" target="#b70">[71]</ref>. Roughly speaking, a unifier is a node substitution (i.e., a function replacing nodes with nodes) that, as the name suggests, makes part of a query equal to part of a rule head. A pieceunifier checks further structural constraints that are necessary for the soundness of rewriting when the rule head features existential nodes, as the rules ùëü 1 -ùëü 3 from Figure <ref type="figure" target="#fig_0">1</ref>. Given a piece-unifier of a query ùëû with a rule ùëü , a rewriting step produces a new query by substituting the unified part of ùëû with the body of ùëü . Then, given a q' 1 q' 2 q' 3 4 r 5 r 6 r 1 r 2 r 3 set of rules Œ†, a Œ†-rewriting of ùëû is a query obtained by a sequence of rewriting steps with rules from Œ†. E.g., each query in Figure <ref type="figure" target="#fig_2">2</ref> is a Œ†-rewriting of ùëû, with Œ† the rule set of Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>The contribution of this work is to identify a restricted class of piece-unifiers, called (semi-)twig-unifiers, which have the nice property of producing tree-shaped rewritings as we sought. <ref type="foot" target="#foot_1">2</ref> The formal development of semi-twig query rewriting is presented in Section 5. This tool allows us to compute a set of rewritings of a query, whose soundness and completeness is stated as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3.1 (Soundness and Completeness of Rewriting).</head><p>For any query ùëû, instance ùëá , and set of constrained tree-rules Œ†, a ‚àà Ans(ùëû,ùëá , Œ†) iff there is a Œ†-rewriting ùëû ‚Ä≤ of ùëû such that a ‚àà Ans(ùëû ‚Ä≤ ,ùëá ).</p><p>Hence, semi-twig query rewriting allows one to compute a finite sound and complete set of rewritings when such set exists. And indeed, there are rule sets and queries that only admit infinite sound and complete sets of rewritings (even modulo query containment). This can happen already with simple rules, as shown by Figure <ref type="figure" target="#fig_3">3</ref>. Query ùëû searches for projects forkedFrom a repository owned by the keras-team. By rewriting ùëû with the rules ùëü 1 and ùëü 2 , one builds paths of arbitrary length along the key from. All of the obtained queries are incomparable to each other w.r.t. query containment, hence the only sound and complete rewriting set here is infinite. This raises the issue of algorithmic feasibility for query answering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Taming Infinite Rewritings</head><p>In spite of an apparent simplicity, query answering with constrained tree-rules is undecidable. This has been shown already for the specific case of (unconstrained) path rules in various settings <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b39">40]</ref>. This negative result opens the quest for decidable rule languages for reasoning on JSON data. Strategies for recovering decidability include the use of acyclicity notions or syntactic conditions ensuring the termination of (forward or) backward chaining <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b45">46]</ref>. Here, we take a different approach. We consider a language with non-terminating (both forward and) backward chaining, but ensuring that the rewritings of a query can always be finitely captured. We draw inspiration from the language of so-called suffix path-rules proposed in <ref type="bibr" target="#b22">[23]</ref> and lift it to the case of trees, which yields a specific constrained tree-rule fragment we call frontier-constrained rules. Crucially, this fragment makes the rewritings of a query forming a regular tree-language one can capture with automata techniques.</p><p>A Tractable Fragment. We consider combinations of 1) frontierconstrained rules and 2) relabeling rules, which are defined next. Definition 3.2. Let ùëü = (B, H, C) be a constrained tree-rule. Then:</p><p>‚Ä¢ ùëü is frontier-constrained if frontier leaves (ùëü ) ‚äÜ C ‚Ä¢ ùëü is relabeling if B and H are edges and frontier leaves (ùëü ) ‚â† ‚àÖ</p><p>In Figure <ref type="figure" target="#fig_0">1</ref>, ùëü 3 -ùëü 6 are frontier-constrained rules while ùëü 1 -ùëü 4 are relabeling rules. Frontier-constrained rules impose that a trigger maps all the frontier leaves of the rule to data values, but without any further condition on the use of recursion. From a practical viewpoint, they allow one to select values in the data and to reorganize them into structures adapted to the targeted application. Relabeling rules are among the most useful rules for reasoning on trees, as they allow one to define hierarchies of keys. In contrast with frontierconstrained rules, they apply anywhere on a tree instance.</p><p>The decidability of query answering for this fragment follows from a natural translation into first-order logic. Constrained queries and rules are translated into tree-shaped conjunctive queries and existential rules, respectively. Frontier-constrained and relabeling rules are more specifically translated into a decidable fragment of existential rules called body-acyclic frontier-guarded <ref type="bibr" target="#b16">[17]</ref>. For this, we obtain that query answering is in ExpTime for combined complexity <ref type="bibr" target="#b35">[36]</ref>. Our framework can also be translated into a specific description logic, namely ELH V <ref type="bibr" target="#b62">[63]</ref>, which furthermore allows one to derive a PTime upper bound for data complexity. Note however that these complexity results do not make use of query rewriting. By relying on the tree-automata rewriting described next, we will design a query answering technique that effectively runs in polynomial time w.r.t. the size of the data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Capturing Infinite Rewritings With Automata</head><p>A key feature of our (general) query rewriting algorithm is that, when rules are frontier-constrained, it is ensured in any direct rewriting of ùëû that a single node is shared between the remaining part of ùëû and the subtree coming from the rule body. Hence, we fall into an even more specific case of unifiers we call twig-unifiers. As a consequence, infinite sets of rewritings such as those illustrated in Figure <ref type="figure" target="#fig_3">3</ref> can be captured by a tree automaton <ref type="bibr" target="#b43">[44]</ref>. In a nutshell, the constructed automaton is made of sub-automata that encode the initial query ùëû as well as all the specializations of rule bodies that can be involved in a rewriting step. This set of sub-automata is finite as there is a finite number of (non-equivalent) specializations for each rule body. Transitions between states of different sub-automata allow to encode rewritings. The detailed construction is provided in Section 6 and its adequacy now stated (follows by Theorem 6.2). Theorem 3.3. Let Œ† be a set of frontier-constrained and relabeling rules and ùëû be a query. Then, there exists a finite tree automaton A recognizing a sound and complete set of rewritings of ùëû w.r.t. Œ†.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">INSTANCE-AWARE EVALUATION</head><p>The automata approach gives us a ground for query answering but still does not suffice, in practice, to exploit NoSQL databases. Evidently, no database API will take an automaton as a query. Tree queries are instead accepted. Concretely, this means that the automaton language has to be enumerated, and that every single query in a rewriting set has to be evaluated. We are thus facing two issues. First, we need to deal again with the case where rewriting sets are infinite. Second, we need to cope with rewriting sets that are finite but possibly large. To tackle these problems, we extend our query rewriting approach to make it instance-aware, and more specifically able to leverage on structural information of data for the sake of query answering. Our approach consists in using a novel combination of ùëñ) summarization techniques to make rewritings finite and ùëñùëñ) partitioning and parallelization techniques for efficiency. Summarization. To always reduce rewritings to finite sound and complete sets -for a given database instance -we use summaries of data. In theory, it is sufficient to know the size of the data, as the automaton allows one to enumerate queries by their size. So, once exceeded the size of data, enumeration can be safely stopped. This rough bound can be improved by considering only the depth of data as nodes in a rewriting have a bounded outdegree (Theorem 6.2).</p><p>In practice, however, as rewriting is independent of the instance, this can generate many queries that are not matching any data. So we consider a data summary built on the set of maximal paths (root to leaf), i.e., a dataguide <ref type="bibr" target="#b52">[53]</ref>. When we enumerate the automaton language we can use this information to discard some empty queries by checking whether the tree query we are generating contains an invalid path according to the summary. For instance, the set of maximal paths of the trees in Figure <ref type="figure" target="#fig_0">1</ref> is</p><formula xml:id="formula_2">(date) (id) (type) (actor ‚Ä¢ login) (payload ‚Ä¢ commits ‚Ä¢ author) (payload ‚Ä¢ issue ‚Ä¢ user)</formula><p>Obviously, any rewriting featuring a path that is not in this list can be discarded, as it will have no answer on the collection. Summaries can sometimes be simplified when there is little ambiguity in the data, by considering only the depth and the set of edge labels. For the collection of Figure <ref type="figure" target="#fig_0">1</ref> these labels are {date, id, type, actor, login, payload, commits, issue, author, user}. The label summary is less precise but more compact. Paths can also be enriched with ùëò-length prefixes of the values found at their end. For instance, with ùëò = 5, we can associate the value "gvanr" to path payload.commits.author instead of gvanrossum. This can help in filtering queries which use values not found in the data. Working with ùëò-prefixes instead of the values themselves enables more concise summaries while retaining the precision of filtering. So, the path (dataguide), label, and path+prefix will be the three main summaries we consider. All can be used to filter empty queries in the automaton language, and hence to reduce the (possibly infinite) set of rewritings of a query to a finite and still complete set (for the given instance). Furthermore, they can all be computed with a linear traversal of the data, and are typically of limited size. We will use the depth summary as a baseline. We did not consider bisimilarity-based summaries <ref type="bibr" target="#b54">[55]</ref> as they tend to be quite large and more complex to compute; the label and path summaries also proved to be quite effective.</p><p>Partitioning and Parallelization Even if finite, rewriting sets can be hard to evaluate for any database because of the number of queries they may contain. To improve the situation, our intuition is that we must provide a mean to lead the single queries (within a rewriting set) where the matching data is. With this aim, we define an instance-aware reasoning strategy based on partitioning. In doing so, we therefore introduce a pre-processing of a collection providing means for the efficient evaluation of large rewriting sets.</p><p>Let ùêΩ = {ùëá 1 , . . . ,ùëá ùëõ } be a (single) collection of tree instances. Our goal is to define a set of collections ùêΩ 1 , . . . , ùêΩ ùëò making for a partitioning of ùêΩ . We adopt a simple partitioning function oriented towards rooted queries, defined as follows: Œõ ùëë (ùëá ) = Œ† ùëë ùëñ=1 labels ùëñ (ùëá ). The function Œõ ùëë (ùëá ) concatenates the labels of edges at each level (we denote by labels ùëñ (ùëá ) the labels of edges going from level ùëñ-1 to level ùëñ in ùëá ) up to the depth set by the parameter ùëë; Œõ ùëë (ùëá ) is then mapped to an integer denoting the partition number of ùëá . So, two trees ùëá 1 ,ùëá 2 will be in the same partition ùêΩ ùëñ if Œõ ùëë (ùëá 1 ) = Œõ ùëë (ùëá 2 ), meaning that they just agree on the set of labels they use level-wise, up to depth ùëë. Note that for Œõ ùëë the number of partitions is not fixed in advance, and rather depends on ùëñ) the data and ùëñùëñ) the parameter ùëë. The function Œõ ùëë could also be replaced by more complex clustering functions for trees also taking care of load balancing <ref type="bibr" target="#b9">[10]</ref>; exploring this range of possibilities is however beyond the scope of this work. Note that Œõ ùëë (ùëá ) can be computed in linear time at the moment when data is loaded into the database.</p><p>The first net advantage of partitioning is that, instead of a rough summarization for the whole collection, we can deploy a set of narrower data-summaries, one for each partition ùêΩ ùëñ . This obviously leads to a greater filtering power. With this scheme, the queries within a rewriting are more likely to be evaluated on the partitions where they can have a match, according to the summary, instead of being evaluated against the whole database. The use of rewriting, summarization, and partitioning is shown in Figure <ref type="figure" target="#fig_4">4</ref>: A rewriting automaton A (ùëû,Œ†) is built from a query ùëû and a set of rules Œ†. A collection ùêΩ is partitioned into the collections ùêΩ 1 , . . . , ùêΩ ùëò . For every partition ùêΩ ùëñ , the language of A (ùëû,Œ†) is filtered by Summary(ùêΩ ùëñ ). This produces a finite set of queries Q |Summary(ùêΩ ùëñ ) to evaluate on ùêΩ ùëñ .</p><p>Partitioning can be implemented in several ways. Here, we consider physical partitioning, where a distinct database collection is built for every partition. Using a logical partitioning strategy is discussed in <ref type="bibr" target="#b68">[69]</ref> and proved to have similar effectiveness. Finally, with partitioning in place, parallelization can further be added to attack all of these partitions simultaneously by leveraging on the concurrent data access facilities of the underlying database.</p><p>Let us point out that assuming data-awareness is not a strong hypothesis in practice. For instance, data-awareness is implicit in the fact of running a materialization algorithm. Also note that a summary does not capture a single instance, but rather abstracts over a class of instances. Instance-aware query rewriting is evaluated in Section 7. The following sections (5 and 6) present our query rewriting algorithms. The goal of this section is to present semi-twig based unification and query rewriting. As already mentioned, we revisit techniques developed for existential rules, based on so-called piece-unifiers <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b60">61]</ref>. To begin, we need to introduce a key notion, that of separating node. Let ùëá be a tree and ùëÜ be a subtree of ùëá . We denote by (ùëá \ ùëÜ) the forest obtained by removing from ùëá all edges in ùëÜ. Then, the nodes that belong to both ùëÜ and (ùëá \ ùëÜ) are said to separate ùëÜ from ùëá . In other words, these are the nodes of ùëÜ that have their parent or one of their children in (ùëá \ ùëÜ). Figure <ref type="figure" target="#fig_5">5</ref> pictures a tree ùëá with four subtrees ùëÜ 1 , ùëÜ 2 ,ùëá ‚Ä≤ ,ùëá ‚Ä≤‚Ä≤ . The nodes marked with S are separating for at least one subtree. The subtrees ùëÜ 1 (in blue), ùëÜ 2 (in brown) and ùëá ‚Ä≤ (in red) have the same root as ùëá . For all of these subtrees the root is separating; indeed the root has other children that do not belong to the subtree. The root of ùëá ‚Ä≤‚Ä≤ (in red) is separating, this time because its parent does not belong to ùëá ‚Ä≤‚Ä≤ . Note that ùëÜ 2 also has a separating leaf and ùëá ‚Ä≤ also has a separating internal node.</p><p>To simplify definitions, we now assume that the root of a rule head has a single child. This can be done without loss of generality since every rule can be decomposed into an equivalent set of rules satisfying this assumption <ref type="bibr" target="#b68">[69]</ref>.</p><p>Definition 5.1 (Semi-twig). A subtree ùëÜ of ùëá is called semi-twig if:</p><p>(1) the root of ùëÜ has exactly one child (2) any node separating ùëÜ from ùëá is either the root of ùëÜ or a leaf of ùëÜ (i.e., no internal node of ùëÜ is separating).</p><p>A semi-twig without separating leaves is called a twig.</p><p>Consider again ùëá in Figure <ref type="figure" target="#fig_5">5</ref>. Then, ùëÜ 1 is a twig as its only separating node is the root, and ùëÜ 2 is a semi-twig as it has a separating leaf. Finally, ùëá ‚Ä≤ and ùëá ‚Ä≤‚Ä≤ are not semi-twigs, since ùëá ‚Ä≤ has an internal separating node and the root of ùëá ‚Ä≤‚Ä≤ has two children. The intuition behind semi-twigs is that these are the parts of the query that can be easily rewritten (Item (1)) while preserving tree-shaped rewritings (Item (2)). We are now ready to define semi-twig unification. Definition 5.2 (Semi-Twig Unification). A semi-twig-unifier ùúá for a constrained query ùëû and a (general) constrained rule ùëü is a triple (ùëÜ, H, ùúà, ùë¢) where:</p><p>‚Ä¢ ùëÜ is a semi-twig of ùëû ‚Ä¢ H is a rooted subtree of Head(ùëü ) ‚Ä¢ ùúà is a leaf assignment for the nodes in frontier leaves (ùëü ) ‚Ä¢ ùë¢ is a rooted homomorphism from ùëÜ to ùúà (H ) such that ùë¢ (ùëÜ) = ùúà (H ) and ùë¢ maps:</p><p>(1) each constrained leaf of ùëÜ to a frontier leaf of ùëü (2) each separating leaf of ùëÜ to an unconstrained frontier leaf of ùëü .</p><p>Although the definition of semi-twig unification may seem somewhat involved, it is perfectly natural. The goal is to identify part of the query (i.e., ùëÜ) that is entailed by the application of the rule ùëü . Rewriting will then replace this part by a suitable specialization of the body of ùëü that reflects the way in which the rule is applied. This is captured first by the rooted homomorphism from ùëÜ to a leaf assignment of H . This leaf assignment may only assign to a frontier node in ùëü a value from ùëÜ, since ùë¢ (ùëÜ) = ùúà (H ). By the homomorphism ùë¢, a leaf of ùëÜ is necessarily mapped to a leaf of H . Then, Conditions (1) and ( <ref type="formula">2</ref>) ensure the correctness of rewriting.</p><p>In the next definition of a direct rewriting, the union of the trees ùë¢ (ùëû \ ùëÜ) and ùúà (Body(ùëü )) is defined in the obvious way (i.e, by making the union of the node sets, the edge sets and the functions) and it can be checked that it results in a tree. Definition 5.3 (Semi-Twig Rewriting). Let ùúá = (ùëÜ, H, ùúà, ùë¢) be a semi-twig-unifier for a constrained query ùëû and a (general) constrained rule ùëü . A direct rewriting of ùëû with ùúá is a query ùëû rew = (ùëá , C, x) such that:</p><formula xml:id="formula_3">‚Ä¢ ùëá = ùë¢ (ùëû \ ùëÜ) ‚à™ ùúà (Body(ùëü )) ‚Ä¢ C = ùë¢ (Constrained(ùëû)) ‚à™ Constrained(ùëü ) ‚Ä¢ x = ùë¢ (AnswerSeq(ùëû)).</formula><p>Proposition 5.4 (Closedness). ùëû rew is a constrained tree query.</p><p>Let us come back to Conditions (1) and ( <ref type="formula">2</ref>) of semi-twig unification and illustrate them with the query ùëû and rules ùëü 1 and ùëü 2 from Figure <ref type="figure" target="#fig_5">5</ref>. Both rules have a constrained leaf in their body. This leaf is frontier for ùëü 1 , but not for ùëü 2 . Hence, an application of ùëü 1 only brings a new edge, while an application of ùëü 2 also brings a new node. One could consider unifying the semi-twig ùëÜ ‚Ä≤ 1 constituted by the sole edge labeled by a. Note that the leaf of ùëÜ ‚Ä≤ 1 is separating, hence can only be mapped to an unconstrained frontier leaf. Unifying ùëÜ ‚Ä≤ 1 with ùëü 1 would violate Condition (2) because the frontier leaf of ùëü 1 is constrained (and the associated rewriting would not be a well-formed query, as it would have an internal constrained node). Unifying ùëÜ ‚Ä≤ 1 with ùëü 2 would also violate Condition (2) because the leaf of Head(ùëü 2 ) is not frontier (and the associated rewriting would not be a well-formed query, as it would be disconnected, and would furthermore be unsound). Now, consider the twig ùëÜ ‚Ä≤ 2 . It can be unified with ùëü 1 thereby yielding the query ùëû rew ùëü 1 . However, ùëÜ ‚Ä≤ 2 cannot be unified with ùëü 2 because Condition (1) would be violated (and the associated rewriting would be unsound). Finally, we say that ùëû rew is a Œ†-rewriting of ùëû if there is a sequence ùëû = ùëû 0 , ùúá 1 , ùëû ‚Ä≤ 1 , ..., ùúá ùëò , ùëû ‚Ä≤ ùëò = ùëû rew such that ùëû ùëñ is a direct rewriting of ùëû ùëñ-1 with ùúá ùëñ using a rule of Œ† and ùëû ‚Ä≤ ùëñ = (ùëû ùëñ ) safe , where ‚Ä¢ safe is a function replacing all nodes of ùëû ùëñ by fresh nodes (1 ‚â§ ùëñ ‚â§ ùëò). This is merely a technicality, but it is needed to avoid multiple uses of the same node if ùëü is used multiple times in a rewriting sequence. The soundness and completeness of query rewriting ensures that for any query ùëû, instance ùëá , and set of constrained tree-rules Œ†, a ‚àà Ans(ùëû,ùëá , Œ†) if and only if there is a Œ†-rewriting ùëû ‚Ä≤ of ùëû such that a ‚àà Ans(ùëû ‚Ä≤ ,ùëá ) (as stated by Theorem 3.1). From this, we can easily build a breadth-first query rewriting operator in the spirit of <ref type="bibr" target="#b60">[61]</ref> that terminates if and only the query admits a finite sound and complete set of rewritings. However, this still leaves the case of infinite rewritings open. An important remark can be made about 2) on which we will focus in the next section.</p><p>Remark 1. Let (ùëÜ, H, ùúà, ùë¢) be a semi-twig unifier for a query ùëû and a frontier-constrained rule ùëü . Then, ùëÜ must be a twig.</p><p>For instance, in Figure <ref type="figure" target="#fig_5">5</ref>, both rules are frontier-constrained, hence ùëÜ ‚Ä≤ 1 can be disregarded for rewriting as it is not a twig.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">AUTOMATA-BASED QUERY REWRITING</head><p>Frontier-constrained rules do not ensure the finiteness of rewriting sets (nor of saturation). However, they have the following key property: the rewriting set of a query under frontier-constrained rules can be characterized by a regular tree language. This means that it can be compactly represented by a tree automaton. Frontierconstrained tree rules generalize context-free path rules in <ref type="bibr" target="#b22">[23]</ref> which are in turn related to suffix-rewriting systems <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b71">72]</ref>. What paves the way for regularity is that frontier-constrained rules make any semi-twig unifier for the query to be necessarily a twig-unifier (Remark 1). Another important insight is that adding relabeling rules (which, in contrast, requires semi-twig unifiers that may not be twig unifiers) still preserves regularity, and so both types of rules can be taken into account jointly. The goal of this section is to present the construction of the automaton A (ùëû,Œ†) recognizing a sound and complete set of rewritings for a query ùëû against a set of rules Œ†. We start by posing the notion of tree automaton needed to capture the rewritings of a query. This follows standard models <ref type="bibr" target="#b43">[44]</ref> adapted to the case of unordered trees. Definition 6.1 (Automaton). A bottom-up automaton for unordered trees is a tuple A = (Œ£, S, L, F , Œî) where:</p><p>‚Ä¢ Œ£ is an alphabet ‚Ä¢ S is a set of states made of S ùê∏ a set of edge-states and S ùëÅ a set of node-states ‚Ä¢ L, F ‚äÜ S ùëÅ are sets of initial (leaves) and final (root) states</p><formula xml:id="formula_4">‚Ä¢ Œî is a set of transitions made of Œî L ‚äÜ (Ô∏Å Œ£ ‚à™ {ùúñ} )Ô∏Å √ó L a set of leaf nodes transitions Œî ùê∏ ‚äÜ S ùëÅ √ó Œ£ √ó S ùê∏ a set of edge transitions Œî ùëÅ ‚äÜ 2 S ùê∏ √ó S ùëÅ</formula><p>a set of (non-leaf) node transitions A run of A on ùëá = (N, E, ùë°, ùúÜ E , ùúÜ N ) is a function ùúå : N ‚Üí S ùëÅ that agrees with the transition rules of A, in the following sense.</p><p>‚Ä¢ Every unlabeled leaf ‚Ñì of ùëá is recognized by a Œî L -transition</p><formula xml:id="formula_5">‚àÖ ùúñ -‚Üí ùúå (‚Ñì) ‚Ä¢ Every labeled leaf ‚Ñì of ùëá is recognized by a Œî L -transition ‚àÖ ùúÜ N (‚Ñì) -‚Üí ùúå (‚Ñì)</formula><p>‚Ä¢ Every (non-leaf) node ùëõ of ùëá with children ùëõ 1 , . . . , ùëõ ùëò is recognized by the following Œî-transitions {s 1 . . .</p><formula xml:id="formula_6">s ùëò } -‚Üí ùúå (ùëõ) ‚àà Œî ùëÅ ùúå (ùëõ ùëñ ) ùúÜ E (ùëõ,ùëõ ùëñ ) --‚Üí s ùëñ ‚àà Œî ùê∏</formula><p>provided that s ùëñ ‚â† s ùëó for all 1‚â§ùëñ‚â†ùëó ‚â§ùëò ‚Ä¢ The root ùë° of ùëá is such that ùúå (ùë°) is a final state in F An automaton defines a language (or set) of unordered trees L(A).</p><p>The automata framework represents tree languages, but is insensitive to query features such as constrained and answer nodes. So, to proceed, we must define an encoding of a query ùëû as a "plain" tree encode(ùëû) that can manipulated by automata. The idea of the encoding is to store information on constrained and answer leaf nodes as values. The encoding must essentially cover three cases. The first is where the leaf is unconstrained. The second is where the leaf is constrained but does not belong to the answer sequence. The third is where the leaf belongs to the answer sequence (so, by definition, is also constrained). Figure <ref type="figure" target="#fig_8">6</ref> (left) shows a query ùëû ‚Ä≤ as well as its corresponding automaton A encode(ùëû ‚Ä≤ ) . The query seeks for forked projects (forkee) for all records describing a ForkEvent which also includes the project from which fork originated (forkedFrom). The query has three leaf nodes, which are recognized by three initial states of the automaton. Each initial state is used to define a non-leaf node transition ‚àÖ -‚Üí e ùëñ where ùëò 1 = type, ùëò 2 = forkee, and ùëò 3 = forkedFrom. Each transition recognizes an edge of the query. Finally, the non-leaf node transition {e 1 , e 2 , e 3 } -‚Üí s final allows A encode(ùëû ‚Ä≤ ) to recognize the whole tree. Due to space constraints, the formal construction of the automata encoding of queries is detailed in <ref type="bibr" target="#b68">[69]</ref>. The example of Figure <ref type="figure" target="#fig_8">6</ref> illustrates that it is straightforward to build an automaton A ùëá recognizing a tree ùëá which is also minimal (i.e., without useless state or transition). We can do so by creating distinct states and transitions for every (1) node label, (2) edge, and (3) internal node of ùëá . This handling of (un)constrained, valued, and answer nodes, also extends to the encoding of rule bodies introduced from single rewriting steps <ref type="bibr" target="#b68">[69]</ref>. In the remainder of the section, the encoding of a query ùëû and of a rule body ùêµ specialized by a unifier ùúá are denoted by encode(ùëû) and encode(ùúá (ùêµ)), respectively. This is at the basis of the rewriting process described next.</p><p>Building the Rewriting Automaton Remind that our goal is to construct an automaton A (ùëû,Œ†) recognizing the set of rewritings of a query ùëû against a set of rules Œ†. For clarity, we present the construction of A (ùëû,Œ†) in two steps. First, we provide a declarative construction, showing (ùëñ) the main steps of the process as well as its connections to the general query rewriting from Section 5 and (ùëñùëñ) the finiteness of A (ùëû,Œ†) . In the second step, we outline how to also achieve a terminating algorithm. Aencode(q' A(q, {r }) . In there, we do some standard assumptions. First, when constructing an automaton A ùêµ from a specialized rule body, we use a fresh set of states. The Extend operation makes the union of two automata A (ùëû,Œ†) = (Œ£, S, L, F , Œî) and A ùêµ = (Œ£ ùêµ , S ùêµ , L ùêµ , F ùêµ , Œî ùêµ ) but gives precedence to the final state of A (ùëû,Œ†) by returning (Œ£ ‚à™ Œ£ ùêµ , S ‚à™ S ùêµ , L ‚à™ L ùêµ , F , Œî ‚à™ Œî ùêµ ). Finally, as we work with automata that have a single final state, we denote by s final A the final state of A. Figure <ref type="figure" target="#fig_8">6</ref> (right) illustrates the rewriting of the query ùëû presented in Figure <ref type="figure" target="#fig_3">3</ref> with rules ùëü 1 and ùëü 2 . Recall that query ùëû searches for projects forkedFrom a repository owned by the keras-team. The query has an infinite rewriting set, which is captured as follows. The process starts by initializing A (ùëû,Œ†) as the automaton for encode(ùëû). A twig-unifier ùúá for ùëü 2 and ùëû is found (steps 3 and 4). Remark that ùúá unifies a twig of the query (actually, the path forkedFrom.owner) with a twig of the rule head. This leads to the extension of A (ùëû,Œ†) with a fresh sub-automaton for encode(ùúá (Body(ùëü 2 ))) (step 5). Also this yields a a novel non-leaf node transition {e 1 , e 2 , e 5 }-‚Üís final ùëû (step 6) resulting from replacing e 3 by e 5 in {e 1 , e 2 , e 3 }-‚Üís final ùëû . In Figure <ref type="figure" target="#fig_8">6</ref>, abusing of notation, we picture this with an edge from e 5 to e 3 . At this point, b the relabeling rule ùëü 1 is applied to the fresh sub-automaton (step 2). This in turn yields a new twig-unifier ùúá ‚Ä≤ for ùëü 2 (steps 3, 4). As encode(ùúá (Body(ùëü 2 ))) = encode(ùúá ‚Ä≤ (Body(ùëü 2 ))), no extension of A (ùëû,Œ†) is performed at this time (step 5). However, c a novel non-leaf node transition {e 5 }-‚Üís 5 (step 6) capturing the infinite recursion stemming from the rules ùëü 1 and ùëü 2 is added. The correctness of the construction is now stated <ref type="bibr" target="#b68">[69]</ref>. Theorem 6.2 (Soundness and Completeness). Let Œ† be a set of frontier-constrained and relabeling rules. For every tree ùëá and query ùëû we have that ‚ãÉÔ∏Å encode(ùëû ‚Ä≤ ) ‚ààL(A (ùëû,Œ†) ) Ans(ùëá , ùëû ‚Ä≤ ) = Ans(ùëá , ùëû, Œ†). Also, A (ùëû,Œ†) is finite and its language is made by trees of bounded rank.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>All-at-Once Twig-Unification</head><p>To turn our declarative construction into a terminating algorithm we have to provide a finite procedure for the enumeration of all possible queries and twigunifiers (steps 3 and 4) which may loop when A (ùëû,Œ†) recognizes an infinite language. And indeed, it is possible to manipulate these unifiers all-at-once by directly working on the states of A (ùëû,Œ†) . So, instead of considering every possible query ùëû ‚Ä≤ recognized by A (ùëû,Œ†) and every possible twig ùëÜ of ùëû ‚Ä≤ we do the following. First, we iterate on the (finite) set of rooted twigs H that belong to the head of the rules in Œ†. Then, for each H , we iterate on the (finite) set of node-states s of A (ùëû,Œ†) . For every H and s, we check if A (ùëû,Œ†) (s)  (that is, the automaton A (ùëû,Œ†) where the final state is set to be s) recognizes a tree ùëá such that ùëÜ is a rooted twig of ùëá and there are ùë¢ and ùúà such that ùë¢ (ùëÜ) = ùúà (H ). Because H is finite this can be done in a finite number of steps. In this way, we can capture all unifiers ùúá representing a possibly infinite class of unifiers. Once A (ùëû,Œ†) built, it is possible to perform a single post-order traversal of an instance ùëá to compute answer to queries <ref type="bibr" target="#b68">[69]</ref>. This adapts classical validation algorithms from <ref type="bibr" target="#b43">[44]</ref>. Follows a PTime data-complexity upper-bound for query answering. The construction is independent from data. Moreover, it can be boostrapped independently from queries. Indeed, the unifiers that hold between the rules only, as those for ùëü 1 and ùëü 2 in Figure <ref type="figure" target="#fig_8">6</ref>, can be precomputed off-line thus reducing rewriting costs at query time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXPERIMENTAL ANALYSIS</head><p>Implementation We implemented our approach for reasoning over document stores in a Java 11 tool: TreeForce (TF). This library can be seen as a general toolbox for implementing reasoning techniques for tree-shaped data and rules. The tool has been coded from scratch. It is composed of two main modules. The first includes generic data structures and algorithms for trees and tree-automata. The second includes our instance-aware query rewriting and evaluation methods. TreeForce also includes a translation module tied to the target DBMS. We deployed our system on top of a well-known NoSQL database: MongoDB (v5.0.8). Our approach can be ported to systems supporting constrained tree-queries, which is a basic requirement for many stores <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b69">70]</ref>. Query translation as well as the deployment on other systems is discussed in <ref type="bibr" target="#b68">[69]</ref>.</p><p>Environment We performed all experiments on a machine with an AMD Ryzen 9 3900XT CPU (4.7 Ghz, 12 cores), 128GB DDR4 2400Mhz memory and 2TB SSD disk, running KDE neon on ext4 FS. By relying on MongoDB, TreeForce has modest memory requirements. We allocated only 10GB memory to the JVM (jdk16). We used MongoDB standard configuration with 8GB cache size.</p><p>Benchmarks used for our study are shown in Table <ref type="table" target="#tab_1">1</ref>. We defined three benchmarks from known benchs: DBLP JR , GitHub JR and XMark JR (JR, for JSON Reasoning). DBLP and GitHub are large corpus of real data. XMark, in contrast, is a synthetic benchmark but equipped with a data generator that helped us in better understanding the scalability question. Both DBLP and XMark come as XML; they have been translated into JSON to feed document stores. These systems are oriented towards the exploitation of limited size records (e.g., 16MB for MongoDB). So, XML trees have been shredded into a collection of JSON records in a standard way, that is, by recording the main objects of the original data in different records (e.g., one record per publication in DBLP JR ). DBLP JR and GitHub JR are tests over several million real world records. For DBLP JR we used 22 queries containing a mix of tree queries of different complexity inspired from those in <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b51">52]</ref>. We manually defined a set of 51 rules with 15 frontier-constrained rules and 36 relabeling rules inspired both from the DBLP ontology (dblp.org/rdf/schema) and <ref type="bibr" target="#b29">[30]</ref>. For GitHub JR we defined 5 queries of different complexity and 54 tree-rules including 40 frontier-constrained and 14 relabeling.</p><p>Overall, these allowed us to gauge our approach on real voluminous data. XMark JR includes a set of 115 distinct JSON collections (up to several million records), 23 rulesets (containing 5 to 62 relabeling rules), and 10 queries. XMark JR is an extension of the well-known XMark <ref type="bibr" target="#b74">[75]</ref> we designed to dispose of a rule-based query answering benchmark over trees to understand the scalability of our approach. First, XMark JR allows us to control the number of rewritings of a query -which is a crucial parameter. We consider 23 rulesets each creating a larger number of rewritings per query (from 1 to 500). Second, it allows us to control the size and variability of data. So for, each ruleset, we considered five collections (see Table <ref type="table" target="#tab_1">1</ref>), with the larger collection having 1.4B edges when data is seen as trees.</p><p>We refer to <ref type="bibr" target="#b68">[69]</ref> for its detailed presentation. Overall, XMark JR is meant to push the limits of rewriting-based query answering.</p><p>Other systems. We are not aware of any system for reasoning with constrained-tree rules on top of JSON data. However, as our rules can be encoded as Datalog ¬± rules <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34]</ref> we used reasoners for Datalog ¬± designed for knowledge-graphs as a baseline. Materialization-based approaches. We used VLog <ref type="bibr" target="#b40">[41]</ref> via Rulewerk <ref type="bibr" target="#b4">[5]</ref> to study in-memory materialization. VLog is a high-performance state-of-the-art reasoner <ref type="bibr" target="#b10">[11]</ref>. As it runs in-memory, it gives us a point on absolute performance to evaluate DBMS-based approaches. Rewriting-based approaches. Graal is the only rewriting-based system for Datalog ¬± we are aware of <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b61">62]</ref>. We used a recent major version of the tool <ref type="bibr" target="#b5">[6]</ref>. Graal is a modular system that allows one to parametrize the storage and reasoning algorithms. So, we leveraged on Graal's modularity to study three rewriting-based strategies, as follows. In all three cases, we used Graal to compute (finite) rewritings of queries -whenever possible. Then, rewritings were evaluated in two different ways. The first is in-memory, again with VLog. The second is with PostgreSQL (v14.7); data was stored as a  knowledge graph by using indexed property-tables <ref type="bibr" target="#b51">[52]</ref> and integer encoding <ref type="bibr" target="#b80">[81]</ref> and tree-queries were translated as SQL queries. As scaling integer encoding can be challenging, we also considered a PostgreSQL storage without integer encoding.</p><p>MongoDB Wrapper Queries have been translated into Mon-goDB with the find() facility which answers true on every record of the collection satisfying a query by returning the record itself. It is also worth noting that for all benchmarks we considered treequeries without answer variables. However, this does not make evaluation easy, as we still ask MongoDB to check if each record satisfies the query. To gauge performances across different systems we asked the competitors compute the set of trees matching a query as for our system. We focused on the computational effort needed for evaluating constrained tree-queries: no input time (i.e., data loading) nor output time (i.e. result serialization) were considered. Inputs were translated into formats recognizable by the other systems (JSON data as CSV, tree queries and rules as DLGP <ref type="bibr" target="#b13">[14]</ref>).</p><p>Overview of the Results We will focus on two aspects. First, a study of the query answering techniques we proposed, then a comparison with the other systems. For space limits, we focus on the main findings and report average query times. Detailed times are reported in <ref type="bibr" target="#b68">[69]</ref>. Results are robust averages over 5 repetitions. All times are in seconds. Experiments with the TreeForce system will be denoted by "TF". The baseline approach for our system uses the depth-summary, this is denoted by TF-depth. Variants of our system with different summaries introduced in Section 4 are denoted TF-{label,path,path+prefix}. We denote by TF-part-parallpath our method with partitioning and parallelization, with the path summary; this is our best resulting approach. The variant of this technique without parallelization is denoted by TF-part-path.</p><p>Linear Scalability of the Underlying Database. Figure <ref type="figure" target="#fig_11">8</ref> illustrates how MongoDB reacts to the evaluation of 1) larger rewriting sets on 2) larger volumes of data produced by XMark JR . Every data point indicates the time taken for evaluating a rewriting set. We can clearly see that the response time is linear both in the size of the rewriting sets and in the size of the data. This is expected as the evaluation algorithm of MongoDB is based on a database scan. This observation is also confirmed on DBLP JR and GitHub JR .</p><p>Summary-based Filtering is Critical. Figure <ref type="figure" target="#fig_12">9</ref> shows average query answering times for the depth, label, path and path+prefix summaries for DBLP JR and GitHub JR . It reports both the query rewriting and the evaluation time. For the path+prefix summary, we fixed ùëò = 5, i.e., prefixes have length 5. We also tested longer prefixes but this did not bring any sensible improvement. For DBLP JR , the label summary leads to an average speedup of 3x on a single query. This raises to 5x for the path summary and to 23x when ùëò-prefixes are added. For GitHub JR , the label summary leads to a speedup of 4x on average, which raises to 17x for the path summary. While for GitHub JR prefixes did not improve much things, for DBLP JR queries with text values, gains with ùëò-prefixes can be in orders of magnitude for single queries <ref type="bibr" target="#b68">[69]</ref>. Overall, it is unavoidable to use data summaries for efficiency as the underlying database system is unable to discard empty queries based on their structure, which slows down performances. Summaries have no effect on XMark JR , which by design produces almost no empty queries, and forces the underlying database to evaluate all queries in a rewriting set. However, summaries will have again the same powerful filtering role combined with partitioning, as discussed next. As a last remark, summaries were relatively lightweight for DBLP JR and GitHub JR . For DBLP JR , they included 50 labels, 188 paths, and 957K 5-prefixes while GitHub JR had 250 labels, 991 paths, and 3.3M 5-prefixes.</p><p>Evaluation Dominates Query Rewriting Costs. Recall that query rewriting is divided in 1) automaton construction and 2) summary-based filtering and query generation. As expected, the query rewriting time depends on the complexity of rules and the size of the resulting rewriting set <ref type="bibr" target="#b68">[69]</ref>. For DBLP JR , the average automaton construction time was 300ms and within 1 second even for thousands of rewritings. For GitHub JR the average automaton construction time was 1.5s and within 3.5 seconds. For XMark JR , it was within 0.1 seconds in general. After the automaton construction follow filtering and query generation. Rewriting generation was on average in the order of tens of milliseconds and within 200ms for large rewritings, across all benchmarks. Figure <ref type="figure" target="#fig_12">9</ref> allows one to compare the rewriting time (automaton construction+query generation) and the evaluation time of a rewriting set, with different data summaries. The main observation is that for large volumes of data query answering is likely to be dominated by the evaluation of a rewriting-set rather than by rewriting itself. Also, automaton construction could be boostrapped off-line as discussed in Section 6 further reducing rewriting costs at query time.</p><p>Partitioning and Parallelization Bring Big Improvements. For partitioning, we used the Œõ ùëë function with ùëë = 2 (Section 4). This led to 8 partitions for DBLP JR , 30 for GitHub JR , and between 6 and 130 for XMark JR . We report the results for the path summary without prefixes. We use this as a yardstick to show that partitioning and parallelization have sensible effects; gains cannot decrease when prefixes are added. Recall we focus on physical partitioning; we found logical partitioning having similar effectiveness <ref type="bibr" target="#b68">[69]</ref>.</p><p>For DBLP JR , we start by looking at the gain provided by partitioning alone (i.e., without parallelization), as illustrated in Figure <ref type="figure" target="#fig_13">10</ref> (TF-part-path). The advantage of partitioning alone is that ùëñ) a query is evaluated on smaller portions of the database and ùëñùëñ) partitions can be skipped when the data summary rules out any answer on a specific partition. In this experiment, partitions are queried sequentially and times added up. For DBLP JR queries that took more than 200ms (20 out 22) the average speedup for (sequentially) querying the partition was of 16.1x; the value increases if all 22 queries are considered <ref type="bibr" target="#b68">[69]</ref>. For GitHub JR , the average speedup was 30x. By introducing parallelization (TF-part-parall-path) the runtime is dominated by the time of querying the "slowest" partition (to which we add the management of the parallel data access). So, the gains further raise to 22.9x for (again: 20 out of 22) DBLP queries and 53x for GitHub JR wrt the baseline TF-depth. For comparison, recall that the path summary had an average speedup of 5.5x (on all 22 queries) on DBLP JR , and of 17.6x on GitHub JR , which means partitioning and parallelization allow one to go 2x to 4x faster wrt the path summary alone on these datasets. As said above, we reported on the path summary to have a yardstick for performances. Interestingly, we found the label summary on DBLP JR to provide essentially the same results <ref type="bibr" target="#b68">[69]</ref>. This is because partitions have a reduced variability of data, hence labels are used with less ambiguity. So, summaries can be both very small and efficient when combined with partitioning. As expected, adding prefixes to the path summary improves the filtering power and reduces the size of rewritings. This can again further improve the speed-up by at least 3x on DBLP JR with respect to using partitioning, parallelization and the path summary without ùëò-prefixes. Overall, these results show the gains provided by partitioning and parallelization.</p><p>Partitioning Leads Towards Horizontal Scalability. Partitioning and parallelization can be extremely efficient in distributing the query answering effort on large databases. Figure <ref type="figure" target="#fig_0">11</ref> (left) reports answering times on an XMark JR ruleset generating rewritings of size 100 over several instances. Data points indicate the average query time for the 10 XMark JR queries. Let us focus on two variants of our system: the baseline (TF-depth) and with partitioning, parallelization, and the path summary (TF-part-parall-path). While for small data the two are closer, gains can reach peaks of two orders of magnitude for single queries on large JSON collections. The average gain on 100M is 2x (over all 23 rulesets), and raises 13.5x on 1G and to 68.2x for 10GB and to 88.8x for 50G. Figure <ref type="figure" target="#fig_0">11</ref> (right) reports single query time with TF-part-parall-path for 10GB and 50G XMark JR data (note, across all rulesets). We observe that the greater is the number of partitions attacked by a query, the lower is the query evaluation time, as the querying effort can be better distributed. For 10GB data we can answer queries with 100 rewritings in 1.3 seconds, which is encouraging. This suggests that other partitioning functions could achieve better load balancing leading towards horizontal scalability; this is left for future work.</p><p>No Stored Inferences and Low Memory Consumption Our method achieves both efficiency and scalability thanks the underlying database. Its persistent storage enables querying on large data, and query rewriting avoids to store any inference. Let us go back to Figure <ref type="figure" target="#fig_0">11</ref> (left), showing average query times for rewriting sets of size 100. Experiments confirm that in-memory materialization with VLog is extremely efficient, especially on small to medium instances, because of its dedicated algorithms and data-structures. TreeForce with partitioning, parallelization, and path summary is slower on small instances but, as data increases, it reaches similar performances (already for ùúÇ = 100). This was confirmed also on XMark JR ruleset generating rewritings of size 10 and 500 <ref type="bibr" target="#b68">[69]</ref>. For ùúÇ = 500, VLog could not load the data as it consumed all of the RAM we allocated. This shows that in-memory solutions may require powerful hardware for their deployment on large datasets, while relying on database solutions allows one to scale with modest memory resources. For DBLP and GitHub the average query time for VLog was 5.9s on DBLP (against 7.4s for TF-part-parall-path) and 0.7s on GitHub JR (against 2.2s for TF-part-parall-path). For a fair comparison, this data does not include the time taken by VLog to apply the rules alone (without computing answers to queries) which can be considered either a one-of operation or not. We report however that rule application time was 160s for DBLP and 65s for GitHub JR (no input nor output time). We conclude that for one-of operations our approach can be relevant also on smaller instances. Finally, note that VLog rule-application is negligible for XMark JR as relabeling rules are kept intensional <ref type="bibr" target="#b56">[57]</ref>; this makes the comparison of Figure <ref type="figure" target="#fig_0">11</ref> meaningful. All of this is interesting also because a DBMS can be considered at disadvantage when compared with main-memory solutions in terms of pure response time.</p><p>Rewriting Algorithms Tailored for Data-Tree. For GitHub JR and XMark JR , we could use Graal to compute rewritings of queries. However, this was not possible for all DBLP JR queries as the translation of DBLP JR tree also yields Datalog ¬± rules which are recursive. Indeed, rewriting with Graal terminated only on 6 queries out of 22. Note that this is not a limitation of this tool, but of any general rewriting algorithm that makes no hypothesis on the shape of data. In contrast, our rewriting algorithm tailored for tree rules terminated in all cases. Hence, times reported next for rewriting-based approaches on DBLP JR only consider those 6 queries.</p><p>The main feature of interest of rewriting-based systems is their frugality in terms of main memory. However, they may face other challenges when scaling out reasoning. The first, is the evaluation of large rewriting sets, which is a well-known issue <ref type="bibr" target="#b32">[33]</ref>. The second is computing dictionary encoding over large collections, which is a question in itself <ref type="bibr" target="#b80">[81]</ref>. Figure <ref type="figure" target="#fig_13">10</ref> illustrates rewriting-based approaches on DBLP JR andGitHub JR showing the effectiveness of our optimizations. XMark JR results for rewriting-based systems are reported in Figure <ref type="figure" target="#fig_0">11</ref>. We include only average times for the cases where all of the 10 XMark JR queries were answered by a system <ref type="bibr" target="#b68">[69]</ref>. For ùúÇ = 500, again data could not be loaded in main memory by VLog. On the other side, Graal could not encode the data, as the dictionary encoding computation ran out of memory. By disabling dictionary encoding data was loaded into PostgreSQL. However, already for ùúÇ = 100, disabling encoding did not allow to answer all the queries of the benchmark (recall, each with 100 rewritings). Our approach, in both its baseline and optimized versions, was able to provide answers across all benchmarks. Overall, we believe these results on rewriting over MongoDB to be very promising.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RELATED WORK AND CONCLUSION</head><p>There has been little work on reasoning on top of JSON databases. Prior work studied path-rules for JSON <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b66">67]</ref>; we focus on treerules. More specifically, our frontier-constrained tree-rules extend the context-free fragment of suffix-path rules from <ref type="bibr" target="#b22">[23]</ref>, while keeping suitability for query rewriting on document-stores. Still on the theoretical level, the work of <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b55">56]</ref> focuses on the computational complexity of some logical query languages for JSON. Note that the frameworks from <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b66">67]</ref> have not been implemented. Another line of work considers the definition of virtual RDF views of JSON data as well as reasoning with RDFS/OWL ontologies at the RDF level <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32]</ref>; we do reasoning at the JSON level.</p><p>With respect to the area of knowledge graphs and hypergraphs, constrained tree-rules allow for existential nodes in the rule head: these are analogous to existentially quantified variables in Datalog ¬± <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b33">34]</ref>. As already said, our decidable fragment can be seen as a strict subset of body-acyclic frontier-guarded existential rules <ref type="bibr" target="#b16">[17]</ref>, as well as of the description logic ELH V <ref type="bibr" target="#b62">[63]</ref>. Many reasoners have been implemented for knowledge graphs. State-of-the-art materialization-based systems include in-memory solutions like VLog <ref type="bibr" target="#b40">[41]</ref>, RDFox <ref type="bibr" target="#b67">[68]</ref> and Vadalog <ref type="bibr" target="#b19">[20]</ref> (the latter being restricted to a specific rule fragment) and RDBMS-based solutions like LLunatic <ref type="bibr" target="#b50">[51]</ref> and DLV <ref type="bibr" target="#b11">[12]</ref>. Note that materialization does not always halt for frontier-constraint tree-rules. State-of-the-art rewritingbased systems include OnTop <ref type="bibr" target="#b36">[37]</ref> and Mastro <ref type="bibr" target="#b38">[39]</ref>, both devoted to lightweight OWL ontologies incomparable with our rules, and Graal for existential rules <ref type="bibr" target="#b14">[15]</ref>. Note that Graal accepts any set of existential rules and conjunctive query, but query rewriting terminates only if the rewriting set is finite <ref type="bibr" target="#b60">[61]</ref>, a property that is not fulfilled by frontier-constrained tree-rules (recall Figure <ref type="figure" target="#fig_3">3</ref>). Also, our query rewriting technique based on semi-twig-unifiers exploits the fact that data is tree-shaped and generates only tree queries.</p><p>Various formalisms for reasoning on XML and object-oriented databases have been studied <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b73">74]</ref>. A difference between our framework and most of these proposals is that they are tied to XML and XPath. Among the rule-based languages for XML, decidable fragments such as XPathLog <ref type="bibr" target="#b64">[65]</ref>, Elog <ref type="bibr" target="#b17">[18]</ref> and F-Logic <ref type="bibr" target="#b58">[59,</ref><ref type="bibr" target="#b59">60]</ref>, which do not allow for existential nodes, are incomparable with our frontier-constrained tree-rules in terms of expressivity. Another sharp difference is that <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b64">65]</ref> have been designed with a forward-chaining reasoning in mind; our focus is query rewriting. Xcerpt <ref type="bibr" target="#b73">[74]</ref> is the closest language to our tree-rules for which backward chaining (over ordered trees) has been studied <ref type="bibr" target="#b72">[73]</ref>. Our work differs as <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b73">74]</ref> provides no guarantees for the termination of Xcerpt rules, while we identify a decidable fragment via query rewriting (over unordered trees). Active XML <ref type="bibr" target="#b6">[7]</ref> is not based on rules but on function calls. UnQL <ref type="bibr" target="#b28">[29]</ref> and XML-QL <ref type="bibr" target="#b44">[45]</ref> are not rule-languages but query-languages based on recursive functions. Although these approaches can be assimilated with ours, their technical development is quite different. A last crucial difference with all these proposals is that our work is the first to consider (and implement) the use of NoSQL document stores to support rule-based query answering over data-trees.</p><p>Rewriting-based techniques have been considered for answering queries over virtual XML views defined either from SQL data <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b76">77]</ref> or XML data <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b78">79]</ref> to support data-integration and secure access to information. Note first that view languages are different from rule languages, which are typically more general. Automata have been proved effective for tackling problems related to XML queries in many settings <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b75">76]</ref>. Very few work considers the presence of recursion in the definition of views. From the automata perspective, the work of <ref type="bibr" target="#b47">[48]</ref> is the closest to ours in spirit as it considers automata-based rewriting for regular XPath queries over recursive XML views. However, the decidable language stemming from recursive view definitions is much closer to <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b64">65]</ref> which makes it orthogonal to frontier-constrained tree-rules. Further, <ref type="bibr" target="#b47">[48]</ref> produces regular-XPath rewritings which are not supported by any system and calls for an ad-hoc implementation. In contrast, our instance-aware method outputs tree-queries and relies on efficient NoSQL systems. To conclude on this matter, note that the problem of answering queries with materialized views <ref type="bibr" target="#b53">[54]</ref> (the input query targets the source database, rewritings target the views) is opposite to the one with virtual views (the input query targets the virtual database, rewritings target the source database). Our approach can nevertheless benefit from the presence of materialized views containing certain answers to queries over the original database. Having materialized views opens for two types of opportunities. First, evaluating a subset of the rewriting-set of a query on the materialized views. Second, the development of early stop techniques for our rewriting algorithms when answers to single rewritings (over views) are found. The study of these questions is however left as the subject of future work.</p><p>In conclusion, we have shown that NoSQL stores can be used to build an efficient and scalable tool for reasoning on JSON databases. We have outlined the importance of instance-aware query rewriting techniques and shown that the combination of data summaries, partitioning and parallelization result in high performances on large data. We believe that some of these ideas can be transposed to the case of knowledge graphs and hypergraphs. Future work also includes the extension to more expressive rule languages, for example including suitable forms of equality constraints and contexts.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Rule-based Querying of GitHub Data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Query Rewriting Associated with Example 1.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Rules and Infinite Rewriting Sequences</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Instance-Aware Rewriting and Evaluation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Separating Nodes and (Semi-)Twig Unification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>ùëñwhere ùë£ ùëñ is the encoding of a query leaf. State s initial 1 recognizes the query leaf labeled by value ForkEvent. By definition, this is a constrained node. Hence its encoding is ùë£ 1 = ($ ‚Ä¢ ForkEvent) where the reserved symbol $ is used to denote a constrained node. State s initial 2 recognizes the answer variable x, which by definition is also constrained. This is encoded as ùë£ 2 = ($ ‚Ä¢ 1), where 1 denotes the position of the answer variable in the answer node sequence. State s initial 3 recognizes an existential node. This is encoded as ùë£ 3 = (#) where # denotes that the node is not constrained. Moving on, the initial states are used to define three edge transitions of the form s initial ùëñ ùëò ùëñ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Query and Rewriting Automata</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>( 1 )( 2 ) 6 )</head><label>126</label><figDesc>Construction of A (ùëû,Œ†) from ùëû and Œ† Initialize A (ùëû,Œ†) to be equal to A encode(ùëû) For every edge transition s a --‚Üí e in Œî ùê∏ and rule ùëü ‚àà Œ† relabeling b into a Add the transition s b --‚Üí e in Œî ùê∏ (3) For every tree encode(ùëû ‚Ä≤ ) recognized by A (ùëû,Œ†) via a run ùúå (4) For every twig-unifier ùúá = (ùëÜ, H, ùúà, ùë¢) for ùëû ‚Ä≤ and rule ùëü ‚àà Œ† (5) Extend A (ùëû,Œ†) with an automaton for A encode(ùúá (Body(ùëü ))) (if not already done) (Add to Œî ùëÅ a (non-leaf) node transition ( U \ T ) ‚à™ B --‚Üí ùúå (Root(ùëÜ)) where ‚Ä¢ U = {ùúå (ùëõ 1 ), . . . , ùúå (ùëõ ùëò )} is a set of node-states where ùëõ 1 , . . . , ùëõ ùëò are the children of Root(ùëÜ) within the query ùëû ‚Ä≤ ‚Ä¢ T = {ùëõ ùëó } is a singleton node-state where ùëõ ùëó is the (only) child of Root(ùëÜ) within the twig ùëÜ ‚Ä¢ B is a set of states such that B --‚Üí s final encode(ùúá (Body(ùëü ))) (7) Repeat (2-6) until no more transitions can be added.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Rewriting Automaton Construction</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Answering Time (baseline) -XMark JR</figDesc><graphic coords="11,75.82,81.22,197.19,98.60" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Answering Time (average) vs Summaries</figDesc><graphic coords="11,56.36,207.75,118.57,78.99" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Answering Time (average) -Rewriting Systems</figDesc><graphic coords="12,317.56,80.31,124.05,81.19" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>, No. 11 ISSN 2150-8097.</figDesc><table /><note><p>doi:10.14778/3611479.3611481</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Dataset Size</figDesc><table><row><cell>XMark JR</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We do not represent the ordering on the elements of a sequence, since the considered queries do not exploit this order. Moreover, a nested sequence is seen as a constant.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>In passing, note we cannot use the query rewriting algorithm based on piece-unifiers as-it-is, because 1) it may yield (more specific) rewritings that are not trees and 2) it may not terminate when it should, as it does not take into account the shape of data.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We are grateful to <rs type="person">Florent Tornil</rs> for his help with the experiments. This work was financially supported by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_sRAwrY3">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>

			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The source code, data, and/or other artifacts have been made available at https://gitlab.inria.fr/boreal-artifacts/pvldb2023.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Software) MongoDB</title>
		<ptr target="www.mongodb.com" />
		<imprint>
			<date type="published" when="2009">2009. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">GitHub (GH) Archive</title>
		<ptr target="www.gharchive.org" />
		<imprint>
			<date type="published" when="2011">2011. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="www.arangodb.com" />
		<title level="m">Software) ArangoDB</title>
		<imprint>
			<date type="published" when="2011">2011. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="https://asterixdb.apache.org" />
		<title level="m">Software) AsterixDB</title>
		<imprint>
			<date type="published" when="2016">2016. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="www.github.com/knowsys/rulewerk" />
		<title level="m">Software) Rulewerk</title>
		<imprint>
			<date type="published" when="2018">2018. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="https://gitlab.inria.fr/rules/integraal" />
		<title level="m">Software) InteGraal</title>
		<imprint>
			<date type="published" when="2022">2022. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Positive Active XML</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omar</forename><surname>Benjelloun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<idno type="DOI">10.1145/1055558.1055564</idno>
		<ptr target="https://doi.org/10.1145/1055558.1055564" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-third ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">Catriel</forename><surname>Beeri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</editor>
		<meeting>the Twenty-third ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004-06-14">2004. June 14-16, 2004</date>
			<biblScope unit="page" from="35" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Foundations of Databases: The Logical Level</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<pubPlace>Boston, MA, USA</pubPlace>
		</imprint>
	</monogr>
	<note>1st ed.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Regular Path Queries with Constraints</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<idno type="DOI">10.1006/jcss.1999.1627</idno>
		<ptr target="https://doi.org/10.1006/jcss.1999.1627" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="428" to="452" />
			<date type="published" when="1999-06">1999. June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">XML Data Clustering: An Overview</title>
		<author>
			<persName><forename type="first">Alsayed</forename><surname>Algergawy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Mesiti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richi</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gunter</forename><surname>Saake</surname></persName>
		</author>
		<idno type="DOI">10.1145/1978802.1978804</idno>
		<ptr target="https://doi.org/10.1145/1978802.1978804" />
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">41</biblScope>
			<date type="published" when="2011-10">2011. oct 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">ForBackBench: A Benchmark for Chasing vs. Query-Rewriting</title>
		<author>
			<persName><forename type="first">Afnan</forename><surname>Alhazmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Blount</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Konstantinidis</surname></persName>
		</author>
		<idno type="DOI">10.14778/3529337.3529338</idno>
		<ptr target="https://doi.org/10.14778/3529337.3529338" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1519" to="1532" />
			<date type="published" when="2022-06">2022. jun 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Disjunctive Datalog System DLV</title>
		<author>
			<persName><forename type="first">Mario</forename><surname>Alviano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Faber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simona</forename><surname>Perri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Pfeifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giorgio</forename><surname>Terracina</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-24206-9_17</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-24206-9_17" />
	</analytic>
	<monogr>
		<title level="m">Datalog Reloaded -First International Workshop, Datalog 2010</title>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Oege De Moor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tim</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andrew</forename><forename type="middle">Jon</forename><surname>Furche</surname></persName>
		</editor>
		<editor>
			<persName><surname>Sellers</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-03-16">2010. March 16-19, 2010</date>
			<biblScope unit="volume">6702</biblScope>
			<biblScope unit="page" from="282" to="301" />
		</imprint>
	</monogr>
	<note>Revised Selected Papers (Lecture Notes in Computer Science</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design and Implementation of the LogicBlox System</title>
		<author>
			<persName><forename type="first">Molham</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Balder Ten Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emir</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">L</forename><surname>Pasalic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Veldhuizen</surname></persName>
		</author>
		<author>
			<persName><surname>Washburn</surname></persName>
		</author>
		<idno type="DOI">10.1145/2723372.2742796</idno>
		<ptr target="https://doi.org/10.1145/2723372.2742796" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIG-MOD International Conference on Management of Data</title>
		<meeting>the 2015 ACM SIG-MOD International Conference on Management of Data<address><addrLine>Melbourne, Victoria, Australia; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1371" to="1382" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;15)</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Datalog+, RuleML and OWL 2: Formats and Translations for Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alain</forename><surname>Gutierrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Lecl√®re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swan</forename><surname>Rocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cl√©ment</forename><surname>Sipieter</surname></persName>
		</author>
		<ptr target="https://ceur-ws.org/Vol-1417/paper9.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the RuleML 2015 Challenge, the Special Track on Rule-based Recommender Systems for the Web of Data, the Special Industry Track and the RuleML 2015 Doctoral Consortium hosted by the 9th International Web Rule Symposium (RuleML 2015)</title>
		<editor>
			<persName><forename type="first">Nick</forename><surname>Bassiliades</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Paul</forename><surname>Fodor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Adrian</forename><surname>Giurca</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tom√°s</forename><surname>Kliegr</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Grzegorz</forename><forename type="middle">J</forename><surname>Nalepa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Monica</forename><surname>Palmirani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Adrian</forename><surname>Paschke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Mark</forename><surname>Proctor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dumitru</forename><surname>Roman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fariba</forename><surname>Sadri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Nenad</forename><surname>Stojanovic</surname></persName>
		</editor>
		<meeting>the RuleML 2015 Challenge, the Special Track on Rule-based Recommender Systems for the Web of Data, the Special Industry Track and the RuleML 2015 Doctoral Consortium hosted by the 9th International Web Rule Symposium (RuleML 2015)<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08-02">2015. August 2-5, 2015</date>
			<biblScope unit="volume">1417</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings)</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graal: A Toolkit for Query Answering with Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Lecl√®re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swan</forename><surname>Rocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cl√©ment</forename><surname>Sipieter</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-21542-6_21</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-21542-6_21" />
	</analytic>
	<monogr>
		<title level="m">Rule Technologies: Foundations, Tools, and Applications -9th International Symposium, RuleML 2015</title>
		<editor>
			<persName><forename type="first">Nick</forename><surname>Bassiliades</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fariba</forename><surname>Sadri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Adrian</forename><surname>Paschke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dumitru</forename><surname>Roman</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015-08-02">2015. August 2-5, 2015. 9202</date>
			<biblScope unit="page" from="328" to="344" />
		</imprint>
	</monogr>
	<note>Proceedings (Lecture Notes in Computer Science)</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Lecl√®re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Salvat</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2011.03.002</idno>
		<ptr target="https://doi.org/10.1016/j.artint.2011.03.002" />
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Walking the Complexity Lines for Generalized Guarded Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Micha√´l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-126</idno>
		<ptr target="https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-126" />
	</analytic>
	<monogr>
		<title level="m">IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting><address><addrLine>Barcelona, Catalonia, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-07-16">2011. July 16-22, 2011</date>
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
	<note>IJCAI/AAAI</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Supervised Wrapper Generation with Lixto</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Baumgartner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Flesca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/2001/P715.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB 2001, Proceedings of 27th International Conference on Very Large Data Bases</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Peter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Paolo</forename><surname>Apers</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Atzeni</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Ceri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kotagiri</forename><surname>Paraboschi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Ramamohanarao</surname></persName>
		</editor>
		<editor>
			<persName><surname>Snodgrass</surname></persName>
		</editor>
		<meeting><address><addrLine>Roma, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2001-09-11">2001. September 11-14, 2001</date>
			<biblScope unit="page" from="715" to="716" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Proof Procedure for Data Dependencies</title>
		<author>
			<persName><forename type="first">Catriel</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1145/1634.1636</idno>
		<ptr target="https://doi.org/10.1145/1634.1636" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="718" to="741" />
			<date type="published" when="1984-09">1984. Sept. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Vadalog System: Datalog-based Reasoning for Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Luigi</forename><surname>Bellomarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<idno type="DOI">10.14778/3213880.3213888</idno>
		<ptr target="https://doi.org/10.14778/3213880.3213888" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="975" to="987" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Benchmarking the Chase</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giansalvatore</forename><surname>Mecca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Papotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donatello</forename><surname>Santoro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Efthymia</forename><surname>Tsamoura</surname></persName>
		</author>
		<idno type="DOI">10.1145/3034786.3034796</idno>
		<ptr target="https://doi.org/10.1145/3034786.3034796" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems<address><addrLine>Chicago, Illinois, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="37" to="52" />
		</imprint>
	</monogr>
	<note>) (PODS &apos;17)</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Goal-Driven Query Answering for Existential Rules With Equality</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Efthymia</forename><surname>Tsamoura</surname></persName>
		</author>
		<ptr target="https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/16927" />
	</analytic>
	<monogr>
		<title level="m">AAAI-18), the 30th innovative Applications of Artificial Intelligence (IAAI-18), and the 8th AAAI Symposium on Educational Advances in Artificial Intelligence (EAAI-18)</title>
		<editor>
			<persName><forename type="first">Sheila</forename><forename type="middle">A</forename><surname>Mcilraith</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kilian</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</editor>
		<meeting><address><addrLine>New Orleans, Louisiana, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2018-02-02">2018. February 2-7, 2018</date>
			<biblScope unit="page" from="1761" to="1770" />
		</imprint>
	</monogr>
	<note>Proceedings of the Thirty-Second AAAI Conference on Artificial Intelligence</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Ontology-Mediated Query Answering for Key-Value Stores</title>
		<author>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
		</author>
		<idno type="DOI">10.24963/ijcai.2017/117</idno>
		<ptr target="https://doi.org/10.24963/ijcai.2017/117" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017</title>
		<meeting>the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017<address><addrLine>Melbourne, Australia; Carles Sierra</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-08-19">2017. August 19-25, 2017</date>
			<biblScope unit="page" from="844" to="851" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">OBDA Beyond Relational DBs: A Study for MongoDB</title>
		<author>
			<persName><forename type="first">Elena</forename><surname>Botoeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-1577/paper_40.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Workshop on Description Logics</title>
		<meeting>the 29th International Workshop on Description Logics<address><addrLine>Cape Town, South Africa</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-04-22">2016. April 22-25, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Expressivity and Complexity of MongoDB Queries</title>
		<author>
			<persName><forename type="first">Elena</forename><surname>Botoeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2018.9</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2018.9" />
	</analytic>
	<monogr>
		<title level="m">21st International Conference on Database Theory, ICDT 2018</title>
		<editor>
			<persName><forename type="first">)</forename><surname>Lipics</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yael</forename><surname>Amsterdamer</surname></persName>
		</editor>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-03-26">2018. March 26-29, 2018</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">JSON: Data model, Query languages and Schema specification</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><surname>Su√°rez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoc</surname></persName>
		</author>
		<idno type="DOI">10.1145/3034786.3056120</idno>
		<ptr target="https://doi.org/10.1145/3034786.3056120" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017</title>
		<editor>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
		</editor>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017-05-14">2017. May 14-19, 2017</date>
			<biblScope unit="page" from="123" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Foundations of Rule-Based Query Answering</title>
		<author>
			<persName><forename type="first">Fran√ßois</forename><surname>Bry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norbert</forename><surname>Eisinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Furche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clemens</forename><surname>Ley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benedikt</forename><surname>Linse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fang</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Summer School Conference on Reasoning Web</title>
		<meeting>the Third International Summer School Conference on Reasoning Web<address><addrLine>Dresden, Germany; Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Path constraints in semistructured databases</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="146" to="193" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">UnQL: a query language and algebra for semistructured data based on structural recursion</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="76" to="110" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Raisonnement efficace sur des grands graphes h√©t√©rog√®nes</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<ptr target="http://www.theses.fr/2020IPPAX061" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
		<respStmt>
			<orgName>Institut polytechnique de Paris</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">These de doctorat</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Obi-Wan: Ontology-Based RDF Integration of Heterogeneous Data</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fran√ßois</forename><surname>Goasdou√©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<idno type="DOI">10.14778/3415478.3415512</idno>
		<ptr target="https://doi.org/10.14778/3415478.3415512" />
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="2933" to="2936" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Ontology-Based RDF Integration of Heterogeneous Data</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fran√ßois</forename><surname>Goasdou√©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2020.27</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2020.27" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Extending Database Technology, EDBT 2020</title>
		<editor>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yongluan</forename><surname>Zhou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marcos</forename><surname>Antonio Vaz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alexander</forename><surname>Salles</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dan</forename><surname>B√∂hm</surname></persName>
		</editor>
		<editor>
			<persName><surname>Olteanu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Arijit</forename><surname>Fletcher</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bin</forename><surname>Khan</surname></persName>
		</editor>
		<editor>
			<persName><surname>Yang</surname></persName>
		</editor>
		<meeting>the 23rd International Conference on Extending Database Technology, EDBT 2020<address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020-03-30">2020. March 30 -April 02, 2020</date>
			<biblScope unit="page" from="299" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Teaching an RDBMS about ontological constraints</title>
		<author>
			<persName><forename type="first">Damian</forename><surname>Bursztyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fran√ßois</forename><surname>Goasdou√©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<idno type="DOI">10.14778/2994509.2994532</idno>
		<ptr target="https://doi.org/10.14778/2994509.2994532" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1161" to="1172" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A general datalogbased framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Cal√¨</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1145/1559795.1559809</idno>
		<ptr target="https://doi.org/10.1145/1559795.1559809" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">Jianwen</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><surname>Su</surname></persName>
		</editor>
		<meeting>the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems<address><addrLine>PODS; Providence, Rhode Island, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009-06-19">2009. 2009. June 19 -July 1, 2009. Jan</date>
			<biblScope unit="page" from="77" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A general Datalogbased framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Cal√¨</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.websem.2012.03.001</idno>
		<ptr target="https://doi.org/10.1016/j.websem.2012.03.001" />
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="57" to="83" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Towards more expressive ontology languages: The query answering problem</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Cal√¨</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2012.08.002</idno>
		<ptr target="https://doi.org/10.1016/j.artint.2012.08.002" />
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">193</biblScope>
			<biblScope unit="page" from="87" to="128" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Ontop: Answering SPARQL queries over relational databases</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarah</forename><surname>Komla-Ebri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="471" to="487" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10817-007-9078-x</idno>
		<ptr target="https://doi.org/10.1007/s10817-007-9078-x" />
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reasoning</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The MASTRO system for ontology-based data access</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Ruzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><forename type="middle">Fabio</forename><surname>Savo</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-2011-0029</idno>
		<ptr target="https://doi.org/10.3233/SW-2011-0029" />
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="43" to="53" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Verification of Evolving Graph-structured Data under Expressive Path Constraints</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Magdalena</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mantas</forename><surname>Simkus</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2016.15</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2016.15" />
	</analytic>
	<monogr>
		<title level="m">19th International Conference on Database Theory, ICDT 2016</title>
		<editor>
			<persName><forename type="first">)</forename><surname>Lipics</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Zeume</surname></persName>
		</editor>
		<meeting><address><addrLine>Bordeaux, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-03-15">2016. March 15-18, 2016</date>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">VLog: A Rule Engine for Knowledge Graphs</title>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irina</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>Gonz√°lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Ceriel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Kr√∂tzsch</surname></persName>
		</author>
		<author>
			<persName><surname>Urbani</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-30796-7_2</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-30796-7_2" />
	</analytic>
	<monogr>
		<title level="m">The Semantic Web -ISWC 2019 -18th International Semantic Web Conference</title>
		<editor>
			<persName><forename type="first">Chiara</forename><surname>Ghidini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Olaf</forename><surname>Hartig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Maria</forename><surname>Maleshkova</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vojtech</forename><surname>Sv√°tek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Isabel</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jie</forename><surname>Song</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Maxime</forename><surname>Lefran√ßois</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
		</editor>
		<meeting><address><addrLine>Auckland, New Zealand</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019-10-26">2019. October 26-30, 2019</date>
			<biblScope unit="volume">11779</biblScope>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II (Lecture Notes in Computer Science)</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On word rewriting systems having a rational derivation</title>
		<author>
			<persName><forename type="first">Didier</forename><surname>Caucal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computation Structures: Third International Conference, FOSSACS 2000 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2000</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000-03-25">2000. March 25-April 2, 2000</date>
			<biblScope unit="page" from="48" to="62" />
		</imprint>
	</monogr>
	<note>Proceedings 3</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Yedalog: Exploring Knowledge at Scale</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vuk</forename><surname>Daniel Von Dincklage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Ercegovac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">S</forename><surname>Hawkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franz</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Och</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName><surname>Pereira</surname></persName>
		</author>
		<ptr target="http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=5017" />
	</analytic>
	<monogr>
		<title level="m">1st Summit on Advances in Programming Languages (SNAPL 2015)</title>
		<meeting><address><addrLine>Dagstuhl, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="63" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><forename type="first">Max</forename><surname>Hubert Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florent</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://www.grappa.univ-lille3.fr/tata" />
		<title level="m">Tree automata techniques and applications</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A query language for XML</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Levy</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer networks</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1155" to="1169" />
			<date type="published" when="1999">1999. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ren√©e</forename><forename type="middle">J</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucian</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><surname>Popa</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2004.10.033</idno>
		<ptr target="https://doi.org/10.1016/j.tcs.2004.10.033" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Secure XML querying with security views</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chee-Yong</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minos</forename><surname>Garofalakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2004 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="587" to="598" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Rewriting regular XPath queries on XML views</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xibei</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 23rd International Conference on Data Engineering</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="666" to="675" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Query translation from XPath to SQL in the presence of recursive DTDs</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianzhong</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bolin</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB journal</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="857" to="883" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">SilkRoute: A framework for publishing relational data in XML</title>
		<author>
			<persName><forename type="first">Mary</forename><surname>Fern√°ndez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yana</forename><surname>Kadiyska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atsuyuki</forename><surname>Morishima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang-Chiew</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="438" to="493" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">That&apos;s All Folks! Llunatic Goes Open Source</title>
		<author>
			<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giansalvatore</forename><surname>Mecca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Papotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donatello</forename><surname>Santoro</surname></persName>
		</author>
		<idno type="DOI">10.14778/2733004.2733031</idno>
		<ptr target="https://doi.org/10.14778/2733004.2733031" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1565" to="1568" />
			<date type="published" when="2014-08">2014. Aug. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Efficient query answering against dynamic RDF databases</title>
		<author>
			<persName><forename type="first">Fran√ßois</forename><surname>Goasdou√©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Roati≈ü</surname></persName>
		</author>
		<idno type="DOI">10.1145/2452376.2452412</idno>
		<ptr target="https://doi.org/10.1145/2452376.2452412" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Extending Database Technology (EDBT &apos;13)</title>
		<meeting>the 16th International Conference on Extending Database Technology (EDBT &apos;13)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="299" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">DataGuides: Enabling Query Formulation and Optimization in Semistructured Databases</title>
		<author>
			<persName><forename type="first">Roy</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Very Large Data Bases (VLDB &apos;97)</title>
		<meeting>the 23rd International Conference on Very Large Data Bases (VLDB &apos;97)</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Answering queries using views: A survey</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="270" to="294" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Computing Simulations on Finite and Infinite Graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Kopke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual Symposium on Foundations of Computer Science (FOCS &apos;95)</title>
		<meeting>the 36th Annual Symposium on Foundations of Computer Science (FOCS &apos;95)<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page">453</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">J-Logic: Logical foundations for JSON querying</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="137" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Datalog Reasoning over Compressed RDF Knowledge Bases</title>
		<author>
			<persName><forename type="first">Pan</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<idno type="DOI">10.1145/3357384.3358147</idno>
		<idno>2065-2068</idno>
		<ptr target="https://doi.org/10.1145/3357384.3358147" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM International Conference on Information and Knowledge Management, CIKM 2019</title>
		<editor>
			<persName><forename type="first">Peng</forename><surname>Cheng</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Elke</forename><forename type="middle">A</forename><surname>Cui</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Rundensteiner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Qi</forename><surname>Carmel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jeffrey</forename><surname>He</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yu</forename><surname>Xu</surname></persName>
		</editor>
		<meeting>the 28th ACM International Conference on Information and Knowledge Management, CIKM 2019<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019-11-03">2019. November 3-7, 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Couchbase Analytics: NoETL for Scalable NoSQL Data Analysis</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">I</forename><surname>Murtadha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Hubail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Alsuliman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Blow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dmitry</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Lychagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Till</forename><surname>Maxon</surname></persName>
		</author>
		<author>
			<persName><surname>Westmann</surname></persName>
		</author>
		<idno type="DOI">10.14778/3352063.3352143</idno>
		<ptr target="https://doi.org/10.14778/3352063.3352143" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2275" to="2286" />
			<date type="published" when="2019-08">2019. aug 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Rules and Ontologies in F-Logic</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<idno type="DOI">10.1007/11526988_2</idno>
		<ptr target="https://doi.org/10.1007/11526988_2" />
	</analytic>
	<monogr>
		<title level="m">Reasoning Web, First International Summer School 2005</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Norbert</forename><surname>Eisinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Maluszynski</surname></persName>
		</editor>
		<meeting><address><addrLine>Msida, Malta</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-07-25">2005. July 25-29, 2005</date>
			<biblScope unit="volume">3564</biblScope>
			<biblScope unit="page" from="22" to="34" />
		</imprint>
	</monogr>
	<note>Tutorial Lectures</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Logical Foundations of Object-Oriented and Frame-Based Languages</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Lausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1145/210332.210335</idno>
		<ptr target="https://doi.org/10.1145/210332.210335" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="741" to="843" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Sound, complete and minimal UCQ-rewriting for existential rules</title>
		<author>
			<persName><forename type="first">M√©lanie</forename><surname>K√∂nig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Lecl√®re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Micha√´l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-140153</idno>
		<ptr target="https://doi.org/10.3233/SW-140153" />
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="451" to="475" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Query rewriting for existential rules with compiled preorder</title>
		<author>
			<persName><forename type="first">M√©lanie</forename><surname>K√∂nig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI: International Joint Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3006" to="3112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Nominal Schemas in Description Logics: Complexities Clarified</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Kr√∂tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference</title>
		<editor>
			<persName><forename type="first">Chitta</forename><surname>Baral</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Giuseppe</forename><surname>De</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Giacomo</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</editor>
		<meeting><address><addrLine>KR; Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2014-07-20">2014. 2014. July 20-24, 2014</date>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Conjunctive Query Answering in the Description Logic EL Using a Relational Database System</title>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
		<ptr target="http://ijcai.org/Proceedings/09/Papers/341.pdf" />
	</analytic>
	<monogr>
		<title level="m">IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence</title>
		<meeting><address><addrLine>Pasadena, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Craig Boutilier</publisher>
			<date type="published" when="2009-07-11">2009. July 11-17, 2009</date>
			<biblScope unit="page" from="2070" to="2075" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A rule-based querying and updating language for XML</title>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Database Programming Languages: 8th International Workshop, DBPL 2001</title>
		<meeting><address><addrLine>Frascati, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2002. September 8-10, 2001</date>
			<biblScope unit="page" from="165" to="181" />
		</imprint>
	</monogr>
	<note>Revised Papers 8</note>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Datalography: Scaling datalog graph analytics on graph processing systems</title>
		<author>
			<persName><forename type="first">Vicky</forename><surname>Walaa Eldin Moustafa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ken</forename><surname>Papavasileiou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alin</forename><surname>Yocum</surname></persName>
		</author>
		<author>
			<persName><surname>Deutsch</surname></persName>
		</author>
		<idno type="DOI">10.1109/BigData.2016.7840589</idno>
		<ptr target="https://doi.org/10.1109/BigData.2016.7840589" />
	</analytic>
	<monogr>
		<title level="m">2016 IEEE International Conference on Big Data (IEEE BigData 2016</title>
		<editor>
			<persName><forename type="first">George</forename><surname>Karypis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ling</forename><surname>Liu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Xiaohua</forename><surname>Hu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ronay</forename><surname>Ak</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yinglong</forename><surname>Xia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Weijia</forename><surname>Xu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Aki-Hiro</forename><surname>Sato</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sudarsan</forename><surname>Rachuri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lyle</forename><forename type="middle">H</forename><surname>Ungar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Rama</forename><surname>Govindaraju</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Toyotaro</forename><surname>Suzumura</surname></persName>
		</editor>
		<meeting><address><addrLine>Washington DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2016-12-05">2016. December 5-8, 2016</date>
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Ontology-Mediated Queries for NOSQL Databases</title>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Christine</forename><surname>Rousset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
		</author>
		<ptr target="http://www.aaai.org/ocs/index.php/AAAI/AAAI16/paper/view/12395" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth AAAI Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Dale</forename><surname>Schuurmans</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><forename type="middle">P</forename><surname>Wellman</surname></persName>
		</editor>
		<meeting>the Thirtieth AAAI Conference on Artificial Intelligence<address><addrLine>Phoenix, Arizona, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2016-02-12">2016. February 12-17, 2016</date>
			<biblScope unit="page" from="1051" to="1057" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">RDFox: A highly-scalable RDF store</title>
		<author>
			<persName><forename type="first">Yavor</forename><surname>Nenov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Piro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhe</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jay</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<author>
			<persName><forename type="first">Rodriguez</forename><surname>Olivier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulliana</forename><surname>Federico</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mugnier</forename><surname>Marie-Laure</surname></persName>
		</author>
		<ptr target="https://gitlab.inria.fr/boreal-artifacts/pvldb2023" />
		<title level="m">Scalable Reasoning on Document Stores via Instance-Aware Query Rewriting</title>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>with Appendix</note>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">The SQL++ Semi-structured Data Model and Query Language: A Capabilities Survey of SQL-on-Hadoop, NoSQL and NewSQL Databases</title>
		<author>
			<persName><forename type="first">Win</forename><surname>Kian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Romain</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><surname>Vernoux</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1405.3631</idno>
		<ptr target="http://arxiv.org/abs/1405.3631" />
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">A Scalable Algorithm for Answering Queries Using Views</title>
		<author>
			<persName><forename type="first">Rachel</forename><surname>Pottinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Very Large Data Bases (VLDB &apos;00)</title>
		<meeting>the 26th International Conference on Very Large Data Bases (VLDB &apos;00)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="484" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Regular canonical systems</title>
		<author>
			<persName><forename type="first">B√ºchi</forename><surname>Richard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Archiv f√ºr mathematische Logik und Grundlagenforschung</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="91" to="111" />
			<date type="published" when="1964">1964. 1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title level="m" type="main">Xcerpt: A rule-based query and transformation language for the Web</title>
		<author>
			<persName><forename type="first">Finn</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Schaffert</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>LMU M√ºnchen: Faculty of Mathematics, Computer Science and Statistics</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Dissertation. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">A gentle introduction to Xcerpt, a rulebased query and transformation language for XML</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Schaffert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fran√ßois</forename><surname>Bry</surname></persName>
		</author>
		<ptr target="https://ceur-ws.org/Vol-60/bry_schaffert.pdf" />
	</analytic>
	<monogr>
		<title level="m">First International Semantic Web Conference ISWC2002 and hosted by SIG2 of the OntoWeb Network (CEUR Workshop Proceedings)</title>
		<editor>
			<persName><forename type="first">Michael</forename><surname>Schroeder</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gerd</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Sardinia, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06-14">2002. 14 June 2002</date>
			<biblScope unit="volume">60</biblScope>
		</imprint>
	</monogr>
	<note>RuleML 2002, Proceedings of the International Workshop on Rule Markup Languages for Business Rules on the Semantic Web</note>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">XMark: A Benchmark for XML Data Management</title>
		<author>
			<persName><forename type="first">Albrecht</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Waas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">L</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralph</forename><surname>Busse</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-155860869-6/50096-2</idno>
		<ptr target="https://doi.org/10.1016/B978-155860869-6/50096-2" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 28th International Conference on Very Large Data Bases, VLDB 2002</title>
		<meeting>28th International Conference on Very Large Data Bases, VLDB 2002<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2002-08-20">2002. August 20-23, 2002</date>
			<biblScope unit="page" from="974" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Automata for XML-a survey</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schwentick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="315" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Querying XML Views of Relational Data</title>
		<author>
			<persName><forename type="first">Jayavel</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerry</forename><surname>Kiernan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugene</forename><forename type="middle">J</forename><surname>Shekita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catalina</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">E</forename><surname>Funderburk</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/2001/P261.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB 2001, Proceedings of 27th International Conference on Very Large Data Bases</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Peter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Paolo</forename><surname>Apers</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Atzeni</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Ceri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kotagiri</forename><surname>Paraboschi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Ramamohanarao</surname></persName>
		</editor>
		<editor>
			<persName><surname>Snodgrass</surname></persName>
		</editor>
		<meeting><address><addrLine>Roma, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2001-09-11">2001. September 11-14, 2001</date>
			<biblScope unit="page" from="261" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">More efficient datalog queries: subsumptive tabling beats magic sets</title>
		<author>
			<persName><forename type="first">Tekle</forename><surname>Tuncay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanhong</forename><forename type="middle">A</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2011 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="661" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Rewriting of visibly pushdown languages for xml data integration</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Thomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivasan</forename><surname>Venkatesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM Conference on Information and Knowledge Management</title>
		<meeting>the 17th ACM Conference on Information and Knowledge Management</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="521" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Materializing knowledge bases via trigger graphs</title>
		<author>
			<persName><forename type="first">Efthymia</forename><surname>Tsamoura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enrico</forename><surname>Malizia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="943" to="956" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">KOGNAC: Efficient Encoding of Large Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sourav</forename><surname>Dutta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sairam</forename><surname>Gurajada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
		<ptr target="http://www.ijcai.org/Abstract/16/548" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016</title>
		<editor>
			<persName><forename type="first">Subbarao</forename><surname>Kambhampati</surname></persName>
		</editor>
		<meeting>the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IJCAI/AAAI Press</publisher>
			<date type="published" when="2016-07">2016. July 2016</date>
			<biblScope unit="page" from="3896" to="3902" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
