<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provenance for the Description Logic ELH r</title>
				<funder>
					<orgName type="full">University of Bergen</orgName>
				</funder>
				<funder ref="#_J6msEUy">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_Rrc9ABa">
					<orgName type="full">Italian PRIN project HOPE</orgName>
				</funder>
				<funder ref="#_bdcfxg9">
					<orgName type="full">Free University of Bozen-Bolzano</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
							<email>camille.bourgaux@ens.fr</email>
							<affiliation key="aff0">
								<orgName type="department">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ana</forename><surname>Ozaki</surname></persName>
							<email>ana.ozaki@uib.no</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Bergen</orgName>
								<address>
									<country key="NO">Norway</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Free University of Bozen-Bolzano</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Rafael</forename><surname>Pe Ñaloza</surname></persName>
							<email>rafael.penaloza@unimib.it</email>
							<affiliation key="aff2">
								<orgName type="institution">University of Milano-Bicocca</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Livia</forename><surname>Predoiu</surname></persName>
							<email>livia.predoiu@unibz.it</email>
							<affiliation key="aff3">
								<orgName type="institution">Free University of Bozen-Bolzano</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Provenance for the Description Logic ELH r</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">AEDF81BE6931EDA6F294509624708B23</idno>
					<idno type="DOI">10.24963/ijcai.2020/258</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We address the problem of handling provenance information in ELH r ontologies. We consider a setting recently introduced for ontology-based data access, based on semirings and extending classical data provenance, in which ontology axioms are annotated with provenance tokens. A consequence inherits the provenance of the axioms involved in deriving it, yielding a provenance polynomial as annotation. We analyse the semantics for the ELH r case and show that the presence of conjunctions poses various difficulties for handling provenance, some of which are mitigated by assuming multiplicative idempotency of the semiring. Under this assumption, we study three problems: ontology completion with provenance, computing the set of relevant axioms for a consequence, and query answering.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Description logics (DLs) are a well-known family of firstorder logic fragments in which conceptual knowledge about a particular domain and facts about specific individuals are expressed in an ontology, using unary and binary predicates called concepts and roles <ref type="bibr">[Baader et al., 2007a]</ref>. Important reasoning tasks performed over DL ontologies are axiom entailment, i.e. deciding whether a given DL axiom follows from the ontology; and query answering. Since scalability is crucial when using large ontologies, DLs with favorable computational properties have been investigated. In particular, the EL language and some of its extensions allow for axiom entailment in polynomial time, and conjunctive query entailment in NP <ref type="bibr" target="#b2">[Baader et al., 2005;</ref><ref type="bibr">Baader et al., 2008a]</ref>. Many real-world ontologies, including SNOMED CT, use languages from the EL family, which underlies the OWL 2 EL profile of the Semantic Web standard ontology language.</p><p>In many settings it is crucial to know how a consequencee.g. an axiom or a query-has been derived from the ontology. In the database community, provenance has been studied for nearly 30 years <ref type="bibr">[Buneman, 2013]</ref> and gained traction when the connection to semirings, so called provenance semirings <ref type="bibr" target="#b34">[Green et al., 2007;</ref><ref type="bibr" target="#b32">Green and Tannen, 2017]</ref> was discovered. Provenance semirings serve as an abstract algebraic tool to record and track provenance information; that is, to keep track of the specific database tuples used for deriving the query, and of the way they have been processed in the derivation. Besides explaining a query answer, provenance has many applications like: computing the probability or the degree of confidence of an answer, counting the different ways of producing an answer, handling authorship, data clearance, or user preferences <ref type="bibr" target="#b55">[Senellart, 2017;</ref><ref type="bibr" target="#b56">Suciu et al., 2011;</ref><ref type="bibr" target="#b44">Lukasiewicz et al., 2014;</ref><ref type="bibr" target="#b40">Ives et al., 2008]</ref>. Semiring provenance has drawn interest beyond relational databases (e.g. <ref type="bibr" target="#b17">[Buneman and Kostylev, 2010;</ref><ref type="bibr" target="#b58">Zimmermann et al., 2012;</ref><ref type="bibr" target="#b30">Deutch et al., 2014;</ref><ref type="bibr" target="#b52">Ramusat et al., 2018;</ref><ref type="bibr" target="#b28">Dannert and Grädel, 2019]</ref>), and in particular has recently been considered for ontology-based data access, a setting where a database is enriched with a DL-Lite R ontology and mappings between them <ref type="bibr" target="#b20">[Calvanese et al., 2019]</ref>. In the latter, the ontology axioms are annotated with provenance variables. Queries are then annotated with provenance polynomials that express their provenance information. Example 1. Consider the facts mayor(Venice, Brugnaro) and mayor(Venice, Orsoni), stating that Venice has mayors Brugnaro and Orsoni, annotated respectively with provenance information v 1 and v 2 , and the DL axiom ran(mayor) Mayor, expressing that the range of the role mayor is the concept Mayor, annotated with v 3 . The query ∃x.Mayor(x) asks if there is someone who is a mayor. The answer is yes and it can be derived using ran(mayor) Mayor together with any of the two facts, interpreting x by Brugnaro or Orsoni. This is expressed by the provenance polynomial</p><formula xml:id="formula_0">v 1 × v 3 + v 2 × v 3 .</formula><p>Intuitively, × expresses the joint use of axioms in a derivation path of the query, and + the alternative derivations.</p><p>We adapt the provenance semantics of Calvanese et al. for the ELH r variant of EL, extending it to those ELH r axioms that do not occur in DL-Lite R . It turns out that handling the conjunction allowed in ELH r axioms is not trivial. To obtain models from which we can derive meaningful provenanceannotated consequences, we adopt ×-idempotent semirings and a syntactic restriction on ELH r (preserving the expressivity of full ELH r when annotations are not considered). After introducing the basic definitions and the semantics for DL ontologies and queries annotated with provenance information, we present a completion algorithm and show that it solves annotated axiom entailment and instance queries in ELH r in polynomial time in the size of the ontology and polynomial space in the size of the provenance polynomial. We then show that we can compute the set of relevant provenance variables for an entailment in polynomial time. Finally, we investigate conjunctive query answering. Note that the query answering methods developed by Calvanese et al. cannot be extended to ELH r since they rely on the FO-rewritability of conjunctive queries in DL-Lite R , a property that does not hold for ELH r <ref type="bibr" target="#b8">[Bienvenu et al., 2013]</ref>. Therefore, we adapt the combined approach for query answering in EL <ref type="bibr" target="#b46">[Lutz et al., 2009]</ref> to provenance-annotated ELH r ontologies.</p><p>Detailed proofs are available in <ref type="bibr" target="#b15">[Bourgaux et al., 2020]</ref>.</p><p>2 Provenance for ELH r</p><p>We first introduce our framework for provenance for ELH r ontology and discuss our design choices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Basic Notions</head><p>In the database setting, commutative semirings have proven to be convenient for representing various kinds of provenance information <ref type="bibr" target="#b34">[Green et al., 2007;</ref><ref type="bibr" target="#b32">Green and Tannen, 2017]</ref>. In a commutative semiring (K, +, ×, 0, 1), the product × and the addition + are commutative and associative binary operators over K, and × distributes over +. Given a countably infinite set N V of variables that are used to annotate the database tuples, a provenance semiring is a semiring over a space of annotations, or provenance expressions, with variables from N V . Green and Tannen present a hierarchy of expressiveness for provenance annotations <ref type="bibr">[2017]</ref>. The most expressive form of annotations is provided by the provenance polynomials semiring N[N V ] = (N[N V ], +, ×, 0, 1) of polynomials with coefficients from N and variables from N V , and the usual operations. The semiring N[N V ] is universal, i.e., for any other commutative semiring K = (K, +, ×, 0, 1), any function ν : N V → K can be extended to a semiring homomorphism h : N[N V ] → K, allowing the computations for K to factor through the computations for N[N V ] <ref type="bibr">[Green, 2011]</ref>. Hence, provenance polynomials provide the most informative provenance annotations and correspond to so-called how-provenance <ref type="bibr" target="#b24">[Cheney et al., 2009]</ref>. Less general provenance semirings are obtained by restricting the operations + and × to idempotence and/or absorption <ref type="bibr" target="#b32">[Green and Tannen, 2017]</ref>. In this work, we focus on ×-idempotent semirings, i.e., for every v ∈ K, v × v = v. This corresponds to the Trio semiring Trio(N V ), defined in <ref type="bibr">[Green, 2011]</ref> as the quotient semiring of N[N V ] by the equivalence kernel ≈ trio of the function trio :</p><formula xml:id="formula_1">N[N V ] → N[N V ]</formula><p>that "drops exponents." An annotation is a polynomial p that is understood to represent its equivalence class p/≈ trio . Trio(N V ) encompasses in the hierarchy the well-known why-provenance semiring Why(N V ) obtained by restricting + to be idempotent as well, where an annotation corresponds to the set of sets of tuples used to derive the result <ref type="bibr" target="#b24">[Cheney et al., 2009]</ref>. We use the following notation. A monomial is a finite product of variables in N V . Let N M be the set of monomials, and N P the set of all finite sums of monomials, i.e., N P contains polynomials of the form 1≤i≤n 1≤ji≤mi v i,ji , with v i,ji ∈ N V ; n, m i &gt; 0. By distributivity, every polynomial can be written into this form. The representative <ref type="bibr">[m]</ref> of a monomial m is the product of the variables occuring in m, in lexicographic order. Two monomials which are equivalent w.r.t. ≈ trio (i.e. are syntactically equal modulo commutativity, associativity and ×-idempotency) have the same representative, e.g., v × u and u</p><formula xml:id="formula_2">× v × u have representative u × v. N [M] denotes the set {[m] | m ∈ N M }.</formula><p>As ontology language we use a syntactic restriction of ELH r . Consider three mutually disjoint countable sets of concept-N C , role-N R , and individual names N I , disjoint from N V . ELH r general concept inclusions (GCIs) are expressions of the form C D, built according to the grammar rules</p><formula xml:id="formula_3">C ::= A | ∃R.C | C C | D ::= A | ∃R,</formula><p>where R ∈ N R , A ∈ N C . Role inclusions (RIs) and range restrictions (RRs) are expressions of the form R S and ran(R) A, respectively, with R, S ∈ N R and A ∈ N C . An assertion is an expression of the form A(a) or R(a, b), with A ∈ N C , R ∈ N R , and a, b ∈ N I . An axiom is a GCI, RI, RR, or assertion. An ELH r ontology is a finite set of ELH r axioms. ELH r usually allows GCIs of the form C C, but these can be translated into our format by exhaustively applying the rules:</p><formula xml:id="formula_4">(i) replace C C 1 C 2 by C C 1 and C C 2 , (ii) replace C 1 ∃R.C 2 by C 1 ∃S, S R and ran(S)</formula><p>C 2 where S is a fresh role name. The reason for syntactically restricting ELH r is that conjunctions or qualified restrictions of a role on the right-hand side of GCIs lead to counter-intuitive behavior when adding provenance annotations. We discuss this later in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Annotated Ontologies</head><p>Provenance information is stored as annotations. An annotated axiom has the form (α, m) with α an axiom and m ∈ N M . An annotated ELH r ontology O is a finite set of annotated ELH r axioms of the form (α, v) with v ∈ N V ∪ {1}. We denote by ind(O) the set of individual names occurring in O.</p><p>The semantics of annotated ontologies extends the classical notion of interpretations to track provenance. An annotated interpretation is a triple I = (∆ I , ∆ I m , • I ) where ∆ I , ∆ I m are non-empty disjoint sets (the domain and domain of monomials of I, respectively), and</p><formula xml:id="formula_5">• I maps • every a ∈ N I to a I ∈ ∆ I ; • every A ∈ N C to A I ⊆ ∆ I × ∆ I m ; • every R ∈ N R to R I ⊆ ∆ I × ∆ I × ∆ I m ; and • every m, n ∈ N M to m I , n I ∈ ∆ I m s.t. m I = n I iff m ≈ trio n. 1</formula><p>We extend • I to complex ELH r expressions as usual:</p><formula xml:id="formula_6">( ) I = ∆ I × {1 I }; (∃R) I = {(d, m I ) | ∃e ∈ ∆ I s.t. (d, e, m I ) ∈ R I }; (C D) I = {(d, (m × n) I ) | (d, m I ) ∈ C I , (d, n I ) ∈ D I }; (ran(R)) I = {(e, m I ) | ∃d ∈ ∆ I s.t. (d, e, m I ) ∈ R I }; (∃R.C) I = {(d, (m × n) I ) | ∃e ∈ ∆ I s.t. (d, e, m I ) ∈ R I , (e, n I ) ∈ C I }.</formula><p>The annotated interpretation I satisfies:</p><formula xml:id="formula_7">(R S, m), if, for all n ∈ N M , (d, e, n I ) ∈ R I implies (d, e, (m × n) I ) ∈ S I ; (C D, m), if, for all n ∈ N M , (d, n I ) ∈ C I implies (d, (m × n) I ) ∈ D I ; (A(a), m), if (a I , m I ) ∈ A I ; and (R(a, b), m), if (a I , b I , m I ) ∈ R I . I is a model of the annotated ontology O, denoted I |= O, if it satisfies all annotated axioms in O. O entails (α, m), denoted O |= (α, m), if I |= (α, m) for every model I of O.</formula><p>Remark. While it may appear counter-intuitive at first sight that C I differs from (C C) I , this is in line with the intuition behind the provenance of a conjunction. In the database setting, the Trio-provenance of tuple (a) being an answer to query ∃yz.R(x, y) ∧ R(x, z) over {R(a, b), R(a, c)} is also different from that of (a) being an answer to ∃y.R(x, y).</p><p>Example 2 illustrates the semantics and some differences with the DL-Lite R case from <ref type="bibr" target="#b20">[Calvanese et al., 2019]</ref>. Example 2. Consider the following annotated ontology.</p><formula xml:id="formula_8">O = {(mayor(Venice, Orsoni), v 1 ), (predecessor(Brugnaro, Orsoni), v 2 ), (∃predecessor.Mayor Mayor, v 3 ), (ran(mayor) Mayor, v 4 )}. Let I be s.t. ∆ I = {Brugnaro, Orsoni, Venice}, ∆ I m = N [M]</formula><p>, individual names are interpreted by themselves, monomials by their representatives and</p><formula xml:id="formula_9">mayor I = {(Venice, Orsoni, v 1 )}, predecessor I = {(Brugnaro, Orsoni, v 2 )}, Mayor I = {(Orsoni, v 1 × v 4 ), (Brugnaro, v 1 × v 2 × v 3 × v 4 )}.</formula><p>I |= O by the semantics of annotated ELH r . Moreover, it can be verified that if</p><formula xml:id="formula_10">I |= (α, m), then O |= (α, m). Note that O entails (Mayor(Brugnaro), v 1 × v 2 × v 3 × v 4</formula><p>) whose provenance monomial contains v 1 and v 2 , witnessing that the two assertions of O have been used to derive Mayor(Brugnaro).</p><p>Combining two assertions to derive another one is not possible in DL-Lite R . The rewriting-based approach by Calvanese et al. cannot be applied here as ∃predecessor.Mayor Mayor leads to infinitely many rewritings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Discussion on Framework Restrictions</head><p>Example 2 shows that conjunction and qualified role restriction lead to a behavior different from DL-Lite R . They are also the reason for some features of our setting. First, the next example illustrates the ×-idempotency impact for the EL family.</p><formula xml:id="formula_11">Example 3. Let O = {(A B 1 , v 1 ), (A B 2 , v 2 ), (B 1 B 2 C, v 3 )}. If I is a model of O and (e, n I ) ∈ A I , then (e, (n × v 1 ) I ) ∈ B I 1 and (e, (n × v 2 ) I ) ∈ B I 2 so (e, (n × v 1 × n × v 2 ) I ) ∈ (B 1 B 2 ) I , i.e. (e, (n × v 1 × v 2 ) I ) ∈ (B 1 B 2 ) I by ×-idempotency, which implies (e, (n×v 1 ×v 2 × v 3 ) I ) ∈ C I . Thus O |= (A C, v 1 × v 2 × v 3 )</formula><p>. This intuitive entailment is lost if × is not idempotent. Indeed, assume that × is not idempotent and let I be the interpretation defined as follows (where ∆ I = {e} and ∆ I m contains all monomials with variables in lexicographic order).</p><formula xml:id="formula_12">A I ={(e, u)} B I 1 = {(e, u × v 1 )} B I 2 = {(e, u × v 2 )} C I ={(e, u × u × v 1 × v 2 × v 3 )}. I is a model of O such that I |= (A C, v 1 × v 2 × v 3 ).</formula><p>A downside of ×-idempotency is a loss of the expressive power of provenance, neglecting the number of times an axiom is used in a derivation.</p><formula xml:id="formula_13">Let O = {(A B, v 1 ), (B A, v 2 )}. With ×-idempotency, O |= (A B, v k 1 × v l 2 ) for k ≥ 1 and l ≥ 0 because for k, l ≥ 1, v k 1 ×v l 2 is interpreted by (v 1 ×v 2 ) I in any interpretation I. In contrast, if × is not idempotent, we only obtain O |= (A B, v k+1 1 × v k 2 ) for k ≥ 0 (in particular O |= (A B, v 1 × v 2 ))</formula><p>, which is a more informative result. Some useful semirings are not ×-idempotent; e.g. the Viterbi semiring ([0, 1] , max, ×, 0, 1), where × is the usual product over real numbers, which is applied for representing confidence scores. We limit ourselves to ×-idempotent semirings because we are interested in computing provenance not only for assertions or queries, but also for GCIs. In particular, when a non-annotated ontology entails the GCI C D, we want the annotated version of the ontology to entail (C D, m) for some monomial m. The non-idempotent case could be relevant when one is not concerned with provenance for GCI entailment, and is left as future work.</p><p>Many useful semirings are ×-idempotent. Examples of these are: the Boolean semiring, used for probabilistic query answering in databases; the security semiring, used to determine the minimal level of clearance required to get the consequence; and the fuzzy semiring which allows to determine the truth degree of the consequence (see e.g. <ref type="bibr" target="#b55">[Senellart, 2017]</ref> for details on these semirings and more examples).</p><p>Second, let us explain the restrictions on the form of the right-hand side of the GCIs. Example 4 illustrates the case of conjunctions. Qualified role restrictions lead to the same kind of behavior (they can be seen as implicit conjunctions). Example 4. Let O = {(A B C, v), (A(a), u)}. All the following interpretations which interpret a by itself and monomials by their representatives are models of O:</p><formula xml:id="formula_14">A I1 = {(a, u)}, B I1 = {(a, u × v)}, C I1 = {(a, u × v)} A I2 = {(a, u)}, B I2 = {(a, u)}, C I2 = {(a, v)} A I3 = {(a, u)}, B I3 = {(a, 1)}, C I3 = {(a, u × v)}</formula><p>Since the semantics does not provide a unique way to "split" the monomial u × v between the two elements of the conjunc- One could argue that it would be better to define the semantics so that only I 1 was a model of O in Example 4, instead of restricting the language as we do. We explain next why this is not so simple.</p><p>One In this case, we lose even basic entailments from annotated ABoxes; e.g., {(A(a), u), (B(a), v)} |= ((A B)(a), u × v). We also lose the entailment of the GCI from Example 3.</p><p>Hence, restricting the syntax to prevent conjunctions on the right and defining the semantics as usual in DLs seems to be the most natural way of handling provenance in DL languages with conjunction. Since EL ontologies are often already expressed in normal form, the main restriction in our language is the avoidance of qualified existential restrictions on the right-hand side.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Annotated Queries</head><p>Following <ref type="bibr" target="#b20">Calvanese et al. [2019]</ref>, we extend DL conjunctive queries with binary and ternary predicates, where the last term of the tuple is used for provenance information. Recall that by the semantics of annotated ontologies, tuples can only contain monomials. A Boolean conjunctive query (BCQ) q is a sentence ∃ x.ϕ( x, a), where ϕ is a conjunction of (unique) atoms of the form A(t 1 , t), R(t 1 , t 2 , t); t i is an individual name from a, or a variable from x; and t (the last term of the tuple) is a variable from x that does not occur anywhere else in q (Calvanese et al. call such a query standard). We use P ( t, t) to refer to an atom which is either A(t 1 , t) or R(t 1 , t 2 , t), and P ( t, t) ∈ q if P ( t, t) occurs in q.</p><p>A match of the BCQ q = ∃ x.ϕ( x, a) in the annotated interpretation I is a function π : x ∪ a → ∆ I ∪ ∆ I m , such that π(b) = b I for all b ∈ a, and π( t, t) ∈ P I for every P ( t, t) ∈ q, where π( t, t) is a shorthand for (π(t 1 ), π(t)) or (π(t 1 ), π(t 2 ), π(t)) depending on the arity of P . I satisfies the BCQ q, written I |= q, if there is a match of q in I. A BCQ q is entailed by an annotated ontology O, denoted O |= q, if every model of O satisfies q. For a BCQ q and an interpretation I, ν I (q) denotes the set of all matches of q in I. The provenance of q on I is the expression prov I (q) := π∈ν I (q) [ P ( t,t)∈q π -(t)]</p><p>where π(t) is the last element of the tuple π( t, t) ∈ P I ; and π -(t) is the only m ∈ N [M] s.t. m I = π(t). For p ∈ N P , we write p ⊆ prov I (q) if p is a sum of monomials and for each occurrence of a monomial in p we find an occurrence of its representative in prov I (q). I satisfies q with provenance p ∈ N P , denoted I |= (q, p), if I |= q and p ⊆ prov I (q). O |= (q, p), if O |= q and p ⊆ prov I (q), for all I |= O. We call (q, p) an annotated query.</p><p>Remark. When O contains only assertions (no GCIs, RIs, and RRs), we can compare the provenance annotations we obtain to the database case. Similarly to Trio-provenance, the sums of monomials distinguish different ways the query atoms can be mapped to annotated interpretations. For example, given O = {(R(a, b), v 1 ), (R(b, a), v 2 )} and query</p><formula xml:id="formula_15">q = ∃xytt .R(x, y, t) ∧ R(y, x, t ), it holds that O |= (q, v 1 × v 2 + v 1 × v 2 ). The provenance annotation v 1 × v 2 + v 1 × v 2</formula><p>distinguishes among two derivations using the same axioms, contrary to the why-provenance v 1 × v 2 . Note that given an axiom α and O that may contain GCIs, RIs, and RRs, the sum over all monomials m such that O |= (α, m) represents all possible derivations of α, in the why-provenance spirit.</p><p>The size |X| of an annotated ontology, a polynomial or a BCQ X is the length of the string representing X, where elements of N C , N R , N I and N V in X are of length one. We often omit 'annotated' and refer to 'ontologies,' 'queries,' 'assertions,' etc. when it is clear from the context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Reasoning with Annotated ELH r Ontologies</head><p>We present a completion algorithm for deriving basic entailments from an ELH r ontology. As usual with completion algorithms, we restrict to ontologies in normal form. The annotated ELH r ontology O is in normal form if for every GCI</p><formula xml:id="formula_16">(α, v) ∈ O, α is of the form A B, A A B, A ∃R, or ∃R.A B, with A, A ∈ N C ∪ { }, B ∈ N C .</formula><p>Every annotated ELH r ontology can be transformed, in polynomial time, into an ontology in normal form which entails the same axioms over the ontology signature, using the following rules where C, D / ∈ N C ∪ { } and A is a fresh concept name: Before describing the reasoning algorithm in detail, we present an important property of entailment; namely, that all entailment problems can be polynomially reduced to each other. This allows us to focus on only one problem. In particular, we focus on entailment of annotated assertions. Theorem 6. Let O be an annotated ontology, and (α, m) an annotated GCI, RR, or RI. One can construct in polynomial time an ontology O and an annotated assertion</p><formula xml:id="formula_17">NF 1 : (C D E, v) -→ ( D A, 1), (C A E, v) NF 2 : (∃R. C D, v) -→ ( C A, 1), (∃R.A D, v) NF 3 : ( C ∃R, v) -→ ( C A, 1), (A ∃R, v).</formula><formula xml:id="formula_18">(β, n) such that O |= (α, m) iff O |= (β, n). Conversely, if (α, m) is an if then (if Φ / ∈ O) CR 0 X ∈ N C ∪ N R ∪ { } occurs in O add Φ = (X X, 1) to O CR 1 (R 1 R 2 , m 1 ), (R 2 R 3 , m 2 ) ∈ O add Φ = (R 1 R 3 , [m 1 × m 2 ]) to O CR 2 (R S, m 1 ), (ran(S) A, m 2 ) ∈ O add Φ = (ran(R) A, [m 1 × m 2 ]) to O CR 3 (A ∃R, m 1 ), (R S, m 2 ) ∈ O add Φ = (A ∃S, [m 1 × m 2 ]) to O CR 4 (A B, m 1 ), (B C, m 2 ) ∈ O add Φ = (A C, [m 1 × m 2 ]) to O CR 5 (A B, m 1 ), (B ∃R, m 2 ) ∈ O add Φ = (A ∃R, [m 1 × m 2 ]) to O CR 6 (A B 1 , m 1 ), (A B 2 , m 2 ), (B 1 B 2 C, m 3 ) ∈ O add Φ = (A C, [m 1 × m 2 × m 3 ]) to O CR 7 (ran(R) B 1 , m 1 ), (ran(R) B 2 , m 2 ), (B 1 C 1 , m 3 ), (B 2 C 2 , m 4 ), (C 1 C 2 C, m 5 ) ∈ O add Φ = (ran(R) C, [m 1 × m 2 × m 3 × m 4 × m 5 ]) to O CR 8 (A B C, m 1 ), ( B, m 2 ) ∈ O add Φ = (A C, [m 1 × m 2 ]) to O CR 9 (A ∃S, m 1 ), (ran(S) B, m 2 ), (B C, m 3 ), (S R, m 4 ), (∃R.C D, m 5 ) ∈ O add Φ = (A D, [m 1 × m 2 × m 3 × m 4 × m 5 ]) to O CR 10 (A ∃R, m 1 ), ( B, m 2 ), (∃R.B C, m 3 ) ∈ O add Φ = (A C, [m 1 × m 2 × m 3 ]) to O CR 11 a ∈ ind(O) add Φ = ( (a), 1) to O CR 12 (R(a, b), m 1 ), (R S, m 2 ) ∈ O add Φ = (S(a, b), [m 1 × m 2 ]) to O CR 13 (A(a), m 1 ), (A B, m 2 ) ∈ O add Φ = (B(a), [m 1 × m 2 ]) to O CR 14 (A 1 (a), m 1 ), (A 2 (a), m 2 ), (A 1 A 2 B, m 3 ) ∈ O add Φ = (B(a), [m 1 × m 2 × m 3 ]) to O CR 15 (R(a, b), m 1 ), (A(b), m 2 ), (∃R.A B, m 3 ) ∈ O add Φ = (B(a), [m 1 × m 2 × m 3 ]) to O CR 16 (R(a, b), m 1 ), (ran(R) A, m 2 ) ∈ O add Φ = (A(b), [m 1 × m 2 ]) to O Table 1: Completion rules. A, . . . , D ∈ N C ∪ { }, R, S, Ri ∈ N R , m, mi ∈ N M .</formula><p>annotated concept (resp. role) assertion, one can construct in polynomial time an ontology O and two annotated concept</p><formula xml:id="formula_19">(resp. role) inclusions (β, n), (γ, n) such that O |= (α, m) iff O |= (β, n) or O |= (γ, n).</formula><p>We adapt the classical EL completion rules to handle annotated ELH r ontologies in normal form. The algorithm starts with the original ontology O, and extends it through an iterative application of the rules from Table <ref type="table">1</ref> until O becomes saturated; i.e., no more rules are applicable. We cannot use the rules of <ref type="bibr">[Baader et al., 2008a]</ref> which eliminate range restrictions by adding GCIs with qualified role restrictions on the right so we designed rules for ELH r .</p><p>A rule application may add axioms annotated with monomials, and other assertions ( (a), 1), which are not foreseen in the definition of annotated ontologies. Still, ×-idempotency ensures that all monomials have at most |O| factors. To show that the completion algorithm is sound and complete for deciding assertion entailment, we prove a stronger result. The k-saturation of O is the saturated ontology O k obtained from O through the completion algorithm restricted to monomials of length at most k. We show that O k suffices for deciding entailment of annotated assertions (α, m) where m is a monomial of length at most k. In general there is no need to interrupt the completion algorithm; the ontology saturated without restricting the monomial length can be used to decide all relevant entailments regardless of the length of the monomial. Using O k is merely an optimisation when one is only interested in a short monomial.</p><formula xml:id="formula_20">Theorem 7. If O k is the k-saturation of O, then 1. O k is computable</formula><p>While the polynomial time upper bound w.r.t. the ontology size is positive, and in line with the complexity of the EL family, the exponential time bound on the monomial size does not scale well for entailments with larger monomials. Recall that these bounds are based on the number of annotated axioms generated by the completion rules. The following example illustrates the potential exponential blow-up.</p><formula xml:id="formula_21">Example 9. Consider O = {(A A i , v i ), (A i B, u i ) | 0 ≤ i ≤ n} ∪ {(B A, u)}.</formula><p>If O is the result of applying the completion algorithm to O, then for every S ⊆ {1, . . . , n},</p><formula xml:id="formula_22">(B A, [u × Π i∈S u i × v i ]) ∈ O .</formula><p>Following <ref type="bibr" target="#b38">Hutschenreiter and Peñaloza [2017]</ref>, we can see the completion algorithm as an automaton. More precisely, given O and (α, m), we can construct a tree automaton A, whose states correspond exactly to all the elements in O k , such that (α, <ref type="bibr">[m]</ref>) ∈ O k iff A accepts at least one tree. Briefly, A is constructed by reading the rule applications backwards, allowing transitions from the consequence to the premises of the rule; see <ref type="bibr" target="#b38">[Hutschenreiter and Peñaloza, 2017]</ref> for details. The number of states in A is exactly the cardinality of O k and hence potentially exponential on k. However, the size of each state is bounded polynomially on k; the arity of the automaton is bounded by the maximum number of premises in a rule, in this case 5; and one can bound polynomially on k the number of different states that may appear in any successful run of A. Thus, A satisfies the conditions for a PSpace emptiness test <ref type="bibr">[Baader et al., 2008b]</ref>, which yields the following result. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Computing Relevant Provenance Variables</head><p>An interesting question is whether a given variable appears in the provenance of a query q; i.e., whether a given axiom occurs in some derivation of q. Formally, v ∈ N V is relevant for q (w.r.t. ontology O) iff ∃m ∈ N M s.t. O |= (q, v × m). For IQs and ELH r this problem can be solved in polynomial time, via an algorithm computing all the relevant variables for all queries of the form A(a), with a ∈ N I , A ∈ N C . We modify the completion algorithm (Section 3) to combine all monomials from a derivation, instead of storing them separately.</p><p>As in Section 3, the algorithm assumes normal form and keeps as data structure a set S of annotated axioms (α, m), where α uses the vocabulary of O, and m ∈ N M . S is initialised as the original ontology where annotations of the same axiom are merged into a single monomial:</p><formula xml:id="formula_23">S := {(α, [Π v∈Vα v]) | (α, u) ∈ O, V α = {v | (α, v) ∈ O}},</formula><p>and extended by exhaustively applying the rules in Table <ref type="table">1</ref>, where rule applications change S into </p><formula xml:id="formula_24">S (α, m) := S ∪ {(α, m)} if there is no (α, n) ∈ S S \ {(α, n)} ∪ {(α, [m × n])} if (α, n) ∈ S; i.e.,</formula><formula xml:id="formula_25">= {(A A, m), (B B, m), (A B, m), (B A, m)} ∪ {(A i B, m), (B A i , m), (A i A, m), (A A i , m) | (1 ≤ i ≤ n} ∪ {(A i A j , m) | 1 ≤ i, j ≤ n} with m = u × Π n i=1 u i × Π n i=1 v i .</formula><p>Each rule application either adds a new axiom, or adds to the label of an existing axiom more variables. As the number of concept and role names, and variables appearing in S is linear on O, at most polynomially many rules are applied, each requiring polynomial time; i.e, the algorithm is polynomial.</p><p>Lemma 13. If S is the saturated set obtained from O, a ∈ N I , A ∈ N C , and v ∈ N V , then v is relevant for A(a) iff v occurs in m for some (A(a), m) ∈ S.</p><p>The algorithm decides relevance for assertion entailment in ELH r , yielding a polynomial-time upper bound for this problem. As in Section 3, axioms and IQs can be handled in polynomial time as well.</p><p>Theorem 14. Relevance for axiom and IQ entailment in ELH r can be decided in polynomial time.</p><p>This result shows that if we only need to know which axioms are used to derive an axiom or an IQ, the complexity is the same as reasoning in ELH r without provenance. This contrasts with axiom pinpointing : the task of finding the axioms responsible for a consequence to follow, in the sense of belonging to some minimal subontology entailing it (a MinA). Deciding whether an axiom belongs to a MinA is NP-hard for Horn-EL <ref type="bibr" target="#b48">[Peñaloza and Sertkaya, 2010]</ref>. Relevance is easier in our context since provenance does not require minimality: if O = {(A B, v 1 ), (B C, v 2 ), (C B, v 3 )}, v 2 and v 3 are relevant for A B, but the only MinA is {A B} so other axioms are not relevant for axiom pinpointing.</p><p>Provenance relevance is related to lean kernels (LKs) <ref type="bibr" target="#b50">[Peñaloza et al., 2017]</ref>, which approximate the union of Mi-nAs. The LK of a consequence c is the set of axioms appearing in at least one proof of c in a given inference method, generalizing the notion from propositional logic, where an LK is the set of clauses appearing in a resolution proof for unsatisfiability. The sets of variables computed by our algorithm are the sets of axioms used in the derivations by the completion algorithm, which is a consequence-based method for ELH r . Thus they correspond to LKs for the associated axioms and our algorithm is an alternative way of computing LKs in ELH r .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Query Answering with Provenance</head><p>Even if ELH r is expressive enough to reduce entailment of rooted tree-shaped BCQs to assertion entailment, the methods presented in Section 3 do not apply to other kinds of BCQs. Example 15. For O={(R(a, a), u 1 ), (A(a), u 2 ), (A ∃R, v 1 ), (ran(R) A, v 2 )} and q = ∃xyztt t .R(x, x, t)∧R(x, y, t )∧ R(z, y, t ), O |= (q, u 1 ) but O |= (q, u 2 × v 1 × v 2 ): O has a model I with R I = {(a, a, u 1 ), (a, b 1 , u 2 × v 1 ), (a, c 1 , u</p><formula xml:id="formula_26">1 × v 1 × v 2 )} ∪ {(b i , b i+1 , u 2 × v 1 × v 2 ) | i ≥ 1} ∪ {(c i , c i+1 , u 1 × v 1 × v 2 ) | i ≥ 1}.</formula><p>We adapt the combined approach by <ref type="bibr" target="#b46">Lutz et al. [2009]</ref> to trace provenance. Assume that queries contain only individual names occurring in the ontology O. The combined approach builds a canonical model for O and shows that every query q can be rewritten into a query q * that holds in this canonical model iff O |= q. We first define the canonical model </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>tion, O |= (B(a), m) for any m ∈ N M , and in particular, O |= (B(a), u × v). It is arguably counter-intuitive since we intuitively know that a is in A with provenance u and that A is a subclass of the intersection of B and C with provenance v. Partially normalizing the ontology before annotating it, or more specifically, replacing e.g. annotated GCIs of the form (C C 1 C 2 , v) by (C C 1 , v) and (C C 2 , v), may be acceptable in most cases, even if the rewritten ontology leads to additional-arguably natural-consequences compared to the original one. For instance, even if O |= (A B, v) in Example 4, in many cases a user would accept to change the GCI of O to (A B, v) and (A C, v) as it may reflect the original intention of the GCI since {A B, A C} and A B C are semantically equivalent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>possibility is to change the definition of satisfaction of a GCI by an interpretation such that I |= (A B C, m) iff for every (d, n I ) ∈ A I , then (d, (m × n) I ) ∈ B I and (d, (m × n) I ) ∈ C I , and similarly for qualified role restrictions. This approach leads to a counter-intuitive behavior. For instance if O = {(A(a), u), (B(a), v)}, then O |= (A B A B, 1), since (a, (u × v) I ) ∈ (A B) I for every model I of O, but there is a model I of O such that (a, (u × v) I ) / ∈ A I (and (a, (u × v) I ) / ∈ B I ). In contrast, our definition of satisfaction ensures that for every interpretation I and concept C, I |= (C C, 1). Another possibility is to modify the interpretation of conjunctions and qualified role restrictions such that (C D) I = {(d, m I ) | (d, m I ) ∈ C I , (d, m I ) ∈ D I } and (∃R.C) I = {(d, m I ) | ∃e ∈ ∆ I s.t. (d, e, m I ) ∈ R I , (e, m I ) ∈ C I }.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 5 .</head><label>5</label><figDesc>Let O be an annotated ELH r ontology, α an axiom, and m a monomial. Let O be obtained by applying exhaustively Rules NF 1 -NF 3 to O. • If O |= (α, m), then O |= (α, m). • If O |= (α, m) and every concept name occurring in α occurs in O, then O |= (α, m).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>in polynomial time w.r.t. the size of O, and in exponential time w.r.t. k, 2. for every assertion α and monomial m k with at most k variables, O |= (α, m k ) iff (α, [m k ]) ∈ O k . This theorem states that to decide whether an assertion (α, m) is entailed by O, one just needs to find the k-saturation of O, where k is the number of variables in m, and then check whether (α, [m]) ∈ O k . Due to the first point of Theorem 7 and Theorem 6, we obtain the following corollary. Corollary 8. For every axiom α, O |= (α, m) is decidable in polynomial time in |O| and in exponential time in |m|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Proposition 10 .</head><label>10</label><figDesc>For every axiom α, O |= (α, m) is decidable in polynomial space in |m|. Interestingly, these results allow us to bound the full complexity of answering instance queries (IQ) of the form C(a) where C is an ELH r concept and a ∈ N I . Theorem 11. Let O be an ontology, C(a) an IQ and m ∈ N M . O |= (C(a), m) is decidable in polynomial time in |O| and |C(a)|, and polynomial space in |m|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>I O of an ontology O annotated with provenance information. Assume that O is in normal form; mon(O) denotes the set of monomial representatives built using variables of N V occurring in O, and rol(O) is the set of role names occurring in O. Also assume that ( * ) if there is B ∈ N C , R ∈ N R , and n ∈ N M such that O |= (ran(R) B, n), then (ran(R) B, [n]) ∈ O. This simplifies the presentation of the construction of the canonical model. Let aux(O) := {d m R | R ∈ rol(O), m ∈ mon(O)}. Assume that ind(O) ∩ aux(O) = ∅. We define the domain of I O and the domain of monomials of I O as follows:∆ I O := ind(O) • ∪ aux(O) ∆ I O m := N [M]We define the interpretation function of I O as the union of• I i O , i ≥ 0. The function • I 0 O sets a I 0 O = a for all a ∈ ind(O) (for a ∈ N I \ ind(O) the mapping a I O is irrelevant), m I 0 O = [m]for all m ∈ N M , and for all A ∈ N C and all R ∈ N R ,A I 0 O := {(a, [m]) | O |= (A(a), m)} R I 0 O := {(a, b, [m]) | O |= (R(a, b), m)}. If I i O is defined, we define I i+1O by choosing an annotated axiom α ∈ O and applying one of the following rules in a fair way (i.e., every applicable rule is eventually applied).R1 α = (C A, m): if there is d ∈ ∆ I O and n ∈ mon(O) s.t. (d, [n]) ∈ C I i O , then add (d, [m × n]) to A I i O . R2 α = (C ∃R,m): if there is n ∈ mon(O), d ∈ ∆ I O s.t. (d, [n]) ∈ C I i O , then add (d, d [m×n] R , [m × n]) to R I i O .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>add the axiom α with an associated monomial if it does not yet appear in S, and modify the monomial associated to α to include new variables otherwise. To ensure termination, a rule is only applied if it modifies S. The rules are applied until no new rule is applicable; i.e., S is saturated.</figDesc><table /><note><p>Example 12. The relevance algorithm on the ontology of Example 9, yields the saturated set S</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>or iff m = n if we consider N[N V ] instead of Trio(N V )</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>This work was supported by <rs type="funder">Camille Bourgaux's CNRS</rs> <rs type="grantName">PEPS grant</rs>; contract <rs type="grantNumber">ANR-18-CE23-0003</rs> (CQFD); the <rs type="funder">University of Bergen</rs>; the <rs type="funder">Free University of Bozen-Bolzano</rs> projects <rs type="projectName">PROVDL</rs> and <rs type="projectName">FO2S</rs>; and the <rs type="funder">Italian PRIN project HOPE</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_J6msEUy">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="grant-name">PEPS grant</orgName>
				</org>
				<org type="funded-project" xml:id="_bdcfxg9">
					<orgName type="project" subtype="full">PROVDL</orgName>
				</org>
				<org type="funded-project" xml:id="_Rrc9ABa">
					<orgName type="project" subtype="full">FO2S</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We define the rewriting q * of a query q, closely following <ref type="bibr" target="#b46">Lutz et al. [2009]</ref>. It contains an additional predicate Aux, always interpreted as</p><p>be the smallest transitive relation over terms of q, term(q), that includes identity relation, and satisfies the closure condition</p><p>Clearly, the relation ∼ q is computable in polynomial time in the size of q. Define for any equivalence class χ of ∼ q , the set</p><p>We define the sets Cyc and Fork = whose main purpose in the translation is to prevent spurious matches (e.g., with cycles) of a query in the anonymous part of the canonical model.</p><p>• Fork = is the set of pairs (pre(χ), χ) with pre(χ) of cardinality at least two. • Cyc is the set of variables x in term(q) such that there are</p><p>1 for all i &lt; n, and t n 2 ∼ q t m 1 . Fork = , and Cyc can also be computed in polynomial time in the size of q. For each equivalence class χ of ∼ q , we choose a representative t χ ∈ χ. For q = ∃ x.ψ, the rewritten query q * is defined as ∃ x.(ψ ∧ ϕ 1 ∧ ϕ 2 ), where</p><p>, avoiding the R-loops in the anonymous part of I O to satisfy R(x, x, t). ϕ 2 enforces that if y is mapped in the anonymous part, then x and z are mapped to the same object, which avoids R-loops in the anonymous part of I O .</p><p>Our construction differs from the original rewriting of <ref type="bibr" target="#b46">Lutz et al. [2009]</ref>. In particular, in their rewriting there is a formula ϕ 3 , which is not necessary in our case. Intuitively, this is because we keep the information of the role name used to connect an element of aux(O) to the rest of the model. Theorem 19 establishes that q * is as required.</p><p>Theorem 19. Let O be an ontology in normal form and (q, p) be an annotated query. Then, O |= (q, p) iff I O |= (q * , p).</p><p>Although the domain of monomials is infinite, since only elements of mon(O) are relevant, an exponential size structure representing I O is sufficient to check whether I O |= (q * , p). The size of the resulting structure is exponential in |O| and can be constructed in exponential time using the completion algorithm (Theorem 7) to check entailment of assertions and RRs. Corollary 20. Let O be an ontology, q a BCQ and p ∈ N P . O |= (q, p) is decidable in exponential time in |O| + |(q, p)|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion and Conclusions</head><p>We study the problem of computing the provenance of an axiom or a BCQ entailment from ELH r ontologies. In particular, entailment of annotated axioms or IQs for a fixed monomial size is tractable, and the set of relevant provenance variables can be computed in polynomial time. For the more challenging problem of CQ answering, we adapt the combined approach.</p><p>Related work. Explaining inferences in DLs has been studied mostly focusing on explaining axiom entailment, in particular concept subsumption, through axiom pinpointing <ref type="bibr" target="#b54">[Schlobach and Cornet, 2003;</ref><ref type="bibr" target="#b42">Kalyanpur et al., 2007;</ref><ref type="bibr">Baader et al., 2007b]</ref>. Few approaches address query answer explanation for DL-Lite or existential rules <ref type="bibr" target="#b12">[Borgida et al., 2008;</ref><ref type="bibr" target="#b26">Croce and Lenzerini, 2018;</ref><ref type="bibr" target="#b22">Ceylan et al., 2019;</ref><ref type="bibr" target="#b10">Bienvenu et al., 2019]</ref>. However, current explanation services in DLs provide minimal explanations, which is crucially different to provenance, since provenance takes into account all derivations (cf. discussion in Section 4).</p><p>Closest to our work is provenance for OBDA <ref type="bibr" target="#b20">[Calvanese et al., 2019]</ref>. However, the challenges in enriching the EL family with provenance were not investigated. We also study additional problems such as axiom entailment and relevance. <ref type="bibr" target="#b28">Dannert and Grädel [2019]</ref> consider provenance in the DL ALC. The setting is not the same as ours since they only consider annotated assertions (not annotated GCIs), do not study BCQs, and the semantics is different as well. There are several proposals for handling provenance in RDF(S), most notably an algebraic deductive system for annotated RDFS <ref type="bibr" target="#b17">[Buneman and Kostylev, 2010]</ref>. The approach by <ref type="bibr" target="#b14">Bourgaux and Ozaki [2019]</ref> for attributed DL-Lite fundamentally differs by using GCIs and RIs to express constraints on provenance.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">if there are d, d I O , n ∈ mon(O) s.t</title>
		<author>
			<persName><forename type="first">R</forename></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Example 16</title>
		<author>
			<persName><forename type="first">O</forename><surname>S I I</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">For our running example, I O is as follows</title>
		<imprint/>
	</monogr>
	<note>References</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName><surname>Baader</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Pushing the EL envelope</title>
		<author>
			<persName><forename type="first">Franz</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><surname>Baader</surname></persName>
		</author>
		<title level="m">The Description Logic Handbook: Theory, Implementation, and Applications</title>
		<editor>
			<persName><forename type="first">Franz</forename><surname>Baader</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Deborah</forename><surname>Mcguinness</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Daniele</forename><surname>Nardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Peter</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Pinpointing in the description logic EL +</title>
		<author>
			<persName><surname>Baader</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
			<publisher>KI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Pushing the EL envelope further</title>
		<author>
			<persName><surname>Baader</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OWLED</title>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Automata can show PSpace results for description logics</title>
		<author>
			<persName><surname>Baader</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">206</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>Bienvenu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">First-Order Rewritability of Atomic Queries in Horn Description Logics</title>
		<author>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><surname>Bienvenu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Computing and explaining query answers over inconsistent DL-Lite knowledge bases</title>
		<author>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franc</forename><surname>¸ois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Goasdoué</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><surname>Borgida</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Explanation in the DL-Lite family of description logics</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Borgida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OTM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Querying attributed DL-Lite ontologies using provenance semirings</title>
		<author>
			<persName><forename type="first">Ozaki</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><surname>Ozaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><surname>Bourgaux</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Provenance for the description logic ELHr</title>
		<author>
			<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><surname>Ozaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Peñaloza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Livia</forename><surname>Predoiu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2001.07541</idno>
		<editor>Buneman and Kostylev</editor>
		<imprint>
			<date type="published" when="2010">2020. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Annotation algebras for RDFS data</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Egor</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SWPM@ISWC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName><surname>Buneman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The providence of provenance</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BNCOD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName><surname>Calvanese</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Enriching ontology-based data access with provenance</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><surname>Ozaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Peñaloza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ceylan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Explanations for query answers under existential rules</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>İsmail İlkan Ceylan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enrico</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrius</forename><surname>Malizia</surname></persName>
		</author>
		<author>
			<persName><surname>Vaicenavicius</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName><surname>Cheney</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Provenance in databases: Why, how, and where</title>
		<author>
			<persName><forename type="first">James</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laura</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Chiew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tan</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Databases</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Lenzerini</forename><surname>Croce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A framework for explaining query answers in DL-Lite</title>
		<author>
			<persName><forename type="first">Federico</forename><surname>Croce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EKAW</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Grädel</forename><surname>Dannert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Provenance analysis: A perspective for description logics? In Description Logic, Theory Combination, and All That</title>
		<author>
			<persName><forename type="first">M</forename><surname>Katrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erich</forename><surname>Dannert</surname></persName>
		</author>
		<author>
			<persName><surname>Grädel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><surname>Deutch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Circuits for datalog provenance</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Tannen</forename><surname>Green</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The semiring framework for database provenance</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName><surname>Green</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>PODS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName><surname>Green</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Containment of conjunctive queries on annotated relations</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Peñaloza</forename><surname>Hutschenreiter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">An automata view to goal-directed methods</title>
		<author>
			<persName><forename type="first">Lisa</forename><surname>Hutschenreiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Peñaloza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LATA</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ives</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">The ORCHESTRA collaborative data sharing system</title>
		<author>
			<persName><forename type="first">Zachary</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grigoris</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Partha</forename><forename type="middle">Pratim</forename><surname>Talukdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><forename type="middle">C N</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sigmod Record</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title/>
		<author>
			<persName><surname>Kalyanpur</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Finding all justifications of OWL DL entailments</title>
		<author>
			<persName><forename type="first">Aditya</forename><surname>Kalyanpur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bijan</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Horridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evren</forename><surname>Sirin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName><surname>Lukasiewicz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Answering ontological ranking queries based on subjective reports</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maria</forename><surname>Vanina Martínez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Molinaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Livia</forename><surname>Predoiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerardo</forename><forename type="middle">I</forename><surname>Simari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SUM</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title/>
		<author>
			<persName><surname>Lutz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Conjunctive query answering in the description logic EL using a relational database system</title>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Sertkaya</forename><surname>Peñaloza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">On the complexity of axiom pinpointing in the EL family of description logics</title>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Peñaloza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baris</forename><surname>Sertkaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KR</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title/>
		<author>
			<persName><surname>Peñaloza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Lean kernels in description logics</title>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Peñaloza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Mencía</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexey</forename><surname>Ignatiev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">João</forename><surname>Marques-Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ramusat</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Semiring provenance over graph databases</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TaPP</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Non-standard reasoning services for the debugging of description logic terminologies</title>
		<author>
			<persName><forename type="first">Cornet</forename><surname>Schlobach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Schlobach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Cornet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Pierre Senellart. Provenance and probabilities in relational databases</title>
		<author>
			<persName><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title/>
		<author>
			<persName><surname>Suciu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Probabilistic Databases. Synthesis Lectures on Data Management</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Morgan and Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title/>
		<author>
			<persName><surname>Zimmermann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">A general framework for representing, reasoning and querying with annotated semantic web data</title>
		<author>
			<persName><forename type="first">Antoine</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nuno</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Axel</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Umberto</forename><surname>Straccia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Sem</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
