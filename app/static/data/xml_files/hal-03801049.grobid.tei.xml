<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Capturing Homomorphism-Closed Decidable Queries with Existential Rules (Extended Abstract)</title>
				<funder ref="#_FERqm6h">
					<orgName type="full">Center for Perspicuous Systems)</orgName>
				</funder>
				<funder ref="#_2yzSgtY">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder>
					<orgName type="full">BMBF in the Center for Scalable Data Analytics and Artificial Intelligence</orgName>
				</funder>
				<funder ref="#_ESxzSwP">
					<orgName type="full">DFG</orgName>
				</funder>
				<funder>
					<orgName type="full">Center for Advancing Electronics Dresden</orgName>
				</funder>
				<funder ref="#_7TVFq6G">
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
							<email>camille.bourgaux@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<email>david.carral@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
							<email>markus.kroetzsch@tu-dresden.de</email>
							<affiliation key="aff2">
								<orgName type="institution">Technische Universität Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
							<email>sebastian.rudolph@tu-dresden.de</email>
							<affiliation key="aff2">
								<orgName type="institution">Technische Universität Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
							<email>michael.thomazo@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Capturing Homomorphism-Closed Decidable Queries with Existential Rules (Extended Abstract)</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">1EE2342C2C78181A6C29CAEE7CECBEF2</idno>
					<idno type="DOI">10.24963/ijcai.2022/733</idno>
					<note type="submission">Submitted on 6 Oct 2022</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>At the core of contemporary logic-based knowledge representation is the concept of querying data sources, often using elaborate query formalisms that allow for taking background knowledge into account. The classical decision problem related to such knowledge-aware querying is Boolean query entailment. From an abstract point of view, a Boolean query identifies a class of databases D -those that satisfy the query, i.e., to which the query "matches". This view allows us to define and investigate properties of (abstract) queries independently from the syntax used to specify them. Such properties can be structural (morphisms, closure properties) or computational <ref type="bibr">(decidability, complexity)</ref>.</p><p>A very popular querying formalism are existential rules, also referred to as tuple-generating dependencies. It is straightforward that the class of databases satisfying some existential rule query is closed under homomorphisms and recursively enumerable. Conversely, it was established that every homomorphism-closed query that is recursively enumerable can be expressed using existential rules <ref type="bibr" target="#b28">[Rudolph and Thomazo, 2015]</ref>. That is, plain existential rules already realize their full potential; further syntactic extensions within these boundaries do not enhance expressivity.</p><p>For questions related to automated deduction, however, decidability rather than recursive enumerability is of central interest. The crucial question we tackle in this paper is thus: Can we characterize an existential rules fragment capable of expressing every decidable homomorphism-closed query?</p><p>The generic computational paradigm for existential rules, the chase <ref type="bibr" target="#b10">[Beeri and Vardi, 1984]</ref>, is based on repetitive, forwardchaining rule application, starting from the database. As this may cause the iterated introduction of new domain elements, this procedure is not guaranteed to terminate -yet, termination is a crucial criterion for decidability. The chase comes in several variants, mainly differing in their (increasingly thorough) mechanisms to prevent unnecessary rule applications: While the Skolem chase <ref type="bibr" target="#b26">[Marnette, 2009]</ref> essentially just avoids duplicate rule applications, the standard <ref type="bibr" target="#b21">[Fagin et al., 2005]</ref> and the core chase <ref type="bibr" target="#b19">[Deutsch et al., 2008]</ref> check for redundancy on a local and global level, respectively.</p><p>The class of existential rule sets with terminating<ref type="foot" target="#foot_0">1</ref> Skolem chase has already been weighed and found wanting: it only comprises those queries that are already expressible in plain Datalog -and hence can be evaluated in polynomial time <ref type="bibr" target="#b26">[Marnette, 2009;</ref><ref type="bibr" target="#b24">Krötzsch and Rudolph, 2011;</ref><ref type="bibr" target="#b31">Zhang et al., 2015]</ref>. For the standard-chase-terminating and the core-chase-terminating existential rules classes, on the other hand, we only know that the former is contained in the latter <ref type="bibr" target="#b23">[Grahne and Onet, 2018]</ref>, but little more than that <ref type="bibr" target="#b25">[Krötzsch et al., 2019]</ref>. In this paper, we clarify the situation significantly by showing the following: Standard-chase-terminating existential rules capture the class of all decidable homomorphism-closed queries.</p><p>Notably, this implies that standard-chase-terminating and core-chase-terminating existential rule queries are equally expressive and no decidable enhancement of this formalism that preserves homomorphism-closedness (e.g. by allowing disjunction in rule heads) can be strictly more expressive.</p><p>As a downside, the existential rules fragment thus identified is not even semi-decidable, that is, one cannot semi-decide whether a set of rules is universally terminating for the standard chase. We show that this downside is unavoidable: There are no semi-decidable query languages that (i) express all decidable, homomorphism-closed queries and (ii) for which query answering is decidable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We first briefly introduce the notions we need in this paper. Rules We consider first-order formulas over countably infinite sets Vars of variables and Preds of predicates, where each p ∈ Preds has an arity Ar (p) ≥ 0. An atom is an expression p( x) with p ∈ Preds and x a list of variables of length Ar (p). The fragment of disjunctive existential rules consists of formulas of the form:</p><formula xml:id="formula_0">∀ x. β[ x] → k i=1 ∃ y i .η i [ x i , y i ] ,<label>(1)</label></formula><p>where β[ x] and η i [ x i , y i ] (i = 1, . . . , k) are conjunctions of atoms with variables x and x i ∪ y i , respectively. We call β body and k i=1 ∃ y i .η i head. Bodies can be empty, but heads must be non-empty. We require that x and y i are mutually disjoint and that x i ⊆ x for all i = 1, . . . , k. We single out the fragment of existential rules by disallowing disjunction, i.e. requiring k = 1, and Datalog rules by disallowing existential quantifiers. We omit the universal quantifiers from rules. Databases, Interpretations, and Entailment The semantics of formulas is based on interpretations, defined as relational structures over a countably infinite set Nulls of nulls. A schema S is a finite set of predicates. An interpretation I over S is a set of expressions p( n) with p ∈ S and n a list of nulls of length Ar (p). A database is a finite interpretation.</p><p>A homomorphism h : I 1 → I 2 between interpretations I 1 and I 2 is a mapping h from the nulls in I 1 to the nulls in</p><formula xml:id="formula_1">I 2 , such that p( n) ∈ I 1 implies p(h( n)) ∈ I 2 .</formula><p>A substitution σ is a mapping from variables to nulls. A rule ρ as in (1) is satisfied by interpretation I if every substitution σ : x → Nulls with σ(β) ⊆ I can be extended to σ : x ∪ y i → Nulls for some i ∈ {1, . . . , k} such that σ (η i ) ⊆ I. Otherwise, if σ(β) ⊆ I but no extension σ of σ verifies σ (η i ) ⊆ I for some i, then ρ, σ is applicable to I.</p><p>An interpretation I satisfies a set Σ of rules if it satisfies every rule in Σ. An interpretation J is satisfied by an interpretation I if there is a homomorphism h : J → I. I is a model of a rule/rule set/interpretation/database X if X is satisfied by I, written I |= X . As usual, we also write X |= Y if every model of X is a model of Y, where X and Y might be rules, rule sets, databases, or lists of several such elements. Note that the semantics of a database D in this context corresponds to the semantics of a Boolean conjunctive query ∃ x. {p(x n1 , . . . , x n ) | p(n 1 , . . . , n ) ∈ D} -we will therefore not introduce such queries as a separate notion. Also note that entailment and satisfaction between interpretations/databases coincide. Abstract Queries, Expressivity, and Decidability An (abstract) query Q over a schema S is a set of databases over S that is closed under isomorphism, i.e., such that whenever D ∈ Q and D is obtained from D by bijective renaming of nulls, then D ∈ Q. The query Q is further closed under homomorphisms if, for all D ∈ Q and all homomorphisms h : D → D , we have D ∈ Q. Definition 1. Let Goal be a nullary predicate. A query Q over S is expressed by a set Σ of rules if, for every database D over S, we have D ∈ Q if and only if Σ, D |= Goal.</p><p>To discuss decidability of queries, we need to see databases as Turing machine (TM) inputs over a fixed alphabet. A serialisation for a schema S is a word s ∈ ({0, 1, } ∪ S) * of the form e 1 • • • e n where n ≥ 0 and e i = p i w i1 • • • w iAr (pi) for w ij ∈ {0, 1} + and p i ∈ S. Given s of this form and an injection η : {0, 1} + → Nulls, let η(s) denote the database {p i (η(w i1 ), . . . , η(w iAr (pi) )) | 1 ≤ i ≤ n}. Then s corresponds to a database D if η(s) is isomorphic to D; note that this does not depend on the choice of η.</p><p>A query Q with schema S is decidable if the set of all serialisations for S that correspond to some D ∈ Q is decidable. Universal Models and the Chase Entailment of databases (corresponding to Boolean conjunctive queries) can be decided by considering only a subset of all models. Given sets I and K of interpretations, I is universal for K if, for all K ∈ K, there is I ∈ I and a homomorphism I → K. Universal model sets can be computed with the chase algorithm. We consider a variation of the standard (or restricted) chase for rules with disjunctions <ref type="bibr" target="#b17">[Carral et al., 2017]</ref>. Definition 2. A chase tree for Σ and D is a (finite or infinite) tree where each node is labelled by a database, such that:</p><p>1. The root is labelled with D.</p><p>2. For every node with label E that has children labelled C 1 , . . . , C , there is a rule ρ ∈ Σ and a substitution σ :</p><p>x → Nulls such that (i) ρ, σ is applicable to E, (ii) ρ has head disjuncts, and (iii)</p><formula xml:id="formula_2">C i = E ∪ σ i (η i )</formula><p>where σ i extends σ by mapping each y ∈ y i to a fresh null. 3. For each ρ ∈ Σ and σ, there is i ≥ 1 such that ρ, σ is not applicable to the label of any node of depth ≥ i. The result that corresponds to a chase tree is the set of all interpretations that can be obtained as the union of all interpretations along a path in the tree.</p><p>Point (3) ensures fair rule application, but different orders of application can lead to different chase trees, and different results. Nevertheless, every result is semantically correct: Fact 2. Every result of a chase on a rule set Σ and database D is a universal model set for Σ and D.</p><p>The pair Σ, D is chase-terminating if all its chase trees are finite; this corresponds to all-strategy termination. Σ is chase-terminating if Σ, D is chase-terminating for every database D; this corresponds to universal termination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Main Results</head><p>We are now ready to state the main results of the paper.</p><p>Capturing Decidable Homomorphism-Closed Queries Given a homomorphism-closed query Q over signature S, and a Turing machine M Q that decides Q, we describe in the next section how to construct a set of standard-chaseterminating existential rules Σ that expresses Q. Theorem 3. Chase-terminating existential rules capture the class of all decidable homomorphism-closed queries. Limitations of Semi-Decidable Languages A query language F over a schema S is a function from a set L to 2 D S , where D S is the set of all databases over schema S. We say that F is semi-decidable if membership to L is semidecidable, and that its query answering problem is decidable if there exists a TM M F that takes as input some (l, D) ∈ (L × D S ) and decides whether D ∈ F(l).</p><p>The set of chase-terminating existential rule sets is a query language that is not semi-decidable <ref type="bibr" target="#b23">[Grahne and Onet, 2018]</ref> and for which the query answering problem is decidable (by running the chase). In fact, we show that one cannot find a semi-decidable query language with similar properties. Theorem 4. There are no semi-decidable query languages that (i) express all decidable, homomorphism-closed queries and (ii) for which query answering is decidable.</p><p>To show this result, we define a set M of TMs (intuitively, M is the set of all deciders that solve homomorphism-closed queries over databases in D {ed} ), show that M can be enumerated up to equivalence if there is a semi-decidable language that satisfies (i) and (ii) above, and finally prove that M is not enumerable up to equivalence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Construction for Theorem 3</head><p>In this section we explain how we construct the standardchase-terminating existential rules Σ that expresses the homomorphism-closed query Q to prove Theorem 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overview</head><p>The construction works in three steps:</p><p>1. express Q with a set of disjunctive existential rules a TM M Q deciding Q. Disjunction is actually used in a very light way: It is only used to guess an ordering on the database elements, and to guess which atoms are not present in D.</p><p>2. We ensure termination of the standard chase by modifying our rule set. Known syntactic criteria to ensure termination come with an upper bound on the length of the chase (possibly exponential) and are thus not applicable in our setting, as M Q may take arbitrarily long to halt. We thus adapt the "emergency brake" technique <ref type="bibr" target="#b25">[Krötzsch et al., 2019]</ref> by casting it as a general rule set transformation, and apply it by detecting the situations in which the previous rule set leads to non-termination. This essentially happens when the "linear order" relation that is guessed contains cycles.</p><p>3. Finally, we remove disjunction by noticing that the rule set has a specific shape, in which all disjunctive rules are Datalog rules that can be applied before any existential rules. For such a rule set, we adapt another technique by</p><formula xml:id="formula_3">→ ∃y.First(y) ∧ DbDom(y) (2) → ∃z.Last(z) ∧ DbDom(z) (3) p( x) → In p ( x) ∧ x∈ x DbDom(x) (4) DbDom(x) → Eq(x, x) (5) Eq(x, y) → Eq(y, x) (6) NEq(x, y) → NEq(y, x) (7) R( x) ∧ Eq(x i , y) → R( x xi →y ) (8) DbDom(x) ∧ DbDom(y) → Eq(x, y) ∨ NEq(x, y) (9) LT(x, y) ∧ LT(y, z) → LT(x, z) (10) First(x) ∧ NEq(x, y) → LT(x, y) (11) NEq(x, y) ∧ Last(y) → LT(x, y) (12) NEq(x, y) → LT(x, y) ∨ LT(y, x) (13) x∈ x DbDom(x) → In p ( x) ∨ NIn p ( x)<label>(14)</label></formula><p>Figure <ref type="figure">1</ref>: The rule set R1, where rules ( <ref type="formula">4</ref>) and ( <ref type="formula" target="#formula_3">14</ref>) are instantiated for each p ∈ S, and rules ( <ref type="formula">8</ref>) are instantiated for each R ∈ {First, Last, Eq, NEq, LT} ∪ {Inp, NInp | p ∈ S} and 1 ≤ i ≤ Ar (R), and xx i →y denotes x with xi replaced by y.</p><formula xml:id="formula_4">First(x) → ∃u.Root(u) ∧ Rep(x, u) (15) Rep(x, v) ∧ LT(x, z) → ∃w.Chi(v, w) ∧ Rep(z, w) (16) Last(x) ∧ Rep(x, u) → Leaf(u) (17) Rep(x, u) ∧ Eq(x, y) → Rep(y, u)<label>(18)</label></formula><formula xml:id="formula_5">In p ( x) ∧ | x| i=1 Rep(x i , u i ) → In p ( u)<label>(19)</label></formula><formula xml:id="formula_6">NIn p ( x) ∧ | x| i=1 Rep(x i , u i ) → NIn p ( u)<label>(20)</label></formula><p>Figure <ref type="figure">2</ref>: The rule set R2 contains R1 (see Figure <ref type="figure">1</ref>) and all above rules, where ( <ref type="formula" target="#formula_5">19</ref>) and ( <ref type="formula" target="#formula_6">20</ref>) are instantiated for each p ∈ S. <ref type="bibr" target="#b25">Krötzsch et al. [2019]</ref> to create an equivalent set of nondisjunctive existential rules: It builds all possible worlds corresponding to choices made by disjunctive Datalog rules, simulates the application of non-disjunctive existential rules in each world independently, and aggregates the results from all worlds.</p><p>In the remaining of this section, we focus on the first step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Expressing Q with Disjunctive Rules</head><p>We build five rule sets</p><formula xml:id="formula_7">R 1 ⊆ R 2 ⊆ R 3 ⊆ R 4 ⊆ R 5 such that for any database D over S, there is a universal model set M of R 5 and D s.t. D ∈ Q iff Goal ∈ I for every I ∈ M.</formula><p>Intuitively, R 1 constructs all possible linear orders over the nulls in D, as well as all possible completions of D with facts built using these nulls; R 2 \ R 1 extracts successor relations from the linear orders; R 3 \ R 2 associates to nulls representations of their positions in successor relations; R 4 \ R 3 encodes all initial TM configurations corresponding to some linear order and completion; and R 5 \ R 4 simulates the run of the TM on these configurations. The two last steps being more standard (e.g. <ref type="bibr" target="#b6">[Abiteboul et al., 1995]</ref> and <ref type="bibr">[Baget et al., 2011a]</ref>), we focus on R 1 to R 3 (see Figures <ref type="figure">1</ref><ref type="figure">2</ref><ref type="figure">3</ref>).</p><p>Figure <ref type="figure">3</ref>: The rule set R3 contains R2 (Figure <ref type="figure">2</ref>) and all of the above rules, where ( <ref type="formula">27</ref>) and ( <ref type="formula">28</ref>) are instantiated for each * ∈ {0, 1}.</p><p>Guessing an Order and Completing the Database R 1 serves two distinct purposes: (1) predicates First, Last, Eq ("="), NEq (" ="), and LT ("&lt;") encode representations of possible linear orders over nulls in D (collected in predicate DbDom); and (2) predicates In p and NIn p for each p ∈ S explicitly encode positive and negative (absent) facts in D. Both purposes require disjunctive reasoning. Possible models include representations of strict, total linear orders (1) and the exact database completion (2), but also models for collapsed orders and inconsistent completions. The latter is not problematic since we consider homomorphism-closed queries.</p><p>Building a Tree Structure According to the Order The purpose of R 2 is to extract successor relations from the transitive linear order LT. It builds a tree structure -defined using predicates Root, Chi ("child"), and Leaf -where each path is a sequence of nulls representing a sequence of elements that respects the linear order LT. Unavoidably, some elements may be skipped in some sequences, but one path is complete, and it is the successor relation with respect to LT. Note that it may lead to non-termination of the restricted chase when the guessed LT contains a cycle. This problem is dealt with in the second part of the construction. Moreover, nulls are related via predicates In p and NIn p that reflect the relations for In p and NIn p that hold between the represented elements (in the database completion of the considered model I of R 1 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Creating a Binary Encoding of the Distance from the Root</head><p>The purpose of R 3 is to associate each node in the tree of R 2 with a binary encoding of its distance from the root (the root starts with "distance" 2 for technical reasons). Encodings start at the least significant bit and always end in 1 (i.e., have no leading 0s). To simplify upcoming steps, encodings take the form of little TM tapes, represented by a Nxt-connected chain of nulls with unary predicates S 0 and S 1 encoding the symbol at each position. Nodes u relate to the first and last null t s and t e of their "tape" through facts Enc(u, t s , t e ). Facts Cpy(a s , a e , b s , b e ) are used to create a tape between b s and b e that contains a copy of the information on the tape between a s and a e . Predicate Cpy +1 is analogous, but creates a representation of the successor of the number that is copied.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion and Conclusion</head><p>We characterized all decidable homomorphism-closed Boolean queries: These are exactly the chase-terminating existential rule queries, that is, queries that can be expressed by a set of (non-disjunctive) existential rules for which the standard chase universally terminates irrespective of the order of rule applications (as long as it is fair).</p><p>By its nature, our result immediately shows that various extensions of our framework do not increase its expressivity: Theorem 5. Chase-terminating existential rule queries have the same expressivity as 1. existential rule queries with guaranteed existence of some finite chase tree (for every database) 2. existential rule queries for which the chase terminates according to some fair strategy (such as datalog-first), 3. core-chase-terminating <ref type="bibr" target="#b19">[Deutsch et al., 2008]</ref> existential rule queries, 4. disjunctive chase-terminating existential rule queries. Moreover, our result also applies to query languages and querying formalisms of different types. An interesting example is the existential rules fragment of bounded treewidth sets (bts) of rules <ref type="bibr">[Baget et al., 2011a]</ref> that is not chaseterminating and encompasses many well-known existential rule fragments with decidable query entailment, including guarded <ref type="bibr" target="#b15">[Calì et al., 2008]</ref>, frontier-guarded <ref type="bibr">[Baget et al., 2011a]</ref>, and glut-guarded existential rules <ref type="bibr" target="#b24">[Krötzsch and Rudolph, 2011]</ref>, as well as greedy bts <ref type="bibr">[Baget et al., 2011b]</ref>: Theorem 6. Let Σ be a bounded-treewidth set of rules and Q a conjunctive query. There is a chase-terminating set Σ Q of existential rules such that D, Σ |= Q iff D, Σ Q |= Goal.</p><p>While possibly surprising, this is a consequence of decidability of conjunctive query entailment from bts and of homomorphism-closedness of existential rule queries. Note, however, that every Q would give rise to a different Σ Q . Asking for a "uniform" chase-terminating existential rules set Σ satisfying D, Σ |= Q iff D, Σ |= Q would change the game <ref type="bibr" target="#b31">[Zhang et al., 2015]</ref>. Such a set will not exist in all cases.</p><p>As we learned recently, <ref type="bibr" target="#b14">Cabibbo [1998]</ref> shows a result akin to Theorem 3 for monotonic queries and Horn logic with inequality. This is important prior work that nonetheless also has important differences, explaining why our proof required several new techniques. A detailed discussion is planned for future work. Another direction of future research is to look at complexity instead of expressivity. Indeed, even though several chase variants can express the same query, we believe that not all of them lead to worst-case optimal computations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Consider a rule set Σ and database D, and let M be the set of all models of Σ, D. Then I is a universal model set for Σ and D if I ⊆ M and I is universal for M. Fact 1. If I is a universal model set for Σ and D then, for every database C, we have Σ, D |= C iff I |= C for all I ∈ I.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We always mean universal termination, i.e., for every database.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>The authors thank <rs type="person">Jan van den Bussche</rs> for pointing them to the related work of Cabibbo [1998] during a discussion at ICDT conference 2022.</p><p>This work is partly supported by <rs type="funder">DFG</rs> in project number <rs type="grantNumber">389792660</rs> (<rs type="grantNumber">TRR 248</rs>, <rs type="funder">Center for Perspicuous Systems)</rs>, by <rs type="funder">BMBF in the Center for Scalable Data Analytics and Artificial Intelligence</rs> (ScaDS.AI), by the <rs type="funder">Center for Advancing Electronics Dresden</rs> (cfaed), by the <rs type="funder">ERC</rs> <rs type="grantName">Consolidator Grant</rs> <rs type="projectName">DeciGUT</rs> (project number <rs type="grantNumber">771779</rs>), and by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_ESxzSwP">
					<idno type="grant-number">389792660</idno>
				</org>
				<org type="funding" xml:id="_FERqm6h">
					<idno type="grant-number">TRR 248</idno>
				</org>
				<org type="funded-project" xml:id="_7TVFq6G">
					<idno type="grant-number">771779</idno>
					<orgName type="grant-name">Consolidator Grant</orgName>
					<orgName type="project" subtype="full">DeciGUT</orgName>
				</org>
				<org type="funded-project" xml:id="_2yzSgtY">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">y 2 .Enc(u, y 1 , y 2 ) ∧ S 0 (y 1 ) ∧ Nxt(y 1 , y 2 )</title>
	</analytic>
	<monogr>
		<title level="j">∧ S</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Enc(, y 1 , y ) ∧ Chi(u, v) → ∃z 1 , z .Enc(v, z 1 , z ) ∧ Cpy +1 (y 1</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Cpy +1 (y 1 , y 2 , z 1 , z ) ∧ S 0 (y 1 ) ∧ Nxt(y 1 , y 2 ) → S 1 (z 1 ) ∧ Nxt(z 1 , z ) ∧ S 1 (z )</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Cpy +1 (y 1 , y 2 , z 1 , z ) ∧ S 1 (y 1 ) ∧ Nxt(y 1 , y 2 ) → ∃z 2 .S 0 (z 1 ) ∧ Nxt(z 1 , z 2 ) ∧ S 0 (z 2 ) ∧ Nxt(z 2 , z ) ∧ S 1 (z ) (24) Cpy +1 (y 1 , y , z 1 , z ) ∧ S 0 (y 1 ) ∧ Nxt(y 1 , y 2 ) ∧ Nxt(y 2 , y 3 ) → ∃z 2 .Cpy(y 2 , y , z 2 , z ) ∧ S 1 (z 1 ) ∧ Nxt(z 1 , z 2 ) (25) Cpy +1 (y 1 , y , z 1 , z ) ∧ S 1 (y 1 ) ∧ Nxt(y 1 , y 2 ) ∧ Nxt(y 2 , y 3 ) → ∃z 2 .Cpy +1 (y 2 , y , z 2 , z ) ∧ S 0 (z 1 ) ∧ Nxt(z 1</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Cpy(y 1 , y 2 , z 1 , z 2 ) ∧ S * (y 1 ) ∧ Nxt(y 1 , y 2 ) → S * (z 1 ) ∧ Nxt(z 1 , z 2 )</title>
	</analytic>
	<monogr>
		<title level="j">∧ S</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Cpy(y 1 , y , z 1 , z ) ∧ S * (y 1 ) ∧ Nxt(y 1 , y 2 ) ∧ Nxt(y 2 , y 3 ) → ∃z 2 .Cpy(y 2 , y , z 2 , z ) ∧ S * (z 1 ) ∧ Nxt</title>
		<imprint/>
	</monogr>
	<note>28) References</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><surname>Abiteboul</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><surname>Baget</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Walking the complexity lines for generalized guarded existential rules</title>
		<author>
			<persName><surname>Baget</surname></persName>
		</author>
		<editor>Walsh</editor>
		<imprint>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Vardi</forename><surname>Beeri</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A proof procedure for data dependencies</title>
		<author>
			<persName><forename type="first">Catriel</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="718" to="741" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><surname>Bourgaux</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Capturing homomorphism-closed decidable queries with existential rules</title>
		<author>
			<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<editor>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gerhard</forename><surname>Lakemeyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Esra</forename><surname>Erdem</surname></persName>
		</editor>
		<meeting>the 18th International Conference on Principles of Knowledge Representation and Reasoning<address><addrLine>KR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The expressive power of stratified logic programs with value invention</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Cabibbo</surname></persName>
		</author>
		<author>
			<persName><surname>Cabibbo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="22" to="56" />
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName><surname>Calì</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Taming the infinite chase: Query answering under expressive relational constraints</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int. Conf. on Knowledge Representation and Reasoning (KR&apos;08)</title>
		<editor>
			<persName><forename type="first">Gerhard</forename><surname>Brewka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jérôme</forename><surname>Lang</surname></persName>
		</editor>
		<meeting>11th Int. Conf. on Knowledge Representation and Reasoning (KR&apos;08)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName><surname>Carral</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Restricted chase (non)termination for existential rules with disjunctions</title>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irina</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Carles Sierra, editor, Proc. 26th Int. Joint Conf. on Artificial Intelligence, IJCAI&apos;17</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="922" to="928" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><surname>Deutsch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The chase revisited</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th Symposium on Principles of Database Systems (PODS&apos;08)</title>
		<editor>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</editor>
		<meeting>27th Symposium on Principles of Database Systems (PODS&apos;08)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName><surname>Fagin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Renée</forename><forename type="middle">J</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucian</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Gösta Grahne and Adrian Onet</title>
		<author>
			<persName><forename type="first">Onet</forename><surname>Grahne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundam. Informaticae</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
	<note>Anatomy of the chase</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Extending decidable existential rules by joining acyclicity and guardedness</title>
		<author>
			<persName><forename type="first">Rudolph</forename><forename type="middle">;</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<editor>Walsh</editor>
		<imprint>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="page" from="963" to="968" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The power of the terminating chase</title>
		<author>
			<persName><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd Int. Conf. on Database Theory, ICDT&apos;19</title>
		<editor>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marco</forename><surname>Calautti</surname></persName>
		</editor>
		<meeting>22nd Int. Conf. on Database Theory, ICDT&apos;19</meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="3" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Generalized schemamappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Marnette</surname></persName>
		</author>
		<author>
			<persName><surname>Marnette</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m">Proc. 28th Symposium on Principles of Database Systems (PODS&apos;09)</title>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jianwen</forename><surname>Su</surname></persName>
		</editor>
		<meeting>28th Symposium on Principles of Database Systems (PODS&apos;09)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Characterization of the expressivity of existential rule queries</title>
		<author>
			<persName><forename type="first">Thomazo</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;15)</title>
		<editor>
			<persName><forename type="first">Qiang</forename><surname>Yang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><surname>Wooldridge</surname></persName>
		</editor>
		<meeting>24th Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;15)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="3193" to="3199" />
		</imprint>
	</monogr>
	<note>Sebastian Rudolph and Michaël Thomazo</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName><surname>Walsh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</author>
		<title level="m">Proc. 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;11). AAAI Press/IJCAI</title>
		<meeting>22nd Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;11). AAAI Press/IJCAI</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Existential rule languages with finite chase: Complexity and expressiveness</title>
		<author>
			<persName><forename type="first">Heng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jia-Huai</forename><surname>You</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th AAAI Conf. on Artificial Intelligence (AAAI&apos;15)</title>
		<editor>
			<persName><forename type="first">Blai</forename><surname>Bonet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sven</forename><surname>Koenig</surname></persName>
		</editor>
		<meeting>29th AAAI Conf. on Artificial Intelligence (AAAI&apos;15)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
