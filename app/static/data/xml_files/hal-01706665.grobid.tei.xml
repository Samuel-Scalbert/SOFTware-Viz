<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Wojciech</forename><surname>Kazana</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">ENS Cachan</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">ENS Cachan</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<address>
									<addrLine>or Eisenacher Strasse 2</addrLine>
									<postCode>94105, 10777</postCode>
									<settlement>Berlin</settlement>
									<region>CA</region>
									<country>USA, Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">FIRST-ORDER QUERIES ON CLASSES OF STRUCTURES WITH BOUNDED EXPANSION</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3AF0E2EAB2EBA5E539161ABAB1F310C1</idno>
					<idno type="DOI">10.23638/LMCS-16(1:25)2020</idno>
					<note type="submission">Preprint submitted to Logical Methods in Computer Science</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>enumeration</term>
					<term>first-order</term>
					<term>constant delay</term>
					<term>bounded expansion</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the evaluation of first-order queries over classes of databases with bounded expansion. The notion of bounded expansion is fairly broad and generalizes bounded degree, bounded treewidth and exclusion of at least one minor. It was known that over a class of databases with bounded expansion, first-order sentences could be evaluated in time linear in the size of the database. We give a different proof of this result. Moreover, we show that answers to first-order queries can be enumerated with constant delay after a linear time preprocessing. We also show that counting the number of answers to a query can be done in time linear in the size of the database.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Query evaluation is certainly the most important problem in databases. Given a query q and a database D it computes the set q(D) of all tuples in the output of q on D. However, the set q(D) may be larger than the database itself as it can have a size of the form n l where n is the size of the database and l the arity of the query. Therefore, computing entirely q(D) may require too many of the available resources.</p><p>There are many solutions to overcome this problem. For instance one could imagine that a small subset of q(D) can be quickly computed and that this subset will be enough for the user needs. Typically one could imagine computing the top-most relevant answers relative to some ranking function or to provide a sampling of q(D) relative to some distribution. One could also imagine computing only the number of solutions |q(D)| or providing an efficient test for whether a given tuple belongs to q(D) or not.</p><p>In this paper we consider a scenario consisting in enumerating q(D) with constant delay. Intuitively, this means that there is a two-phase algorithm working as follows: a preprocessing phase that works in time linear in the size of the database, followed by an enumeration phase outputting one by one all the elements of q(D) with a constant delay between any two consecutive outputs. In particular, the first answer is output after a time linear in the size of the database and once the enumeration starts a new answer is being output regularly at a speed independent from the size of the database. Altogether, the set q(D) is entirely computed in time f (q)(n + |q(D)|) for some function f depending only on q and not on D.</p><p>One could also view a constant delay enumeration algorithm as follows. The preprocessing phase computes in linear time an index structure representing the set q(D) in a compact way (of size linear in n). The enumeration algorithm is then a streaming decompression algorithm.</p><p>One could also require that the enumeration phase outputs the answers in some given order. Here we will consider the lexicographical order based on a linear order on the domain of the database.</p><p>There are many problems related to enumeration. The main one is the model checking problem. This is the case when the query is boolean, i.e. outputs only true or false. In this case a constant delay enumeration algorithm is a Fixed Parameter Linear (FPL) algorithm for the model checking problem of q, i.e. it works in time f (q)n. This is a rather strong constraint as even the model checking problem for conjunctive queries is not FPL (assuming some hypothesis in parametrized complexity) <ref type="bibr" target="#b20">[PY99]</ref>. Hence, in order to obtain constant delay enumeration algorithms, we need to make restrictions on the queries and/or on the databases. Here we consider first-order (FO) queries over classes of structures having "bounded expansion".</p><p>The notion of class of graphs with bounded expansion was introduced by Nešetřil and Ossona de Mendez in <ref type="bibr" target="#b17">[NdM08a]</ref>. Its precise definition can be found in Section 2.2. At this point it is only useful to know that it contains the class of graphs of bounded degree, the class of graphs of bounded treewidth, the class of planar graphs, and any class of graphs excluding at least one minor. This notion is generalized to classes of structures via their Gaifman graphs or adjacency graphs.</p><p>For the class of structures with bounded degree and FO queries the model checking problem is in FPL <ref type="bibr" target="#b21">[See96]</ref> and there also are constant delay enumeration algorithms <ref type="bibr" target="#b7">[DG07,</ref><ref type="bibr" target="#b14">KS11]</ref>. In the case of structures of bounded treewidth and FO queries (actually even MSO queries with first-order free variables) the model checking problem is also in FPL <ref type="bibr" target="#b6">[Cou90]</ref> and there are constant delay enumeration algorithms <ref type="bibr" target="#b2">[Bag06,</ref><ref type="bibr" target="#b16">KS13b]</ref>. For classes of structures with bounded expansion the model checking problem for FO queries was recently shown to be in FPL <ref type="bibr" target="#b8">[DKT13,</ref><ref type="bibr" target="#b10">GK11]</ref>.</p><p>Our results can be summarized as follows. For FO queries and any class of structures with bounded expansion:</p><p>• we provide a new proof that the model checking problem can be solved in FPL,</p><p>• we show that the set of solutions to a query can be enumerated with constant delay,</p><p>• we show that computing the number of solutions can be done in FPL,</p><p>• we show that, after a preprocessing in time linear in the size of the database, one can test on input ā whether ā ∈ q(D) in constant time.</p><p>Concerning model checking, our method uses a different technique than the previous ones. There are several characterizations of classes having bounded expansion <ref type="bibr" target="#b17">[NdM08a]</ref>. Among them we find characterizations via "low tree depth coloring" and "transitive fraternal augmentations". The previous methods were based on the low tree depth coloring characterization while ours is based on transitive fraternal augmentations. We show that it is enough to consider quantifier-free queries in a given normal form. The normal form is at the core of our algorithms for constant delay enumeration and for counting the number of solutions. As for the previous proofs, we exhibit a quantifier elimination method, also based on our normal form. Our quantifier elimination method results in a quantifier-free query but over a recoloring of a functional representation of a "fraternal and transitive augmentation" of the initial structure.</p><p>Our other algorithms (constant delay enumeration, counting the number of solution or testing whether a tuple is a solution or not) start by eliminating the quantifiers as for the model checking algorithm. The quantifier-free case is already non trivial and require the design and the computation of new index structures. For instance consider the simple query R(x, y). Given a pair (a, b) we would like to test whether (a, b) is a tuple of the database in constant time. In general, index structures can do this with log n time. We will see that we can do constant time, assuming bounded expansion.</p><p>In the presence of a linear order on the domain of the database, our constant delay algorithm can output the answers in the corresponding lexicographical order. Related work. We make use of a functional representation of the initial structures. Without this functional representations we would not be able to eliminate all quantifiers. Indeed, with this functional representation we can talk of a node at distance 2 from x using the quantifier-free term f (f (x)), avoiding the existential quantification of the middle point. This idea was already taken in <ref type="bibr" target="#b7">[DG07]</ref> for eliminating first-order quantifiers over structures of bounded degree. Our approach differs from theirs in the fact that in the bounded degree case the functions can be assumed to be permutations (in particular they are invertible) while this is no longer true in our setting, complicating significantly the combinatorics.</p><p>Once we have a quantifier-free query, constant delay enumeration could also be obtained using the characterization of bounded expansion based on low tree depth colorings. Indeed, using this characterization one can easily show that enumerating a quantifier-free query over structures of bounded expansion amounts in enumerating an MSO query over structures of bounded tree-width and for those known algorithms exist <ref type="bibr" target="#b2">[Bag06,</ref><ref type="bibr" target="#b16">KS13b]</ref>. However, the known enumeration algorithms of MSO over structures of bounded treewidth are rather complicated while our direct approach is fairly simple. Actually, our proof shows that constant delay enumeration of FO queries over structures of bounded treewidth can be done using simpler algorithms than for MSO queries. Moreover, it gives a constant delay algorithm outputting the solutions in lexicographical order. No such algorithms were known for FO queries over structures of bounded treewidth. In the bounded degree case, both enumeration algorithms of <ref type="bibr" target="#b7">[DG07,</ref><ref type="bibr" target="#b14">KS11]</ref> output their solutions in lexicographical order.</p><p>Similarly, counting the number of solutions of a quantifier-free query over structures of bounded expansion reduces to counting the number of solutions of a MSO query over structures of bounded treewidth. This latter problem is known to be in FPL <ref type="bibr" target="#b0">[ALS91]</ref>. We give here a direct and simple proof of this fact for FO queries over structures of bounded expansion.</p><p>Our main result is about enumeration of first-order queries. We make use of a quantifier elimination method reducing the general case to the quantifier-free case. As a special we obtain a new proof of the linear time model checking algorithm, already obtained in <ref type="bibr" target="#b8">[DKT13,</ref><ref type="bibr" target="#b10">GK11]</ref>. Both these results were also obtained using (implicitly or explicitly) a quantifier elimination method. As our enumeration of quantifier-free query also needs a specific normal form, we could not reuse the results of <ref type="bibr" target="#b8">[DKT13,</ref><ref type="bibr" target="#b10">GK11]</ref>. Hence we came up with our own method which differ in the technical details if not in the main ideas.</p><p>In <ref type="bibr" target="#b8">[DKT13]</ref> it is also claimed that the index structure used for quantifier elimination can be updated in constant time. It then tempting to think that enumeration could be achieved by adding each newly derived output tuple to the index structure and obtain the next output in constant time using the updated index. This idea does not work because constant update time can only be achieved if the inserted tuple does not modify too much the structure of the underlying graph. In particular the new structure must stay within the class under investigation. This is typically not the case with first-order query that may produce very dense results.</p><p>This paper is the journal version of <ref type="bibr" target="#b15">[KS13a]</ref>. All proofs are now detailed and the whole story has been simplified a bit, without changing the key ideas. Since the publication of the conference version, constant delay enumeration has been obtained for first-order queries over any class of structures having local bounded expansion <ref type="bibr" target="#b23">[SV17]</ref> or being nowhere dense <ref type="bibr" target="#b22">[SSV18]</ref> These two classes of structures generalize bounded expansion. However the preprocessing time that has been achieved for these two classes is not linear but pseudo-linear (i.e for any there is an algorithm working in time O(n 1+ )) and the enumeration algorithms are significantly more complicated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>In this paper a database is a finite relational structure. A relational signature is a tuple </p><formula xml:id="formula_0">σ = (R 1 , . . . , R l ), each R i being a relation symbol of arity r i . A relational structure over σ is a tuple D = D, R D 1 , . . . , R D l , where D is the domain of D and R D i is a subset of D r i . We will often write R i instead of R D i when D is</formula><formula xml:id="formula_1">||D|| = |D| + Σ R i ∈σ ||R D i ||.</formula><p>By query we mean a formula of first-order logic, FO, built from atomic formulas of the form x = y or R i (x 1 , . . . , x r i ) for some relation R i , and closed under the usual Boolean connectives (¬, ∨, ∧) and existential and universal quantifications (∃, ∀). We write φ(x) to denote a query whose free variables are x, and the number of free variables is called the arity of the query. A sentence is a query of arity 0. We use the usual semantics, denoted |=, for first-order. Given a structure D and a query q, an answer to q in D is a tuple ā of elements of D such that D |= q(ā). We write q(D) for the set of answers to q in D, i.e. q(D) = {ā | D |= q(ā)}. As usual, |q| denotes the size of q.</p><p>Let C be a class of structures. The model checking problem for FO over C is the computational problem of given first-order sentence q and a database D ∈ C to test whether D |= q or not.</p><p>We now introduce our running examples.</p><p>Example A-1 . The first query has arity 2 and returns pairs of nodes at distance 2 in a graph. The query is of the form ∃zE(x, z) ∧ E(z, y).</p><p>Testing the existence of a solution to this query can be easily done in time linear in the size of the database. For instance one can go trough all nodes of the database and check whether it has non-nill in-degree and out-degree. The degree of each node can be computed in linear time by going through all edges of the database and incrementing the counters associated to its endpoints.</p><p>Example B-1 . The second query has arity 3 and returns triples (x, y, z) such that y is connected to x and z via an edge but x is not connected to z. The query is of the form E(x, y) ∧ E(y, z) ∧ ¬E(x, z).</p><p>It is not clear at all how to test the existence of a solution to this query in time linear in the size of the database. The problem is similar to the one of finding a triangle in a graph, for which the best know algorithm has complexity even slightly worse than matrix multiplication <ref type="bibr" target="#b1">[AYZ95]</ref>. If the degree of the input structure is bounded by a constant d, we can test the existence of a solution in linear time by the following algorithm. We first go through all edges (x, y) of the database and add y to a list associated to x and x to a list associated to y. It remains now to go through all nodes y of the database, consider all pairs (x, z) of nodes in the associated list (the number of such pairs is bounded by d 2 ) and then test whether there is an edge between x and z (by testing whether x is in the list associated to z).</p><p>We aim at generalizing this kind of reasoning to structures with bounded expansion.</p><p>Given a query q, we care about "enumerating" q(D) efficiently. Let C be a class of structures. For a query q(x), the enumeration problem of q over C is, given a database D ∈ C, to output the elements of q(D) one by one with no repetition. The maximum time between any two consecutive outputs of elements of q(D) is called the delay. The definition below requires a constant time delay. We formalize these notions in the forthcoming section.</p><p>2.1. Model of computation and enumeration. We use Random Access Machines (RAM) with addition and uniform cost measure as a model of computation. For further details on this model and its use in logic see <ref type="bibr" target="#b7">[DG07]</ref>. In the sequel we assume that the input relational structure comes with a linear order on the domain. If not, we use the one induced by the encoding of the database as a word. Whenever we iterate through all nodes of the domain, the iteration is with respect to the initial linear order.</p><p>We say that the enumeration problem of q over a class C of structures is in the class CD•Lin, or equivalently that we can enumerate q over C with constant delay, if it can be solved by a RAM algorithm which, on input D ∈ C, can be decomposed into two phases: • a precomputation phase that is performed in time O(||D||),</p><p>• an enumeration phase that outputs q(D) with no repetition and a constant delay between two consecutive outputs. The enumeration phase has full access to the output of the precomputation phase but can use only a constant total amount of extra memory.</p><p>Notice that if we can enumerate q with constant delay, then all answers can be output in time O(||D|| + |q(D)|) and the first output is computed in time linear in ||D||. In the particular case of boolean queries, the associated model checking problem must be solvable in time linear in ||D||. Notice also that the total amount of memory used after computing all answers is linear in ||D||, while a less restrictive definition requiring only a constant time delay between any two outputs may yield in a total amount of memory linear in ||D|| + ||q(D)||.</p><p>Note that we measure the running time complexity as a function of ||D||. The multiplicative factor will depend on the class C of database under consideration and, more importantly, on the query q. In our case we will see that the multiplicative factor is non elementary in |q| and that cannot be avoided, see the discussion in the conclusion section.</p><p>We may in addition require that the enumeration phase outputs the answers to q using the lexicographical order. We then say that we can enumerate q over C with constant delay in lexicographical order.</p><p>Example A-2 . Over the class of all graphs, we cannot enumerate pairs of nodes at distance 2 with constant delay unless the Boolean Matrix Multiplication problem can be solved in quadratic time <ref type="bibr" target="#b4">[BDG07]</ref>. However, over the class of graphs of degree d, there is a simple constant delay enumeration algorithm. During the preprocessing phase, we associate to each node the list of all its neighbors at distance 2. This can be done in time linear in the size of the database as in Example B-1. We then color in blue all nodes having a non empty list and make sure each blue node points to the next blue node (according to the linear order on the domain). This also can be done in time linear in the size of the database and concludes the preprocessing phase. The enumeration phase now goes through all blue nodes x using the pointer structure and, for each of them, outputs all pairs (x, y) where y is in the list associated to x.</p><p>Example B-2 . Over the class of all graphs, the query of this example cannot be enumerated with constant delay because, as mentioned in Example B-1, testing whether there is one solution is already non linear. Over the class of graphs of bounded degree, there is a simple constant delay enumeration algorithm, similar to the one from Example A-2.</p><p>Note that in general constant delay enumeration algorithms are not closed under any boolean operations. For instance if q and q can be enumerated with constant delay, we cannot necessarily enumerate q ∨ q with constant delay as enumerating one query after the other would break the "no repetition" requirement. However, if we can enumerate with constant delay in the lexicographical order, then a simple argument that resembles the problem of merging two sorted lists shows closure under union: Lemma 2.1. If both queries q(x) and q (x) can be enumerated in lexicographical order with constant delay then the same is true for q(x) ∨ q (x).</p><p>Proof. The preprocessing phase consists in the preprocessing phases of the enumeration algorithms for q and q .</p><p>The enumeration phase keeps two values, the smallest element from q(D) that was not yet output and similarly the smallest element from q (D) that was not yet output. It then outputs the smaller of the two values and replaces it in constant time with the next element from the appropriate set using the associated enumeration procedure. In case the elements are equal, the value is output once and both stored values are replaced with their appropriate successors.</p><p>It will follow from our results that the enumeration problem of FO over the class of structures with "bounded expansion" is in CD•Lin. The notion of bounded expansion was defined in <ref type="bibr" target="#b17">[NdM08a]</ref> for graphs and then it was generalized to structures via their Gaifman or Adjacency graphs. We start with defining it for graphs.</p><p>2.2. Graphs with bounded expansion and augmentation. By default a graph has no orientation on its edges and has colors on its vertices. In an oriented graph every edge is an arrow going from the source vertex to its target. We can view a (oriented or not) graph as a relational structure</p><formula xml:id="formula_2">G = (V G , E G , P G 1 , . . . , P G l )</formula><p>, where V G is the set of nodes, E G ⊆ V 2 is the set of edges and, for each 1 ≤ i ≤ l, P G i is a predicate of arity 1, i.e. a color. We omit the subscripts when G is clear from the context. In the nonoriented case, E is symmetric and irreflexive and we denote by {u, v} the edge between u and v. In the oriented case we denote by (u, v) the edge from u to v. We will use the notation G when the graph is oriented and G in the nonoriented case. An orientation of a graph G is any graph</p><formula xml:id="formula_3">H such that {u, v} ∈ E G implies (u, v) ∈ E H or (v, u) ∈ E H . The in-degree of a node v of G is the number of nodes u such that (u, v) ∈ E.</formula><p>We denote by ∆ -( G) the maximum in-degree of a node of G. Among all orientations of a graph G, we choose the following one, which is computable in time linear in ||G||. It is based on the degeneracy order of the graph. We find the first node of minimal degree, orient its edges towards it and repeat this inductively in the induced subgraph obtained by removing this node. The resulting graph, denoted G 0 , has maximum in-degree which is at most twice the optimal value and that is enough for our needs.</p><p>In <ref type="bibr" target="#b17">[NdM08a]</ref> several equivalent definitions of bounded expansion were shown. We present here only the one we will use, exploiting the notion of "augmentations".</p><p>Let G be an oriented graph. A 1-transitive fraternal augmentation of G is any graph H with the same vertex set as G and the same colors of vertices, including all edges of G (with their orientation) and such that for any three vertices x, y, z of G we have the following:</p><p>(transitivity): if (x, y) and (y, z) are edges in G, then (x, z) is an edge in H, (fraternity): if (x, z) and (y, z) are edges in G, then at least one of the edges: (x, y), (y, x)</p><p>is in H, (strictness): moreover, if H contains an edge that was not present in G, then it must have been added by one of the previous two rules.</p><p>Note that the notion of 1-transitive fraternal augmentation is not a deterministic operation. Although transitivity induces precise edges, fraternity implies nondeterminism and thus there can possibly be many different 1-transitive fraternal augmentations. We care here about choosing the orientations of the edges resulting from the fraternity rule in order to minimize the maximum in-degree.</p><p>Following <ref type="bibr" target="#b18">[NdM08b]</ref> we fix a deterministic algorithm computing a "good" choice of orientations of the edges induced by the fraternity property. The precise definition of the algorithm is not important for us, it only matters here that the algorithm runs in time linear in the size of the input graph (see Lemma 2.3 below). With this algorithm fixed, we can now speak of the 1-transitive fraternal augmentation of G.</p><p>Let G 0 be an oriented graph. The transitive fraternal augmentation of G 0 is the sequence G 0 ⊆ G 1 ⊆ G 2 ⊆ . . . such that for each i ≥ 1 the graph G i+1 is the 1-transitive fraternal augmentation of G i . We will say that G i is the i-th augmentation of G 0 . Similarly we denote the transitive fraternal augmentation of a nonoriented graph G by considering the orientation G 0 based on the degeneracy order as explained above.</p><p>Definition 2.2. <ref type="bibr" target="#b17">[NdM08a]</ref> Let C be a class of graphs. C has bounded expansion if there exists a function Γ C : N → R such that for each graph G ∈ C its transitive fraternal augmentation</p><formula xml:id="formula_4">G 0 ⊆ G 1 ⊆ G 2 ⊆ . . . of G is such that for each i ≥ 0 we have ∆ -( G i ) ≤ Γ C (i).</formula><p>Consider for instance a graph of degree d. Notice that the 1-transitive fraternal augmentation introduces an edge between nodes that were at distance at most 2 in the initial graph. Hence, when starting with a graph of degree d, we end up with a graph of degree at most d 2 . This observation shows that the class of graphs of degree d has bounded expansion as witnessed by the function Γ(i) = d 2 i . Exhibiting the function Γ for the other examples of classes with bounded expansion mentioned in the introduction: bounded treewidth, planar graphs, graphs excluding at least one minor, requires more work <ref type="bibr" target="#b17">[NdM08a]</ref>.</p><p>The following lemma shows that within a class C of bounded expansion the i-th augmentation of G ∈ C can be computed in linear time, the linear factor depending on i and on C.</p><formula xml:id="formula_5">Lemma 2.3. [NdM08b] Let C be a class of bounded expansion. For each G ∈ C and each i ≥ 0, G i is computable from G in time O(||G||).</formula><p>A transitive fraternal augmentation introduces new edges in the graphs in a controlled way. We will see that we can use these extra edges in order to eliminate quantifiers in a firstorder query. Lemma 2.3 shows that this quantifier elimination is harmless for enumeration as it can be done in time linear in the size of the database and can therefore be done during the preprocessing phase.</p><p>2.3. Graphs of bounded in-degree as functional structures. Given the definition of bounded expansion it is convenient to work with oriented graphs. These graphs will always be such that the maximum in-degree is bounded by some constant depending on the class of graphs under investigation. It is therefore convenient for us to represent our graphs as functional structures where the functions links the current node with its predecessors. This functional representation turns out to be also useful for eliminating some quantifiers.</p><p>A functional signature is a tuple σ = (f 1 , . . . , f l , P 1 , . . . , P m ), each f i being a functional symbol of arity 1 and each P i being an unary predicate. A functional structure over σ is then defined as for relational structures. FO is defined as usual over the functional signature. In particular, it can use atoms of the form f (f (f (x))), which is crucial for the quantifier elimination step of Section 4 as the relational representation would require existential quantification for denoting the same element. A graph G of in-degree l and colored with m colors can be represented as a functional structure f G, where the unary predicates encode the various colors and v = f i (u) if v is the i th element (according to some arbitrary order that will not be relevant in the sequel) such that (v, u) is an edge of G. We call such node v the i th predecessor of u (where "i th predecessor" should really be viewed as an abbreviation for "the node v such that f i (u) = v" and not as a reference to the chosen order). If we do not care about the i and we only want to say that v is the image of u under some function, we call it a predecessor of u. If a node u has j predecessors with j &lt; l, then we set f k (u) = u for all k &gt; j. This will allow us to detect how many predecessors a given node has without quantifiers by checking whether f j (u) = u or not. Given a nonoriented graph G we define f G to be the functional representation of G 0 as described above. Note that f G is computable in time linear in ||G|| and that for each first order query φ(x), over the relational signature of graphs, one can easily compute a first order query ψ(x), over the functional signature, such that φ(G) = ψ(f G).</p><p>Example A-3 . Consider again the query computing nodes at distance 2 in a nonoriented graph. There are four possible ways to orient a path of length 2. With the functional point of view we further need to consider all possible predecessors. Altogether the distance 2 query is now equivalent to:</p><formula xml:id="formula_6">f,g f (g(x)) = y ∨ g(f (y)) = x ∨ f (x) = g(y) ∨ ∃z f (z) = x ∧ g(z) = y</formula><p>where the small disjuncts correspond to the four possible orientations and the big one to all possible predecessors, each of them corresponding to a function name, whose number depends on the function Γ C .</p><p>Example B-3 . Similarly, the reader can verify that the query of Example B-1 is equivalent to:</p><formula xml:id="formula_7">f,g h (h(x) = z ∧ h(z) = x)∧ (f (x) = y ∧ g(y) = z) ∨ (x = f (y) ∧ g(y) = z) ∨ (f (x) = y ∧ y = g(z)) ∨ (x = f (y) ∧ y = g(z)) .</formula><p>Augmentation for graphs as functional structures. The notion of 1-transitive fraternal augmentation can be adapted directly to the functional setting. However it will be useful for us to enhance it with extra information. In particular it will be useful to remember at which stage the extra edges are inserted. We do this as follows.</p><p>Given a graph f G, its 1-transitive fraternal augmentation f G is constructed as follows. The signature of f G extends the signature of f G with new function symbols for taking care of the new edges created during the expansion and f G is then an expansion, in the logical sense, of f G over this new signature: f G and f G agree on the relations in the old signature.</p><p>For any pair of functions f and g in the signature of f G there is a new function h in the signature of f G representing the transitive part of the augmentation. It is defined as the composition of f and g, i.e.</p><formula xml:id="formula_8">h f G = f f G • g f G</formula><p>Similarly, for any pair of functions f and g in the signature of f G, and any node x in the domain of both f f G and g f G there will be a function h in the new signature representing the fraternity part of the augmentation. I.e h is such that</p><formula xml:id="formula_9">h f G (f f G (x)) = g f G (x) or h f G (g f G (x)) = f f G (x).</formula><p>Given a class C of bounded expansion, the guarantees that the number of new function symbols needed for the i-th augmentation is bounded by Γ C (i) and does not depend on the graph. Hence a class C of bounded expansion generates finite functional signatures σ C (0) ⊆ σ C (1) ⊆ σ C (2) ⊆ . . . such that for any graph G ∈ C and for all i:</p><formula xml:id="formula_10">(1) f G i is a functional structure over σ C (i) computable in linear time from G, (2) f G i+1 is an expansion of f G i , (3) for every FO query φ(x) over σ C (i) and every j ≥ i we have that φ(f G i ) = φ(f G j ).</formula><p>We denote by α C (i) the number of function symbols of σ C (i). Notice that we have</p><formula xml:id="formula_11">α C (i) ≤ Σ j≤i Γ C (j).</formula><p>We say that a functional signature σ is a recoloring of σ if it extends σ with some extra unary predicates, also denoted as colors, while the functional part remains intact. Similarly, a functional structure f G over σ is a recoloring of f G over σ if σ is a recoloring of σ and f G differs from f G only in the colors in σ . We write φ is over a recoloring of σ if φ is over σ and σ is a recoloring of σ. Notice that the definition of bounded expansion is not sensitive to the colors as it depends only on the binary predicates, hence adding any fixed finite number of colors is harmless.</p><p>Given a class C of graphs, for each p ≥ 0, we define C p to be the class of all recolorings f G p of f G p for some G ∈ C. In other words C p is the class of functional representations of all recolorings of all p-th augmentations of graphs from C. Note that all graphs from C p are recolorings of a structure in σ C (p), hence they use at most α C (p) function symbols.</p><p>From now on we assume that all graphs from C and all queries are in their functional representation. It follows from the discussion above that this is without loss of generality.</p><p>2.4. From structures to graphs. A class of structures is said to have bounded expansion if the set of adjacency graphs of the structures of the class has bounded expansion.</p><p>The adjacency graph of a relational structure D, denoted by Adjacency(D), is a functional structure defined as follows. The set of vertices of Adjacency(D) is D ∪ T where D is the domain of D and T is the set of tuples occurring in some relation of D. For each relation R i in the schema of D, there is a unary symbol P R i coloring the elements of T belonging to R i . For each tuple t = (a 1 , • • • , a r i ) such that D |= R i (t) for some relation R i of arity r i , we have an edge f j (t) = a j for all j ≤ r i .</p><p>Observation 2.4. It is immediate to see that for every relational structure D we can compute Adjacency(D) in time O(||D||).</p><p>Let C be a class of relational structures. We say that C has bounded expansion if the class C' of adjacency graphs (seen as graphs) of structures from C has bounded expansion.</p><p>Remark 2.5. In the literature, for instance <ref type="bibr" target="#b8">[DKT13,</ref><ref type="bibr" target="#b10">GK11]</ref>, a class C of relational structures is said to have bounded expansion if the class of their Gaifman graphs has bounded expansion. It is easy to show that if the class of Gaifman graphs of structures from C has bounded expansion then the class of adjacency graphs of structures from C also has bounded expansion. The converse is not true in general. However the converse holds if the schema is fixed, i.e. C is a class of structures all having the same schema. We refer to <ref type="bibr" target="#b12">[Kaz13]</ref> for the simple proofs of these facts.</p><p>Let Γ C be the function given by Definition 2.2 for C'. The following lemma is immediate. For instance R(x) is rewritten as ∃yP R (y) ∧ 1≤i≤r f i (y) = x i .</p><p>Lemma 2.6. Let C be a class of relational structures with bounded expansion and let C' be the underlying class of adjacency graphs. Let φ(x) ∈ FO. In time linear in the size of φ we can find a query ψ(x) over σ C (0) such that for all D ∈ C we have φ(D) = ψ(Adjacency(D)).</p><p>As a consequence of Lemma 2.6 it follows that model checking, enumeration and counting of first-order queries over relational structures reduce to the graph case. Therefore in the rest of the paper we will only concentrate on the graph case (viewed as a functional structure), but the reader should keep in mind that all the results stated over graphs extend to relational structures via this lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Normal form for quantifier-free first-order queries</head><p>We prove in this section a normal form on quantifier-free first-order formulas. This normal form will be the ground for all our algorithms later on. It says that, modulo performing some extra augmentation steps, a quantifier-free formula has a very simple form.</p><p>Fix class C of graphs with bounded expansion. Recall that we are now implicitly assuming that graphs are represented as functional structures.</p><p>A formula is simple if it does not contain atoms of the form f (g(x)), i.e. it does not contain any compositions of functions. We first observe that, modulo augmentations, any formula can be transformed into a simple one.</p><p>Lemma 3.1. Let ψ(x) be a formula over a recoloring of σ C (p). Then, for q = p + |ψ|, there is a simple formula ψ (x) over a recoloring of σ C (q) such that: for all graphs f G ∈ C p there is a graph</p><formula xml:id="formula_12">f G ∈ C q computable in time linear in ||f G|| such that ψ(f G) = ψ (f G ).</formula><p>Proof. This is a simple consequence of transitivity. Any composition of two functions in f G represents a transitive pair of edges and becomes an single edge in the 1-augmentation f H of f G. Then y = f (g(x)) over f G is equivalent to h y = h(x) ∧ P f,g,h (x) over f H, where h is one of the new function introduced by the augmentation and the newly introduced color P f,g,h holds for those nodes v, for which the f (g(v)) = h(v). As the nesting of compositions of functions is at most |ψ|, the result follows. The linear time computability is immediate from Lemma 2.3.</p><p>We make one more observation before proving the normal form:</p><formula xml:id="formula_13">Lemma 3.2. Let f G ∈ C p . Let u be a node of f G. Let S be all the predecessors of u in f G and set q = p + Γ C (p). Let f G ∈ C q be the (q -p)-th augmentation of f G. There exists a linear order &lt; on S computable from f G , such that for all v, v ∈ S, v &lt; v implies v = f (v) is an edge of f G for some function f from σ C (q).</formula><p>Proof. This is because all nodes of S are fraternal and the size of S is at most Γ C (p). Hence, after one step of augmentation, all nodes of S are pairwise connected and, after at most Γ C (p) -1 further augmentation steps, if there is a directed path from one node u of S to another node v of S, then there is also a directed edge from u to v. By induction on |S| we show that there exists a node u ∈ S such that for all v ∈ S there is an edge from v to u. If |S| = 1 there is nothing to prove. Otherwise fix v ∈ S and let S = S \ {v}. By induction we get a u in S satisfying the properties. If there is an edge from v to u, u also works for S and we are done. Otherwise there must be an edge from u to v. But then there is a path of length 2 from any node of S to v. By transitivity this means that there is an edge from any node of S to v and v is the node we are looking for.</p><p>We then set u as the minimal element of our order on S and we repeat this argument with S \ {u}. Lemma 3.2 justifies the following definition. Let p be a number and let q = p + Γ C (p). A p-type τ (x) is a quantifier-free formula over the signature σ C (q) with one free variable x consisting of the conjunction of a maximal consistent set of clauses of the form f (g(x)) = h(x) or f (x) = x. Given a node u of some graph f G of C p , its p-type is the set of clauses satisfied by u in the (q -p)-th augmentation f G of f G. From Lemma 3.2 it follows that the p-type of u induces a linear order on its predecessors in f G. Indeed the predecessors of u in f G can be deduced from the p-type by looking at the clauses f (x) = x where f is a function symbol from σ C (p) and the linear order can be deduced from the clauses h(f (x)) = g(x). Lemma 3.2 guarantees that these latter clauses induce a linear order. In the sequel we denote this property as "the p-type τ induces the order f 1 (x) &lt; f 2 (x) &lt; • • • " and for i &lt; j we refer to the h linking f i (x) to f j (x) as h i,j .</p><p>Note that for a given p there are only finitely many possible p-types and that each of them can be specified with a conjunctive formula over σ C (q). We now state the normal form result.</p><p>Proposition 3.3. Let φ(xy) be a simple quantifier-free query over a recoloring of σ C (p).</p><p>There exists q that depends only on p and φ and a quantifier-free query ψ over a recoloring of σ C (q) that is a disjunction of formulas:</p><formula xml:id="formula_14">ψ 1 (x) ∧ τ (y) ∧ ∆ = (xy) ∧ ∆ = (xy), (3.1)</formula><p>where τ (y) implies a p-type of y; ∆ = (xy) is either empty or contains one clause of the form y = f (x i ) or one clause of the form f (y) = g(x i ) for some i, f and g; and ∆ = (xy) contains arbitrarily many clauses of the form y = f (x i ) or f (y) = g(x j ). Moreover, ψ is such that:</p><formula xml:id="formula_15">for all f G ∈ C p there is a f G ∈ C q computable in time linear in ||f G|| with φ(f G) = ψ(f G ).</formula><p>Proof. Set q as given by Lemma 3.2. We first put φ into a disjunctive normal form (DNF) and in front of each such disjunct we add a big disjunction over all possible p-types of y (recall that a type can be specified as a conjunctive formula). We deal with each disjunct separately.</p><p>Note that each disjunct is a query over σ C (q) of the form:</p><formula xml:id="formula_16">ψ 1 (x) ∧ τ (y) ∧ ∆ = (xy) ∧ ∆ = (xy),</formula><p>where all sub-formulas except for ∆ = are as desired. Moreover, ψ 1 (x), ∆ = (xy) and ∆ = (xy) are in fact queries over σ C (p). At this point ∆ = contains arbitrarily many clauses of the form y = f (x i ) or f (y) = g(x i ). If it contains at least one clause of the form y = f (x i ), we can replace each other occurrence of y by f (x i ) and we are done. Assume now that ∆ = contains several conjuncts of the form f i (y) = g(x k ). Assume wlog that τ is such that f 1 (y) &lt; f 2 (y) &lt; • • • , where f 1 (y), f 2 (y), • • • are all the predecessors of y from σ C (p). Let i 0 be the smallest index i such that a clause of the form f i (y) = g(x k ) belongs to ∆ = . We have f i 0 (y) = g(x k ) in ∆ = and recall that τ specifies for i &lt; j a function h i,j in σ C (q) such that h i,j (f i (y)) = f j (y). Then, as y is of type τ , a clause of the form f j (y) = h(x k ) with i 0 &lt; j is equivalent to h i 0 ,j (g(x k )) = h(x k ).</p><p>Example A-4 . Let us see what Lemma 3.1 and the normalization algorithm do for p = 0 and some of the disjuncts of the query of Example A-3:</p><p>In the case of f (g(x)) = y note that by transitivity, in the augmented graph, this clause is equivalent to one of the form y = h(x) ∧ P f,g,h (x) (this case is handled by Lemma 3.1).</p><p>Consider now ∃z f (z) = x ∧ g(z) = y. It will be convenient to view this query when z plays the role of y in Proposition 3.3. Notice that in this case it is not in normal form as ∆ = contains two elements. However, the two edges f (z) = x and g(z) = y are fraternal. Hence, after one augmentation step, a new edge is added between x and y and we either have y = h(x) or x = h(y) for some h in the new signature.</p><p>Let τ h,f,g (z) be 0-type stating that h(f (z)) = g(z) and τ h,g,f (z) be 0-type stating that h(g(z)) = f (z). It is now easy to see that the query ∃z f (z) = x ∧ g(z) = y is equivalent to</p><formula xml:id="formula_17">∃z h y = h(x) ∧ τ h,f,g (z) ∧ f (z) = x ∨ x = h(y) ∧ τ h,g,f (z) ∧ g(z) = y.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Model checking</head><p>In this section we show that the model checking problem of FO over a class of structures with bounded expansion can be done in time linear in the size of the structure. This gives a new proof of the result of <ref type="bibr" target="#b8">[DKT13]</ref>. Recall that by Lemma 2.6 it is enough to consider oriented graphs viewed as functional structures. The proof of Theorem 4.1 is done using a quantifier elimination procedure: given a query ψ(x) with at least one free variable we can compute a quantifier-free query φ(x) that is "equivalent" to ψ. Again, the equivalence should be understood modulo some augmentation steps for a number of augmentation steps depending only on C and |ψ|. When starting with a sentence ψ we end-up with φ being a boolean combination of formulas with one variable. Those can be easily tested in linear time in the size of the augmented structure, which in turn can be computed in time linear from the initial structure by Lemma 2.3. The result follows. We now state precisely the quantifier elimination step: Proposition 4.2. Let C be a class of graphs with bounded expansion witnessed by the function Γ C . Let ψ(xy) be a quantifier-free formula over a recoloring of σ C (p). Then one can compute a q and a quantifier-free formula φ(x) over a recoloring of σ C (q) such that: for all f G ∈ C p there is an f G ∈ C q such that:</p><formula xml:id="formula_18">φ(f G ) = (∃yψ)(f G) Moreover, f G is computable in time O(||f G||).</formula><p>Proof. In view of Lemma 3.1 we can assume that ψ is simple. We then apply Proposition 3.3 to ψ and p and obtain a q and an equivalent formula in DNF, where each disjunct has the special form given by (3.1). As disjunction and existential quantification commute, it is enough to treat each part of the disjunction separately. We thus assume that ψ(xy) is a quantifier-free conjunctive formula over a recoloring of σ C (q) of the form (3.1):</p><formula xml:id="formula_19">ψ 1 (x) ∧ τ (y) ∧ ∆ = (xy) ∧ ∆ = (xy).</formula><p>Let's assume that the p-type τ satisfied by y enforces f 1 (y) &lt; f 2 (y) &lt; • • • , where f 1 (y), f 2 (y), • • • are all the images of y by a function from σ C (p) such that f i (y) = y. Moreover, for each i &lt; j, τ contains an atom of the form h i,j (f i (y)) = f j (y) for some function h i,j ∈ σ C (q). We do a case analysis depending on the value of ∆ = .</p><p>• If ∆ = is y = g(x k ) for some function g and some k, then we replace y with g(x k ) everywhere in ψ(xy) resulting in a formula φ(x) having obviously the desired properties.</p><p>• Assume now that ∆ = is of the form f (y) = g(x k ). Without loss of generality we can assume that f is f i 0 and k = 1. In other words ∆ = contains only the constraint f i 0 (y) = g(x 1 ). The general idea is to limit the quantification on y to a finite set (whose size depends only on C and ψ), depending only on x 1 . We then encode these sets using suitable extra colors. To do this, for each node w we first compute a set Witness(w) such that for each tuple v we have f G q |= ∃y ψ(vy) iff f G q |= ∃y ∈ Witness(g(v 1 )) ψ(vy). Moreover, for all w, |Witness(w)| ≤ N where N is a number depending only on p. We then encode these witness sets using suitable extra colors.</p><p>The intuition behind the Witness set is as follows. Assume first that ∆ = is empty. Then we only need to test the existence of y such that f i 0 (y) = g(x 1 ). To do so, we scan through all nodes u, test if τ (u) holds and if so we add u to Witness(f i 0 (u)) if this set is empty and do nothing otherwise. Clearly each witness set has size at most one and the desired properties are verified. Moreover if v is in Witness(g(x 1 )) then f i 0 (v) = g(x 1 ). Therefore it is then enough to color with a new color red all nodes having a non-empty witness set and ∃y τ (y) ∧ f i 0 (y) = g(x 1 ) is then equivalent to red(g(x 1 )).</p><p>The situation is slightly more complicated if ∆ = is not empty. Assume for instance that ∆ = contains only constraints of the form y = h(x k ). Then the previous procedure does not work because Witness(g(x 1 )) may be such that it is equal to h(x k ). However there are only c nodes that we need to avoid, where c depends only on the formula, hence if Witness(g(x 1 )) contains at least c + 1 nodes we are sure that at least one of them will satisfy all the inequality constraints. We implement this by scanning through all nodes u, test if τ (u) holds and if so we add u to Witness(f i 0 (u)) if this set has a size smaller or equal to c do nothing otherwise. The difficulty is to encode this set into the formula. If the witness set is of size c + 1 one of its element must make all inequalities true hence a new color as before does the job. When the set has a smaller size we need to test each of its elements against the inequalities. For this we introduce a predicates Q i , and add a node u to Q i if u has been added as the i th element in Witness(f i 0 (u)). As before any element y in Witness(g(x 1 )) is such that f i 0 (y) = g(x 1 ). It remains to test whether the i th such element satisfies y = h(x). In other words whether h(x) is the i th witness of g(x 1 ) or not. It is easy to check that the i th witness of g(</p><formula xml:id="formula_20">x 1 ) is h(x) iff Q i (h(x k )) ∧ f i 0 (h(x k )) = g(x 1 ).</formula><p>The general case, when ∆ = contains also clauses of the form h 1 (y) = h 2 (x k ) is more complex and require an even bigger witness set but this is essentially what we do.</p><p>Computation of the Witness function. We start by initializing Witness(v) = ∅ for all v.</p><p>We then successively investigate all nodes u of f G q and do the following. If f G q |= ¬τ (u) then we move on to the next u. If f G q |= τ (u) then let u 1 , • • • , u l be the current value of Witness(f i 0 (u)) -if Witness(f i 0 (u)) is empty then we add u to this set and move on to the next node of f G q .</p><p>Let β p be α C (p)(α C (p) + 1)|x| + 1. Let i be minimal such that there exists j with f i (u j ) = f i (u) (notice that i ≤ i 0 ). Note that because f j (w) = h i,j (f i (w)) for all w verifying τ and all j &gt; i, this implies that u and u j agree on each f j with j ≥ i and disagree on each f j with j &lt; i.</p><formula xml:id="formula_21">Let S i = {f i-1 (u j ) | f i (u j ) = f i (u)}, where f 0 (u j ) is u j in the case where i = 1. If |S i | &lt; β p then we add u to Witness(f i 0 (u)).</formula><p>Analysis of the Witness function. Clearly the algorithm computing the witness function runs in linear time.</p><p>Moreover, for each node v, Witness(v) can be represented as the leaves of a tree of depth at most α C (p) and of width β p . To see this, notice that all nodes u of Witness(v) are such that f i 0 (u) = v. Note also that if two nodes u and u satisfying τ share a predecessor, f i (u) = f i (u ), then for all j &gt; i, u and u agree on f j as f j = h i,j • f i for all nodes satisfying τ . The depth of the least common ancestor of two nodes u and u of Witness(v) is defined as the least i such that u and u agree on f i . One can then verify that by construction of Witness(v) the tree has the claimed sizes. Hence the size of Witness(v) is bounded by β α C (p)+1 p . We now show that for each tuple v and each node u such that f G q |= ψ(vu) there is a node u in Witness(g(v 1 )) such that f G q |= ψ(vu ).</p><p>To see this assume f G q |= ψ(vu). If u ∈ Witness(g(v 1 )) we are done. Otherwise note that f i 0 (u) = g(v 1 ) and that f G q |= τ (u). Let i and S i be as described in the algorithm when investigating u. As u was not added to Witness(f i 0 (u)), we must have |S i | &gt; β p . Let u 1 , • • • , u βp be the elements of Witness(g(v 1 )) providing β p pairwise different values for f i-1 . Among these, at most α C (p)|v| of them may be of the form f j (v l ) for some j and l as each v l has at most α C (p) predecessors. Notice that for all j &gt; i and all , u agrees with u on f i and therefore they also agree on f j for j &gt; i as f j = h i,j • f i for all nodes satisfying τ . When j &lt; i the values of f j (u ) and f j (u ) must be different if = as otherwise u and u would also agree on f i-1 as f i-1 = h j,i-1 • h i-1 for all nodes satisfying τ . Therefore, for each and each j &lt; i there are at most α C (p) of the u such that f j (u ) is a predecessor of v l .</p><p>Altogether, at most α C (p) 2 |v| + α C (p)|v| nodes u may falsify an inequality constraint. As β p is strictly bigger than that, one of the u is the desired witness.</p><p>Recoloring of f G q . Based on Witness we recolor f G q as follows. Let γ p = (β p + 1) α C (p)+1 . For each v ∈ f G q , the i th witness of v is the i th element inserted in Witness(v) by the algorithm.</p><p>For each i ≤ γ p we introduce a new unary predicate P i and for each u ∈ f G q we set P i (u) if Witness(u) contains at least i elements.</p><p>For each i ≤ γ p , we introduce a new unary predicate Q i and for each v ∈ f G q we set Q i (v) if the i th witness of f i 0 (v) is v.</p><p>For each i ≤ γ p and each h, h ∈ α C (q) we introduce a new unary predicate P i,h,h and for each v ∈ f G q we set P i,h,h (v) if the i th witness of h(v) is an element u with h (u) = v.</p><p>We denote by f G the resulting graph and notice that it can be computed in linear time from f G.</p><p>Computation of φ. We now replace ψ(x, y) by the following formula:</p><formula xml:id="formula_22">i≤γp ψ 1 (x) ∧ ψ i (x)</formula><p>where ψ i (x) checks that the i th witness of g(x 1 ) makes the initial formula true.</p><p>Notice that if y is the i th witness of g(x 1 ) then f i 0 (y) = g(x 1 ). Hence the equality</p><formula xml:id="formula_23">f j (y) = h(x k ) with j &lt; i 0 is equivalent over f G to h j,i 0 (h(x k )) = g(x 1 ) ∧ P i,h j,i 0 ,f j (h(x k ))</formula><p>and the equality y</p><formula xml:id="formula_24">= h(x k ) is equivalent over f G to f i 0 (h(x k )) = g(x 1 ) ∧ Q i (h(x k )).</formula><p>From the definition of p-type, the equality f j (y) = h(x k ) with j &gt; i 0 is equivalent to</p><formula xml:id="formula_25">h i 0 ,j (g(x 1 )) = h(x k ).</formula><p>This implies that ψ i (x) can be defined as</p><formula xml:id="formula_26">P i (g(x 1 )) ∧ f j (y) =h(x k )∈∆ = j&lt;i 0 ¬ h j,i 0 (h(x k )) = g(x 1 ) ∧ P i,h j,i 0 ,f j (h(x k )) ∧ f j (y) =h(x k )∈∆ = j≥i 0 h i 0 ,j (g(x 1 )) = h(x k ) ∧ y =h(x k )∈∆ = ¬ f i 0 (h(x k )) = g(x 1 ) ∧ Q i (h(x k )) .</formula><p>• It remains to consider the case when ∆ = is empty. This is a simpler version of the previous case, only this time it is enough to construct a set Witness which does not depend on v. It is constructed as in the previous case and verifies: for all tuples v of f G q , if f G q |= ψ(vu) for some node u, then there is a node u ∈ Witness such that f G q |= ψ(vu ). Moreover, |Witness| ≤ γ p . We then argue as in the previous case.</p><p>Example A-5 . Consider one of the quantified formulas as derived by Example A-4:</p><formula xml:id="formula_27">∃z y = h(x) ∧ τ h,f,g (z) ∧ f (z) = x.</formula><p>The resulting quantifier-free query has the form:</p><formula xml:id="formula_28">P (x) ∧ h(x) = y</formula><p>where P (x) is a newly introduced color saying "∃z τ h,f,g (z) ∧ f (z) = x". The key point is that this new predicate can be computed in linear time by iterating through all nodes z, testing whether τ h,f,g (z) is true and, if this is the case, coloring f (z) with color P .</p><p>Applying the quantifier elimination process from inside out using Proposition 4.2 for each step and then applying Lemma 3.1 to the result yields: Theorem 4.3. Let C be a class of graphs with bounded expansion. Let ψ(x) be a query of FO over a recoloring of σ C (0) with at least one free variable. Then one can compute a p and a simple quantifier-free formula φ(x) over a recoloring of σ C (p) such that:</p><formula xml:id="formula_29">∀f G ∈ C, we can construct in time O(||f G||) a graph f G ∈ C p such that φ(f G ) = ψ(f G).</formula><p>We will make use of the following useful consequence of Theorem 4.3:</p><p>Corollary 4.4. Let C be a class of graphs with bounded expansion and let ψ(x) be a formula of FO over σ C (0) with at least one free variable. Then, for all f G ∈ C, after a preprocessing in time O(||f G||), we can test, given ū as input, whether f G |= ψ(ū) in constant time.</p><p>Proof. By Theorem 4.3 it is enough to consider quantifier-free simple queries. Hence it is enough to consider a query consisting in a single atom of either P (x) or P (f (x)) or x = f (y) or f (x) = g(y).</p><p>During the preprocessing phase we associate to each node v of the input graph a list L(v) containing all the predicates satisfied by v and all the images of v by a function symbol from the signature. This can be computed in linear time by enumerating all relations of the database and updating the appropriate lists with the corresponding predicate or the corresponding image. Now, because we use the RAM model, given u we can in constant time recover the list L(u). Using those lists it is immediate to check all atoms of the formula in constant time.</p><p>Theorem 4.1 is a direct consequence of Theorem 4.3 and Corollary 4.4: Starting with a sentence, and applying Theorem 4.3 for eliminating quantifiers from inside out we end up with a Boolean combination of formulas with one variable. Each such formula can be tested in O(||f G||) by iterating through all nodes v of f G and in constant time (using Corollary 4.4) checking if v can be substituted for the sole existentially quantified variable.</p><p>On top of Theorem 4.1 the following corollary is immediate from Theorem 4.3 and Corollary 4.4: Corollary 4.5. Let C be a class of graphs with bounded expansion and let ψ(x) be a formula of FO over σ C (0) with one free variable. Then, for all f G ∈ C, computing the set ψ(f G) can be done in time O(||f G||).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Enumeration</head><p>In this section we consider first-order formulas with free variables and show that we can enumerate their answers with constant delay over any class with bounded expansion. Moreover, assuming a linear order on the domain of the input structure, we will see that the answers can be output in the lexicographical order. As before we only state the result for graphs, but it immediately extends to arbitrary structures by Lemma 2.6.</p><p>Theorem 5.1. Let C be a class of graphs with bounded expansion and let φ(x) be a first-order query. Then the enumeration problem of φ over C is in CD•Lin. Moreover, in the presence of a linear order on the vertices of the input graph, the answers to φ can be output in lexicographical order.</p><p>The proof of Theorem 5.1 is by induction on the number of free variables of φ. The unary case is done by Corollary 4.5. The inductive case is a simple consequence of the following: Proposition 5.2. Let C be a class of graphs with bounded expansion and let φ(xy) be a first-order query or arity 2 or more. Let G be a graph of C. Let &lt; be any linear order on the nodes of G. After a preprocessing working in time linear in the size of G we can, on input a tuple ā of nodes of G, enumerate with constant delay and in the order given by &lt; all b such that G |= φ(āb) or answer nill if no such b exists.</p><p>Proof. Fix a class C of graphs with bounded expansion and a query φ(xy) with k ≥ 2 free variables. Let f G be the functional representation of the input graph and V be its set of vertices. Let &lt; be any order on V .</p><p>During the preprocessing phase, we apply Theorem 4.3 to get a simple quantifier-free query ϕ(xy) and a structure f G ∈ C p , for some p that does not depend on f G, such that ϕ(f G ) = φ(f G) and f G can be computed in linear time from f G.</p><p>Furthermore we normalize the resulting simple quantifier-free query using Proposition 3.3, and obtain an equivalent quantifier-free formula ψ and a structure f G ∈ C q , where q depends only on p and ϕ, f G can be computed in linear time from f G , ϕ(f G ) = ψ(f G ) and ψ is a disjunction of formulas of the form (3.1):</p><formula xml:id="formula_30">ψ 1 (x) ∧ τ (y) ∧ ∆ = (xy) ∧ ∆ = (xy),</formula><p>where ∆ = (xy) is either empty or contains one clause of the form y = f (x i ) or one clause of the form f (y) = g(x i ) for some i, f and g; and ∆ = (xy) contains arbitrarily many clauses of the form y = f (x i ) or f (y) = g(x j ).</p><p>In view of Lemma 2.1 it is enough to treat each disjunct separately. In the sequel we then assume that ψ has the form described in (3.1). We let ψ (y) be the formula ∃xψ(xy) and ψ (x) the formula ∃yψ(xy).</p><p>If ∆ = contains an equality of the form y = f (x i ) we then use Corollary 4.4 and test whether f G |= ψ(āf (a i )) and we are done as f (a i ) is the only possible solution for ā.</p><p>Assume now that ∆ = is either empty or of the form f (y) = g(x i ). We first precompute the set of possible candidates for y (i.e. those y satisfying ψ ) and distribute this set within their images by f . In other words we define a function</p><formula xml:id="formula_31">L : V → 2 V such that L(w) = {u | w = f (u) ∧ u ∈ ψ (f G )}.</formula><p>In the specific case where ∆ = is empty we pick an arbitrary node w 0 in f G and set L(w 0 ) = ψ (f G ) and L(w) = ∅ for w = w 0 . This can be done in linear time by the following procedure. We first use Corollary 4.5 and compute in linear time the set ψ (f G ). We next initialize L(w) to ∅ for each w ∈ V . Then, for each u ∈ ψ (f G ), we add u to the set L(f (u)).</p><p>Let W be the function from V k-1 to V such that W (v) = g(v i ). In the specific case where ∆ = is empty we set W (v) = w 0 , where w 0 is the node chosen above.</p><p>Notice that for each vu, f G |= ψ(vu) implies u ∈ L(W (v)) and if u ∈ L(W (v)) then ∆ = (vu) is true. Hence, given ā it remains to enumerate within L(W (ā)) the nodes b satisfying ∆ = (āb).</p><p>To do this with constant delay, it will be important to jump from an element u of L(w) to the smallest (according to &lt;) element u ≥ u of L(w) satisfying the inequality constraints.</p><p>For this we define for S 1 , . . . , S α C (q) ⊆ V the element next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) to be the first element w ≥ u of L(f (u)) 1 such that f 1 (w) / ∈ S 1 , . . . , and f α C (q) (w) / ∈ S α C (q) . If such w does not exist, the value of next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) is NULL. When all S i are empty, we write next ∅ (u) and by the above definitions we always have next ∅ (u) = u. We denote such functions as shortcut pointers of u. The size of a shortcut pointer next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) is the sum of sizes of the sets S i .</p><p>In order to avoid writing too long expressions containing shortcut pointers, we introduce the following abbreviations:</p><formula xml:id="formula_32">• next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) is denoted with next S (u), • next f 1 ,S 1 ,...,f i ,S i ∪{u i },...,f α C (q) ,S α C (q) (u) is denoted with next S[S i +={u i }] (u). Set γ q = (k -1) • α C (q) 2 .</formula><p>1 In order to simplify the notations we consider explicitly the case where ∆ = is not empty. If empty then L(f (u)) should be replaced by L(w0).</p><p>Computing all shortcut pointers of size γ q would take more than linear time. We therefore only compute a subset of those, denoted SC L , that will be sufficient for our needs. SC L is defined in an inductive manner. For all u such that u ∈ L(f (u)), next ∅ (u) ∈ SC L . Moreover, if the shortcut pointer next S (u) ∈ SC L is not NULL and has a size smaller than γ q , then, for each i, next S[S i +={u i }] (u) ∈ SC L , where u i = f i (next S (u)). We then say that next S (u) is the origin of next S[S i +={u i }] (u). Note that SC L contains all the shortcut pointers of the form next f i ,{f i (u)} (u) for u ∈ L(f (u)) and these are exactly the shortcut pointers of u of size 1. By SC L (u) ⊆ SC L we denote the shortcut pointers of u that are in SC L .</p><p>The set SC L contains only a constant number of shortcut pointers for each node u.</p><p>Claim 5.3. There exists a constant ζ(q, k) such that for every node u we have</p><formula xml:id="formula_33">|SC L (u)| ≤ ζ(q, k).</formula><p>Proof. The proof is a direct consequence of the recursive definition of SC L (u). Fix u.</p><p>Note that there is exactly 1 shortcut pointer of u of size 0 (namely next ∅ (u)) and α C (q) shortcut pointers of u of size 1. By the definition of SC L , any shortcut pointer next S (u) can be an origin of up to α C (q) shortcut pointers of the form next S[S i +={u i }] (u), where</p><formula xml:id="formula_34">u i = f i (next S (u)</formula><p>) and the size of next S[S i +={u i }] (u) is the size of next S (u) plus 1. This way we see that SC L (u) contains up to α C (q) 2 shortcut pointers of size 2 and, in general, up to α C (q) s shortcut pointers of size s. As the maximal size of a computed shortcut pointer is bounded by γ q , we have |SC L (u)| ≤ 0≤i≤γq α C (q) i . Both α C (q) and γ q depend only on q and k, which concludes the proof.</p><p>Moreover SC L contains all what we need to know.</p><p>Claim 5.4. Let next S (u) be a shortcut pointer of size not greater than γ q . Then there exists next S (u) ∈ SC L such that next S (u) = next S (u). Moreover, such next S (u) can be found in constant time.</p><p>Proof. If next S (u) ∈ SC L , then we have nothing to prove. Assume then that next S (u) / ∈ SC L . We write next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) if for each 1 ≤ i ≤ α C (q) we have S i ⊆ S i . Note that for a given u the relation is a partial order on the set of shortcut pointers of u.</p><formula xml:id="formula_35">A trivial observation is that if next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u), then next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u) ≤ next f 1 ,S 1 ,...,f α C (q) ,S α C (q) (u).</formula><p>Let next S (u) ∈ SC L be a maximal in terms of size shortcut pointer of u such that next S (u) next S (u). Such a shortcut pointer always exists as next ∅ (u) next S (u) and next ∅ (u) ∈ SC L . Note that the size of next S (u) is strictly smaller than the size of next S (u), so it is strictly smaller than γ q . One can find next S (u) by exploring all the shortcut pointers of u in SC L (u). This can be done in constant time using Claim 5.3.</p><p>We now claim that next S (u) = next S (u). Let v = next S (u). We know that v ≤ next S (u). Assume now that there would exists 1 ≤ i ≤ α C (q) such that f i (v) ∈ S i . Then we have that next S [S i +={u i }] (u) ∈ SC L , where u i = f i (v), and this contradicts the maximality of next S (u). This means that such an i does not exist and concludes the fact that next S (u) = next S (u).</p><p>The following claim guarantees that SC L can be computed in linear time and has therefore a linear size. This concludes the proof of the theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Counting</head><p>In this section we investigate the problem of counting the number of solutions to a query, i.e. computing |q(D)|. As usual we only state and prove our results over graphs but they generalize to arbitrary relational structures via Lemma 2.6. Theorem 6.1. Let C be class of graphs with bounded expansion and let φ(x) be a first-order formula. Then, for all f G ∈ C, we can compute |φ(f G)| in time O(||f G||).</p><p>Proof. The key idea is to prove a weighted version of the desired result. Assume φ(x) has exactly k free variables and for 1 ≤ i ≤ k we have functions # i : V → N. We will compute in time linear in ||f G|| the following number:</p><formula xml:id="formula_36">|φ(f G)| # := ū∈φ(f G) 1≤i≤k # i (u i ).</formula><p>By setting all # i to be constant functions with value 1 we get the regular counting problem. Hence Theorem 6.1 is an immediate consequence of the next lemma. Lemma 6.2. Let C be class of graphs with bounded expansion and let φ(x) be a first-order formula with exactly k free variables. For 1 ≤ i ≤ k let # i : V → N be functions such that for each v the value of # i (v) can be computed in constant time. Then, for all f G ∈ C, we can compute |φ(f G)| # in time O(||f G||).</p><p>Proof. The proof is by induction on the number of free variables.</p><p>The case k = 1 is trivial: in time linear in ||f G|| we compute φ(f G) using Corollary 4.5. By hypothesis, for each v ∈ φ(f G), we can compute the value of # 1 (v) in constant time. Therefore the value</p><formula xml:id="formula_37">|φ(f G)| # = v∈φ(f G) # 1 (v)</formula><p>can be computed in linear time as desired. Assume now that k &gt; 1 and that x and y are the free variables of φ, where |x| = k -1. We apply Theorem 4.3 to get a simple quantifier-free query ϕ(xy) and a structure</p><formula xml:id="formula_38">f G ∈ C p , for some p that does not depend on f G, such that ϕ(f G ) = φ(f G) and f G can be computed in linear time from f G. Note that |φ(f G)| # = |ϕ(f G )| # ,</formula><p>so it is enough to compute the latter value. We normalize the resulting simple quantifier-free query using Proposition 3.3, and obtain an equivalent quantifier-free formula ψ and a structure f G ∈ C q , where q depends only on p and ϕ, f G can be computed in linear time from f G , ϕ(f G ) = ψ(f G ) and ψ is a disjunction of formulas of the form (3.1):</p><formula xml:id="formula_39">ψ 1 (x) ∧ τ (y) ∧ ∆ = (xy) ∧ ∆ = (xy),</formula><p>where ∆ = (xy) is either empty or contains one clause of the form y = f (x i ) or one clause of the form f (y) = g(x i ) for some suitable i, f and g; and ∆ = (xy) contains arbitrarily many clauses of the form y = f (x i ) or f (y) = g(x j ). Note that |ϕ(f G )| # = |ψ(f G )| # , so it is enough to compute the latter value.</p><p>Observe that it is enough to solve the weighted counting problem for each disjunct separately, as we can then combine the results using a simple inclusion-exclusion reasoning (the weighted sum for q ∨ q is obtained by adding the weighted sum for q to the weighted sum for q and then subtracting the weighted sum for q ∧ q ). In the sequel we then assume that ψ has the form described in (3.1).</p><p>The proof now goes by induction on the number of inequalities in ∆ = . While the inductive step turns out to be fairly easy, the difficult part is the base step of the induction.</p><p>We start with proving the inductive step. Let g(y) = f (x i ) be an arbitrary inequality from ∆ = (where g might possibly be the identity). Let ψ -be ψ with this inequality removed and ψ + = ψ -∧ g(y) = f (x i ). Of course ψ and ψ + have disjoint sets of solutions and we have:</p><formula xml:id="formula_40">|ψ(f G )| # = |ψ -(f G )| # -|ψ + (f G )| # .</formula><p>Note that ψ -and ψ + have one less conjunct in ∆ = . The problem is that ψ + is not of the form (3.1) as it may now contain two elements in ∆ = . However it can be seen that the removal of the extra equality in ∆ = as described in the proof of Proposition 3.3 does not introduce any new elements in ∆ = . Claim 6.3. . There exists a query ψ + NF such that: its size depends only on the size of ψ + , ψ + NF is in the normal form given by (3.1), it contains an inequality conjunct h(y) = g 1 (x i ) (where h might possibly be identity) iff ψ + also contains such conjunct and ψ + NF (f G ) = ψ + (f G ). Moreover, ψ + NF can be constructed in time linear in the size of ψ + . Proof. The proof is a simple case analysis of the content of ∆ = of ψ.</p><p>If its empty, then ψ + NF is already in the desired form. If it contains an atom of the form y = h 2 (x j ), then equality g(y) = f (x i ) is equivalent to g(h 2 (x j )) = f (x i ) and we are done.</p><p>If it contains an atom of the form h 3 (y) = h 2 (x j ) and g is identity, then h 3 (y) = h 2 (x j ) is equivalent to h 3 (f (x i )) = h 2 (x j ). If g is not identity, then τ (y) ensures us that either g(y) determines h 3 (y) or vice versa. If we have h 4 (g(y)) = h 3 (y), then h 3 (y) = h 2 (x j ) is equivalent to h 4 (f (x i )) = h 2 (x j ). The other case is symmetric.</p><p>The fact that ψ + NF does not contain any additional inequalities, that it can be computed in time linear in the size of ψ + and that ψ + NF (f G ) = ψ + (f G ) follows from the above construction.</p><p>We can therefore remove the extra element in ∆ + and assume that ψ + has the desired form. We can now use the inductive hypothesis on the size of ∆ = to both ψ -and ψ + in order to compute both |ψ -(f G )| # and |ψ + (f G )| # and derive |ψ(f G )| # .</p><p>It remains to show the base of the inner induction. In the following we assume that ∆ = is empty. The rest of the proof is a case analysis on the content of ∆ = .</p><p>Assume first that ∆ = consists of an atom of the form y = f (x 1 ).</p><p>Note that the solutions to ψ are of the form (vf (v 1 )). We have:</p><formula xml:id="formula_41">|ψ(f G )| # = (vu)∈ψ(f G )   # k (u) 1≤i≤k-1 # i (v i )   = (vf (v1))∈ψ(f G )   # k (f (v 1 )) 1≤i≤k-1 # i (v i )   = (vf (v1))∈ψ(f G )   # 1 (v 1 )# k (f (v 1 )) 2≤i≤k-1 # i (v i )  </formula><p>In linear time we now iterate through all nodes w in f G and set # 1 (w) := # 1 (w) • # k (f (w))</p><p># i (w) := # i (w) for 2 ≤ i ≤ k -1.</p><p>Let ϑ(x) be ψ with all occurrences of y replaced with f (x 1 ). We then have:</p><formula xml:id="formula_42">|ψ(f G )| # = (vf (v1))∈ψ(f G )   # 1 (v 1 ) 2≤i≤k-1 # i (v i )   = v∈ϑ(f G ) 1≤i≤k-1 # i (v i ) = |ϑ(f G )| #</formula><p>By induction on the number of free variables, as # i (w) can be computed in constant time for each i and w, we can compute |ϑ(f G )| # in time linear in ||f G || and we are done.</p><p>Assume now that ∆ = consists of an atom g(y) = f (x 1 ). Let ψ (y) be the formula ∃xψ(xy) and ψ (x) the formula ∃yψ(xy). We first compute set ψ (f G ) in linear time using Corollary 4.5. We now define a function # k : V → N as:</p><formula xml:id="formula_43"># k (w) := {u∈ψ (f G ) g(u)=w} # k (u).</formula><p>Note that this function can be easily computed in linear time by going through all nodes w and adding # k (w) to # k (g(w)). Finally we set:</p><p># 1 (w) := # 1 (w)# k (f (w))</p><p># i (w) := # i (w) for 2 ≤ i ≤ k -1.</p><p>Let u 1 , u 2 ∈ ψ (f G ) be such that g(u 1 ) = g(u 2 ). Because ∆ = is empty, observe that f G |= ∀x(ψ(xu 1 ) ↔ ψ(xu 2 )). Based on this observation we now group the solutions to ψ according to their last k -1 values and get:</p><formula xml:id="formula_44">|ψ(f G )| # = (vu)∈ψ(f G )   # k (u) 1≤i≤k-1 # i (v i )   = v∈ψ (f G ) {u∈ψ (f G ) g(u)=f (v1)}   # k (u) 1≤i≤k-1 # i (v i )   = v∈ψ (f G )      {u∈ψ (f G ) g(u)=f (v1)} # k (u)      1≤i≤k-1 # i (v i ) = v∈ψ (f G )   # k (f (v 1 )) 1≤i≤k-1 # i (v i )   = v∈ψ (f G )   # 1 (v 1 )# k (f (v 1 )) 2≤i≤k-1 # i (v i )   = v∈ψ (f G ) 1≤i≤k-1 # i (v i ) = |ψ (f G )| #</formula><p>By induction on the number of free variables, as # i (w) can be computed in constant time for each i and w, we can compute |ψ (f G )| # and we are done with this case.</p><p>The remaining case when ∆ = is empty is handled similarly to the previous one. We then have ψ(xy) = ψ 1 (x) ∧ τ (y). As we said earlier, Theorem 6.1 is an immediate consequence of Lemma 6.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>Queries written in first-order logic can be efficiently processed over the class of structures having bounded expansion. We have seen that over this class the problems investigated in this paper can be computed in time linear in the size of the input structure. The constant factor however is high. The approach taken here, as well as the ones of <ref type="bibr" target="#b8">[DKT13,</ref><ref type="bibr" target="#b10">GK11]</ref>, yields a constant factor that is a tower of exponentials whose height depends on the size of the query. This nonelementary constant factor is unavoidable already on the class of unranked trees, assuming FPT =AW[ * ] <ref type="bibr" target="#b9">[FG04]</ref>. In comparison, this factor can be triply exponential in the size of the query in the bounded degree case <ref type="bibr" target="#b21">[See96,</ref><ref type="bibr" target="#b14">KS11]</ref>.</p><p>Since the submission of this work, the result has been extended to a larger class of structures. In <ref type="bibr" target="#b19">[NdM11]</ref> the class of nowhere dense graphs was introduced and it generalizes the notion of bounded expansion. It has been shown that the model checking problem of first-order logic can be done in nearly linear time (i.e. for any &gt; 0 it can be done in O(n 1+ )) over any nowhere dense class of graph <ref type="bibr" target="#b11">[GKS17]</ref>. Recently an enumeration procedure has been proposed for first-order queries over nowhere dense graph classes, with a nearly linear preprocessing time and constant delay <ref type="bibr" target="#b22">[SSV18]</ref>.</p><p>For graph classes closed under substructures, the nowhere dense property seems to be the limit for having good algorithmic properties for first-order logic. Indeed, it is known that the model checking problem of first-order logic over a class of structures that is not nowhere dense cannot be FPT <ref type="bibr" target="#b13">[KD09]</ref> (modulo some complexity assumptions).</p><p>For structures of bounded expansion, an interesting open question is whether a sampling of the solutions can be performed in linear time. For instance: can we compute the j-th solution in constant time after a linear preprocessing? This can be done in the bounded degree case <ref type="bibr" target="#b5">[BDGO08]</ref> and in the bounded treewidth case <ref type="bibr" target="#b3">[Bag09]</ref>. We leave the bounded expansion case for future research.</p><p>Finally it would be interesting to know whether the index structure computed in linear time for the enumeration process could be updated efficiently. In the boolean case, queries of arity 0, updates can be done in constant time <ref type="bibr" target="#b8">[DKT13]</ref>, assuming the underlying graph is not changed too much. In particular a relabeling of a node require only constant update time. It would be interesting to know whether this constant update time could also be achieved for an index structure allowing for constant delay enumeration.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>clear from the context. We use a standard notion of size. The size of R D i , denoted ||R D i || is the number of tuples in R D i multiplied by the arity r i . The size of the domain of D, denoted |D|, is the number of elements in D. Finally the size of D, denoted by ||D||, is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Theorem 4.1. [DKT13] Let C be a class of graphs with bounded expansion and let ψ be a sentence of FO. Then, for all f G ∈ C, testing whether f G |= ψ can be done in time O(||f G||).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>After setting # 1 (w) := # 2 (w) • u∈τ (f G ) # 1 (u) # i (w) := # i+1 (w) for 2 ≤ i ≤ k -1 we see that |ψ(f G )| # = |ψ 1 (f G )| #and we conclude again by induction on the number of free variables.</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Claim 5.5. SC L can be computed in time linear in ||f G ||.</p><p>Proof. For every u we compute SC L (u) in time linear in the size of SC L (u). By Claim 5.3 the total time is linear in the size of V as claimed.</p><p>The computation of SC L (u) is done in reverse order on u: Assuming SC L (v) has been computed for all v &gt; u we compute SC L (u) time linear in the size of L(u).</p><p>Note that we only care to compute next S (u) when u ∈ L(u).</p><p>Consider a node u. If u is the maximaum vertex then all next S (u) are NULL. Assume now that u is not the maximum vertex and that for all v &gt; u SC L (v) has been computed. If u does not belong to L(u) we do nothing. If u ∈ L(u) we set next ∅ (u) = u and we construct SC L (u) by induction on the size.</p><p>Assume next S (u) ∈ SC L has already been computed. Let v = next S (u) and assume it is not NULL. Let S = S[S i += {f i (v)}] and assume next S (u) ∈ SC L (u).</p><p>It is easy to see that next S (u) = next S (v). By Claim 5.4 we can obtain in constant</p><p>The computation of SC L concludes the preprocessing phase and it follows from Claim 5.5 that it can be done in linear time. We now turn to the enumeration phase.</p><p>Assume we are given ā. In view of Corollary 4.4 we can without loss of generality assume that ā is such that G |= ψ (ā). If not we simply return nill and stop here.</p><p>By construction we know that all nodes b such that f G |= ψ(āb) are in L = L(W (ā)). Recall also that all elements b ∈ L make τ (b) ∧ ∆ = (āb) true. For 1 ≤ i ≤ α C (q) we set By the definition of sets S i and next S (b), for each b ≤ v &lt; b there is a i and j such that g(a j ) = f i (v) and g(x j ) = f i (y) is a conjunct of ∆ = . This way the algorithm does not skip any solutions at Step 1 and so it outputs exactly all solutions.</p><p>It remains to show that there is a constant time between any two outputs.</p><p>Step 1 takes constant time due to Claim 5.4. From there the algorithm either immediately outputs a solution at Step 2 or jumps to Step 3. In the second case, this means that f G |= ψ(āb ), but from the definitions of list L, sets S i and shortcut pointers next S (b) this can only happen if ∆ = is falsified and this is because of an inequality of the form y = g(x j ) for some suitable g and j (where g may possibly be identity). Hence b = g(a j ). As all the elements on L are distinct, the algorithm can skip over Step 2 up to (k -1) • (α C (q) + 1) times for each tuple ā (there are up to that many different images of nodes from ā under α C (q) different functions). The delay is therefore bounded by k • (α C (q) + 1) consecutive applications of Claim 5.4.</p><p>As the list L was sorted with respect to the linear order on the domain, it is clear that the enumeration procedure outputs the set of solutions in lexicographical order.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Easy Problems for Tree-Decomposable Graphs</title>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Arnborg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Lagergren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Detlef</forename><surname>Seese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Algorithms</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="308" to="340" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Color-Coding</title>
		<author>
			<persName><forename type="first">Noga</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raphael</forename><surname>Yuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uri</forename><surname>Zwick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="844" to="856" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">MSO Queries on Tree Decomposable Structures Are Computable with Linear Delay</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Computer Science Logic (CSL)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="167" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
		<title level="m">Algorithmes et complexité des problèmes d&apos;énumération pour l&apos;évaluation de requêtes logiques</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Université de Caen</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On Acyclic Conjunctive Queries and Constant Delay Enumeration</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Grandjean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Computer Science Logic (CSL)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="208" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Computing the jth solution of a first-order query</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Grandjean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Olive</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RAIRO Theoretical Informatics and Applications</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="147" to="164" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Graph Rewriting: An Algebraic and Logic Approach</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Theoretical Computer Science</title>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="193" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">First-order queries on structures of bounded degree are computable with constant delay</title>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Grandjean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Computational Logic (ToCL)</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Testing first-order properties for subclasses of sparse graphs</title>
		<author>
			<persName><forename type="first">Zdenek</forename><surname>Dvorak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Král</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robin</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="36" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The complexity of first-order and monadic second-order logic revisited</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Frick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Pure Appl. Logic</title>
		<imprint>
			<biblScope unit="volume">130</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="3" to="31" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Model Theoretic Methods in Finite Combinatorics, chapter Methods for Algorithmic Meta Theorems</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Kreutzer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Deciding first-order properties of nowhere dense graphs</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Kreutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Siebertz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="17" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Query evaluation with constant delay</title>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Kazana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">L&apos;évaluation de requêtes avec un délai constant</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>École normale supérieure de Cachan</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parameterized complexity of first-order logic</title>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Kreutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anuj</forename><surname>Dawar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Electronic Colloquium on Computational Complexity</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page">131</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">First-order query evaluation on structures of bounded degree</title>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Kazana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science (LMCS)</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Enumeration of first-order queries on classes of structures with bounded expansion</title>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Kazana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="297" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Enumeration of monadic second-order queries on trees</title>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Kazana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Computational Logic (ToCL)</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Grad and classes with bounded expansion I. Decompositions</title>
		<author>
			<persName><forename type="first">Jaroslav</forename><surname>Nešetřil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrice Ossona De</forename><surname>Mendez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eur. J. Comb</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="760" to="776" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Grad and classes with bounded expansion II</title>
		<author>
			<persName><forename type="first">Jaroslav</forename><surname>Nešetřil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrice Ossona De</forename><surname>Mendez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmic aspects</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="777" to="791" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note>Eur. J. Comb.</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On nowhere dense graphs</title>
		<author>
			<persName><forename type="first">Jaroslav</forename><surname>Nešetřil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrice Ossona De</forename><surname>Mendez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European J. of Combinatorics</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="600" to="617" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the Complexity of Database Queries</title>
		<author>
			<persName><forename type="first">Christos</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mihalis</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. on Computer and System Sciences (JCSS)</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="407" to="427" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Linear Time Computable Problems and First-Order Descriptions</title>
		<author>
			<persName><forename type="first">Detlef</forename><surname>Seese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="505" to="526" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Enumeration for FO queries over nowhere dense graphs</title>
		<author>
			<persName><forename type="first">Nicole</forename><surname>Schweikardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Vigny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="151" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Constant delay enumeration for FO queries over databases with local bounded expansion</title>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Vigny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Database Theory</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
