<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How to use Model Checking for Diagnosing Fault Patterns in Petri nets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Johanne</forename><surname>Bakalara</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LAAS-CNRS</orgName>
								<orgName type="institution" key="instit1">Université de Toulouse</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">INSA</orgName>
								<address>
									<settlement>Toulouse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yannick</forename><surname>Pencolé</surname></persName>
							<email>ypencole@laas.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LAAS-CNRS</orgName>
								<orgName type="institution" key="instit1">Université de Toulouse</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">INSA</orgName>
								<address>
									<settlement>Toulouse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Audine</forename><surname>Subias</surname></persName>
							<email>subias@laas.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LAAS-CNRS</orgName>
								<orgName type="institution" key="instit1">Université de Toulouse</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">INSA</orgName>
								<address>
									<settlement>Toulouse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">How to use Model Checking for Diagnosing Fault Patterns in Petri nets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">59BD2944151507A5020D75EAE220744C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Diagnosis</term>
					<term>model checking</term>
					<term>fault patterns</term>
					<term>Petri net</term>
					<term>Linear Time Logic</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper deals with the problem of fault pattern diagnosis in discrete event systems modelled by Petri nets. A general framework for implementing a pattern diagnosis function by model-checking is proposed. Two different approaches with experimental results are presented and compared to a third approach from the literature.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>The original problem of diagnosis in discrete event systems as introduced in <ref type="bibr" target="#b9">Sampath et al. (1995)</ref> is to determine the occurrence of a fault in a system, the fault being modelled by a single event. In this work, our objective is to consider the diagnosis of a fault event but also the diagnosis of more complex faulty behaviours (called fault patterns) that cannot be modelled by a simple event (see <ref type="bibr" target="#b5">Jéron et al. (2006)</ref>, <ref type="bibr" target="#b2">Boussif and Ghazel (2018)</ref>). Indeed, for some systems, a change in the order of occurrence of the events, or the joint occurrence of specific events, or the multiple occurrence of a specific type of event may reflect a faulty behaviour. This paper addresses the pattern diagnosis problem that has been introduced in <ref type="bibr" target="#b8">Pencolé and Subias (2017)</ref> for Petri nets. The objective is to investigate several manners to solve the problem that use model-checking techniques <ref type="bibr" target="#b3">(Clarke et al. (1999)</ref>). The advantages of model checking methods are numerous: speed, no proof building, many logics allowing to express large numbers of properties, generation of counter-examples. Model-checking has been well studied for many years and many techniques are used to counter the main obstacle of the combinatorial explosion (e.g. abstraction, symmetries, reduction). The objective of this article is to consider a range of approaches based on model checking to solve the pattern diagnosis problem and to compare their advantages and drawbacks. The proposed approaches solve the same problem but differ in the way they represent the three elements that define a diagnosis problem: the system, the faulty behaviour and the sequence of events observed. The paper is organized as follows. The problem statement is presented in Section 2 followed by the description of the general method to solve the pattern diagnosis problem with a model-checking approach. Section 3 then presents a first method in which the faulty behaviour and the observations are directly expressed as a complex property to be verified in the system's model. A first series of experimental results are then presented in Section 4 and compared with a method proposed in <ref type="bibr" target="#b8">Pencolé and Subias (2017)</ref>. Based on these results, a second approach is proposed in Section 5 and compared with the others. Finally, conclusions and some perspectives are given in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PROBLEM STATEMENT</head><p>The system is modeled as a classical bounded labeled Petri net, denoted LPN (possibly with transition priorities and arc inhibitors): some labels represent observable events (Σ o = {o 1 , ..., o p }) and the others represent silent/unobservable events (Σ u = {uo 1 , ..., uo m }). A run of the system is a sequence of fired transitions from an initial marking and generates a word ρ ∈ (Σ u ∪ Σ o ) * . Now, given a sequence of observed events from the system, denoted σ ∈ Σ * o , the Ω-diagnosis problem consists in determining whether an unobservable pattern of events Ω has occurred or not. A pattern of events Ω denotes a complex assembling of events (a set of words from Σ * u ) and we say that Ω has occurred in a run if the run generates a word ρ that contains as a subword one of the words of Ω (see <ref type="bibr" target="#b8">Pencolé and Subias (2017)</ref> for more details). To solve this problem, the objective is to design a diagnosis function ∆ that returns one of the three results: Ω F aulty if the pattern has certainly occurred (any run of the system that generates σ is a run where Ω occurred), Ω Absent if the pattern is certainly absent (no run of the system that generates σ is a run where Ω occurred) and Ω Ambiguous otherwise. In this paper we investigate several approaches to design ∆ by using a model-checking tool called TINA (TIme petri Net Analyzer http://www.laas.fr/tina/) that is able to check properties over LPN and compare them with the one of <ref type="bibr" target="#b8">Pencolé and Subias (2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Background on model checking</head><p>A model-checking problem consists in checking whether some given states (or runs) of a formal model M satisfy a given property φ encoded in a formula of some temporal logic <ref type="bibr" target="#b3">(Clarke et al. (1999)</ref>). A model-checking tool checks if M satisfies φ (denoted M |= φ) i.e if φ is true in all the worlds of M. To do so, one solution is the automata based approach of model-checking. In this case the problem is translated to a language intersection problem by converting M and ¬φ as Büchi automata. The Büchi automaton of M generates the infinitely long words of L ω (M) describing the set of runs of M while the Büchi automaton of ¬φ generates the infinitely long words of L ω (¬φ) where ¬φ holds. The model-checker then checks for L(M)∩L(¬φ) = ∅. If the intersection is empty, then M |= φ, otherwise M |= φ and a counterexample is returned as a word of L(M)∩L(¬φ). Linear temporal logic (LTL) can be used to express the properties so that their statements can easily be transformed in automata. TINA is a model-checking tool that converts any LPN into a specific enriched Kripke structure M <ref type="bibr" target="#b1">(Berthomieu et al. (2004)</ref>, <ref type="bibr" target="#b0">Berthomieu et al. (2007)</ref>) and checks properties φ that are written in State/Event LTL (SE-LTL) logic. A formula φ is a SE-LTL formula if it is a universally quantified formula φ ::= ∀ϕ where ϕ ::</p><formula xml:id="formula_0">= cst | r | ¬ϕ | ϕ ∨ ϕ | ϕ∧ϕ | ϕ | ϕ | ♦ϕ | ϕ ϕ.</formula><p>The constant cst can be ⊥ (false), (true), dead (deadlock), div (temporal divergence), sub (partially known state). r denotes constraints e e with ∈ {=, &lt;, &gt;, ≤, ≥} between arithmetical expressions e involving place and transition symbols from the underlying LPN. Finally, modal operators , , ♦, are respectively the operators next, always, eventually and until. SE-LTL expresses formulas about places and transitions of Petri nets, however, all along the paper, we will express SE-LTL formulas with events from Σ u ∪ Σ o .</p><p>An event e being the label of one or several transitions t 1 , . . . , t n of the net, by writing e in any of the following formula we actually write the underlying SE-LTL formula</p><formula xml:id="formula_1">(t 1 ∧ ¬(t 2 ∨ • • • ∨ t n )) ∨ (t 2 ∧ ¬(t 1 ∨ t 3 • • • ∨ t n )) ∨ . .</formula><p>. that asserts that one (and only one) transition labeled with e is fired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">General principle for implementing a diagnosis function by model-checking</head><p>Algorithm 1 describes the general diagnosis algorithm implementing the diagnosis function ∆ by model-checking. M denotes the formal model that is investigated while Ψ ¬Ω is a SE-LTL formula corresponding to the question: are we sure that pattern Ω never occurred in a run consistent with the observation sequence σ? If the result is true, ∆ can immediately returns Ω Absent . If not, a new question Ψ Ω is asked: are we sure that Ω always occurred in all the sequences consistent with σ? If the result is true, ∆ can return Ω F aulty , otherwise we are sure there is an ambiguity (∆ returns Ω Ambiguous ).</p><p>Algorithm 1 Diagnosis algorithm ∆ by model-checking </p><formula xml:id="formula_2">1: if M |= Ψ ¬Ω then 2: return ∆(σ) = Ω Absent 3: else if M |= Ψ Ω then</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A PURE MODEL-CHECKING APPROACH</head><p>This section presents a method that is called pure modelchecking approach (denoted PURE for short). It is called pure in the sense that the method aims at fully encoding the pattern diagnosis problem with the questions Ψ Ω and Ψ ¬Ω based on the model of the system that is encoded with M. There are actually two subproblems to solve. The first one is: what are the runs of the system that are consistent with σ? The second one is: among these runs, what are the ones where Ω has occurred and the ones where it has not. The two formulae Ψ ¬Ω (absence of Ω) and Ψ Ω (occurrence of Ω) are then as below:</p><formula xml:id="formula_3">Ψ ¬Ω : Φ σ ⇒ Φ ¬Ω Ψ Ω : Φ σ ⇒ Φ Ω (1)</formula><p>Φ σ is the part of the formula that expresses that any run of interests in the question is consistent with the observation sequence σ while Φ ¬Ω (resp. Φ Ω ) expresses that Ω has not occurred in any run (resp. Ω has occurred in any run). It follows that Ψ ¬Ω is true either if Ω does not occur in any run consistent with σ or if there is no run consistent with σ. For Ψ Ω , in the remainder it is supposed that the observed sequence is correct and that it always exists at least one run in the model of the system that is consistent with the observation σ. Therefore, Ψ Ω is true if Ω occurs in any run consistent with σ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Definition of Φ σ</head><p>Let us consider now the representation of the observation sequence σ in the SE -LT L formula (Φ σ ). We denote N OE the disjunction of all the unobservable events,</p><formula xml:id="formula_4">N OE = 1≤i≤m uo i = uo 1 ∨ uo 2 ... ∨ uo m with N OE =</formula><p>if the set is empty. An observation sequence σ = o 1 o 2 can be described by the following formula:</p><formula xml:id="formula_5">N OE (o 1 ∧ (N OE o 2 )).</formula><p>In other words, an observation sequence is a trace including some unobservable events (N OE) until ( ) an observable event o 1 and this event o 1 is directly followed ( ) by unobservable events (N OE) until ( ) o 2 . Note that the Until operator (a b) accepts the traces that satisfy a until b but also nothing before b. So, if no unobservable event occurs between the two observed events o 1 and o 2 in a run, this property holds in the run. In the general case an observation sequence σ of k = |σ| events is then recursively given by Φ σ = ϕ 1 with ϕ n for n from (k -1) to 1 such that:</p><formula xml:id="formula_6">ϕ k = N OE o k ϕ n = N OE ( o n ∧ (ϕ n+1 ) )<label>(2)</label></formula><p>Let us consider σ = o 1 o 2 o 3 , ϕ 1 is given by:</p><formula xml:id="formula_7">ϕ 3 = N OE o 3 ϕ 2 = N OE (o 2 ∧ (ϕ 3 ))) = N OE (o 2 ∧ (N OE o 3 ))) ϕ 1 = N OE (o 1 ∧ (ϕ 2 ))) = N OE (o 1 ∧ (N OE (o 2 ∧ (N OE o 3 )))))) then Φ σ = ϕ 1 = N OE (o 1 ∧ (N OE (o 2 ∧ (N OE o 3 )))))).</formula><p>3.2 Definitions of Φ Ω , Φ ¬Ω : the single fault case</p><p>We consider first the single fault case: Ω is the occurrence of a single fault f ∈ Σ u . To define Φ f , Φ ¬f , we need to distinguish two cases: diagnosis problem with or without silent closure (introduced in <ref type="bibr" target="#b6">Lamperti and Zanella (2003)</ref>).</p><p>In the case that the diagnoser does not want to address the silent closure issue (i.e. the diagnosis function does not look for what could have happened after the last observed event of σ), only unobservable events occurring before or during executions that are consistent with the observation sequence σ are considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Diagnosis without silent closure</head><p>To check that the fault has not ocurred in any run (i.e Φ ¬f ) it is necessary to express that the fault does not occur neither at the beginning of the observation nor between observable events. Note that at this stage only the relevant runs are considered due to the double implication of Equation (1). As an example let us consider an observation sequence σ = o 1 o 2 , any run in which Φ ¬f holds must be such that it does not include f until ( ) o 1 that is followed ( ) by some events that are not f until o 2 . This can be expressed by: (¬f (o 1 ∧ ( ¬f o 2 ))).</p><p>From this example it appears that the formula can be expressed in a recursive way such that: Φ ¬f = ϕ 1 with ϕ n for n from (k -1) to 1.</p><formula xml:id="formula_8">ϕ k = ¬ f o k ϕ n = ¬ f ( o n ∧ (ϕ n+1 ) )<label>(3)</label></formula><p>Let us consider the observation sequence σ = o 1 o 2 o 3 , ϕ 1 is then given recursively by:</p><formula xml:id="formula_9">ϕ 3 = ¬f o 3 ϕ 2 = ¬f (o 2 (∧ (ϕ 3 ))) = ¬f (o 2 (∧ (¬f o 3 ))) ϕ 1 = ¬f (o 1 (∧ (ϕ 2 ))) = ¬f (o 1 (∧ (¬f (o 2 (∧ (¬ f o 3 ))))) Then Φ ¬f = ¬f (o 1 (∧ (¬f (o 2 (∧ (¬f o 3 )))))</formula><p>Now let us define Φ f , we need to express that the fault may appear before the observed events or between the observed events. Let us consider a simple sequence of two events σ = o 1 o 2 . Any run where Φ f holds must include unobservable events different from f (N OE /{f } ) until f or the event o 1 directly followed by unobservable events different from f until f :</p><formula xml:id="formula_10">N OE /{f } (f ∨(o 1 ∧ (N OE /{f } f ))</formula><p>). This can be formalized in a recursive way by: Φ f = ϕ 1 with ϕ n for n from (k -1) to 1.</p><formula xml:id="formula_11">ϕ k = N OE /{f } f ϕ n = N OE /{f } (f ∨ ( o n ∧ (ϕ n+1 ) ) )<label>(4)</label></formula><p>To illustrate this formula let us consider σ = o 1 o 2 o 3 .</p><formula xml:id="formula_12">ϕ 3 = N OE /{f } f ϕ 2 = N OE /{f } (f ∨ (o 2 ∧ (ϕ 3 ))) = N OE /{f } (f ∨ (o 2 ∧ (N OE /{f } f ))) ϕ 1 = N OE /{f } (f ∨ (o 1 ∧ (ϕ 2 ))) = N OE /{f } (f ∨ (o 1 ∧ (N OE /{f } (f ∨ (o 2 ∧ (N OE /{f } f )))))) then Φ f = ϕ 1 = N OE /{f } (f ∨ (o 1 ∧ (N OE /{f } (f ∨ (o 2 ∧ (N OE /{f } f )))))).</formula><p>How to deal with silent closure By considering the silent closure, the diagnoser must now also take into account the fact that the fault can also occur after the last observed event. To check that the fault is absent all along the run, we then need to modify Φ ¬f . Let OE = 1≤i≤p o i = o 1 ∨ o 2 ... ∨ o p be the disjunction of all observable events from Σ o . Let us consider an observation sequence σ = o 1 o 2 . The runs that we want to characterize with Φ ¬f do not include the fault event f until o 1 , that is followed by unobservable events different from f until o 2 , that is followed by unobservable events different from f until any observable event. So by generalizing, the formula Φ ¬f is given in a recursive way as Φ ¬f = ϕ 1 with ϕ n for n from k to 1.</p><formula xml:id="formula_13">ϕ k+1 = ¬ f OE ϕ n = ¬ f ( o n ∧ (ϕ n+1 ) )<label>(5)</label></formula><p>Suppose now that M |= Φ σ ⇒ Φ ¬f is true, the diagnosis function stops and returns f Absent (see Algorithm 1). If it is not true, suppose that f occurs before the last observed event in every run such that Φ σ holds, then with the previous formula Φ f , M |= Φ σ ⇒ Φ f is true and ∆ returns f F aulty . Finally, if there is a run, such that Φ σ holds, in which f occurs only after the last observed event, then there is also a run, such that Φ σ holds, in which f does not occur at all (it is a prefix of the previous run) so in this last case, ∆ must return f Ambiguous . Therefore, the formula Φ f remains unchanged when dealing with silent closure, only Φ ¬f is modified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Extension to fault class diagnosis</head><p>We now propose to extend this pure model-checking approach to deal with a specific type of patterns called fault class. A fault class gathers a set of independent fault events denoted F = {f 1 , f 2 , .., f q } ⊆ Σ u . Following Algorithm 1, the diagnosis principle is to check first that no fault of the class has occurred in a run of the system consistent with the observation sequence. If the result is true (i.e. M |= Ψ ¬F ), the diagnosis result is F Absent i.e it is sure that the fault class has not occurred. Otherwise, if in any system's run consistent with the observations σ, at least one fault of the class F has occurred, the diagnosis result is F F aulty . Finally, ∆ returns F Ambiguous if there are at least two runs consistent with σ such that one contains at least a fault of the class F and the other run does not contain any fault of the class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fault class diagnosis without silent closure</head><p>The SE-LTL formula that checks the absence of a fault class is similar to the one proposed in the case of simple fault where the simple fault event f is replaced by F that denotes the disjunction of all the faults of F: F = f ∈F f . Then Φ ¬F = ϕ 1 with ϕ n for n from (k -1) to 1.</p><formula xml:id="formula_14">ϕ k = ¬F o k ϕ n = ¬F (o n ∧ (ϕ n+1 )) (6)</formula><p>Formula Φ F is also derived from the simple case (see Equation ( <ref type="formula" target="#formula_11">4</ref>)). Φ F = ϕ 1 with ϕ n for n from (k -1) to 1.</p><formula xml:id="formula_15">ϕ k = N OE /F F ϕ n = N OE /F (F ∨ ( o n ∧ (ϕ n+1 )))</formula><p>Case of the silent closure For the absence of fault class with the silent closure, the formula is similar to the one given for the simple fault (see Equation ( <ref type="formula" target="#formula_13">5</ref>)) by replacing the event f by F . To check the occurrence of the fault class, the same formula as the one used in the case without the silent closure is considered for the same reason as in the simple fault case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">FIRST EXPERIMENTAL RESULTS</head><p>This section describes some experimental results about the PURE approach presented here above. These experiments are performed on the example from Pencolé and Subias (2017): a product transportation system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Product transportation system</head><p>The proposed example is a two-level system composed of two product sites (namely sites 1 and 2) at level 2 where a set of products is stored and two assembly stations at level 1 that request products from level 2. A lift is used between the two levels. Each site has a conveyor belt to move a product from the site to the lift and each station also has a conveyor belt to get the products from the lift. Figure <ref type="figure">1</ref> presents the system LPN model. Once a product is detected on the site 1, a Product1 signal (denoted P r1) is emitted. The product is then put in a box and becomes available. The box is then pushed and sent into the lift (action Push 1 that starts with event P 1 and ends with event EP 1 ). Site 2 behaves in a similar manner. A product from site 1 has a priority access to the lift. In the Petri net model of Figure <ref type="figure">1</ref>, this priority relation is indicated by a dashed edge between the transitions labeled by P 1 and P 2 . After a product has been pushed into the lift, the lift goes down (action Down) to reach level 1 (signal D detects the end of the Down action). At this level the box is directed to the station that makes the request (either request Req 1 or request Req 2 ). If it is request Req 1 , then the box is pushed on the conveyor belt of station 1 (action PushReq 1 that starts with event Req 1 and ends with event EPReq 1 ). Then the conveyor belt performs a move-left action (LeftReq 1 , ELReq 1 ) to deliver the box with the product and a moveright action to go back to initial position (RightReq 1 , ERReq 1 ). The behaviour of station 2 is similar except that its conveyor belt moves right first (RightReq 2 , ERReq 2 ) and then moves left (LeftReq 2 , ELReq 2 ). Once the box has been pushed on a conveyor belt, the lift goes up (action Up ending with the emission of signal U ) to level 2. In Figure <ref type="figure">1</ref> only underlined events are observable events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Results</head><p>The objective in this experimental setting is to diagnose the occurrence of the event Req1 based on σ : Pr1 Pr2 D U D ERReq2 ELReq2 ELReq1 ERReq1 U composed of ten observable events. In the approach that we already described, the Kripke structure M computed by TINA depends only on the system and has 204 states and 625 transitions. </p><formula xml:id="formula_16">P r1 T F Absent 12 P r2 T F Absent 14 D T F Absent 13 U F F Ambiguous 22 D F F Ambiguous 153 ERReq2 F F Ambiguous 197 ELReq2 F F Ambiguous 1076 ELReq1 F T Faulty 7121 ERReq1 F T Faulty 66799 U x x x x</formula><p>Table <ref type="table">2</ref>. Fault event diagnosis without silent closure sequence ? ( Ψ f ). Column 4 gives the diagnosis conclusion and the last column is the computation times obtained by TINA. Table <ref type="table">2</ref> presents the results in the case without silent closure. First of all, based on Table <ref type="table">2</ref>, the PURE approach gets the same results as for the method proposed in Pencolé and Subias (2017) (and denoted PROD here below). Also, if we compare both Tables, we can see that the results with the silent closure are sometimes more ambiguous (line 3) which is explained by the fact that Req1 may occur between the occurrence of D and U. Without the silent closure this possible occurrence is simply ignored (the diagnosis is Absent) while the diagnosis is Ambiguous when considering the silent closure. Now regarding the computation time, results show the computation time is not satisfactory as the computation time is exponential with the size of the observation sequence and PROD clearly outperforms PURE. A detailed analysis of the set of experiments indicates the source of the complexity problem. As explained in Section 2.1, one step of the model-checking is the computation of the language L(¬Φ), that is the conversion of the formula ¬Φ into its equivalent Büchi automaton and this conversion is unfortunately exponential to the length of formula Φ (i.e. O(2 |Φ| )) and so, by construction of the formula Ψ f , Ψ ¬f (see Section 3), PURE is exponential in the size of</p><formula xml:id="formula_17">σ (O(2 |Φ| ) = O(2 |σ| )).</formula><p>Looking now at the PROD method, this limitation is not present. Indeed, even if PROD follows the same algorithm (see Algorithm 1), the information stored in M and in Ψ Ω , Ψ ¬Ω are fundamentally different. PROD relies on a set of specific products of LPNs to gather in one single LPN the information about how a pattern Ω matches any single run of the system and how any single run of the system is consistent with σ. The size of M is in O(2 |σ| ) in PROD while in PURE the size of M does not depend on |σ|. Secondly, in PROD, the questions Ψ Ω , Ψ ¬Ω do not depend on the size of σ as opposed to the ones from PURE. As opposed to PROD, our objective is to benefit of the expressivity of SE-LTL to write pattern Ω and not as an LPN like in PROD. To avoid that Ψ Ω and Ψ ¬Ω depend on the size of σ, we propose a tradeoff between the PURE and PROD approaches. The idea is to synchronise first the system model with the observation sequence σ by classical transition fusion as in PROD to isolate the runs of the system consistent with the observation sequence. The result of this synchronisation is an LPN that would be converted as a Kripke structure M (in O(2 |σ| ) as in PROD) and Ψ Ω , Ψ ¬Ω would only characterize the pattern matching (independent from σ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">AN APPROACH OVER A MODEL SYNCHRONISED WITH THE OBSERVATIONS</head><p>This section describes the model-checking approach denoted SYN that is a compromise between PURE and PROD. The observed sequence σ is then modeled by a LPN O as a single sequence of places and transitions. A synchronised product between the LPN of the system and the LPN of the observation sequence is performed based on transition fusions (see <ref type="bibr" target="#b4">Hack (1975)</ref>). Figure <ref type="figure">2</ref> presents such a synchronisation. The SYN approach is still governed by Algorithm 1 and the formula Ψ Ω and Ψ ¬Ω still follow Equation (1). But now, as opposed with the PURE approach, and similarly to the PROD approach, Ψ σ consists in checking whether a system's run will eventually lead to a marking where p obs is marked in the synchronised LPN (see Figure <ref type="figure">2</ref>). It follows that in the SYN approach Φ σ = ♦ p obs whose length does not depend on |σ|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Diagnosis of a fault event</head><p>The objective is to check that no run consistent with the observations contains the fault event f at the beginning or between two observed events. The formula Φ ¬f is then given by: Φ ¬f = ¬(f ∧ (♦(o k ∧ p obs ))). Φ ¬f asserts Fig. <ref type="figure">2</ref>. σ on the left, the system on the right, the synchronisation below that fault f never occurs ( ¬) if in the future ( )<ref type="foot" target="#foot_0">1</ref> the system eventually leads (♦) to the firing of the last event of σ (o k ∧ p obs ). It is necessary to consider the sequence until the last observed event followed by p obs as the event o k is not a sufficient condition since the same event can be observed several times in the observation sequence, so its observation does not guarantee the end of the execution of the observation sequence. Moreover p obs is also not sufficient as it remains marked after the execution of the observations whereas some unobservable events can occur after the last observation. The formula Φ f is then given by Φ f = ♦(f ∧ (♦(o k ∧ p obs ))): it means the system will eventually (♦) fire f followed ( ) by a set of transitions to end as a run that is consistent with σ (o k ∧ p obs ). Unlike the PURE method, Φ f has a size independent of |σ|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Diagnosis of a fault class and multiple faults</head><p>The problem of fault class diagnosis can also be considered by replacing the event f by F the disjunction of all the faults of the class in the previous formulas Φ ¬f and Φ f as in the PURE method. Now we may also be interested in the diagnosis of multiple faults. Suppose for instance a fault class F = {f 1 , f 2 }, the multiple fault associated with F is the occurrence of fault f 1 and f 2 in the same run. To diagnose such a multiple fault, the formulas Φ ¬F , Φ F can be adapted:</p><formula xml:id="formula_18">Φ ¬F = ¬(ϕ 2 ) and Φ F = ϕ 2 where ϕ 2 = ♦(f 1 ∧ (♦(o k ∧ p obs ))))∧(♦(f 2 ∧ (♦(o k ∧ p obs ))).</formula><p>The problem can be generalised to F = {f 1 , f 2 , .., f q }, thus Φ ¬F = (¬(ϕ q )) and Φ F = ϕ q where ϕ q is such that</p><formula xml:id="formula_19">ϕ n = (ϕ n-1 ) ∧ (♦(f n ∧ (♦(o k ∧ p obs )))) ϕ 1 = (♦(f 1 ∧ (♦(o k ∧ p obs )))) (7)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Pattern diagnosis</head><p>With the SYN approach, the problem of fault event diagnosis can be extended to the fault pattern diagnosis that aims at diagnosing more complex faulty behaviours or any normal behaviour of interest <ref type="bibr">(Jéron et al. (2006), Pencolé and</ref><ref type="bibr" target="#b8">Subias (2017)</ref>). For instance a pattern can describe a sequence of n unobservable events: let us consider a pattern Ω 1 corresponding to the sequence e 1 e 2 e 3 . If Ω 1 occurs in a run then the run first leads to e 1 followed in the future by e 2 that is followed in the future by e 3 followed by the last observed event followed by end of synchronisation:</p><formula xml:id="formula_20">Φ Ω1 = ♦(e 1 ∧ (♦(e 2 ∧ (♦(e 3 ∧ (♦(o k ∧ p obs ))))))).</formula><p>And the absence Ω 1 in the run is characterized by the negation: Φ ¬Ω1 = (¬Φ Ω1 ). This approach allows also to consider more complex behaviour that one might want to diagnose. Let us come back to system of Figure <ref type="figure">1</ref>. Figure <ref type="figure" target="#fig_1">3</ref> describes a pattern Ω 2 (3, 2) that models 3 consecutive occurrences of events of type Req 1 that are not interleaved with any occurrence of Req 2 events (the left conveyor keeps having its requests fulfilled while the right conveyor gets stuck) and this pattern should occur 2 times (the pattern has a counter). This pattern is made up of normal events but defines a behaviour that could be unexpected (both conveyors at Level 1 should get items regularly).</p><p>In this case it is necessary first to express that in the future the event Req1 is not followed by Req2 until Req1 that is not followed by Req2 until Req1. Ξ = ♦(Req1 ∧ ((¬Req2 Req1) ∧ ((¬Req2 Req1))). Then, to check that the behaviour described above occurs twice the formula Φ Ω2(3,2) is given by: Φ Ω2(3,2) = Ξ ∧ (Ξ ∧ (♦(o k ∧ p obs ))). The absence of the pattern is checked through Φ ¬Ω2(3,2) = (¬(Φ Ω2(3,2) )).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Results analysis</head><p>The SYN approach handle more complex problems than the PURE approach with satisfactory size of observations but is still not as efficient as PROD (see Table <ref type="table" target="#tab_1">3</ref>). Based on the pattern Ω 2 (n, counter) of Figure <ref type="figure" target="#fig_1">3</ref>, several comparisons have been made with the PROD approach by selecting different values for n (the number of Req1 ), counter and the size of the observation sequence. As an example Table <ref type="table" target="#tab_1">3</ref> shows the results of the two approaches for one occurrence of five events Req1 without Req2, for ten occurrences of ten consecutive events Req1, with several sizes for the observation sequence. The SYN approach is efficient relatively to the size of the Kripke structure that only depends on the observation sequence. Nevertheless, for the same reason as for the PURE approach, SYN is limited by the length of the pattern formula, SYN must be only considered for small patterns only. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSION AND FUTURE WORK</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>actually an algorithm template as we have not yet defined what is M, Ψ ¬Ω and Ψ Ω . The next sections propose different methods and compare them.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Pattern Ω 2 (3, 2): 2 occurrences of 3 requests Req 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3 .</head><label>3</label><figDesc>This paper addresses the diagnosis of fault patterns in the context of Petri nets. This problem is formulated as Fault class diagnosis without silent closure a model checking problem using the TINA tool taking benefit of the expressivity of SE-LTL. According to the knowledge encoded in the question and in the model. several approaches are presented and compared. In our perspectives, we plan to investigate alternative approaches to keep a low complexity both in the formula and in the models given to the model checker. One direction would be to consider a new way for the intersection of Petri nets<ref type="bibr" target="#b7">(Lubat et al. (2019)</ref>). The applicability to online diagnosis is also an issue.</figDesc><table><row><cell>size</cell><cell>Req 1</cell><cell>counter</cell><cell>nS</cell><cell>nT</cell><cell>Diagnosis</cell></row><row><cell>SYN</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>2000</cell><cell>5</cell><cell>1</cell><cell>6601</cell><cell>8000</cell><cell>Ω F Absent</cell></row><row><cell>5000</cell><cell>5</cell><cell>1</cell><cell cols="2">16501 20000</cell><cell>Ω F Absent</cell></row><row><cell>2000</cell><cell>10</cell><cell>10</cell><cell>6601</cell><cell>8000</cell><cell>x</cell></row><row><cell>PROD</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>2000</cell><cell>5</cell><cell>1</cell><cell>1028</cell><cell>1223</cell><cell>Ω F Absent</cell></row><row><cell>5000</cell><cell>5</cell><cell>1</cell><cell cols="2">25988 30983</cell><cell>Ω F Absent</cell></row><row><cell>2000</cell><cell>10</cell><cell>10</cell><cell cols="2">10388 12383</cell><cell>Ω F Absent</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The next operator is used to traduce that the events f and o k are not simultaneous, but it is not mandatory.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Model checking bounded prioritized time Petri nets</title>
		<author>
			<persName><forename type="first">B</forename><surname>Berthomieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Peres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vernadat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Technology for Verification and Analysis</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The tool tina -construction of abstract state spaces for Petri nets and time Petri nets</title>
		<author>
			<persName><forename type="first">B</forename><surname>Berthomieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">O</forename><surname>Ribet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Vernadat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Production Research</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="2741" to="2756" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Formal verification of intermittent fault diagnosability of discrete-event systems using model-checking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boussif</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ghazel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Critical Computer-Based Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="193" to="213" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Model checking</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Peled</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>MIT press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Petri net languages</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hack</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
		</imprint>
		<respStmt>
			<orgName>M.I.T. Project MAC, Computation Structures Group, Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report 124</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Supervision patterns in discrete event systems diagnosis</title>
		<author>
			<persName><forename type="first">T</forename><surname>Jéron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Marchand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pinchinat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Cordier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th International Workshop on Discrete Event Systems</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="262" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Continuous diagnosis of discrete-event systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Lamperti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zanella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">14th International Workshop on Principles of Diagnosis DX</title>
		<imprint>
			<biblScope unit="volume">03</biblScope>
			<biblScope unit="page" from="105" to="111" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A State Class Construction for Computing the Intersection of Time Petri Nets Languages</title>
		<author>
			<persName><forename type="first">É</forename><surname>Lubat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dal Zilio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Le Botlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Pencolé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Subias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th International Conference FORMATS</title>
		<meeting><address><addrLine>Amsterdam, Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">11750</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Diagnosis of supervision patterns on bounded labeled Petri nets by model checking</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Pencolé</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Subias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28h International Workshop on Principles of Diagnosis DX17</title>
		<meeting><address><addrLine>Brescia, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Diagnosability of discrete-event systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sampath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lafortune</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sinnamohideen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Teneketzis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Automatic Control</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1555" to="1575" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
