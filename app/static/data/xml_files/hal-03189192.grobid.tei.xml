<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PG-Keys: Keys for Property Graphs</title>
				<funder ref="#_2YZm4gV">
					<orgName type="full">NCN</orgName>
				</funder>
				<funder ref="#_zWmstnN #_q3qFe6C">
					<orgName type="full">EPSRC</orgName>
				</funder>
				<funder ref="#_bMpy6md #_AeDuKEW">
					<orgName type="full">DFG</orgName>
				</funder>
				<funder ref="#_dQYmUKd">
					<orgName type="full">ANID</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Angela</forename><forename type="middle">Bonifati</forename><surname>Lyon</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Stefania</forename><surname>Dumbrava</surname></persName>
						</author>
						<author>
							<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Keith</forename><forename type="middle">W</forename><surname>Hare</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Victor</forename><forename type="middle">E</forename><surname>Lee</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Tigergraph</forename><forename type="middle">Bei</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Josh</forename><surname>Perryman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ognjen</forename><surname>Savković</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Schmidt</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Juan</forename><surname>Sequeda</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sławek</forename><surname>World</surname></persName>
						</author>
						<author>
							<persName><surname>Staworko</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Bei</forename><surname>Li</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Universidad de Talca</orgName>
								<address>
									<country>IMFD Chile</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Univ</orgName>
								<orgName type="institution" key="instit2">Liris CNRS &amp; INRIA</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">ENSIIE &amp; Inst</orgName>
								<orgName type="institution">Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Eindhoven Univ. of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">JCC Consulting Inc</orgName>
								<address>
									<settlement>Neo4j</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="department">Birkbeck</orgName>
								<orgName type="institution">Univ. of London</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">Google LLC</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution" key="instit1">U. of Edinburgh</orgName>
								<orgName type="institution" key="instit2">ENS-Paris/PSL</orgName>
								<address>
									<settlement>Neo4j</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="institution">University of Bayreuth</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff9">
								<orgName type="institution">University of Warsaw</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff10">
								<orgName type="institution">Interos Inc</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff11">
								<orgName type="institution">Free Univ. of Bozen-Bolzano</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff12">
								<orgName type="institution" key="instit1">U. Lille</orgName>
								<orgName type="institution" key="instit2">INRIA LINKS</orgName>
								<orgName type="institution" key="instit3">CRIStAL CNRS Dominik Tomaszuk Inst. of Comp. Sci</orgName>
								<orgName type="institution" key="instit4">U. of Bialystok</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">PG-Keys: Keys for Property Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">DF9F9B2170CFF5DD9DD674C0DABB2DCC</idno>
					<idno type="DOI">10.1145/3448016.3457561</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Information systems → Integrity checking</term>
					<term>• Theory of computation → Data modeling</term>
					<term>Database constraints theory</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We report on a community effort between industry and academia to shape the future of property graph constraints. The standardization for a property graph query language is currently underway through the ISO Graph Query Language (GQL) project. Our position is that this project should pay close attention to schemas and constraints, and should focus next on key constraints.</p><p>The main purposes of keys are enforcing data integrity and allowing the referencing and identifying of objects. Motivated by use cases from our industry partners, we argue that key constraints should be able to have different modes, which are combinations of basic restriction that require the key to be exclusive, mandatory, and singleton. Moreover, keys should be applicable to nodes, edges, and properties since these all can represent valid real-life entities. Our result is PG-Keys, a flexible and powerful framework for defining key constraints, which fulfills the above goals.</p><p>PG-Keys is a design by the Linked Data Benchmark Council's Property Graph Schema Working Group, consisting of members from industry, academia, and ISO GQL standards group, intending to bring the best of all worlds to property graph practitioners. PG-Keys aims to guide the evolution of the standardization efforts towards making systems more useful, powerful, and expressive.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Graphs are a flexible and agile data model for representing complex network-structured data used in a wide range of application domains, including social networks <ref type="bibr" target="#b63">[64]</ref>, biological networks <ref type="bibr" target="#b51">[52,</ref><ref type="bibr" target="#b59">60]</ref>, bioinformatics <ref type="bibr" target="#b57">[58]</ref>, cheminformatics <ref type="bibr" target="#b73">[74]</ref>, medical data <ref type="bibr" target="#b80">[81]</ref>, and knowledge management <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b81">82]</ref>. In the context of enterprise data management, many current graph database systems (e.g., Amazon Neptune <ref type="bibr" target="#b3">[4]</ref>, Neo4j <ref type="bibr" target="#b69">[70]</ref>, TigerGraph <ref type="bibr" target="#b28">[29]</ref>) support property graphs. A property graph is a multigraph where nodes and edges can have labels and properties (i.e., key-value pairs) <ref type="bibr" target="#b13">[14]</ref>.</p><p>The development of standards for property graphs is in process. In September 2019, ISO/IEC JTC1 approved a project to standardize a property graph database language GQL. The GQL project is assigned to ISO/IEC JTC1 SC32 WG3 Database Languages -the same committee responsible for developing and enhancing the Database Language SQL and of which four of this paper's authors are members. A standards effort for a new database model is a daunting task: the SQL standard was first approved in 1986 and continues to be enhanced and expanded today. In addition to standardizing the language for queries, the following aspects also need to be considered: extensions to the data model, schema language, constraints, among others. It is unrealistic to expect that all of these features can be addressed by the ISO committee in a timely fashion. Therefore the initial focus of the ISO committee is to standardize a graph query language. This begs the question: what about standardization efforts for property graph schema and constraints?</p><p>Standards for property graph schema and constraints are critical to avoid interoperability risks. With the increased popularity of graph databases and the strong industry uptake, vendors are implementing their own versions of schema and constraints. By the time the ISO committee starts to address schema and constraints, the drift will be so large that it will be hard to reconcile approaches.</p><p>As a community of graph database industry practitioners and academics, we acknowledge the need for standardized property graph schema and constraints. Our work in the Linked Data Benchmark Council (LDBC) Property Graph Schema Working Group (PGSWG) is focused on providing community recommendations to the ISO committee. This paper presents the deliverable and recommendation of the working group around the notion of PG-Keys, namely keys for property graphs. Intuitively, a key in a property graph database is used to establish and identify unique nodes, edges, and properties in the property graph.</p><p>Why Keys? Consider the following scenario to motivate the need for keys in a property graph. An e-commerce company is in its digital transformation process and in order to be competitive, it needs to offer customers new functionalities such as personalized recommendations based on their social network, new offers based on purchasing habits, etc. To accomplish this goal, the company wants to create an identity graph in order to achieve a 360 view of a customer and subsequently apply graph algorithms for next generation analytics. This identity graph is the result of integrating several data sources including the company's internal relational data (i.e., order management system, customer relationship management system) and acquired external data not necessarily in relational format (i.e., social media data and consumer behavior data in graph-oriented format). Notice that some data sources, such as the relational ones, might already have some constraints. Moreover, data can also be injected through ETL pipelines, where the constraints are enforced. However, even with cleaned data sources or input ETL pipelines, their integration and migration into the graph database might still bring global inconsistency. Thus, constraints should be persistent within the graph database, where the integrated and migrated data is stored, and should be seamlessly enforced on these data. Therefore, when it comes to integrate data from graph and non-graph data sources, the need of specifying constraints for the result of the integration is quite evident, as shown in the following use cases.</p><p>Example 1.1 (Identity in the graph). An identity graph providing a 360 view of customers must have a way to uniquely identify customer nodes in the graph. The order management system contains a unique identifier for a customer which is in the customer_id column of the Customer table. The following is an example (using a GQL-like syntax, quite similar with that of Cypher <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b37">38]</ref>) of two Customer nodes in the property graph where customerid is the property that uniquely identifies a Customer node:</p><p>(: Customer { customerid : " C123 " , name : " Alice Smith " }) , (: Customer { customerid : " C456 " , name : " Jan " }) .</p><p>Without an identity key, the resulting property graph could have Customer nodes that appear to be the same when in reality they are not. This would introduce data errors in the graph. With an identity key, the integrity of the data is maintained, meaning that there cannot be another Customer node with the same customerid.</p><p>The next source to incorporate is social media data containing data about Twitter users and the posts they have liked. The following is an example of a user node in the property graph, where username is a key that uniquely identifies a TwitterUser node:</p><p>(: TwitterUser { username : " asmith " , firstname : " Alice " , lastname : " Smith " , email : " asmith@d . org " }) . In order to merge Customer and TwitterUser nodes that correspond to the same people, the company applies entity resolution techniques. The merged entity contains (deduplicated) data from both sources, for example:</p><p>(: Customer { customerid : " C123 " , name : " Alice Smith " , twitter : " asmith " , email : " asmith@d . org " }) . Note that not every Customer node would have corresponding social media data, so the following node remains perfectly valid:</p><p>(: Customer { customerid : " C456 " , name : " Jan " }) . Here, both customerid and twitter are exclusive, meaning that no two nodes should have identical values of either property. In addition, customerid is required for each node, while twitter is optional. Such semantics should ideally be encoded in the key constraints to prevent ill-formed data from entering the graph. If each Customer does not have a unique customerid, then the associated social media information for a single customer may be incorrectly merged into more than one customer:</p><p>(: Customer { customerid : " C456 " , name : " Alice Smith " , twitter : " asmith " , email : " asmith@d . org " }) , (: Customer { customerid : " C456 " , name : " Jan " , twitter : " asmith " , email : " asmith@d . org " }) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1.2 (Integrity in the graph</head><p>). An Order is placed by a Customer, as shown in the following graph pattern:</p><p>(: Order ) -[: placedBy ] -&gt;(: Customer ) . Business users would want to ensure that (1) an Order must be associated with a Customer and be exclusive to that Customer and (2) a Customer can place zero or more Orders. These business rules can be ensured through key constraints. It is not uncommon that key constraints like this also imply such a participation constraint.</p><p>Without this key constraint for Order, the resulting property graph could have Order nodes without an associated Customer, thus introducing data errors in the graph. For example, if in the process of replicating the order management system to a property graph, the Order table has a customer_id column, which is a foreign key referencing the Customer table, and the customer_id column is nullable, this can lead to problems. Perhaps that value is allowed to be changed later, or maybe it is a bug in the order management system. If a row in the Order table has a NULL value in the customer_id column, then the resulting property graph can have an Order node without a corresponding Customer. This would heavily affect analytics and recommendations and subsequently create the need to invest more money and effort in data cleaning.</p><p>With the key constraints, these problems would be avoided. First, the keys enforce the data integrity of the property graph. Second, data quality issues can be identified proactively thus avoiding costly data cleaning expenses later on. Therefore, business rules can be modeled as key constraints, thereby maintaining property graphs consistently and preventing data quality issues.</p><p>The above use cases showing the utility of PG-Keys in data integration and data migration pipelines are recurrent in graph database applications, as witnessed by the industry members of the PGSWG (namely Amazon, data.world, Google, Interos, Neo4j, and TigerGraph). Furthermore, property graph databases such as Neo4j, Tigergraph, etc., are transactional, therefore they can be used as a database of record. For this reason, keys are crucial to reference and identify a node, edge, or property in a graph, avoid duplicate nodes and edges, provide a base for describing how one entity connects to another, constrain the structure of the database, and enforce identity and integrity of the nodes, edges, and properties in a graph, among others.</p><p>From an academic viewpoint, keys are interesting to study because they are the most basic and most-used type of database constraint, and as such play a fundamental role in reasoning over data and queries for the sake of correctness and performance. For example, the existence of keys influences the choice of data structures and algorithms for indexing, and they can be crucial for determining if a certain query always has a unique and meaningful result. So an effective and well-understood formalism for describing keys is crucial for developing a body of knowledge that can help with building correct and more efficient databases.</p><p>Property graph keys today. Given the popularity of property graphs and the rise of numerous database vendors, one would believe that incorporating keys in property graphs would be a foregone conclusion. Unfortunately, we are at a stage where there is already a significant drift between database vendors. From an academic perspective, there has been broad research of keys in a variety of data models, including graphs; however, the results are disconnected from the needs of industry.</p><p>Industry. The online documentation of thirteen property graph database systems (AgensGraph <ref type="bibr" target="#b2">[3]</ref>, Amazon Neptune <ref type="bibr" target="#b3">[4]</ref>, Azure Cosmos <ref type="bibr" target="#b58">[59]</ref>, DataStax <ref type="bibr" target="#b26">[27]</ref>, JanusGraph <ref type="bibr" target="#b44">[45]</ref>, Memgraph <ref type="bibr" target="#b56">[57]</ref>, Neo4j <ref type="bibr" target="#b75">[76]</ref>, Oracle Spatial and Property Graph <ref type="bibr" target="#b61">[62]</ref>, RedisGraph <ref type="bibr" target="#b46">[47]</ref>, Sparksee <ref type="bibr" target="#b74">[75]</ref>, TigerGraph <ref type="bibr" target="#b76">[77]</ref>, TinkerPop <ref type="bibr" target="#b8">[9]</ref> and Titan <ref type="bibr" target="#b77">[78]</ref>) reveal the following. Some systems (DataStax, Oracle Spatial and Property Graph, and TigerGraph) offer primary keys for nodes, which combine three constraints on the property values: unique, mandatory, and singlevalued. Other systems take a more granular approach. AgensGraph, Memgraph, Microsoft Azure Cosmos, Neo4j, and Sparksee support a uniqueness constraint on nodes: the same property value may not appear in more than one node of a given label or type. AgensGraph, Memgraph, and Neo4j also support a mandatory constraint: every node having a given label or type must have a value for the given property. Both uniqueness and mandatory are supported in Oracle relational database, which are then inherited in the derived Spatial and Property Graph. Some systems offer some of these constraints for edges, but no clear pattern emerges. In general, every edge has an implied constraint, namely that it connects one source node and one destination node. For TigerGraph, this is extended to say that these two nodes form the primary key of an edge. This means there may be only one edge of a given type between a given pair of nodes. Other systems do not have this built-in constraint, embracing a multigraph model. To our knowledge, none of these systems offer user-specified edge cardinality. It is clear that there is no uniform approach taken for keys in property graphs. This lack of uniformity underlines the importance of a standardization effort motivated by existing use cases and based on solid theoretical foundations.</p><p>Academia. The notion of "key" exists in most database systems, although its definition and meaning depend on the underlying database model. For example, a key in the relational model is a set of attributes whose values are used to identify tuples inside a table <ref type="bibr" target="#b1">[2]</ref>; in object-oriented data models, object identity is achieved by equipping each database object with a unique identifier <ref type="bibr" target="#b66">[67]</ref> or by using an arbitrary query <ref type="bibr" target="#b64">[65]</ref>; in semi-structured models and XML, a key can be specified in terms of path expressions <ref type="bibr" target="#b17">[18]</ref>; in RDF, every resource is either identified by an Internationalized Resource Identifier (IRI) <ref type="bibr" target="#b47">[48]</ref> or by using a term described by a vocabulary <ref type="bibr" target="#b48">[49]</ref>. Section 5 gives a closer review of these notions.</p><p>In the context of graph databases, we can also find different approaches to key constraints in the research literature <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b13">14]</ref>. A prominent proposal for graph keys <ref type="bibr" target="#b32">[33]</ref> relies on a graph model that differs from the property graph model in that property values are modeled as data value objects (i.e., special data nodes) and edges do not have identity or property values. Keys there are a kind of uniqueness constraint defined in terms of graph patterns (to specify topological constraints and value bindings), and are interpreted based on graph pattern matching. The focus of the paper is on the entity-matching problem rather than on producing a widely applicable recommendation for the design of keys, rooted in industrial property graph use-cases. Specifically, the authors analyze the general complexity of the problem and evaluate two specific algorithms for entity matching. The work has been extended to graph functional dependencies <ref type="bibr" target="#b33">[34]</ref>, though for a model that is less general than property graphs, as values are only allowed at the nodes. The extension focuses on the satisfiability, implication and validation problems for functional dependencies rather than on a recommendation proposal for property graph databases.</p><p>A recent formalism <ref type="bibr" target="#b50">[51]</ref> allows the definition of property-based key constraints solely on nodes and discusses its possible implementation on top of Neo4j using the Cypher language; that is, for a label and a set of properties, all the properties must exist in all the nodes with that label, and each combination of the values for these properties is unique for each node. It is also observed that such keys can be extended to nodes that carry multiple labels. The focus of this work is on the implication problem and its axiomatic characterization. Another extension of Neo4j constraints <ref type="bibr" target="#b67">[68]</ref> studies new notions such as "node property uniqueness" to make reference to a set of properties whose values must be unique for a given set of nodes, and "mandatory properties" for nodes and edges.</p><p>Although various aspects of key constraints for graph database models have been touched upon in the past, a full-fledged formalism as the one presented in this paper is missing. Moreover, it is clear that there is no consensus among the vendors. The existence of this working group is evidence that a consensus is needed.</p><p>Contributions. Motivated by the current situation in property graph data management systems, and following the success of G-CORE <ref type="bibr" target="#b5">[6]</ref>, the Property Graph Schema Working Group was formed in 2019. This paper documents the consensus based on intensive and constructive discussions held over 18 months between the industry and academic members of the group. Our contributions are: (a) an analysis of the requirements for property graph keys; (b) a proposal for a modular, flexible, and expressive formalism called PG-Keys, that defines a syntax and a semantics for specifying keys, satisfying all design requirements; (c) a comparison of this formalism with keys in existing database models and data models.</p><p>Our contributions impact the following audiences: (1) industry practitioners building graph databases, who can use our framework as a guideline to incorporate keys in their systems, (2) graph database standards committee members, who can build upon our recommendations for upcoming standardization features, and (3) academics, who are given a concrete model of keys for property graphs, which they can use as a basis for further research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DESIGN REQUIREMENTS FOR KEYS</head><p>In this section we elaborate on the design requirements for a suitable notion of key for property graphs. We begin by discussing the relevant functions that keys play in databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Purposes of Keys</head><p>A common reason for using keys is to constrain the database contents and prevent data patterns that are nonsensical, contradictory, or unnatural. For instance, a key can be used to prevent a database from storing two copies of information for individuals using the same SSN (Social Security Number). Also, in relational tables that represent relationships between entities, keys are used to express participation constraints that restrict the relationships to many-to-many, one-to-many, and one-to-one kind, cf. Example 1.2.</p><p>Another purpose of keys is to allow one to reference database objects. For example, foreign keys in relational databases allow one record to reference another, by citing its primary key, a common mechanism for representing relationships between entities. In property graphs, relationships are represented with edges rather than foreign keys, and consequently, keys are not needed for intradatabase referencing. However, a reference mechanism is still required by external applications that access the database.</p><p>A special, but distinct, case of referencing is when keys are used to identify real-life objects represented by database objects, and vice versa. To this end, keys specify the identifying information for each object. This use case is particularly relevant in various entity resolution problems <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b30">31]</ref>, where it is essential that the identities of objects can be compared through their identifying information (cf. Example 1.1). Also, this use of keys is crucial in conceptual data models and object-oriented database models <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b42">43]</ref>, which typically introduce an abstract object identifier and a link to real-life objects needs to be established.</p><p>All of the above uses of keys are relevant for property graphs and motivate the following requirement. R0 Coverage. The proposed formalism must address the need to constrain the database and to reference and identify objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Key Types</head><p>To properly address the various purposes of keys, we elaborate on a repertoire of key types of varying power, but first we need to outline the basic anatomy of keys and how they work. A key has a scope, which is the set of objects to which it applies, and a descriptor, which specifies, for an object in the key scope, how to obtain a key value. For instance, in relational databases, the scope of a key is a table and the descriptor consists of a set of (key) attributes: for an object represented by a single row of a table, the key value consists of the values of key attributes in that row.</p><p>For object identification purposes, the key values need to be:</p><p>EXCLUSIVE, no two objects in the key scope can share a key value. This ensures unambiguity of the reference given by the key. MANDATORY, every object in the key scope must have a key value.</p><p>This ensures that every object in the key scope can be referenced using the key, which provides a total reference scheme. SINGLETON, every object in the key scope must have at most one key value. This ensures that the key value is canonical, and in particular, for any two objects in the scope that have key values, the objects are identical if and only if their key values are the same. So, the key value of an object is equivalent to its identity.</p><p>The conditions above are in fact fulfilled by virtually all existing notions of keys, including keys in relational databases <ref type="bibr" target="#b1">[2]</ref>, keys in ER diagrams <ref type="bibr" target="#b21">[22]</ref>, and keys in XML Schema <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b52">53]</ref>.</p><p>For the purposes of referencing objects and imposing constraints, we additionally consider variants that drop either MANDATORY or SINGLETON or both. Indeed, such variants are commonly employed in existing database models and data modeling frameworks. For instance, XML Schema proposes the &lt;unique&gt; identity constraint that drops MANDATORY. Similarly, SQL provides a UNIQUE constraint for relational databases (where SINGLETON is implied by 1NF).</p><p>For the presented purposes, we identify four natural key types, which we illustrate with an example of a system that manages information about a set of users:</p><p>• EXCLUSIVE MANDATORY SINGLETON, or IDENTIFIER for short, e.g., login: every user is required to have precisely one, and no two users can have the same login; • EXCLUSIVE MANDATORY, e.g., email: every user must have at least one email and no two users can use the same email; • EXCLUSIVE SINGLETON, e.g., preferred email: every user may have at most one preferred email for contacting them but again no two users can have the same preferred email; • EXCLUSIVE, e.g., alias: every user may have an arbitrary number of aliases but no two users can have a common alias. These four key types form a natural hierarchy, presented in Figure <ref type="figure" target="#fig_0">1</ref>: arrows lead from weaker to stronger types of keys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Defining Scope and Descriptor</head><p>We next identify design requirements that focus on defining the scope and the descriptor of keys. To illustrate them, we use a small example of a property graph, presented in Figure <ref type="figure">2</ref>, representing a Social Network (SN) graph database inspired by the LDBC Social Network Benchmark <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b31">32]</ref>. Recall that a property graph is a directed labeled multigraph whose nodes and edges have (possibly multiple) labels and properties <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14]</ref>.</p><p>For a majority of keys, the scope and the descriptor are defined by simple means of inspecting labels and property values only. For instance, countries, represented by nodes with label Country, are identifiable by their name, stored as the property name.</p><p>However, the information relevant to establishing the kind of a node and its key value may be located outside of the node: accessing it may require navigating through the graph. For instance, suppose that we wish to express a key that asserts that forum moderators can be distinguished through their first and last names alone. The scope of such a key consists of Person nodes with an incoming hasModerator edge. Similarly, consider a key stating that a city can be identified with the combination of its name and its country: the key descriptor needs to access a Country node reachable from the City node with an outgoing isPartOf edge. Hence, the following.</p><p>R1 Key Scope. The proposed key formalism must support a rich language that allows specification of relevant elements of the property graph that represent real-world objects. In particular, it must allow the selection of nodes, edges, and their properties. This language cannot assume that a schema is present. R2 Key Descriptor. Additionally, the proposed key formalism must support an equally rich language to locate the graph elements constituting the key value of an object in scope.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Object Identity</head><p>In R1, we state the need to consider nodes, edges, and properties as the objects which one may wish to identify with a key. The justification for nodes is straightforward, since they are typically used to represent real-world objects. Edges represent relationships, which may capture events and facts. For instance, in the SN graph database, the studyAt edges represent the fact that an individual attends university and, as such, we may wish to identify them. Finally, it is also conceivable that a real-world object is not represented directly in a graph database with a dedicated node or edge, but rather by a property value. For instance, a mobile phone may be represented by its IMEI number, stored as an attribute of the node representing its owner. We point out, however, that property values are literal values and, hence, do not have an identity of an abstract data object, such as nodes and edges. Consequently, the treatment of property values needs to adequately address this difference.</p><p>In the context of the relational model, keys are modeled as equality generating dependencies <ref type="bibr" target="#b1">[2]</ref>, where the generated equalities are between domain values. However, they can also be understood as a way of determining if two records represent the same real-world object. Namely, any two records that agree on key attributes represent the same real-world object and, therefore, should be equal. Keys for property graphs can also be understood in this way as a mechanism for determining the identity of the objects by nodes, edges, and property values. This leads to the following requirements. R3 Node Identity. Our formalism must allow determining the identity of nodes in a graph database. R4 Edge Identity. Our formalism must allow determining the identity of edges in a graph database.</p><p>R5 Property Value Identity. Our formalism must also allow identification of property values of both nodes and edges. In particular, the formalism must allow the determination that two properties must or must not have the same value. Note the distinction between object identity and the ability of users to observe and compare object identifiers (i.e., the concrete object ID values used internally by a system implementation). Towards maximal flexibility for system designers and implementors, we do not require access to observable object identifiers in our formalism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Pragmatic Concerns</head><p>Finally, we list requirements of a pragmatic nature. They are concerned with ease of use and feasibility of implementation. R6 Usability. The keys defined by the formalism must be understandable and intuitive for the intended users. Preferably the formalism should be declarative. R7 Validation. It should be relatively straightforward to validate a key, i.e., check whether it holds in a given property graph. Its complexity should be comparable to the complexity of executing a query in the available querying apparatus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">QUERYING PROPERTY GRAPHS</head><p>In this section, we discuss languages that can be used to specify the scope and descriptor of key constraints for property graphs. To this end, we first treat property graphs themselves. A property graph is a directed labelled multigraph with the special characteristic that each node or edge maintains a (possibly empty) set of properties, where a property is a name-value pair. From a data modeling point of view, a node represents an entity, an edge represents a relationship between entities, a label represents a classification or type, and a property represents an attribute of an entity or relationship.</p><p>The general structure of a property graph can be restricted to satisfy specific requirements. In this paper we will assume the following restrictions: each node/edge has an exclusive object identifier (oid); each node/edge has zero or more labels; each node/edge has zero or more properties; the value of a property must be either a simple value (e.g., a number, a string, a date) or a complex value (e.g., a tuple, a set, a JSON structure); and two properties (inside a single node/edge) cannot have the same name.</p><p>We now give a formal definition of property graphs. Assume that L is a countably infinite set, containing labels and property names, and V is a countably infinite set of property values. Definition 3.1 (Property Graph). A property graph is defined as a tuple 𝐺 = (𝑁 , 𝐸, 𝜌, 𝜆, 𝜋) where: 𝑁 is a finite set of nodes; 𝐸 is a finite set of edges such that 𝑁 ∩𝐸 = ∅; 𝜌 : 𝐸 → (𝑁 ×𝑁 ) is a total function mapping edges to ordered pairs of nodes; 𝜆 : (𝑁 ∪ 𝐸) → 2 L is a total function mapping nodes and edges to sets of labels (including the empty set); 𝜋 : (𝑁 ∪ 𝐸) × L ↦ → V is a partial function mapping nodes / edges and property names to property values. Example 3.2. Consider the property graph in Figure <ref type="figure">2</ref>. We have  For ease of reference, we associate with every node and edge an identifier and employ consistent typographic conventions. For instance, take the node 𝑢 1 representing the Hague University: 𝑢 1 is its identifier, University is its only label, name is a property name, and The Hague University is its value.</p><formula xml:id="formula_0">𝑁 = {𝑐𝑡 2 , 𝑐𝑛 2 , . . . , 𝑚 2 , 𝑚 1 }; 𝐸 = {𝑝𝑜 2 , 𝑟 1 , . . . , 𝑠 2 }; 𝜌 (𝑝𝑜 2 ) = (𝑐𝑡 2 , 𝑐𝑛 2 ), . . ., 𝜌 (𝑟 1 ) = (𝑚 2 , 𝑚 1 ); 𝜆(𝑐𝑡 2 ) = {City}, . . . , 𝜆(𝑚 1 ) = {Message, Post}, 𝜆(𝑝𝑜 2 ) = {isPartOf}, . . . , 𝜆(𝑠 2 ) = {studyAt}; and 𝜋 (𝑐𝑡2, name) = Wassenaar, . . . , 𝜋 (s 2 , classYear) = 2021.</formula><p>For defining the scope and descriptor of key constraints, we assume that we can use a language that allows us to map property graphs 𝐺 to tables 𝑇 , where a table 𝑇 is a set of bindings that map variables to values. Concretely, we assume that we can write statements such as: 𝑞( x) , where x is a tuple of variables that bind to nodes, edges, and property values. We will use these statements to describe the scope and descriptor of keys. Informally, such a statement could be the query "Return all bindings to (𝑥, 𝑦, 𝑧) such that 𝑥 is a person, 𝑦 the city that 𝑥 is located in, and 𝑧 is the name of 𝑦. " On the data in Figure <ref type="figure">2</ref>, this query would return the table</p><formula xml:id="formula_1">𝑥 𝑦 𝑧 𝑝 1 𝑐𝑡 1 Wassenaar 𝑝 2 𝑐𝑡 1 Wassenaar</formula><p>where the first and second row express that (𝑥, 𝑦, 𝑧) can be bound to (𝑝 1 , 𝑐𝑡 1 , Wassenaar) and (𝑝 2 , 𝑐𝑡 1 , Wassenaar), respectively. Notice that our convention to let variables bind to nodes, edges, and property values implies that (a) queries cannot output paths and (b) queries can only output entire property values, treating them as atomic. We will consider extensions of our formalism that relax these conditions in Sections 6.2 and 6.3.</p><p>The language for specifying 𝑞( x) will be a parameter of PG-Keys. This means that different database systems can use different languages for specifying 𝑞( x) and still fully conform to PG-Keys. We recommend using languages with a good expressiveness/complexity balance, which will allow efficient implementations of key validation, while providing sufficient expressive power.</p><p>In order to be able to present examples in the paper, however, we will specify 𝑞( x) as queries in a language where the patterns are expressed in a GQL-like syntax, similar to that of Cypher <ref type="bibr" target="#b35">[36]</ref>, a popular graph query language. In this syntax the above query would be written as Here, the part preceding keyword WITHIN specifies the output of the query, whereas the part following WITHIN specifies the pattern to be matched in the property graph. Notice that our syntax does not require giving an explicit name to every variable. For instance, we just use y.name to refer to "the name of 𝑦", which we called 𝑧 before. We will use this convention throughout the paper.</p><p>If there is exactly one output variable and this is the only variable in the pattern, as for example in x WITHIN (x:Person), then we allow the query to be specified by just the pattern (x:Person).</p><p>We will also assume that all variables in the query, including the implicit ones, must be bound to existing objects in the property graph. In Section 6.1, we discuss what happens when a reference to an undefined property is allowed to occur. In that case, following the practice of existing graph query languages, a null (or more precisely, a non-applicable null) is returned. Existing query languages tend to follow SQL's three-valued approach to handling nulls, though in Section 6.1 we suggest another approach that fits in better with the semantics of undefined properties: namely, returning false for results of comparisons using such properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A GUIDED TOUR OF PG-KEYS</head><p>In this section, we define PG-Keys formally and demonstrate how they satisfy the design requirements identified in Section 2.</p><p>We begin with a basic example illustrating the general shape of PG-Keys. Suppose that cities can be identified by their name and the country they are in (if this information is known). More precisely, this means that the combination of the name property of a city node, with the country node to which it has an isPartOf edge, identifies the city node. The corresponding PG-Key</p><formula xml:id="formula_2">FOR ( x : City ) EXCLUSIVE x . name , z WITHIN ( x ) -[: isPartOf ] -&gt;( z : Country )</formula><p>involves two queries. The query (x:City) specifies the scope of the PG-Key, which is the set of all possible targets; here, city nodes. The query x.name, z WITHIN (x)-[:isPartOf]-&gt;(z:Country) is the descriptor that selects a key value for each target; here, the city's name and the country it is part of. The keyword EXCLUSIVE indicates that the PG-Key asserts that the key value is exclusive to each target.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">PG-Keys Formally</head><p>A PG-Key is an expression of the form</p><formula xml:id="formula_3">FOR 𝑝 (𝑥) EXCLUSIVE [ MANDATORY | SINGLETON ] | IDENTIFIER 𝑞 (𝑥, ȳ)</formula><p>, where ȳ = (𝑦 1 , 𝑦 2 , . . . , 𝑦 𝑛 ) for some positive integer 𝑛, and 𝑝 (𝑥) and 𝑞(𝑥, ȳ) are queries, called the scope and the descriptor, respectively.</p><p>Note that the keyword WITHIN appearing in the basic example belongs to our syntax for queries.</p><p>The keywords EXCLUSIVE, MANDATORY, and SINGLETON indicate which assertions the PG-Key makes: EXCLUSIVE -no two targets can have the same key value; MANDATORY -for each target there is at least one key value; SINGLETON -for each target there is at most one key value.</p><p>More precisely, the assertions can be formulated as follows:</p><p>(K1) for all 𝑜 1 and 𝑜 2 such that 𝑝 (𝑜 1 ) and 𝑝 (𝑜 2 ), for all r such that 𝑞(𝑜 1 , r ) and 𝑞(𝑜 2 , r ), it holds that 𝑜 1 = 𝑜 2 ; (K2) for all 𝑜 such that 𝑝 (𝑜), there exists r such that 𝑞(𝑜, r ); (K3) for all 𝑜 such that 𝑝 (𝑜), for all r1 and r2 such that 𝑞(𝑜, r1 ) and 𝑞(𝑜, r2 ), it holds that r1 = r2 . A graph 𝐺 satisfies: an EXCLUSIVE constraint if condition (K1) holds, an EXCLUSIVE MANDATORY constraint if (K1) and (K2) hold, an EXCLUSIVE SINGLETON constraint if (K1) and (K3) hold, and an IDENTIFIER constraint if (K1), (K2), and (K3) hold. That is, IDENTIFIER is a shorthand for EXCLUSIVE MANDATORY SINGLETON. PG-Keys clearly satisfies design requirements R1-R5 of Section 2: there is full support for specifying the scope (R1) and descriptor of a key (R2); and, key constraints can be defined for nodes (R3), edges (R4), and property values (R5).</p><p>In the following Sections 4.2-4.4, we give a guided tour highlighting how design requirement R6 (Usability) is also satisfied, through the intuitive declarative way in which PG-Keys are specified. We further address design requirement R0 (Full coverage): PG-Keys allows us to constrain the graph database, reference objects within the database, and identify objects in the database. Indeed, our presentation follows the modular structure the PG-Keys formalism, showcasing the support provided for finely controlling the scope and descriptor (which can be complex queries over object properties and graph topology) and for the four key types identified in Section 2. Last but not least, the discussion of validation of PG-Keys in Section 4.5 addresses design requirement R7 (Validation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Keys on Nodes</head><p>Keys Defined Using Properties. Suppose that we are in the process of building our SN graph, and not all country nodes have name property values yet. However, the name property should be unique for each country, for countries that already have a name. More precisely, if it exists, the name property of a country node should identify the country node. This is a uniqueness (or exclusivity) constraint, allowing us to reference countries:</p><p>FOR (x: Country ) EXCLUSIVE x . name . In other words, given any two nodes 𝑛 1 and 𝑛 2 labeled Country, if they have the same value for the property name, then it must be the case that 𝑛 1 = 𝑛 2 .</p><p>As the data becomes more complete, suppose that we further require that each country must have a name. In this case, reference constraints and identification constraints are equivalent, because our data model does not include multi-valued properties:</p><p>FOR (x: Country ) EXCLUSIVE MANDATORY x . name , FOR (x: Country ) IDENTIFIER x . name .</p><p>Keys Defined Using Properties and Topology. To further illustrate the distinction between EXCLUSIVE MANDATORY and IDENTIFIER, we return to the example with which we opened this section, where cities are identified by their name and the country they are part of (if this information is known). This is an example of a uniqueness constraint allowing us to reference cities, i.e., given any two nodes 𝑛 1 and 𝑛 2 labeled City, if they have the same value for the property name and both have an isPartOf edge to a common node 𝑛 3 labeled Country, then it must be the case that 𝑛 1 = 𝑛 2 . If we further require that cities must have names and must be part of a country, then it would be natural to specify the constraint Keys Defined Using Topology. As an example of a constraint defined purely in terms of graph topology, consider forums which can be identified by the posts that they contain, i.e., knowing a post, the forum that contains it is uniquely identified. This is a uniqueness constraint, allowing us to reference forums:</p><formula xml:id="formula_4">FOR ( x : Forum ) EXCLUSIVE z WITHIN ( x ) -[: containerOf ] -&gt;( z : Post ) .</formula><p>In other words, given any two nodes 𝑛 1 and 𝑛 2 labeled Forum, if they both have a containerOf edge to the same Post, then it must be the case that 𝑛 1 = 𝑛 2 . If we further require that forums must have posts, we specify an EXCLUSIVE MANDATORY constraint on the database. Further, it is not expected that forums must each have exactly one post (since these would be rather lonely forums), hence it doesn't make sense that posts are identifiers for forums. We can express that each post is contained in exactly one forum as FOR ( z : Post ) MANDATORY SINGLETON x WITHIN ( x : Forum ) -[: containerOf ] -&gt;( z ) , but this is a participation constraint rather than a key constraint, and is not part of PG-Keys.</p><p>Keys With Complex Scope. So far, we have defined constraints on nodes based on a fairly simple scope, namely, by only considering the label of the node. As a final example illustrating the need for more complex scope, consider the constraint that a forum which has members (1) must have a moderator and ( <ref type="formula">2</ref>) is identified by the moderator. In PG-Keys, we have In other words, a forum with members must have exactly one moderator and, furthermore, given any two such forum nodes 𝑛 1 and 𝑛 2 , if they both have a hasModerator edge to the same Person, then it must be the case that 𝑛 1 = 𝑛 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Keys on Edges</head><p>Keys Defined Using Topology. For our first edge key constraint, consider that there is only one isPartOf edge from a given country to a given continent, i.e., the identity of an isPartOf edge from a country to a continent is determined by the country and the continent. More formally, this actually means that there is at most one isPartOf edge from a given country to a given continent, which is a uniqueness constraint: In other words, given any two edges 𝑒 1 and 𝑒 2 labeled isPartOf, if they have the same source node 𝑛 𝑠 labeled Country and the same target node 𝑛 𝑡 labeled Continent, then it must hold that 𝑒 1 = 𝑒 2 .</p><p>Keys Defined Using Properties and Topology. Suppose that people can study at the same university in different years, but for a given year, the studyAt edge between a person and a university is unique. Rephrased, this means that, in a given year, the information that a person studies at a given university is stored only once. More precisely, if you have a studyAt edge from a person to a university with the property classYear, then this edge is identified by the person, the university, and the value of classYear. This is a uniqueness constraint, which we can express in PG-Keys as In other words, given any two edges 𝑒 1 and 𝑒 2 labeled studyAt with property classYear, if they have the same source node 𝑛 𝑠 labeled Person, the same target node 𝑛 𝑡 labeled University, and have the same value for the property classYear, then it must be the case that 𝑒 1 = 𝑒 2 .</p><p>As another example, suppose that studyAt edges must have a classYear property (and always be from person nodes to university nodes). As our properties are single-valued and edges have a single source and a single target, we have an identification constraint: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Keys on Properties</head><p>We close our tour of the functionality of PG-Keys with an illustration of a constraint on properties. Consider that study semesters belong to a particular year, e.g., the first semester of 2019. That is, the classYear property of a studyAt edge is identified by the semester property of the edge (if it is known): In other words, for any classYear property values 𝑣 1 and 𝑣 2 of studyAt edges 𝑒 1 and 𝑒 2 , if 𝑒 1 and 𝑒 2 have the same value for property semester, then it must be the case that 𝑣 1 = 𝑣 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Validation of PG-Keys</head><p>The crucial task related to PG-Keys is validation; that is, determining if a given property graph satisfies a given PG-Key. Validation of PG-Keys can be recast as query evaluation. Indeed, recall that the satisfaction of a PG-Key is expressed in terms of conditions (K1), (K2), and (K3). Each of these conditions can be reformulated as emptiness of a query built from the scope and the descriptor of the PG-Key. We explain this with an example from Section 4.2: For (K2), we select targets in the scope for which the descriptor cannot be matched:</p><formula xml:id="formula_5">MATCH ( x : City ) WHERE NOT EXISTS ( x . name ) OR NOT ( x ) -[: isPartOf ] -&gt;( y : Country ) RETURN x .</formula><p>Notice that matching the descriptor also involves checking that the property name is set. Again, (K2) holds exactly when this query returns no answers.</p><p>For (K3), the query selects targets for which two different key values exist. It is built from one copy of the scope and two copies of the descriptor with different descriptor variables: MATCH ( x : City ) , ( x ) -[: isPartOf ] -&gt;( y1 : Country ) , ( x ) -[: isPartOf ] -&gt;( y2 : Country ) WHERE y1 &lt;&gt; y2 RETURN x . Note that we do not need to check that there is only one value of the property name, because our data model does not include multivalued properties. Like in both previous cases, (K3) holds exactly when the constructed query returns no answers.</p><p>Clearly, such rewritings into queries can be directly obtained for any PG-Key. This additionally addresses the design requirement R6 identified in Section 2, allowing to express the semantics of PG-Keys in the very familiar terms of query semantics. Moreover, while additional mechanisms would be needed to handle aspects like batching or incremental validation, implementations of PG-Keys can leverage existing facilities for efficient query evaluation. Hence, PG-Keys have excellent potential for direct deployment and impact in practice, satisfying design requirement R7.</p><p>Incremental validation. Database constraints must be enforced by a DBMS when the state of a database changes after an update. This is standard with relational constraints and updates. The state of graph database updates is far from being fixed, with GQL not yet offering such facilities, and even in well-established languages such as Cypher it is accepted that update features need to be redesigned as they have several deficiencies <ref type="bibr" target="#b37">[38]</ref>. Some variants of PG-Keys are very close to relational (see Section 5.2) and thus easily maintainable under updates that resemble relational insertions/deletions. Others are more complex, akin to SQL's assertions, and thus their incremental validation will require techniques from incremental view/integrity maintenance <ref type="bibr" target="#b12">[13]</ref>. Such techniques are well developed for languages that do not use recursion or reachability queries, see e.g. <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b68">69]</ref>. If reachability, or more generally regular path queries (see Section 6.2) are present, incremental validation with non-recursive queries becomes impossible without the use of complex auxiliary data structures <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b29">30]</ref> and specialized algorithms based on maintenance of datalog queries <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b60">61]</ref>. Hence, the cost of incremental validation will heavily depend on the cost of maintaining the underlying complex data structures under insertions, deletions and update operations. Related to this is the question of constraint-enforced cascading updates, similarly to cascading deletes in the presence of foreign keys. All the above issues need to be studied once the standardization process of graph query and update languages has concluded.</p><p>To summarize this section, we conclude that PG-Keys satisfies all eight of the design requirements (R0-R7) specified in Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATIONSHIP TO OTHER PARADIGMS</head><p>In this section, we compare PG-Keys to key formalisms in existing database models and data models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Conceptual Data Models</head><p>By conceptual data models we mean here data models that are conceptual in nature, i.e., the Entity-Relationship Model, UML Class diagrams and ORM diagrams.</p><p>The Entity-Relationship Model. The classical ER Model <ref type="bibr" target="#b21">[22]</ref> allows a group of attributes to be declared as key of an entity type. Moreover, it introduces the notion of weak entity-type, which has a partial key that, combined with the keys of entity types that are connected via identifying relationships, can identify entities in the entity type.</p><p>Both constructs are easily represented in PG-Keys, assuming that the nodes that represent entities are labeled with the entity type. For example, if the entity type Person has a key consisting of name and birthday then this can be represented as FOR (x: Person ) IDENTIFIER x . name , x . birthday . The same holds for weak entity types with partial keys. For example, consider a case where we have a weak entity type City, which is identified by a combination of its attribute name and the entity of type Country that it is reached via the identifying relationship isPartOf. This can be represented in PG-Keys as FOR (x: City ) IDENTIFIER y , x . name WITHIN (x) -[: isPartOf ] -&gt;( y : Country ) . UML Class Diagrams. UML class diagrams model the structure of a system in terms of classes and their relationships. When used for the conceptual perspective <ref type="bibr" target="#b34">[35]</ref> they can serve as a conceptual data model. There is no special graphical notation for keys, and these are usually represented by comments or stereotypes. However, OCL, the Object Constraint Language, which is part of UML, allows the expression of key constraints with the collection operator isUnique(). For example, if a class City represents a weak entity type where entities are identified by their name and the Country they are part of, then the EXCLUSIVE aspect of the key constraint can be represented as</p><formula xml:id="formula_6">City . allInstances -&gt; isUnique ( Tuple { ctyName = name , cntryName = isPartof }) .</formula><p>There is a close similarity to PG-Keys: the collection to which isUnique() is applied corresponds to the scope of a PG-Key, which in the example is defined by City.allInstances. The function with which isUnique() is parameterized, which is here a function that constructs a tuple containing the name property and the country that the city is part of, corresponds to the descriptor. Given this similarity, the expressive power of the isUnique() operator is similar to that of PG-Keys if the used OCL expressions for defining the scope and the descriptor are similar in expressive power to the queries used in the PG-Keys.</p><p>ORM Diagrams. The Object-Role Modelling (ORM) approach <ref type="bibr" target="#b41">[42]</ref> extends Entity-Relationship modelling with an elaborate graphical notation for a wide range of constraints and a specific languagebased design methodology. It treats attributes and relationships as equals and unifies them in the concept of fact types. As a consequence, it uses for each the same notation to denote key, cardinality and other constraints.</p><p>An example of an ORM diagram with key constraints is: In addition ORM has the concept of reference scheme which is a special type of external uniqueness constraint that corresponds to the IDENTIFIER constraint in PG-Keys. This latter notion is explicitly designed as the mechanism that allows users to refer unambiguously to objects in the instance of a diagram <ref type="bibr" target="#b42">[43]</ref>.</p><p>As illustrated in the ORM diagram, the uniqueness constraints can be combined with mandatory participation constraints, indicated by bullets. This allows in fact the representation of all the four types of keys in PG-Keys.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Relationships to Relational Keys</head><p>Relational data are often migrated to graph databases, where expensive joins can be replaced by more efficient navigational exploration allowed by graph query languages. Can the key constraints present in a relational database 𝑅 be expressed by PG-Keys over the corresponding graph representation 𝐺 𝑅 ? We illustrate how this is possible by means of an example that involves both keys and foreign keys. Consider the relations:</p><p>City ( ID , name , country , population ) ,</p><p>Person ( name , birthday , cityID )</p><p>storing information about persons and the city they live in. We assume that cityID is a foreign key referring to the ID attribute of City. Suppose that these relations are translated to a property graph, as follows. Each tuple in City becomes a different node with label City and properties ID, name, country, and population. Each tuple in Person becomes a different node with label Person and properties name and birthday. Finally, for each tuple in Person with cityID not null, we add a livesIn-edge from the relevant person node to the city node that is identified by cityID. This translation follows closely that of a recent proposed method for systematically mapping relational data to property graphs <ref type="bibr" target="#b72">[73]</ref>.</p><p>To express that ID is a key for City, we use the PG-Key FOR (x: City ) IDENTIFIER x . ID . Notice that each node always has at most one value of the property ID, just like each tuple in the relation City has at most one value in the column ID. Consequently, the SINGLETON restriction, built into IDENTIFIER, is redundant here and we can equivalently use EXCLUSIVE MANDATORY. Candidate keys and uniqueness constraints, including multi-attribute ones, can be handled in a similar fashion. For instance, to express that (name,country) is unique in the table City, we can use FOR (x: City ) EXCLUSIVE x . name , x . country . PG-Keys can also ensure referential integrity on the property graph side. The foreign key itself expresses only that the entity in which a person lives is a city. However, assuming that the property graph will be allowed to evolve after translation, in order to guarantee that it can be translated back to relations we also need to ensure that each person lives in at most one place. (Recall that each Person node in the graph corresponds to a single tuple in the relation Person.) The combination of these two conditions can be expressed using the following two PG-Keys: The first PG-Key states that, for each node with label Person, there is at most one outgoing livesIn-edge. Notice that this requires using SINGLETON, which does not have a counterpart in the relational setting. The second PG-Key states that each node with label Person and an outgoing livesIn-edge, has exactly one outgoing livesInedge pointing to a node with label City. The precise formulation of referential integrity constraints on the graph side depends on the concrete translation from relations to property graphs. However, PG-Keys are sufficiently flexible to express these constraints if the translations stay true to the underlying data.</p><p>Having taken care of the foreign key, we can easily handle keys built on top of it. For instance, to express that (name,cityID) is a key in the relation Person we can use PG-Key FOR (x: Person ) IDENTIFIER x . name , y . ID WITHIN (x) -[: livesIn ] -&gt;( y : City ) . Overall, under natural translations from relations to property graphs, PG-Keys offer full support for relational keys and foreign keys. Moreover, while in the relational model the scope is always one whole relation and the descriptor is a list of attributes, in PG-Keys the power to specify the scope and the descriptor is only limited by the chosen query language. The expressiveness of such keys (as those of object-oriented databases <ref type="bibr" target="#b20">[21]</ref>) is similar to those in the ER Model in that it allows the representation of strong entity types and weak entity types. In general, a formal comparison with relational constraints is an important topic for further study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">XML Keys</head><p>The literature on XML keys includes industrial standards like XML Schema <ref type="bibr" target="#b52">[53]</ref> and DSDL (including RelaxNG and Schematron) <ref type="bibr" target="#b0">[1]</ref>, as well as a large body of academic work <ref type="bibr">[18-20, 44, 54]</ref> proposing various extensions and improvements. Due to the space limitations we focus on XML Schema.</p><p>XML Schema offers two constructors for keys: UNIQUE and KEY. UNIQUE requires that an attribute or element value must be unique within a certain scope. For instance, &lt; unique name = " PersonUnique " &gt; &lt; selector xpath = " ../ Person " / &gt; &lt; field xpath = " @name " / &gt; &lt; field xpath = " @birthday " / &gt; &lt;/ unique &gt; corresponds to the EXCLUSIVE SINGLETON example in Section 5.4. The selector describes the scope: every Person node in the tree. The fields specify the components of the key: the values of the attributes @name and @birthday of each selected node. The XPath expression in the field must return a single value for each selected node.</p><p>KEY extends UNIQUE such that an entity value must be unique and cannot be set to nil (i.e., is not nillable) which corresponds to our IDENTIFIER when focusing on values. For instance,</p><p>&lt; key name = " personKey " &gt; &lt; selector xpath = " ../ Person " / &gt; &lt; field xpath = " @email " / &gt; &lt;/ key &gt; corresponds to the PG-Key FOR ( x : Person ) IDENTIFIER x . email . As we can see, there is indeed a close relationship between keys for XML and PG-Keys. The main difference between the two is perhaps the navigational language. Whereas XPath is perfectly suited for navigation in trees (and can be adapted for graphs <ref type="bibr" target="#b49">[50]</ref>), we aim at using languages that were specifically designed for navigation in property graphs, such as GQL and Cypher.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Keys in Semantic Web Stack</head><p>We now discuss how PG-Keys can be used to simulate key constraints available in the Semantic Web Stack (SWS). Due to the limited space, we forsake the existing academic work <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b65">66]</ref> and focus on the standards <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b70">71]</ref>.</p><p>At the lower layers of SWS, RDF <ref type="bibr" target="#b47">[48,</ref><ref type="bibr" target="#b79">80]</ref> uses Internationalized Resource Identifiers (IRIs) to provide a rudimentary mechanism for reference but not identification since the same real-world object may be described with multiple IRIs.</p><p>Going up the SWS, OWL <ref type="bibr" target="#b10">[11]</ref> supports keys using the HasKey construct. For example, assuming :Person is a class and :name and :birthday are properties, the snippet : Person owl : hasKey (: name : birthday ) .</p><p>asserts that instances of :Person are uniquely identified by the combination of the values of :name and :birthday; it does not say that those values exist nor that there is only one of each. This corresponds precisely to the PG-Key FOR ( x : Person ) EXCLUSIVE x . name , x . birthday . If :name and :birthday were declared as functional, e.g., : name rdf : type owl : FunctionalProperty .</p><p>the corresponding PG-Key would be an EXCLUSIVE SINGLETON constraint. Ensuring that all key components exist, under the openworld assumption adopted by OWL, is very hard.</p><p>Recent RDF constraint languages <ref type="bibr" target="#b78">[79]</ref>, such as SHACL <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b45">46]</ref> or ShEx <ref type="bibr" target="#b71">[72]</ref>, adopt the closed-world assumption. They do not have built-in key constraints, but they support cardinality constraints which can be used to emulate simple keys; keys with multiple components, like in the first example, cannot be expressed directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXTENSIONS OF PG-KEYS</head><p>We discuss extensions of PG-Keys that are not in our core formalism but would need to be eventually supported by a fully fledged design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">NULL Values</head><p>So far we have tacitly assumed that property values cannot be nulls. In real life, nulls are abundant and arise for two principal reasons. First, a value may exist but be currently unknown (for example, the birthday of a person may not be known). Second, a value may not even exist (for example, one may refer to a property of a node that does not exist, say x.age instead of x.birthday). In relational database practice, and in particular in SQL, these different scenarios are represented by the same NULL <ref type="bibr" target="#b27">[28]</ref>, and the practice has been extended to graph query languages like Cypher <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b37">38]</ref>.</p><p>SQL's approach to handling nulls is based on a three-valued logic (3VL) that extends the standard Boolean logic of true and false with a truth value unknown. It can be summarized as follows: (1) every condition involving a null evaluates to unknown; (2) truth values propagate through connectives AND, OR, and NOT by using the rules of SQL's 3VL; (3) once a condition is evaluated in the WHERE clause of a SQL query, only true tuples remain.</p><p>With PG-Keys, we propose to follow SQL's approach that a constraint holds if it does not evaluate to false. In this case one can validate a key 𝜃 by a query 𝑄 𝜃 that looks for violations of 𝜃 , that is, it computes witnesses of the negation of 𝜃 , as is explained in Section 4.5. If the key 𝜃 itself evaluates to true or unknown, then its negation is false or unknown, according to 3VL, and therefore 𝑄 𝜃 produces no output.</p><p>Nulls in conditions however need to be handled with care. To give a simple relational example (easily mimicked in a property graph), if we have a relation R(A,B) with a UNIQUE declaration on attribute A, then adding tuples (NULL,1) and (NULL,2) is possible. The uniqueness constraint, stating that there are no two different tuples with the same value of A, will evaluate to unknown, and hence will be validated. To fall back to the two-valued logic of true and false, one needs to impose NOT NULL constraints. This is what happens with primary keys: then the situation above when two NULLs can be entered is no longer possible.</p><p>We now explain how PG-Keys work in the presence of nulls. To start, we must specify what the queries used in PG-Keys are. We assume, in line with all the examples so far, that they are patterns with further constraints on property values, for example,</p><p>x WITHIN (x: Person ) WHERE x . age &gt; 30 . With each such query 𝑞( x), we associate a new query 𝑞 notnull ( x) which is the same as 𝑞 but with added IS NOT NULL conditions for each property value used in the query. For example, the above query would be transformed into</p><p>x WITHIN ( x : Person ) WHERE x . age &gt;30 AND x . age IS NOT NULL . Such a query rules out both kinds of nulls, be they due to unknown value of age or to the absence of the property age altogether.</p><p>For each condition (Ki), for 𝑖 = 1, 2, 3, used in the definition of satisfaction of PG-Keys in Section 4.1, we define a condition (Ki) null which is the same as (Ki) except that 𝑝 (𝑥) is replaced by 𝑝 notnull (𝑥) and 𝑞(𝑥, ȳ) by 𝑞 notnull (𝑥, ȳ). Notice that it is easier to satisfy (K1) null and (K3) null than (K1) and (K3) respectively, because only null-free objects must be looked at. More precisely, all the IS NOT NULL conditions appear in the antecedent, and since it is harder to satisfy the antecedent, it is thus easier to satisfy the whole constraint. In fact, (Ki), for 𝑖 = 1, 3, holds (i.e., does not evaluate to false) in 3VL if and only if the condition (Ki) null is true. In other words, to check satisfaction of EXCLUSIVE and EXCLUSIVE SINGLETON we can disregard nulls.</p><p>The situation with MANDATORY, i.e., (K2) is more involved, since (K2) null captures our intuition of such constraints, but disagrees with the 3VL semantics of (K2). To illustrate this, consider FOR ( x : Person ) EXCLUSIVE MANDATORY y WITHIN ( x ) -[: owns ] -&gt;( y : Passport ) WHERE y . expiry &gt; $today . Suppose that we have a single person in the database whose passport expiry date is NULL. Condition (K2) defining MANDATORY constraints in this case evaluates to unknown, and thus in the SQLinspired approach the constraint is satisfied. Condition (K2) null , on the other hand, is false. In the case of MANDATORY, this is the desired behavior and indeed mandatory keys should avoid nulls, similarly to primary keys in SQL that mandate NOT NULL for attributes involved.</p><p>One way of resolving this is to assume that conditions involving NULL evaluate to false rather than unknown. The idea in itself is not new, it was present in old query languages such as Quel, and was recently studied in connection with various proposals on using 2-valued logic in place of SQL's 3VL, see <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25]</ref>. In such a logic, the above MANDATORY condition would not hold for a person whose passport expiry is NULL, thus fulfilling our intuition about these constraints. At the same time, it does not affect other constraints. In fact, under this 2-valued logic of nulls, condition (Ki) is true iff (Ki) null is true, for 𝑖 = 1, 2, 3. We would thus advocate one of two options for handling nulls in PG-Keys: either use a 2-valued logic as explained here, or follow SQL's 3VL but then introduce NOT NULL declarations for properties used in MANDATORY constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Regular Path Queries</head><p>In Section 3, we assumed that key constraints for property graphs are defined using queries of the form 𝑞( x), where x is a tuple of variables that bind to nodes, edges, and property values. We now extend x to variables that bind to paths, the latter being first-class citizens in several graph query languages <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b35">36]</ref>. In the research literature <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">12]</ref> and in practical query languages, this is usually done by incorporating regular path queries (RPQs) or a subset thereof. (The term RPQ is fairly standard in the research literature, but has diverse names in practical languages, e.g., property paths or path patterns.)</p><p>As an example, let us assume that the isPartOf relation in Figure <ref type="figure">2</ref> is extended (as in LDBC Social Network Benchmark <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b31">32]</ref>) to a larger hierarchy of geographical entities, containing provinces and continents. The following PG-Key expresses that every isPartOf path from a city to a continent can be uniquely identified by the city and the continent: The variable 𝑝 binds to a path in both the scope and the descriptor of the constraint (we use a GQL-like syntax for path variables).</p><p>The following example shows the usage of paths as key components: the PG-Key asserts that if two cities within a country have the same name, then their paths to the country must differ (e.g., go via different states). Both constraints use the transitive operator isPartOf*, which matches to paths of arbitrary length in which each edge is labeled isPartOf. Notice that such use of isPartOf makes the constraints robust against changes in the data. For instance, if the geographical hierarchy would be extended in the data, e.g., by adding counties or states, then the above mentioned constraints do not need to be updated to reflect these changes in the data.</p><p>Transitive operators in key constraints also pose challenges, however. One challenge is how they deal with cyclicity in the data. This particular challenge also arises with the corresponding operators in query languages, and is part of an ongoing discussion. Essentially, the question is: which paths do we allow to match against these expressions? Current systems are working with four different variants: unrestricted, no repeated nodes (simple paths), no repeated edges (trails), or shortest paths <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b35">36]</ref>.</p><p>The choice between these alternatives is not entirely trivial, because it may have a large influence on the complexity of evaluation. In the unrestricted case, RPQs can be evaluated in polynomial time, whereas deciding whether a pair of nodes in 𝑉 is in the result set of an RPQ under simple path or trail semantics is NP-complete in general. The latter becomes tractable for certain fixed regular path expressions, leading to the classes 𝐶 tract <ref type="bibr" target="#b9">[10]</ref> and 𝑇 tract <ref type="bibr" target="#b54">[55]</ref> highly frequent in real-world query logs <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref>. The class 𝑇 tract precisely identifies the set of regular expressions for which the data complexity under trail semantics is tractable if P ≠ NP, and the slightly smaller class 𝐶 tract does the same for the simple path semantics. An even more restricted class included in 𝐶 tract and consisting of simple transitive expressions <ref type="bibr" target="#b55">[56]</ref> leads to only use simple subexpressions of the kind 𝑎 * also very common in practice <ref type="bibr" target="#b15">[16]</ref>. The query in the scope of the second constraint above falls in this latter class.</p><p>It is currently not clear which of these semantics is preferable in practice. Whereas the arbitrary path semantics has a lower evaluation complexity <ref type="bibr" target="#b62">[63]</ref>, simple path and trail semantics avoid issues with infinitely many results. Furthermore, arbitrary path semantics may lead to some issues when used for evaluating the queries within key constraints. For example, if a constraint required a path to be unique, then this would mean that this path cannot have a cycle, as cycles can be repeatedly traversed. Thus, simple path or trail semantics might be preferable in this case, bringing up the question of which semantics to use to evaluate key constraints, which is an interesting direction of investigation for next-generation graph databases implementing these constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Complex Values</head><p>In our data model we allow complex property values, such as tuples, sets, lists, or even arbitrary JSON structures, but so far we have been treating them atomically. In order to support them fully, we need to navigate inside their complex structure.</p><p>Suppose that university students can be identified by each of their multiple official email addresses. Furthermore, assume that the addresses are stored in an email property, organized into a JSON tree structure, listing addresses together with their categories (official/unofficial). To express that each official address is unique, we can use for instance JSONPath <ref type="bibr" target="#b36">[37]</ref> to iterate over the list and, for each entry storing an official address, recover the actual value of the address: Analogously to selecting simple values from a complex value, it is also possible to use descriptors to collect multiple simple values into one complex value. For instance, to express that an entity is uniquely defined by an (unordered) collection of values, we can deploy a descriptor that collects all these values into a set, and define a key with this set as a component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">LOOKING AHEAD</head><p>The LDBC Property Graph Schema Working Group has reached an important consensus and milestone by producing this recommendation for the design of property graph key constraints.</p><p>Our recommendation must be framed in its broader context: the design of the new GQL graph query language by the ISO/IEC JTC1 SC32 WG3 committee. PG-Keys is informing the design of GQL via the LDBC liaison, by having the main elements of this proposal incorporated into its future standard. Furthermore, our recommendation extends the expressivity of property graphs which may help facilitate mapping to other data models.</p><p>This paper is a call to action for industry and academia driving the graph database industry. From a developer standpoint, PG-Keys can influence the implementation of property graph keys in commercial and non-commercial graph database systems as well as their applications in many graph processing tasks. On the research side, our framework triggers a number of open problems that can attract the attention of the data management community. These problems include the validation and maintenance complexity of PG-Keys for specific query languages, the implication and inference problems, as well as the use of static analysis for optimization purposes. Furthermore, the handling of nulls in PG-Keys suggests alternatives to SQL's three-valued logic that need to be further explored.</p><p>Finally, the work of the PGSWG is not done. We are in the process of establishing consensus with respect to the semantics of a schema language and to extensions of the property graph data model to support features such as meta-properties.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Hierarchy for PG-Keys.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>ct 1 :</head><label>1</label><figDesc>City name: Wassenaar cn 1 :Country name: Japan ct 2 :City name: Wassenaar cn 2 :Country name: The Netherlands 𝑢 1 :University name: The Hague University 𝑝 2 :Person firstname: Akira lastname: Miyazaki 𝑝 1 :Person firstname: Hayao lastname: Kurosawa birthday: 1988-06-24 𝑓 0 :Forum title: Databases</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>𝑚 1 :Figure 2 :</head><label>12</label><figDesc>Figure 2:An example of a property graph: a Social Network (SN) graph database. For ease of reference, we associate with every node and edge an identifier and employ consistent typographic conventions. For instance, take the node 𝑢 1 representing the Hague University: 𝑢 1 is its identifier, University is its only label, name is a property name, and The Hague University is its value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>x , y , y. name WITHIN (x: Person ) -[: isLocatedIn ] -&gt;( y : City ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FOR</head><label></label><figDesc>( x : City ) EXCLUSIVE MANDATORY x . name , z WITHIN ( x ) -[: isPartOf ] -&gt;( z : Country ) allowing to reference cities and impose the required constraints on the graph topology. If we further require that cities are part of exactly one country, we would specify the identification constraint: FOR ( x : City ) IDENTIFIER x . name , z WITHIN ( x ) -[: isPartOf ] -&gt;( z : Country ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>FOR x WITHIN ( x : Forum ) -[: hasMember ] -&gt;(: Person ) IDENTIFIER p WITHIN ( x ) -[: hasModerator ] -&gt;( p : Person ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>FOR y WITHIN (: Country ) -[ y : isPartOf ] -&gt;(: Continent ) EXCLUSIVE x , z WITHIN ( x : Country ) -[ y ] -&gt;( z : Continent ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>FOR y WITHIN (: Person ) -[ y : studyAt ] -&gt;(: University ) EXCLUSIVE x , y. classYear , z WITHIN (x: Person ) -[y ] -&gt;( z : University ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>FOR y WITHIN () -[ y : studyAt ] -&gt;() IDENTIFIER x , y. classYear , z WITHIN (x: Person ) -[y ] -&gt;( z : University ) . Note that this is not the same as: FOR y WITHIN (: Person ) -[ y : studyAt ] -&gt;(: University ) IDENTIFIER x , y. classYear , z WITHIN ( x ) -[ y ] -&gt;( z ) , which has the scope limited to those studyAt edges that are from Person to University. As a final example, suppose that our edge constraint only holds for study years after 1970. We can express this as FOR y WITHIN () -[ y : studyAt ] -&gt;() WHERE y . classYear &gt; 1970 IDENTIFIER x , y. classYear , z WITHIN (x: Person ) -[y ] -&gt;( z : University ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>FOR y. classYear WITHIN () -[ y : studyAt ] -&gt;() EXCLUSIVE y. semester .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>FOR</head><label></label><figDesc>( x : City ) IDENTIFIER y , x . name WITHIN ( x ) -[: isPartOf ] -&gt;( y : Country ) . The query for (K1) is obtained by combining two copies of the scope with different scope variables and two copies of the descriptor with the same descriptor variable: MATCH ( x1 : City ) , ( x1 ) -[: isPartOf ] -&gt;( y : Country ) , ( x2 : City ) , ( x2 ) -[: isPartOf ] -&gt;( y : Country ) WHERE x1 &lt;&gt; x2 AND x1 . name IS NOT NULL AND x2 . name IS NOT NULL AND x1 . name = x2 . name RETURN x1 , x2 . Because the property name is also a component of the key, we additionally check that it is set and that x1.name = x2.name. The resulting query finds pairs of different targets that share a key value. Hence, (K1) holds exactly when the query returns no answers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>It illustrates an internal uniqueness constraint on the fact type is part of, represented by a line over its first role, which indicates that each City has at most one associated Country. It also illustrates an external uniqueness constraint, represented by a horizontal line in a circle connected to the second role of is part of and the second role of City.has.City name, which indicates that each combination of Country and City name is associated with at most one City. It will be clear that the internal uniqueness constraint corresponds to an EXCLUSIVE PG-Key for edges, and the external uniqueness constraint to an EXCLUSIVE PG-Key for nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>FOR</head><label></label><figDesc>(x: Person ) EXCLUSIVE SINGLETON y WITHIN (x) -[y: livesIn ] -&gt;() , FOR (x: Person ) -[: livesIn ] -&gt;() IDENTIFIER y WITHIN (x) -[y: livesIn ] -&gt;(: City ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>FOR p WITHIN p = (: City ) -[: isPartOf *] -&gt;(: Continent ) IDENTIFIER x , z WITHIN p = (x: City ) -[: isPartOf *] -&gt;( z : Continent ) .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>FOR</head><label></label><figDesc>(x: City ) EXCLUSIVE x . name , p WITHIN p = (x) -[: isPartOf *] -&gt;(: Country )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>FOR x WITHIN ( x : Person ) -[: studyAt ] -&gt;(: University ) EXCLUSIVE MANDATORY x.email[@.category='official'].address .</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>ACKNOWLEDGMENTS R. Angles was supported by <rs type="funder">ANID</rs>, <rs type="programName">Millennium Science Initiative Program</rs>, Code <rs type="grantNumber">ICN17_002</rs>; <rs type="person">L. Libkin</rs> by <rs type="funder">EPSRC</rs> grants <rs type="grantNumber">N023056</rs> and <rs type="grantNumber">S003800</rs>; <rs type="person">W. Martens</rs> by <rs type="funder">DFG</rs> grants <rs type="grantNumber">369116833</rs> and <rs type="grantNumber">431183758</rs>, and <rs type="person">F. Murlak</rs> by <rs type="funder">NCN</rs> grant <rs type="grantNumber">2018/30/E/ST6/00042</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_dQYmUKd">
					<idno type="grant-number">ICN17_002</idno>
					<orgName type="program" subtype="full">Millennium Science Initiative Program</orgName>
				</org>
				<org type="funding" xml:id="_zWmstnN">
					<idno type="grant-number">N023056</idno>
				</org>
				<org type="funding" xml:id="_q3qFe6C">
					<idno type="grant-number">S003800</idno>
				</org>
				<org type="funding" xml:id="_bMpy6md">
					<idno type="grant-number">369116833</idno>
				</org>
				<org type="funding" xml:id="_AeDuKEW">
					<idno type="grant-number">431183758</idno>
				</org>
				<org type="funding" xml:id="_2YZm4gV">
					<idno type="grant-number">2018/30/E/ST6/00042</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<idno>ISO/IEC 19757. 2016</idno>
		<title level="m">Information technology -Document Schema Definition Languages (DSDL) -Part 3: Rule-based validation -Schematron</title>
		<meeting><address><addrLine>Geneva, CH</addrLine></address></meeting>
		<imprint>
			<publisher>Standard. International Organization for Standardization</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><surname>Agensgraph</surname></persName>
		</author>
		<ptr target="https://bitnine.net/agensgraph" />
		<title level="m">AgensGraph</title>
		<imprint>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Amazon Neptune</title>
		<ptr target="https://aws.amazon.com/neptune/" />
		<imprint>
			<date type="published" when="2020">2020. 2020-11</date>
			<publisher>Amazon</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The LDBC Social Network Benchmark</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">János</forename><surname>Benjamin Antal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Averbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orri</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vlad</forename><surname>Haprian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josep-Lluís</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norbert</forename><surname>Martínez-Bazan</surname></persName>
		</author>
		<idno>CoRR abs/2001.02299</idno>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">G-CORE: A Core for Future Graph Query Languages</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Gutierrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcus</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Paradies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">F</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oskar</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Van Rest</surname></persName>
		</author>
		<author>
			<persName><surname>Voigt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1421" to="1432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Foundations of Modern Query Languages for Graph Databases</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="68" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Survey of graph database models</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Gutiérrez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="https://tinkerpop.apache.org/" />
		<title level="m">TinkerPop</title>
		<imprint>
			<publisher>Apache</publisher>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A trichotomy for regular simple path queries on graphs</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benoît</forename><surname>Groz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="29" to="48" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">OWL 2 Web Ontology Language Quick Reference Guide (Second Edition)</title>
		<author>
			<persName><forename type="first">Jie</forename><surname>Bao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Deborah</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elisa</forename><surname>Kendall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/" />
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation. W3C</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Graph Queries: From Theory to Practice</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefania</forename><surname>Dumbrava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="5" to="16" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Certified Graph View Maintenance with Regular Datalog</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefania</forename><surname>Dumbrava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emilio</forename><surname>Jesús</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gallego</forename><surname>Arias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Pract. Log. Program</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="372" to="389" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Querying Graphs</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Algebraic incremental maintenance of XML views</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Hugh</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenica</forename><surname>Sileo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Navigating the Maze of Wikidata Query Logs</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Timm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW. ACM</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="127" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An analytical study of large SPARQL query logs</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Timm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="655" to="679" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Keys for XML</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carmem</forename><forename type="middle">S</forename><surname>Hara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Chiew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tan</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="473" to="487" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Reasoning about keys for XML</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Susan</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carmem</forename><forename type="middle">S</forename><surname>Hara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang</forename><surname>Chiew</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tan</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1037" to="1063" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Constraints for Semi-structured Data and XML</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jérôme</forename><surname>Siméon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="47" to="92" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The Object Data Standard: ODMG 3</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">G G</forename><surname>Cattell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Douglas</forename><forename type="middle">K</forename><surname>Barry</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The Entity-Relationship Model -Toward a Unified View of Data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="36" />
			<date type="published" when="1976">1976. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Entity Resolution in the Web of Data</title>
		<author>
			<persName><forename type="first">Vassilis</forename><surname>Christophides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vasilis</forename><surname>Efthymiou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kostas</forename><surname>Stefanidis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Propositional and Predicate Logics of Incomplete Information</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<editor>KR.</editor>
		<imprint>
			<date type="published" when="2018">2018</date>
			<publisher>AAAI Press</publisher>
			<biblScope unit="page" from="592" to="601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Coping with Incomplete Data: Recent Advances</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Toussaint</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS. ACM</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="33" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Semantics and Validation of Recursive SHACL</title>
		<author>
			<persName><forename type="first">Julien</forename><surname>Corman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ognjen</forename><surname>Savkovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">11136</biblScope>
			<biblScope unit="page" from="318" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<ptr target="https://datastax.com/" />
		<title level="m">DataStax</title>
		<imprint>
			<publisher>DataStax</publisher>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">A Guide to the SQL Standard</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Darwen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Aggregation Support for Modern Graph Analytics in TigerGraph</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingxi</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><forename type="middle">E</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="377" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Incremental recomputation in local languages</title>
		<author>
			<persName><forename type="first">Guozhu</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Limsoon</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="88" to="98" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Duplicate Record Detection: A Survey</title>
		<author>
			<persName><forename type="first">Ahmed</forename><forename type="middle">K</forename><surname>Elmagarmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Panagiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vassilios</forename><forename type="middle">S</forename><surname>Ipeirotis</surname></persName>
		</author>
		<author>
			<persName><surname>Verykios</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The LDBC Social Network Benchmark: Interactive Workload</title>
		<author>
			<persName><forename type="first">Orri</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Averbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josep-Lluís</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnau</forename><surname>Prat-Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minh-Duc</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="619" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Keys for Graphs</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhe</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Chao Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong</forename><surname>Luna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1590" to="1601" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Dependencies for Graphs</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ping</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="5" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">UML Distilled: A Brief Guide to the Standard Object Modeling Language</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Fowler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<pubPlace>USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Cypher: An Evolving Query Language for Property Graphs</title>
		<author>
			<persName><forename type="first">Nadime</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mats</forename><surname>Rydberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrés</forename><surname>Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1433" to="1445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Gössner</surname></persName>
		</author>
		<ptr target="https://goessner.net/articles/jsonpath/" />
		<title level="m">JSONPath</title>
		<imprint>
			<date type="published" when="2007">2007. 2021-02</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Updating Graph Databases with Cypher</title>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Marsault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petra</forename><surname>Selmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Voigt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2242" to="2253" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Incremental Maintenance of Views with Duplicates</title>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Griffin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="328" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Maintaining Views Incrementally</title>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Inderpal</forename><surname>Singh Mumick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Knowledge Graphs: A Tutorial on the History of Knowledge Graph&apos;s Main Ideas</title>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Gutierrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">F</forename><surname>Sequeda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="3509" to="3510" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Object-Role Modeling Fundamentals: A Practical Guide to Data Modeling with ORM</title>
		<author>
			<persName><forename type="first">Terry</forename><surname>Halpin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>Technics Publications</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Modeling of Reference Schemes</title>
		<author>
			<persName><forename type="first">Terry</forename><forename type="middle">A</forename><surname>Halpin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BMMDS/EMMSAD</title>
		<title level="s">Lecture Notes in Business Information Processing</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="page" from="308" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Expressive, yet tractable XML keys</title>
		<author>
			<persName><forename type="first">Sven</forename><surname>Hartmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Link</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<title level="s">ACM International Conference Proceeding Series</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">360</biblScope>
			<biblScope unit="page" from="357" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<author>
			<persName><surname>Janusgraph</surname></persName>
		</author>
		<ptr target="https://janusgraph.org/(visited:2020-11" />
		<title level="m">JanusGraph</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<author>
			<persName><forename type="first">Dimitris</forename><surname>Kontokostas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Holger</forename><surname>Knublauch</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2017/REC-shacl-20170720/" />
		<title level="m">Shapes Constraint Language (SHACL). W3C Recommendation. W3C</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<ptr target="https://redislabs.com/modules/redis-graph/(vis-ited:2020-11" />
		<title level="m">RedisGraph</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
		<respStmt>
			<orgName>Redis Labs</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">RDF 1.1 Concepts and Abstract Syntax</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Lanthaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Cyganiak</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/" />
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation. W3C</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Relational databases in RDF: Keys and foreign keys</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Lausen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantic Web, Ontologies and Databases</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="43" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Querying Graphs with Data</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Neo4j Keys</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Link</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ER</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">12400</biblScope>
			<biblScope unit="page" from="19" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Representing and querying disease networks using graph databases</title>
		<author>
			<persName><forename type="first">Artem</forename><surname>Lysenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irina</forename><forename type="middle">A</forename><surname>Roznovat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mansoor</forename><surname>Saqi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Mazein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><forename type="middle">J</forename><surname>Rawlings</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Auffray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BioData Min</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">23</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<author>
			<persName><forename type="first">Murray</forename><surname>Maloney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Beech</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandy</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noah</forename><surname>Mendelsohn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Sperberg-Mcqueen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Thompson</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2012/REC-xmlschema11-1-20120405/" />
		<title level="m">W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures. W3C Recommendation. W3C</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">BonXai: Combining the Simplicity of DTD with the Expressiveness of XML Schema</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Niewerth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schwentick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">A Trichotomy for Regular Trail Queries</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Niewerth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tina</forename><surname>Trautner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STACS (LIPIcs</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Dichotomies for Evaluating Simple Regular Path Queries</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tina</forename><surname>Trautner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="16" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<author>
			<persName><surname>Memgraph</surname></persName>
		</author>
		<ptr target="https://memgraph.com/" />
		<title level="m">MemGraph</title>
		<imprint>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">BioGraph: a web application and a graph database for querying and analyzing bioinformatics resources</title>
		<author>
			<persName><forename type="first">Antonio</forename><surname>Messina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonino</forename><surname>Fiannaca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laura</forename><forename type="middle">La</forename><surname>Paglia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimo</forename></persName>
		</author>
		<author>
			<persName><forename type="first">La</forename><surname>Rosa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfonso</forename><surname>Urso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC systems biology</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">98</biblScope>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<ptr target="https://azure.microsoft.com/" />
		<title level="m">Azure Cosmos</title>
		<imprint>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
		<respStmt>
			<orgName>Microsoft</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Network motifs: simple building blocks of complex networks</title>
		<author>
			<persName><forename type="first">R</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shen-Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Itzkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kashtan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Chklovskii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Alon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">298</biblScope>
			<biblScope unit="page" from="824" to="827" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Maintenance of datalog materialisations revisited</title>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yavor</forename><surname>Nenov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Piro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">269</biblScope>
			<biblScope unit="page" from="76" to="136" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<ptr target="https://www.oracle.com/database/technologies/spatialandgraph.html" />
		<title level="m">Oracle Spatial and Graph</title>
		<imprint>
			<publisher>Oracle</publisher>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Regular Path Query Evaluation on Streaming Graphs</title>
		<author>
			<persName><forename type="first">Anil</forename><surname>Pacaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Tamer</forename><surname>Özsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1415" to="1430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Do We Need Specialized Graph Databases?: Benchmarking Real-Time Social Networking Applications</title>
		<author>
			<persName><forename type="first">Anil</forename><surname>Pacaci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alice</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jimmy</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Tamer</forename><surname>Özsu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GRADES@SIGMOD/PODS. ACM</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Identifying Objects by Declarative Queries</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Papazoglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Spaccapietra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Tari</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="255" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">What about Constraints in RDF? In Conceptual Modelling and Its Theoretical Foundations</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="7" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Identification of Database Objects by Key</title>
		<author>
			<persName><forename type="first">Norman</forename><forename type="middle">W</forename><surname>Paton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OODBS</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="volume">334</biblScope>
			<biblScope unit="page" from="280" to="285" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Integrity constraints in graph databases</title>
		<author>
			<persName><forename type="first">Jaroslav</forename><surname>Pokorný</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michal</forename><surname>Valenta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiří</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Procedia Computer Science</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="page" from="975" to="981" />
			<date type="published" when="2017">Kovačič. 2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Incremental Recomputation of Active Relational Expressions</title>
		<author>
			<persName><forename type="first">Xiaolei</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gio</forename><surname>Wiederhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="337" to="341" />
			<date type="published" when="1991">1991. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">Graph databases</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jim</forename><surname>Webber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emil</forename><surname>Eifrem</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>O&apos;Reilly Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">OWL Web Ontology Language Reference</title>
		<author>
			<persName><forename type="first">Guus</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mike</forename><surname>Dean</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2004/REC-owl-ref-20040210/" />
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation. W3C</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Complexity and Expressiveness of ShEx for RDF</title>
		<author>
			<persName><forename type="first">Sławek</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iovka</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">José</forename><surname>Emilio Labra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Gayo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">G</forename><surname>Hym</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harold</forename><forename type="middle">R</forename><surname>Prud</surname></persName>
		</author>
		<author>
			<persName><surname>Solbrig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT (LIPIcs</title>
		<title level="s">Schloss Dagstuhl -Leibniz-Zentrum für Informatik</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="195" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">On Directly Mapping Relational Databases to Property Graphs</title>
		<author>
			<persName><forename type="first">Radu</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">F</forename><surname>Sequeda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AMW</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">biochem4j: Integrated and extensible biochemical knowledge through graph databases</title>
		<author>
			<persName><forename type="first">Neil</forename><surname>Swainston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riza</forename><surname>Batista-Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Carbonell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">D</forename><surname>Dobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Dunstan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><forename type="middle">J</forename><surname>Jervis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maria</forename><surname>Vinaixa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">R</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophia</forename><surname>Ananiadou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Loup</forename><surname>Faulon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Mendes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Douglas</forename><forename type="middle">B</forename><surname>Kell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nigel</forename><forename type="middle">S</forename><surname>Scrutton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rainer</forename><surname>Breitling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLOS ONE</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<ptr target="https://sparsity-technologies.com/#sparksee" />
		<title level="m">Sparksee</title>
		<imprint>
			<publisher>Sparsity Technologies</publisher>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title/>
		<ptr target="https://neo4j.com/(visited" />
	</analytic>
	<monogr>
		<title level="j">Neo Technology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<author>
			<persName><surname>Tigergraph</surname></persName>
		</author>
		<ptr target="https://www.tigergraph.com/" />
		<title level="m">TigerGraph</title>
		<imprint>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<author>
			<persName><surname>Titan</surname></persName>
		</author>
		<ptr target="https://titan.thinkaurelius.com/" />
		<title level="m">Titan</title>
		<imprint>
			<date type="published" when="2020">2020. 2020-11</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">RDF validation: A brief survey</title>
		<author>
			<persName><forename type="first">Dominik</forename><surname>Tomaszuk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference: Beyond Databases, Architectures and Structures</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="344" to="355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">RDF 1.1: Knowledge representation and data integration language for the Web</title>
		<author>
			<persName><forename type="first">Dominik</forename><surname>Tomaszuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Hyland-Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Symmetry</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">84</biblScope>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Property Graph Database Modeling and Application of Electronic Medical Record</title>
		<author>
			<persName><forename type="first">Yuhang</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chenglin</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IMCCC Conference</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="963" to="967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Graph databases for knowledge management</title>
		<author>
			<persName><forename type="first">Justin</forename><surname>Zuopeng</surname></persName>
		</author>
		<author>
			<persName><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IT Professional</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="26" to="32" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
