<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Multi-Objective Evolutionary Approach to Class Disjointness Axiom Discovery</title>
				<funder ref="#_YAGpBcW">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_zDb6cMT">
					<orgName type="full">French government</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Thu</forename><forename type="middle">Huong</forename><surname>Nguyen</surname></persName>
							<email>thu-huong.nguyen@univ-cotedazur.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>I3S Nice</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrea</forename><forename type="middle">G B</forename><surname>Tettamanzi</surname></persName>
							<email>andrea.tettamanzi@univ-cotedazur.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Université Côte d&apos;Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>I3S Nice</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Multi-Objective Evolutionary Approach to Class Disjointness Axiom Discovery</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3C18CE3B6E5FAD45AE6918D145099C96</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Ontology Learning</term>
					<term>OWL Axiom</term>
					<term>Disjointness Axiom</term>
					<term>Genetic Programming</term>
					<term>Grammatical Evolution</term>
					<term>Multi-Objective Optimization</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The huge wealth of linked data available on the Web (also known as the Web of data), organized according to the standards of the Semantic Web, can be exploited to automatically discover new knowledge, expressed in the form of axioms, one of the essential components of ontologies. In order to overcome the limitations of existing methods for axiom discovery, we propose a two-objective grammar-based genetic programming approach that casts axiom discovery as a genetic programming problem involving the two independent criteria of axiom credibility and generality. We demonstrate the power of the proposed approach by applying it to the task of discovering class disjointness axioms involving complex class expression, a type of axioms that plays an important role in improving the quality of ontologies. We carry out experiments to determine the most appropriate parameter settings and we perform an empirical comparison of the proposed method with state-of-the-art methods proposed in the literature.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>The growth of the Semantic Web also known as the Web of data, where the Linked Open Data (LOD) is a prominent representative opens up exciting opportunities for ontology learning. Due to heterogeneous semantic resources on the Web, ontological knowledge bases (KBs) may turn out to incomplete and noisy. Specifically, the incompleteness refers to the lack of information in ontology while the noise is relevant to the issues of invalid information. To enhance the quality of an ontology, the existence of axioms can be considered as the agents in pinpointing errors and inconsistencies in KBs. In ontology construction and knowledge base enrichment, the automatic asquistion of axiom is a central task which goes under the name of axiom learning. Like other types of axioms, class disjointness axioms are used to check the consistencies of the information contained in the ontologies or to deduce new information. For example, a reasoner will be able to deduce an error, i.e., a logical inconsistency of facts in the ontology, whenever the class Fish is associated to a resource related to the class Planet, if there is a constraint of disjointness between the two concepts Fish and Planet.</p><p>As a consequence of the essential role of class disjointness axioms in existing ontologies, learning hidden knowledge in terms of axioms from a LOD repository in the context of the Semantic Web has been the object of research using several different methods. Some prominent research towards the automatic creation of class disjointness axioms from RDF facts include supervised classification, like in the LeDA system <ref type="bibr" target="#b0">[1]</ref>, statistical schema induction via associative rule mining, like in the GoldMiner system <ref type="bibr" target="#b1">[2]</ref>, and learning general class descriptions (including disjointness) from training data, like in the DL-Learner framework <ref type="bibr" target="#b2">[3]</ref>. In adtition, recent contribution has proposed using unsupervised statistical approaches like Formal Concept Analysis (FCA) <ref type="bibr" target="#b3">[4]</ref> or Terminological Cluster Trees (TCT) <ref type="bibr" target="#b4">[5]</ref>, to discover disjointness axioms. Most approaches to learning axioms in the literature are based on deterministic level-wise generate-and-test methods, which essentially perform an exhaustive search, coupled with heuristic pruning, of the the space of hypotheses. Their main limitation is that they are incapable of scaling up when the space of the hypothesis, i.e. axioms, becomes too large. As a consequence, their applicability is restricted to the discovery of relatively simple axioms, i.e. atomic axioms.</p><p>Given the complexity of the problem, a heuristic approach, such as evolutionary algorithm, can handle with the search for more complex axioms whose space is incomparably larger. In fact, there are also some recent works <ref type="bibr" target="#b5">[6]</ref>- <ref type="bibr" target="#b8">[9]</ref> applying an evolutionary approach by using Grammatical Evolution (GE) to extracting class disjointness axioms from large RDF repository, i.e., DBpedia<ref type="foot" target="#foot_0">1</ref> . The use of a grammar allows great flexibility: only the grammar needs to be changed to mine different data repositories for different types of axioms. Extracted axioms in <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref> include both atomic and complex axioms, i.e., defined with the help of relational operators of intersection and union; in other words, axioms like Dis(C 1 , C 2 ), where C 1 and C 2 are complex class expressions including operators. However, the dependence on SPARQL endpoints (i.e., query engines) for testing mined axioms against facts, i.e. instances, in large RDF repositories limits the performance of the method. In addition, evaluating the effectiveness of the method requires the participation of experts in specific domains, i.e. the use of a Gold Standard, which is proportional to the number of concepts. Hence, the extracted axioms are limited to the classes relevant to a small scope of topics, namely the Work topic of DBpedia. Also, complex axioms are defined with the help of relational operators of intersection and union, which can also be mechanically derived from the known atomic axioms. To overcome that limitation, the type of mined class disjointness axioms in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> is extended to include the existence restriction (∃r.C) and value restriction (∀r.C) constructors, where r is a property and C a class, which cannot be mechanically derived from a given set of atomic axioms. Furthermore, a training-testing model is applied to objectively validate the method. Specifically, the whole DBpedia is used as the objective benchmark for evaluating the extracted axioms from a small training RDF dataset, i.e. sample of DBpedia, and eliminating the use of Gold Standard created by knowledge experts. The evaluation framework based on possibility theory <ref type="bibr" target="#b6">[7]</ref>- <ref type="bibr" target="#b8">[9]</ref> to determine the fitness values of generated axioms in the evolutionary cycle, i.e. the credibility and generality of axioms. However, the selection pressure in each phases of the evolutionary process tends naturally to drive the diversity of the population down. In addition, the presence of highly fit but possibly invalid candidate axioms in the population reduces the number of valid axioms that can be discovered which can be derived from unsuited fitness function in evaluation framework which based on a single criterion.</p><p>Along the lines of the studies using GE to mine class disjointness axioms, we extend the approach as a multiobjective problem, i.e. multi-objective GE, in additition to the trade-off between a set of objectives. Specifically, we used an multi-objectives approach to refine the evaluation of candidate axioms that improves the adaptive fit of a population of candidate axioms constrained by two independent criteria, i.e. the credibility and generality. We also proposed a new measure called the similarity and a method to compute it. We aim to optimize the evaluation framework for the axioms which ensures the high accuracy, generality and the diversity of the obtained axioms. In the study, we reuse the grammar and the training-testing model to extract class disjointness axioms in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> and perform comparison with the relevant approaches.</p><p>The rest of the paper is organized as follows: some basics in GE and GE in axioms discovery are provided in Section II. Axiom discovery in multi-objective GE approach is presented in Section III. Section IV introduces the organization of dataset. The experimental settings and results are presented and discussed in Section V. Finally, conclusions and directions for future research are given in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. GRAMMATICAL EVOLUTION FOR AXIOM DISCOVERY</head><p>The foundation of our study is Grammatical Evolution (GE), a recent evolutionary model pioneered by Michael O'Neil and his collaborators <ref type="bibr" target="#b9">[10]</ref>. In this section, we provide a summary of the GE in addition to theoretical and technical ingredients concerning axiom discovery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Basics</head><p>Grammatical Evolution (GE) is an evolutionary approach that extends Genetic Programming (GP) <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b11">[12]</ref> to allow the exploration of the space of computer programs through the use of a grammar-mediated representation. Programs, viewed According to it, the variable-length binary string genomes, or chromosomes, are split into consecutive groups of bits, called codons, representing an integer value, used to select, at each step, one of a set of production rules from a formal grammar, typically in Backus-Naur form (BNF), which specifies the syntax of the desired programs. Furthermore, inspired by biological evolution and its fundamental mechanisms, these programs are "bred" using iterative improvement of an initially random population of programs. That is an evolutionary process. At each iteration, known as a generation, improvements are made possible by stochastic variation, i.e., by a set of genetic operators, usually crossover and mutation, and probabilistic selection according to pre-specified criteria for judging the quality of an individual (solution). According to the levels of fitness, the process of selecting individuals, called fitness-based selection, is performed to create a list of better qualified individuals as input for generating a new set of candidate solutions in the next generation. The new solutions of each generation are bred by applying genetic operators on the selected old individuals. Then, replacement is the last step and decides which individuals stay in a population and which are replaced on a par, with selection influencing convergence. An illustration of the GE mechanism is presented in Fig 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. BNF Grammar</head><p>In terms of axioms discovery, "programs" or "phenotypes" refer to axioms constrained by a given BNF grammar. A BNF grammar is a context-free grammar consisting of terminal and non-terminal symbols (also called just terminals and nonterminals) and being represented in the form of a four-tuple {N, T, P, S}, where N is the sets of non-terminals, which can be extended into one or more terminals; T is the set of terminals, which are tokens in the described language; P is the set of the production rules that map N to T ; S is the start symbol and a member of N . When there are a number of productions that can be used to rewrite one specific nonterminal, they are separated by the '|' symbol.</p><p>We comply with the BNF grammar given in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> to mine binary disjointness axioms only, of the form DisjointClasses(C 1 , C 2 ), where C 1 and C 2 may be atomic or complex classes involving relational operators, i.e. existential quantification and value restriction, and possibly including more than one single class identifier, like DisjointClasses(VideoGame, ObjectAllValuesFrom(hasStadium, Sport)). To make the paper self-contained, we recall here the most important aspects of this grammar. The grammar is split into a static and a dynamic part to ensure that changes in the contents of RDF repositories will not require the grammar to be rewritten. The static part defines the syntax of the types of axioms to be extracted. The content of this part is loaded from a hand-crafted text file. The structure of the BNF grammar here aims at mining well-formed axioms expressing the facts, i.e. instances, contained in a given RDF triple store. Hence, only resources that actually occur in the RDF dataset should be generated. The static part of the grammar is thus structured as follows:</p><p>The dynamic part contains production rules for the low-level non-terminals, called primitives in <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b6">[7]</ref>. These production rules are automatically filled at run-time by querying the SPARQL endpoint of the RDF data source at hand. Let us consider an example representing a small sample of an RDF dataset: The productions for Class and ObjectPropertyOf would thus be: </p><formula xml:id="formula_0">PREFIX</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Mapping Process</head><p>In the mapping process, codons are used consecutively to choose production rules in the BNF grammar according to the function: production = codon modulo Number of productions for the current non-terminal <ref type="bibr" target="#b0">(1)</ref> We illustrate the decoding of an integer chromosome into an OWL class disjointness axiom through a specific example (see <ref type="bibr">Fig 2)</ref>. Let the chromosome be (352, 265, 529, 927, 419). There is only one production for the non-terminals Axiom, ClassAxiom, DisjointClasses, ObjectIntersectionOf, ObjectSomeValuesFrom and ObjectAllValuesFrom, as it can be seen from Rules 1-3 and 6-8. In these cases, we skip using any codons for mapping and concentrate on reading codons for nonterminals having more than one production, like in Rules 4, 5, 9, and 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MULTI-OBJECTIVE GE FOR AXIOM DISCOVERY</head><p>Within the evolutionary process, the evaluation framework quantifies the quality of axioms, which is the base for selecting individuals (solutions) for the recombination, mutation, and replacement phases. In previous work <ref type="bibr" target="#b6">[7]</ref>- <ref type="bibr" target="#b8">[9]</ref>, the aim was to look for credible and general axioms, based on possibilistic axiom scoring for credibility and on a scoring of their generality. These two scores were then combined into a single fitness function, i.e., a single objective. The superiority of an axiom over other ones was simply determined by comparing their fitness scores. However, the fitness values can suffer from one of two objectives offsetting the other, for instance when a high generality score is assigned to axioms possessing a low possibility. In fact, the two criteria of generality and credibility are incommensurable and any way of combining them is therefore largely a matter of points of view, hard to justify on an objective basis. To overcome that limitation, we treat the problem as a multi-objective optimization problem, which allows for explicit trade-offs with respect to a set of objectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Multi-Objective Evolutionary Algorithms</head><p>A Multi-objective Optimization (MO) <ref type="bibr" target="#b12">[13]</ref> problem involves a number of objective functions constituting a multidimensional objective space, in addition to the decision variable space. Specifically, a solution to a MO problem is a vector of decision variables x = (x 1 , x 2 , ...., x n ) T in the decision space X. For each x, there exists an objective vector y = (y 1 , y 2 , ...., y n ) T in the objective space Y mapped by a function f : X → Y .</p><p>The term domination is used for the situation of comparing two solutions x (1) and x (2) . A solution x (1) dominates the other solution x (2) (x (1) x (2) ) if x (1) is no worse than x (2)  in all objectives (no component of y (1) is smaller than the component of y (2) , where y (1) = f (x (1) ) and y (2) = f (x (2) )), and x (1) is strictly better than x (2) in at least one objective (at least one component is greater). The set of optimal solutions in the decision space X is denoted as Pareto-optimal solutions or Pareto set. In addition, there are corresponding optimal objective vectors, i.e. points, in the objective space Y , denoted as Pareto-optimal front or non-domination front. In MO, all objectives are equally important, i.e., finding the optimum solution cannot be based on one objective alone while skipping other objectives. The goal of MO is to find multiple solutions Fig. <ref type="figure">2</ref>. An illustration of mapping process representing the possible non-dominated trade-offs among the objective functions, i.e., a set of solutions lying on the Paretooptimal front. In addition, a set of obtained solutions is sought for that is also diverse enough to represent the entire range of the Pareto-optimal front. This results in a heuristic approach, the Multi-objective Evolutionary Algorithm (MOEA) <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b13">[14]</ref>, which follows the goal of MO but refers to finding multiple non-dominated points as close to the Pareto-optimal front as possible, i.e., a Pareto-optimal front approximation, with respect to the trade-off among objectives. Also, it provides operators, i.e., recombination and mutation operators, to constantly improve the evolving non-dominated points.</p><p>NSGA-II <ref type="bibr" target="#b14">[15]</ref> is one of the well-known multi objective evolutionary algorithms, which simultaneously optimizes each objective without being dominated by any other solution. NSGA-II concentrates on finding non-dominated solutions in addition to elistist and diversity preserving mechanisms.</p><p>As a particular case of MOEA, the approach we propose comprises the integration of GE in MOEA i.e., using NSGA-II, for axiom discovery, which we call Multi-Objective GE (MOGE). Basically, the mechanism of MOGE is quite similar to the one of a MOEA, except that we define multi-objective problems using integer arrays called codons as decision variables. The codons do not define axioms, i.e., the programs, themselves, but provide instructions for deriving axioms using the BNF grammar through the mapping process explained above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Multi-objective Evaluation Framework</head><p>The goodness of an axioms is determined by its dominance, whereby it obtains a score on each objective which is not dominated by the corresponding score of another axiom. To derive such axioms, we extend the classic GE approach presented in <ref type="bibr" target="#b5">[6]</ref>- <ref type="bibr" target="#b8">[9]</ref> to MOGE. We also develop separate objective functions to evaluate the fitness of each axiom. In order to ensure the diversity of the obtained axioms, a scoring of the similarity of each axiom to the other axioms in the population (essentially, a local phenotypic crowding measure) is also considered in the evaluation framework. In this section, we first recall axiom the scoring, regarding possibility and generality applied in <ref type="bibr" target="#b6">[7]</ref>- <ref type="bibr" target="#b8">[9]</ref>. In addition, we introduce a new scoring, called the similarity. Finally, the objective functions for the method are presented.</p><p>1) Possibility Measure: is based on possibility theory <ref type="bibr" target="#b15">[16]</ref>, a mathematical theory of epistemic uncertainty. In the openworld, the knowledge base represented by RDF repository is incomplete. Additionally, as a results of the heterogeneous and collaborative character of the LOD, there exist some missing and erroneous facts (instances) in RDF datasets, i.e. noisy knowledge. Hence, adopting an axiom scoring heuristics based on possibility theory (see <ref type="bibr" target="#b16">[17]</ref> for the theoretical background) is well-suited. Accordingly, a candidate axiom φ is viewed as a hypothesis that has to be tested against the evidence contained in an RDF dataset. Its content is defined as a finite set of logical consequences</p><formula xml:id="formula_1">content(φ) = {ψ : φ |= ψ},<label>(2)</label></formula><p>obtained through the instantiation of φ to the vocabulary of the RDF repository; every ψ ∈ content(φ) may be readily tested by means of a SPARQL ASK query. The support of axiom φ, u φ , is defined as the cardinality of content(φ). The support, together with the number of confirmations u + φ (i.e., the number of ψ for which the test is successful) and the number of counterexamples u - φ (i.e., the number of ψ for which the test is unsuccessful), are used to compute a degree of possibility Π(φ) for axiom φ, defined, for u(φ) &gt; 0, as</p><formula xml:id="formula_2">Π(φ) = 1 -1 - u φ -u - φ u φ 2 .</formula><p>Possibility alone is a reliable measure of the credibility of a class disjointness axiom, all the more so because (and this is a very important point), in view of the open world assumption, for two classes that do not share any instance, disjointness can only be hypothetical (i.e., fully possible, if not contradicted by facts, but never necessary). Possibility is measured by defining the numbers of counterexamples and the support. These values are counted by executing the corresponding SPARQL queries based on graph patterns, via an accessible SPARQL endpoint.</p><p>We refer the interested reader to <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref> for an in-depth description of the relevant SPARQL queries.</p><p>2) Generality measure: is determined by the quantities of the facts(instances), in the extension of its components. In <ref type="bibr" target="#b5">[6]</ref>, the generality of an axiom is defined as the cardinality of the set of the facts in the RDF repository reflecting the support of each axiom, i.e., u φ . However, in case one of the components of an axiom is not supported by any fact, its generality should be zero. Hence, the generality of an axiom should be measured by the minimum of the cardinalities of the extensions of the two class expressions involved, i.e. g φ = min{ [C] , [D] } where C, D are class expressions.</p><p>3) Similarity measure: quantifies the similarity of an axiom φ, s(φ), to the population of n axioms which is defined by the average of similarity metrics s(φ, a i ) between axiom φ and each axiom a i in the population:</p><formula xml:id="formula_3">s(φ) = 1 n -1 n i=1;ai =φ s(φ, a i )<label>(3)</label></formula><p>In order to measure the similarity coefficient s(φ) as in the above formula, the similarities s(φ, a i ) need to be computed. Expressions in each axiom are represented in the form of binary trees where each node can be an atomic class or a relational operator, namely existential quantification (∃), value restriction (∀), or intersection ( ) operators. Determining each similarity between expressions, e.g., s(A, C), is performed on corresponding binary trees t 1 and t 2 . Binary trees are traversed simultaneously and each pair of corresponding nodes (p j , q j ) in both trees, i.e., p j in t 1 and q j in t 2 , is compared to each other and the value returned is the similarity between two nodes, i.e., s(p j , q j ), according to Table <ref type="table">I</ref>. One notable point is that if both nodes represent atomic classes, the value returned is 1 if the two nodes represent the same class; otherwise the value returned is 0. Each similarity between expressions, e.g. s(A,C), is defined as</p><formula xml:id="formula_4">s(A, C) = 1 k k j=1 s(p j , q j )<label>(5)</label></formula><p>where k is the number of pairs defined by the number of nodes in the smallest tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE I MATRIX FOR THE COMPARISON BETWEEN NODES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Node</head><p>Atomic class</p><formula xml:id="formula_5">∃ ∀ Atomic class 0 or 1 0 0 0 0 1 0 0.5 ∃ 0 0 1 0 ∀ 0 0.5 0<label>1</label></formula><p>4) Objective Functions: are used for the comparisons between axioms which reflect the correlation of measures to determine the quality of each axiom. We propose two objective functions, f 1 and f 2 , used in our approach, which aim at obtaining axioms that maximize the value of possibility and generality, while not being too similar among themselves:</p><formula xml:id="formula_6">       Maximize f 1 = Π(φ) • 1 -s(φ) 2 Maximize f 2 = g φ • 1 -s(φ) 2 Where 0 ≤ Π(φ) ≤ 1; g φ ≥ 0 ; 0 &lt; s(φ) &lt; 1<label>(6)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. DATASET ORGANIZATION</head><p>To investigate the effectiveness of our approach, we organize our dataset following the "training-testing" model. Specifically, the learning process is performed with the input data source derived from a training RDF dataset, a random sample of DBpedia, whereas the evaluation of discovered axioms is based on a testing dataset, which is the full DBpedia, which can be considered as an objective benchmark. The workflow of this model is shown in Fig <ref type="figure" target="#fig_3">3</ref>. We use the same Training Dataset<ref type="foot" target="#foot_1">2</ref> (TD) used in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, with 6,739,240 connected RDF triples with a variety of topics from DBpedia, which randomly collect 1% of the triples from DBpedia 2015-04 (English version).The performance of the method is measured by using the entire DBpedia 2015-04 as a test set, measuring possibility, generality, and similarity scores for every distinct axiom discovered by our algorithm. To avoid overloading DBpedia's SPARQL endpoint, we set up a local mirror using the Virtuoso Universal Server. <ref type="foot" target="#foot_2">3</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTS &amp; RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experimental Protocol</head><p>We use the BNF grammar introduced in Section II. In addition, to make fair comparisons possible with previous studies <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, a set of milestones of total effort k (defined as the total number of fitness evaluations) corresponding to each population size are also recorded for each run, namely 100,000; 200,000; 300,000 and 400,000, respectively. The maximum numbers of generations, maxGenerations (used as the stopping criterion of the algorithm) are automatically determined based on the values of the total effort k, thus popSize • maxGenerations = k.</p><p>A prototype system of the proposed method was developed in Java, using Apache Jena to interface with SPARQL endpoints and GEVA v.2.0<ref type="foot" target="#foot_3">4</ref> , a reference Java implementation of GE. Also, we integrated the system with the MOEA framework API, <ref type="foot" target="#foot_4">5</ref> a Java framework for multi-objective optimization. The parameters are listed in Table <ref type="table" target="#tab_1">II</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Results</head><p>We ran the MOGE method for 20 distinct runs for each of the different parameter settings summarized in Table <ref type="table" target="#tab_1">II</ref>, using the BNF grammar defined in Section II-B. The full set of valid distinct axioms, i.e., axioms φ such that Π(φ) &gt; 0 and g φ &gt; 0 discovered are available online. <ref type="foot" target="#foot_5">6</ref> Statistics for automatically generated axioms are presented in Table <ref type="table" target="#tab_1">III</ref>. In addition, we can see in Fig. <ref type="figure" target="#fig_5">4</ref> that the number of valid distinct axioms for most parameter settings, i.e., population size popSize and total effort k, mined by MOGE is significantly greater than those mined by the single-objective GE method in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>. This means that the diversity of an extracted set of axioms is considerably enhanced when we use the MOGE method. Furthermore, we follow the use of the fuzzy extension of the usual definition of precision in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> to measure the accuracy of our results. Accordingly, Π(φ) is interpreted as the degree of membership of axiom φ in the (fuzzy) set of the "positive" axioms. The value of precision can thus be computed against the test dataset, i.e., DBpedia 2015-04, according to the formula precision = true positives discovered axioms</p><formula xml:id="formula_7">= φ Π DBpedia (φ) φ Π TD (φ) .<label>(7)</label></formula><p>where Π TD and Π DBpedia are the possibility measures computed on the training dataset and DBpedia, respectively. The results in Table IV confirm the high accuracy of the proposed MOGE method. The precision values are quite equivalent to the figures of GE method <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref> with the range from 0.984 to 0.996 for all the different considered population sizes and different numbers of generations (reflected through the values of total effort). in terms of the two objectives, i.e. possibility and generality, compared with the GE methods of <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>. We perform the comparison based on the results of the best setting, i.e., those yielding the largest number of obtained distinct axioms and the highest accuracy, for either method, i.e., {popSize = 10, 000; k = 200, 000} and {popSize = 5, 000; k = 300, 000}, respectively. We can observe that the number of highly qualified axioms (Π(Φ) &gt; 2 3 and g Φ &gt; 100)) is maintained in MOGE system. More clearly, based on the specific resulting statistics, the number of obtained axioms from MOGE in the best setting is 38, 134 which is much greater than those extracted by the GE, i.e., 23, 767 axioms. In addition, with the smaller value of total effort k reflecting the cost of evaluations, i.e., k = 200, 0000 compared with k = 300, 000 in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, MOGE is clearly more effective in inducing highly qualified axioms. We also show the distribution of the discovered axioms in this best setting in terms of similarity coefficient in Fig. <ref type="figure">6</ref>. The range of similarity scores recorded for these axioms lies below 0.35, which indicates a good diversity of the classes and properties in the components of axioms. Based on the given grammar, one part of the axioms is forced to contain a relational operator, i.e. ∃, ∀, or , hence, the overlap of the operators in axioms does not allow the similarity score to be zero.</p><p>According to the results, we consider in detail the axioms discovered by the algorithm with this best setting. First, we witness that the number of obtained axioms containing the ∃ operator is slightly larger than the one  of those with the ∀ operator, namely 40,122 and 36,682 axioms, respectively. However, together with the mandatory class expression containing the ∀ or ∃ operator, most extracted class disjointness axioms contain an atomic class expression. This may be due to the fact that the support of atomic classes is usually larger than the support of a complex class expression. Specifically, we obtain 7 axioms containing complex expressions in both their members. These axioms are less general, even though they are completely possible. An example is the case with DisjointClasses(ObjectAllValuesFrom(dbprop:operation dbo:MilitaryConflict) ObjectAllValuesFrom(dbprop:order dbo:MIlitaryUnit))(Π(φ) = 1.0 ; g φ = 1). Also, we analyze an example of a completely possible and highly general axiom, DisjointClasses(dbo:District ObjectSomeValuesFrom(dbo:birthPlace dbo:Place)) (Π(φ) = 1.0 ; g φ = 8, 483), which we can paraphrase as "districts cannot have a place as their birthplace". Knowing that District and Place are not disjoint, this axiom states that District and ∃birthPlace.Place are in fact disjoint; in addition, ∃birthPlace.Place, i.e., "(people) whose birthplace is a place" is a class with many instances, hence the high generality of the axiom.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GE MOGE</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION</head><p>We have proposed a multi-objective extension to a grammarbased genetic programming approach to axiom discovery which consists of using two objectives plus a "similarity" score, which is in fact a sort of a local phenotypic crowding factor. The experimental results confirm that the proposed method is capable of discovering highly accurate and general axioms and is more effective compared with the singleobjective methods of previous studies. In the future, we will focus on mining disjointness axioms involving further types of complex classes, by bringing into the picture other relational operators such as owl:hasValue and owl:OneOf. We also plan on refining the evaluation of candidate axioms with the inclusion of some measurement of their complexity in the fitness function. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GE MOGE</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Grammatical Evolution mechanism</figDesc><graphic coords="3,311.98,50.54,257.04,113.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>As mentioned in II-B, axioms are structured in the form of binary axioms of the form φ ≡ DisjointClasses(A, B) and a i ≡ DisjointClasses(C, D) where A, B, C, D can be atomic expressions or complex expressions containing relational operators of restriction, i.e., existential quantification and value restriction. We define the similarity between two axioms based on the similarities between pairs of expressions as s(φ, a i ) = max{s(A, C), s(A, D), s(B, C), s(B, D)} (4)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Workflow of class disjointness axioms discovery using GE in the training-testing model</figDesc><graphic coords="6,311.98,544.09,257.04,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5</head><label>5</label><figDesc>illustrates the distribution of axioms having Π(φ) &gt; 2 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Statistical comparison about the number of axioms discovered over 20 runs between MOGE and GE method.</figDesc><graphic coords="8,68.49,63.29,231.33,231.33" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 . 3 Fig. 6 .</head><label>536</label><figDesc>Fig. 5. Possibility and generality distribution of the discovered axioms with Π(φ) &gt; 2 3</figDesc><graphic coords="9,68.50,63.30,231.33,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="5,72.92,50.54,462.67,255.13" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II PARAMETER</head><label>II</label><figDesc>VALUES FOR MOGE.</figDesc><table><row><cell>Parameter</cell><cell>Value</cell></row><row><cell>Total effort k</cell><cell>100,000; 200,000; 300,000; 400,000</cell></row><row><cell>initLenChrom</cell><cell>6</cell></row><row><cell>pCross</cell><cell>80%</cell></row><row><cell>popSize</cell><cell>1000; 2000; 5000; 10000</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE IV AVERAGE</head><label>IV</label><figDesc>PRECISION PER RUN (±std)</figDesc><table><row><cell></cell><cell></cell><cell>GE</cell><cell></cell><cell></cell><cell></cell><cell cols="2">MOGE</cell><cell></cell></row><row><cell>X k X X 100,000 X X popSize X X</cell><cell>1,000 0.981 0.019</cell><cell>2,000 0.999 ±0.002</cell><cell>5,000 0.998 ±0.002</cell><cell>10,000 0.998 ±0.003</cell><cell>1,000 0.988 ±0.007</cell><cell>2,000 0.990 ±0.005</cell><cell>5,000 0.989 ±0.003</cell><cell>10,000 0.996 ±0.001</cell></row><row><cell>200,000</cell><cell>0.973 ±0.024</cell><cell>0.979 ±0.011</cell><cell>0.998 ±0.001</cell><cell>0.998 ±0.002</cell><cell>0.989 ±0.007</cell><cell>0.990 ±0.004</cell><cell>0.987 ±0.004</cell><cell>0.988 ±0.004</cell></row><row><cell>300,000</cell><cell>0.972 ±0.024</cell><cell>0.973 ±0.014</cell><cell>0.993 ±0.007</cell><cell>0.998 ±0.001</cell><cell>0.989 ±0.007</cell><cell>0.989 ±0.003</cell><cell>0.986 ±0.004</cell><cell>0.986 ±0.003</cell></row><row><cell>400,000</cell><cell>0.972 ±0.024</cell><cell>0.969 ±0.018</cell><cell>0.980 ±0.008</cell><cell>0.998 ±0.001</cell><cell>0.989 ±0.008</cell><cell>0.990 ±0.003</cell><cell>0.985 ±0.004</cell><cell>0.984 ±0.004</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://wiki.dbpedia.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Available for download at http://bit.ly/2OtFqHp</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>https://virtuoso.openlinksw.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>http://ncra.ucd.ie/Site/GEVA.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>http://moeaframework.org/javadoc/index.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>https://bit.ly/38crj4M</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This research was carried out in the Wimmics team, which is a joint research team of <rs type="institution">Université Côte d'Azur, Inria</rs>, and I3S. Our research motto: AI in bridging social semantics and formal semantics on the Web. This work has been partially supported by the <rs type="funder">French government</rs>, through the <rs type="programName">3IA Côte d'Azur "Investments in the Future</rs>" project managed by the <rs type="funder">National Research Agency (ANR)</rs> with the reference number <rs type="grantNumber">ANR-19-P3IA-0002</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_zDb6cMT">
					<orgName type="program" subtype="full">3IA Côte d&apos;Azur &quot;Investments in the Future</orgName>
				</org>
				<org type="funding" xml:id="_YAGpBcW">
					<idno type="grant-number">ANR-19-P3IA-0002</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Learning disjointness</title>
		<author>
			<persName><forename type="first">J</forename><surname>Völker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vrandecic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sure</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hotho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ESWC, ser. Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">4519</biblScope>
			<biblScope unit="page" from="175" to="189" />
			<date type="published" when="2007">2007</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automatic acquisition of class disjointness</title>
		<author>
			<persName><forename type="first">J</forename><surname>Völker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fleischhacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Stuckenschmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Sem</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="124" to="139" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Dl-learner: Learning concepts in description logics</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lehmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="2639" to="2642" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Redescription mining for learning definitions and disjointness axioms in linked open data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Reynaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Toussaint</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">ICCS, ser. Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">11530</biblScope>
			<biblScope unit="page" from="175" to="189" />
			<date type="published" when="2019">2019</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Terminological cluster trees for disjointness axiom discovery</title>
		<author>
			<persName><forename type="first">G</forename><surname>Rizzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Amato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Fanizzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Esposito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC (1)</title>
		<title level="s">ser. Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10249</biblScope>
			<biblScope unit="page" from="184" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Learning class disjointness axioms using grammatical evolution</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G B</forename><surname>Tettamanzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">EuroGP, ser. Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">11451</biblScope>
			<biblScope unit="page" from="278" to="294" />
			<date type="published" when="2019">2019</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">An evolutionary approach to class disjointness axiom discovery</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<publisher>WI. ACM</publisher>
			<biblScope unit="page" from="68" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Using grammar-based genetic programming for mining disjointness axioms involving complex class expressions</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<publisher>ICCS. Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Grammatical evolution to mine OWL disjointness axioms involving complex concept expressions</title>
	</analytic>
	<monogr>
		<title level="m">WCCI. IEEE</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Grammatical evolution</title>
		<author>
			<persName><forename type="first">M</forename><surname>O'neill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ryan</surname></persName>
		</author>
		<idno type="DOI">10.1109/4235.942529</idno>
		<ptr target="http://dx.doi.org/10.1109/4235.942529" />
	</analytic>
	<monogr>
		<title level="j">Trans. Evol. Comp</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="349" to="358" />
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Genetic Programming: On the Programming of Computers by Means of Natural Selection</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Vanneschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Poli</surname></persName>
		</author>
		<title level="m">Genetic Programming -Introduction, Applications, Theory and Open Issues</title>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Multi-objective optimisation using evolutionary algorithms: An introduction</title>
		<author>
			<persName><forename type="first">K</forename><surname>Deb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Multi-objective Evolutionary Optimisation for Product Design and Manufacturing</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="3" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A tutorial on evolutionary multiobjective optimization</title>
		<author>
			<persName><forename type="first">E</forename><surname>Zitzler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Laumanns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bleuler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Metaheuristics for Multiobjective Optimisation</title>
		<editor>
			<persName><forename type="first">X</forename><surname>Gandibleux</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Sevaux</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Sörensen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>T'kindt</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="3" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A fast and elitist multiobjective genetic algorithm: NSGA-II</title>
		<author>
			<persName><forename type="first">K</forename><surname>Deb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pratap</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Meyarivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Evol. Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="182" to="197" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fuzzy sets as a basis for a theory of possibility</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Zadeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fuzzy Sets and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="3" to="28" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Possibilistic testing of OWL axioms against RDF data</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G B</forename><surname>Tettamanzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faron-Zucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Approx. Reasoning</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="114" to="130" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
