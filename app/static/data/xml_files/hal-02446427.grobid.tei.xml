<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ontology-Based RDF Integration of Heterogeneous Data</title>
				<funder ref="#_BXAMpHP">
					<orgName type="full">Inria Project Lab iCoda</orgName>
				</funder>
				<funder ref="#_M5dkMcp">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">Inria and LIX (</orgName>
								<orgName type="laboratory" key="lab2">UMR 7161</orgName>
								<orgName type="institution">CNRS and Ecole polytechnique)</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Univ. Rennes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">IRISA</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">Inria and LIX (</orgName>
								<orgName type="laboratory" key="lab2">UMR 7161</orgName>
								<orgName type="institution">CNRS and Ecole polytechnique)</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Univ. Montpellier</orgName>
								<orgName type="institution" key="instit2">LIRMM</orgName>
								<address>
									<settlement>Inria</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Ontology-Based RDF Integration of Heterogeneous Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">BC0F2D7C8829449E121CD7EE07F6C49C</idno>
					<idno type="DOI">10.5441/002/edbt.2020.27</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The proliferation of heterogeneous data sources in many application contexts brings an urgent need for expressive and efficient data integration mechanisms. There are strong advantages to using RDF graphs as the integration format: being schemaless, they allow for flexible integration of data from heterogeneous sources; RDF graphs can be interpreted with the help of an ontology, describing application semantics; last but not least, RDF enables joint querying of the data and the ontology. To address this need, we formalize RDF Integration Systems (RIS), Ontology Based-Data Access mediators, that go beyond the state of the art in the ability to expose, integrate and flexibly query data from heterogeneous sources through GLAV (global-localas-view) mappings. We devise several query answering strategies, based on an innovative integration of LAV view-based rewriting and a form of mapping saturation. Our experiments show that one of these strategies brings strong performance advantages, resulting from a balanced use of mapping saturation and query reformulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The proliferation of digital data sources across all application domains brings a new urgency to the need for tools which allow to query heterogeneous data (relational, JSON, key-values, graphs etc.) in a flexible fashion. Traditional data integration systems fall into two classes: data warehousing, where all data source content is materialized in a single centralized source, respectively, mediation, where data remains in their original stores and all data can be queried through a single module called mediator. Data warehousing simplifies query evaluation, but requires potentially costly maintenance operations when the content of data sources changes; mediation does not suffer from these drawbacks, but requires more intricate query evaluation algorithms to distribute the work between the sources and the mediator. Below, we classify prior mediator-based approaches according to two main dimensions, and illustrate this classification in Table <ref type="table">1</ref>. Note that we also include in this table theoretical frameworks that did not necessarily lead to implementations. A first dimension concerns the data model and query language provided by the mediator to its applications. (i) The earliest goal of a mediator system was to mimic a single, integrated database. Thus the mediator supports one data model and its query language, e.g., relational and SQL, or XML and XPath/XQuery. More recent polystore systems support side-byside different (data model, query language) pairs. These databasestyle mediators appear in the row we label DB in Table <ref type="table">1</ref>. (ii) Mediators studied in knowledge representation and management research provide a view of the data sources as a set of classes and relationships, also endowed with a set of semantic</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mappings</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GAV LAV GLAV</head><p>Model DB <ref type="bibr">[22, 24, 27] [4, 5, 22, 38]</ref> [19] CQ <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b42">43]</ref> [1, <ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b35">36]</ref> [18] SPARQL-data <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b33">34]</ref>  <ref type="bibr" target="#b44">[45]</ref> [21] SPARQL <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b43">44]</ref> this work Table <ref type="table">1</ref>: Outline of the positioning of our work.</p><p>constraints, or ontology. In such systems, users formulate conjunctive (relational) queries; answering them involves not only evaluation over the data (as done in DB mediators), but also reasoning on the data with the help of ontologies. This mediation approach is also commonly termed Ontology-Based Data Access (OBDA) <ref type="bibr" target="#b40">[41]</ref>, with ontologies expressed in Description Logics (DL, in short). Work following this approach are listed in the row we label CQ in Table <ref type="table">1</ref>. (iii) RDF <ref type="bibr" target="#b46">[47]</ref> is naturally suited as an integration model, thanks to its flexibility, its wide adoption in the Open Data community, its close relationship with ontology languages such as RDFS and OWL, and the presence of its associated standard SPARQL query language. Accordingly, several mediators from the CQ group have been extended to support RDF as an integration model and SPARQL query answering. However, while SPARQL allows querying the data together with the ontology, e.g., "find the properties of node n, as well the classes to which the values of these properties belong", a DL-based mediation approach shares with all logic-based query languages, e.g., Datalog, SQL etc., the inability to do so. RDF mediators which support SPARQL but limited to querying the data only (not the ontology) appear in the row we label SPARQL-data in Table <ref type="table">1</ref>. (iv) Recent RDF mediators lift this limitation to support joint querying of the data and ontology; we list them in the SPARQL row in Table <ref type="table">1</ref>.</p><p>A second dimension is how the source (or local) schemas are connected to the global (integration) schema, using mappings <ref type="bibr" target="#b22">[23]</ref>. There are three types of mappings, each corresponding to a column in Table <ref type="table">1</ref>. The simplest mappings define each element of the global schema, e.g., each relation (if the global schema is relational), as a view over the local schemas; this is known as Global-As-View, or GAV in short. In a GAV system, a query over the global (virtual) schema is easily transformed into a query over the local schemas, by unfolding each global schema relation, i.e., replacing it with its definition. In contrast, Local-As-View (LAV) mappings define elements of the local schemas as views over the global one. Query answering in this context requires rewriting the query with the views describing the local sources <ref type="bibr" target="#b30">[31]</ref>. Global-Local-As-View (GLAV) data integration generalizes both GAV and LAV. A GLAV mapping pairs a query q 1 over one or several local schemas to a query q 2 over the global schema, having the same answer variables. The semantics is that for each answer of q 1 , the integration system exposes the data comprised in a corresponding answer of q 2 . GLAV maximizes flexibility, or, equivalently, integration expressive power: unlike LAV, a GLAV mapping may expose only part of a given source's data, and may combine data from several sources; unlike GAV, a GLAV mapping may include joins or complex expressions over the global schema.</p><p>In this work, we study GLAV mediation supporting SPARQL queries over the data and the ontology. We pick GLAV for its highest expressive power, RDF for its wide adoption, and aim at querying the data and the ontology in order to fully benefit from the flexibility and expressivity of RDF. As Table <ref type="table">1</ref> shows, our system is the first capable of integrating multiple data sources through GLAV mappings, for SPARQL querying over the data and the ontology; further, it supports heterogeneous data sources (of different data models). A benefit of our using GLAV is the ability to support a form of incomplete information, naturally present in RDF through the so-called blank nodes, in the virtual RDF graph exposed by the mediator (see Section 3.1). Our closest competitors only support GAV mappings, even though some support more expressive ontologies and/or queries <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b43">44]</ref>. Formal OBDA frameworks based on GLAV mappings have been defined, e.g., <ref type="bibr" target="#b17">[18]</ref>, without concretely deployed systems. A technique for simulating GLAV mappings through GAV ones under certain conditions is suggested in <ref type="bibr" target="#b20">[21]</ref>, however this solution has many drawbacks; we defer a detailed discussion to Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions and novelty</head><p>The contributions we make in this work are as follows.</p><p>(1). RIS Formalism We formally define RDF Integration Systems (RIS, in short), OBDA mediators capable of exposing data from heterogeneous sources of virtually any data model through GLAV mappings, under the form of an RDF graph endowed with an RDFS ontology. We formalize the problem of BGP (basic graph pattern) RDF query answering over the RDF data and ontology exposed in such systems. <ref type="bibr" target="#b1">(2)</ref>. Novel RIS query answering techniques We describe several RIS query answering methods based on transforming mappings into LAV view definitions, and on reducing query answering to rewriting it using views. Our first method combines known techniques; the other two methods are novel, and rely on a form of mapping saturation. We show that a smart decomposition of reasoning between offline precomputation and query time makes one of these methods much faster than the others. The paper is organized as follows. Section 2 recalls a set of preliminary notions we build upon. Then, Section 3 defines our RIS and formalizes RIS query answering. Section 4 describes RIS query answering methods. Section 5 presents our experiments, then we discuss related work and conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>We present the basics of the RDF graph data model (Section 2.1), of RDF entailment used to make explicit the implicit information RDF graphs encode (Section 2.2), and how RDF graphs can be queried using the widely-considered SPARQL Basic Graph Pattern queries (Section 2.3). Then, we recall two techniques, namely query reformulation (Section 2.4) and view-based query rewriting (Section 2.5), which will serve as building blocks for our query answering techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">RDF Graphs</head><p>We consider three pairwise disjoint sets of values: I of IRIs (resource identifiers), L of literals (constants) and B of blank nodes modeling unknown IRIs or literals, a.k.a. labelled nulls <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b28">29]</ref>. A (well-formed) triple belongs to (I ∪B)×I ×(L ∪I ∪B), and an RDF graph G is a set of (well-formed) triples. A triple (s, p, o) states that its subject s has the property p with the object value o <ref type="bibr" target="#b46">[47]</ref>. We denote by Val(G) the set of all values (IRIs, blank nodes and literals) occurring in an RDF graph G, and by Bl(G) its to denote blank nodes, and quoted strings to denote literals. Within an RDF graph, we distinguish data triples from schema ones. The former describe data (either attach a type, or a class, to a resource, or state the value of a certain data property of a resource). The latter state ontological constraints using RDF Schema (RDFS), which relate classes and properties: subclass (specialization relation between types), subproperty (specialization of a binary relation), typing of the domain (first attribute) of a property, respectively, range (typing of the second attribute) of a property. Table <ref type="table" target="#tab_0">2</ref> introduces short notations we adopt for these schema properties. From now on, we denote by I rdf the reserved IRIs from the RDF standard, e.g., the properties τ , ≺ sc , ≺ sp , ← d , → r shown in Table <ref type="table" target="#tab_0">2</ref>. The rest of the IRIs are application-dependent classes and properties, which are said user-defined and denoted by I user . Hence, I user = I \ I rdf . We will consider RDF graphs with RDFS ontologies made of schema triples of the four above flavours. More precisely: Definition 2.1 (RDFS ontology). An ontology triple is a schema triple whose subject and object are user-defined IRIs from I user . An RDFS ontology (or ontology in short) is a set of ontology triples. Ontology O is the ontology of an RDF graph G if O is the set of schema triples of G.</p><p>Above, ontology triples are not allowed over blank nodes. This is only to simplify the presentation; we could have allowed them, and handled them as in <ref type="bibr" target="#b28">[29]</ref>. More importantly, we forbid ontology triples from altering the common semantics of RDF itself. For instance, we do not allow (← d , ≺ sp , → r ), which would impose that the range of every property shares all the types of the property's domain! This second restriction can be seen as common-sense; it underlies most ontological formalisms, in particular description logics <ref type="bibr" target="#b7">[8]</ref> thus the W3C's Web Ontology Language (OWL), Datalog± <ref type="bibr" target="#b14">[15]</ref> and existential rules <ref type="bibr" target="#b38">[39]</ref>, etc.</p><p>Example 2.2 (Running example, based on <ref type="bibr" target="#b11">[12]</ref>). Consider the following RDF graph: G ex = {(:worksFor, ← d , :Person), (:worksFor, → r , :Org), (:PubAdmin, ≺ sc , :Org), (:Comp, ≺ sc , :Org), (:NatComp, ≺ sc , :Comp), (:hiredBy, ≺ sp , :worksFor) (:ceoOf, ≺ sp , :worksFor), (:ceoOf, → r , :Comp), (:p 1 , :ceoOf, _:b c ), (_:b c , τ , :NatComp), (:p 2 , :hiredBy, :a), (:a, τ , :PubAdmin)} The ontology of G ex , i.e., the first eight schema triples, states that people work for organizations, some of which are public administrations or companies. Further, national companies are a kind of companies. Being hired by or being CEO of an organization are two ways of working for it; in the latter case, this organization is a company. The facts of G ex , i.e., the four remaining data triples, state that :p 1 is CEO of some unknown company represented by the blank node _:b c , which is a national company, and :p 2 is hired by the public administration :a. </p><formula xml:id="formula_0">Rule [48] Entailment rule R                                    rdfs5 (p 1 , ≺ sp , p 2 ), (p 2 , ≺ sp , p 3 ) → (p 1 , ≺ sp , p 3 )                    R c rdfs11 (s, ≺ sc , o), (o, ≺ sc , o 1 ) → (s, ≺ sc , o 1 ) ext1 (p, ← d , o), (o, ≺ sc , o 1 ) → (p, ← d , o 1 ) ext2 (p, → r , o), (o, ≺ sc , o 1 ) → (p, → r , o 1 ) ext3 (p, ≺ sp , p 1 ), (p 1 , ← d , o) → (p, ← d , o) ext4 (p, ≺ sp , p 1 ), (p 1 , → r , o) → (p, → r , o) rdfs2 (p, ← d , o), (s 1 , p, o 1 ) → (s 1 , τ , o)            R a rdfs3 (p, → r , o), (s 1 , p, o 1 ) → (o 1 , τ , o) rdfs7 (p 1 , ≺ sp , p 2 ), (s, p 1 , o) → (s, p 2 , o) rdfs9 (s, ≺ sc , o), (s 1 , τ , s) → (s 1 , τ , o)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">RDF Entailment Rules</head><p>An entailment rule r has the form body(r ) → head(r ), where body(r ) and head(r ) are RDF graphs, respectively called body and head of the rule r . In this work, we consider the RDFS entailment rules R shown in </p><formula xml:id="formula_1">(I ∪ B ∪ V ) × (I ∪ V ) × (I ∪ B ∪ L ∪ V ).</formula><p>For a BGP P, we denote by Var(P) the set of variables occurring in P, by Bl(P) its set of blank nodes, and by Val(P) its set of values (IRIs, blank nodes, literals and variables).</p><p>Definition 2.5 (BGP Queries). A BGP query q is of the form q( x) ← P, where P is a BGP (also denoted by body(q)), and x ⊆ Var(P) are the answer variables of q.</p><p>To ease the presentation, and without loss of generality, we consider BGPQs without blank nodes, as it is well-known that these can be replaced by non-answer variables <ref type="bibr" target="#b45">[46]</ref>. For query answering based on query reformulation (see Section 2.4), it is convenient to slightly generalize BGPQs into partially instantiated BGPQs <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b28">29]</ref>. Starting from a BGPQ q, partial instantiation may replace some variables with values from I ∪ L ∪ B, as specified by a substitution σ . Due to σ , and in contrast with standard BGPQs, some answer variables of the resulting query q σ can be bound:</p><p>Example 2.6 (Partially instantiated BGPQ). Consider the BGPQ asking for who is working for which kind of company q(x, y) ← (x, :worksFor, z), (z, τ , y), (y, ≺ sc , :Comp) and the substitution σ = {x → :p 1 }. The corresponding partially instantiated BGPQ is: q(:p 1 , y) ← (:p 1 , :worksFor, z), (z, τ , y), (y, ≺ sc , :Comp). In it, the first answer variable has been bound to :p 1 .</p><p>For simplicity, below we use the term "query" to designate either a standard BGPQ or a partially instantiated BPGQ.</p><p>The semantics of a BGPQ on an RDF graph is defined through standard homomorphisms from the query body to the queried graph. We recall that a homomorphism from a BGP P to an RDF graph G is a function φ from Val(P) to Val(G) such that for any triple (s, p, o) ∈ P, the triple (φ(s), φ(p), φ(o)) is in G, with φ the identity on IRIs and literals. Next, we distinguish query evaluation, whose result is just based on the explicit triples of the graph, i.e., on BGP-to-RDF graph homomorphisms, from query answering that also accounts for the implicit graph triples, resulting from entailment. Formally: Definition 2.7 (Evaluation and answering). The answer set to a BGPQ q on an RDF graph G w.r.t. a set R of RDF entailment rules is: q(G, R) = {φ( x) | φ homomorphism from body(q) to G R }. If x = ∅, q is a Boolean query, in which case q is false when q(G, R) = ∅ and true when q(G, R) = {⟨⟩}, i.e., the answer to q is the empty tuple.</p><p>The evaluation of q on G, denoted q(G, ∅) or q(G) in short, is obtained from homomorphisms from body(q) to G alone (not G R ). It can be seen as a particular case of query answering when R = ∅.</p><p>Example 2.8 (Evaluation and answering). Consider again the BGPQ q from the preceding example. Its evaluation on G ex is empty because G ex has no explicit :worksFor assertion, while its answer set on G ex w.r.t. R is {⟨:p 1 , :NatComp⟩} because :p 1 being CEO of _:b c , :p 1 implicitly works for it, and _:b c is explicitly a company of the particular type :NatComp.</p><p>The above notions and notations naturally extend to unions of (partially instantiated) BGPQs, or UBGPQs in short. We end this section by pointing out that many RDF data management systems use saturation-based query answering, which directly follows the definition of query answering: an RDF graph G is first saturated with the set R of entailment rules, so that the answer set to an incoming query q is obtained through query evaluation as q(G R ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Query Reformulation</head><p>Reformulation-based query answering is an alternative technique to the widely adopted saturation-based query answering. It consists in reformulating a query using R, so that evaluating the reformulated query on G yields the answer set to the original query on G w.r.t. R. Intuitively, reformulation injects the ontological knowledge into the query, just as saturation injects it into the RDF graph. We rely here on the very recent algorithm from <ref type="bibr" target="#b11">[12]</ref>, which takes into account all the entailment rules from Table <ref type="table" target="#tab_1">3</ref>. The process is decomposed into two steps according to the partition of R into R a and R c .</p><p>(i) The first step reformulates a BGPQ q w.r. </p><formula xml:id="formula_2">O, Q c (G, R a ) = Q c ,a (G). Furthermore, a key property is that q(G, R) = Q c (G, R a ), i.e.</formula><p>, only R a needs to be considered to answer Q c with respect to the entire set of rules R. This is the fundamental reason why the sucessive application of these two reformulation steps leads to a sound and complete reformulationbased query answering technique:</p><formula xml:id="formula_3">q(G, R) = Q c ,a (G).</formula><p>Example 2.9 (Two-step reformulation). Consider the query q(x, y) ← (x, :worksFor, z), (z, τ , y), (y, ≺ sc , :Comp) from the preceding example and the ontology O in Example 2.2. The first reformulation step instantiates the triple (y, ≺ sc , :Comp) on O, leading to: Q c = q(x, :NatComp) ← (x, :worksFor, z), (z, τ , :NatComp).</p><p>Then, Q c is reformulated into Q c ,a = q(x, :NatComp) ← (x, :worksFor, z), (z, τ , :NatComp) ∪ q(x, :NatComp) ← (x, :hiredby, z), (z, τ , :NatComp) ∪ q(x, :NatComp) ← (x, :ceoOf, z), (z, τ , :NatComp) by specializing :worksFor according to its subproperties in O.</p><formula xml:id="formula_4">It can be checked that Q c ,a (G ex ) = q(G ex , R) = q(G R ex ) = {⟨:p 1 , :NatComp⟩}, obtained here from the third BGPQ in Q c,a .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Query Rewriting-based Data Integration</head><p>We recall now the basics of relational view-based query rewriting (Section 2.5.1), which has been extensively studied <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b30">31]</ref>. Then we present a generalization of the notion of views as mappings <ref type="bibr" target="#b34">[35]</ref> (Section 2.5.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">View-based (LAV) Data</head><p>Integration. An integration system I is made of a global schema S (a set of relations) and a set V of views. An instance of I assigns a set of tuples to each relation of S and to each view of V. The data stored in a view is called its extension. Further, to each view V is associated a query V ( x) :-ψ ( x) over the global schema S, specifying how its data fits into S. Accordingly, this framework is called local-as-view (LAV) data integration. For instance, let S consist of three relations Emp(eID, name, dID), Dept(dID, cID, country), Salary(eID,amount), where eID, dID and cID are respectively identifiers for employees, departments and companies. Consider the views V 1 (eID, name, country) :-Emp(eID, name, dID), Dept(dID, "IBM", country) providing the names of IBM employees and where they work, and V 2 (eID, amount) :-Emp(eID, name, "R&amp;D"), Salary(eID,amount), which indicates the salaries of employees in R&amp;D departments. Typically, no single view is expected to bring all information of a given kind; for instance, V 1 brings some IBM employees, but other views may bring others, e.g., V 2 , possibly overlapping with V 1 ; this is called the "Open World Assumption" (OWA). In an OWA setting, we are interested in certain answers <ref type="bibr" target="#b30">[31]</ref>, i.e., those that are sure to be part of the query result, knowing the data present in the views. Such answers can be computed by rewriting a query over S, into one over the views V; evaluating the rewriting over the view extensions produces the answers. Ideally, a rewriting should be equivalent to the query over S, i.e., compute exactly the same answers. However, depending on the views and queries, such a rewriting may not exist. For instance, the query q(n, a) :-Emp(e, n, d), Dept(d, c, "France"), Salary(e, a) does not have an equivalent rewriting using V 1 and V 2 , because V 1 only provides IBM employees working in France, while V 2 only has salaries of employees of R&amp;D departments. A maximally contained rewriting brings all the query answers that can be obtained through the given set of views; the rewriting may be not be equivalent to q (but just contained in q). In our example, q r (n, a) :-V 1 (e, n, "France"), V 2 (e, a) is a maximally contained rewriting of q; it returns employees of French IBM R&amp;D departments with their salary, clearly a subset of q answers. A remarkable result holds for (unions of) conjunctive queries ((U)CQs), conjunctive views (views V such that the associated query V ( x) :-ψ ( x) is a CQ) and rewritings that are UCQs: any maximally contained rewriting computes exactly the certain answers <ref type="bibr" target="#b1">[2]</ref>; we will build upon this result for answering queries in our RDF integration systems.</p><p>2.5.2 GLAV Data Integration. The above setting has been generalized to views that are not necessarily stored as such, but just queries over some underlying data source. For instance, assuming a data source D holds the relations Person(eID, name) and Contract(eID, dID, country) (see Figure <ref type="figure">1</ref>) with people and their work contracts at IBM, the view V 1 from the above example may be defined on D by the query V D 1 over the D schema shown in the figure (note that V D 1 hides the department from system I);</p><formula xml:id="formula_5">V D 1 provides the extension of V 1 .</formula><p>Similarly, view V 2 may be defined as a query over some data source (or sources).</p><p>Global schema S Emp(eID, name, dID), Dept(dID, cID, country), Salary(eID,amount) V 1 (eID, name, country) :-Emp(eID, name, dID), Dept(dID, "IBM", country) V D 1 (eID, name, country) :-Person(eID, name), Contract(eID, dID, country) Person(eID, name), Contract(eID, dID, country) Data source D Figure <ref type="figure">1</ref>: Example: view V 1 as a GLAV mapping. Query rewriting is unchanged, whether the views are stored or defined by source queries. In the latter case, to obtain answers, a view-based rewriting needs to be unfolded, replacing every occurence of a view symbol V with the body of the source query defining that view. Executing the resulting query (potentially over different data sources) computes the answers. This integration setting, which considers views as intermediaries between sources and the integration schema, has been called "global-local-as-view" (GLAV) <ref type="bibr" target="#b25">[26]</ref>. An association of a query q 1 over the data sources and another query q 2 over the global schema, both with the same answer variables, e.g., q 1 = V D 1 and q 2 = V 1 above, is commonly called a GLAV mapping (denoted q 1 ( x) q 2 ( x)).</p><p>Historically, two restrictions of GLAV mappings have been investigated. First, global-as-view (or GAV) mappings define global schema relations as views over the local schemas. Specifically, a GAV mapping q 1 ( x) q 2 ( x), q 2 defines a single element of the global schema (hence body(q 2 ) is restricted to a single atom if q 2 is a CQ, or a single triple pattern if q 2 is a BGPQ) and its variables are exactly x. Second, local-as-view (LAV) mappings express elements of the local schema as views over the global schema, similarly to the views described in Section 2.5.1. Importantly, unlike GAV mappings, GLAV ones do not require all variables of q 2 to be answer variables (e.g., dID in V 1 in Figure <ref type="figure">1</ref>); this makes integration more powerful. For example, suppose that ⟨1,"John Doe","France"⟩ is an answer to V D 1 above. Then, V 1 exposes this tuple in the global schema as: Emp(1,"John Doe",x), Dept(x,"IBM", "France"), stating that John Doe works for a department x located in France. Here, x is an existential variable (called "labeled null" in <ref type="bibr" target="#b2">[3]</ref>); the GLAV mapping states the existence of such a department in the global schema, even if its identifier is unknown (because it is not provided by V 1 ). Therefore, John Doe is a certain answer to a query asking for all employees in IBM departments, based on the above GLAV mapping. This answer cannot be found using GAV mappings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PROBLEM STATEMENT</head><p>In this section, we first formalize the notion of RDF integration system (Section 3.1). Then, we state the associated query answering problem (Section 3.2), for which Section 4 provides solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">RDF integration system (RIS)</head><p>In an RDF integration system (RIS in short), data from heterogeneous sources, each of which may have its own data model and query language, is integrated into an RDF graph, consisting of an (RDFS) ontology and of data triples derived from the sources by means of GLAV-style mappings. Mappings allow (i) specifying the data made available from the sources, and (ii) organizing it according to the RIS ontology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.1 (RIS mappings and extensions).</head><p>A RIS mapping m is of the form m = q 1 ( x) q 2 ( x) where q 1 and q 2 are two queries with the same answer variables, and q 2 is a BGPQ whose body contains only triples of the forms:</p><p>• (s, p, o) where p ∈ I user ,</p><p>• (s, τ , C) where C ∈ I user . The body of m is q 1 and its head is q 2 . The extension of m is the set of tuples ext(m) = {V m (δ (v 1 ), . . . , δ (v n )) | ⟨v 1 , . . . , v n ⟩ ∈ q 1 (D)}, where q 1 (D) is the answer set of q 1 on the data source D that m integrates and δ is a function that maps source values to RDF values, i.e., IRIs, blank nodes and literals.</p><p>Intuitively, m specifies that the result of query q 1 on D transformed in RDF, i.e., the extension of m, is exposed to the RIS as the result of the (BGP) query q 2 . Example 3.2 (Mappings). Consider the two mappings: m 1 with head q 2 (x) ← (x, :ceoOf, y), (y, τ , :NatComp) and m 2 with head q 2 (x, y) ← (x, :hiredBy, y), (y, τ , :PubAdmin).</p><p>Suppose that the body of m 1 returns ⟨p D 1 ⟩ as its results, and that the δ function maps the value p D 1 1 from the data source D 1 to the IRI :p 1 . Then, the extension of m 1 is: ext(m 1 ) = {V m 1 (:p 1 )}. Further, suppose that the body of m 2 returns ⟨p D 2 2 , a D 2 ⟩, and that δ maps the values p D 2 2 , a D 2 from the data source D 2 to the IRIs :p 2 , :a. Then, the extension of m 2 is: ext(m 2 ) = {V m 2 (:p 2 , :a)}.</p><p>Given a set of RIS mappings M, the extent of M is the union of the mappings' extensions, i.e., E = m ∈M ext(m), and we denote by Val(E) the set of values occurring in E. We can now define the RIS data triples induced by some mappings and an extent thereof. These are all the data which is exposed (can be queried) through a RIS. Definition 3.3 (RIS data triples). Given a set M of RIS mappings and an extent E of M, the RIS data triples induced by M and E form an RDF graph defined as follows:</p><formula xml:id="formula_6">G M E = m=q 1 ( x ) q 2 ( x )∈M {bgp2rdf(body(q 2 ) [ x ←t ] )) | V m ( t) ∈ E} where • body(q 2 ) [ x ←t ] is the BGP body(q 2 )</formula><p>in which the answer variables x are bound to the values in the tuple V m ( t), part of E; • bgp2rdf(•) is a function that transforms a BGP into an RDF graph, by replacing each variable with a fresh blank node.</p><p>Observe that, because we use GLAV mappings, RIS data triples may include fresh blank nodes, as exemplified below; these correspond to the existential variables allowed in GLAV mappings, as discussed at the end of Section 2.5.2. Finally, we define a RIS as a tuple S = ⟨O, R, M, E⟩ stating that S allows to access (query), with the reasoning power given by the set R of RDFS entailment rules, the RDF graph comprising the ontology O and the data triples induced by the set of mappings M and their extent E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Query answering problem</head><p>The problem we consider is answering BGPQs in a RIS. We define certain answers in a RIS setting as follows: Definition 3.5 (Certain answer set). The certain answer set of a BGPQ q on a RIS S = ⟨O, R, M, E⟩ is: cert(q, S) = {φ( x) | φ homomorphism from body(q) to (O∪G M E ) R } where φ( x) comprises only values from Val(E).</p><p>The certain answer set cert(q, S) is thus the subset of q(O ∪ G M E , R) restricted to tuples fully built from source values, i.e., we exclude tuples with blank nodes introduced by the mappings (see Def. 3.3). Note, however, that blank nodes can be exploited to answer queries, as shown below.  <ref type="table" target="#tab_1">3</ref>, and the set of mappings M together with the extent E from Example 3.4. Let q(x, y) ← (x, :worksFor, y), (y, τ , :Comp) be the query asking "who works for which company", while the query q ′ (x) ← (x, :worksFor, y), (y, τ , :Comp) asks "who works for some company". The only difference between them is that y is an answer variable in q and not in q ′ . The certain answer set of q is ∅, M mapping saturation</p><formula xml:id="formula_7">M a,O ont. mapping creation M a,O ∪ M O Rc (A) (B) reformulation Q c ,a Q c q (1') (1) O R a R c rewriting<label>(2)</label></formula><p>(2') The query q has no answer because it requires a value not available from the source: the company for which :p 1 works; the RIS only knows the existence of such value through the blank node _:b c begotten by bgp2rdf in its data triples. In contrast, q ′ allows finding out that :p 1 works for (as CEO of) some (national) company, even though the mapping m 1 (the only one involving companies) does not expose the company IRI through the RIS.</p><formula xml:id="formula_8">(2") q r q REW (3) (<label>3</label></formula><p>The problem we study in the next section is: Problem 1. Given a RIS S, compute the certain answer set of a BGPQ q on S, i.e., cert(q, S).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">QUERY ANSWERING IN A RIS</head><p>Since we adopt a mediator-style approach, the RIS data triples G M E are not materialised, hence the saturation of O ∪G M E cannot be computed to answer queries as defined above. Instead, queries are rewritten in terms of the remote heterogeneous sources, based on the RIS ontology O, reasoning power R and mappings M. We present three query answering strategies, which differ in how the ontological reasoning is incorporated: we may have all, some or no reasoning performed at query time, as outlined in Figure <ref type="figure" target="#fig_2">2</ref>. All reasoning at query time The first strategy will be detailed in Section 4.1. First, it reduces the RIS query answering problem to standard query evaluation in an RDF data management system, by reformulating (step (1) in Figure <ref type="figure" target="#fig_2">2</ref>) the query q based on the RIS ontology O and entailment rules R = R c ∪ R a . The obtained reformulated query Q c ,a thus yields the expected certain answers when evaluated on the RIS data triples (recall Section 2.4), provided that answers with blank nodes introduced by the bgp2rdf function are discarded (recall Section 3.2). Since these data triples are not materialized, the RDF query evaluation problem is in turn reduced to relational view-based query answering, by rewriting Q c ,a using the RIS GLAV mappings M seen as LAV views (step (2)). This produces a relational rewriting q r over the mappings extension (step (3)), whose evaluation with a mediator query engine provides the desired certain answers (steps (4) and ( <ref type="formula">5</ref>)). Some reasoning at query time The second strategy (detailed in Section 4.2) is a main contribution of this paper. First, it reduces the RIS query answering problem to saturation-based query answering by reformulating (step (1')) the query q based on O and R c only (not R = R c ∪ R a as above). The obtained reformulation Q c thus yields the expected certain answer set when evaluated on the RIS data triples saturated with R a (recall Section 2.4), again provided that the answers with blank nodes introduced by the bgp2rdf function are discarded (as above). Since these triples are not materialized in a RIS, hence cannot be saturated with R a , the saturation-based query answering problem is in turn reduced to relational view-based query answering, by rewriting Q c using the RIS GLAV mappings saturated O and R a , seen as LAV views. These saturated mappings, denoted M a,O , are obtained (step (A)) from the original ones by adding to their head queries (q 2 ) all the implicit data triples they model w.r.t. O and R a . Then, the partially reformulated query Q c is rewritten using M a,O (step (2')) and the resulting query (step (3)) is evaluated as in the first strategy (steps (4) and ( <ref type="formula">5</ref>)). Importantly, mappings are saturated offline, and need to be updated only when some mapping changes. This limits both the reasoning effort at query time and the complexity of the reformulated query to rewrite, hence the rewriting time needed to obtain a rewriting q r over the data sources, as our experiments show (Section 5). No reasoning at query time Finally, the third strategy (detailed in Section 4.3) reduces the RIS query answering problem directly to view-based query answering. Here, the mappings are saturated offline as above (step (A)), in order to model all explicit and implicit RIS data triples. Also, these mappings are complemented with a set of mappings, noted M O Rc (step (B)), comprising all the explicit and implicit RIS schema triples w.r.t. O and R; since only R c rules entail new schema triples (Table <ref type="table" target="#tab_1">3</ref>), O R is actually equal to O R c . This second set of mappings is also computed offline, and only needs to be updated when the ontology changes. A query q just needs to be rewritten based on the above mappings M a,O ∪ M O Rc seen as LAV views (step (2")), in order to obtain, as above, a rewriting q REW over the data sources (step(3'), followed by the evaluation steps (4') and ( <ref type="formula">5</ref>)). Before going into the technical details of the above strategies, we introduce a set of simple functions. The bдp2ca function transforms a BGP into a conjunction of atoms with ternary predicate T (standing for "triple") as follows: bдp2ca({(s 1 , p 1 , o 1 ), . . .,</p><formula xml:id="formula_9">(s n , p n , o n )}) = T (s 1 , p 1 , o 1 ) ∧ • • • ∧ T (s n , p n , o n ).</formula><p>The bдpq2cq function transforms a BGPQ q( x) ← body(q) into a CQ q( x) ← bдp2ca(body(q)). Finally, the function ubдpq2ucq function transforms a UBGPQ n i=1 q i ( xi ) into a UCQ by applying the above bдpq2cq function to each of its q i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Rewriting Fully-Reformulated Queries using Mappings as Views: REW-CA</head><p>Based on <ref type="bibr" target="#b11">[12]</ref>, the first step of this strategy, (1) in Figure <ref type="figure" target="#fig_2">2</ref>, reformulates a query q w.r.t. O and R = R c ∪ R a into a query Q c,a . This allows obtaining the certain answers directly from the RIS data triples, and not from their saturation after they have been augmented with O (recall Definition 3.5). Indeed, the correctness of the reformulation ensures that the certain answers of q on the RIS S correspond precisely to those of Q c ,a asked on S when disregarding O and R, as formally expressed in the next lemma. Of course, this still does not provide a concrete solution to obtain the desired certain answers using standard query evaluation, since the RIS data triples G M E are not materialized. Lemma 4.1. Let S = ⟨O, R, M, E⟩ be a RIS, q be a BGPQ and Q c ,a its UBGPQ reformulation w.r.t. O, R = R c ∪ R a using <ref type="bibr" target="#b11">[12]</ref>. Then:</p><formula xml:id="formula_10">cert(q, S) = cert(Q c ,a , ⟨∅, ∅, M, E⟩)</formula><p>The proof of this and our following claims can be found in <ref type="bibr" target="#b12">[13]</ref>. Recall that the RIS data triples are defined from the mappings M by, for every mapping m = q 1 ( x) q 2 ( x) ∈ M, (i) evaluating the mapping body q 1 ( x) on the data source to produce its extension ext(m) ∈ E, and then (ii) instantiating the mapping head q 2 ( x) with its extension. At the same time, this is also how the instance of a data integration system based on LAV views and their extensions is defined in a relational setting (Section 2.5.1)! Based on this analogy, we recast the RIS query answering problem of the above Lemma, into a relational view-based query answering one. To this aim, we treat our mappings as LAV views:</p><p>Definition 4.2 (Mappings as relational LAV views). Let m = q 1 ( x) q 2 ( x) be a mapping. Its corresponding relational LAV view is: V m ( x) ← bдp2ca(body(q 2 )).</p><p>Example 4.3. The relational LAV views corresponding to the mappings m 1 , m 2 from Example 3.2 are:</p><formula xml:id="formula_11">• V m 1 (x) ← T (x, :ceoOf, y),T (y, τ , :NatComp) • V m 2 (x, y) ← T (x, :hiredBy, y),T (y, τ , :PubAdmin)</formula><p>We denote the set of views derived from all the mappings M by Views(M). Crucially, the extent E of the mapping set M is also an extent for the corresponding set of views Views(M). Based on the above Lemma 4.1, treating mappings and their extent as relational LAV views and their extent, and seeing (U)BGPQs as (U)CQs with the help of the functions introduced in the beginning of Section 4, we reduce the RIS query answering problem to view-based query answering: Theorem 4.4 (REW-CA correctness). Let S = ⟨O, R, M, E⟩ be a RIS and q be a BGPQ. Let Q c ,a be the reformulation of q w.r.t. O and R using <ref type="bibr" target="#b11">[12]</ref>. Then:</p><formula xml:id="formula_12">cert(q, S) = cert(ubдpq2ucq(Q c ,a ), Views(M), E)</formula><p>where cert(ubдpq2ucq(Q c,a ), Views(M), E) denotes the certain answer set of ubдpq2ucq(Q c ,a ) over Views(M) and E.</p><p>Importantly, this provides an effective solution to RIS query answering problem by using state-of-the-art view-based query rewriting techniques <ref type="bibr" target="#b30">[31]</ref>, in particular for step (2) in Figure <ref type="figure" target="#fig_2">2</ref>.</p><p>Example 4.5 (REW-CA query answering). Consider again the RIS in Example 3.6 and the query q(x, y) ← (x, y, z), (z, τ , t), (y, ≺ sp , :worksFor), (t, ≺ sc , :Comp), (x, :worksFor, a), (a, τ , :PubAdmin)</p><p>asking "who works for some public administration, and what working relationship he/she has with some company". Its UBGPQ reformulation, seen as a UCQ, is shown in Figure <ref type="figure" target="#fig_3">3</ref>. Its maximallycontained rewriting based on the views obtained from the RIS mappings is: q r (x, :ceoOf) ← V m 1 (x), V m 2 (x, y), obtained from the second CQ in the above union. This becomes clear when the views are replaced by their bodies: q(x, :ceoOf) ← T (x, :ceoOf, y 1 ), T (y 1 , τ , :NatComp),T (x, :hiredBy, y 2 ),T (y 2 , τ , :PubAdmin). Note Q c ,a = q(x, :ceoOf) ← T (x, :ceoOf, z),T (z, τ , :NatComp), T (x, :worksFor, a),T (a, τ , :PubAdmin) ∪ q(x, :ceoOf) ← T (x, :ceoOf, z),T (z, τ , :NatComp), T (x, :hiredBy, a),T (a, τ , :PubAdmin) ∪ q(x, :ceoOf) ← T (x, :ceoOf, z),T (z, τ , :NatComp), T (x, :ceoOf, a),T (a, τ , :PubAdmin) ∪ q(x, :hiredBy) ←T (x, :hiredBy, z),T (z, τ , :NatComp), T (x, :worksFor, a),T (a, τ , :PubAdmin) ∪ q(x, :hiredBy) ←T (x, :hiredBy, z),T (z, τ , :NatComp), T (x, :hiredBy, a),T (a, τ , :PubAdmin) ∪ q(x, :hiredBy) ←T (x, :hiredBy, z),T (z, τ , :NatComp), T (x, :ceoOf, a),T (a, τ , :PubAdmin) that the other CQs cannot be rewritten given the available views.</p><p>With the current RIS, this rewriting yields an empty certain answer set to q, i.e., cert(q, S) = ∅, because the extent of the mappings, hence of the views, is: E = {V m 1 (:p 1 ), V m 2 (:p 2 , :a)}. However, if we add V m 2 (:p 1 , :a) to E, then cert(q, S) = {⟨:p 1 , :ceoOf⟩}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Rewriting Partially-Reformulated</head><p>Queries using Saturated Mappings as Views: REW-C</p><p>In constrast with the REW-CA strategy that performs all the reasoning w.r.t. O and R = R c ∪ R a at query time, our second strategy called REW-C splits the reasoning work between offline preprocessing and query time.</p><p>The first step of this strategy, labeled (1') in Figure <ref type="figure" target="#fig_2">2</ref>, reformulates a query q using <ref type="bibr" target="#b11">[12]</ref>, but solely w.r.t. O, R c , producing a UBGPQ denoted Q c . From the correctness of this reformulation step, and the fact that only R a needs to be considered to answer Q c with respect to the entire set of rules R (recall Section 2.4), the certain answer set of q asked on the RIS S is exactly the certain answer set of Q c asked on S when disregarding R c . Formally: Lemma 4.6. Let S = ⟨O, R, M, E⟩ be a RIS, q be a BGPQ and Q c its reformulation w.r.t. O, R c <ref type="bibr" target="#b11">[12]</ref>. Then:</p><formula xml:id="formula_13">cert(q, S) = cert(Q c , ⟨O, R a , M, E⟩)</formula><p>In other words, the desired answer set could be obtained by evaluating Q c on the RIS data triples G M E saturated by R a . Again, since the RIS data triples are not materialized, this does not provide a concrete solution. To account for the impact of the ontology O and the entailment rules R on these "virtual" data triples, we rely on BGPQ saturation <ref type="bibr" target="#b24">[25]</ref>: given a BGPQ q, O and R, the saturation q R,O is q augmented with all the triples q implicitly asks for, given the ontology O and the rules R. BGPQ saturation is exemplified below:</p><p>Example 4.7 (BGPQ saturation). Consider the ontology O of G ex and the query q(x) ← (x, :hiredBy, y), (y, τ , :NatComp) asking who has been hired by a national company. Its saturation w.r.t. R a , O is: q R a ,O (x) ← body(q), (x, :worksFor, y), (x, τ , :Person), (y, τ , :Comp), (y, τ , :Org).</p><p>We use BGPQ saturation to saturate the RIS mapping heads w.r.t. R a , O, so that the saturated mappings together with E model the saturated RIS data triples w.r.t. R a , O. To compute q R a ,O we (1) saturate body(q) ∪ O using R a , then (2) add to the body of q all triples thus inferred. </p><formula xml:id="formula_14">M a,O = m ∈M {q 1 ( x) q R a ,O 2 ( x) | m = q 1 ( x) q 2 ( x)}</formula><p>We saturate mappings offline, and just need to update them when O or the mapping heads change.</p><p>Example 4.9 (Saturated mappings). Consider the RIS of Example 3.6, the mapping heads in M a,O are (added implicit triples are in blue):</p><formula xml:id="formula_15">m 1 : q R a ,O<label>2</label></formula><p>(x) ← (x, :ceoOf, y), (y, τ , :NatComp) (x, :worksFor, y), (y, τ , :Comp) (x, τ :Person), (y, τ , :Org) m 2 : q R a ,O 2 (x, y) ←(x, :hiredBy, y), (y, τ , :PubAdmin) (x, :worksFor, y), (y, τ , :Org) (x, τ , :Person)</p><p>From the above Lemma and the use of saturated RIS mappings instead of the original ones, we show: Lemma 4.10. Let S = ⟨O, R, M, E⟩ be a RIS, q be a BGPQ and Q c its reformulation w.r.t. O, R c <ref type="bibr" target="#b11">[12]</ref>. Then:</p><formula xml:id="formula_16">cert(q, S) = cert(Q c , ⟨∅, ∅, M a,O , E⟩)</formula><p>This result allows solving the RIS query answering problem by relational view-based query rewriting (step (2') in Figure <ref type="figure" target="#fig_2">2</ref>): Theorem 4.11 (REW-C correctness). Let S = ⟨O, R, M, E⟩ be a RIS, q be a BGPQ and Q c its reformulation w.r.t. O, R c .Then:</p><formula xml:id="formula_17">cert(q, S) = cert(ubдpq2ucq(Q c ), Views(M a,O ), E)</formula><p>Example 4.12 (REW-CA). Consider again the RIS in Example 3.6 and the query q of Example 4.5. Its reformulation Q c w.r.t. O, R c , seen as a UCQ, is: q(x, :ceoOf) ← T (x, :ceoOf, z),T (z, τ , :NatComp), T (x, :worksFor, a),T (a, τ , :PubAdmin) ∪ q(x, :hiredBy) ←T (x, :hiredBy, z),T (z, τ , :NatComp), T (x, :worksFor, a),T (a, τ , :PubAdmin) This reformulation is therefore rewritten using the RIS views as: q r (x, :ceoOf) ← V m 1 (x), V m 2 (x, y). It is obtained from the first CQ in the above; the second one has no rewriting based on the available RIS views. We remark that this rewriting is equivalent to the one obtained in Example 4.5, hence yields the same answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Rewriting Queries using Saturated</head><p>Mappings and Ontology Mappings as Views: REW This strategy does not reason at query time at all. Instead, it rewrites a query q based on the saturated RIS mappings M a,O as above, and on a specific set of ontology mappings we build to model the saturated RIS ontology as a data source: Definition 4.13 (Ontology mappings). The set of ontology mappings for a RIS ontology O is:</p><formula xml:id="formula_18">M O c = x ∈ { ≺ sc , ≺ sp ,← d , → r } {m x | m x = q 1 (s, o) q 2 (s, o)} with q 2 (s, o) ← (s, x, o). The extension of an ontology mapping m x is ext(m x ) = {V m x (s, o) | (s, x, o) ∈ O R c }. The extent of M O c is denoted E O c .</formula><p>We compute ontology mappings offline, and only need to update them when the ontology changes. The ontology mapping extensions E O c store all the explicit and implicit RIS ontology triples (recall from Section 2.2 that only R c lead to such triples). Importantly, this leads to the observation that a query triple that refers to the ontology (schema) can be evaluated on the ontology mapping extensions alone. Formally:</p><formula xml:id="formula_19">q(x, :ceoOf) ← V m 1 (x), V m ≺sp (:ceoOf, :worksFor), V m ≺sc (:NatComp, :Comp), V m 2 (x, a) ∪ q(x, :ceoOf) ← V m 1 (x), V m ≺sp (:ceoOf, :worksFor), V m ≺sc (:Comp, :Comp), V m 2 (x, a) ∪ q(x, :ceoOf) ← V m 1 (x), V m ≺sp (:ceoOf, :worksFor),</formula><p>V m ≺sc (:Org, :Comp), V m 2 (x, a) ∪ q(x, :worksFor) ←V m 1 (x), V m ≺sp (:worksFor, :worksFor),</p><p>V m ≺sc (:NatComp, :Comp), V m 2 (x, a) ∪ q(x, :worksFor) ←V m 1 (x), V m ≺sp (:worksFor, :worksFor),</p><p>V m ≺sc (:Comp, :Comp), V m 2 (x, a) ∪ q(x, :worksFor) ←V m 1 (x), V m ≺sp (:worksFor, :worksFor),</p><formula xml:id="formula_20">V m ≺sc (:Org, :Comp), V m 2 (x, a) ∪ q(x, :hiredBy) ← V m 2 (x, z), V m ≺sp (:hiredBy, :worksFor), V m ≺sc (:PubAdmin, :Comp), V m 2 (x, a) ∪ q(x, :hiredBy) ← V m 2 (x, z), V m ≺sp (:hiredBy, :worksFor), V m ≺sc (:Org, :Comp), V m 2 (x, a) ∪ q(x, :worksFor) ←V m 2 (x, z), V m ≺sp (:worksFor, :worksFor), V m ≺sc (:PubAdmin, :Comp), V m 2 (x, a) ∪ q(x, :worksFor) ←V m 2 (x, z), V m ≺sp (:worksFor, :worksFor), V m ≺sc (:Org, :Comp), V m 2 (x, a) ∪ r∈ { ≺ sc , ≺ sp ,← d , → r } q(x, r) ← V m r (x, z), V m 2 (v, z), V m ≺sp (r, :worksFor), V m ≺sc (:PubAdmin, :Comp), V m 2 (x, a) ∪ q(x, r) ←V m r (x, z), V m 2 (v ,z) , V m ≺sp (r, :worksFor), V m ≺sc (:Org, :Comp), V m 2 (x, a)</formula><p>Figure <ref type="figure">4</ref>: Sample rewriting for Example 4.17.</p><p>Lemma 4.14. Let S = ⟨O, R, M, E⟩ be a RIS and q be a BGPQ. Then:</p><formula xml:id="formula_21">cert(q, S) = cert(q, ⟨O, R a , M O c ∪ M, E O c ∪ E⟩)</formula><p>This lemma effectively "pushes" R c reasoning in the set of mappings (to which we add M O c ) and the extent (to which we add E O c ). Next, we rely (as we did for REW-CA) on mappings saturation with O, R a to also push R a reasoning in the mappings, leading to: Lemma 4.15. Let S = ⟨O, R, M, E⟩ be a RIS and q be a BGPQ. Then:</p><formula xml:id="formula_22">cert(q, S) = cert(q, ⟨∅, ∅, M O c ∪ M a,O , E O c ∪ E⟩)</formula><p>This allows to reduce RIS query answering to relational viewbased query rewriting (step (2") in Figure <ref type="figure" target="#fig_2">2</ref>): Theorem 4.16 (REW correctness). Let S = ⟨O, R, M, E⟩ be a RIS and q be a BGPQ. Then:</p><formula xml:id="formula_23">cert(q, S) = cert(bдpq2cq(q), Views(M O c ∪ M a,O ), E O c ∪ E)</formula><p>Example 4.17 (REW). Consider again the RIS in Example 3.6 and the query q of Example 4.5 seen as a CQ: q(x, y) ←T (x, y, z),T (z, τ , t),T (y, ≺ sp , :worksFor), T (t, ≺ sc , :Comp),T (x, :worksFor, a), T (a, τ , :PubAdmin) Its maximally-contained rewriting q REW based on the views obtained from the RIS saturated mappings and ontology mappings appears in Figure <ref type="figure">4</ref>. This rewriting is much larger than the ones of the two preceding techniques: this is due to the ontology mappings. If we assume that E also contains V m 2 (:p 1 , :a), as we did in Example 4.5, we obtain again cert(q, S) = {⟨:p 1 , :ceoOf⟩}, which results from the evaluation of the first CQ in the UCQ rewriting; the other CQs yield empty results because some required ≺ sc or ≺ sp contraints are not found in the views built from the RIS ontology mappings.</p><p>How do our strategies compare? Since they are all correct, they lead to the same RIS certain answer set, however they do not necessarily compute the same view-based rewritings. Indeed, REW considers the additional set M O c of ontology mappings. Hence, for queries over the ontology, i.e., featuring in a property position ≺ sc , ≺ sp , ← d , → r , or a variable, a REW rewriting is larger than a REW-CA or REW-C rewriting and, to be answered, requires the additional ontology source. In contrast, REW-CA and REW-C yield logically equivalent rewritings; we minimize them both to avoid possible redundancies, thus they become identical (up to variable renaming). Hence, REW-CA and REW-C do not differ in how these rewritings are evaluated. Instead, they differ in how the rewritings are computed, or, equivalently, on the distribution of the reasoning effort on the data and mappings, across various query answering stages. As our experiments show, given the computational complexity of view-based query rewriting <ref type="bibr" target="#b41">[42]</ref>, this difference has a significant impact on their performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTAL EVALUATION</head><p>We now describe our experiments with RIS query answering. In addition to our strategies based on query rewriting, we include in our comparison a simple alternative strategy, based on materialization and denoted MAT. Offline (before answering queries), this strategy materializes the RIS data triples and saturates them with the rule set R. The materialization is stored and saturated in an RDF data management system (RDFDB, in short). Then, MAT query answering amounts to query evaluation on the saturated materialization. Therefore, MAT query answering can be seen as a lower bound for query answering through other strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental settings</head><p>Software Our platform is developed in Java 1.8, as follows. Our RDFDB is OntoSQL<ref type="foot" target="#foot_1">2</ref> , a Java platform providing efficient RDF storage, saturation, and query evaluation on top of an RDBMS <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b28">29]</ref>, relying on Postgres v9.6. To save space, OntoSQL encodes IRIs and literals into integers, and a dictionary table which allows going from one to the other. It stores all resources of a certain type in a one-attribute table, and all (subject, object) pairs for each property (including RDFS schema properties) in a table; the tables are indexed. OntoSQL is used in the MAT strategy, and it also provides the RDF query reformulation algorithm <ref type="bibr" target="#b11">[12]</ref>. We rely on the Graal engine <ref type="bibr" target="#b8">[9]</ref> for view-based query rewriting. Graal is a Java toolkit dedicated to query answering algorithms in knowledge bases with existential rules (a.k.a. tuplegenerating dependencies). Since the relational view V m ( x) ← bдp2ca(body(q 2 )) corresponding to a GLAV mapping m (recall Def. 4.2) can be seen as a specific existential rule of the form V m ( x) → bдp2ca(body(q 2 )), the query reformulation algorithm of Graal can be used to rewrite the UCQ translation of a BGPQ with respect to a set of RIS mappings. To execute queries against heterogeneous data sources, we use Tatooine <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b9">10]</ref>, a Javabased mediator (or polystore) system, capable both of pushing queries in underlying data sources and (unlike other polystores, e.g., <ref type="bibr" target="#b23">[24]</ref>) of evaluating joins within the mediator engine. Query rewritings produced by Graal are unfolded into queries on the data sources (using the q 1 parts of the mappings, see Section 2.5.2) and passed to Tatooine. We implemented the RIS query answering methods described here in Java 1.8 on top of these tools. Hardware We used servers with 2,7 GHz Intel Core i7 processors and 160 GB of RAM, running CentOs Linux 7.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experimental scenarios</head><p>RDF Integration Systems (RIS) used Our first interest was to study scalability of RIS query answering, in particular in the relational setting studied in many prior works. To achieve this, we used the BSBM benchmark relational data generator <ref type="foot" target="#foot_2">3</ref>  Relational-sources RIS We devised two sets M 1 , M 2 of 307, respectively, 3863 mappings, which expose the relational data from DS 1 , respectively, DS 2 as RDF graphs. The relatively high number of mappings is because: (i) each product type (of which there are many, and their number scales up with the BSBM data size) appears in the head of a mapping, enabling fine-grained and high-coverage exposure of the data in the integration graph;</p><p>(ii) we also generated more complex GLAV mappings, partially exposing the results of join queries over the BSBM data; interestingly, these mappings expose incomplete knowledge, in the style of Example 3.4. The mapping sets lead to the RIS graphs of 2.0•10 6 , respectively, 108 • 10 6 triples. Their saturated versions comprise respectively 3.4 • 10 6 and 185 • 10 6 triples. Our first two RIS are thus:</p><formula xml:id="formula_24">S 1 = ⟨O 1 , R, M 1 , E 1 ⟩ and S 2 = ⟨O 2 , R, M 2 , E 2 ⟩</formula><p>, where E i for i in {1, 2} are the extents resulting from DS i and M i . Heterogeneous-sources RIS Second, going beyond relationalsources OBDA <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b43">44]</ref>, our architecture extends to heterogeneous data sources. For that, we converted a third (33%) of DS 1 , DS 2 into JSON documents, and stored them into MongoDB, leading to the JSON data sources denoted DS j,1 , DS j,2 ; the relational sources DS r ,1 , DS r 2 store the remaining (relational) data. Conceptually, for i in {1, 2}, the extension based on DS r ,i and extension based on DS j,i form a partition of E i . We devise a set of JSON-to-RDF mappings to expose DS j,1 and DS j,2 into RDF, and denote M 3 the set of mappings exposing DS r ,1 and DS j,1 , together, as an RDF graph; similarly, the mappings M 4 expose DS r ,2 and DS j,2 as RDF. Our last two RIS are thus:</p><formula xml:id="formula_25">S 3 = ⟨O 1 , R, M 3 , E 3 ⟩ and S 4 = ⟨O 2 , R, M 4 , E 4 ⟩</formula><p>, where E 3 is the extent of M 3 based on DS r ,1 and DS j,1 , while E 4 is the extent of M 4 based on DS r ,2 and DS j,2 . The RIS data and ontology triples of S 1 and S 3 are identical; thus, the difference between these two RIS is only due to the heterogeneity of their underlying data sources. The same holds for S 2 and S 4 . Queries We devised a set of 28 BGP queries having from 1 to 11 triple patterns (5.5 on average), of varied selectivity (they return between 2 and 330 • 10 3 results in S 1 and S 3 and between 2 and 4.   competitor systems lack (see <ref type="bibr">Section 6)</ref>. Table <ref type="table" target="#tab_6">4</ref> reports three query properties impacting query answering performance: the number of induced triples (N TRI ), the number of BGPQ reformulations on the ontology (|Q c ,a |, ranging from 1 to 1225; this strongly determines the performance of answering such large union queries, recall Example 4.5), and its number of answers (N ANS ) on the two RIS groups (S 1 , S 3 and S 2 , S 4 ). To further study the impact of the ontology on query evaluation complexity, we created query families denoted Q X , Q X a etc. by replacing the classes and properties appearing in Q X with their super classes or super properties in the ontology. In such a family, Q X is the most selective, and queries are sorted in the increasing order of their number of reformulations. Our ontologies, mappings, queries, and experimental details are available online<ref type="foot" target="#foot_3">4</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Query answering performance</head><p>REW inefficiency We have conducted experiments 4 using our six queries on ontological triples showing, as in Example 4.17 and Figure <ref type="figure">4</ref>, an explosion of the size of the rewriting (number of CQs), compared to the rewriting produced by the two other approaches. On queries (also) over the ontology, as explained in Section 4.3, we noted that the size of the rewriting produced by REW is larger (by a multiplicative factor of 29 to 74 in S 1 and S 3 , and of 33 to 969 in S 2 and S 4 ) than the rewritings of the two other strategies, which led to an explosion of the time spent minimizing the rewriting, and made REW overall unfeasible; the details of these tests can be found online 4 . On queries that do not carry over the ontology, REW produces the same rewritings as the other methods. Thus, we do not report further REW performance below. The size of (number of BGPQs in) the reformulation of each query w.r.t. R, |Q c ,a | appears in parentheses after the query name, in the labels along the x axis. Given that S 1 , S 3 have the same RIS data triples, the MAT strategy coincides among these two RIS. Figure <ref type="figure" target="#fig_6">6</ref> shows the corresponding times for the largest RIS S 2 and S 4 ; the same observations apply. Note the logarithmic time axes. A first observation is that our query set is quite diverse; their answering times range from a few to more than 10<ref type="foot" target="#foot_4">5</ref> ms. As expected, query answering in MAT is the fastest in most cases, since it has no reasoning work to do at query answering time. However, it required, for S 1 , S 3 , 1.2 • 10 5 ms to build the materialization and 1.49 • 10 5 ms more to saturate it, whereas for S 2 , S 4 , these times are 14h46 (5.31 • 10 7 ms), respectively, 1h28 (5.28 • 10<ref type="foot" target="#foot_5">6</ref> ms). Not only these are orders of magnitude more than all query answering times; recall also that materializing G M E requires maintaining it when the underlying data changes, and its saturation (G M E ∪ O) R needs a second level of maintenance. Thus, MAT is not practical when data sources change. We were surprised to see REW-C and REW-CA somehow faster than MAT for queries Q 09 and Q 14 . Answering these queries through MAT within OntoSQL leads to producing many results that involve mapping-generated blank nodes, tuples which should not appear in our certain answers, as per Definition 3.5. We remove such tuples in post-processing mode, which leads to a performance overhead for MAT. REW-C and REW-CA, in contrast, are answered by evaluating rewritings, and do not have to apply such a result pruning. It remains to be seen if this pruning could be pushed in an RDFDB; note that not all answers including blank nodes should be pruned, only those whose blank nodes are due to mappings. In each scenario, we observe that REW-C is faster or takes as long as REW-CA. Since the two approaches produce the same rewritings, the difference is due to steps before the step (3) in Figure <ref type="figure" target="#fig_2">2</ref>. It turns out it is due to the rewriting time, which in turn strongly depends on the size of the reformulation it receives as input. In REW-C, the reformulations w.r.t. R c are of size 1 (no union, just one BGP) for queries on data triples only, and never exceed 64 in S 1 and S 3 and 200 in S 2 and S 4 , whereas, in REW-CA the reformulation sizes are much larger. REW-C is most often faster than REW-CA, by up to two orders of magnitude e.g., for Q 02a , Q 19 and Q 20a on S 2 , the latter two on S 4 etc. One order of magnitude speed-up is noticeable even on the smaller RIS S 1 , S 3 (Figure <ref type="figure" target="#fig_5">5</ref>) for Q 02a . As a consequence, REW-C completes successfully in all scenarios we study, whereas REW-CA fails to complete for many queries with timeout set to 10min (missing yellow bars in Figure <ref type="figure" target="#fig_6">6</ref>), in close correlation with the increased number of reformulations. Scaling in the data size As stated in Section 5.2, there is a scale factor of about 50 between S 1 , S 3 on one hand, and S 2 , S 4 on the other. Figures <ref type="figure" target="#fig_7">5</ref> and<ref type="figure" target="#fig_6">6</ref> show that the query answering times generally grow by less than 50, when moving from S 1 to S 2 , and from S 3 to S 4 . This is mostly due to the good scalability of PostgreSQL (in the all-relational RIS), Tatooine (itself building on PostgreSQL and MongoDB, in the heterogeneous RIS), and OntoSQL (for MAT). As discussed above, computation steps we implemented outside these systems are strongly impacted by the mappings, ontology and query; intelligently distributing the reasoning effort, as REW-C does, avoids the heavy performance penalties that from which REW-CA and REW sometimes suffer. Impact of heterogeneity REW-CA and REW-C incur a (modest) overhead when combining data from PostgreSQL and MongoDB (heterogeneous RIS) w.r.t. the relational-sources RIS. Part of this is due to the cost of marshalling data across system boundaries; the rest is due to imperfect optimization within Tatooine. Overall, the comparison demonstrates that RIS query answering is feasible and quite efficient even on heterogeneous data sources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Query answering time comparison</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Experiment conclusion</head><p>In a setting where the data, ontology and mappings do not change, MAT is an efficient and robust query answering technique, at a rather high cost to materialize and saturate the RIS instance. In contrast, in a dynamic setting, REW-C smartly combines partial reformulation and view-based query rewriting to efficiently compute query answers. The changes it requires when the ontology and mappings change (basically re-saturating mapping heads) are light and likely to be very fast. Thus, we conclude that REW-C is the best query answering strategy for dynamic RIS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RELATED WORK AND CONCLUSION</head><p>Ontologies have been used to integrate relational or heterogeneous data sources in mediators <ref type="bibr" target="#b48">[49]</ref> with LAV views based on description logics <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b36">37]</ref> or their combination with Datalog <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b29">30]</ref>. Semantics have been used at the integration level since e.g., <ref type="bibr" target="#b19">[20]</ref> for SGML and soon after for RDF <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>; data is considered represented and stored in a flexible object-oriented model, thus no mappings are used. Our work follows the OBDA paradigm introduced in <ref type="bibr" target="#b40">[41]</ref>. This paradigm was conceived to enhance access to relational data by mappings to an ontology expressed in a dialect of the DL-Lite description logic family (typically DL-Lite R underpinning the OWL 2 QL profile of the W3C ontological language OWL 2). Mature DL-based systems include Mastro 5 <ref type="bibr" target="#b16">[17]</ref> and Ontop 6 <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b42">43]</ref>. Another notable OBDA system, namely Ultrawrap O BDA <ref type="bibr" target="#b43">[44]</ref>, is based on an extension of RDFS to inverse and transitive properties. All these systems rely on GAV mappings. Compared to these, our main novelty is to handle GLAV mappings and provide query answering algorithms for the resulting novel RIS setting. Note that formal OBDA frameworks with GLAV mappings have long been defined, e.g., in <ref type="bibr" target="#b17">[18]</ref>, but not put into practice. Regarding the other components of OBDA, we consider a simpler ontological language than existing OBDA systems, but support BGPQs on both data and ontological triples, a feature hardly found in these systems (an exception is <ref type="bibr" target="#b32">[33]</ref>). As explained in the introduction, GLAV mappings maximize the expressive power of the integration system. In particular, they allow to expose a form of incomplete information (recall Example 3.6). To some extent, GLAV mappings may be simulated by GAV mappings provided with so-called Skolem functions on answer variables, as suggested for instance in <ref type="bibr" target="#b20">[21]</ref>. To illustrate, consider the GLAV mapping m 1 = q 1 ( x) q 2 ( x) with head q 2 (x) ← (x, :ceoOf, y), (y, τ , :NatComp) from Example 3.2. The non-answer variable y could be replaced by a Skolem function f (x), which would yield two GAV mappings, namely m 1 1 = q 1 ( x) q 2 1 ( x) and m 1 2 = q 1 ( x) q 2 2 ( x), with respective head q 2 1 ( x) ← (x, :ceoOf, f (x)) and q 2 2 ( x) ← (f (x), τ , :NatComp).</p><p>Note that Skolem functions would have to produce syntactically correct RDF values in a materialization scenario. Still in a materialisation scenario, query answering would require some postprocessing to prevent the values built by the Skolem functions to be accepted as answers, while in a query rewriting sceSkolemnario functional values would also have to be dealt with in a special way, which in particular prevents to use off-the-shelf view-based query rewriting algorithms. Hence, value invention would be simulated here at the price of technically more complex mappings and processing. Second, the break-up of GLAV mappings into several GAV mappings would lead to higher conceptual complexity since intrinsically connected triples, as those associated with (x, :ceoOf, y) and (y, τ , :NatComp) in the example, could not be exposed together by a single mapping. Last but not least, query rewriting would be considerably slowed down and would produce highly redundant rewritings, as demonstrated in the seminal paper <ref type="bibr" target="#b41">[42]</ref>. Our mapping saturation (Definition 4.8) is inspired by a query saturation technique introduced in <ref type="bibr" target="#b24">[25]</ref> to compute least general generalizations of BGPQs under RDFS background knowledge.</p><p>It can be seen as a generalization to GLAV mappings of the Tmapping technique introduced in <ref type="bibr" target="#b42">[43]</ref> (and further developed in <ref type="bibr" target="#b43">[44]</ref>) to optimize query rewriting in a classical OBDA context. The T -mapping technique consists of completing the original set of GAV mappings with new ones, encapsulating information inferred from the DL ontology. For instance, given a GAV mapping m = q 1 (x) q 2 (x) ← C(x) with C a class, and a DL constraint specifying that C is a subclass of D, a new mapping m ′ = q 1 (x) q ′ 2 (x) ← D(x) is created by composing m and the DL constraint. On this example, we would saturate the head of m into q 2 (x) ← C(x) ∧ D(x), which is semantically equivalent to adding the mapping m ′ . However, when mappings are GLAV and not GAV, one cannot simply add new mappings. For instance, consider the GLAV mapping m 1 = q 1 ( x) q 2 ( x) with head q 2 (x) ← (x, :ceoOf, y), (y, τ , :NatComp); given the entailment rule rdfs9 and the ontological triple (:NatComp, ≺ sc , :Comp), the saturation adds the triple (y, τ , :Comp) to the body of q 2 ; creating instead a new mapping of the form m ′ 1 = q 1 ( x) q ′ 2 ( x) with head q ′ 2 (x) ← (y, τ , :Comp) would be unsatisfactory as y in m ′ 1 should correspond to the same object as y in m 1 . Our mapping saturation technique could be extended to more general entailment rules, in which the head of the rules may include blank nodes that are not in their body, possibly shared by several triples. This is part of our future research agenda.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3 . 4 .</head><label>34</label><figDesc>Reusing the mappings from Example 3.2, let M = {m 1 , m 2 } and its extent E = {V m 1 (:p 1 ), V m 2 (:p 2 , :a)}. The RIS data triples they lead to are:G M E = {(:p 1 , :ceoOf, _:b c ), (_:b c , τ , :NatComp),(:p 2 , :hiredBy, :a), (:a, τ , :PubAdmin)} In particular, the first and second triples contain the blank node _:b c , introduced by bgp2rdf instead of the variable y in the head (query q 2 ) of m 1 . Importantly, only non-answer variables in a mapping head lead to blank nodes introduced this way: by Def. 3.3, answer variables (here x for m 1 and x, y for m 2 ) are replaced with values from V m ( t), thus from Val(E).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 3 . 6 (</head><label>36</label><figDesc>Certain answers). Consider the RIS S made of the ontology O of G ex in Example 2.2, the set R of entailment rules shown in Table</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Outline of query answering strategies.while the certain answer set of q ′ is {⟨:p 1 ⟩}. This answer results from the RIS data triples (:p 1 , :worksFor, _:b c ), (_:b c , τ , :Comp), which are entailed from:• the G M E triples (:p 1 , :ceoOf, _:b c ), (_:b c , τ , :NatComp), with the blank node _:b c discussed in Example 3.4, and: • either the O triples (:ceoOf, ≺ sp , :worksFor), (:ceoOf, → r , :Comp) together with the R rules rdfs3, rdfs7, or the O triples (:ceoOf, ≺ sp , :worksFor), (:NatComp, ≺ sc , :Comp) together with the R rules rdfs3, rdfs9.The query q has no answer because it requires a value not available from the source: the company for which :p 1 works; the RIS only knows the existence of such value through the blank node _:b c begotten by bgp2rdf in its data triples. In contrast, q ′ allows finding out that :p 1 works for (as CEO of) some (national) company, even though the mapping m 1 (the only one involving companies) does not expose the company IRI through the RIS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Sample reformulation for Example 4.5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 4 . 8 (</head><label>48</label><figDesc>Mappings saturation). The saturation of a set M of RIS mappings w.r.t. entailment rules R a and ontology O is:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Query answering times on the smaller RIS S 1 (top, relational sources) and S 3 (bottom, heterogeneous sources).</figDesc><graphic coords="11,53.80,333.25,231.88,116.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Query answering times on the larger RIS S 2 (top, relational sources) and S 4 (bottom, heterogeneous sources).</figDesc><graphic coords="11,309.59,334.17,231.88,117.13" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5</head><label>5</label><figDesc>depicts the query answering times, on the smaller RIS, of REW-CA, REW-C and MAT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 2 :</head><label>2</label><figDesc>p, o) s.t. p {τ , ≺ sc , ≺ sp , ← d , → r } RDF triples. set of blank nodes. In triples, we use _:b (possibly with indices)</figDesc><table><row><cell cols="2">Schema triples Notation</cell></row><row><cell>Subclass</cell><cell>(s, ≺ sc , o)</cell></row><row><cell>Subproperty</cell><cell>(s, ≺ sp , o)</cell></row><row><cell>Domain typing</cell><cell>(s, ← d , o)</cell></row><row><cell>Range typing</cell><cell>(s, → r , o)</cell></row><row><cell>Data triples</cell><cell>Notation</cell></row><row><cell>Class fact</cell><cell>(s, τ , o)</cell></row><row><cell>Property fact</cell><cell>(s,</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3 :</head><label>3</label><figDesc>Sample RDFS entailment rules.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 ,</head><label>3</label><figDesc>which are the most frequently used; in the table, all values except RDF reserved IRIs are blank ) i ∈N of RDF graphs as follows: G 0 = G, andG i+1 = G i ∪C G i , R for i ≥ 0. The saturation of G w.r.t. R, denoted G R , is G n for n the smallest integer such that G n = G n+1 .</figDesc><table><row><cell>e., they</cell></row></table><note><p>nodes. For instance, rule rdfs5 reads: whenever in an RDF graph, a property p 1 is a subproperty of a property p 2 , and further p 2 is a subproperty of p 3 (body of rdfs5), it follows that p 1 is a subproperty of p 3 (head of rdfs5). Similarly, rule rdfs7 states that if p 1 is a subproperty of p 2 and a resource s has the value o for p 1 , then s also has o as a value for p 2 . The triples (p 1 , ≺ sp , p 3 ) and (s, p 2 , o) in the above examples are called implicit, i.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>t. an RDFS ontology O and the set of rules R c into a UBGPQ, say Q c , which is guaranteed not to contain ontology triples. Intuitively, this step generates new BGPQs obtained from q by instantiating variables that query</figDesc><table /><note><p><p>the ontology with all their possible bindings; for instance, y in a query triple (y, ≺ sc , :Comp) is bound to the IRIs of all explicit and implicit subclasses of :Comp in O. This step, alone, is sound and complete w.r.t. R c for query answering, i.e., for any graph G with ontology O, q(G, R c ) = Q c (G).</p>(ii) The second step reformulates Q c w.r.t. O and R a , and outputs a UBGPQ, say Q c ,a . This step, alone, is sound and complete w.r.t. R a for query answering, i.e., for any graph G with ontology</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>to build databases consisting of 10 relations named producer, product, offer, review etc. Using two different benchmark scale factors, we obtained a data source DS 1 of 154.054 tuples across the relations, respectively, DS 2 of 7.843.660 tuples; both are stored in Postgres. We used two RDFS ontologies O 1 respectively O 2 , containing, first, subclass hierarchies of 151 (resp. 2011) product types, which come with DS 1 , respectively, DS 2 . To O 1 and O 2 , we add a natural RDFS ontology for BSBM composed of 26 classes and 36 properties, used in 40 subclass, 32 subproperty, 42 domain and 16 range statements.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>4 • 10 6 results in S 2 and S 4 ); 6 among them query the data and the ontology (recall Example 2.6), a capability which most , S 4 N ANS 4416946 10049829 2998948 249004 39826 60834 904 7818 10486 51988 37176 1528 18588 1329887</figDesc><table><row><cell></cell><cell>RIS</cell><cell></cell><cell>Q01</cell><cell>Q01a</cell><cell cols="9">Q01b Q02 Q02a Q02b Q02c Q03 Q04 Q07 Q07a</cell><cell cols="2">Q09 Q10</cell><cell>Q13</cell></row><row><cell></cell><cell>all</cell><cell>N TRI</cell><cell>5</cell><cell>5</cell><cell>5</cell><cell>6</cell><cell>6</cell><cell>6</cell><cell>6</cell><cell>5</cell><cell>2</cell><cell>3</cell><cell>3</cell><cell>1</cell><cell>3</cell><cell>4</cell></row><row><cell></cell><cell cols="2">S 1 , S 3 |Q c,a |</cell><cell>7</cell><cell>21</cell><cell>175</cell><cell>21</cell><cell>49</cell><cell cols="2">147 1225</cell><cell>525</cell><cell>1</cell><cell>5</cell><cell>19</cell><cell>7</cell><cell>670</cell><cell>28</cell></row><row><cell></cell><cell cols="2">S 1 , S 3 N ANS</cell><cell>1272</cell><cell>4376</cell><cell>22738</cell><cell>16</cell><cell>56</cell><cell cols="2">174 1342</cell><cell>19</cell><cell>91</cell><cell>2</cell><cell>3</cell><cell>5617</cell><cell>9</cell><cell>13190</cell></row><row><cell></cell><cell cols="2">S 2 , S 4 |Q c,a |</cell><cell>21</cell><cell>175</cell><cell>1407</cell><cell>63</cell><cell>147</cell><cell cols="3">525 1225 4375</cell><cell>1</cell><cell>5</cell><cell>19</cell><cell cols="2">7 9350</cell><cell>84</cell></row><row><cell></cell><cell cols="6">S 2 , S 4 N ANS 15514 111793 863729 124</cell><cell cols="3">598 1058 1570</cell><cell cols="2">5 4487</cell><cell>2</cell><cell cols="2">3 299902</cell><cell cols="2">10 167760</cell></row><row><cell>RIS</cell><cell></cell><cell cols="2">Q13a</cell><cell>Q13b</cell><cell>Q14</cell><cell>Q16</cell><cell cols="7">Q19 Q19a Q20 Q20a Q20b Q20c</cell><cell cols="3">Q21 Q22 Q22a</cell><cell>Q23</cell></row><row><cell>all</cell><cell>N TRI</cell><cell></cell><cell>4</cell><cell>4</cell><cell>3</cell><cell>4</cell><cell>9</cell><cell>9</cell><cell>11</cell><cell>11</cell><cell>11</cell><cell></cell><cell>11</cell><cell>3</cell><cell>4</cell><cell>4</cell><cell>7</cell></row><row><cell cols="2">S 1 , S 3 |Q c,a |</cell><cell></cell><cell>84</cell><cell>700</cell><cell>1</cell><cell>25</cell><cell>63</cell><cell>147</cell><cell>21</cell><cell>63</cell><cell>525</cell><cell></cell><cell>1225</cell><cell>670</cell><cell>2</cell><cell>40</cell><cell>192</cell></row><row><cell cols="2">S 1 , S 3 N ANS</cell><cell cols="2">43157</cell><cell>330142</cell><cell>56200</cell><cell>8114</cell><cell>2015</cell><cell>3515</cell><cell>0</cell><cell>236</cell><cell>2312</cell><cell></cell><cell>7564</cell><cell>1085</cell><cell>28</cell><cell>434</cell><cell>25803</cell></row><row><cell cols="2">S 2 , S 4 |Q c ,a |</cell><cell cols="2">5628</cell><cell>5628</cell><cell>1</cell><cell>201</cell><cell>525</cell><cell>1225</cell><cell>63</cell><cell>525</cell><cell>1225</cell><cell></cell><cell>4221</cell><cell>9350</cell><cell>40</cell><cell>520</cell><cell>192</cell></row><row><cell>S 2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 4 :</head><label>4</label><figDesc>Characteristics of the queries used in our experiments.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In the notations R c and R a , c and a respectively stand for "constraint triples" (called schema triples here) and "assertion triples" (data triples).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://ontosql.inria.fr</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>https://downloads.sourceforge.net/project/bsbmtools/bsbmtools/ bsbmtools-0.2</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Experiment web site: https://gitlab.inria.fr/mburon/org/blob/master/projects/ het2onto-benchmark/bsbm/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>http://obdasystems.com/mastro/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>https://ontop.inf.unibz.it/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements: This work is supported by the <rs type="funder">Inria Project Lab iCoda</rs> and the <rs type="projectName">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_BXAMpHP">
					<orgName type="project" subtype="full">ANR</orgName>
				</org>
				<org type="funded-project" xml:id="_M5dkMcp">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">DL-LITER in the Light of Propositional Logic for Decentralized Data Management</title>
		<author>
			<persName><forename type="first">Nada</forename><surname>Abdallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Christine</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Complexity of Answering Queries Using Materialized Views</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oliver</forename><forename type="middle">M</forename><surname>Duschka</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>ACM Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Towards Scalable Hybrid Stores: Constraint-Based Rewriting to the Rescue</title>
		<author>
			<persName><forename type="first">Rana</forename><surname>Alotaibi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damian</forename><surname>Bursztyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stamatis</forename><surname>Zampetakis</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-02070827" />
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Querying XML Sources Using an Ontology-Based Mediator</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Amann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catriel</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irini</forename><surname>Fundulaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Scholl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CoopIS</title>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Integrating Ontologies and Thesauri to Build RDF Schemas</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Amann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irini</forename><surname>Fundulaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECDL</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Integrating ontologies and thesauri for RDF schema creation and metadata querying</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Amann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irini</forename><surname>Fundulaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Scholl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. on Digital Libraries</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m">The Description Logic Handbook: Theory, Implementation, and Applications</title>
		<editor>
			<persName><forename type="first">Franz</forename><surname>Baader</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Deborah</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Daniele</forename><surname>Nardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Peter</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Graal: A Toolkit for Query Answering with Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-François</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swan</forename><surname>Rocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clément</forename><surname>Sipieter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RuleML</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Mixed-instance querying: a lightweight integration architecture for data journalism</title>
		<author>
			<persName><forename type="first">Raphaël</forename><surname>Bonaque</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tien</forename><surname>Duc Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bogdan</forename><surname>Cautis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Letelier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oscar</forename><surname>Mendoza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swen</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Tannier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-01321201" />
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Generalized Framework for Ontology-Based Data Access</title>
		<author>
			<persName><forename type="first">Elena</forename><surname>Botoeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julien</forename><surname>Corman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AI*IA</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Reformulation-Based Query Answering for RDF Graphs with RDFS Ontologies</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Rewriting-Based Query Answering for Semantic Data Integration Systems</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<ptr target="https://hal.archives-ouvertes.fr/hal-01927282" />
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>BDA (informal publication only</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimizing Reformulation-based Query Answering in RDF</title>
		<author>
			<persName><forename type="first">Damian</forename><surname>Bursztyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A general Datalogbased framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ontop: Answering SPARQL queries over relational databases</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarah</forename><surname>Komla-Ebri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The MASTRO system for ontology-based data access</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Ruzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><forename type="middle">Fabio</forename><surname>Savo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Using OWL in Data Integration</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Ruzzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantic Web Information Management -A Model-Based Perspective</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Query Processing under GLAV Mappings for Relational and Graph Databases</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Semantic Network Approach to Semi-Structured Documents Repositories</title>
		<author>
			<persName><forename type="first">Vassilis</forename><surname>Christophides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Doerr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irini</forename><surname>Fundulaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECDL</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Using Ontologies for Semantic Data Integration</title>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giacomo</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A Comprehensive Guide Through the Italian Database Research Over the Last 25 Years</title>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">31</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">MARS: A System for Publishing XML from Mixed and Redundant Storage</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Principles of Data Integration</title>
		<author>
			<persName><forename type="first">Anhai</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Morgan Kaufmann</publisher>
			<pubPlace>Waltham, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The BigDAWG Polystore System</title>
		<author>
			<persName><forename type="first">J</forename><surname>Duggan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Elmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Balazinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kepner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mattson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Learning Commonalities in SPARQL</title>
		<author>
			<persName><forename type="first">Sara</forename><forename type="middle">El</forename><surname>Hassad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hélène</forename><surname>Jaudoin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Navigational Plans for Data Integration</title>
		<author>
			<persName><forename type="first">Marc</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">D</forename><surname>Millstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">I3 workshop@IJCAI</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The TSIMMIS Approach to Mediation: Data Models and Languages</title>
		<author>
			<persName><forename type="first">Hector</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dallan</forename><surname>Quass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehoshua</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vasilis</forename><surname>Vassalos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Intell. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The Use of CARIN Language and Algorithms for Information Integration: The PICSEL System</title>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Véronique</forename><surname>Lattès</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Christine</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Cooperative Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Efficient query answering against dynamic RDF databases</title>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Roatis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Answering queries using views: A KRDB perspective for the semantic Web</title>
		<author>
			<persName><forename type="first">François</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Christine</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOIT</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2004">2004. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Answering Queries Using Views: A Survey</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2001-12">2001. Dec. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Ontology-Based Data Access to Slegge</title>
		<author>
			<persName><forename type="first">Dag</forename><surname>Hovland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">G</forename><surname>Skjaeveland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arild</forename><surname>Waaler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Answering SPARQL Queries over Databases under OWL 2 QL Entailment Regime</title>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodríguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Cost-Driven Ontology-Based Data Access</title>
		<author>
			<persName><forename type="first">Davide</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Data Integration: A Theoretical Perspective</title>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>PODS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Querying Heterogeneous Information Sources Using Source Descriptions</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anand</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joann</forename><forename type="middle">J</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><surname>Ordille</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Data Model and Query Evaluation in Global Information Systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divesh</forename><surname>Levy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName><surname>Kirk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Intell. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Answering XML Queries on Heterogeneous Data Sources</title>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donald</forename><surname>Kossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Ontological Query Answering with Existential Rules</title>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<editor>RR.</editor>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Optimizing query rewriting in ontology-based data access</title>
		<author>
			<persName><forename type="first">Di</forename><surname>Floriana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Mancini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><forename type="middle">Fabio</forename><surname>Ruzzi</surname></persName>
		</author>
		<author>
			<persName><surname>Savo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Linking Data to Ontologies</title>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Data Semantics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">MiniCon: A scalable algorithm for answering queries using views</title>
		<author>
			<persName><forename type="first">Rachel</forename><surname>Pottinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Ontology-Based Data Access: Ontop of Databases</title>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">OBDA: Query Rewriting or Materialization? In Practice, Both!</title>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">F</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">P</forename><surname>Miranker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">AGGREGO SEARCH: Interactive Keyword Query Construction</title>
		<author>
			<persName><forename type="first">Grégory</forename><surname>Smits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Pivert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hélène</forename><surname>Jaudoin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><surname>Paulus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<author>
			<persName><forename type="first">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<idno>3</idno>
		<ptr target="https://www.w3.org/TR/sparql11-query/" />
		<title level="m">SPARQL 1.1 Query Language</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<author>
			<persName><forename type="first">W</forename></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename></persName>
		</author>
		<idno>3</idno>
		<ptr target="https://www.w3.org/TR/rdf11-concepts/" />
		<title level="m">RDF 1.1 Concepts and Abstract Syntax</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<author>
			<persName><surname>W3c</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/rdf11-mt/#rdfs-entailment" />
		<title level="m">RDF 1.1 Semantics</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Mediators in the Architecture of Future Information Systems</title>
		<author>
			<persName><forename type="first">Gio</forename><surname>Wiederhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1992">1992. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
