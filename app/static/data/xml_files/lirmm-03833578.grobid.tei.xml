<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Deciding Hyperproperties Combined with Functional Specifications</title>
				<funder ref="#_JEmEAjn">
					<orgName type="full">Center for Perspicuous Systems)</orgName>
				</funder>
				<funder ref="#_bcZcRJj">
					<orgName type="full">German Research Foundation (DFG)</orgName>
				</funder>
				<funder ref="#_RaccuPu">
					<orgName type="full">Center for Advancing Electronics Dresden</orgName>
				</funder>
				<funder ref="#_2ZKn6m8">
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
				<funder ref="#_vxXfdrg">
					<orgName type="full">Bundesministerium für Bildung und Forschung (BMBF)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2022-05-30">30 May 2022</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CISPA Helmholtz Center for Information Security Germany</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS France</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">CISPA Helmholtz Center for Information Security Germany</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jana</forename><surname>Hofmann</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">CISPA Helmholtz Center for Information Security Germany</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Technische Universität Dresden</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Deciding Hyperproperties Combined with Functional Specifications</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2022-05-30">30 May 2022</date>
						</imprint>
					</monogr>
					<idno type="MD5">6AF4BFFD862E50007D25F7701F6602DE</idno>
					<idno type="DOI">10.1145/3531130.3533369</idno>
					<idno type="arXiv">arXiv:2205.15138v1[cs.LO]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CCS Concepts:</term>
					<term>Theory of computation → Logic and verification; Modal and temporal logics Hyperproperties</term>
					<term>HyperLTL</term>
					<term>Satisfiability ACM</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study satisfiability for HyperLTL with a ∀ * ∃ * quantifier prefix, known to be highly undecidable in general. HyperLTL can express system properties that relate multiple traces (socalled hyperproperties), which are often combined with trace properties that specify functional behavior on single traces. Following this conceptual split, we first define several safety and liveness fragments of ∀ * ∃ * HyperLTL, and characterize the complexity of their (often much easier) satisfiability problem. We then add LTL trace properties as functional specifications. Though (highly) undecidable in many cases, this way of combining "simple" HyperLTL and arbitrary LTL also leads to interesting new decidable fragments. This systematic study of ∀ * ∃ * fragments is complemented by a new (incomplete) algorithm for ∀∃ * -HyperLTL satisfiability.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Hyperproperties are properties that relate multiple execution traces of a system <ref type="bibr" target="#b12">[13]</ref> and comprise a range of relevant properties from many areas of computer science. Examples are symmetry, optimality, robustness, and noninterference. The most prominent logic for expressing hyperproperties is HyperLTL <ref type="bibr" target="#b11">[12]</ref>, which extends LTL with trace quantification. Generalized noninterference <ref type="bibr" target="#b33">[33]</ref>, for example, states that high-security inputs do not influence the input-output behavior observable by a low-security user, which can be expressed in HyperLTL as follows.</p><p>∀𝜋∀𝜋 ′ ∃𝜋 ′′ .</p><formula xml:id="formula_0">𝑎 ∈𝐿 out ∪𝐿 in (𝑎 𝜋 ↔ 𝑎 𝜋 ′′ ) ∧ 𝑎 ∈𝐻 in (𝑎 𝜋 ′ ↔ 𝑎 𝜋 ′′ )</formula><p>The formula states that for every two traces 𝜋, 𝜋 ′ , there exists a trace 𝜋 ′′ that combines the low-security inputs and outputs on 𝜋 and the high-security inputs on 𝜋 ′ .</p><p>In this paper, we study the satisfiability problem of Hyper-LTL. For LTL, satisfiability is PSPACE-complete <ref type="bibr" target="#b39">[39]</ref>. For hyperproperties, satisfaction cannot be decided by analyzing single traces in isolation, making formal reasoning challenging. Deciding satisfiability in the ∃ * ∀ * fragment of HyperLTL is already EXPSPACE-complete <ref type="bibr" target="#b18">[19]</ref>; and deciding hyperproperties with a ∀ * ∃ * trace quantifier alternations is, in general, strongly undecidable, namely Σ 1 1 -complete <ref type="bibr" target="#b23">[24]</ref>. The ∀ * ∃ * fragment contains many relevant properties like generalized noninterference, program refinement, and software doping <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b33">33]</ref>. However, positive results for this important fragment have been very rare and were only obtained by heavy restrictions on the use of temporal operators or by assuming finite models <ref type="bibr" target="#b32">[32]</ref> (see related work below). Algorithms, even if incomplete, are similarly missing.</p><p>In this work, we address these shortcomings by studying ways of solving satisfiability of ∀ * ∃ * HyperLTL specifications. We identify simple yet expressive fragments of ∀ * ∃ * with better computational properties, where our approach derives interesting fragments in two steps. First, we split a specification into hyperproperty and trace property, so that we can focus on "simple" hyperproperties. Second, to find such simple hyperproperties, we systematically study fragments of temporal safety and temporal liveness hyperproperties. This work towards new decidable fragments is complemented by a new (incomplete but often successful) algorithm that is applicable to arbitrary ∀∃ * specifications.</p><p>Splitting in Hyperproperties and Trace Properties. So far, all HyperLTL decidability results were obtained by considering HyperLTL specifications in isolation. Most of the time, however, specifications refer to a specific system. The hyperproperty itself is often relatively simple (like the noninterference property above) and only gets difficult to satisfy given a specification of the functional behavior of the system. <ref type="foot" target="#foot_0">1</ref> The following example highlights this interplay between functional property and hyperproperty.</p><p>Example 1.1. Consider a system of agents that send and receive data. Each trace describes the behavior of a single agent. We want the system to satisfy the following hyperproperty.</p><formula xml:id="formula_1">𝜑 ∀𝜋∃𝜋 ′ . (send 𝜋 ∧ rec 𝜋 ′ )</formula><p>The formula states that each agent eventually sends its information and that there exists some agent receiving it. The formula on its own is easily satisfiable already by a one-trace model. In addition to the hyperproperty we add the simple functional specification (trace property)</p><formula xml:id="formula_2">𝜓 (¬rec) U (rec ∧ ¬rec) ∧ (rec ↔ send)</formula><p>which expresses that each agent receives data exactly once and sends it forth in the next step. Every model that satisfies the combination of 𝜑 and 𝜓 needs to be infinite. Automatically checking satisfiability is thus complex as we cannot iteratively search for models of bounded (finite) size. ◁</p><p>A satisfiability checker that distinguishes between a functional specification and hyperproperties could be used to sanity-check whether a hyperproperty is satisfiable in combination with the specification of the system at hand.</p><p>Temporal Safety and Temporal Liveness. The classification into safety and liveness has a long tradition in the study of trace properties, where especially safety often allows for easier algorithms. For our analysis, we define analogous fragments: a HyperLTL formula is temporal safety (resp. temporal liveness) if its LTL body describes a safety (resp. liveness) property. We study the relationship to the existing notations of hypersafety and hyperliveness defined by Clarkson and Schneider <ref type="bibr" target="#b12">[13]</ref>. Guided by our insights into the complete fragments, we derive several more specific classes of temporal safety and liveness properties, for which satisfiability is easier to decide.</p><p>Main Results. Our results are summarized in Table <ref type="table" target="#tab_0">1</ref>, where each line represents a class of HyperLTL properties, and the columns distinguish whether or not additional (arbitrarily complex) LTL specifications are allowed. All hardness results for ∀ * ∃ * fragments, except in the NEXP cases, already hold for ∀∃ * . The restriction to temporal safety makes the satisfiability of HyperLTL drop from Σ 1  1 to coRE, which we show by an effective reduction to satisfiability of first-order logic. While still undecidable, this enables the use of common first-order techniques such as resolution, tableaux, and related methods <ref type="bibr" target="#b36">[36]</ref>. Hardness already holds for simple formulas consisting only of a single with s in its scope. If we add (non-safety) functional specifications, hardness jumps back to Σ 1 1 . In contrast to temporal safety properties, the class of temporal liveness HyperLTL formulas is of analytical complexity, even without additional LTL specifications. However, again in contrast to ( * ), formulas from the ∀∃ * . ( * ) fragment are decidable, even when combined with an arbitrary LTL specification. This is the first Hyper-LTL decidability result for formulas that can enforce models with infinitely many traces. The class also contains the specification from Example 1.1. This decidability result is tight in the sense that already conjunctions of multiple eventualities are analytical again.</p><p>Finally, to complement our decidability results, we propose a general approximation algorithm to find the largest model for specifications consisting of a HyperLTL formula and an LTL formula. Our experimental evaluation shows that our algorithm performs significantly better than approaches that iteratively search for models of bounded size <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">32]</ref> and can even show unsatisfiability for many formulas (which is impossible in bounded approaches).</p><p>Structure. The remainder of this paper is structured as follows. We give some basic preliminaries and introduce HyperLTL in Section 2. We study the fragment of temporal safety in Section 3. We begin this study with the full fragment, and then gradually decrease in expressiveness all the way to the fragment containing only operators. We then move to temporal liveness in Section 4. Analogous to the safety case, we begin with the full fragment, gradually decreasing to the fragment of pure eventualities, for which we establish decidability. Finally, in Section 5, we describe our approximation for finding the largest models and report on experimental results in Section 6.</p><p>Related Work. In recent years, many logics to express hyperproperties have been developed. Most approaches extend existing logics with trace or path quantification, examples besides HyperLTL are HyperCTL * <ref type="bibr" target="#b12">[13]</ref>, HyperQPTL <ref type="bibr" target="#b35">[35]</ref>, HyperPDL-Δ <ref type="bibr" target="#b26">[26]</ref>, and HyperATL * <ref type="bibr" target="#b5">[6]</ref>. Monadic first-order logics can be extended by adding a special equal-level predicate <ref type="bibr" target="#b21">[22]</ref> or using different types of quantifiers <ref type="bibr" target="#b3">[4]</ref>. Recently, hyperproperties have also been obtained via a team semantics for trace logics <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b42">42]</ref>. Apart from plain temporal logics, there are also hyperlogics for hyperproperties that are asynchronous <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b27">27]</ref>, quantitative <ref type="bibr" target="#b20">[21]</ref>, or probabilistic <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>HyperLTL remains the most used among the proposed hyperlogics. Its satisfiability problem is known to be challenging: if we define fragments based on quantifier prefixes (but with an arbitrary body), then ∃ * ∀ * is the most general fragment for which satisfiability is still decidable (and EXPSPACEcomplete), whereas ∀∃ * already leads to undecidability <ref type="bibr" target="#b18">[19]</ref>. In fact, the ∀ * ∃ * fragment is already satisfiability-complete: any HyperLTL formula can be effectively translated into equisatisfiable ∀ * ∃ * formula <ref type="bibr" target="#b32">[32]</ref>. Analyzing the case of (unrestricted) HyperLTL in more detail, Fortin et al. show satisfiability to be Σ 1 1 -complete, and therefore above all problems in the arithmetic hierarchy <ref type="bibr" target="#b23">[24]</ref>. In a more fine-grained analysis, Mascle and Zimmermann show that the problem becomes decidable if one only considers models of a bounded size or if, for selected quantifier prefixes, temporal operators are not nested <ref type="bibr" target="#b32">[32]</ref>. In particular, ∀∃ * properties using only and (without s) are decidable (and always have a finite model), as no "diagonal" comparison between trace positions is possible <ref type="bibr" target="#b32">[32]</ref>. The satisfiability of the logics HyperQPTL and HyperCTL * , which both subsume HyperLTL, has been studied as well <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We assume a fixed, finite set of atomic propositions AP and write Σ 2 AP . Given a symbol 𝜋, we write AP 𝜋 for the set</p><formula xml:id="formula_3">{𝑎 𝜋 | 𝑎 ∈ AP }. A trace 𝑡 is an element in Σ 𝜔 . For 𝑖 ∈ N, 𝑡<label>(</label></formula><p>𝑖) denotes the 𝑖th element in 𝑡 (starting with the 0th) and 𝑡 [𝑖, ∞] is the suffix of a trace starting in point in time 𝑖. For a finite trace 𝑢 ∈ Σ * and an infinite trace 𝑡 ∈ Σ 𝜔 , 𝑢 is a prefix of 𝑡 (written 𝑢 ⋖ 𝑡) if for every 0 ≤ 𝑖 &lt; |𝑢 |, 𝑢 (𝑖) = 𝑡 (𝑖). A trace property 𝑃 is a set of traces, whereas a hyperproperty 𝐻 is a set of sets of traces <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Trace Properties and LTL</head><p>Linear temporal logic (LTL) defines trace properties by combining temporal operators with boolean connectives. Its syntax is defined by the following grammar.</p><formula xml:id="formula_4">𝜓 𝑎 | ¬𝜓 | 𝜓 ∧ 𝜓 | 𝜓 | 𝜓 U 𝜓</formula><p>where 𝑎 ∈ AP. We also use the standard Boolean connectives ∧, →, ↔ and constants ⊤, ⊥, as well as the derived LTL operators eventually 𝜓 ⊤ U 𝜓 , and globally 𝜓 ¬ ¬𝜓 . The semantics of LTL is defined as usual.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>𝑡 |= 𝑎</head><p>iff 𝑎 ∈ 𝑡 (0)</p><formula xml:id="formula_5">𝑡 |= ¬𝜓 iff 𝑡 ̸ |= 𝜓 𝑡 |= 𝜓 1 ∧ 𝜓 2 iff 𝑡 |= 𝜓 1 and 𝑡 |= 𝜓 2 𝑡 |= 𝜓 iff 𝑡 [1, ∞] |= 𝜓 𝑡 |= 𝜓 1 U 𝜓 2 iff ∃𝑖. 𝑡 [𝑖, ∞] |= 𝜓 2 and ∀𝑗 &lt; 𝑖. 𝑡 [ 𝑗, ∞] |= 𝜓 1</formula><p>Safety and liveness properties are prominent classes of trace properties <ref type="bibr" target="#b1">[2]</ref>. Safety properties are characterized by the fact that each violation is caused after a finite time. Liveness properties characterize that something good happens eventually.</p><p>Definition 2.1. A property 𝑃 is safety if it holds that for every trace 𝑡 ∉ 𝑃, there exists a 𝑢 ⋖ 𝑡 such that for every 𝑡 ′ with 𝑢 ⋖ 𝑡 ′ , we have 𝑡 ′ ∉ 𝑃. A property 𝑃 is liveness if for every 𝑢 ∈ Σ * , there exists a 𝑡 ∈ Σ 𝜔 with 𝑢 ⋖ 𝑡 and 𝑡 ∈ 𝑃.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Hyperproperties and HyperLTL</head><p>HyperLTL <ref type="bibr" target="#b11">[12]</ref> extends LTL with explicit quantification over traces, thereby lifting it from a logic expressing trace properties to one expressing hyperproperties <ref type="bibr" target="#b12">[13]</ref>. Let V be a set of trace variables. We define HyperLTL formulas with the following grammar.</p><formula xml:id="formula_6">𝜑 ∃𝜋 . 𝜑 | ∀𝜋 . 𝜑 | 𝜙 𝜙 𝑎 𝜋 | ¬𝜙 | 𝜙 ∧ 𝜙 | 𝜙 | 𝜙 U 𝜙</formula><p>Here, 𝜋 ∈ V and 𝑎 ∈ AP. We consider only closed formulas, i.e., formulas where for each atom 𝑎 𝜋 the trace variable 𝜋 is bound by some trace quantifier. The semantics of HyperLTL is given with respect to a set of traces 𝑇 and a trace assignment Π, which is a partial mapping Π : V ⇀ Σ 𝜔 . For 𝜋 ∈ V and 𝑡 ∈ 𝑇 , we write Π[𝜋 ↦ → 𝑡] for the trace assignment obtained by updating the value of 𝜋 to 𝑡. We write</p><formula xml:id="formula_7">Π[𝑖, ∞] for the assignment Π[𝑖, ∞] (𝜋) Π(𝜋) [𝑖, ∞]. Π |= 𝑇 𝑎 𝜋 iff 𝑎 ∈ Π(𝜋) (0) Π |= 𝑇 ¬𝜙 iff Π ̸ |= 𝑇 𝜙 Π |= 𝑇 𝜙 1 ∧ 𝜙 2 iff Π |= 𝑇 𝜙 1 and Π |= 𝑇 𝜙 2 Π |= 𝑇 𝜙 iff Π[1, ∞] |= 𝑇 𝜙 Π |= 𝑇 𝜙 1 U 𝜙 2 iff ∃𝑖. Π[𝑖, ∞] |= 𝑇 𝜙 2 and ∀𝑗 &lt; 𝑖. Π[ 𝑗, ∞] |= 𝑇 𝜙 1 Π |= 𝑇 ∃𝜋 . 𝜑 iff ∃𝑡 ∈ 𝑇 . Π[𝜋 ↦ → 𝑡] |= 𝑇 𝜑 Π |= 𝑇 ∀𝜋 . 𝜑 iff ∀𝑡 ∈ 𝑇 . Π[𝜋 ↦ → 𝑡] |= 𝑇 𝜑</formula><p>We say that 𝑇 is a model of Analogous to trace properties, we can characterize hyperproperties as hypersafety and hyperliveness <ref type="bibr" target="#b12">[13]</ref>. We lift the prefix relation ⋖ to sets of traces: a set 𝑈 ⊆ Σ * of finite traces is a prefix of a set 𝑇 ⊆ Σ 𝜔 (written 𝑈 ⋖𝑇 ) if, for every 𝑢 ∈ 𝑈 , there exists a 𝑡 ∈ 𝑇 such that 𝑢 ⋖ 𝑡. Definition 2.3. A hyperproperty 𝐻 is hypersafety if for every 𝑇 ⊆ Σ 𝜔 with 𝑇 ∉ 𝐻 , there exists a finite set 𝑈 ⊆ Σ * with 𝑈 ⋖ 𝑇 such that, for every 𝑇 ′ ⊆ Σ 𝜔 with 𝑈 ⋖ 𝑇 ′ , we have 𝑇 ′ ∉ 𝐻 . A property 𝐻 is hyperliveness if for every finite set 𝑈 ⊆ Σ * , there exists 𝑇 ⊆ Σ 𝜔 with 𝑈 ⋖ 𝑇 and 𝑇 ∈ 𝐻 .</p><p>Intuitively, a violation of a hypersafety property can be explained by the finite interaction of finitely many traces. Conversely, a hyperproperty is hyperliveness, if such a set can always be extended to a set satisfying the property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Specifications and Notation</head><p>We study the combination of ∀ * ∃ * HyperLTL formulas and arbitrary LTL formulas, and call such pairs specifications. Definition 2.4. A specification is a pair (𝜓, 𝜑) where 𝜓 is an LTL formula and 𝜑 a HyperLTL formula. We say that (𝜓, 𝜑) is satisfiable iff there exists a non-empty set of traces 𝑇 ⊆ Σ 𝜔 such that ∀𝑡 ∈ 𝑇 . 𝑡 |= 𝜓 and 𝑇 |= 𝜑.</p><p>In general, we write (𝜓, 𝜑) for specifications with arbitrary LTL and HyperLTL formulas. We use the following notation for fragments of specifications. We write (⊤, 𝜑) to indicate that no LTL formula is given or, equivalently, the trace specification is true. We represent the quantifier prefix of the HyperLTL property using regular expressions. For example, ∀∃ * is a prefix consisting of a single universal quantifier followed by any number of existential quantifiers. We write 𝑄 * for an arbitrary prefix. The body of a HyperLTL formula is structured based on the use of temporal operators. We allow propositional (temporal-operator-free) formulas as conjuncts if not stated otherwise Consider the following example. A ∀ * ∃ * . ( * ) formula is of the form ∀𝜋 1 . . . ∀𝜋 𝑛 ∃𝜋 𝑛+1 . . . ∃𝜋 𝑛+𝑚 . ( 𝜙) ∧ 𝜙 ′ , where 𝜙 may contain (potentially nested) operators and 𝜙 ′ does not contain any temporal operators. Analogously, a formula in ∀ * ∃ * . describes formulas as the one above but 𝜙 may not contain s. A formula in ∀ * ∃ * . ∧ uses a conjunction of two eventualities (also without s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Complexity of Undecidable Problems</head><p>Many problems considered in this paper are highly undecidable. To enable precise quantification of "how undecidable", we briefly recall the arithmetic and analytical hierarchy. We only provide a brief overview and refer to <ref type="bibr" target="#b37">[37]</ref> for details.</p><p>The arithmetic hierarchy contains all problems (languages) that can be expressed in first-order arithmetic over the natural numbers. It contains the class of recursively enumerable (RE) and co-enumerable problems (coRE) in its first level. The class Σ 1 1 (sitting in the analytical hierarchy) contains all problems that can be expressed with existential second-order quantification (over sets of numbers) followed by a firstorder arithmetic formula. Analogously, the class Π 1  1 contains all problems expressible using universal second-order quantification. Consequently, both Σ 1 1 and Π 1 1 (strictly) contain the entire arithmetic hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Machines</head><p>As a basic model of computation to show hardness we use two-counter machines. A nondeterministic 2-counter machine (2CM) consists of a finite set of instructions 𝑙 1 , . . . 𝑙 𝑛 , which modify two counters 𝑐 1 , 𝑐 </p><formula xml:id="formula_8">. A config- uration of a 2CM is a tuple (𝑙 𝑖 , 𝑣 1 , 𝑣 2 )</formula><p>, where 𝑙 𝑖 is the next instruction to be executed, and 𝑣 1 , 𝑣 2 ∈ N denote the values of the counters. The initial configuration of a 2CM is (𝑙 1 , 0, 0). The transition relation between configurations is defined as expected. Decrementing a counter that is already 0 leaves the counter unchanged. A 2CM halts if a configuration with a halt instruction is reached. Deciding if a machine has a halting computation is RE-complete and deciding if it has an infinite computation is coRE-complete <ref type="bibr" target="#b34">[34]</ref>. An infinite computation is recurring if it visits instruction 𝑙 1 infinitely many times. Deciding if a machine has a recurring computation, is Σ 1 1 -hard <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Temporal Safety</head><p>In this section, we study the satisfiability problem of temporal safety HyperLTL formulas. We begin by defining temporal safety and argue why, compared to hypersafety, it is the more suitable fragment in the context of satisfiability. Subsequently, we show that temporal safety specifications improve the general Σ 1 1 -hardness of ∀ * ∃ * hyperproperties <ref type="bibr" target="#b23">[24]</ref> to coRE-complete. We obtain this result by a reduction to satisfiability of first-order logic. In the next step, we investigate the combination of temporally safe hyperproperties with arbitrary functional trace specifications given in LTL. The complexity jumps again to Σ 1 1 -completeness, perhaps surprisingly already for very basic ∀∃ * formulas only using one as temporal operator. We, therefore, analyze the remaining fragments for decidability results and establish that hyperproperties that only use s as temporal operators are NEXPTIME-complete, even when adding arbitrary LTL specifications. The same holds for hyper-invariants (using ) without an LTL specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Hypersafety and Temporal Safety</head><p>The safety fragment of LTL is one of the most successful fragments of temporal logics as it is amendable to easier monitoring and verification than arbitrary 𝜔-regular properties <ref type="bibr" target="#b30">[30]</ref>. The concept of a safety property (i.e., every violation is caused after a finite time) naturally extends to hyperproperties, giving the general class of hypersafety (cf. Definition 2.3) <ref type="bibr" target="#b12">[13]</ref>. However, hypersafety is not well suited for a systematic study of the decidability of hyperproperties.</p><p>Deciding if a property is hypersafety is already highly undecidable and deciding if a hypersafety property is satisfiable is directly reducible to LTL satisfiability.</p><p>Proposition 3.1. Deciding if a HyperLTL formula 𝜑 is hypersafety is Π 1 1 -hard. Proof. As shown in <ref type="bibr" target="#b17">[18,</ref><ref type="bibr">Thm. 23]</ref>, for any HyperLTL formula 𝜑 we can effectively construct a formula 𝜑 ′ such that 𝜑 is unsatisfied iff 𝜑 ′ is hypersafety. As HyperLTL unsatisfiability is Π 1 1 -hard <ref type="bibr" target="#b23">[24]</ref>, the hardness follows. □ Proposition 3.2. Given a HyperLTL formula 𝜑 that is hypersafety, satisfiability of 𝜑 is decidable in PSPACE.</p><p>Proof. As hypersafety properties are closed under subsets <ref type="bibr" target="#b12">[13]</ref>, 𝜑 is satisfiable iff it is satisfiable by a single trace model. Therefore, we can collapse all quantifiers in 𝜑 to universal ones, giving an equisatisfiable (but not equivalent) ∀ * formula for which satisfiability is decidable in PSPACE <ref type="bibr" target="#b18">[19]</ref>. □ Instead of focusing on hypersafety, we study the satisfiability problem for a broader fragment of formulas which we call temporally safe. Definition 3.3. A HyperLTL formula 𝑄𝜋 1 . . . 𝑄𝜋 𝑛 . 𝜙 is temporal safety if 𝜙 (interpreted as an LTL formula over AP 𝜋 1 ∪ . . . ∪ AP 𝜋 𝑛 ) describes a safety property.</p><p>Similar to the case of LTL <ref type="bibr" target="#b30">[30]</ref>, the safety restriction on the body of the HyperLTL formula allows for easier verification (see, e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>). We argue that temporal safety is also an interesting fragment to study in the context of satisfiability. First, compared with hypersafety, it is decidable whether a formula is temporally safe, as safety is recognizable for LTL <ref type="bibr" target="#b38">[38]</ref>. Second, the next two propositions show that temporal safety defines an expressive fragment: it subsumes all ∀ * ∃ * hypersafety properties. Proposition 3.4. For any ∀ * hypersafety property, there exists an equivalent ∀ * property that is temporally safe.</p><p>Proof. Let 𝜑 = ∀𝜋 1 . . . 𝜋 𝑛 . 𝜙 be the hypersafety property. For any function 𝑓 : {1, . . . , 𝑛} → {1, . . . , 𝑛} (of which there are 𝑛 𝑛 many) we define the formula 𝜙 [𝑓 ] as the formula obtained by replacing each trace variable 𝜋 𝑖 for 1 ≤ 𝑖 ≤ 𝑚 with 𝜋 𝑓 (𝑖) . Define 𝜑 ′ ∀𝜋 1 . . . 𝜋 𝑛 . 𝜙 ′ where 𝜙 ′ 𝑓 :{1,...,𝑛 }→{1,...,𝑛 }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>𝜙 [𝑓 ]</head><p>It is easy to see that 𝜑 ≡ 𝜑 ′ (using the semantics of universal quantification). We claim that 𝜙 ′ expresses a safety property when interpreted as trace property over</p><formula xml:id="formula_9">AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑛 . Take any trace 𝑡 over AP 𝜋 1 ∪ • • • ∪AP 𝜋 𝑛 with 𝑡 ̸ |= 𝜙 ′ (</formula><p>as in the definition of safety, cf. Definition 2.1). Let 𝑇 = {𝑡 1 , . . . , 𝑡 𝑛 } be the set obtained by splitting 𝑡 into 𝑛 traces, i.e., 𝑡 𝑖 is a trace over AP that copies the assignments to AP 𝜋 𝑖 on 𝑡. By construction of 𝑇 we get 𝑇 ̸ |= 𝜑 ′ and, as 𝜑 ≡ 𝜑 ′ is hypersafety, we get a finite set of finite traces 𝑈 ⋖𝑇 such that no extension of 𝑈 satisfies 𝜑. We assume that 𝑈 = {𝑢 1 , . . . , 𝑢 𝑛 } where 𝑢 𝑖 ⋖𝑡 𝑖 for each 𝑖. This assumption is w.l.o.g., as we can replace multiple prefixes of the same 𝑡 𝑖 by the longest among those prefixes, and add an arbitrary prefix of each 𝑡 𝑖 that previously had no prefix in 𝑈 . We further assume, again w.l.o.g., that all 𝑢 𝑖 s have the same length, say 𝑘. Now define 𝑢 as the finite trace (of length 𝑘) over AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑛 , where the assignment to AP 𝜋 𝑖 is taken from 𝑢 𝑖 . As 𝑢 𝑖 ⋖ 𝑡 𝑖 for each 𝑖, we get 𝑢 ⋖ 𝑡. It remains to argue that 𝑢 is a bad prefix of 𝜙 ′ . Let 𝑡 ′ be any trace with 𝑢 ⋖ 𝑡 ′ . We, again, split </p><formula xml:id="formula_10">𝑡 ′ into traces 𝑡 ′ 1 , . . . , 𝑡 ′ 𝑛 . Now 𝑇 ′ {𝑡 ′ 1 , . . . , 𝑡 ′ 𝑛 } satisfies 𝑈 ⋖ 𝑇 ′ , so 𝑇 ′ ̸ |= 𝜑. By the semantics of universal quantification, there thus exists a 𝑓 such that [𝜋 1 ↦ → 𝑡 ′ 𝑓 (1) , . . . , 𝜋 𝑛 ↦ → 𝑡 ′ 𝑓 (𝑛) ] ̸ |= 𝜙 and so [𝜋 1 ↦ → 𝑡 ′ 1 , . . . , 𝜋 𝑛 ↦ → 𝑡 ′ 𝑛 ] ̸ |= 𝜙 [𝑓 ] . This implies that 𝑡 ′ ̸ |= 𝜙 [𝑓 ] in</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Temporal Safety without Functional Specifications</head><p>Having established that temporal safety spans a broad spectrum of properties, we now establish that the general analytical hardness of HyperLTL <ref type="bibr" target="#b23">[24]</ref> drops to coRE-completeness for temporal safety.</p><p>Theorem 3.7. The satisfiability problem of temporally safe HyperLTL is coRE-complete.</p><p>We show the upper bound of Theorem 3.7 by giving an effective translation from temporally safe HyperLTL to firstorder logic using the fact that satisfiability of first-order logic is coRE-complete <ref type="bibr" target="#b25">[25]</ref>. Our translation enables the application of first-order satisfiability solvers in the realm of hyperproperties.</p><p>Definition 3.8. A safety automaton over alphabet Σ is a tuple A = (𝑄, 𝑞 0 , 𝛿) where 𝑄 is a finite set of states, 𝑞 0 ∈ 𝑄 the initial state, and 𝛿 ⊆ 𝑄 ×Σ×𝑄 is the transition relation. A trace 𝑡 ∈ Σ 𝜔 is accepted by A if there exists some infinite run 𝑟 ∈ 𝑄 𝜔 such that 𝑟 (0) = 𝑞 0 and for all 𝑖, (𝑟 (𝑖), 𝑡 (𝑖), 𝑟 (𝑖 + 1)) ∈ 𝛿. For every safety trace property 𝜙, there exists a safety automaton that accepts 𝜙 <ref type="bibr" target="#b30">[30]</ref>.</p><p>Proposition 3.9. The satisfiability problem of temporally safe HyperLTL is in coRE.</p><formula xml:id="formula_11">Proof. Let 𝜑 = 𝑄 1 𝜋 1 . . . 𝑄 𝑛 𝜋 𝑛 . 𝜙 be a temporally safe Hyper- LTL formula. Let A 𝜙 = (𝑄 𝜙 , 𝑞 0,𝜙 , 𝛿 𝜙 ) be a safety automaton over Σ 2 AP 𝜋 1 ∪•••∪AP 𝜋𝑛 that accepts 𝜙 (when interpreted as an LTL formula over AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑛 ).</formula><p>We define in the following an equisatisfiable first-order formula Θ, which can be computed from 𝜑. For readability, we use two-sorted first-order logic, which is equisatisfiable to standard firstorder logic. We use two sorts: Trace, which contains trace variables, and TimePoint, which contains time variables. We use the constant 𝑖 0 : To complement the upper bound, we show coRE-hardness by reducing the complement of the halting problem of deterministic Turing machines. The proof shows that already a single with nested suffices for coRE-hardness.</p><p>Lemma 3.10. The satisfiability problem is coRE-hard for specifications (⊤, 𝜑) where 𝜑 is of the form ∀∃ * . ( * ).</p><p>Proof sketch. We encode the non-termination of deterministic Turning machines, which is coRE-hard. Each trace represents a configuration of the machine and the ∀∃ formula demands that each configuration encoded in trace 𝜋 has a successor configuration on some trace 𝜋 ′ . As the transitions of a TM can be checked locally, we can encode a successor configuration by comparing every three consecutive positions on 𝜋 and 𝜋 ′ , which is possible with a single globally. We give a detailed proof in Appendix A. □</p><p>This completes the proof of Theorem 3.7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Temporal Safety with Functional Specifications</head><p>We now investigate satisfiability for the combination of temporally safe HyperLTL formulas and LTL properties. If the LTL specification is safety, we can simply merge the trace property with the temporally safe hyperproperty, maintaining the applicability of Theorem 3.7. The situation changes if we allow non-safety trace properties.</p><p>Theorem 3.11. The satisfiability problem is Σ 1 1 -complete for specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃ * . . Proof sketch. Membership in Σ 1  1 follows from <ref type="bibr" target="#b23">[24]</ref>. For hardness, we encode recurring computations of nondeterministic two-counter machines. We represent each configuration by encoding the current instruction and two atomic propositions c 1 , c 2 that hold exactly once, i.e., counter 𝑥 has value 𝑣 if c 𝑥 occurs in the 𝑣th position. To ensure a recurring computation, we add a third counter 𝑡 that decreases in each step. When it reaches 0, the trace must encode the initial instruction, at which point 𝑡 is reset to any value. The key idea of the proof is that each trace in the model represents two consecutive configurations, which are encoded over disjoint copies of AP (for 𝑖 ∈ {1, 2}, AP 𝑖 = {𝑎 𝑖 | 𝑎 ∈ AP}). In LTL, we can express that the second configuration encoded in a trace is a successor of the first configuration in that trace. Furthermore, we express in LTL that the value of 𝑡 either decreases or the initial instruction is executed. In the HyperLTL property we ensure the existence of the initial configuration, and state that for each trace 𝜋, there exist a 𝜋 ′ such that the second configuration on 𝜋 equals the first on 𝜋 ′ . We can express the latter as</p><formula xml:id="formula_12">∀𝜋∃𝜋 ′ . 𝑎 ∈AP 𝑎 2 𝜋 ↔ 𝑎 1 𝜋 ′ .</formula><p>The resulting specification is satisfiable if and only if the machine has a recurring computation. We give a detailed proof in Appendix A. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Propositional Hyperproperties and Invariants</head><p>As we have seen, with arbitrary LTL properties present, a single operator suffices to jump to Σ 1 1 . This leaves hyperproperties expressed using only s as the only sub-analytical fragment. We settle the precise complexity of the resulting problem to be NEXPTIME-complete.</p><p>Theorem 3.12. The satisfiability problem is NEXPTIME-complete for specifications (𝜓, 𝜑) where 𝜑 is of the form 𝑄 * . * . Hardness holds already for 𝜓 = ⊤, a ∀ * ∃ * prefix, and no s.</p><p>Proof sketch. To show containment, we nondeterministically guess a set of finite traces 𝑀 ⊆ Σ 𝑘 , where 𝑘 is the number of operators in the formula. We then verify that each trace in 𝑀 can be extended to one satisfying 𝜓 and that 𝑀 is a model of the hyperproperty. For the lower bound, we reduce the acceptance of an exponential-time bounded nondeterministic Turing machine to a HyperLTL formula. Our encoding is a ∀ * ∃ * -formula, which does not contain any temporal operators (not even ) and no trace property. Each trace in our model encodes a piece of information (𝑠, 𝑝, 𝛾, 𝑞), where 𝑠, 𝑝 ∈ N, 𝛾 is a tape symbol of the TM, and 𝑞 either a state of the TM or ⊥. The tuple (𝑠, 𝑝, 𝑡, 𝑞) encodes that in time-step 𝑠 and at position 𝑝, the tape content is 𝛾, and either the head is at position 𝑝 and the machine is in state 𝑞, or the head is not at position 𝑝 (if 𝑞 = ⊥). As the TM is time (and thus space) bounded, 𝑠 and 𝑝 are bound by 2 𝑛 for some 𝑛. We show that we can express in HyperLTL that the information encoded in a given model defines a valid accepting run of the TM. The resulting formula is satisfiable iff TM has an accepting computation. As we can never refer to all exponentially many positions explicitly, we use ∀ * ∃ * formulas to encode a counter that references all positions. We give a formal proof in the Appendix A.</p><p>□ We note that HyperLTL without temporal operators has a strong connection to quantified boolean formulas (QBF), the validity of which is a standard PSPACE-complete problem <ref type="bibr" target="#b40">[40]</ref>. In contrast to QBF, where the quantifier structure spans the polynomial hierarchy, our proof shows that in Hyper-LTL, the ∀ * ∃ * fragment suffices to show NEXPTIME-hardness (refuting a conjecture in <ref type="bibr" target="#b32">[32]</ref> that temporal-operator-free HyperLTL is equivalent to QBF). The reason is that Hyper-LTL satisfiability asks for the existence of some model for which the formula holds (which is related to the more general second-order QBF problem <ref type="bibr" target="#b31">[31]</ref>).</p><p>If we forgo the additional trace property, we can also show the following lemma. Hardness already holds if we disallow propositional formulas outside of the . Lemma 3.13. The satisfiability problem is NEXPTIME-complete for specifications (⊤, 𝜑) where 𝜑 is of the form ∀ * ∃ * . . Proof. A property 𝜑 = ∀ 𝑛 ∃ 𝑚 . ( 𝜙) ∧ 𝜙 ′ (where 𝜙, 𝜙 ′ do not contain any temporal operators) is satisfiable iff ∀ 𝑛 ∃ 𝑚 . 𝜙 ∧𝜙 ′ is satisfiable. The result then follows using Theorem 3.12. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Temporal Liveness</head><p>The natural counterparts of safety properties are liveness properties, which postulate that "something good happens eventually". Similar to the case of hypersafety, hyperliveness as a fragment is not well-suited when studying satisfiability: any hyperliveness property is, by definition, satisfiable. Analogously to our study of temporal safety, we instead study HyperLTL properties whose body is a liveness property. We examine the temporal liveness fragment following the structure of Section 3 and point out analogous results wherever possible. As in Section 3, we first examine the entire class of temporal liveness and then gradually restrict this class to obtain new decidability results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hyperliveness and Temporal Liveness</head><p>As opposed to the safety case (cf. Proposition 3.6), temporal liveness and hyperliveness are incomparable. In temporal liveness, we can easily express falsity via ∀𝜋∀𝜋 ′ . (𝑎 𝜋 ∧ ¬𝑎 𝜋 ′ ), which is not hyperliveness. Conversely, the property ∀𝜋∃𝜋 ′ . (𝑎 𝜋 ↮ 𝑎 𝜋 ′ ) is hyperliveness (as we can always add more witness traces) but not expressible in temporal liveness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">General Temporal Liveness</head><p>Analogous to Theorem 3.7, we consider the full fragment of temporal liveness. Different from the fragment of temporal safety, the class of temporal liveness is already Σ 1 1 -hard. Theorem 4.2. The satisfiability problem is Σ 1  1 -hard for ∀∃ * temporal liveness HyperLTL formulas.</p><p>To prove Theorem 4.2, we show a stronger result: we can effectively reduce every ∀ * ∃ * HyperLTL property to an equisatisfiable temporal liveness property.</p><p>Theorem 4.3. Let (𝜓, 𝜑) be a specification where 𝜑 is of the form ∀ 𝑛 ∃ 𝑚 . 𝜙, and 𝜓 and 𝜙 are arbitrary but satisfiable LTL formulas. Then there is an effectively computable specification (𝜓 ′ , 𝜑 ′ ) such that 𝜓 ′ is an LTL liveness property, 𝜑 ′ is a ∀ 𝑛 ∃ 𝑚 temporal liveness property, and (𝜓, 𝜑) and (𝜓 ′ , 𝜑 ′ ) are equisatisfiable.</p><p>Proof. The idea is to move the start position of the formula under a operator. We introduce a fresh atomic proposition † and ensure that all traces satisfy the liveness property ( † ∧ ¬ †). The unique position where † ∧ ¬ † holds (the last time that † is true) is then the "start position" to evaluate the formula. Let 𝜑 = 𝑄 * . 𝜙 where 𝑄 * = ∀𝜋 1 . . . 𝜋 𝑛 ∃𝜋 𝑛+1 . . . 𝜋 𝑛+𝑚 is the quantifier prefix of 𝜑. Define</p><formula xml:id="formula_13">𝜑 ′ 𝑄 * . 𝑛+𝑚 𝑖=1 † 𝜋 𝑖 ∧ 𝑛+𝑚 𝑖=1 ¬ † 𝜋 𝑖 ∧ 𝜙</formula><p>In similar fashion, we define 𝜓 ′ ( † ∧ ( ¬ †) ∧𝜓 ). It is easy to see that both the LTL body of 𝜑 ′ and 𝜓 ′ are liveness properties. Here it is crucial that we assumed that 𝜓 and 𝜙 are satisfiable.</p><p>We now claim that (𝜓, 𝜑) is satisfiable if and only if (𝜓 ′ 𝜑 ′ ) is satisfiable. For the first direction, assume that 𝑇 is a model for (𝜓, 𝜑). The model with † added to the first step of all traces satisfies (𝜓 ′ , 𝜑 ′ ). For the other direction, let 𝑇 be a model of (𝜓 ′ , 𝜑 ′ ). We assume w.l.o.g. that there is no subset 𝑇 ′ ⊊ 𝑇 such that 𝑇 ′ is also a model for (𝜓 ′ , 𝜑 ′ ). The property enforces that for any traces 𝑡 1 , . . . , 𝑡 𝑛+𝑚 , where 𝑡 𝑛+1 , . . . , 𝑡 𝑛+𝑚 are the witness traces for 𝑡 1 , . . . , 𝑡 𝑚 , † holds for the last time at a common time point. As 𝑇 ′ is minimal, every trace serves as a witness for some other traces. Therefore the last position where † holds is the same for all traces in 𝑇 ′ . Let 𝑖 be this position. Then {𝑡 [𝑖, ∞] | 𝑡 ∈ 𝑇 ′ } is a model of (𝜓, 𝜑). □ By Theorem 3.11, satisfiability of ∀∃ * HyperLTL is Σ 1 1hard (note that we transform any specification (𝜓, ∀ 𝑛 ∃ 𝑚 . 𝜙) with 𝑛 ≥ 1 into a specification (⊤, ∀ 𝑛 ∃ 𝑚 . 𝜙 ′ ) by integrating the trace property into the body of the HyperLTL formula). Theorem 4.3 thus gives a proof of Theorem 4.2. More generally, every HyperLTL formula can be effectively reduced to an equisatisfiable ∀<ref type="foot" target="#foot_1">2</ref> ∃ * HyperLTL formula <ref type="bibr" target="#b32">[32,</ref><ref type="bibr">Thm. 5]</ref>, so Theorem 4.3 shows that deciding temporal liveness can be used to decide full HyperLTL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Simple Liveness Properties</head><p>The general class of temporal liveness thus does not define an "easier" fragment of HyperLTL. As in the case of safety properties, we study the precise boundary at which the jump to Σ 1 1 occurs by restricting to simpler forms of temporal liveness. Analogously to the case of invariants (described with ), we study eventualities ( ). Proof sketch. We collapse all universal quantifiers in 𝜑 and thereby reduce satisfiability of (⊤, 𝜑) to boolean satisfiability. We give a detailed proof in Appendix B. □ Note that if we allow properties where propositional formulas occur outside of the operators, the complexity jumps back to NEXPTIME (see Lemma B.1). It is worth to contrast this result with the analogous findings for simple temporally safe formulas. <ref type="bibr">Lemma 4.4</ref> shows that when adding an operator around a propositional formula, the problem drops from NEXPTIME (Theorem 3.12) to NP. This is in contrast to adding operators, which remains NEXPTIME-complete (Lemma 3.13). Invariants with nested and propositional conjuncts are undecidable (Lemma 3.10), whereas eventualities with nested operators and propositional conjuncts remain decidable (see Lemma B.1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Eventualities with Functional Specifications</head><p>Surprisingly, the sharp contrast between and continues if we add functional specifications as LTL trace properties. For , the resulting problem directly jumps to full analytical hardness (cf. Theorem 3.11). For , we now show that the problem remains decidable. Our result reads as follows.</p><p>Theorem 4.5. The satisfiability problem is decidable for specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃ * . ( * ).</p><p>This result is interesting for two reasons. First, it outlines the precise difference between and . Second, it defines a new decidable class that contains many properties of interest. In particular, formulas of the fragment can enforce infinite models. 2 For example, the specification in Example 1.1 falls in this newly identified fragment.</p><p>The remainder of this subsection provides a proof for Theorem 4.5. We introduce necessary concepts along the way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Eliminating</head><p>Nexts. We first show how to eliminate the operators in 𝜑.</p><p>Lemma 4.6. Let (𝜓, 𝜑) be a specification where 𝜑 is of the form ∀ 𝑛 ∃ 𝑚 . ( * ). There exists an effectively computable specification (𝜓 ′ , 𝜑 ′ ) where 𝜑 ′ is the of the form ∀ 𝑛 ∃ 𝑚 . such that (𝜓, 𝜑) and (𝜓 ′ , 𝜑 ′ ) are equisatisfiable.</p><p>Proof sketch. Let 𝜑 = ∀ 𝑛 ∃ 𝑚 . ( 𝜙) ∧ 𝜙 ′ . We eliminate operators in 𝜙 by letting traces range over tuples. Instead of considering traces in Σ 𝜔 , we consider traces in (Σ 𝑘 ) 𝜔 , where 𝑘 is the lookahead needed to evaluate 𝜙 (which is upper bounded by the number of s in 𝜙). For each trace 𝑡 ∈ Σ 𝜔 , we define 𝑡 ′ ∈ (Σ 𝑘 ) 𝜔 by 𝑡 ′ (𝑖) (𝑡 (𝑖), 𝑡 (𝑖 + 1), . . . , 𝑡 (𝑖 + 𝑘)). This reduces the evaluation of 𝜙 to a formula without s. We also modify the LTL formula (which is allowed to contain operators) to assert that the tuples in each tuple trace are consistent, i.e., for each step 𝑖 if 𝑡 (𝑖) = (𝑙 1 , . . . , 𝑙 𝑘 ) then 𝑡 (𝑖 + 1) = (𝑙 2 , . . . , 𝑙 𝑘 , 𝑙 𝑘+1 ). A detailed proof can be found in Appendix B. □ Using Lemma 4.6, we can assume that in Theorem 4.5, the HyperLTL formula 𝜑 contains a single as the only temporal operator. For now, we make two further assumptions: First, we assume that 𝜑 contains only a single ∃ quantifier, and, second, we assume that there are no additional propositional conjuncts outside the . So let 𝜑 = ∀𝜋∃𝜋 ′ . 𝜙 where 𝜙 contains no temporal operators. We begin by translating the trace property 𝜓 into a Büchi automaton. Definition 4.7. A state-labeled Büchi automaton over alphabet Σ is a tuple A = (𝑄, 𝑄 0 , 𝛿, 𝐹, 𝐿), where 𝑄 is a finite set of states, 𝑄 0 ⊆ 𝑄 the initial states, 𝛿 ⊆ 𝑄 × 𝑄 the transition relation, 𝐹 ⊆ 𝑄 the set of accepting states, and 𝐿 : 𝑄 → Σ a state labeling function. An accepting run 𝑟 of A is an infinite sequence 𝑟 ∈ 𝑄 𝜔 such that 1) 𝑟 (0) ∈ 𝑄 0 , 2) (𝑟 (𝑖), 𝑟 (𝑖 + 1)) ∈ 𝛿 for every 𝑖, and 3) 𝑟 (𝑖) ∈ 𝐹 for infinitely many 𝑖. The trace 𝐿(𝑟 ) ∈ Σ 𝜔 associated to a run is defined by 𝐿(𝑟 ) (𝑖) 𝐿(𝑟 (𝑖)). For a set 𝑋 ⊆ 𝑄, we define Step A (𝑋 ) {𝑞 ∈ 𝑄 | ∃𝑞 ′ ∈ 𝑋 . (𝑞 ′ , 𝑞) ∈ 𝛿 } as all states reachable in one step from 𝑋 and Reach A (𝑛) as all states reachable in 𝑛 steps from a state in 𝑄 0 .</p><p>Note that we use state-labeled automata (as opposed to transition-labeled automata) to simplify our construction. Let A 𝜓 = (𝑄 𝜓 , 𝑄 0,𝜓 , 𝛿 𝜓 , 𝐹 𝜓 , 𝐿 𝜓 ) be a (state-labeled) Büchi automaton over 2 AP accepting 𝜓 <ref type="bibr" target="#b41">[41]</ref>. A state 𝑞 ∈ 𝑄 𝜓 is nonempty if there exists an accepting infinite run starting in 𝑞. W.l.o.g., we assume that A 𝜓 only includes non-empty states, as we can remove all empty states without changing the language of A 𝜓 . Detecting if a state is non-empty can be done easily using, e.g., nested depth-first search.</p><p>4.4.2 Models for ∀∃. Intuitively, our decidability result can be derived as follows. Assume we had a model 𝑇 of (𝜓, 𝜑). Let 𝑅 ⊆ 𝑄 𝜔 𝜓 be a set of accepting runs of A 𝜓 associated to 𝑇 , i.e., 𝑇 = {𝐿 𝜓 (𝑟 ) | 𝑟 ∈ 𝑅}. As we consider a ∀∃ formula, we As an intermediate step, we describe an infinite-state Büchi system (a Büchi automaton without labels) that guesses such a "linear" model of (𝜓, 𝜑). The states of the system are triples (𝑞, 𝑏, 𝑛), where 𝑞 ∈ 𝑄 𝜓 is a state in A 𝜓 , 𝑏 ∈ {⇛, ⇚} gives a running direction, and 𝑛 ∈ N. Each state (𝑞, 𝑏, 𝑛) additionally satisfies 𝑞 ∈ Reach A 𝜓 (𝑛). The initial states of the system are all states (𝑞 0 , ⇛, 0) with 𝑞 0 ∈ 𝑄 0,𝜓 . In each step, the system has three options: it can either run forwards, run backwards, or claim to have found a witness. In a forward step (F-step), the automaton moves from (𝑞, ⇛, 𝑛) to (𝑞 ′ , ⇛, 𝑛 + 1), where (𝑞, 𝑞 ′ ) ∈ 𝛿 𝜓 . Similarly, in a backwards step (B-step), it runs from (𝑞, ⇚, 𝑛 + 1) to (𝑞 ′ , ⇚, 𝑛), where (𝑞 ′ , 𝑞) ∈ 𝛿 𝜓 . Note that in the backwards step, we always ensure that 𝑞 ′ ∈ Reach A 𝜓 (𝑛). Lastly, the system can claim to have found a witness (W-step): if in state (𝑞, 𝑏, 𝑛), it can select any 𝑞 ′ ∈ Reach A 𝜓 (𝑛) such that 𝐿 𝜓 (𝑞) × 𝐿 𝜓 (𝑞 ′ ) |= 𝜙. Afterwards, the system continues in state (𝑞 ′ , 𝑏 ′ , 𝑛), where 𝑏 ′ ∈ {⇛, ⇚} is chosen nondeterministically. Call the resulting system S. We claim the following. Lemma 4.8. S has an infinite run that uses W-steps infinitely often if and only if (𝜓, 𝜑) is satisfiable.</p><formula xml:id="formula_14">𝑟 0 𝑟 1 𝑟 2 𝑟 3 𝑟 4 • • • F W F F W B W B B W Figure 1.</formula><p>Proof. We sketch both directions. For the "if" direction, assume there is a model for (𝜓, 𝜑). We can arrange a subset of this model as depicted in Figure <ref type="figure">1</ref>. Let 𝑟 0 , 𝑟 1 , . . . , with 𝑟 𝑖 ∈ 𝑄 𝜔 𝜓 be the sequence of accepting runs in A 𝜓 and 𝑛 𝑖 the witness points. Traversing the graph as shown by the small blue states in Figure <ref type="figure">1</ref> creates a run of S. We start in (𝑟 0 (0), ⇛, 0) and move forward (using F-steps) until the counter reaches 𝑛 0 . At this point, we take the W-step from (𝑟 0 (𝑛 0 ), ⇛, 𝑛 0 ) to (𝑟 1 (𝑛 0 ), 𝑏, 𝑛 0 ) and run towards counter value 𝑛 1 . If 𝑛 1 &lt; 𝑛 0 , we set the running direction 𝑏 to ⇚ and otherwise to ⇛. We continue this procedure to construct an infinite run. For the example situation depicted in Figure <ref type="figure">1</ref>, the resulting run would start with:</p><formula xml:id="formula_15">(𝑟 0 (0), ⇛, 0) F - → (𝑟 0 (1), ⇛, 1) W --→ (𝑟 1 (1), ⇛, 1) F - → (𝑟 1 (2), ⇛, 2) F - → (𝑟 1 (3), ⇛, 3) W --→ (𝑟 2 (3), ⇚, 3) B -→ (𝑟 2 (2), ⇚, 2) W --→ • • •</formula><p>The resulting sequence is a run of S and uses W-steps infinitely many times.</p><p>For the "only if" direction, assume an infinite run 𝑟 = (𝑞 0 , 𝑏 0 , 𝑚 0 ) → (𝑞 1 , 𝑏 1 , 𝑚 1 ) → • • • of S. We split 𝑟 into infinitely many finite segments 𝑥 0 , 𝑥 1 , . . . , by splitting each time 𝑟 takes a W-step. In the example run above we would get 𝑥 0 = (𝑟 0 (0), 0) (𝑟 0 (1), 1), Büchi pushdown system has an accepting run <ref type="bibr" target="#b9">[10]</ref>.</p><formula xml:id="formula_16">𝑥 1 = (𝑟 1 (1), 1) (𝑟 1 (2), 2) (𝑟 1 (3), 3), . . ..</formula><p>We replace S with a pushdown system P. Conceptually, we represent a state (𝑞, 𝑏, 𝑛) in S by the pushdown configuration with state (𝑞, 𝑏) and stack content [Reach A 𝜓 (𝑛), . . . , Reach A 𝜓 (0)], i.e., the length of the stack is 𝑛 + 1 and the 𝑖th element are all states reachable in 𝑖 steps. The states in the pushdown system thus have the form (𝑞, 𝑏) with 𝑞 ∈ 𝑄 𝜓 , 𝑏 ∈ {⇛, ⇚} and the stack alphabet is 2 𝑄 𝜓 . The initial stack symbol is 𝛾 0 𝑄 0,𝜓 and the initial states are {(𝑞 0 , ⇛) | 𝑞 0 ∈ 𝑄 0,𝜓 }. The transitions are of the following form:</p><formula xml:id="formula_17">(𝑞, 𝑞 ′ ) ∈ 𝛿 𝜓 (F) (𝑞, ⇛), [𝐴] ⇝ (𝑞 ′ , ⇛), [Step A 𝜓 (𝐴), 𝐴] 𝑞 ′ ∈ 𝐴 2 (𝑞 ′ , 𝑞) ∈ 𝛿 𝜓 (B) (𝑞, ⇚), [𝐴 1 , 𝐴 2 ] ⇝ (𝑞 ′ , ⇚), [𝐴 2 ] 𝑞 ′ ∈ 𝐴 𝐿 𝜓 (𝑞) × 𝐿 𝜓 (𝑞 ′ ) |= 𝜙 𝑏, 𝑏 ′ ∈ {⇛, ⇚} (W) (𝑞, 𝑏), [𝐴] ⇝ (𝑞 ′ , 𝑏 ′ ), [𝐴]</formula><p>Note the close correspondence with the transitions in S. In particular, in F-steps, we compute Reach A 𝜓 (𝑛 + Lastly, we can easily translate a Büchi pushdown system with transition-based acceptance (as in P) to state-based acceptance (as in Definition 4.9). Using the decidability of pushdown systems <ref type="bibr" target="#b9">[10]</ref>, we thus get that the satisfiability of (𝜓, 𝜑) is decidable. Note that our proof gives an elementary upper bound of 2EXPTIME (for ∀∃ properties). <ref type="foot" target="#foot_2">3</ref>4.4.4 Propositional Conjuncts and ∀∃ * . We can now lift the two assumptions we made earlier. As a first extension, we modify our construction to also support formulas of the form ∀𝜋∃𝜋 ′ .( 𝜙) ∧ 𝜙 ′ . To do so, we keep track of the first state of the run we are currently considering. In a W-step, we then only select a witness state 𝑞 ′ that stems from an initial state which satisfies the propositional requirement 𝜙 ′ when combined with the initial state of the current run. We can access the set of all such states by keeping track of the set of states reachable from every individual state (by changing the stack alphabet to functions 𝑄 𝜓 → 2 𝑄 𝜓 ).</p><p>As a second extension, we can show decidability for a ∀∃ 𝑚 prefix by moving to alternating Büchi pushdown systems (defined as expected, see <ref type="bibr" target="#b9">[10]</ref> for details). For ∀∃ 𝑚 , we can no longer arrange the traces of a model in a linear sequence (as depicted in Figure <ref type="figure">1</ref>) and instead use 𝑚-ary trees labeled by traces such that the children of a node correspond to witness traces of that trace. In a W-step from a state (𝑞, 𝑏), we now select 𝑚 states 𝑞 1 , . . . , 𝑞 𝑚 (whereas we previously picked only 𝑞 ′ ) such that 𝑞 together with 𝑞 1 , . . . , 𝑞 𝑚 satisfy 𝜙. Afterwards, we need to find a new witnesses for each of the 𝑞 𝑖 . We accomplish this by introducing a universal transition that branches into states (𝑞 𝑖 , 𝑏 𝑖 ) for each 1 ≤ 𝑖 ≤ 𝑚 (leaving the stack unchanged as before). The F and B step stay purely nondeterministic. The resulting alternating pushdown system has an accepting run (which now has the form of a tree) iff (𝜓, 𝜑) is satisfiable. As emptiness of alternating pushdown systems is still decidable (albeit only in exponential time) <ref type="bibr" target="#b9">[10]</ref>, we get a proof of Theorem 4.5 for the full ∀∃ * -fragment. For the ∀∃ * -fragment, our proof gives an elementary upper bound of 3EXPTIME.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Conjunctions of Eventualities</head><p>We show that Theorem 4.5 is tight in the sense that already a conjunction of eventualities combined with an arbitrary trace property is undecidable (and even Σ 1 1 -hard). Theorem 4.11. The satisfiability problem is Σ 1  1 -hard for specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃ * . ∧ ∧ .</p><p>Proof. We encode the problem of whether a nondeterministic 2CM with instructions 𝑙 1 , . . . , 𝑙 𝑛 has a recurring computation <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23]</ref>.</p><formula xml:id="formula_18">Let AP = 𝑥 ∈ {1,2,𝑡 } { 𝑥 , ■ 𝑥 , isZero 𝑥 } ∪ {l 1 , . . . , l 𝑛 }.</formula><p>Each trace encodes a configuration of the machine as follows. The current value of counter 𝑥 ∈ {1, 2} is encoded as a trace in ∅ * { 𝑥 }{■ 𝑥 }∅ 𝜔 such that the (unique) step at which 𝑥 holds indicates the current value of 𝑐 𝑥 . We later use proposition ■ 𝑥 (which always holds the step after 𝑥 ) to encode the update of the counter. The proposition isZero 𝑥 holds exactly if the counter is zero. The current instruction is encoded by propositions {l 1 , . . . , l 𝑛 }, of which exactly one holds globally along a trace. Finally, to ensure a recurring computation, we use a third counter 𝑡, which is encoded analogously to the counters above and counts down the steps to the next visit to 𝑙 1 . It is easy to see that we can encode the validity of a configuration in an LTL formula 𝜓 . For 𝑥 ∈ {1, 2, 𝑡 } we ensure a valid counter via</p><formula xml:id="formula_19">(¬ 𝑥 ∧¬■ 𝑥 ) U ( 𝑥 ∧ ¬■ 𝑥 ) ∧ (■ 𝑥 ∧ ¬ 𝑥 ) ∧ (¬ 𝑥 ∧¬■ 𝑥 )</formula><p>and ensure correct placement of isZero 𝑥 by ( isZero 𝑥 ) ∨ ( ¬isZero 𝑥 ) together with isZero 𝑥 ↔ 𝑥 . Finally, we assert that the propositions {l 1 , . . . , l 𝑛 } are set correctly via 𝑖 l 𝑖 ∧ 𝑗≠𝑖 ¬l 𝑗 . In the hyperproperty, we encode that there exists a trace representing the initial configuration as follows (note that we allow counter 𝑡 to have any value):</p><formula xml:id="formula_20">𝜑 init ∃𝜋 .(l 1 ) 𝜋 ∧ (isZero 1 ) 𝜋 ∧ (isZero 2 ) 𝜋</formula><p>Lastly, we express that each trace has a successor. For each instruction 𝑙 𝑖 , we write 𝑐 (𝑙 𝑖 ) ∈ {1, 2} for the counter that is changed or tested in instruction 𝑙 𝑖 . We define 1 2 and 2 1 for the other counter. We then define</p><formula xml:id="formula_21">𝜑 ∀𝜋∃𝜋 ′ . 𝑖 ∈ {1,...,𝑛 } (l 𝑖 ) 𝜋 ∧ exec(𝑙 𝑖 ) ∧ 𝑖 ∈ {1,...,𝑛 } (l 𝑖 ) 𝜋 ∧ ( 𝑐 (𝑙 𝑖 ) ) 𝜋 ∧ ( 𝑐 (𝑙 𝑖 ) ) 𝜋 ′ ∧ (isZero 𝑡 ) 𝜋 ∧ (l 1 ) 𝜋 ∨ ( 𝑡 ) 𝜋 ∧ (■ 𝑡 ) 𝜋 ′ .</formula><p>Here, exec(𝑙 𝑖 ) denotes that the action or test of instruction 𝑙 𝑖 is performed on 𝑐 (𝑙 𝑖 ). For example, if 𝑙 𝑖 = 𝑐 𝑥 𝑐 𝑥 + 1; goto{𝑙 𝑗 , 𝑙 𝑘 } , we define exec(𝑙 𝑖 ) as</p><formula xml:id="formula_22">(l 𝑗 ) 𝜋 ′ ∨ (l 𝑘 ) 𝜋 ′ ∧ (■ 𝑥 ) 𝜋 ∧ ( 𝑥 ) 𝜋 ′ .</formula><p>Note that (■ 𝑥 ) 𝜋 ∧ ( 𝑥 ) 𝜋 ′ encodes that the counter 𝑥 is increased. For a decrement operation, we can replace this with (■ 𝑥 ) 𝜋 ′ ∧ ( 𝑥 ) 𝜋 . If 𝑙 𝑖 = if 𝑐 𝑥 = 0 then goto 𝑙 𝑗 else goto 𝑙 𝑘 , we define exec(𝑙 𝑖 ) as</p><formula xml:id="formula_23">( 𝑥 ) 𝜋 ∧ ( 𝑥 ) 𝜋 ′ ∧ (isZero 𝑥 ) 𝜋 → (l 𝑗 ) 𝜋 ′ ∧ ¬(isZero 𝑥 ) 𝜋 → (l 𝑘 ) 𝜋 ′ .</formula><p>In 𝜑, the first conjunct thus encodes that the counter 𝑐 (𝑙 𝑖 ) is updated and/or tested as required by 𝑙 𝑖 . The second conjunct states that the counter that is not involved in 𝑙 𝑖 is left unchanged. As the current instruction is set consistently along a trace, both eventualities refer to the same instruction. Finally, the third conjunct ensures that the counter 𝑡 either decreases or is already zero, at which point the current instruction is 𝑙 1 . In case the 𝑡-counter is zero, it can be reset to any value on 𝜋 ′ . This ensures a recurring computation of the machine. It is easy to see that (𝜓, 𝜑 init ∧ 𝜑) is satisfiable iff the 2CM has a recurring computation (note that 𝜑 init ∧ 𝜑 is a ∀∃ 2 -formula). □ While Theorem 4.11 requires three conjunctions of eventualities to show Σ 1 1 -hardness, already two eventualities suffice to show undecidability. To do so, we can encode the nontermination of a 2CM (avoiding the 𝑡 counter). This further underlines the tightness of Theorem 4.5.</p><p>Lemma 4.12. The satisfiability problem is undecidable for specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃ * . ∧ . Example 4.13. Using similar ideas as in Theorem 4.11, we can encode that a one-counter machine has an infinite computation with only a single eventuality (as we only need to ensure that the single counter is updated consistently). Combined with Theorem 4.5, we derive that we can decide the existence of an infinite computation in a one-counter machine. While this is long known (see, e.g., <ref type="bibr" target="#b28">[28]</ref>), it nevertheless emphasizes that our newly identified decidable class is broader than it seems at first glance. ◁</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Deterministic Liveness</head><p>Livness for trace properties (cf. Definition 2.1) and hyperliveness (cf. Definition 2.3) already imply that a property is satisfiable. As demonstrated by Theorem 4.2, the same does not hold for temporal liveness hyperproperties. We can, however, identify a fragment within temporal liveness for which the intuition that liveness implies satisfiability transfers to the realm of hyperproperties. We say an LTL property 𝜙 is a deterministic liveness property if it is a liveness property and can be recognized by a deterministic Büchi automaton.</p><p>Proposition 4.14. HyperLTL formulas of the form 𝜑 = ∀∃ * . 𝜙 where 𝜙 is a deterministic liveness property are always satisfiable and have a finite model.</p><p>Proof sketch. In a deterministic automaton describing a liveness property, any reachable state has a path to an accepting state. We use this to iteratively construct a model. The full proof can be found in Appendix B. □ Note that the same does not hold if we consider more than one universal quantifier. As an example, the formula ∀𝜋∀𝜋 ′ . (𝑎 𝜋 ∧ ¬𝑎 𝜋 ′ ) is unsatisfiable but (𝑎 𝜋 ∧ ¬𝑎 𝜋 ′ ) is a deterministic liveness property. If we consider deterministic liveness in combination with trace properties, we again obtain a jump to Σ 1 1 -hardness. Corollary 4.15. Satisfiability is Σ 1  1 -hard for specifications of the form (𝜓, 𝜑) where 𝜑 is of the form ∀∃ * . 𝜙 and 𝜙 is a deterministic liveness property.</p><p>Proof. Follows directly from Theorem 4.11 as conjunctions of eventualities are deterministic liveness. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Overview: Liveness vs Safety</head><p>Our results provide a clear picture of the (un)decidability boundaries within fragments of HyperLTL. In particular, our systematic study allows a direct comparison between temporal safety and temporal liveness. For the full fragment, temporal liveness already subsumes satisfiability of full HyperLTL, which contrasts strongly with the much cheaper (albeit still undecidable) problem for temporal safety. This changes if we consider simpler fragments. Here, the fragment is drastically better behaved in terms of complexity and even admits large decidable fragments for cases where the safety counterpart already exhibits full analytical hardness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Finding Largest Models</head><p>To complement the decidability results from the previous sections, we propose a new (incomplete) algorithm to detect (un)satisfiability of ∀∃ * HyperLTL formulas. So far, the only available algorithm checks for finite models of bounded size and then iteratively increases the bound <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">32]</ref>. Such an approach finds smallest models and cannot determine unsatisfiability. The key insight for our algorithm is that ∀∃ * formulas are closed under union, therefore, a formula 𝜑 is satisfiable iff there is a (unique) largest model satisfying 𝜑. To find such models algorithmically, we iteratively eliminate choices for the ∃ * quantifiers that admit no witness trace when chosen for the ∀ quantifier. Thereby, we do not only find largest models but can also detect unsatisfiability. Our incremental elimination is closely related to a recent algorithm used in the context of finite-trace properties (which was developed independently) <ref type="bibr" target="#b8">[9]</ref>.</p><p>For presentation reasons, we present the algorithm for ∀∃ formulas. Our implementation (see Section 6) supports full ∀∃ * properties.</p><p>Algorithm 1 Algorithm that searches for the largest model of a ∀∃ property. Initially, A is a Büchi automaton that accepts the body the HyperLTL property.</p><formula xml:id="formula_24">1: procedure findModel(A) 2: if L (A ∀ ) = ∅ then 3: return UNSAT; 4: if L (A ∃ ) ⊆ L (A ∀ ) then 5:</formula><p>return SAT, model: L (A ∀ ); 6:</p><formula xml:id="formula_25">A new A ∩ A ∀ 𝜋 ′ ; 7:</formula><p>findModel(A new );</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Algorithm</head><p>For a Büchi automaton A over AP 𝜋 ∪ AP 𝜋 ′ , we define A ∀ and A ∃ as the automata (over AP) that (existentially) project A on the alphabet AP 𝜋 and AP 𝜋 ′ , respectively. Now let a HyperLTL formula 𝜑 = ∀𝜋∃𝜋 ′ . 𝜙 be given and let A 𝜙 be an automaton over AP 𝜋 ∪ AP 𝜋 ′ accepting 𝜙. In particular, A ∀ 𝜙 accepts all words for which there exists a witness trace for the existential quantifier. Our algorithm is depicted in Algorithm 1. Initially, we call findModel(A 𝜙 ).</p><p>The first candidate is</p><formula xml:id="formula_26">A = A 𝜙 . If L (A ∀ ) = ∅, i.e.</formula><p>, no trace has a witness trace in A, 𝜑 is unsatisfiable. If all potential witness traces in L (A ∃ ) are contained in L (A ∀ ) (so they have a witness trace themself), 𝜑 is satisfiable and L (A ∀ ) is a model. If neither is the case, we refine A by removing all traces whose ∃ component is not in L (A ∀ ). We define A new as the intersection A ∩ A ∀ 𝜋 ′ where A ∀ 𝜋 ′ is A ∀ with the alphabet changed from AP to AP 𝜋 ′ . We can compute A new via a standard intersection construction on Büchi automata. Note that A new might again contain witness traces that themselves have no witness trace, so we recurse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Correctness</head><p>The algorithm maintains the following invariants. Lemma 5.1. In every iteration of the algorithm it holds that L (A new ) ⊆ L (A), and for any trace set𝑇 with𝑇 |= ∀𝜋∃𝜋 ′ . 𝜙, 𝑇 ⊆ L (A ∀ ).</p><p>Using Lemma 5.1 it is easy to see the following. Proposition 5.2. Given a formula 𝜑 = ∀𝜋∃𝜋 ′ . 𝜙, if Algorithm 1 terminates with UNSAT, the formula is unsatisfiable. If it terminates with SAT and model L (A ∀ ), then L (A ∀ ) is the unique largest model of 𝜑.</p><p>To generalize to ∀∃ * , we intersect the universal projection with each of the projections on existentially quantified positions. Models for ∀ * ∃ * -properties are, in general, not closed under union, so our algorithm does not extend beyond ∀∃ * .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Implementation and Experiments</head><p>We have implemented the algorithm described in Section 5 in a tool called LMHyper (short for Largest Model of Hy-perLTL). LMHyper reads both a ∀∃ * HyperLTL formula 𝜑 and Table <ref type="table">2</ref>. Comparison of LMHyper and MGHyper on 100 random formulas generated with randltl <ref type="bibr" target="#b16">[17]</ref>. Size refers to the size of the AST, 𝑝 is the percentage of solved formulas, 𝑡 the average time spent on solved cases in milliseconds, and #Iter is the average number of iterations (number of recursive calls) used by LMHyper. The timeout is set to 5sec. LTL formula 𝜓 and searches for an (un)satisfiability proof for (𝜓, 𝜑). Internally, we represent the current candidate as a generalized Büchi automaton and use spot <ref type="bibr" target="#b16">[17]</ref> to perform automata operations. The only other available tool for ∀∃ * HyperLTL satisfiability is MGHyper <ref type="bibr" target="#b19">[20]</ref>, which implements the incremental approach to find models of bounded size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MGHyper</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Random Benchmarks</head><p>We compare LMHyper against MGHyper on random formulas where we sample the LTL body of a formula using randltl <ref type="bibr" target="#b16">[17]</ref>. The results are given in Table <ref type="table">2</ref>. On our benchmarks, LMHyper usually takes longer than MGHyper but can handle a larger percentage of formulas. We observe that randomly generated HyperLTL formulas are, in most cases, satisfiable by a model with a single trace, as the atomic propositions are seldom shared between different trace variables. This explains the high success rate of MGHyper (see <ref type="bibr" target="#b19">[20]</ref>) even though MGHyper cannot prove unsatisfiability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Infinite and Large Models</head><p>We compiled a small number of more interesting properties that do not have single-trace models. Our results are depicted in Table <ref type="table" target="#tab_8">3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have studied the satisfiability problem for ∀ * ∃ * Hyper-LTL formulas in combination with LTL formulas describing functional behavior. To obtain results below the general Σ 1  1 complexity of HyperLTL, we have focused on simpler hyperproperties belonging to the classes of temporal safety and temporal liveness as well as fragments thereof. We have shown that temporal safety is an expressive class that is very well suited for satisfiability studies and enjoys coRE-completeness. In combination with general LTL properties, already very simple formulas like invariants cause Σ 1  1 -completeness. The temporal liveness class, on the other hand, is Σ 1 1 -complete in general but contains non-trivial fragments that are decidable, even in combination with arbitrary LTL formulas.</p><p>We have shown that functional specifications given in LTL play a significant role in the undecidability of general hyperproperties. The main open question for future work is whether further decidable fragments can be found by restricting the operator structure of the functional specification. change in the position of the old head.</p><formula xml:id="formula_27">𝜓 LxorR (¬ℎ 𝜋 ∧ (¬ℎ 𝜋 ∧ ¬ℎ 𝜋 )) → 𝑎 ∈AP 𝑎 𝜋 ↔ 𝑎 𝜋 ′ ∧ ℎ 𝜋 → ¬ℎ 𝜋 ′ ∧ (ℎ 𝜋 ′ ⊕ ℎ 𝜋 ′ ) ∧ 𝑎 ∈Γ (𝑎 𝜋 ↔ 𝑎 𝜋 ′ ) ∧ (𝑎 𝜋 ↔ 𝑎 𝜋 ′ )</formula><p>Now we translate each transition (𝑞, 𝑎), (𝑞 ′ , 𝑎 ′ , 𝐿) ∈ 𝛿 as follows. If the head moves right instead of left, we change the position of the operator accordingly.</p><formula xml:id="formula_28">𝜓 trans 1 (ℎ 𝜋 ∧ 𝑎 𝜋 ∧ 𝑞 𝜋 ) → ℎ 𝜋 ′ ∧ 𝑞 ′ 𝜋 ′ ∧ 𝑎 ′ 𝜋 ′</formula><p>The final transition formula is the following:</p><formula xml:id="formula_29">∀𝜋 . ∃𝜋 ′ . (𝜓 LxorR ∧ (𝜓 trans 1 ∨ 𝜓 trans 2 ∨ • • • ))</formula><p>We only encode transitions where 𝑞 ′ ∉ 𝐹 , i.e. only those transitions that do not make the TM halt. The conjunction of the above formulas can be easily transformed into a ∀∃ 2 formula with a single and only non-nested operators in the scope of . Now, the TM has an infinite non-halting run iff the conjunction of the above formulas has a satisfying model. The trace set might not only contain the witnessing run but also non-valid configurations or non-reachable configurations, which we can just ignore. □ Theorem 3.11. The satisfiability problem is Σ 1 1 -complete for specifications (𝜓, 𝜑) where 𝜑 is of the form ∀∃ * . . Proof. Membership in Σ 1  1 follows from <ref type="bibr" target="#b23">[24]</ref>. We reduce from the recurring computation problem of nondeterministic twocounter machines. The key idea is to use LTL formulas over pairs of encoded configurations and use the hyperproperty only to ensure that every second component matches with some first component of another trace. We thus set AP = AP 1 ∪ AP 2 and each AP 𝑖 = {l 𝑖 1 , . . . , l 𝑖 𝑛 , c 𝑖 1 , c 𝑖 2 , t 𝑖 }. The counter values for counter 𝑐 1 , 𝑐 2 are encoded by two atomic propositions c 1 and c 2 which hold exactly once, i.e., counter 𝑥 has value 𝑣 if c 𝑥 occurs in the 𝑣th position. We use 𝑛 atomic propositions for the instructions, and require that in the first position, exactly one instruction label holds. Note that all of the above requirements for a valid configuration are easily expressible in LTL. To ensure that the computation visits the initial instruction 𝑙 1 infinitely often, we use a proposition t, which must also hold exactly once and decreases with every computation step. When 𝑡 is in position 0, l 1 must hold. We encode this requirement as l 1  1 ∨ (t 2 ↔ t 1 ). We also encode that each trace denotes an update step of the 2CM. For example instruction 𝑙 𝑖 = 𝑐 1 𝑐 1 + 1 goto {𝑙 𝑗 , 𝑙 𝑘 } can be encoded as:</p><formula xml:id="formula_30">l 1 𝑖 → ((c 1 2 ↔ c 2 2 ) ∧ (c 1 1 ↔ c 2<label>1</label></formula><p>)) ∧ (l 2 𝑗 ∨ l 2 𝑘 ) Decrement instructions are analogous. Instructions of the form 𝑙 𝑖 = if 𝑐 1 = 0 then goto 𝑙 𝑗 else goto 𝑙 𝑘 can be encoded as.</p><formula xml:id="formula_31">l 1 𝑖 → (c 1 1 → l 2 𝑗 ) ∧ (¬c 1 1 → l 2 𝑘 ) ∧ 𝑥 ∈1,2 (c 1 𝑥 ↔ c 2 𝑥 )</formula><p>We then take the conjunction over the resulting formulas for each instruction.</p><p>What is left to state is the hyperproperty 𝜑, which matches second components to first components. To show hardness we reduce the acceptance of a timebounded nondeterministic Turing machine on the empty word to a HyperLTL formula (our construction does not require any temporal operators, not even s). Consequently, only the first position of each trace is relevant. Let 𝑇 = (𝑄, 𝑄 0 , Γ, 𝛿, 𝐹 ) be a exponential time-bounded nondeterministic TM. As our formula uses no s, only the first position is relevant so we can see each trace as a propositional evaluation over AP. The idea is that each trace in the model encodes a piece of information of an accepting run of 𝑇 . Such a piece of information is a tuple (𝑠, 𝑝, 𝛾, 𝑞) where 𝑠, 𝑝 ∈ N, 𝛾 ∈ Γ and 𝑞 ∈ 𝑄 ∪ {⊥}. The information encodes that in time-step 𝑠 and at position 𝑝, the tape content is 𝛾 and the head is at that position and the machine in state 𝑞 if 𝑞 ∈ 𝑄 or the head is not at that position (if 𝑞 = ⊥). As 𝑇 is time (and thus space) bounded, 𝑠 and 𝑝 are bound by 2 𝑛 for some 𝑛.</p><p>In our formula we now use propositions ì s = s 1 , . . . , s 𝑛 to encode a time step and ì p = p 1 , . . . , p 𝑛 to encode a position on the tape (both as a binary counter). Moreover, for each state 𝑞 ∈ 𝑄 ∪ {⊥} and each letter 𝛾 ∈ Γ, we introduce an atomic proposition 𝑞 and 𝛾. In each evaluation exactly one of the tape-content propositions holds and at most one stateproposition holds (if none holds, the head is at a different step).</p><p>Using HyperLTL, we specify that the information encoded in the traces is consistent and forms an accepting run of the TM:</p><p>(1) At most one of the state-propositions and exactly one of the tape-propositions holds:</p><formula xml:id="formula_32">∀𝜋 . 𝛾 ∈Γ 𝛾 𝜋 ∧ 𝛾 ≠𝛾 ′ ∈Γ ¬𝛾 ′ 𝜋 ∧ 𝑞≠𝑞 ′ ∈𝑄 ¬(𝑞 𝜋 ∧ 𝑞 ′ 𝜋 )</formula><p>(2) If two traces agree in time step and position they also agree on tape content, state (and thus head position):</p><formula xml:id="formula_33">∀𝜋∀𝜋 ′ . 𝑛 𝑖=1 (s 𝑖 𝜋 ↔ s 𝑖 𝜋 ′ ) ∧ (p 𝑖 𝜋 ↔ p 𝑖 𝜋 ′ ) → 𝑞 ∈𝑄 (𝑞 𝜋 ↔ 𝑞 𝜋 ′ ) ∧ 𝛾 ∈Γ (𝛾 𝜋 ↔ 𝛾 𝜋 ′ )<label>(3)</label></formula><p>The TM state (and therefore also head position) agrees across all traces that are in the same time step. Phrased differently, for any two different traces that agree on the step and the automaton state, are already equal. Here we write 𝜋 = 𝜋 ′ to mean that 𝜋 and 𝜋 ′ agree (in the first position)</p><formula xml:id="formula_34">∀𝜋∀𝜋 ′ . 𝑛 𝑖=1 (s 𝑖 𝜋 ↔ s 𝑖 𝜋 ′ ) ∧ 𝑞 ∈𝑄 (𝑞 𝜋 ↔ 𝑞 𝜋 ′ ) → 𝜋 = 𝜋 ′ (4)</formula><p>The initial configuration of the TM is in the model. We cannot encode this with existential quantification directly, as we would need to refer to exponentially many positions and therfiore also exponentially many traces. Instead, we express it as a ∀∃ property. We use syntactic sugar and write ì p 𝜋 = ì p 𝜋 ′ + 1 to indicate that the binary counter increases by one position. This can easily be encoded in propositional logic in quadratic size. For a constant 𝑐 we write ì p 𝜋 = 𝑐 to denote the binary counter given by ì p equals 𝑐. We express the desired property as a conjunction of the following two formulas. The first formula is given by:</p><formula xml:id="formula_35">∃𝜋 . ì s 𝜋 = 0 ∧ ì p 𝜋 = 0 ∧ # 𝜋 ∧ 𝑞 ∈𝑄 0 𝑞 𝜋</formula><p>Which expresses that at step 0 at least the very first position is filled with # and the head is at that poistion (in an initial state). The second information propagates this information to all remaining positions in the first step:</p><formula xml:id="formula_36">∀𝜋∃𝜋 ′ . ì s 𝜋 = 0 ∧ ì p 𝜋 ≠ 2 𝑛 -1 → ì s 𝜋 ′ = 0 ∧ ì p 𝜋 ′ = ì p 𝜋 + 1 ∧ # 𝜋 ′</formula><p>Note that (3) already implies that the position is set consistently in the same step, so we do not need to require that ⊥ 𝜋 ′ holds.</p><p>(5) The model encodes valid steps of the TM. As the transitions of a TM are local, it is sufficient to compare three consecutive tape positions with the same three tape positions in the next step. Thus, for every three traces that share the same time step and encode consecutive positions, there exists three traces on the next time step with the same positions such that the step is possible in the TM. The resulting ∀ 3 ∃ 3 formula then consists of a finite conjunction over those valid "transitions triples" of 𝑇 . We do not give the formula explicitly, as the notation gets clustered.</p><formula xml:id="formula_37">)<label>(6</label></formula><p>The TM is eventually in an accepting state which we can express via ∃𝜋 . 𝑞 ∈𝐹 𝑞 𝜋 . Note that because of the explicit step count (via ì s), each model directly encodes a unique run of the TM. In particular, there can not be spurious facts that do not hold on the defined run of the TM. Consequently, we get that the resulting formula is satisfiable iff TM has a 2 We claim that we can actually assume that 𝜙 contains no s operators. We assume that in 𝜙 the s occur directly in from of atomic proportions, i.e., 𝜙 is a boolean formula over atoms of the form 𝑛 𝑎 𝜋 𝑖 . Transforming a formula in this form is possible in polynomial time. Now let 𝑘 be the lookahead needed to evaluate 𝜙 (which is upper bounded by the number of s in 𝜙). We define 𝜙 ′ as the formula over AP 0 ∪ • For the reverse, assume that 𝜁 is satisfiable and let 𝛼 be a satisfying variable assignment over AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑛+𝑚 . We construct a model with 𝑛 + 𝑚 traces 𝑡 1 , . . . , 𝑡 𝑛+𝑚 as follows: For every indices 𝑖 1 , . . . , 𝑖 𝑛 ∈ {1, . . . , 𝑛 + 𝑚} we choose 𝑚 distinct indices 𝑗 1 , . . . , 𝑗 𝑚 ∈ {1, . . . , 𝑛 +𝑚} that are also different from all 𝑖 1 , . . . , 𝑖 𝑛 (this is possible as we fixed 𝑛 + 𝑚 traces). Now fix some fresh position 𝑛 ∈ N and ensure that [𝜋 1 ↦ → 𝑡 𝑖 1 , . . . , 𝜋 𝑛 ↦ → 𝑡 𝑖 𝑛 , 𝜋 𝑛+1 ↦ → 𝑡 𝑗 1 . . . 𝜋 𝑛+𝑚 ↦ → 𝑡 𝑗 𝑚 ] [𝑛, ∞] |= 𝜙. This is always possible as we can use 𝛼 to construct the assignments of all involved traces at position 𝑘. Here it is crucial that we added the second conjunct 𝑛 𝑖=2 𝑎 ∈AP (𝑎 𝜋 𝑖 ↔ 𝑎 𝜋 1 ) to 𝜁 as this ensures that we construct a position at which the property holds even if 𝑡 𝑖 1 , . . . , 𝑡 𝑖 𝑛 are not distinct. We iterate this for every of the finitely many elements in {1, . . . , 𝑛 + 𝑚} 𝑛 (always choosing a fresh position 𝑛), thereby defining a model of 𝜑.</p><p>To show NP-hardness, we can easily reduce from propositional SAT problem: A formula 𝜁 over AP is satisfiable iff ∃𝜋 . 𝜁 𝜋 is satisfiable (we write 𝜁 𝜋 for 𝜁 when replacing all atoms 𝑎 with 𝑎 𝜋 ).</p><p>To handle multiple eventualities, reuse the above proof. Let 𝜑 = ∀ * ∃ * . 𝜙 1 ∧ • • • ∧ 𝜙 𝑛 . We again assume, w.l.o.g., that each 𝜙 𝑖 contains no s. We introduce a different copy of AP 𝑖 for the 𝑖th operator. In each -subformula, the propositional variables are exchanged accordingly, i.e., let 𝜙 ′ 𝑖 be 𝜙 𝑖 where the atomic propositions from AP are replaced with those from AP 𝑖 . It is easy to see that 𝜑 is satisfiable iff ∀ * ∃ * . (𝜙 ′ 1 ∧ • Proof. Let 𝜑 = ∀ 𝑛 ∃ 𝑚 . 𝜙. Let 𝑘 be the lookahead needed to evaluate 𝜙 (which is upper bounded by the number of s in 𝜙). Similar to the proof of Lemma 4.4 we eliminate s by using letting traces range over tuples. We construct a formula 𝜙 ′ over AP 0 ∪ • • • ∪ AP 𝑘 (where AP 𝑖 = {𝑎 𝑖 | 𝑎 ∈ AP }) as follows: We assume that in 𝜙 the s occur directly in from of atomic proportions, i.e., 𝜙 is a boolean formula over atoms of the form 𝑛 𝑎 𝜋 𝑖 . Transforming a formula in this form is possible in polynomial time. We then define 𝜙 ′ as the formula over AP 0 ∪ • • • ∪ AP 𝑘 obtained from 𝜙 by replacing each atom 𝑛 𝑎 𝜋 𝑖 with the atomic proposition (𝑎 𝑛 ) 𝜋 𝑖 .</p><p>The traces we consider now range over letters from AP 0 ∪ • • • ∪ AP 𝑘 , i.e., over the window of the next 𝑘 + 1 steps. In the LTL part of the specification we assert that this window is consistent, i.e., the 𝑖 + 1th state (evaluation over AP 𝑖+1 equals the evaluation of the 𝑖th state in the next step). We define 𝜓 ′ as</p><formula xml:id="formula_38">𝜓 ′ 𝜓 0 ∧ 𝑘-1 𝑖=0 𝑎 ∈AP 𝑎 𝑖+1 ↔ 𝑎 𝑖</formula><p>where 𝜓 0 is obtained from 𝜓 by replacing each proposition 𝑎 ∈ AP with 𝑎 0 ∈ AP 0 . We define 𝜑 ′ = ∀ 𝑛 ∃ 𝑚 . 𝜙 ′ . It is easy to see that (𝜓, 𝜑) and (𝜓 ′ , 𝜑 Let 𝑡 1 , . . . 𝑡 𝑚+1 be the infinite traces constructed in the limit. It is easy to see that 𝑇 = {𝑡 1 , . . . , 𝑡 𝑚+1 } is a model of 𝜑. In the limit, this constructs traces of infinite length which serve as a model for 𝜑. For each trace 𝑡 𝑖 , the traces with index determined by 𝑓 (𝑖) can be chosen as witness traces for existential quantification. By construction, the (unique) run of A 𝜙 on the resulting tuple of traces is accepting. □ C Additional Material for Section 5 Lemma 5.1. In every iteration of the algorithm it holds that L (A new ) ⊆ L (A), and for any trace set𝑇 with𝑇 |= ∀𝜋∃𝜋 ′ . 𝜙, 𝑇 ⊆ L (A ∀ ).</p><p>Proof. Initially, the property obviously holds as A encodes 𝜑 and every trace which occurs in any satisfying trace set must have a run through A as the ∀ trace. It remains to show that A new does not exclude traces that occur in satisfying 𝑇 . The construction ensures that if 𝑡 ∈ L (A ∀ ) but 𝑡 ∉ L (A ∀ new ), then there exists no witness trace 𝑡 ′ such that 𝑡 𝜋 ∪𝑡 ′ 𝜋 ′ ∈ L (A) and 𝑡 ′ ∈ L (A ∀ ). By induction, L (A) is a superset of the union of all satisfying trace sets, therefore, there can be no 𝑇 such that 𝑡 ∈ 𝑇 and 𝑇 |= ∀𝜋∃𝜋 ′ . 𝜙. □</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 4 . 1 .</head><label>41</label><figDesc>A HyperLTL formula 𝑄𝜋 1 . . . 𝑄𝜋 𝑛 . 𝜙 is a temporal liveness property if 𝜙 (interpreted as an LTL formula over AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑛 ) describes a liveness property.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 4 . 4 .</head><label>44</label><figDesc>The satisfiability problem is NP-complete for specifications (⊤, 𝜑) where 𝜑 is of the form ∀ * ∃ * . ( * ) ∧ • • • ∧ ( * ) and no propositional formulas occur outside of the operators. Hardness already holds for a single eventuality.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Deciding satisfiability of HyperLTL specifications. All results, expect for decidability (dec.), denote completeness. Our notation is found in Section 2.3, e.g., ∀ * ∃ * . ( * ) is the class of ∀ * ∃ * formulas whose LTL body uses a single operator with optional operators in its scope.</figDesc><table><row><cell></cell><cell></cell><cell cols="2">no LTL spec. with LTL spec.</cell></row><row><cell>Temporal</cell><cell>Safety</cell><cell cols="2">complete fragment coRE [Thm. 3.7] ∀  *  ∃  *  .  *  NEXP [Thm. 3.12] NEXP [Thm. 3.12] Σ 1 1 [Thm. 3.11] ∀  *  ∃  *  . NEXP [Lem. 3.13] Σ 1 1 [Thm. 3.11] ∀  *  ∃  *  . (  *  ) coRE [Lem. 3.10] Σ 1 1 [Thm. 3.11]</cell></row><row><cell>Temporal</cell><cell>Liveness</cell><cell>complete fragment ∀∃  *  . det-liveness trivial [Prop. 4.14] Σ 1 1 [Thm. 4.2] ∀∃  *  . (  *  ) NP [Lem. 4.4] ∀  *  ∃  *  . ∧ • • • ∧ NP [Lem. 4.4]</cell><cell>Σ 1 1 [Thm. 4.2] Σ 1 1 [Cor. 4.15] dec. [Thm. 4.5] Σ 1 1 [Thm. 4.11]</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>HyperLTL formulas 𝜑 1 , 𝜑 2 , we therefore write 𝜑 1 ∧ 𝜑 2 for some HyperLTL formula expressing the conjunction of 𝜑 1 , 𝜑 2 . For examples (∀𝜋∃𝜋 ′ . (𝑎 𝜋 ↮ 𝑎 𝜋 ′ )) ∧ (∀𝜋 . 𝑏 𝜋 ) can be expressed as ∀𝜋∀𝜋 ′ ∃𝜋 ′′ . (𝑎 𝜋 ↮ 𝑎 𝜋 ′′ ) ∧ 𝑏 𝜋 ′ . ◁</figDesc><table /><note><p>𝜑 (written 𝑇 |= 𝜑) if ∅ |= 𝑇 𝜑, where ∅ denotes the empty trace assignment. Remark 2.2. HyperLTL is closed under conjunction (and, more generally, under any boolean combination). For two</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>2 . Each instruction 𝑙 𝑖 is of one of the following forms, where 𝑥 ∈ {1, 2} and 1 ≤ 𝑖, 𝑗, 𝑘 ≤ 𝑛. 1) 𝑙 𝑖 : 𝑐 𝑥 𝑐 𝑥 + 1; goto {𝑙 𝑗 , 𝑙 𝑘 } 2) 𝑙 𝑖 : 𝑐 𝑥 𝑐 𝑥 -1; goto {𝑙 𝑗 , 𝑙 𝑘 } 3) 𝑙 𝑖 : if 𝑐 𝑥 = 0 then goto 𝑙 𝑗 else goto 𝑙 𝑘 4) 𝑙 𝑖 : halt Here, goto {𝑙 𝑗 , 𝑙 𝑘 } indicates that the machine nondeterministically chooses between instructions 𝑙 𝑗 and 𝑙 𝑘</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>the LTL semantics so 𝑡 ′ ̸ |= 𝜙 ′ as required. {1, . . . , 𝑚} → {1, . . . , 𝑛} we define the formula 𝜙 [𝑔] as the formula obtained by replacing each trace variable 𝜋 ′ 𝑡 𝑖 . The trace assignment [𝜋 1 ↦ → 𝑡 1 , . . . , 𝜋 𝑛 ↦ → 𝑡 𝑛 ] satisfies 𝜙 [𝑔] . As we can find such a 𝑔 for every 𝑡 1 , . . . , 𝑡 𝑛 ∈ 𝑇 , we get that 𝑇 |= 𝜑 ′ as required. As 𝜑 ′ is a ∀ * formula, we can conclude using Proposition 3.4. □ While temporal safety subsumes ∀ * ∃ * hypersafety, it is a strictly larger fragment as shown by the following formula. ∃𝜋 . 𝑎 𝜋 ∧ ∀𝜋 . (𝑎 𝜋 → ¬𝑎 𝜋 ) ∧ ∀𝜋∃𝜋 ′ . (𝑎 𝜋 ↔ 𝑎 𝜋 ′ ) Every model of this property must contain infinitely many traces. Hypersafety properties, on the other hand, are closed under subsets and are therefore always satisfiable by a single trace model (if satisfiable at all) [13].</figDesc><table /><note><p><p><p><p><p><p>□ Remark 3.5. We do not claim that every ∀ * hypersafety property is temporally safe. Instead, Proposition 3.4 only states that there exists an equivalent temporally safe property. For example, ∀𝜋∀𝜋 ′ . (𝑎 𝜋 ∧ ¬𝑎 𝜋 ′ ) is unsatisfiable and thus hypersafety but (𝑎 𝜋 ∧ ¬𝑎 𝜋 ′ ) is not a safety property. ◁ Proposition 3.6. For any ∀ * ∃ * hypersafety property, there exists an equivalent ∀ * property that is temporally safe.</p>Proof. Let 𝜑 = ∀𝜋 1 . . . 𝜋 𝑛 ∃𝜋 ′ 1 . . . 𝜋 ′ 𝑚 . 𝜙 be hypersafety. For a function 𝑔 : 𝑖 for 1 ≤ 𝑖 ≤ 𝑚 with 𝜋 𝑔 (𝑖) . Now define:</p>𝜑 ′ ∀𝜋 1 . . . 𝜋 𝑛 .</p>𝑔:{1,...,𝑚 }→{1,...,𝑛 }</p>𝜙 [𝑔]</p>We claim that 𝜑 ≡ 𝜑 ′ . Showing that 𝜑 ′ implies 𝜑 is easy as the disjunction gives an explicit witness for the existential quantifiers. For the other direction, assume 𝑇 |= 𝜑 for some model 𝑇 . Let 𝑡 1 , . . . , 𝑡 𝑛 ∈ 𝑇 be arbitrary. As 𝜑 is a hypersafety property and {𝑡 1 , . . . , 𝑡 𝑛 } ⊆ 𝑇 , we get that {𝑡 1 , . . . , 𝑡 𝑛 } |= 𝜑. In particular, if we bind each 𝜋 𝑖 to 𝑡 𝑖 (in 𝜑), we get witness traces 𝑡 ′ 1 , . . . , 𝑡 ′ 𝑚 ∈ {𝑡 1 , . . . , 𝑡 𝑛 } for the existential quantifiers in 𝜑. Now define 𝑔 by mapping each 1 ≤ 𝑗 ≤ 𝑚 to 𝑖 ∈ {1, . . . , 𝑛} with 𝑡 ′ 𝑗 =</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>TimePoint to indicate that on trace 𝑡, 𝑎 holds at point in time 𝑖. For each state 𝑞 ∈ 𝑄 𝜙 we use a predicate State 𝑞 over Trace 𝑛 × TimePoint. Informally, State 𝑞 (𝑥 1 , . . . , 𝑥 𝑛 , 𝑖) indicates that a run of A on traces 𝑥 1 , . . . , 𝑥 𝑛 is in state 𝑞 at timepoint 𝑖.We first ensure that each point in time has a successor and that the set of traces is non-empty.For each state 𝑞 ∈ 𝑄 𝜙 , we construct a formula 𝜌 𝑞 (over free variables 𝑥 1 , . . . , 𝑥 𝑛 ), describing that, for any choice of traces and at any point in time, there is a transition in A.𝜌𝑞 ∀𝑖, 𝑖 ′ : TimePoint. State 𝑞 (𝑥 1 , . . . , 𝑥 𝑛 , 𝑖) ∧ Succ(𝑖, 𝑖 ′ ) → (𝑞,𝜎,𝑞 ′ ) ∈𝛿 𝜙 𝑎 𝜋 𝑗 ∈𝜎 𝑃 𝑎 (𝑥 𝑗 , 𝑖) ∧</figDesc><table><row><cell>𝜙 succ</cell></row></table><note><p>TimePoint to indicate the initial time point. The predicate Succ(•, •) over TimePoint × TimePoint encodes the successor relation on time. For each 𝑎 ∈ AP, we use a predicate 𝑃 𝑎 (•, •) over Trace × ∀𝑖 : TimePoint. ∃𝑖 ′ : TimePoint. Succ(𝑖, 𝑖 ′ ) 𝜙 non-empty ∃𝑥 : Trace. ⊤ 𝑎 𝜋 𝑗 ∉𝜎 ¬𝑃 𝑎 (𝑥 𝑗 , 𝑖) ∧ State 𝑞 ′ (𝑥 1 , . . . , 𝑥 𝑛 , 𝑖 ′ ) Now, Θ is defined as follows Θ 𝑄 1 𝑥 1 : Trace. . . . 𝑄 𝑛 𝑥 𝑛 : Trace. 𝜙 succ ∧ 𝜙 non-empty ∧ 𝑞 ∈𝑄 𝜌 𝑞 ∧ State 𝑞 0 (𝑥 1 , . . . , 𝑥 𝑛 , 𝑖 𝑜 ). The last conjunct ensures that all trace tuples chosen by the quantifiers have an infinite run in A starting in the initial state and in the initial time point. If Θ is satisfiable, we can construct a trace assignment by setting the propositions based on the evaluation of 𝑃 𝑎 (•, •) in a satisfying first-order model of Θ and vice versa. A detailed proof can be found in Appendix A. □</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Model for ∀𝜋 . ∃𝜋 ′ . 𝜙 formulas. Dashed boxes indicate the witness points for the operator.can arrange the runs in 𝑅 as a sequence: we choose 𝑟 0 , 𝑟 1 , . . . ∈ 𝑅 (not necessarily distinct) such that, for each 𝑖, 𝑟 𝑖+1 serves as a witness for 𝑟</figDesc><table /><note><p><p><p><p><p>𝑖 , i.e., [𝜋 ↦ → 𝐿 𝜓 (𝑟 𝑖 ), 𝜋 ′ ↦ → 𝐿 𝜓 (𝑟 𝑖+1 )] |= 𝜙. We say 𝑛 0 , 𝑛 1 , . . . are witness points if</p>[𝜋 ↦ → 𝐿 𝜓 (𝑟 𝑖 ), 𝜋 ′ ↦ → 𝐿 𝜓 (𝑟 𝑖+1 )] [𝑛 𝑖 , ∞]</p>|= 𝜙 for every 𝑖, i.e., the 𝑛 𝑖 point to a step at which the eventuality holds. The trace arrangement is depicted in Figure</p>1</p>(ignoring the blue smaller nodes and gray edges for now). For each 𝑖, the dashed box denotes the witness point 𝑛 𝑖 where 𝑟 𝑖 and 𝑟 𝑖+1 satisfy 𝜙.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>In general, let 𝑥 𝑖 be the sequence (𝑞 0 𝑖 , 𝑛 0 𝑖 ) . . . (𝑞 𝑘 𝑖 𝑖 , 𝑛 𝑘 𝑖 𝑖 ). From 𝑥 𝑖 , we construct a finite run 𝑟 𝑖 ∈ 𝑄 * 𝜓 of A 𝜓 starting in a state in 𝑄 0,𝜓 such that for every 0 ≤ 𝑗 ≤ 𝑘 𝑖 , 𝑟 𝑖 (𝑛 𝑗 𝑖 ) = 𝑞 𝑗 𝑖 . Using the fact that for each (𝑞, 𝑏, 𝑛) in S, we have 𝑞 ∈ Reach A 𝜋 (𝑛), this is always possible. It is crucial that we cannot reverse directions between two W-steps. The finite 𝑟 𝑖 ends in a state in A 𝜓 , so by the assumption that all states are nonempty, we can extend it into an infinite accepting run. The set {𝐿 𝜓 (𝑟 0 ), 𝐿 𝜓 (𝑟 1 ), . . .} is a model of (𝜓, 𝜑). to the stack and moves to state 𝑞 ′ . An accepting run is an infinite sequence of configurations that starts in ⟨𝑞 0 , [𝛾 0 ]⟩ for some 𝑞 0 ∈ 𝑄 0 , respects 𝛿, and visits states in 𝐹 infinitely many times. It is decidable in polynomial time if a</figDesc><table /><note><p>□ 4.4.3 From Infinite State to Pushdown. The construction of S requires infinitely many states as we need to carry the natural number 𝑛 to ensure valid B and W steps (which need access to Reach A 𝜓 (𝑛)). We show next that we can replace this infinite state space by a finite pushdown system. Definition 4.9. A Büchi pushdown system is a tuple P = (𝑄, Γ, 𝑄 0 , 𝛾 0 , 𝛿, 𝐹 ), where 𝑄 is a finite set of states, Γ the finite stack alphabet, 𝑄 0 ⊆ 𝑄 initial states, 𝛾 0 ∈ Γ the initial stack symbol, 𝛿 ⊆ (𝑄 × Γ + ) × (𝑄 × Γ * ) a finite transition relation, and 𝐹 ⊆ 𝑄 a set of accepting states. The system operates on configuration ⟨𝑞, 𝛼⟩, where 𝑞 ∈ 𝑄 and 𝛼 ∈ Γ * . A transition ⟨𝑞, 𝛼⟩ ⇝ ⟨𝑞 ′ , 𝛼 ′ ⟩ ∈ 𝛿 describes that the system, if in state 𝑞 and 𝛼 ∈ Γ + is a prefix of the current stack, pops 𝛼, pushes 𝛼 ′ ∈ Γ *</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>1) based onReach A 𝜓 (𝑛). In B-steps, the stack provides access to all states that are reachable, and thus guarantees the invariant that 𝑞 ∈ Reach A 𝜓 (𝑛) for each state (𝑞, 𝑏, 𝑛) in S. It is not hard to see that P has a run that uses W-steps infinitely often iff S has a run that uses W-steps infinitely often. Combined with Lemma 4.8 we thus get:</figDesc><table /><note><p>Lemma 4.10. P has an accepting run that uses W-steps infinitely often if and only if (𝜓, 𝜑) is satisfiable.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 3 .</head><label>3</label><figDesc>Comparison of LMHyper and MGHyper on handcrafted specifications. We give the result (✓ if the specification is satisfiable and ✗ if it is unsatisfiable), the time in ms, and the number of iterations needed by LMHyper. The timeout is set to 5min.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="3">LMHyper</cell></row><row><cell>Size</cell><cell>𝑝</cell><cell>𝑡</cell><cell>𝑝</cell><cell>𝑡</cell><cell cols="2">#Iter</cell></row><row><cell>15</cell><cell cols="2">95% 40</cell><cell cols="3">100% 235 0.38</cell></row><row><cell>16</cell><cell cols="2">93% 39</cell><cell cols="3">99% 239 0.44</cell></row><row><cell>17</cell><cell cols="2">95% 39</cell><cell cols="3">100% 221 0.43</cell></row><row><cell>18</cell><cell cols="2">92% 38</cell><cell cols="3">100% 201 0.39</cell></row><row><cell>19</cell><cell cols="2">95% 40</cell><cell cols="3">100% 180 0.43</cell></row><row><cell>20</cell><cell cols="2">97% 42</cell><cell cols="3">100% 215 0.27</cell></row><row><cell></cell><cell cols="2">MGHyper</cell><cell></cell><cell></cell><cell cols="2">LMHyper</cell></row><row><cell>Problem</cell><cell cols="2">Res 𝑡</cell><cell>Res</cell><cell></cell><cell>𝑡</cell><cell>#Iter</cell></row><row><cell>Inf</cell><cell>-</cell><cell>TO</cell><cell>✓</cell><cell></cell><cell>350</cell><cell>1</cell></row><row><cell>Example 1.1</cell><cell>-</cell><cell>TO</cell><cell>✓</cell><cell></cell><cell>232</cell><cell>1</cell></row><row><cell>Enforce-2</cell><cell cols="2">✓ 444</cell><cell>✓</cell><cell></cell><cell>262</cell><cell>0</cell></row><row><cell>Enforce-3</cell><cell>-</cell><cell>TO</cell><cell>✓</cell><cell></cell><cell>334</cell><cell>0</cell></row><row><cell>Enforce-5</cell><cell>-</cell><cell>TO</cell><cell>✓</cell><cell></cell><cell>491</cell><cell>0</cell></row><row><cell>Unsat-3</cell><cell>-</cell><cell>TO</cell><cell>✗</cell><cell></cell><cell>777</cell><cell>3</cell></row><row><cell>Unsat-5</cell><cell>-</cell><cell>TO</cell><cell cols="3">✗ 1363</cell><cell>5</cell></row><row><cell>Unsat-9</cell><cell>-</cell><cell>TO</cell><cell cols="3">✗ 1681</cell><cell>9</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>. The Inf specification expresses that a model has infinitely many traces. Example 1.1 is the example from the introduction. The Enforce-𝑛 specification enforces a model that has at least 𝑛 traces. It is defined as∀𝜋∃𝜋 1 . . . 𝜋 𝑛 . 𝑖≠𝑗 (𝑎 𝜋 𝑖 ↮ 𝑎 𝜋 𝑗 ). 𝑛 ¬𝑎 combined with the hyperproperty 𝜑 ∀𝜋∃𝜋 ′ . (𝑎 𝜋 ∧ 𝑎 𝜋 ′ ).The formula is designed such that Algorithm 1 requires 𝑛 iterations to discover unsatisfiability. MGHyper times out for most of the examples; even on simple properties like Enforce-3. In contrast, LMHyper can verify properties enforcing many traces in a single iteration because the number of iterations is independent of the number of traces in a model. As expected, Unsat-𝑛 is unsatisfiable and LMHyper requires multiple iterations to show this.</figDesc><table><row><cell></cell><cell></cell><cell>The Unsat-𝑛 specifica-</cell></row><row><cell cols="3">tions are unsatisfiable. Their definition is a trace property</cell></row><row><cell>𝜓</cell><cell>(¬𝑎) U (𝑎 ∧</cell><cell>¬𝑎) ∧</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>∀𝜋 . ∃𝜋 ′ . 𝜋 The resulting specification (𝜓, 𝜑) is satisfiable iff the 2CM has a recurring computation starting in the initial state. The formula 𝜑 is from the ∀∃ 2 fragment and uses only a single without nested temporal operators. □ Theorem 3.12. The satisfiability problem is NEXPTIME-complete for specifications (𝜓, 𝜑) where 𝜑 is of the form 𝑄 * . * . Hardness holds already for 𝜓 = ⊤, a ∀ * ∃ * prefix, and no s. Proof. Let 𝜑 = 𝑄 * . 𝜙. For membership in NEXPTIME, let 𝑘 be the lookahead needed to evaluate 𝜙, which is upperbounded the number of operators occurring in 𝜙. Now define 𝑀 ⊆ Σ 𝑘 as all finite traces 𝜏 of length 𝑘 such that 𝜏 can be extended to a trace satisfying 𝜓 . 𝑀 can be constructed in exponential time by converting 𝜓 to a Büchi automaton and checking if each 𝜏 ∈ 𝑀 has an accepting run in linear time. We then nondeterministically guess a subset 𝑀 ′ ⊆ 𝑀 and verify that 𝑀 ′ |= 𝜑 which can easily be done in nondeterministic exponential time, giving the desired NEXPTIME-upper bound.</figDesc><table><row><cell>𝑎 2 𝜋 ↔ 𝑎 1 𝜋 ′</cell></row><row><cell>𝑎 ∈AP</cell></row><row><cell>Additionally, the initial configuration must be present in the</cell></row><row><cell>first component of a trace.</cell></row><row><cell>∃𝜋 . (c 1 1 ) 𝜋 ∧ (c 1 2 ) 𝜋 ∧ (l 1 1 )</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>𝑛 -time bounded accepting run. The reduction outlined above can be done in logspace, giving the desired NEXPTIME-hardness.</figDesc><table /><note><p><p>□ B Additional Material for Section 4 Lemma 4.4. The satisfiability problem is NP-complete for specifications (⊤, 𝜑) where 𝜑 is of the form ∀ * ∃ * . ( * ) ∧ • • • ∧ ( * ) and no propositional formulas occur outside of the operators. Hardness already holds for a single eventuality.</p>Proof. We first consider the case where we have only a single eventuality. Let 𝜑 = ∀𝜋 1 . . . 𝜋 𝑛 ∃𝜋 𝑛+1 . . . 𝜋 𝑛+𝑚 . 𝜙.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>• • ∪ AP 𝑘 (where AP 𝑖 = {𝑎 𝑖 | 𝑎 ∈ AP }) obtained from 𝜙 by replacing each atom 𝑛 𝑎 𝜋 𝑖 with the atomic proposition (𝑎 𝑛 ) 𝜋 𝑖 . As 𝜙 occurs under a , it is easy to see that ∀𝜋 1 . . . 𝜋 𝑛 ∃𝜋 𝑛+1 . . . 𝜋 𝑛+𝑚 . 𝜙 is satisfiable iff ∀𝜋 1 . . . 𝜋 𝑛 ∃𝜋 𝑛+1 . . . 𝜋 𝑛+𝑚 . 𝜙 ′ is satisfiable. So let us assume in the following that 𝜙 contains no temporal operators, i.e., 𝜙 is a propositional boolean formula over AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑛+𝑚 . We claim that 𝜑 is satisfiable iff Let 𝑛 ∈ N be such that [𝜋 1 ↦ → 𝑡, . . . , 𝜋 𝑛 ↦ → 𝑡, 𝜋 𝑛+1 ↦ → 𝑡 𝑛+1 , . . . , 𝜋 𝑛+𝑚 ↦ → 𝑡 𝑛+𝑚 ] [𝑛, ∞] |= 𝜙. We construct an assignment 𝛼 : AP 𝜋 1 ∪ • • •∪AP 𝜋 𝑛+𝑚 → B as follows: For each 𝑎 𝜋 𝑖 we define 𝛼 (𝜋 𝑖 ) 𝑡 (𝑛) (𝑎) if 1 ≤ 𝑖 ≤ 𝑛 and 𝛼 (𝜋 𝑖 ) 𝑡 𝑖 (𝑛) (𝑎) if 𝑛 +1 ≤ 𝑖 ≤ 𝑛 +𝑚. It is easy to see that 𝛼 satisfies 𝜁 (note that all universally quantified copies are chosen by 𝑡 so 𝑛 𝑖=2 𝑎 ∈AP (𝑎 𝜋 𝑖 ↔ 𝑎 𝜋 1 ) holds trivially).</figDesc><table><row><cell></cell><cell>𝑛</cell><cell></cell></row><row><cell>𝜁</cell><cell>𝜙 ∧</cell><cell>(𝑎 𝜋 𝑖 ↔ 𝑎 𝜋 1 )</cell></row><row><cell></cell><cell>𝑖=2 𝑎 ∈AP</cell><cell></cell></row><row><cell cols="3">is satisfiable (viewed as a propositional formula). For the</cell></row><row><cell cols="3">left to right direction, assume that 𝜑 is satisfiable by 𝑇 . We</cell></row><row><cell cols="3">now pick any 𝑡 ∈ 𝑇 and instantiate all universal quanti-</cell></row></table><note><p>fiers with 𝑡. Then let 𝑡 𝑛+1 , . . . , 𝑡 𝑛+𝑚 ∈ 𝑇 , be witness traces for the existential quantification. So [𝜋 1 ↦ → 𝑡, . . . , 𝜋 𝑛 ↦ → 𝑡, 𝜋 𝑛+1 ↦ → 𝑡 𝑛+1 , . . . , 𝜋 𝑛+𝑚 ↦ → 𝑡 𝑛+𝑚 ] |= 𝜙.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>• • ∧ 𝜙 ′ 𝑛 ) is satisfiable, as we can simply fulfill all eventualities at different timepoints. □ Lemma B.1. The satisfiability problem is NEXPTIME-complete for specifications (⊤, 𝜑) where 𝜑 is of the form ∀ * ∃ * . ( * ) ∧ • • • ∧ ( * ) (and we do allow propositional formulas occur outside of the operators). Proof. We prove this lemma by combining Lemma 4.4 and Theorem 3.12. The crux is that we can separate the propositional formulas outside the . Assume we are given a formula 𝜑 = ∀ * ∃ * . ( 𝜙 1 )∧• • •∧( 𝜙 𝑛 )∧𝜙 ′ where 𝜙 1 , . . . , 𝜙 𝑛 , 𝜙 ′ contain only s. It it easy to see that 𝜑 is satisfiable iff both ∀ * ∃ * . ( 𝜙 1 ) ∧ • • • ∧ ( 𝜙 𝑛 ) and ∀ * ∃ * . 𝜙 ′ are satisfiable. The former is decidable in NP (see Lemma 4.4) and the latter in NEXPTIME (see Theorem 3.12), so the NEXPTIME upper bound follows. For the lower bound, we can directly use the hardness shown in Theorem 3.12 and ignore the ability to use formulas. □ Lemma 4.6. Let (𝜓, 𝜑) be a specification where 𝜑 is of the form ∀ 𝑛 ∃ 𝑚 . ( * ). There exists an effectively computable specification (𝜓 ′ , 𝜑 ′ ) where 𝜑 ′ is the of the form ∀ 𝑛 ∃ 𝑚 . such that (𝜓, 𝜑) and (𝜓 ′ , 𝜑 ′ ) are equisatisfiable.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>′ ) are equisatisfiable. □ Proposition 4.14. HyperLTL formulas of the form 𝜑 = ∀∃ * . 𝜙 where 𝜙 is a deterministic liveness property are always satisfiable and have a finite model.Proof. Let 𝜑 = ∀𝜋 1 ∃𝜋 2 . . . 𝜋 𝑚+1 . 𝜙 and let A 𝜙 be a deterministic Büchi automaton for 𝜙 over AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑚+1 . For finite traces 𝑢 1 , . . . , 𝑢 𝑚+1 of the same length (say 𝑘), we define zip(𝑢 1 , . . . , 𝑢 𝑚+1 ) as the finite trace (of length 𝑘) over AP 𝜋 1 ∪ • • • ∪ AP 𝜋 𝑚+1 that combines 𝑢 1 , . . . , 𝑢 𝑚+1 , i.e., the evaluation of AP 𝜋 𝑖 is copied from 𝑡 𝑖 . The crucial property we use is that for a deterministic liveness property, we can always revisit an accepting state even after having read an arbitrary finite word. We claim that there always exists a finite model of size at most 𝑚 + 1. For any 𝑖 ∈ {1, . . . , 𝑚 + 1} define 𝑓 (𝑖) as the vector (1, . . . , 𝑖 -1, 𝑖 + 1, . . . , 𝑚 + 1) (which has length 𝑚). We iteratively constructs a model as follows: Initially, we set 𝑢 1 , . . . , 𝑢 𝑚+1 = 𝜖. For each 𝑗 = 0, 1, 2, . . . let 𝑖 = ( 𝑗%(𝑚 + 1)) + 1 (this way we consider each 𝑖 ∈ {1, . . . , 𝑚 + 1} infinitely many times) and ( 𝑗 1 , . . . , 𝑗 𝑚 ) = 𝑓 (𝑖). We now extend each of the traces in 𝑇 by some finite, non-empty word 𝑢 ′ 1 , . . . , 𝑢 ′ 𝑚+1 of the same length such that zip(𝑢 𝑖 𝑢 ′ 𝑖 , 𝑢 𝑗 1 𝑢 ′ 𝑗 1 , . . . , 𝑢 𝑗 𝑚 𝑢 ′ 𝑗 𝑚 ) reaches an accepting state in A 𝜙 . As A 𝜙 is a deterministic liveness automaton this is always possible.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Of course, we can incorporate the LTL property in the HyperLTL formula: we conceptually divide the specification into a (complicated) trace property and a (simple) hyperproperty.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>Existing decidability results for HyperLTL consider fragments that, if satisfiable, are satisfiable by a finite set of traces of bounded size. This includes the ∃ * ∀ * fragment studied in<ref type="bibr" target="#b18">[19]</ref> and the decidable fragments identified in<ref type="bibr" target="#b32">[32]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The size of 𝑄 𝜓 is at most exponential in 𝜓<ref type="bibr" target="#b41">[41]</ref>, so the size of the stack alphabet of P (which is 2 𝑄 𝜓 ) is at most double exponential in 𝜓 . As deciding the emptiness of a Büchi pushdown system is polynomial, the 2EXPTIME upper bound follows.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments All authors are partially supported by the <rs type="funder">German Research Foundation (DFG)</rs> in project <rs type="grantNumber">389792660</rs>, <rs type="grantNumber">TRR 248</rs> (<rs type="funder">Center for Perspicuous Systems)</rs>. <rs type="person">M. Krötzsch</rs> is additionally supported by the <rs type="funder">Bundesministerium für Bildung und Forschung (BMBF)</rs> in project <rs type="projectName">ScaDS</rs>.<rs type="projectName">AI (Center for Scalable Data Analytics and Artificial Intelligence</rs>), and by the <rs type="funder">Center for Advancing Electronics Dresden</rs> (cfaed). <rs type="person">R. Beutner</rs>, <rs type="person">B. Finkbeiner</rs> and <rs type="person">J. Hofmann</rs> are additionally supported by the <rs type="funder">European Research Council (ERC)</rs> in project <rs type="projectName">OSARES</rs> (No. <rs type="grantNumber">68330</rs>). <rs type="person">R. Beutner</rs> and <rs type="person">J. Hofmann</rs> carried out this work as members of the <rs type="institution">Saarbrücken Graduate School of Computer Science</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_bcZcRJj">
					<idno type="grant-number">389792660</idno>
				</org>
				<org type="funding" xml:id="_JEmEAjn">
					<idno type="grant-number">TRR 248</idno>
				</org>
				<org type="funded-project" xml:id="_vxXfdrg">
					<orgName type="project" subtype="full">ScaDS</orgName>
				</org>
				<org type="funded-project" xml:id="_RaccuPu">
					<orgName type="project" subtype="full">AI (Center for Scalable Data Analytics and Artificial Intelligence</orgName>
				</org>
				<org type="funded-project" xml:id="_2ZKn6m8">
					<idno type="grant-number">68330</idno>
					<orgName type="project" subtype="full">OSARES</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A Additional Material For Section 3 Definition A.1. A nondeterministic Turing machine is a tuple 𝑇 = (𝑄, 𝑄 0 , Γ, 𝛿, 𝐹 ) where 𝑄 is a finite set of states, 𝑄 0 ⊆ 𝑄 the initial states, Γ a finite alphabet, 𝛿 ⊆ (𝑄 × Γ) × (𝑄 × Γ × {𝐿, 𝑅}) the transition relation and 𝐹 ⊆ 𝑄 a set of accepting states. A transition ((𝑞, 𝑎), (𝑞 ′ , 𝑎 ′ , 𝑑)) ∈ 𝛿 means that the if the TM is in state 𝑞 and reads 𝑎, it updates its state to 𝑞 ′ , writes 𝑎 ′ , and moves either to the left (𝑑 = 𝐿) or the right (𝑑 = 𝑅). We assume a dedicated blank symbol # ∈ Γ. In an initial configuration for a finite word 𝑤 ∈ Γ (not containing #), the head is at position 0, the state is in some state in 𝑄 0 and the tape contains 𝑤 (followed by infinitely many #). We say that a TM accepts the empty word if there is a run starting in an initial configuration that eventually visits a configuration where the state is in 𝐹 . A TM is deterministic if 𝑄 0 = {𝑞 0 } and for each (𝑞, 𝑎), there exists at most one successor in 𝛿.</p><p>Proposition 3.9. The satisfiability problem of temporally safe HyperLTL is in coRE.</p><p>Proof. We already gave the construction of a FOL formula Θ in the proof sketch in the main part (in Section 3). Here we only show its correctness, i.e., we show that the FOL formula Θ and HyperLTL formula 𝜑 are equisatisfiable.</p><p>Assume Θ is satisfiable and fix a first-order model. Let the set 𝑋 be the set of elements from the Trace domain which may be assigned to some variable 𝑥 𝑖 in any possible evaluation of the quantifiers. We iteratively construct a trace for any element of 𝑋 . To do so, let 𝑖 0 , 𝑖 1 , . . . be a fixed sequence of element from TimePoint such that Succ(𝑖 𝑗 , 𝑖 𝑗+1 ) for any 𝑗 ∈ N and 𝑖 0 is the constant described above. This sequence might not be unique and elements might occur several times but we need to fix one such sequence to obtain well-defined traces. For each element 𝑣 ∈ 𝑋 , we define a trace 𝑡 𝑣 ∈ Σ 𝜔 , by setting 𝑡 𝑣 (𝑛) {𝑎 | 𝑃 𝑎 (𝑣, 𝑖 𝑛 )} for every 𝑛 ∈ N, where we write 𝑃 𝑎 (𝑣, 𝑖 𝑛 ) whenever this holds in the fixed firs-order model of Θ. It is easy to see that 𝑇 {𝑡 𝑣 | 𝑣 ∈ 𝑋 } is a model of 𝜑. This holds as Θ minims the quantification in 𝜑, so whenever a quantifier is instantiated with 𝑣 ∈ 𝑋 , we use trace 𝑡 𝑣 ∈ 𝑇 for the respective quantifier in 𝜑. By construction of 𝜌 𝑞 we ensure that A 𝜙 has an accepting run on all tuples of 𝑛 traces chosen in the quantifier prefix.</p><p>For the other direction, assume that 𝜑 is satisfiable by trace set 𝑇 , which we choose as domain for sort Trace. For TimePoints, we choose the set of natural numbers with 𝑖 0 = 0. We set 𝑃 𝑎 (𝑡, 𝑖) to true iff 𝑎 ∈ 𝑡 [𝑖]. For every assignment of 𝑡 1 , . . . 𝑡 𝑛 to the trace variables, we fix a run through A and set State 𝑞 (𝑡 1 , . . . , 𝑡 𝑛 , 𝑖) to true iff the the run is in state 𝑞 in step 𝑖. The resulting structure satisfies 𝜙. □ Lemma 3.10. The satisfiability problem is coRE-hard for specifications (⊤, 𝜑) where 𝜑 is of the form ∀∃ * . ( * ).</p><p>Proof. We reduce from the non-halting problem of deterministic Turing machines on the empty word, which is coRE complete. We assume, w.l.o.g., that the tape of the Turing machine is left-bounded and only takes a step to the left when it is possible. We encode the position of the head with a proposition ℎ. Throughout the construction, we maintain the invariant on all relevant traces that ℎ is set exactly once on the trace. We cannot encode this property directly as it would require to nest multiple operators. We encode the alphabet Γ and the set of states 𝑄 with sets of atomic propositions, one for each symbol and enforce that in each step, exactly one for each set holds, for 𝑆 = Γ or 𝑆 = 𝑄:</p><p>We fix the current state to be the one that holds in the position of the head. Initially, the TM is in state 𝑞 0 , the head at position 0, and the tape is blank. We require that the initial configuration is present in the set:</p><p>Now we encode the possible transitions with a ∀𝜋∃𝜋 ′ formula. We ensure that if the configuration encoded by 𝜋 is a valid one (i.e., ℎ only holds once), then the successor configuration is also valid. For correct transitions, all positions on 𝜋 ′ , which are not left or right of the head in 𝜋, must remain unchanged. Second, the head must move either left or right and the symbol and state propositions are only allowed to</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Probabilistic Hyperproperties with Nondeterminism</title>
		<author>
			<persName><forename type="first">Erika</forename><surname>Ábrahám</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ezio</forename><surname>Bartocci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Borzoo</forename><surname>Bonakdarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oyendrila</forename><surname>Dobe</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-59152-6_29</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-59152-6_29" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Automated Technology for Verification and Analysis, ATVA 2020</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">12302</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Defining Liveness</title>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Alpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
		<idno type="DOI">10.1016/0020-0190(85)90056-0</idno>
		<ptr target="https://doi.org/10.1016/0020-0190(85)90056-0" />
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Really Temporal Logic</title>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<idno type="DOI">10.1145/174644.174651</idno>
		<ptr target="https://doi.org/10.1145/174644.174651" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Flavors of Sequential Information Flow</title>
		<author>
			<persName><forename type="first">Ezio</forename><surname>Bartocci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ferrère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dejan</forename><surname>Nickovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><surname>Oliveira Da</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Costa</forename></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-94583-1_1</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-94583-1_1" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Verification, Model Checking, and Abstract Interpretation</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2022">2022</date>
			<biblScope unit="volume">13182</biblScope>
		</imprint>
	</monogr>
	<note>VMCAI 2022</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Temporal Logic for Asynchronous Hyperproperties</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Baumeister</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norine</forename><surname>Coenen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Borzoo</forename><surname>Bonakdarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">César</forename><surname>Sánchez</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-81685-8_33</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-81685-8_33" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="volume">12759</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Temporal Logic for Strategic Hyperproperties</title>
		<author>
			<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CONCUR.2021.24</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CONCUR.2021.24" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 2021</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">203</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Prophecy Variables for Hyperproperty Verification</title>
		<author>
			<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Security Foundations Symposium</title>
		<meeting><address><addrLine>CSF</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Software Verification of Hyperproperties Beyond 𝑘-Safety</title>
		<author>
			<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">Borzoo</forename><surname>Bonakdarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarai</forename><surname>Sheinvald</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2201.01670[cs.FL</idno>
		<title level="m">Finite-Word Hyperlanguages</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reachability Analysis of Pushdown Automata: Application to Model-Checking</title>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Bouajjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Maler</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-63141-0_10</idno>
		<ptr target="https://doi.org/10.1007/3-540-63141-0_10" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 1997</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1243</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Asynchronous Extensions of HyperLTL</title>
		<author>
			<persName><forename type="first">Laura</forename><surname>Bozzelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adriano</forename><surname>Peron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">César</forename><surname>Sánchez</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS52264.2021.9470583</idno>
		<ptr target="https://doi.org/10.1109/LICS52264.2021.9470583" />
	</analytic>
	<monogr>
		<title level="m">Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2021</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Temporal Logics for Hyperproperties</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masoud</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristopher</forename><forename type="middle">K</forename><surname>Koleini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><forename type="middle">N</forename><surname>Micinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">César</forename><surname>Rabe</surname></persName>
		</author>
		<author>
			<persName><surname>Sánchez</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-54792-8_15</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-54792-8_15" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Principles of Security and Trust</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>POST</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="volume">8414</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hyperproperties</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><forename type="middle">B</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><surname>Schneider</surname></persName>
		</author>
		<idno type="DOI">10.1109/CSF.2008.7</idno>
		<ptr target="https://doi.org/10.1109/CSF.2008.7" />
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Security Foundations Symposium, CSF</title>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Hierarchy of Hyperlogics</title>
		<author>
			<persName><forename type="first">Norine</forename><surname>Coenen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jana</forename><surname>Hofmann</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS.2019.8785713</idno>
		<ptr target="https://doi.org/10.1109/LICS.2019.8785713" />
	</analytic>
	<monogr>
		<title level="m">Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2019</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Is Your Software on Dope? -Formal Analysis of Surreptitiously &quot;enhanced&quot; Programs</title>
		<author>
			<persName><forename type="first">Pedro</forename><forename type="middle">R</forename><surname>D'argenio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Biewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Holger</forename><surname>Hermanns</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-54434-1_4</idno>
		<ptr target="https://doi.org/10.1007/978-3-662-54434-1_4" />
	</analytic>
	<monogr>
		<title level="m">European Symposium on Programming, ESOP 2017</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10201</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Probabilistic Hyperproperties of Markov Decision Processes</title>
		<author>
			<persName><forename type="first">Rayna</forename><surname>Dimitrova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hazem</forename><surname>Torfah</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-59152-6_27</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-59152-6_27" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Automated Technology for Verification and Analysis</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
	<note>ATVA</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Spot 2.0 -A Framework for LTL and 𝜔-Automata Manipulation</title>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Duret-Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Lewkowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amaury</forename><surname>Fauchille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thibaud</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Renault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Xu</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-46520-3_8</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-46520-3_8" />
	</analytic>
	<monogr>
		<title level="m">ternational Symposium on Automated Technology for Verification and Analysis</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2016">2016. 9938</date>
			<biblScope unit="volume">2016</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Canonical Representations of k-Safety Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lennart</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hazem</forename><surname>Torfah</surname></persName>
		</author>
		<idno type="DOI">10.1109/CSF.2019.00009</idno>
		<ptr target="https://doi.org/10.1109/CSF.2019.00009" />
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Security Foundations Symposium</title>
		<meeting><address><addrLine>CSF</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Deciding Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CONCUR.2016.13</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CONCUR.2016.13" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 2016 (LIPIcs</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">59</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">MGHyper: Checking Satisfiability of HyperLTL Formulas Beyond the ∃ * ∀ * Fragment</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Hans</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-01090-4_31</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-01090-4_31" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Automated Technology for Verification and Analysis</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">2018</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Model Checking Quantitative Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hazem</forename><surname>Torfah</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-96145-3_8</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-96145-3_8" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">10981</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The First-Order Logic of Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.STACS.2017.30</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.STACS.2017.30" />
	</analytic>
	<monogr>
		<title level="m">Symposium on Theoretical Aspects of Computer Science, STACS 2017 (LIPIcs</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">66</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Propositional Dynamic Logic of Regular Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">E</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><surname>Ladner</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(79)90046-1</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(79)90046-1" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">Marie</forename><surname>Fortin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louwe</forename><forename type="middle">B</forename><surname>Kuijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Totzke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<title level="m">HyperLTL Satisfiability is Σ 1 1 -complete, HyperCTL* Satisfiability is Σ 2</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">1 -complete</title>
		<idno type="DOI">10.4230/LIPIcs.MFCS.2021.47</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.MFCS.2021.47" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Mathematical Foundations of Computer Science, MFCS 2021</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<biblScope unit="volume">202</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Über die vollständigkeit des logikkalküls</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>Gödel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1929">1929</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Propositional Dynamic Logic for Hyperproperties</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Oliver Gutsfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Müller-Olm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Ohrem</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CONCUR.2020.50</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CONCUR.2020.50" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 2020</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">171</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Automata and fixpoints for asynchronous hyperproperties</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Oliver Gutsfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Müller-Olm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Ohrem</surname></persName>
		</author>
		<idno type="DOI">10.1145/3434319</idno>
		<ptr target="https://doi.org/10.1145/3434319" />
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Program. Lang</title>
		<meeting>ACM Program. Lang</meeting>
		<imprint>
			<publisher>POPL</publisher>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Reachability in Succinct and Parametric One-Counter Automata</title>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Haase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Kreutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joël</forename><surname>Ouaknine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Worrell</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-04081-8_25</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-04081-8_25" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="volume">5710</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Team Semantics for the Specification and Verification of Hyperproperties</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Krebs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arne</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonni</forename><surname>Virtema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.MFCS.2018.10</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.MFCS.2018.10" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Mathematical Foundations of Computer Science, MFCS 2018</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">117</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Model Checking of Safety Properties</title>
		<author>
			<persName><forename type="first">Orna</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-48683-6_17</idno>
		<ptr target="https://doi.org/10.1007/3-540-48683-6_17" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="volume">1633</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Complete Problems of Propositional Logic for the Exponential Hierarchy</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Lück</surname></persName>
		</author>
		<idno>CoRR abs/1602.03050</idno>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The Keys to Decidable HyperLTL Satisfiability: Small Models or Very Simple Formulas</title>
		<author>
			<persName><forename type="first">Corto</forename><surname>Mascle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CSL.2020.29</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CSL.2020.29" />
	</analytic>
	<monogr>
		<title level="m">EACSL Annual Conference on Computer Science Logic</title>
		<title level="s">Schloss Dagstuhl</title>
		<meeting><address><addrLine>CSL</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="volume">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Noninterference and the composability of security properties</title>
		<author>
			<persName><forename type="first">Daryl</forename><surname>Mccullough</surname></persName>
		</author>
		<idno type="DOI">10.1109/SECPRI.1988.8110</idno>
		<ptr target="https://doi.org/10.1109/SECPRI.1988.8110" />
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<meeting><address><addrLine>Oakland, SP</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Computation</title>
		<author>
			<persName><forename type="first">Marvin</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minsky</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1967">1967</date>
			<publisher>Prentice-Hall Englewood Cliffs</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">Markus</forename><forename type="middle">N</forename><surname>Rabe</surname></persName>
		</author>
		<title level="m">A temporal logic approach to Information-flow control</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
		<respStmt>
			<orgName>Saarland University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Handbook of Automated Reasoning</title>
		<editor>John Alan Robinson and Andrei Voronkov</editor>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Theory of recursive functions and effective computability</title>
		<author>
			<persName><forename type="first">Hartley</forename><surname>Rogers</surname><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>MIT press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Safety, liveness and fairness in temporal logic</title>
		<author>
			<persName><forename type="first">Sistla</forename><surname>Prasad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">5</biblScope>
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The complexity of propositional linear temporal logics</title>
		<author>
			<persName><forename type="first">Prasad</forename><surname>Sistla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edmund</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The Polynomial-Time Hierarchy</title>
		<author>
			<persName><forename type="first">Larry</forename><forename type="middle">J</forename><surname>Stockmeyer</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(76)90061-X</idno>
		<ptr target="https://doi.org/10.1016/0304-3975(76)90061-X" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1976">1976. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Reasoning About Infinite Computations</title>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Wolper</surname></persName>
		</author>
		<idno type="DOI">10.1006/inco.1994.1092</idno>
		<ptr target="https://doi.org/10.1006/inco.1994.1092" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Linear-Time Temporal Logic with Team Semantics: Expressivity and Complexity</title>
		<author>
			<persName><forename type="first">Jonni</forename><surname>Virtema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jana</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juha</forename><surname>Kontinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fan</forename><surname>Yang</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.FSTTCS.2021.52</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.FSTTCS.2021.52" />
	</analytic>
	<monogr>
		<title level="m">IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2021</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">213</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
