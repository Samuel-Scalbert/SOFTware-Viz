<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Graph-FCA Meets Pattern Structures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Sébastien</forename><surname>Ferré</surname></persName>
							<email>ferre@irisa.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<orgName type="institution" key="instit4">IRISA</orgName>
								<address>
									<postCode>F-35000</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<orgName type="institution" key="instit4">IRISA</orgName>
								<address>
									<postCode>F-35000</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Graph-FCA Meets Pattern Structures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">336FB860BE07B19F98CE8E36BCA48DB6</idno>
					<idno type="DOI">10.1007/978-3-031-35949-1_3</idno>
					<note type="submission">Submitted on 23 Aug 2023</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract xml:lang="fr">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Formal Concept Analysis (FCA) <ref type="bibr" target="#b16">[17]</ref> has been applied to many different taskssuch as information retrieval, recommendation, ontology engineering, or knowledge discovery -and in many application domains, e.g., social sciences, software engineering, bioinformatics or chemoinformatics, natural language processing <ref type="bibr" target="#b14">[15]</ref>. The variety of those tasks and application domains early called for FCA extensions in order to handle complex data. Complex data includes non-binary attributes, concrete domains, heterogeneous data, uncertain data, and structured data.</p><p>The earlier extensions enable to use complex descriptions of objects in place of sets of binary attributes. Three similar extensions have been introduced at almost the same time: Generalized Formal Concept Analysis <ref type="bibr" target="#b5">[6]</ref>, Logical Concept Analysis <ref type="bibr" target="#b11">[12]</ref>, and Pattern Structures <ref type="bibr" target="#b15">[16]</ref>. They enable to describe objects with valued attibutes, intervals over numbers and dates, convex polygons, partitions, sequence patterns, tree patterns, or labelled graph patterns <ref type="bibr" target="#b14">[15]</ref>. Other extensions address the uncertainty of object descriptions <ref type="bibr" target="#b21">[22]</ref>, notably Fuzzy FCA <ref type="bibr" target="#b4">[5]</ref> where the incidence between an object and an attribute is a truth degree in [0, 1] instead of a crisp Boolean value. Triadic Concept Analysis <ref type="bibr" target="#b20">[21]</ref> adds conditions to the incidence between an object and an attribute, making the formal context a ternary relation instead of a binary relation. Polyadic Concept Analysis <ref type="bibr" target="#b23">[24]</ref> generalizes this idea by allowing any number of dimensions for the context. Finally, a number of more recent extensions add relationships between objects, so that the concepts do not depend only on the individual descriptions of objects but also on relationship patterns over interconnected objects. Relational Concept Analysis <ref type="bibr" target="#b22">[23]</ref> combines several classical FCA contexts and several binary relations to form concepts whose intents are similar to description logic class expressions <ref type="bibr" target="#b2">[3]</ref>, combining object attributes, binary relations, and quantifier operators. Relational structures <ref type="bibr" target="#b18">[19]</ref> and Graph-FCA <ref type="bibr" target="#b7">[8]</ref> add n-ary relationships between objects (n ≥ 1), and form n-ary concepts, i.e. concepts whose intents are equivalent to conjunctive queries, and whose extents are equivalent to the results of such queries, i.e. sets of n-tuples of objects.</p><p>In this paper, we propose to merge two FCA extensions that are representative of the first and last categories above: Pattern Structures (PS) and Graph-FCA. The aim is to combine the benefits of the two categories of extensions, in short complex descriptions and relationships between objects. Logical Concept Analysis (LCA) could have been used in place of PS but we have chosen PS as it has been more widely adopted, and because it is better suited to the effective computation of concepts. In this paper we choose to merge PS with Graph-FCA but it would be perfectly relevant to do so with Relational Concept Analysis (RCA). We hope this work will encourage and facilitate the merge with RCA in a future work. The merge results in a new FCA extension called Graph-PS. It is an elegant extension in the sense that PS is a special case of Graph-PS, obtained by not using inter-object relationships; and Graph-FCA is a special case of Graph-PS, obtained by using sets of binary attributes as descriptions of individual objects and inter-object relationships. As a consequence, classical FCA is also a special case of Graph-PS. It therefore acts as an unifying FCA theory encompassing classical FCA and two mainstream FCA extensions.</p><p>The paper is structured as follows. Section 2 recalls the main definitions and results of Pattern Structures and Graph-FCA, as preliminaries. Section 3 defines Graph-PS as the extension of Graph-FCA with PS-like descriptions, and illustrates the different notions with a running example combining binary relationships, valued attributes and intervals. Section 4 describes its application to RDFS graphs by defining a custom set of descriptions and similarity operator. Section 5 concludes the paper, and draws some perspectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>In this section, we recall the main definitions of two extensions of Formal Concept Analyis (FCA): Pattern Structures (PS) <ref type="bibr" target="#b15">[16]</ref> and Graph-FCA <ref type="bibr" target="#b10">[11]</ref>. The former extends FCA attributes with complex descriptions and patterns. The latter extends FCA with n-ary relations between objects, and n-ary concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Pattern Structures (PS)</head><p>A pattern structure is a triple K = (O, (D, ), δ) where O is a set of objects, (D, ) is a meet-semi-lattice of patterns, and δ ∈ O → D is a mapping taking each object to its description. The meet operator d 1 d 2 represents the similarity between two patterns d 1 and d 2 . It entails a partial ordering , called subsumption, defined for all patterns</p><formula xml:id="formula_0">d 1 , d 2 ∈ D as d 1 d 2 ⇐⇒ d 1 d 2 = d 1 .</formula><p>Conversely, the pattern d 1 d 2 is the most specific pattern, according to , that subsumes patterns d 1 and d 2 . The extension of a pattern d is defined as the set of objects whose description contains the pattern <ref type="foot" target="#foot_1">1</ref> .</p><formula xml:id="formula_1">ext(d) := {o ∈ O | d δ(o)}, for every d ∈ D</formula><p>The intension of a set of objects X is defined as the most specific pattern that subsumes the description of all objects in X, i.e. the similarity between all those descriptions.</p><p>int(X) := </p><formula xml:id="formula_2">(X 1 , d 1 ) ≤ (X 2 , d 2 ) ⇔ X 1 ⊆ X 2 ⇔ d 2 d 1 .</formula><p>This partial ordering forms a complete lattice called the pattern concept lattice.</p><p>Pattern structures were first applied to labeled graphs <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b19">20]</ref>, e.g. to discover frequent patterns in molecular structures. They were then applied to various types of descriptions: e.g., numbers and intervals <ref type="bibr" target="#b17">[18]</ref>, partitions for characterizing functional dependencies <ref type="bibr" target="#b3">[4]</ref>, RDF graphs <ref type="bibr" target="#b0">[1]</ref>.</p><p>Classical FCA is the special case of PS when D := 2 A for a given set of attributes A, and the similarity between two sets of attributes is their intersection: ( ) := (∩).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Graph-FCA</head><p>We first need to introduce notations for tuples. Given a set X of elements, a k-tuple of elements is an ordered collection of k elements that is written (x 1 , . . . , x k ). For the sake of concision, a tuple is often written as an overlined letter x, whose element at position i can be written x[i], or simply x i if there is no ambiguity. The set of all k-tuples over X is written X k . The set of all tuples of any arity is written X * = k≥0 X k . The latter includes the empty tuple () for arity 0.</p><p>Graph-FCA extends a formal context into a graph context, defined as a triple K = (O, A, I) where O is a set of objects, A is a set of attributes, and I ⊆ O * × A is an incidence relation between tuples of objects o ∈ O * and attributes a ∈ A. Objects are graph nodes, attributes are graph labels, and an incidence ((o 1 , . . . , o k ), a) ∈ I -also written a(o 1 , . . . , o k ) -is an ordered hyperedge between nodes o 1 , . . . , o k , labeled with a.</p><p>A projected graph pattern of arity k (k-PGP) is a pair Q = (x, P ) where x = (x 1 , . . . , x k ) ∈ V k is a tuple of k projected variables, and P ⊆ V * ×A is a graph pattern. Variables are here graph nodes, and pattern elements ((y 1 , . . . , y k ), a)also written a(y 1 , . . . , y k ) -are hyper-edges. The set of k-PGPs Q k is equipped, for each arity k, with a subsumption operator ⊆ q and a similarity operator ∩ q . The description of a tuple of objects o is the PGP Q(o) := (o, I), which uses objects as variables.</p><p>The extension of a k-PGP Q is defined as the set of k-tuples of objects whose description contains the PGP.</p><formula xml:id="formula_3">ext(Q) := {o ∈ O k | Q ⊆ q Q(o)}, for every Q ∈ Q k</formula><p>The intension of a set of k-tuples of objects R is defined as the most specific PGP that subsumes the description of all tuples of objects in R, i.e. the PGPintersection of all those descriptions.</p><formula xml:id="formula_4">int(R) := o∈R Q(o), for every R ⊆ O k</formula><p>Those two derivation operators (ext, int) form a Galois connection between the two posets</p><formula xml:id="formula_5">(2 O k , ⊆) and (Q k , ⊆ q ). A graph concept of a graph context K = (O, A, I) is a pair (R, Q) with R ⊆ O k and Q ∈ Q k , for some arity k, such that R = ext(Q) and Q = q int(R). The component R of a graph con- cept (R, Q) is called the extent, and the component Q is called the intent. Graph concepts are partially ordered by (R 1 , Q 1 ) ≤ (R 2 , Q 2 ) ⇔ R 1 ⊆ R 2 ⇔ Q 2 ⊆ q Q 1 .</formula><p>This partial ordering forms a complete lattice called the graph concept lattice. There is a distinct lattice for each arity.</p><p>Graph-FCA has been applied to syntactic representations of texts, either for mining linguistic patterns <ref type="bibr" target="#b9">[10]</ref> or for information extraction <ref type="bibr" target="#b1">[2]</ref>. It has also been applied to knowledge graphs through the notion of concepts of neighbors for approximate query answering <ref type="bibr" target="#b8">[9]</ref> and for link prediction <ref type="bibr" target="#b13">[14]</ref>.</p><p>Classical FCA is a special case of Graph-FCA when only 1-tuples (i.e., singletons) are used, for the incidence relation, the projected variables of PGPs, and hence for concepts. This implies that PGPs and concept intents have the shape ((x), ({a 1 (x), . . . , a p (x)})), they use a single variable x, and hence they are equivalent to sets of attributes {a 1 , . . . , a p }. Concept extents are then sets of singleton objects, which are equivalent to sets of objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Graph-PS: Extending Graph-FCA with Pattern Structures</head><p>For concision sake, we reuse the terms of Graph-FCA in Graph-PS as the graph structure remains, and only the description of nodes and edges are affected by the extension. In the following, we first define graph contexts as a common generalization of Graph-FCA contexts and pattern structures. Then, we define Projected Graph Patterns (PGP) and operations on them as they play the role of concept intents. Finally, we define graph concepts, their formation through a Galois connection, and their organization into a lattice. Compared to Graph-FCA, each hyperedge is mapped to one description instead of to zero, one or several attributes. Graph-FCA is therefore equivalent to the special case of Graph-PS where descriptions are sets of attributes. An hyperedge that is mapped to the empty description is considered as a non-existent relationship: δ((o 1 , o 2 )) = ⊥ means that there is no relation from o 1 to o 2 ; in other words, the pair (o 1 , o 2 ) is nothing more than a pair of objects. This can be paralleled with the blank cells ((o, a) ∈ I) in a classical formal context.</p><p>Compared to PS, descriptions can not only be attached to objects but also to tuples of objects, which enables to express relationships between objects. Those relationships are taken into account, in addition to PS-like descriptions, when forming concepts. Concepts are sets of objects that have similar descriptions, and that also have similar relationships to objects that have similar descriptions, and so on.</p><p>Example 1. As an example of graph context K ex , we extend an example from Graph-FCA about the British royal family, introducing taxonomic relationships between attributes, and numeric invervals. The objects are people belonging to three generations.</p><p>O ex := {Charles, Diana, W illiam, Harry, Kate, George, Charlotte} They are respectively abbreviated as C, D, W, H, K, G, A. Objects (people) are described by a pair made of their gender and their birth year:</p><formula xml:id="formula_6">δ(C) = man : 1948, δ(D) = woman : 1961, δ(W ) = man : 1982, δ(K) = woman : 1982, δ(H) = man : 1984, δ(G) = man : 2013, δ(A) = woman : 2015.</formula><p>Pairs of objects are described whether the second is a parent of the first, and with the rank among siblings.</p><formula xml:id="formula_7">δ(W, C) = parent : 1 δ(H, C) = parent : 2 (same for D in place of C) δ(G, W ) = parent : 1 δ(A, W ) = parent : 2 (same for K in place of W)</formula><p>For instance, δ(W, C) = parent : 1 tells that William is the first child of Charles. Any other tuple of objects has the empty description: δ(o) = ⊥.</p><p>We want to take into account similarities between attributes and values. First, we define the similarity between genders, man woman = person, saying that men and women have in common to be persons. Second, like in <ref type="bibr" target="#b17">[18]</ref>, we define the similarity between two numeric values as the smallest interval that contains the two values: e.g., 1 3 = <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>. This extends to intervals by using the convex hull of two intervals, considering a value v as equivalent to the interval</p><formula xml:id="formula_8">[v, v]. [u 1 , v 1 ] [u 2 , v 2 ] = [min(u 1 , u 2 ), max(v 1 , v 2 )]</formula><p>However, to avoid intervals that are too large and hence meaningless, intervals [u, v] s.t. v -u &gt; are generalized into the symbol * that represents the range of all possible values. The threshold depends on the type of values: = 20 for birth years so that similarity means "in the same generation", and = 1 for birth ranks. To summarize, the set of descriptions in our example is defined as:</p><formula xml:id="formula_9">D ex := {a : [u, v], a : * | a ∈ {person, man, woman, parent}, u ≤ v ∈ Z} ∪ {⊥},</formula><p>with a : v as a shorthand for a : [v, v], and ⊥ the empty description. The similarity</p><formula xml:id="formula_10">operator d = d 1 d 2 is defined as follows. If d 1 = ⊥ or d 2 = ⊥ then d = ⊥, otherwise, d 1 = a 1 : V 1 and d 2 = a 2 : V 2 .</formula><p>Then, if the attribute similarity a 1 a 2 is defined as attribute a, then d = a : V where V = V 1 V 2 as defined above with the threshold depending on the attribute, else d = ⊥.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Projected Graph Patterns (PGP)</head><p>A graph pattern over a graph context shares the same structure as a graph context, with nodes and hyperedges labelled by descriptions, except that nodes are variables that range over the objects of the context. Definition 2 (graph pattern). Let K = (O, (D, ), δ) be a graph context. A graph pattern over K is a pair P = (V, δ P ), where V ⊆ V is a finite set of variables (nodes), and δ P ∈ V * → D is a mapping taking each hyperedge to its description (hyperedge label).</p><p>Compared to Graph-FCA, hyperedges are labelled by custom descriptions rather than by sets of attributes. An embedding of a graph pattern in a graph context is a mapping φ ∈ V → O from pattern variables to context objects such that for each hyperedge x, the pattern description of the edge subsumes the context description of the corresponding edge, i.e. δ P (x) δ(φ(x)).</p><p>Example 2. Given the graph context in Example 1, we introduce the example graph pattern P ex = ({x, y}, δ P ), where the description δ P is defined as follows:</p><formula xml:id="formula_11">δ P (x) = man : [1980, 1989], δ P (y) = person : * , δ P (x, y) = parent : [1, 2].</formula><p>This description can be more concisely written as follows:</p><formula xml:id="formula_12">δ P = {x → man : [1980, 1989], y → person : * , (x, y) → parent : [1, 2]}.</formula><p>This pattern represents the situation where a man born in the eighties (x) is the first or second child of some person with unconstrainted birthdate (y). The pattern has four embeddings in the context, e.g. {x → Harry, y → Diana} because Harry is a man born in 1984, and is the second child of Diana, who is a woman and hence a person.</p><p>A Projected Graph Pattern (PGP) is a graph pattern with a tuple of distinguished variables, called projected variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (PGP).</head><p>A projected graph pattern (PGP) is a couple Q = (x, P ) where P = (V, δ) is a graph pattern, and x ∈ V * , called projection tuple, is a tuple of variables from the pattern. |Q| = |x| denotes the arity of the PGP. We note Q the set of PGPs, and Q k the subset of k-PGPs, i.e. PGPs having arity k.</p><p>A PGP can be seen as a SPARQL query SELECT x FROM { P }, whose answers are the embeddings of the pattern restricted to the projected variables.</p><p>Example 3. The PGP Q ex = ((x), P ex ) based on the graph pattern in Example 2 selects all men born in the eighties as the first or second child of somebody. The answers over the example context are therefore Harry and William. The PGP ((x, y), P ex ) would select pairs (child, parent), such as (Harry, Diana).</p><p>In Graph-FCA and Graph-PS, PGPs play the role of descriptions in PS. We therefore have to define two key operations on them: inclusion ⊆ q (aka. subsumption) and intersection ∩ q (aka. similarity). In Graph-PS, their definitions depend on the corresponding operations on PS-like descriptions, and .</p><p>Definition 4 (PGP inclusion). Let K = (O, (D, ), δ) be a graph context. Let</p><formula xml:id="formula_13">Q 1 = (x 1 , (V 1 , δ 1 )), Q 2 = (x 2 , (V 2 , δ 2 )) be two k-PGPs for some arity k. Q 1 is included in Q 2 , or equivalently Q 2 contains Q 1 , which is written Q 1 ⊆ q Q 2 iff ∃φ ∈ V 1 → V 2 : φ(x 1 ) = x 2 ∧ ∀y ∈ V * 1 : δ 1 (y) δ 2 (φ(y))</formula><p>According to this definition, the inclusion of Q 1 into Q 2 is analogous to the embedding of a pattern into a context, with the difference that variables are mapped to the variables of another pattern instead of the objects of the context. There is also the additional constraint that the projected variables match. Example 4. For example, the PGP Q = ((z), ({z}, {z → man : * })), which selects the set of men, is included in the above PGP Q ex , through the embedding φ = {z → x}.</p><p>Definition 5 (PGP intersection). Let ψ be an injective mapping from pairs of variables to fresh variables. The intersection of two k-PGPs Q</p><formula xml:id="formula_14">1 = (x 1 , (V 1 , δ 1 )) and Q 2 = (x 2 , (V 2 , δ 2 )), written Q 1 ∩ q Q 2 , is defined as Q = (x, (V, δ)), where x = ψ(x 1 , x 2 ), V = {ψ(v 1 , v 2 ) | v 1 ∈ V 1 , v 2 ∈ V 2 }, δ(y) = δ 1 (y 1 ) δ 2 (y 2 ), for y = ψ(y 1 , y 2 ) ∈ V *</formula><p>PGP intersection works as a product of two PGPs where each pair of edges (y 1 , y 2 ) makes an edge whose description is the similarity δ 1 (y 1 ) δ 2 (y 2 ) between the descriptions of the two edges. Variables xz and yz result from the pairing of variables from each PGP (function ψ). The tuples of variables that are not shown in the δ P part have the empty description. For instance, δ P ((xz, yz)</p><formula xml:id="formula_15">) = δ ex ((x, y)) δ ((z, z)) = parent : [1, 2] ⊥ = ⊥.</formula><p>In Q the description of yz is disconnected from the projected variable xz, and is therefore useless to the semantics of Q . Q can therefore be simplified to ((xz), ({xz}, {xz → man : * })), which is equal to Q up to renaming variable xz as x. More information about such simplifications are available in <ref type="bibr" target="#b10">[11]</ref>.</p><p>The above example suggests as expected that</p><formula xml:id="formula_16">Q 1 ⊆ q Q 2 implies Q 1 ∩ q Q 2 = Q 1 .</formula><p>The following lemma proves that this is indeed the case, like with PS descriptions. <ref type="bibr" target="#b0">[1]</ref> (recall that ψ is an injective mapping from 2-tuples of variables to variables), and to prove that φ 1 (x) = x 1 and δ(y) δ 1 (φ 1 (y)) for all y ∈ V * . This is easily obtained from the definition of Q. The proof of Q ⊆ q Q 2 is identical with φ 2 (x) = (ψ -1 (x)) <ref type="bibr" target="#b1">[2]</ref>.</p><formula xml:id="formula_17">Lemma 1. Let Q 1 , Q 2 be two PGPs. Their PGP intersection Q 1 ∩ q Q 2 is their infimum relative to query inclusion ⊆ q . Proof. To prove that Q = Q 1 ∩ q Q 2 is a lower bound, it suffices to prove that Q is included in both Q 1 and Q 2 . To prove Q ⊆ q Q 1 , it suffices to choose the mapping φ 1 (x) = (ψ -1 (x))</formula><p>To prove that Q 1 ∩ q Q 2 is the greatest lower bound (the infimum), we have to prove that every PGP Q that is included in both Q 1 (via φ 1 ) and Q 2 (via φ 2 ) is also included in Q. To that purpose, it suffices to choose φ(x ) = ψ(φ 1 (x ), φ 2 (x )), and to prove that φ(x ) = x and δ (y ) δ(φ(y )) for all y . This can be obtained from the definition of Q, and from the hypotheses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Graph Concepts</head><p>As usual in FCA, concepts are composed of an extent and an intent. In Graph-PS like in Graph-FCA, k-PGPs in Q k play the role of intents. For the extents we use the answers of PGPs seen as queries, i.e. sets of tuples of objects. The latter are mathematically k-ary relations over objects: R ⊆ O k , for some arity k ≥ 0. We note R k = 2 O k the set of k-relations over the objects of some graph context K. This definition says that the graph description of an object is the whole graph context, seen as a graph pattern (objects as variables), and projected on the object. In practice, only the part of the graph context that is connected to the object is relevant. The generalization to tuples of objects enables to have a description for pairs of objects, triples of objects, and so on.</p><p>From there, we can define two derivation operators between PGPs and relations, and prove that they form a Galois connection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7 (extension). Let</head><formula xml:id="formula_18">K = (O, (D, ), δ) be a graph context. The ex- tension of a k-PGP Q ∈ Q k is the k-relation defined by ext(Q) := {o ∈ O k | Q ⊆ q γ(o)}</formula><p>The extension of a k-PGP is the set of k-tuples of objects whose graph description contains the PGP. It can be understood as the set of answers of the PGP seen as a query. Note that this intension expands the PGP in Example 7 with the following elements: x is a man, x is the first child of some man z, his father, and there is a second child w of parents y and z. The extension of this expanded PGP remains the relation R, which suggests that int • ext is a closure operator.</p><p>We can actually prove that ext and int form a Galois connection. This implies that int • ext and ext • int are closure operators, respectively on PGPs and relations.</p><p>Theorem 1 (Galois connection). Let K = (O, (D, ), δ) be a graph context. For every arity k, the pair of mappings (ext, int) forms a Galois connection between (R k , ⊆) and (Q k , ⊆ q ), i.e. for every object relation</p><formula xml:id="formula_19">R ∈ R k and PGP Q ∈ Q k , R ⊆ ext(Q) ⇐⇒ Q ⊆ q int(R) Proof. R ⊆ ext(Q) ⇐⇒ ∀o ∈ R : o ∈ ext(Q) ⇐⇒ ∀o ∈ R : Q ⊆ q γ(o) (Definition 7) ⇐⇒ Q ⊆ q o∈R γ(o) (Lemma 1) ⇐⇒ Q ⊆ q int(R) (Definition 8)</formula><p>From the Galois connection, graph concepts can be defined and organized into concept lattices, like in classical FCA, with one concept lattice for each arity k.</p><formula xml:id="formula_20">Definition 9 (graph concept). Let K = (O, (D, ), δ) be a graph context. A k-graph concept of K is a pair (R, Q), made of a k-relation (the extent) and a k-PGP (the intent), such that R = ext(Q) and Q = q int(R).</formula><p>Example 9. The 2-relation and 2-PGP in Example 8 form a 2-graph concept. It can be understood as the (first child, mother) binary relationship. Its intent tells us that in the example context, every first child whose mother is known also has a known father, and a sibling (man or woman) that was born after him.</p><p>Theorem 2 (graph concept lattices). The set of graph k-concepts C k , partially ordered by ≤, which is defined by</p><formula xml:id="formula_21">(R 1 , Q 1 ) ≤ (R 2 , Q 2 ) : ⇐⇒ R 1 ⊆ R 2 ⇐⇒ Q 2 ⊆ q Q 1 ,</formula><p>forms a bounded lattice (C k , ≤, ∧, ∨, , ⊥), the k-graph concept lattice.  1. A concept/node identifier Qnx made of a number n and a letter x. The number identifies a pattern P n , and the letter identifies a node of this pattern. Together they form the concept intent Q n = (x, P n ). The set of nodes V n of pattern P n = (V n , δ Pn ) is therefore made of all boxes whose identifier has Qn as a prefix. (Some concepts also have an informal description under the identifier, manually added to help the reading of the lattice.) 2. A list of pattern hyperedges in the form d y 1 . . . y n , to be read as δ Pn (y 1 , . . . , y n ) = d, where an underscore _ refers to the current node x.</p><p>A 1-edge d _ is abbreviated as d as it corresponds to an attribute in classical FCA. 3. A list of objects composing the concept extent.</p><p>A k-concept with k &gt; 1 can be read by selecting k different boxes that belong to the same pattern. The graph pattern is the same, whatever the nodes chosen as projected variables, so the concept intent can be read like for 1-concepts. However, the concept extent cannot be read exactly from this representation, it is a subset of the Cartesian product of the extents of the selected boxes.</p><p>Example 10. Given the way different concepts share the same graph pattern in their intent, it makes sense to interpret the concept lattice in Figure <ref type="figure" target="#fig_1">1</ref> pattern by pattern.</p><p>-Pattern P 3 is a about a person born at any time. It has a single node a, hence there is a single concept Q3a, the concept of all persons in the context. It is the top concept. -Pattern P 1 is the refinement of P 3 on women.</p><p>-Pattern P 4 is the refinement of P 3 on men.</p><p>-Pattern P 2 is the refinement of P 3 on people born in the eighties.</p><p>-Pattern P 5 has 7 nodes (a-g). It is about a man (a) that is the first child of two parents, a man (d) and a woman (c), and about another person (b) that is the second child of the same parents. Those nodes respectively correspond to the concepts of "male first child" (Q5a), "father" (Q5d), "mother" (Q5c), and "second child" (Q5b). The other nodes in the pattern actually define generalizations of those concepts for which the a-b-c-d pattern is always present in the context: "parent" (Q5g), "male child" (Q5e), and "child" (Q5f). It can be observed that the latter concepts (e-g) are in a lighter color and the former concepts (a-d) are in a more vivid color (called core concepts/nodes <ref type="bibr" target="#b10">[11]</ref>). When reading a concept intent, the boxes in a lighter color can be ignored when they are not selected because the information they provide is redundant with the core nodes. -The core nodes of pattern P 6 reproduce the graph context, each node corresponding to a specific object. The non-core concepts provide generalizations over single objects: "grand-parents born between 1948 and 1961" (Q6i), "parents born in 1982" (Q6h), "children born between 1982 and 1984" (Q6j), and "grand-children born between 2013 and 2015" (Q6k).</p><p>From the concept lattice structure, it is possible to find what different people have in common. For instance, from Q6d ∨ Q6g = Q5f , we learn that what William (Q6d) and Charlotte (Q6g) have in common is that they are persons with a father (Q5d, Charles or William) and a mother (Q5c, Diana or Kate) who have together a male first child (Q5a, William or George), and a second child (Q5b, Harry or Charlotte). We also learn that they share that with Harry and George, the other instances of concept Q5f.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Application to RDFS Graphs</head><p>As an application case of Graph-PS we consider RDFS graphs. An RDFS graph is a structure R, L, (C, ≤), (P, ≤), T , where R is a collection of resources (IRIs and blank nodes), L is a set of literal values of various datatypes (e.g., strings, numbers, dates), C is a hierarchy of classes, P is a hierarchy of properties, and T is a set of triples expressing the factual knowledge.</p><p>In order to apply Graph-PS to RDFS graphs, we need to identify what are the objects, the descriptions, and the similarity between descriptions. From the usual RDFS graph representation that uses resources, literals, and classes as nodes, it is tempting to use them as objects. However, it is desirable to define similarity over literals and classes. The similarity between two integer literals could be an interval like in the example of the previous section. The similarity between two classes should be the most specific common ancestor class. Moreover, we think that literals and classes are more appropriate as descriptors of objects than as objects to be described. We therefore define the set of object as O = R.</p><p>We now look at the description of (tuples of) objects. The description information lies in the triples. We define below their conversion into elementary descriptions, according to the three kinds of triples.</p><p>-(r, rdf:type, c) δ(r) = {c, . . .} The triple states that resource r is an instance of class c. The class is used as a descriptor of the resource, rdf:type can be ignored because it is always used with a class. We use an open set containing c because a resource can be declared an instance of several classes. -(r, p, r ) δ(r, r ) = {p, . . .} The triple states that resource r is related to resource r with property p. The property is used as a descriptor of the pair of resources, hence representing a binary edge. We again use an open set because RDFS graphs are multigraphs, i.e. several properties can relate the same resources (e.g., a person who is both the director and an actor of some film).</p><p>-(r, p, l) δ(r) = {p : l, . . .} The triple states that resource r is related to literal l with property p. Both the property and literal are descriptors, so they must be combined into a composite descriptor, similarly to the example of previous section. We again use an open set because RDFS properties can be multi-valued, and also because resources also have classes as descriptors.</p><p>To summarize, the set of descriptions can be defined as follows.</p><formula xml:id="formula_22">D = D 1 ∪ D 2 where D 1 = 2 C × 2 P×L and D 2 = 2 P D 1</formula><p>is the set of descriptions of individuals resources, where a description is a pair made of a set of classes, and a set of valued properties. D 2 is the set of descriptions of edges between resources, where a description is a set of properties. The empty description is therefore simply the empty set: ⊥ = ∅. From there, we can formally define the description of every resources and pairs of resources.</p><formula xml:id="formula_23">δ(r) = ({c | (r, rdf:type, c) ∈ T }, {p : l | (r, p, l) ∈ T, l ∈ L}) δ(r, r ) = {p | (r, p, r ) ∈ T, r ∈ R}</formula><p>It remains to define the similarity operator over descriptions. As our descriptions of RDFS resources are based on sets of elementary descriptors, we derive similarity on sets from similarity on elements. We can allow the similarity between two elements to be a set of elements, the least general generalizations (lgg). This set-based approach has already been used in Pattern Structures, e.g. for graphs and subgraphs <ref type="bibr" target="#b15">[16]</ref>. On classes and properties, we have a partial ordering ≤ from which the lgg operator can defined as follows:</p><formula xml:id="formula_24">lgg(x, y) := M in ≤ {z ∈ X | x ≤ z, y ≤ z}</formula><p>On literals, given that L is in general infinite, it is more convenient to assume the lgg operation to be defined, and to derive the partial ordering from it: x ≤ y ⇐⇒ lgg(x, y) = {y}. Here are a few examples on how lgg could be defined on literals: Of course, this assumes to extend the set of literals L with all patterns that may be generated by the lgg operator, e.g. intervals. On valued properties the lgg operator can be obtained by combining the lgg operators on properties and literals. lgg Finally, the similarity between a D 1 -description and a D 2 -description is simply the empty description ⊥, although Graph-PS only applies similarity to the descriptions of tuples of objects with the same arity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion and Perspectives</head><p>We have introduced a new extension of Formal Concept Analysis that merges two existing FCA extensions, Pattern Structures (PS) and Graph-FCA. In short, PS-like descriptions are used to describe the nodes and hyperedges of graphs, in place of sets of attributes. The new extension therefore combines the benefits of the two existing extensions: complex descriptions and relationships between objects. A strength of Graph-PS is that it is a proper generalization of PS and Graph-FCA, in the sense that PS and Graph-FCA -as well as FCA -are special cases of Graph-PS. Hence, all previous work about defining custom pattern structures can be reused in Graph-PS, and the compact graphical representations of concept lattices in Graph-FCA can be reused in Graph-PS. We have also shown that Graph-PS can accurately represent existing graph-based models like RDFS graphs. This paper focuses on the theoretical aspects of Graph-PS, and the most immediate perspectives concern its implementation and its applications. The implementation could be adapted from the existing implementation of Graph-FCA <ref type="bibr" target="#b6">[7]</ref>, by taking into account the similarity operator in the PGP operations ⊆ q and ∩ q . The additional cost of using Graph-PS in PS and Graph-FCA settings should be evaluated. A toolbox of components should be built in order to facilitate the design of new sets of descriptions, by capitalizing on previous applications of pattern structures, and by adopting the methodology of logic functors <ref type="bibr" target="#b12">[13]</ref>. In the end, we plan to experiment Graph-PS in diverse knowledge graphs and other complex structures like sequences and trees.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>o∈X δ(o), for every X ⊆ O The two derivation operators (ext, int) form a Galois connection between the two posets (2 O , ⊆) and (D, ). A pattern concept of a pattern structure K = (O, (D, ), δ) is a pair (X, d) with X ⊆ O and d ∈ D such that X = ext(d) and d = int(X). The component X of a pattern concept (X, d) is called the extent, and the component d is called the intent. Pattern concepts are partially ordered by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3. 1</head><label>1</label><figDesc>Graph Context Definition 1 (graph context). A graph context is a triple K = (O, (D, ), δ), where O is a set of objects, D is a meet-semi-lattice of descriptions, and δ ∈ O * → D is a mapping taking each tuple of objects to its description. The meet operator on descriptions entails a smallest description ⊥ (called the empty description), and a partial ordering (called subsumption), defined for all descriptions c, d ∈ D as c d ⇐⇒ c d = c.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 5 .</head><label>5</label><figDesc>The intersection of Q ex and Q results in the PGP Q = ((xz), ({xz, yz}, {xz → man : * , yz → person : * })).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 6 .</head><label>6</label><figDesc>The set of father-mother-child triples can be represented as the following 3-relation (with abbreviated people names).R := {(C, D, W ), (C, D, H), (W, K, G), (W, K, A)}Note that the order of objects in tuples matters while the order of tuples in the relation does not. A k-relation can be seen as a table with k unlabeled columns.Charles Diana WilliamCharles Diana Harry William Kate George William Kate Charlotte Before defining the Galois connection between PGPs and relations, we introduce the notion of graph description γ(o) of an object or a tuple of objects. It incorporates everything that is known about an object or tuple of objects, in terms of relationships in the graph context around those objects, and in terms of D-description of those relationships. It therefore integrates the description δ of individual hyperedges. Definition 6 (graph description). Given a graph context K = (O, (D, ), δ), the graph description of any object o ∈ O is defined as the PGP γ(o) := ((o), P K ) where P K = (O, δ). By extension, the description of any tuple of objects o ∈ O * is defined as γ(o) := (o, P K ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Example 7 .Example 8 .</head><label>78</label><figDesc>In the example context, the extension of the 2-PGP Q = ((x, y), ({x, y}, {x → person : * , y → woman : * , (x, y) → parent : 1})) is the 2-relation R = ext(Q) = {(W illiam, Diana), (George, Kate)}, i.e. the set of pairs (first child, mother). Definition 8 (intension). Let K = (O, A, I) be a graph context. The intension of a k-relation R ∈ R k is the k-PGP defined by int(R) := o∈R γ(o) The intension of a k-relation is the PGP intersection of the graph descriptions of all tuples of objects in the relation, hence the most specific projected graph pattern shared by them. In the example context, the intension of the 2-relation from Example 7 R = {(W illiam, Diana), (George, Kate)} is the 2-PGP Q = int(R) = ((x, y), ({x, y, z, w}, δ P )) where δ p = {x → man : * , y → woman : * , z → man : * , w → person : * , (x, y) → parent : 1, (x, z) → parent : 1, (w, y) → parent : 2, (w, z) → parent : 2}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The 1-graph concept lattice of the royal family context (less the bottom concept). The descriptor parent:1 a _ in box Q5g reads δP 5(a, g) = parent : 1, as part of the graph pattern P 5 of the intent of concept Q5g. The nodes of pattern P 5 are the boxes Q5a-g.</figDesc><graphic coords="12,134.77,115.84,345.83,314.55" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 1</head><label>1</label><figDesc>Figure 1 is a representation of the 1-graph concept lattice -less the bottom concept -of the royal family graph context from Example 1. This is a compact representation because each box represents at the same time a 1-concept and a node of the graph pattern of a concept intent. Each box is made of three parts:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>-</head><label></label><figDesc>lgg<ref type="bibr" target="#b9">(10,</ref><ref type="bibr" target="#b19">20)</ref> = {[10, 20]}, lgg([10, 30], [25, 50]) = {[10, 50]}, lgg("Formal Concept Analysis", "Relational Concept Analysis") ={"Concept", "Analysis"}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>(p : l , p : l ) = {p : l | p ∈ lgg(p , p ), l ∈ lgg(l , l )} Each lgg operator can be lifted to the PS similarity operator on sets of elements by collecting all least general generalizations of elements pairwise, and then filtering them to keep only the most specific ones.d d = Min ≤ {x ∈ lgg(x , x ) | x ∈ d , y ∈ d }This is enough to define similarity on D 2 -descriptions, which are sets of properties. On D 1 -descriptions, similarity can be defined element-wise as they are pairs (C, P L) of sets of elementary descriptors: C is a set of classes, and P L is a set of valued properties.(C , P L ) (C , P L ) = (C C , P L P L )</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>This research is supported by ANR project SmartFCA (ANR-21-CE23-0023).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>The original notation for the two PS derivation operators is (.) . We use the notations ext(.) and int(.) because they are more explicit and also consistent with notations in other FCA extensions.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Exploratory knowledge discovery over web of data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Buzmakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">249</biblScope>
			<biblScope unit="page" from="2" to="17" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Extracting relations in texts with concepts of neighbours</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ayats</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cellier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Concept Analysis</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">12733</biblScope>
			<biblScope unit="page" from="155" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">The Description Logic Handbook: Theory, Implementation, and Applications</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">F</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Characterizing functional dependencies in formal concept analysis with pattern structures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baixeries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaytoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="129" to="149" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fuzzy closure operators</title>
		<author>
			<persName><forename type="first">R</forename><surname>Belohlavek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Mathematical Analysis and Appl</title>
		<imprint>
			<biblScope unit="volume">262</biblScope>
			<biblScope unit="page" from="473" to="489" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Generalized formal concept analysis</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chaudron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Maille</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Conceptual Structures. LNCS</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Mineau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1867</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Modeling complex structures in Graph-FCA: Illustration on natural language syntax</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cellier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Existing Tools and Applications for Formal Concept Analysis (ETAFCA)</title>
		<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A proposal for extending formal concept analysis to knowledge graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Formal Concept Analysis (ICFCA)</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Baixeries</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Sacarea</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Ojeda-Aciego</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9113</biblScope>
			<biblScope unit="page" from="271" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Answers partitioning and lazy joins for efficient query relaxation and application to similarity search</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Semantic Web (ESWC)</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Gangemi</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">10843</biblScope>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Graph-FCA in practice</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cellier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Conceptual Structures (ICCS)</title>
		<editor>
			<persName><forename type="first">O</forename><surname>Haemmerlé</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9717</biblScope>
			<biblScope unit="page" from="107" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Graph-FCA: An extension of formal concept analysis to knowledge graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cellier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="81" to="102" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A logical generalization of formal concept analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ridoux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Conceptual Structures</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Mineau</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">1867</biblScope>
			<biblScope unit="page" from="371" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A framework for developing embeddable customized logics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Ridoux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Work. Logic-based Program Synthesis and Transformation</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Pettorossi</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">2372</biblScope>
			<biblScope unit="page" from="191" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Application of concepts of neighbours to knowledge graph completion</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Science: Methods, Infrastructure, and Applications</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1" to="28" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A guided tour of artificial intelligence research</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaytoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Concept Analysis: from knowledge discovery to knowledge processing (Chapter 13)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">II</biblScope>
			<biblScope unit="page" from="411" to="445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pattern structures and their projections</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Conceptual Structures</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Delugach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Stumme</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2120</biblScope>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wille</surname></persName>
		</author>
		<title level="m">Formal Concept Analysis -Mathematical Foundations</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Revisiting numerical pattern mining with formal concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kaytoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Joint Conf. Artificial Intelligence (IJCAI)</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Concept lattices of a relational structure</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kötters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Conceptual Structures for STEM Research and Education</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Pfeiffer</surname></persName>
		</editor>
		<editor>
			<persName><surname>Others</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7735</biblScope>
			<biblScope unit="page" from="301" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Learning closed sets of labeled graphs for chemical applications</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Samokhin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Inductive Logic Programming</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kramer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Pfahringer</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3625</biblScope>
			<biblScope unit="page" from="190" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A triadic approach to formal concept analysis</title>
		<author>
			<persName><forename type="first">F</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wille</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Conf. Conceptual Structures (ICCS)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="32" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Fuzzy and rough formal concept analysis: a survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Poelmans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">I</forename><surname>Ignatov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Dedene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. General Systems</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="134" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Relational concept analysis: mining concept lattices from multi-relational data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rouane-Hacene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valtchev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="108" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Polyadic concept analysis</title>
		<author>
			<persName><forename type="first">G</forename><surname>Voutsadakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Order</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="295" to="304" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
