<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Approximate Querying on Property Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Stefania</forename><surname>Dumbrava</surname></persName>
							<email>stefania.dumbrava@ensiie.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">ENSIIE Évry</orgName>
								<orgName type="institution" key="instit2">CNRS Samovar</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">CNRS LIRIS</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
							<email>angela.bonifati@univ-lyon1.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Lyon</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amaia</forename><surname>Nazabal</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ruiz</forename><surname>Diaz</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Romain</forename><surname>Vuillemot</surname></persName>
							<email>romain.vuillemot@ec-lyon.fr</email>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">École Centrale Lyon</orgName>
								<orgName type="institution" key="instit2">CNRS LIRIS</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amaia</forename><surname>Nazabal Ruiz Diaz</surname></persName>
							<email>amaia.nazabal-ruiz-diaz@univ-lyon1.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Lyon</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Approximate Querying on Property Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">20A8FC5F4EA2ECB000595F43B5B647AA</idno>
					<idno type="DOI">10.1007/978-3-030-35514-2_19</idno>
					<note type="submission">Submitted on 18 Dec 2019</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract xml:lang="fr">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A tremendous amount of information stored in the LOD can be inspected, by leveraging the already mature query capabilities of SPARQL, relational, and graph databases <ref type="bibr" target="#b13">[14]</ref>. However, arbitrarily complex queries <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b6">7]</ref>, entailing rather intricate, possibly recursive, graph patterns prove difficult to evaluate, even on small-sized graph datasets <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>. On the other hand, the usage of these queries has radically increased in real-world query logs, as shown by recent empirical studies on SPARQL queries from large-scale Wikidata and DBPedia corpuses <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17]</ref>. As a tangible example of this growth, the percentage of SPARQL property paths has increased from 15% to 40%, from 2017 to beginning 2018 <ref type="bibr" target="#b16">[17]</ref>, for user-specified Wikidata queries. In this paper, we focus on regular path queries (RPQs) that identify paths labeled with regular expressions and aim to offer an approximate query evaluation solution. In particular, we consider counting queries with regular paths, which are a notable fragment of graph analytical queries. The exact evaluation of counting queries on graphs is #P -complete <ref type="bibr" target="#b20">[21]</ref> and is based on another result on enumeration of simple graph paths. Due to this intractability, an efficient and highly-accurate approximation of these queries is desirable, which we address in this paper. Ans(count( )) ← l2?( , ) Q3(l0) Ans(count( )) ← l + 0 ( , ) Q4(l0) Ans(count( )) ← l * 0 ( , ) Q5(l4, l1) Ans(count( )) ← l4 + l1( , ) Q6(l4, l5) Ans(count( )) ← l - 4 • l5( , ) Q7(l4, l5) Ans(count(x)) ← l - 4 • l5(x, ), ≥ (x.age, 18), ≤ (x.age, 24).</p><p>Fig. <ref type="figure">2</ref>: Targeted Advertising Queries</p><p>Approximate query processing on relational data and the related sampling methods are not applicable to graphs, since the adopted techniques are based on the linearity assumption <ref type="bibr" target="#b14">[15]</ref>, i.e., the existence of a linear relationship between the sample size and execution time, typical of relational query processing. As such, we design a novel query-driven graph summarization approach tailored for property graphs. These significantly differ from RDF and relational data models, as they attach data values to property lists on both nodes and edges <ref type="bibr" target="#b6">[7]</ref>.</p><p>To the best of our knowledge, ours is the first work on approximate property graph analytics addressing counting estimation on top of navigational graph queries. We illustrate our query fragment with the running example below.</p><p>Example 1 (Social Network Advertising). Let G SN (see Fig. <ref type="figure" target="#fig_0">1</ref>) be a property graph (see Sec. 2) encoding a social network, whose schema is inspired by the LDBC benchmark <ref type="bibr" target="#b11">[12]</ref> 4 . Entities are people (type Person, P i ) that know (l 0 ) and/or follow (l 1 ) either each other or certain forums (type Forum, F i ). These are moderated (l 2 ) by specific persons and can contain (l 3 ) messages/ads (type Message, M i ), to which persons can author (l 4 ) other messages in reply (l 5 ).</p><p>We focus on a RPQ <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23]</ref> dialect with counting, capturing following query types (Q 1 -Q 7 ) (see Fig. <ref type="figure">2</ref>): (1) Simple/Optional Label. The number of pairs satisfying Q 1 , i.e., () l5 -→(), counts the ad reactions, while that for Q 2 , i.e., () 4 One of the few benchmarks currently available for generating property graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions. Our paper provides the following main contributions:</head><p>-We design a property graph summarization algorithm for approximately evaluating counting regular path queries (Sec. 3). -We prove the intractability of the optimal graph summarization problem under the conditions of our summarization algorithm (Sec. 3). -We define a query translation module, ensuring that queries on the initial and summary property graphs are expressible in the same fragment (Sec. 4). -Based on this, we experimentally exhibit the small relative errors of various workloads, in the expressive query fragment from Example 1. We measure the relative response time between estimating counting recursive queries on summaries and on the original graphs. For non-recursive queries, we compare with SumRDF <ref type="bibr" target="#b18">[19]</ref>, a baseline graph summary for RDF datasets (Sec. 5).</p><p>In Section 2, we revisit the property graph model and query language. We present related work in Section 6 and conclude the paper in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Graph Model. We take the property graph model (PGM) <ref type="bibr" target="#b6">[7]</ref> as our foundation.</p><p>Graph instances are multi-edge digraphs; its objects are represented by typed, data vertices and their relationships, by typed, labeled edges. Vertices and edges can have any number of properties (key/value pairs). Let L V and L E be disjoint sets of vertex (edge) labels and G = (V, E), with E ⊆ V × L E × V , a graph instance. Vertices v ∈ V have an id label, l v , and a set of property labels (attributes, l i ), each with a (potentially undefined) term value. For e ∈ E, we use the binary notation e = l e (v 1 , v 2 ) and abbreviate v 1 , as e.1, and v 2 , as e.2. We denote the number of occurrences of l e , as #l e , and the set of all edge labels in G, as Λ(G). Other key notations henceforth used are given in Table <ref type="table">1</ref>.</p><p>G, Φ, v, V, e, E Graph, graph partitioning, vertex (set), edge (set) G * , v * , V * , e * , E * S-graph, s-node (set), s-edge (set) Ĝ, v, V , ê, Ê H-graph, h-node (set), h-edge (set)</p><formula xml:id="formula_0">λ(G) label on which a graph G is maximally l-connected Λ d (v * ), d ∈ {1, 2} set of edge labels with direction d w.r.t v * (1-incoming, 2-outgoing)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1: Notation Table</head><p>Graph Query Language. To query the above property graph model, we rely on an RPQ <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> fragment with aggregate operators (see Fig. <ref type="figure">3</ref>). RPQs correspond to SPARQL 1.1 property paths and are a well-studied query class tailored to express graph patterns of one or more label-constrained reachability paths. For labels l i e and vertices v i , the labeled path π, corresponding to v 1</p><formula xml:id="formula_1">l 1 e -→ v 2 . . . v k-1 l k e -→ v k , is the concatenation l 1 e • . . . • l k e .</formula><p>In their full generality, RPQs allow one to select vertices connected via such labeled paths in a regular language over</p><formula xml:id="formula_2">Clauses C ::= A ← A1, . . . , An | Q ← A1, . . . , An Queries Q ::= Ans(count( )) | Ans(count(lv)) | Ans(count(lv 1 , lv 2 )) Atoms A ::= π(lv 1 , lv 2 ) | op(lv 1 .li, lv 2 .lj) | op(lv 1 .li, k), op ∈ {&lt;, ≤, &gt;, ≥}, k ∈ R Paths π ::= | le | le? | l -1 e | l * e | le 1 • le 2 | π + π</formula><p>Fig. <ref type="figure">3</ref>: Graph Query Language L E . We restrict RPQs to handle atomic paths -bi-directional, optional, singlelabeled (l e , l e ?, and l - e ) and transitive single-labeled (l * e ) -and composite paths -conjunctive and disjunctive composition of atomic paths (l e • l e and π + π).</p><p>While not as general as SPARQL, our fragment already captures more than 60% of the property paths found in practice in SPARQL query logs <ref type="bibr" target="#b7">[8]</ref>. Moreover, it captures property path queries, as found in the large Wikidata corpus studied in <ref type="bibr" target="#b8">[9]</ref>. Indeed, almost all the property paths in the considered logs contain Kleenestar expressions over single labels. In our work, we enrich the above query classes with the count operator and support basic graph reachability estimates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Graph Summarization</head><p>We introduce a novel algorithm that summarizes any property graph into one tailored for approximately counting reachability queries. The key idea is that, as nodes and edges are compressed, informative properties are iteratively added to the corresponding newly formed structures, to enable accurate estimations.</p><p>The grouping phase (Sec. 3.1) computes Φ, a label-driven G-partitioning into subgroupings, following the connectivity on the most frequent labels in G. A first summarization collapses the vertices and inner-edges of each subgrouping into s-nodes and the edges connecting s-nodes, into s-edges. The merge phase (Sec. 3.2), based on further label-reachability conditions, specified by a heuristic mode m, collapses s-nodes into h-nodes and s-edges into h-edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Grouping Phase</head><p>For each frequently occurring label l in G, in descending order, we iteratively partition G into Φ, containing components that are connected on l, as below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Maximal L-Connectivity</head><formula xml:id="formula_3">). A G-subgraph 5 , G = (V , E ), is maximally l-connected, i.e., λ(G ) = l, iff 1) G is weakly-connected, 2</formula><p>) removing any l-labeled edge from E , there exists a V node pair not connected by a l +labeled undirected path, 3) no l-labeled edge connects a V node to V \ V . Example 2. In Fig. <ref type="figure" target="#fig_0">1</ref>, G 1 is maximally l 0 -connected, since it is weakly-connected, not connected by an l 0 -labeled edge to the rest of G, and such that, by removing P 8 l0 -→ P 9 , no undirected, l + 0 -labeled path unites P 8 and P 9 .  We call each such component a subgrouping. The procedure (see Alg.1) computes, as the first grouping, all the subgroupings for the most frequent label, l 1 , and then identifies those corresponding to the rest of the graph and to l 2 . At the end, all remaining nodes are collected into a final subgrouping. We illustrate this in Fig. <ref type="figure" target="#fig_3">4</ref>, on the running example below.</p><formula xml:id="formula_4">G1 G3 G2 P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 R1 R2 R3 R4 M1 M2 M3 F1 F2 M4 M5 M6 R5 R6 R7<label>l0</label></formula><p>Example 3 (Grouping). In Fig. <ref type="figure" target="#fig_0">1</ref>, #l 0 = 11, #l 1 = 3, #l 2 = 2, #l 3 = 6, #l 4 = #l 5 = 7, #l 6 = 1, and ---→ Λ(G) = [l 0 , l 5 , l 4 , l 3 , l 1 , l 2 , l 6 ], as #l 4 = #l 5 allows arbitrary ordering. We add the maximal l 0 -connected subgraph, G 1 , to Φ. Hence, V = {R i∈1,7 , M i∈1,6 , F 1 , F 2 }. Next, we add G 2 , regrouping the maximal l 5 -connected subgraph. Hence,</p><formula xml:id="formula_5">V = {F 1 , F 2 }; we add G 3 and output Φ = {G 1 , G 2 , G 3 }. Algorithm 1 GROUPING(G) Input: G -a graph; Output: Φ -a graph partitioning 1: n ← |Λ(G)|, ---→ Λ(G) ← [l1, . . . , ln], Φ ← ∅, i ← 1 Descending frequency label list ---→ Λ(G) 2: for all li ∈ ---→ Λ(G) do</formula><p>Label-driven partitioning computation <ref type="figure" target="#fig_3">4b</ref>). As such, each s-node gathers all the nodes and inner edges of a Φ-subgrouping, G * j , and each s-edge, all same-labeled cross-edges (edges between pairwise distinct s-nodes). During this phase, we compute analytics concerning the regrouped entities. We leverage PGM's expressivity to internalize these as properties, e.g., Fig. <ref type="figure" target="#fig_1">5</ref> (right) <ref type="foot" target="#foot_1">6</ref> . Hence, to every s-edge, e * , we attach EW eight, its number of compressed edges, e.g., in Fig. <ref type="figure" target="#fig_3">4b</ref>, all s-edges have weight 1, except e * (v * 4 , v * 1 ), with weight 2. To every s-node, v * , we attach properties concerning: (1) Compression. VWeight and EWeight store its number of inner vertices/edges.</p><formula xml:id="formula_6">3: Φ ← Φ ∪ {G * k = (V * k , E * k ) ⊆ G | λ(G * k ) = li} Maximally li-Connected Subgraphs 4: V ← V \ {v ∈ V * k | k ∈ N} Discard Already Considered Nodes 5: i ← i + 1 6: Φ ← Φ ∪ {Gi = (V * i , E * i ) ⊆ G | V * i = V \ V * } Collect Remains in Final Subgroup 7: return Φ A G-partitioning Φ (see Fig. 4a) is transformed into a s-graph G * = (V * , E * ) (see Fig.</formula><p>(2) Inner-Connectivity. The percentage of its l-labeled inner edges is LPercent and the number of its vertex pairs, connected with an l-labeled edge, is LReach. These first two types of properties will be useful in Sec.4, for estimating Kleene paths, as the labels of inner-edges in s-nodes are not unique, e.g., both l 0 and l 1 appear in v * 1 .</p><p>(3) Outer-Connectivity. For pairs of labels and direction indices with respect to v * (d = 1, for incoming edges, and d = 2, for outgoing ones), we compute cross-connectivity, CReach, as the number of binary cross-edge paths that start/end in v * . Analogously, we record that of binary traversal paths, i.e., formed of an inner v * edge and of a cross-edge, as T Reach. Also, for a label l and given direction, we store, as V F , the number of frontier vertices on l, i.e., that of v * nodes at either endpoint of a l-labeled s-edge.</p><p>We can thus record traversal connectivity information, LP art, dividing the number of traversal paths by that of the frontier vertices on the cross-edge label. Intuitively, this is due to the fact that, traversal connectivity, as opposed to cross connectivity, also needs to account for the "dispersion" of the inner-edge label of the path, within the s-node it belongs to. For example, for a traversal path l c • l i , formed of a cross-edge, l c , and an inner one, l i , not all frontier nodes l c are endpoints of l i labeled inner-edges, as we will see in the example below. Example 4 (Outer-Connectivity). Fig. <ref type="figure" target="#fig_1">5</ref> (left) depicts a stand-alone example, such that circles denote s-nodes, labeled arrows denote the s-edges relating them, and crosses represent nameless vertices, as we only label relevant ones, for simplicity. We use this configuration to illustrate analytics regarding cross and traversal connectivity on labels l 1 and l 2 . For instance, as we will see in Sec.4, when counting l 1 • l - 2 cross-edge paths, we will look at the CReach s-node properties mentioning these labels and note that there is a single such one, i.e., that corresponding to l 1 and l 2 appearing on edges incoming v * 1 , i.e., CReach(v * 1 , l 1 , l 2 , 1, 1) = 1. When counting l 1 • l 2 traversal paths, for the case when l 1 appears on the cross-edge, we will look at the properties of s-nodes containing l 2 inner-edges. Hence, for v * 2 , we note that there is a single such path, formed by an outgoing l 2 edge and incoming l 1 edge, as T Reach(v * 2 , l 1 , l 2 , 1, 1) = 1. To estimate the traversal connectivity we will divide this by the number of frontier vertices on incoming l 1 edges. As, V F (v * 2 , l 1 , 1) = {v 2 , v 3 }, we have that LPart(v * 2 , l 1 , l 2 , 1, 1) = 0.5.</p><formula xml:id="formula_7">VW eight v * 1 → 10, v * {2,3,5,6,7} → 2, v * 4 → 3, v * {8,9} → 1 EW eight v * 1 → 14, v * {2,3,5,6,7} → 1, v * 4 → 3, v * {8,9} → 0 LReach (v * 1 , l0) → 11, (v * 1 , l1) → 3 LP ercent (v * 1 , l0) → 79, (v * 1 , l1) → 21</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Merge Phase</head><p>We take as input the graph computed by Alg.1, and a label set and output a compressed graph, Ĝ = ( V , Ê). During this phase, sets of h-nodes, V , and h-edges, Ê, are created. At each step, as previously, Ĝ is enriched with approximationrelevant precomputed properties (see Sec. 4). Each h-node, v, merges all s-nodes, v * i , v * j ∈ V * , that are maximally label connected on the same label, i.e., λ(v * i ) = λ(v * j ), and that have either the same set of incoming (source-merge) or outgoing (target-merge) edge labels, i.e., </p><formula xml:id="formula_8">Λ d (v * i ) = Λ d (v * j ), d ∈ {1,</formula><formula xml:id="formula_9">Input: V * -s-nodes; Λ -labels; m -heuristic mode; Output: V -h-nodes 1: for all v * ∈ V * do 2: Λ d (v * ) ← {l ∈ Λ | ∃e * = l( , ) ∈ E * ∧ e.d = v * } Labels Incoming/Outgoing v * 3: for all v * 1 , v * 2 ∈ V * do</formula><p>Pair-wise S-node Inspection</p><formula xml:id="formula_10">4: b λ ← λ(v * 1 ) ? = λ(v * 2 ), b d ← Λ d (v * 1 ) ? = Λ d (v * 2 ), d ∈ {1, 2} Boolean Conditions 5: if m = true then v ← {v * 1 , v * 2 | b λ ∧ b1 = true} Target-Merge 6: else v ← {v * 1 , v * 2 | b λ ∧ b2 = true} Source-Merge 7: V ← {v k | k ∈ [1, |V * |]} H-node Computation</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8: return V</head><p>To each h-node, we attach properties, whose values, except LP ercent, are the sum of those corresponding to each of its s-nodes. For the label percentage, these values record the weighted percentage mean. Next, we merge s-edges into h-edges, if they have the same label and endpoints, and attach to each h-edge, its number of compressed s-edges, EW eight. We also record the avg. s-node weight, V * W eight, to estimate how many nodes a h-node compresses.</p><p>To formally characterize the graph transformation corresponding to our summarization technique, we first define the following function.</p><p>Definition 2 (Valid Summarization). For G = (V, E), a valid summarization function χ Λ : V → N assigns vertex identifiers, s.t., any vertices with the same identifier are either in the same maximally l-connected G-subgraph, or in different ones, not connected by an l-labeled edge.</p><p>A valid summary is thus obtained from G, by collapsing vertices with the same χ Λ into h-nodes and edges with the same (depending on the heuristic, ingoing/outgoing) label into h-edges. We illustrate this below.</p><p>Example 5 (Graph Compression). The graphs in Fig. <ref type="figure" target="#fig_3">4c</ref> are obtained from G * = (V * , E * ), after the merge phase. Each h-node contains the s-nodes (see Fig. <ref type="figure" target="#fig_3">4b</ref>) collapsed via the target-merge (left) and source-merge (right) heuristics.</p><p>We study our summarization's optimality, i.e., the size of the obtained compressed graph, to grasp its tractability. Specifically, we investigate the following MinSummary problem, to establish whether one can always minimize the number of nodes of an input graph, when constructing its valid summary.</p><p>Problem 1 (Minimal Summary). Let MinSummary be the problem that, for a graph G and an integer k ≥ 2, decides if there exists a label-driven partitioning Φ of G, |Φ| ≤ k , such that χ Λ is a valid summarization.</p><p>Each MinSummary h-node is thus intended to regroup as many nodes from the original graph as possible, while ensuring these are connected by frequently occurring labels. This condition (see Def. 2) reflects the central idea of our framework, namely that the connectivity of such prominent labels can serve to both compress a graph and to approximately evaluate label-constrained reachability queries. Next, we establish the difficulty of solving MinSummary. The intractability of constructing an optimal summary thus justifies our search for heuristics with good performance in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Approximate Query Evaluation</head><p>Query Translation. For G and a counting reachability query Q, we approximate Q G , the evaluation of Q over G. We translate Q into a query Q T , evaluated over the summarization Ĝ of G, s.t</p><formula xml:id="formula_11">Q T Ĝ ≈ Q G .</formula><p>The translations by input query type are given in Fig. <ref type="figure">6</ref>, with PGQL as concrete syntax. (1) Simple and Optional Label Queries. A label l occurs in Ĝ either within a h-node or on a crossedge. Thus, we either cumulate the number of l-labeled h-node inner-edges or the l-labeled cross-edge weights. To account for the potential absence of l, we also estimate, in the optional-label queries, the number of nodes in Ĝ, by cumulating those in each h-node. (2) Kleene Plus and Kleene Star Queries. To estimate l + , we cumulate the counts within h-nodes containing l-labeled inner-edges and the weights on l-labeled cross-edges. For the former, we distinguish whether the l + reachability is due to: 1) inner-connectivity -we use the property counting the inner l-paths; 2) incoming cross-edges -we cumulate the l-labeled in-degrees of h-nodes; or 3) outgoing cross-edges -we cumulate the number of outgoing l-paths. To handle the -label in l * , we also estimate the number of nodes in Ĝ.</p><p>(3) Disjunction. We treat each possible configuration, on both labels. Hence, we either cumulate the number of h-node inner-edges or that of cross-edge weights, with either label. (4) Binary Conjunction. We distinguish whether the label pair appears on an inner h-node path, on a cross-edge path, or on a traversal one. Example 6. We illustrate the approximate evaluation of these query types on Fig. <ref type="figure" target="#fig_3">4</ref>. To evaluate the number of single-label atomic paths, e.g., Q T L (l 5 ), as l 5 only occurs inside h-node v2 , l 5 Ĝ is the amount of l 5 -labeled inner edges in v2 , i.e., EW eight(v 2 , l 5 ) * LP ercent(v 2 , l 5 ) = 7. To estimate the number of optional label atomic paths, e.g., Q T O (l 2 ), we add to Q T L (l 2 ) the total number of graph vertices, v∈ V V * W eight(v) * VW eight(v) (empty case). As l 2 only appears on a h-edge of weight 2 and there are 25 initial vertices, l 2 ? Ĝ is 27. To estimate Kleene-plus queries, e.g., Q T P (l 0 ), as no h-edge has label l 0 , we return LReach(v 1 , l 0 ), i.e., the number of l 0 -connected vertex pairs. Thus, l + 0 Ĝ is 15. For Kleene-star, we add to this, the previously computed total number of vertices and obtain that l * 0 Ĝ is 40. For disjunction queries, e.g., l 4 + l 1 Ĝ , we cumulate the single-labeled atomic paths on each label, yielding 14. For binary conjunctions, e.g., l - 4 • l 5 Ĝ , we rely on the traversal connectivity, LP art(v * , l 4 , l 5 , 2, 2), as l 4 appears on a h-edge and, l 5 , inside h-nodes; we thus count 7 node pairs. SELECT COUNT(*) MATCH () -/:l+/-&gt; ()</p><formula xml:id="formula_12">Q L (l) SELECT COUNT(*) MATCH () -[:l]-&gt; () Q T L<label>(</label></formula><formula xml:id="formula_13">Q T P (l) SELECT SUM(x.LREACH_L) MATCH (x) WHERE x.LREACH_L &gt; 0 SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-&gt; () Q S (l)</formula><p>SELECT COUNT(*) MATCH () -/:l*/-&gt; () </p><formula xml:id="formula_14">Q T S (l) SELECT SUM(x.LREACH_L) MATCH (x) WHERE x.LREACH_L &gt; 0 SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-&gt; () SELECT SUM(x.AVG_SN_VWEIGHT * x.VWEIGHT) MATCH (x) Q D (l1, l2) SELECT COUNT(*) MATCH () -[:l1|l2]-&gt; () Q T D (l1, l2) SELECT SUM(x.LPERCENT_L1 * x.EWEIGHT + x.LPERCENT_L2 * x.EWEIGHT) MATCH (x) SELECT SUM(e.EWEIGHT) MATCH () -[e:l1|l2]-&gt; () Q C (l1, l2, 1, 1) SELECT COUNT(*) MATCH () -[:l1]-&gt; () &lt;-[:l2]-() Q C (l1, l2, 1, 2) SELECT COUNT(*) MATCH () -[:l1]-&gt; () -[:l2]-&gt; () Q C (l1, l2,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Analysis</head><p>In this section, we present an empirical evaluation of our graph summarization, recording (1) the succinctness of our summaries and the efficiency of the underlying algorithm and (2) the suitability of our summaries for approximate evaluation of counting label-constrained reachability queries. Setup, Datasets and Implementation. The summarization and approximation modules are implemented in Java using OpenJDK 1.8<ref type="foot" target="#foot_2">8</ref> . As the underlying graph database backend, we have used Oracle Labs PGX 3.1, which is the only property graph engine allowing for the evaluation of complex RPQs.</p><p>To implement the intermediate graph analysis operations (e.g., weakly connected components), we used the Green-Marl domain-specific language and mod-  ified the methods to fit the construction of node properties required by our summarization algorithm. We base our analysis on the graph datasets in Fig. <ref type="figure" target="#fig_8">7</ref>, encoding: a Bibliographic network (bib), the LDBC social network schema <ref type="bibr" target="#b11">[12]</ref> (social ), Uniprot knowledge graphs (uniprot), and the WatDiv schema <ref type="bibr" target="#b0">[1]</ref> (shop).</p><formula xml:id="formula_15">Dataset |L V | |L E | ∼ 1K ∼ 5K ∼ 25K ∼ 50K ∼ 100K ∼ 200K |V | |E| |V | |E| |V | |E| |V | |E| |V | |E| |V | |E| bib<label>5</label></formula><p>We obtained these datasets using gMark <ref type="bibr" target="#b4">[5]</ref>, a synthetic graph instance and query workload generator. As gMark tries to construct the instance that best fits the size parameter and schema constraints, the resulting sizes vary (especially for the very dense graphs social and shop). Next, on the same datasets, we generated workloads of varying sizes, for each type in Section 2. These datasets and related query workloads have been chosen since they provide the most recent benchmarks for recursive graph queries and also to ensure a comparison with SumRDF <ref type="bibr" target="#b18">[19]</ref> (as shown next) on a subset of those supported by the latter. Studies <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17]</ref> have shown that practical graph pattern queries formulated by users in online query endpoints are often small: 56.5% of real-life SPARQL queries consist of a single edge (RDF triple), whereas 90.8% use 6 edges at most. Hence, we select smallsized template queries with frequently occuring topologies, such as chains <ref type="bibr" target="#b7">[8]</ref>, and formulate them on our datasets, for workloads of ∼ 600 queries.</p><p>Experiments ran on a cloud VM with Intel Xeon E312xx, 4 cores, 1.80 GHz CPU, 128GB RAM, and Ubuntu 16.04.4 64-bit. Each data point corresponds to repeating an experiment 6 times, removing the first value from the average. Summary Compression Ratios. First, we evaluate the effect that using the source-merge and target-merge heuristics has on the summary construction time (SCT). We also assess the compression ratio (CR) on the original graph's vertices and edges, by measuring (1 -| V|/|V|) * 100 and, respectively, (1 -| Ê|/|E|) * 100.</p><p>Next, we compare the results for source and target merge. In Fig. <ref type="figure" target="#fig_9">8 (a-d</ref>), the most homogeneous datasets, shop and uniprot, achieve very high CR (close to 100%) and steadily maintain it with varying graph sizes. As far as heterogeneity significantly grows for bib and social, the CR becomes eagerly sensitive to the dataset size, starting with low values, for smaller graphs, and stabilizing between 85% and 90%, for larger ones. Notice also that bib and social, while similar, display a symmetric CR behavior: the former better compresses vertices, while the latter, edges. Concerning the SCT runtime in Fig. <ref type="figure" target="#fig_9">8 (e-f</ref>), all datasets keep a reasonable performance for larger sizes, even the most heterogeneous one shop. The runtime is, in fact, not affected by heterogeneity, but is rather sensitive, for larger sizes, to |E| variations (up to 450K and 773K, for uniprot and social ). Also, while the source and target merge SCT runtimes are similar, the latter achieves better CRs for social. Overall, the dataset with the worst CR for the two heuristics is shop, with the lowest CR for smaller sizes. This is also due to the CR Edges (%) 60 70 80 90 100 1 K 5 K 2 5 K 5 0 K 1 0 0 K 2 0 0 K q q q q q q (a) CR Edges (s-m) 60 70 80 90 100 1 K 5 K 2 5 K 5 0 K 1 0 0 K 2 0 0 K q q q q q q (b) CR Edges (t-m) Datasets:</p><p>q Shop Social Bib Uniprot CR Vertices (%) 92 94 96 98 100 1 K 5 K 2 5 K 5 0 K 1 0 0 K 2 0 0 K q q q q q q (c) CR Vertices (s-m) 85 90 95 100 1 K 5 K 2 5 K 5 0 K 1 0 0 K 2 0 0 K q q q q q q (d) CR Vertices (t-m) q Graph sizes (# nodes) Execution time (sec) 0 2000 6000 1 K 5 K 2 5 K 5 0 K 1 0 0 K 2 0 0 K q q q q q q (e) SCT (s-m) [sec] 0 2000 6000 1 K 5 K 2 5 K 5 0 K 1 0 0 K 2 0 0 K q q q q q q (f) SCT (t-m) [sec]  high number of labels in the initial shop instances, and, hence, to the high number of properties its summary needs: on average, for all considered sizes, 62.33 properties, against 17.67, for social graph, 10.0, for bib, and 14.0, for uniprot. These experiments show that, despite its high complexity, our summarization provides high CRs and low SCT runtimes, even for large, heterogeneous graphs. Approximate Evaluation Accuracy. We assess the accuracy and efficiency of our engine with the relative error and time gain measures, respectively. The relative error (per query</p><formula xml:id="formula_16">Q i ) is 1 -min(Q i (G), Q T i ( Ĝ))/ max(Q i (G), Q T i ( Ĝ)) (in %)</formula><p>, where Q i (G) computes (with PGX) the counting query Q i , on the original graph, and Q T i ( Ĝ) computes (with our engine) the translated query Q T i , on the summary. The time gain is: t G -t Ĝ /max(t G , t Ĝ ) (in %), where t G and t Ĝ are the query evaluation times of Q i on the original graph and on the summary.</p><p>For the Disjunction, Kleene-plus, Kleene-star, Optional and Single Label query types, we have generated workloads of different sizes, bound by the number of labels in each dataset. For the concatenation workloads, we considered binary conjunctive queries (CQs) without disjunction, recursion, or optionality. Note that, currently, our summaries do not support compositionality. Fig. <ref type="figure" target="#fig_10">9</ref> (a) and (b) show the relative error and average time gain for the Disjunction, Kleene-plus, Kleene-star, Optional and Single Label workloads. In Fig. <ref type="figure" target="#fig_10">9</ref> (a), we note that the avg. relative error is kept low in all cases and is bound by 5.5%, for the Kleene-plus and Kleene-star workloads of the social dataset. In all the other cases, including the Kleene-plus and Kleene-star workloads of the shop dataset, the error is relatively small (near 0%). This confirms the effectiveness of our graph summaries for approximate evaluation of graph queries. In Fig. <ref type="figure" target="#fig_10">9</ref> (b), we studied the efficiency of approximate evaluation on our summaries by reporting the time gain (in %) compared with the query evaluation on the original graphs for the four datasets. We notice a positive time gain (≥ 75%) in most cases, but for disjunction. While the relative approximation error is still advantageous for disjunction, disjunctive queries are time-consuming for approximate evaluation on our summaries, especially for extremely heterogeneous datasets, such as shop (having the most labels). This is due to the overhead introduced by considering all possible connectivity combinations on the disjunctive labels. The problem of scaling our method, without prohibitive accuracy loss, to queries involving multiple labels and further compositionality, e.g., Kleene-star over disjunctions <ref type="bibr" target="#b21">[22]</ref>, is challenging and falls under the scope of future work.</p><p>Baseline for approximate query evaluation performance. The closest system to ours is SumRDF <ref type="bibr" target="#b18">[19]</ref> (see Section 6), which, however, operates on a simpler edge-labeled model rather than on property graphs and is tailored for estimating the results of conjunctive queries only. As a performance baseline, we considered the shop dataset in gMark <ref type="bibr" target="#b4">[5]</ref>, simulating the WatDiv benchmark <ref type="bibr" target="#b0">[1]</ref> (also a benchmark in <ref type="bibr" target="#b18">[19]</ref>). From this dataset with 31K nodes and 56K edges, we generated the corresponding SumRDF and our summaries. We obtained a better CR than SumRDF, with 2737 nodes vs. 3480 resources and 17430 edges vs. 29621 triples. This comparison is, however, tentative, as our approach compresses vertices independently of the edges, while SumRDF returns triples. We then considered the same CQ types as in Fig. <ref type="figure" target="#fig_5">10</ref>. Comparing our approach vs. SumRDF (see Fig. <ref type="figure" target="#fig_5">10</ref>), we recorded an average relative error of estimation of only 0.15%. vs. 2.5% and an average query runtime of only 27.55 ms vs. 427.53 ms. As SumRDF does not support disjunctions, Kleene-star/plus queries and optional queries, further comparisons were not possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Preliminary work on approximate graph analytics in a distributed setting has recently been pursued in <ref type="bibr" target="#b14">[15]</ref>. They rather focus on a graph sparsification technique and small samples, in order to approximate the results of specific graph algorithms, such as PageRank and triangle counting on undirected graphs. In contrast, our approach operates in a centralized setting and relies on querydriven graph summarization for graph navigational queries with aggregates.</p><p>RDF graph summarization for cardinality estimation has been tackled in <ref type="bibr" target="#b18">[19]</ref>, albeit for a less expressive data model than ours (plain RDF vs. property graphs). They focus on Basic Graph Patterns (BGP), hence their considered query fragment has limited overlap with ours. As shown in Section 5, our approximate evaluation is faster and more accurate on a common set of (non recursive) queries.</p><p>An algorithm for answering graph reachability queries, using graph simulation based pattern matching, is given in <ref type="bibr" target="#b12">[13]</ref>, to construct query preserving summaries. However, it does not consider property graphs or aggregates.</p><p>Aggregation-based graph summarization <ref type="bibr" target="#b15">[16]</ref> is at the heart of previous approaches, the most notable of which is SNAP <ref type="bibr" target="#b19">[20]</ref>. This method is mainly devoted to discovery-driven graph summarization of heterogeneous networks and is unsuitable for approximate query evaluation.</p><p>More recently, Rudolf et al. <ref type="bibr" target="#b17">[18]</ref> have introduced a graph summary suitable for property graphs based on a set of input summarization rules. However, it does not support the label-constrained reachability queries in this paper. Graph summaries for answering subgraphs returned by keyword queries on large networks are studied in <ref type="bibr" target="#b23">[24]</ref>. Our query classes significantly differ from theirs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>Our paper focuses on a novel graph summarization method that is suitable for property graph querying. As the underlying MinSummary decision problem is NP-complete, this technique builds on an heuristic that compresses label frequency information in the nodes of the graph summary. We show the practical effectiveness of our approach, in terms of compression ratios, error rates and query evaluation time. As future work, we plan to investigate the feasibility of our graph summary for other query classes, such as those described in <ref type="bibr" target="#b21">[22]</ref>. Also, we aim to apply formal methods, as described in <ref type="bibr" target="#b5">[6]</ref>, to ascertain the correctness of our approximation algorithm, with provably tight error bounds.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Example Social Graph G SN</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>( 5 )</head><label>5</label><figDesc>indicates the number of potential moderators. (2) Kleene Plus/Kleene Star. The number of the connected /potentially connected acquaintances is the count of node pairs satisfying Q 3 , i.e., () ← l + 0 (), respectively, Q 4 , i.e., () ← l * 0 (). (3) Disjunction. The number of the targeted subscribers is the sum of counting all node pairs satisfying Q 5 , i.e., () l4 ← -() or () l1 ← -(). (4) Conjunction. The direct reach of a company via its page ads is the count of node pairs satisfying Q 6 , i.e., () Conjunction with Property Filters. Recommendation systems can further refine the Q 6 estimates. Thus, one can compute the direct demographic reach and target people within an age group, e.g., 18-24, by counting all node pairs that satisfy Q 7 , i.e. (x) l4 ← -() l5 -→(), s.t x.age ≥ 18 and x.age ≤ 24.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 l 3 l 3 l 3 l 3 l 3 l 3 l 6 (</head><label>2336</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 :</head><label>4</label><figDesc>Fig. 4: Summarization Phases for G SN</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Selected Properties for Fig.4b (right); Frontier Vertices (left);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 1 (</head><label>1</label><figDesc>MinSummary NP-completeness). Even for undirected graphs, |Λ(G)| ≤ 2, and k = 2, MinSummary is NP-complete 7 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>l) SELECT SUM(x.LPERCENT_L * x.EWEIGHT) MATCH (x) SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-&gt; () Q O (l) SELECT COUNT(*) MATCH () -[:l?]-&gt; () Q T O SELECT SUM(x.LPERCENT_L * x.EWEIGHT) MATCH (x) SELECT SUM(e.EWEIGHT) MATCH () -[e:l]-&gt; () SELECT SUM(x.AVG_SN_VWEIGHT * x.VWEIGHT) MATCH (x) Q P (l)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>2 , 1 )Fig. 6 :</head><label>216</label><figDesc>Fig. 6: Query translations onto the graph summary.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: Datasets: no. of vertices |V |, edges |E|, vertex |L V | and edge labels |L E |.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: CRs for vertices and edges, along with SCT runtime for various dataset sizes, for both source-merge (a-c-e), and target-merge (b-d-f).</figDesc><graphic coords="12,133.23,295.48,172.92,99.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: Rel. Error (a), Time Gain (b) per Workload, per Dataset, 200K nodes.</figDesc><graphic coords="12,312.29,295.48,172.92,99.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>2} (see Alg. 2). Each h-edge, ê, merges all s-edges in E * with the same label and orientation, i.e., e * i .d = e * j .d, for d ∈ {1, 2}.</figDesc><table><row><cell>Algorithm 2 MERGE(V</cell></row></table><note><p>* , Λ, m)</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>SELECT COUNT(*) MATCH Q i , on the summaries of a shop graph instance (31K nodes, 56K edges); comparing estimated cardinality (no. of computed answers), rel. error w.r.t the original graph results, and query runtime.</figDesc><table><row><cell>ID</cell><cell>Query Body</cell><cell cols="6">Approx. Answer Rel. Error (%) Runtime (ms) SumRDF APP SumRDF APP SumRDF APP</cell></row><row><cell cols="2">Q1 (x0)-[:producer]-&gt;()&lt;-[:paymentAccepted]-(x1)</cell><cell>75</cell><cell>76</cell><cell>1.32</cell><cell cols="3">0.00 136.30 38.2</cell></row><row><cell cols="2">Q2 (x0)-[:totalVotes]-&gt;()&lt;-[:price]-(x1)</cell><cell>42.4</cell><cell>44</cell><cell>3.64</cell><cell>0.00</cell><cell>50.99</cell><cell>17</cell></row><row><cell cols="2">Q3 (x0)-[:jobTitle]-&gt;()&lt;-[:keywords]-(x1)</cell><cell>226.7</cell><cell>221</cell><cell>2.51</cell><cell cols="3">0.18 463.85 12.8</cell></row><row><cell cols="2">Q4 (x0)&lt;-[:title]-()-[:performedIn]-&gt;(x1)</cell><cell>19.5</cell><cell>20</cell><cell>2.50</cell><cell cols="2">0.00 831.72</cell><cell>8.8</cell></row><row><cell cols="2">Q5 (x0)-[:artist]-&gt;()&lt;-[:employee]-(x1)</cell><cell>143.3</cell><cell>133</cell><cell>7.19</cell><cell cols="3">0.37 196.77 10.6</cell></row><row><cell cols="2">Q6 (x0)-[:follows]-&gt;()&lt;-[:editor]-(x1)</cell><cell>524</cell><cell>528</cell><cell>0.38</cell><cell cols="3">0.48 1295.83 19</cell></row><row><cell cols="8">Fig. 10: Performance Comparison: SumRDF vs. APP (our approach): approx.</cell></row><row><cell cols="2">eval. of binary CQs,</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_0"><p>G is a G-subgraph iff V ⊆ V and E ⊆ E and is weakly connected iff there exists an undirected path between any pair of vertices.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_1"><p>All corresponding formulas are provided in the additional material.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_2"><p>Available at: https://github.com/grasp-algorithm/label-driven-summarization.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Diversified stress testing of RDF data management systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Aluç</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Özsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Daudjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="197" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">G-CORE: A core for future graph query languages</title>
		<author>
			<persName><forename type="first">R</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H L</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gutierrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Paradies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Plantikow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Sequeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Van Rest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Voigt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1421" to="1432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Foundations of modern query languages for graph databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vrgoc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">40</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Counting beyond a Yottabyte, or how SPARQL 1.1 property paths will prevent adoption of the standard</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Conca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="629" to="638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">gmark: Schema-driven generation of graphs and queries</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ciucanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H L</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lemay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Advokaat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="856" to="869" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Certified graph view maintenance with Regular Datalog</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dumbrava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J G</forename><surname>Arias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TPLP</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="372" to="389" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Querying Graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yakovets</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Synthesis Lectures on Data Management</title>
		<imprint>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An analytical study of large SPARQL query logs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Timm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="161" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Navigating the maze of Wikidata query logs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Timm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="127" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Rewriting of regular expressions and regular path queries</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="443" to="465" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A graphical query language supporting recursion</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="323" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The LDBC Social Network Benchmark: Interactive Workload</title>
		<author>
			<persName><forename type="first">O</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Averbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Prat-Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="619" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Query preserving graph compression</title>
		<author>
			<persName><forename type="first">W</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-MOD</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="157" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Querying wikidata: Comparing sparql, relational and graph databases</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riveros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rojas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Zerega</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="88" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Bridging the GAP: towards approximate graph analytics</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkataraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">GRADES</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Summarizing static and dynamic big graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Bhowmick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Bonchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1981" to="1984" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Getting the most out of wikidata: Semantic technology usage in wikipedia&apos;s knowledge graph</title>
		<author>
			<persName><forename type="first">S</forename><surname>Malyshev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krotzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonsior</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bielefeldt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Synopsys: Foundations for multidimensional graph analytics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rudolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bornhövd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lehner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BIRTE</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Estimating the cardinality of conjunctive queries over rdf data using graph summarisation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Stefanoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1043" to="1052" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient aggregation for graph summarization</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Hankins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="567" to="580" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The complexity of enumeration and reliability problems</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="410" to="421" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Landmark indexing for evaluation of label-constrained reachability queries</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D J</forename><surname>Valstar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H L</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="345" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Query languages for graph databases</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">T</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="50" to="60" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Summarizing answer graphs induced by keyword queries</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Srivatsa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Iyengar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="1774" to="1785" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
