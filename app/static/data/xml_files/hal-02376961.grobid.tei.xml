<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Correlation Clustering with Adaptive Similarity Queries</title>
				<funder>
					<orgName type="full">Digital Markets (ALGADIMAR)</orgName>
				</funder>
				<funder ref="#_au6cRqE">
					<orgName type="full">Google Focused Award &quot;Algorithms and Learning for AI</orgName>
				</funder>
				<funder>
					<orgName type="full">MIUR PRIN grant Algorithms, Games</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marco</forename><surname>Bressan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Rome Sapienza</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">DSRC</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicolo</forename><surname>Cesa-Bianchi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Rome Sapienza</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andrea</forename><surname>Paudice</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Rome Sapienza</orgName>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science degli Studi di Milano &amp; IIT</orgName>
								<orgName type="institution">Università</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fabio</forename><surname>Vitale</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Rome Sapienza</orgName>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">University of Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Nicolò</forename><surname>Cesa-Bianchi</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Università degli Studi di Milano</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Correlation Clustering with Adaptive Similarity Queries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C42ABAD6A88C6DC5C424A6BC4AE58EF3</idno>
					<note type="submission">Submitted on 22 Nov 2019</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Clustering is a central problem in unsupervised learning. A clustering problem is typically represented by a set of elements together with a notion of similarity (or dissimilarity) between them. When the elements are points in a metric space, dissimilarity can be measured via a distance function. In more general settings, when the elements to be clustered are members of an abstract set V , similarity is defined by an arbitrary symmetric function σ defined on pairs of distinct elements in V . Correlation Clustering (CC) <ref type="bibr" target="#b2">[3]</ref> is a well-known special case where σ is a {-1, +1}-valued function establishing whether any two distinct elements of V are similar or not. The objective of CC is to cluster the points in V so to maximize the correlation with σ. More precisely, CC seeks a clustering minimizing the number of errors, where an error is given by any pair of elements having similarity -1 and belonging to the same cluster, or having similarity +1 and belonging to different clusters. Importantly, there are no a priori limitations on the number of clusters or their sizes: all partitions of V , including the trivial ones, are valid. Given V and σ, the error achieved by an optimal clustering is known as the Correlation Clustering index, denoted by OPT. A convenient way of representing σ is through a graph G = (V, E) where {u, v} ∈ E iff σ(u, v) = +1. Note that OPT = 0 is equivalent to a perfectly clusterable graph (i.e., G is the union of disjoint cliques). Since its introduction, CC has attracted a lot of interest in the machine learning community, and has found numerous applications in entity resolution <ref type="bibr" target="#b15">[16]</ref>, image analysis <ref type="bibr" target="#b17">[18]</ref>, and social media analysis <ref type="bibr" target="#b23">[24]</ref>. Known problems in data integration <ref type="bibr" target="#b12">[13]</ref> and biology <ref type="bibr" target="#b3">[4]</ref> can be cast into the framework of CC <ref type="bibr" target="#b24">[25]</ref>.</p><p>From a machine learning viewpoint, we are interested in settings when the similarity function σ is not available beforehand, and the algorithm must learn σ by querying for its value on pairs of objects. This setting is motivated by scenarios in which the similarity information is costly to obtain. For example, in entity resolution, disambiguating between two entities may require invoking the user's help. Similarly, deciding if two documents are similar may require a complex computation, and possibly the interaction with human experts. In these active learning settings, the learner's goal is to trade the clustering error against the number of queries. Hence, the fundamental question is: how many queries are needed to achieve a specified clustering error? Or, in other terms, how close can we get to OPT, under a prescribed query budget Q?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contributions</head><p>In this work we characterize the trade-off between the number Q of queries and the clustering error on n points. The table below here summarizes our bounds in the context of previous work. Running time and upper/lower bounds on the expected clustering error are expressed in terms of the number of queries Q, and all our upper bounds assume Q = Ω(n) while our lower bounds assume Q = O(n 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Running time</head><p>Expected clustering error Reference</p><formula xml:id="formula_0">Q + LP solver + rounding 3(ln n + 1)OPT + O n 5/2 / √ Q [6] Q 3OPT + O(n 3 /Q)</formula><p>Theorem 1 (see also <ref type="bibr" target="#b4">[5]</ref>)</p><formula xml:id="formula_1">Exponential OPT + O n 5/2 / √ Q Theorem 7 Exponential (OPT = 0) O n 3 /Q Theorem 7 Unrestricted (OPT = 0) Ω n 2 / √ Q Theorem 8 Unrestricted (OPT 0) OPT + Ω n 3 /Q Theorem 9</formula><p>Our first set of contributions is algorithmic. We take inspiration from an existing greedy algorithm, KwikCluster <ref type="bibr" target="#b1">[2]</ref>, that has expected error 3OPT but a vacuous O(n 2 ) worst-case bound on the number of queries. We propose a variant of KwikCluster, called ACC, for which we prove several desirable properties. First, ACC achieves expected clustering error 3OPT + O(n 3 /Q), where Q = Ω(n) is a deterministic bound on the number of queries. In particular, if ACC is run with Q = n 2 , then it becomes exactly equivalent to KwikCluster. Second, ACC recovers adversarially perturbed latent clusters. More precisely, if the input contains a cluster C obtained from a clique by adversarially perturbing a fraction ε of its edges (internal to the clique or leaving the clique), then ACC returns a cluster C such that E |C ⊕ C| = O ε|C| + n 2 /Q , where ⊕ denotes symmetric difference. This means that ACC recovers almost completely all perturbed clusters that are large enough to be "seen" with Q queries. We also show, under stronger assumptions, that via independent executions of ACC one can recover exactly all large clusters with high probability. Third, we show a variant of ACC, called ACCESS (for Early Stopping Strategy), that makes significantly less queries on some graphs. For example, when OPT = 0 and there are Ω n 3 /Q similar pairs, the expected number of queries made by ACCESS is only the square root of the queries made by ACC. In exchange, ACCESS makes at most Q queries in expectation rather than deterministically.</p><p>Our second set of contributions is a nearly complete information-theoretic characterization of the query vs. clustering error trade-off (thus, ignoring computational efficiency). Using VC theory, we prove that for all Q = Ω(n) the strategy of minimizing disagreements on a random subset of pairs achieves, with high probability, clustering error bounded by OPT + O n 5/2 / √ Q , which reduces to O n 3 /Q when OPT = 0. The VC theory approach can be applied to any efficient approximation algorithm, too. The catch is that the approximation algorithm cannot ask the similarity of arbitrary pairs, but only of pairs included in the random sample of edges. The best known approximation factor in this case is 3(ln n + 1) <ref type="bibr" target="#b13">[14]</ref>, which gives a clustering error bound of 3(ln n + 1)OPT + O n 5/2 / √ Q with high probability. This was already observed in <ref type="bibr" target="#b5">[6]</ref> albeit in a slightly different context.</p><p>We complement our upper bounds by developing two information-theoretic lower bounds; these lower bounds apply to any algorithm issuing Q = O(n 2 ) queries, possibly chosen in an adaptive way. For the general case, we show that any algorithm must suffer an expected clustering error of at least OPT + Ω n 3 /Q . In particular, for Q = Θ(n 2 ) any algorithm still suffers an additive error of order n, and for Q = Ω(n) our algorithm ACC is essentially optimal in its additive error term. For the special case OPT = 0, we show a lower bound Ω n 2 / √ Q .</p><p>Finally, we evaluate our algorithms empirically on real-world and synthetic datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>Minimizing the correlation clustering error is APX-hard <ref type="bibr" target="#b7">[8]</ref>, and the best efficient algorithm found so far achieves 2.06 OPT <ref type="bibr" target="#b8">[9]</ref>. This almost matches the best possible approximation factor 2 achievable via the natural LP relaxation of the problem <ref type="bibr" target="#b7">[8]</ref>. A very simple and elegant algorithhm for approximating CC is KwikCluster <ref type="bibr" target="#b1">[2]</ref>. At each round, KwikCluster draws a random pivot π r from V , queries the similarities between π r and every other node in V , and creates a cluster C containing π r and all points u such that σ(π r , u) = +1. The algorithm then recursively invokes itself on V \ C. On any instance of CC, KwikCluster achieves an expected error bounded by 3OPT. However, it is easy to see that KwikCluster makes Θ(n 2 ) queries in the worst case (e.g., if σ is the constant function -1).</p><p>Our algorithms can be seen as a parsimonious version of KwikCluster whose goal is reducing the number of queries.</p><p>The work closest to ours is <ref type="bibr" target="#b4">[5]</ref>. Their algorithm runs KwikCluster on a random subset of 1/(2ε) nodes and stores the set Π of resulting pivots. Then, each node v ∈ V \ Π is assigned to the cluster identified by the pivot π ∈ Π with smallest index and such that σ(v, π) = +1. If no such pivot is found, then v becomes a singleton cluster. According to <ref type="bibr" target="#b4">[5,</ref><ref type="bibr">Lemma 4</ref>.1], the expected clustering error for this variant is 3OPT + O εn 2 , which can be compared to our bound for ACC by setting Q = n/ε. On the other hand our algorithms are much simpler and significantly easier to analyze. This allows us to prove a set of additional properties, such as cluster recovery and instance-dependent query bounds. It is unclear whether these results are obtainable with the techniques of <ref type="bibr" target="#b4">[5]</ref>.</p><p>Another line of work attempts to circumvent computational hardness by using the more powerful same-cluster queries (SCQ). A same-cluster query tells whether any two given nodes are clustered together according to an optimal clustering or not. In [? ] SCQs are used to design a FPTAS for a variant of CC with bounded number of clusters. In [? ] SCQs are used to design algorithms for solving CC optimally by giving bounds on Q which depend on OPT. Unlike our setting, both works assume all n 2 similarities are known in advance. The work <ref type="bibr" target="#b20">[21]</ref> considers the case in which there is a latent clustering with OPT = 0. The algorithm can issue SCQs, however the oracle is noisy: each query is answered incorrectly with some probability, and the noise is persistent (repeated queries give the same noisy answer). The above setting is closely related to the stochastic block model (SBM), which is a well-studied model for cluster recovery <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b21">22]</ref>. However, few works investigate SBMs with pairwise queries <ref type="bibr" target="#b10">[11]</ref>. Our setting is strictly harder because our oracle has a budget of OPT adversarially incorrect answers.</p><p>A different model is edge classification. Here the algorithm is given a graph G with hidden binary labels on the edges. The task is to predict the sign of all edges by querying as few labels as possible <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b11">12]</ref>. As before, the oracle can have a budget OPT of incorrect answers, or a latent clustering with OPT = 0 is assumed and the oracle's answers are affected by persistent noise. Unlike correlation clustering, in edge classification the algorithm is not constrained to predict in agreement with a partition of the nodes. On the other hand, the algorithm cannot query arbitrary pairs of nodes in V , but only those that form an edge in G.</p><p>Preliminaries and notation. We denote by V ≡ {1, . . . , n} the set of input nodes, by E ≡ V 2 the set of all pairs {u, v} of distincts nodes in V , and by σ : E → {-1, +1} the binary similarity function. A clustering C is a partition of V in disjoint clusters C i : i = 1, . . . , k. Given C and σ, the set Γ C of mistaken edges contains all pairs {u, v} such that σ(u, v) = -1 and u, v belong to same cluster of C and all pairs {u, v} such that σ(u, v) = +1 and u, v belong to different clusters of C.</p><formula xml:id="formula_2">The cost ∆ C of C is Γ C . The correlation clustering index is OPT = min C ∆ C</formula><p>, where the minimum is over all clusterings C. We often view V, σ as a graph G = (V, E) where {u, v} ∈ E is an edge if and only if σ(u, v) = +1. In this case, for any subset U ⊆ V we let G[U ] be the subgraph of G induced by U , and for any v ∈ V we let N v be the neighbor set of v.</p><p>A triangle is any unordered triple T = {u, v, w} ⊆ V . We denote by e = {u, w} a generic triangle edge; we write e ⊂ T and v ∈ T \ e. We say T is a bad triangle if the labels σ(u, v), σ(u, w), σ(v, w) are {+, +, -} (the order is irrelevant). We denote by T the set of all bad triangles in V . It is easy to see that the number of edge-disjoint bad triangles is a lower bound on OPT.</p><p>Due to space limitations, here most of our results are stated without proof, or with a concise proof sketch; the full proofs can be found in the supplementary material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The ACC algorithm</head><p>We introduce our active learning algorithm ACC (Active Correlation Clustering).</p><p>Algorithm 1 Invoked as ACC(V 1 , 1) where V 1 ≡ V and r = 1 is the index of the recursive call.</p><formula xml:id="formula_3">Parameters: Query rate function f : N → N. 1: if |V r | = 0 ∨ r &gt; f (|V 1 | -1) then RETURN 2:</formula><p>Draw pivot π r u.a.r. from V r 3: C r ← {π r } Create new cluster and add the pivot to it 4: Draw a random subset S r of f (|V r | -1) nodes from V r \ {π r } 5: for each u ∈ S r do query σ(π r , u)</p><formula xml:id="formula_4">6: if ∃ u ∈ S r such that σ(π r , u) = +1 then</formula><p>Check if there is at least a positive edge 7:</p><p>Query all remaining pairs (π r , u) for u ∈ V r \ {π r } ∪ S r 8:</p><formula xml:id="formula_5">C r ← C r ∪ {u : σ(π r , u) = +1}</formula><p>Populate cluster based on queries 9: Output cluster C r 10: ACC(V r \ C r , r + 1)</p><p>Recursive call on the remaining nodes ACC has the same recursive structure as KwikCluster. First, it starts with the full instance V 1 = V . Then, for each round r = 1, 2, . . . it selects a random pivot π r ∈ V r , queries the similarities between π r and a subset of V r , removes π r and possibly other points from V r , and proceeds on the remaining residual subset V r+1 . However, while KwikCluster queries σ(π r , u) for all u ∈ V r \ {π r }, ACC queries only f (n r ) ≤ n r other nodes u (lines 4-5), where n r = |V r | -1. Thus, while KwikCluster always finds all positive labels involving the pivot π r , ACC can find them or not, with a probability that depends on f . The function f is called query rate function and dictates the tradeoff between the clustering cost ∆ and the number of queries Q, as we prove below. Now, if any of the aforementioned f (n r ) queries returns a positive label (line 6), then all the labels between π r and the remaining u ∈ V r are queried and the algorithm operates as KwikCluster until the end of the recursive call; otherwise, the pivot becomes a singleton cluster which is removed from the set of nodes. Another important difference is that ACC deterministically stops after f (n) recursive calls (line 1), declaring all remaining points as singleton clusters. The intuition is that with good probability the clusters not found within f (n) rounds are small enough to be safely disregarded. Since the choice of f is delicate, we avoid trivialities by assuming f is positive, integral, and smooth enough. Formally:</p><formula xml:id="formula_6">Definition 1. f : N → N is a query rate function if f (1) = 1 and f (n) ≤ f (n + 1) ≤ 1 + 1 n f (n) for all n ∈ N. This implies f (n+k) n+k ≤ f (n) n for all k ≥ 1.</formula><p>We can now state formally our bounds for ACC. Theorem 1. For any query rate function f and any labeling σ on n nodes, the expected cost E[∆ A ] of the clustering output by ACC satisfies</p><formula xml:id="formula_7">E[∆ A ] ≤ 3OPT + 2e -1 2(e -1)</formula><formula xml:id="formula_8">n 2 f (n) + n 2e .</formula><p>The number of queries made by ACC is deterministically bounded as Q ≤ nf (n). In the special case f (n) = n for all n ∈ N, ACC reduces to KwikCluster and achieves</p><formula xml:id="formula_9">E[∆ A ] ≤ 3OPT with Q ≤ n 2 .</formula><p>Note that Theorem 1 gives an upper bound on the error achievable when using Q queries: since Q = nf (n), the expected error is at most 3OPT + O(n 3 /Q). Furthermore, as one expects, if the learner is allowed to ask for all edge signs, then the exact bound of KwikCluster is recovered (note that the first formula in Theorem 1 clearly does not take into account the special case when f (n) = n, which is considered in the last part of the statement).</p><p>Proof sketch. Look at a generic round r, and consider a pair of points {u, w} ∈ V r . The essence is that ACC can misclassify {u, w} in one of two ways. First, if σ(u, w) = -1, ACC can choose as pivot π r a node v such that σ(v, u) = σ(v, w) = +1. In this case, if the condition on line 6 holds, then ACC will cluster v together with u and w, thus mistaking {u, w}. If instead σ(u, w) = +1, then ACC could mistake {u, w} by pivoting on a node v such that σ(v, u) = +1 and σ(v, w) = -1, and clustering together only v and u. Crucially, both cases imply the existence of a bad triangle T = {u, w, v}. We charge each such mistake to exactly one bad triangle T , so that no triangle is charged twice. The expected number of mistakes can then be bound by 3OPT using the packing argument of <ref type="bibr" target="#b1">[2]</ref> for KwikCluster. Second, if σ(u, w) = +1 then ACC could choose one of them, say u, as pivot π r , and assign it to a singleton cluster. This means the condition on line 6 fails. We can then bound the number of such mistakes as follows. Suppose π r has cn/f (n) positive labels towards V r for some c ≥ 0. Loosely speaking, we show that the check of line 6 fails with probability e -c , in which case cn/f (n) mistakes are added. In expectation, this gives cne -c /f (n) = O n/f (n) mistakes. Over all f (n) ≤ n rounds, this gives an overall O n 2 /f (n) . (The actual proof has to take into account that all the quantities involved here are not constants, but random variables).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">ACC with Early Stopping Strategy</head><p>We can refine our algorithm ACC so that, in some cases, it takes advantage of the structure of the input to reduce significantly the expected number of queries. </p><formula xml:id="formula_10">E[∆ A ] ≤ 3OPT + n 2 ef (n) + n 2e .</formula><p>Moreover, the expected number of queries performed by</p><formula xml:id="formula_11">ACCESS is E[Q] ≤ n(2f (n) + 1).</formula><p>Theorem 2 reassures us that ACCESS is no worse than ACC. In fact, if most edges of G belong to relatively large clusters (namely, all but O(n 2 /f (n)) edges), then we can show ACCESS uses much fewer queries than ACC (in a nutshell, ACCESS quickly finds all large clusters and then quits). The following theorem captures the essence. For simplicity we assume OPT = 0, i.e. G is a disjoint union of cliques. Theorem 3. Suppose OPT = 0 so G is a union of disjoint cliques. Let C 1 , . . . , C be the cliques of G in nondecreasing order of size. Let i be the smallest i such that</p><formula xml:id="formula_12">i j=1 |E Cj | = Ω(n 2 /f (n)), and let h(n) = |C i |. Then ACCESS makes in expectation E[Q] = O n 2 lg(n)/h(n) queries. As an example, say f (n) = √ n and G contains n 1/3 cliques of n 2/3 nodes each. Then for ACC The- orem 1 gives Q ≤ nf (n) = O(n 3/2 ), while for ACCESS Theorem 3 gives E[Q] = O(n 4/3 lg(n)).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Cluster recovery</head><p>In the previous section we gave bounds on E[∆], the expected total cost of the clustering. However, in applications such as community detection and alike, the primary objective is recovering accurately the latent clusters of the graph, the sets of nodes that are "close" to cliques. This is usually referred to as cluster recovery. For this problem, an algorithm that outputs a good approximation C of every latent cluster C is preferrable to an algorithm that minimizes E[∆] globally. In this section we show that ACC natively outputs clusters that are close to the latent clusters in the graph, thus acting as a cluster recovery tool. We also show that, for a certain type of latent clusters, one can amplify the accuracy of ACC via independent executions and recover all clusters exactly with high probability.</p><p>To capture the notion of "latent cluster", we introduce the concept of (1ε)-knit set. As usual, we view V, σ as a graph G = (V, E) with e ∈ E iff σ(e) = +1. Let E C be the edges in the subgraph induced by C ⊆ V and cut(C, C) be the edges between C and</p><formula xml:id="formula_13">C = V \ C. Definition 2. A subset C ⊆ V is (1 -ε)-knit if E C ≥ (1 -ε) |C| 2 and cut(C, C) ≤ ε |C| 2 .</formula><p>Suppose now we have a cluster C as "estimate" of C. We quantify the distance between C and C as the cardinality of their symmetric difference,</p><formula xml:id="formula_14">C ⊕ C = C \ C + C \ C . The goal is to obtain, for each (1 -ε)-knit set C in the graph, a cluster C with | C ⊕ C| = O(ε|C|)</formula><p>for some small ε. We prove ACC does exactly this. Clearly, we must accept that if C is too small, i.e.</p><formula xml:id="formula_15">|C| = o(n/f (n)), then ACC will miss C entirely. But, for |C| = Ω(n/f (n)), we can prove E[| C ⊕ C|] = O(ε|C|).</formula><p>We point out that the property of being (1ε)-knit is rather weak for an algorithm, like ACC, that is completely oblivious to the global topology of the cluster -all what ACC tries to do is to blindly cluster together all the neighbors of the current pivot. In fact, consider a set C formed by two disjoint cliques of equal size. This set would be close to 1 /2-knit, and yet ACC would never produce a single cluster C corresponding to C. Things can only worsen if we consider also the edges in cut(C, C), which can lead ACC to assign the nodes of C to several different clusters when pivoting on C. Hence it is not obvious that a (1ε)-knit set C can be efficiently recovered by ACC.</p><p>Note that this task can be seen as an adversarial cluster recovery problem. Initially, we start with a disjoint union of cliques, so that OPT = 0. Then, an adversary flips the signs of some of the edges of the graph. The goal is to retrieve every original clique that has not been perturbed excessively.</p><p>Note that we put no restriction on how the adversary can flip edges; therefore, this adversarial setting subsumes constrained adversaries. For example, it subsumes the high-probability regime of the stochastic block model <ref type="bibr" target="#b16">[17]</ref> where edges are flipped according to some distribution.</p><p>We can now state our main cluster recovery bound for ACC.</p><formula xml:id="formula_16">Theorem 4. For every C ⊆ V that is (1 -ε)-knit, ACC outputs a cluster C such that E |C ⊕ C| ≤ 3ε|C| + min 2n f (n) , 1 -f (n) n |C| + |C|e -|C|f (n)/5n .</formula><p>The min in the bound captures two different regimes: when f (n) is very close to n, then E |C⊕ C| = O(ε|C|) independently of the size of C, but when f (n) n we need |C| = Ω(n/f (n)), i.e., |C| must be large enough to be found by ACC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Exact cluster recovery via amplification</head><p>For certain latent clusters, one can get recovery guarantees significantly stronger than the ones given natively by ACC (see Theorem 4). We start by introducing strongly (1ε)-knit sets (also known as quasi-cliques). Recall that N v is the neighbor set of v in the graph G induced by the positive labels.</p><formula xml:id="formula_17">Definition 3. A subset C ⊆ V is strongly (1 -ε)-knit if, for every v ∈ C, we have N v ⊆ C and |N v | ≥ (1 -ε)(|C| -1).</formula><p>We remark that ACC alone does not give better guarantees on strongly (1ε)-knit subsets than on (1ε)-knit subsets. Suppose for example that To bypass this limitation, we run ACC several times to amplify the probability that every node in C is found. Recall that V = [n]. Then, we define the id of a cluster C as the smallest node of C. The min-tagging rule is the following: when forming C, use its id to tag all of its nodes. Therefore, if u C = min{u ∈ C} is the id of C, we will set id(v) = u C for every v ∈ C. Consider now the following algorithm, called ACR (Amplified Cluster Recovery). First, ACR performs K independent runs of ACC on input V , using the min-tagging rule on each run. In this way, for each v ∈ V we obtain K tags id 1 (v), . . . , id K (v), one for each run. Thereafter, for each v ∈ V we select the tag that v has received most often, breaking ties arbitrarily. Finally, nodes with the same tag are clustered together. One can prove that, with high probability, this clustering contains all strongly (1ε)-knit sets. In other words, ACR with high probability recovers all such latent clusters exactly. Formally, we prove: Theorem 5. Let ε ≤ 1 10 and fix p &gt; 0. If ACR is run with K = 48 ln n p , then the following holds with probability at least 1p: for every strongly (1ε)-knit C with |C| &gt; 10 n f (n) , the algorithm outputs a cluster C such that C = C.</p><formula xml:id="formula_18">|N v | = (1 -ε)(|C| -1) for all v ∈ C. Then C is strongly (1 -ε)-knit,</formula><p>It is not immediately clear that one can extend this result by relaxing the notion of strongly (1-ε)-knit set so to allow for edges between C and the rest of the graph. We just notice that, in that case, every node v ∈ C could have a neighbor x v ∈ V \ C that is smaller than every node of C. In this case, when pivoting on v ACC would tag v with x rather than with u C , disrupting ACR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A fully additive scheme</head><p>In this section, we introduce a(n inefficient) fully additive approximation algorithm achieving cost OPT + n 2 ε in high probability using order of n ε 2 queries. When OPT = 0, Q = n ε ln 1 ε suffices. Our algorithm combines uniform sampling with empirical risk minimization and is analyzed using VC theory.</p><p>First, note that CC can be formulated as an agnostic binary classification problem with binary classifiers h C : E → {-1, +1} associated with each clustering C of V (recall that E denotes the set of all pairs {u, v} of distinct elements u, v ∈ V ), and we assume h C (u, v) = +1 iff u and v belong to the same cluster of C. Let H n be the set of all such h C . The risk of a classifier h C with respect to the uniform distribution over E is P(h C (e) = σ(e)) where e is drawn u.a.r. from E. It is easy to see that the risk of any classifier h C is directly related to</p><formula xml:id="formula_19">∆ C , P h C (e) = σ(e) = ∆ C n 2 .</formula><p>Hence, in particular, OPT = n 2 min h∈Hn P h(e) = σ(e) . Now, it is well known -see, e.g., [23, Theorem 6.8]-that we can minimize the risk to whithin an additive term of ε using the following procedure: query O d/ε 2 edges drawn u.a.r. from E, where d is the VC dimension of H n , and find the clustering C such that h C makes the fewest mistakes on the sample. If there is h * ∈ H n with zero risk, then O (d/ε) ln(1/ε) random queries suffice. A trivial upper bound on the VC dimension of</p><formula xml:id="formula_20">H n is log 2 |H n | = O n ln n).</formula><p>The next result gives the exact value. Theorem 6. The VC dimension of the class H n of all partitions of n elements is n -1.</p><p>Proof. Let d be the VC dimension of H n . We view an instance of CC as the complete graph K n with edges labelled by σ. Let T be any spanning tree of K n . For any labeling σ, we can find a clustering of V such that h perfectly classifies the edges of T : simply remove the edges with label -1 in T and consider the clusters formed by the resulting connected components. Hence d ≥ n -1 because any spanning tree has exactly n -1 edges. On the other hand, any set of n edges must contain at least a cycle. It is easy to see that no clustering C makes h C consistent with the labeling σ that gives positive labels to all edges in the cycle but one. Hence d &lt; n.</p><p>An immediate consequence of the above is the following. Theorem 7. There exists a randomized algorithm A that, for all</p><formula xml:id="formula_21">0 &lt; ε &lt; 1, finds a clustering C satisfying ∆ C ≤ OPT + O n 2 ε with high probability while using Q = O n ε 2 queries. Moreover, if OPT = 0, then Q = O n ε ln 1 ε queries are enough to find a clustering C satisfying ∆ C = O n 2 ε .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Lower bounds</head><p>In this section we give two lower bounds on the expected clustering error of any (possibly randomized) algorithm. The first bound holds for OPT = 0, and applies to algorithms using a deterministically bounded number of queries. This bound is based on a construction from [7, <ref type="bibr">Lemma 11]</ref> and related to kernel-based learning. Theorem 8. For any ε &gt; 0 such that 1 ε is an even integer, and for every (possibly randomized) learning algorithm asking fewer than 1 50ε 2 queries with probability 1, there exists a labeling σ on n ≥ 16  ε ln 1 ε nodes such that OPT = 0 and the expected cost of the algorithm is at least n 2 ε 8 .</p><p>Our second bound relaxed the assumption on OPT. It uses essentially the same construction of [5, Lemma 6.1], giving asymptotically the same guarantees. However, the bound of <ref type="bibr" target="#b4">[5]</ref> applies only to a very restricted class of algorithms: namely, those where the number q v of queries involving any specific node v ∈ V is deterministically bounded. This rules out a vast class of algorithms, including KwikCluster, ACC, and ACCESS, where the number of queries involving a node is a function of the random choices of the algorithm. Our lower bound is instead fully general: it holds unconditionally for any randomized algorithm, with no restriction on what or how many pairs of points are queried.</p><formula xml:id="formula_22">Theorem 9. Choose any function ε = ε(n) such that Ω 1 n ≤ ε ≤ 1 2 and 1 ε ∈ N.</formula><p>For every (possibly randomized) learning algorithm and any n 0 &gt; 0 there exists a labeling σ on n ≥ n 0 nodes such that the algorithm has expected error E[∆] ≥ OPT + n 2 ε 80 whenever its expected number of queries satisfies</p><formula xml:id="formula_23">E[Q] &lt; n 80 ε .</formula><p>In fact, the bound of Theorem 9 can be put in a more general form: for any constant c ≥ 1, the expected error is at least c • OPT + A(c) where A(c) = Ω(n 2 ε) is an additive term with constant factors depending on c (see the proof). Thus, our algorithms ACC and ACCESS are essentially optimal in the sense that, for c = 3, they guarantee an optimal additive error up to constant factors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experiments</head><p>We tested ACC on six datasets from <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b19">20]</ref>. Four of these datasets are obtained from real-world data and the remaining two are synthetic. In Figure <ref type="figure" target="#fig_3">2</ref> we show our results for one real-world dataset (cora, with 1879 nodes and 191 clusters) and one synthetic dataset (skew, with 900 nodes and 30 clusters). Similar results for the remaining four datasets can be found in the supplementary material.</p><p>Every dataset provides a ground-truth partitioning of nodes with OPT = 0. To test the algorithm for OPT &gt; 0, we perturbed the dataset by flipping the label of each edge indipendently with probability p (so the results for p = 0 refer to the original dataset with OPT = 0).   The performance of KwikCluster is shown by the circular marker. On both datasets, the error of ACC shows a nice sublinear drop as the number of queries increases, quickly approaching the performance of KwikCluster. Ignoring lower order terms, Theorem 1 gives an expected cost bounded by about 3.8n 3 /Q for the case OPT = 0 (recall that OPT is unknown). Placing this curve in our plots, shows that ACC is a factor of two or three better than the theoretical bound (which is not shown in Figure <ref type="figure" target="#fig_3">2</ref> due to scaling issues).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Probability bounds</head><p>We give Chernoff-type probability bounds can be found in e.g. <ref type="bibr" target="#b14">[15]</ref> and that we repeatedly use in our proofs. Let X 1 , . . . , X n be binary random variables. We say that X 1 , . . . , X n are non-positively correlated if for all I ⊆ {1, . . . , n} we have:</p><formula xml:id="formula_24">P[∀i ∈ I : X i = 0] ≤ i∈I P[X i = 0] and P[∀i ∈ I : X i = 1] ≤ i∈I P[X i = 1]<label>(1)</label></formula><p>The following holds:</p><p>Lemma 1. Let X 1 , . . . , X n be independent or, more generally, non-positively correlated binary random variables. Let a 1 , . . . , a n ∈ [0, 1] and X = n i=1 a i X i . Then, for any δ &gt; 0, we have:</p><formula xml:id="formula_25">P[X &lt; (1 -δ)E[X]] &lt; e -δ 2 2 E[X]</formula><p>(2)</p><formula xml:id="formula_26">P[X &gt; (1 + δ)E[X]] &lt; e -δ 2 2+δ E[X]<label>(3)</label></formula><p>B Supplementary Material for Section 3 Query all remaining pairs (π r , u) for u ∈ V r \ {π r } ∪ S r 8:</p><formula xml:id="formula_27">B.1 Pseudocode of ACC Algorithm 2 Invoked as ACC(V 1 , 1) where V 1 ≡ V and r = 1 is the index of the recursive call. Parameters: Query rate function f : N → N. 1: if |V r | = 0 ∨ r &gt; f (|V 1 | -1)</formula><p>C r ← C r ∪ {u : σ(π r , u) = +1} Populate cluster based on queries 9: Output cluster C r 10: ACC(V r \ C r , r + 1)</p><p>Recursive call on the remaining nodes</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Proof of Theorem 1</head><p>We refer to the pseudocode of ACC ( Algorithm 2). We use V r to denote the set of remaining nodes at the beginning of the r-th recursive call. Hence V 1 = V . If the condition in the if statement on line 6 is not true, then C r is a singleton cluster. We denote by V sing the set nodes that are output as singleton clusters.</p><p>Let Γ A be the set of mistaken edges for the clustering output by ACC and let ∆ A = Γ A be the cost of this clustering. Note that, in any recursive call, ACC misclassifies an edge e = {u, w} if and only if e is part of a bad triangle whose third node v is chosen as pivot and does not become a singleton cluster, or if σ(e) = +1 and at least one of u, w becomes a singleton cluster. More formally, ACC misclassifies an edge e = {u, w} if and only if one of the following three disjoint events holds:</p><p>B 1 (e): There exists r ≤ f (n -1) and a bad triangle T ≡ {u, v, w} ⊆ V r such that π r = v and v ∈ V sing . B 2 (e): There exists r ≤ f (n -1) such that u, w ∈ V r with σ(u, w) = +1 and π r ∈ {u, w} ∩ V sing . B 3 (e): The algorithm stops after f (n -1) calls without removing neither u nor w, and σ(u, w) = +1.</p><p>Therefore the indicator variable for the event "e is mistaken" is:</p><formula xml:id="formula_28">I {e ∈ Γ A } = I {B 1 (e)} + I {B 2 (e)} + I {B 3 (e)}</formula><p>The expected cost of the clustering is therefore:</p><formula xml:id="formula_29">E[∆ A ] = e∈E P(B 1 (e)) + e∈E P(B 2 (e)) + e∈E P(B 3 (e))<label>(4)</label></formula><p>We proceed to bound the three terms separately.</p><p>Bounding e∈E P(B 1 (e)). Fix an arbitrary edge e = {u, w}. Note that, if B 1 (e) occurs, then T is unique, i.e. exactly one bad triangle T in V satisfies the definition of B 1 (e). Each occurrence of B 1 (e) can thus be charged to a single bad triangle T . We may thus write</p><formula xml:id="formula_30">e∈E I {B 1 (e)} = e∈E I {(∃ r)(∃ T ∈ T ) : T ⊆ V r ∧ e ⊂ T ∧ π r ∈ T \ e ∧ π r ∈ V sing } = T ∈T I {(∃ r) : T ⊆ V r ∧ π r ∈ T ∧ π r ∈ V sing } ≤ T ∈T I {A T }</formula><p>where If A T holds for some r 0 , then it cannot hold for any other r &gt; r 0 because π r0 ∈ T implies that for all r &gt; r 0 we have π r0 ∈ V r implying T ⊆ V r . Hence, given that A T holds for r 0 , if F T (e) holds too, then it holds for the same r 0 by construction. This implies that P F T (e) | A T = 1 3 because ACC chooses the pivot u.a.r. from the nodes in V r0 . Thus, for each e ∈ E we can write </p><formula xml:id="formula_31">A T ≡ (∃ r) : T ⊆ V r ∧ π r ∈ T . Let</formula><p>Choosing β T = 1 3 P(A T ) we get T ∈T P(A T ) ≤ 3OPT. In the proof of KwikCluster, the condition T ∈T (e) β T ≤ 1 was ensured by considering events G T (e) = A T ∧ e ∈ Γ A . Indeed, in KwikCluster the events {G T (e) : T ∈ T (e)} are disjoint, because G T (e) holds iff T is the first and only triangle in T (e) whose node opposite to e is chosen as pivot. For ACC this is not true because a pivot can become a singleton cluster, which does not cause e ∈ Γ A necessarily to hold.</p><formula xml:id="formula_33">Bounding e∈E P(B 2 (e)). For any u ∈ V r , let d + r (u) = {v ∈ V r : σ(u, v) = +1} . We have: e∈E I {B 2 (e)} = 1 2 u∈V f (n-1) r=1 I {π r = u ∧ π r ∈ V sing } d + r (u) .</formula><p>Taking expectations with respect to the randomization of ACC,</p><formula xml:id="formula_34">e∈E P B 2 (e) = 1 2 u∈V f (n-1) r=1 E I {π r = u ∧ π r ∈ V sing } d + r (u) = 1 2 u∈V f (n-1) r=1 E I {π r ∈ V sing } d + r (u) π r = u P(π r = u)</formula><p>For any round r, let H r-1 be the sequence of random draws made by the algorithm before round r.</p><formula xml:id="formula_35">Then P π r ∈ V sing π r = u, H r-1 d + r (u) = 0 if either d + r (u) = 0, or d + r (u) ≥ 1 and d - r (u) &lt; f (n r ). Otherwise, P π r ∈ V sing π r = u, H r-1 = f (nr)-1 j=0 d - r (u) -j n r -j ≤ d - r (u) n r f (nr) = 1 - d + r (u) n r f (nr)<label>(6)</label></formula><p>where the inequality holds because d - r (u) ≤ n r . Therefore, when d + r (u) ≥ 1 and d - r (u) ≥ f (n r ),</p><formula xml:id="formula_36">E I {π r ∈ V sing } d + r (u) π r = u, H r-1 = P π r ∈ V sing π r = u, H r-1 d + r (u) = 1 - d + r (u) n r f (nr) d + r (u) = 1 - d + r (u) n r f (nr) d + r (u) ≤ exp - d + r (u)f (n r ) n r d + r (u) ≤ max z&gt;0 exp - z f (n r ) n r z ≤ n r ef (n r )</formula><p>.</p><p>Combining with the above, this implies</p><formula xml:id="formula_37">e∈E P B 2 (e) ≤ 1 2e f (n-1) r=1 E n r f (n r ) ≤ 1 2e f (n-1) r=1 n f (n) &lt; n 2e</formula><p>where we used the facts that n r ≤ n and the properties of f .</p><p>Bounding e∈E P(B 3 (e)). Let V fin be the remaining vertices in V r after the algorithm stops and assume |V fin | &gt; 1 (so that there is at least a query left). Let n fin = |V fin | -1 and, for any u ∈ V fin , let d + fin (u) = {v ∈ V fin : σ(u, v) = +1} . In what follows, we conventionally assume V r ≡ V fin for any r &gt; f (n -1), and similarly for n fin and d + fin . We have</p><formula xml:id="formula_38">e∈E I {B 3 (e)} = 1 2 u∈V fin d + fin (u) ≤ 1 2 u∈V fin n fin f (n fin ) + u∈V fin I d + fin (u) &gt; n fin f (n fin ) d + fin (u) .</formula><p>Fix some r ≤ f (n -1). Given any vertex v ∈ V r with d + r (v) ≥ nr f (nr) , let E r (v) be the event when at round r, ACC queries σ(v, u) for all u ∈ V r \ {v}. Introduce the notation S r = u∈Vr I d + r (u) &gt; nr f (nr) d + r (u) with S r = S fin for all r &gt; f (n), and let δ r = n rn r+1 be the number of nodes that are removed from V r at the end of the r-th recursive call. Then</p><formula xml:id="formula_39">δ r ≥ I {E r (π r )} d + r (π r ) ≥ I d + r (π r ) &gt; n r f (n r ) I {E r (π r )} d + r (π r )</formula><p>and</p><formula xml:id="formula_40">E[δ r | H r-1 ] ≥ v∈Vr I d + r (v) &gt; n r f (n r ) P E r (v) | π r = v, H r-1 P(π r = v | H r-1 )d + r (v) .</formula><p>Using the same argument as the one we used to bound <ref type="bibr" target="#b5">(6)</ref>,</p><formula xml:id="formula_41">P E r (v) | π r = v, H r-1 ≥ 1 -1 - d + r (v) n r f (nr) ≥ 1 -1 - 1 f (n r ) f (nr) ≥ 1 - 1 e</formula><p>and P(π r = v | H r-1 ) = 1 nr+1 for any v ∈ V r , we may write</p><formula xml:id="formula_42">E[δ r | H r-1 ] ≥ 1 - 1 e E[S r | H r-1 ] n r + 1 ≥ 1 - 1 e E[S r | H r-1 ] n .</formula><p>Observe now that </p><formula xml:id="formula_43">f (n-1) r=1 δ r ≤ n 1 -n fin ≤ n -1 and S r is monotonically nonincreasing in r. Thus n -1 ≥ f (n-1) r=1 E[δ r ] ≥ 1 n 1 - 1 e f (n) r=1 E[S r ] ≥ f (n -1) n 1 - 1 e E[S</formula><formula xml:id="formula_44">u∈V fin E n fin f (n fin ) + E[S fin ] ≤ 1 2 n 2 f (n) + e e -1 n 2 f (n) as claimed.</formula><p>Bounding the number of queries. In round r, ACC asks n r ≤ n queries if π r ∈ V sing and f (n r ) ≤ f (n) queries otherwise. Since the number of rounds is at most f (n), the overall number of queries is at most max n, f</p><formula xml:id="formula_45">(n) f (n) ≤ nf (n).</formula><p>KwikCluster as special case. When f (r) = r for all r, ACC issues all queries σ(π r , u) for u ∈ V r \ {π r } in each round r, and builds a cluster just like KwikCluster would. At the end of f (n) = n = |V | -1 rounds, there can be at most a single node left, which is then declared a singleton cluster. Hence, ACC and KwikCluster behaves identically for any sequence of pivot draws. Moreover, it is easy to check that the events B 2 (e) and B 3 (e) can never occur when f (n) = n. Therefore, the only contribution to ∆ A is T ∈T A T which is bounded by 3OPT for any choice of f . STOP and declare every v ∈ V r as singleton 4: Draw pivot π r u.a.r. from V r 5: C r ← {π r } Create new cluster and add the pivot to it 6: Draw a random subset S r of f (|V r | -1) nodes from V r \ {π r } 7: for each u ∈ S r do query σ(π r , u) 8: if ∃ u ∈ S r such that σ(π r , u) = +1 then Check if there is at least an edge 9:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3 Pseudocode of ACCESS</head><formula xml:id="formula_46">Algorithm 3 Invoked as ACCESS(V 1 , 1) where V 1 ≡ V and</formula><p>Query all remaining pairs (π r , u) for u ∈ V r \ {π r } ∪ S r 10:</p><formula xml:id="formula_47">C r ← C r ∪ {u : σ(π r , u) = +1} Populate cluster based on queries 11: Output cluster C r 12: ACCESS(V r \ C r , r + 1)</formula><p>Recursive call on the remaining nodes</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.4 Proof of Theorem 2</head><p>We refer to the pseudocode of ACCESS (Algorithm 3).</p><p>Let G r be the residual graph at round r. The total cost of the clustering produced by ACCESS is clearly bounded by the sum of the cost of ACC without round restriction, plus the number of edges in the residual graph G r if r is the round at which ACCESS stops. The first term is, in expectation, at most 3OPT + n/2e, as one can easily derive from the proof of Theorem 1. For the second term note that, if G r contains k edges, then the probability that ACCESS stops is at most:</p><formula xml:id="formula_48">1 - k |Vr| 2 ( |Vr | 2 )f(n)/n 2 ≤ e -kf (n)/n 2</formula><p>Thus the expected number of edges in the residual graph when ACCESS returns is bounded from above by max k≥1 (ke</p><formula xml:id="formula_49">-kf (n)/n 2 ) ≤ n 2 ef (n) .</formula><p>Let us then move to the bound on the number of queries. The queries performed at line 1 are deterministically at most nf (n). Concerning the other queries (line 7 and line 9), we divide the algorithm in two phases: the "dense" rounds r where G r still contains at least n 2 /2f (n) edges, and the remaining "sparse" rounds where G r contains less than n 2 /2f (n) edges.</p><p>Consider first a "dense" round r. We see G r as an arbitrary fixed graph: for all random variables mentioned below, the distribution is thought solely as a function of the choices of the algorithm in the current round (i.e., the pivot node π r and the queried edges). Now, let Q r be the number of queries performed at lines 7 and 9), and R r = |V r | -|V r+1 | be the number of nodes removed. Let π r be the pivot, and let D r be its degree in G r . Let X r be the indicator random variable of the event that σ(π r , u) = +1 for some u ∈ S r . Observe that:</p><formula xml:id="formula_50">Q r ≤ f (|V r | -1) + X r (|V r | -1) and R r = 1 + X r D r Thus E[Q r ] ≤ f (|V r |-1)+E[X r ]|V r |, while E[R r ] = 1+E[X r D r ]. However, X r is monotonically increasing in D r , so E[X r D r ] = E[X r ]E[D r ] + Cov(X r , D r ) ≥ E[X r ]E[D r ]. Moreover, by hypothesis E[D r ] ≥ 2 n 2 /2f (n) /|V r | ≥ n/f (n).</formula><p>Thus:</p><formula xml:id="formula_51">E[R r ] ≥ 1 + E[X r ]E[D r ] ≥ 1 + E[X r ] n f (n) ≥ 1 + E[X r ] |V r | f (|V r |) ≥ E[Q r ] f (|V r |) ≥ E[Q r ] f (n)</formula><p>But then, since obviously r R r ≤ n:</p><formula xml:id="formula_52">E r dense Q r ≤ f (n)E r dense R r ≤ nf (n)</formula><p>Consider now the "sparse" rounds, where G r contains less than n 2 /2f (n) edges. With probability at least 1/2 ACCESS finds no edge and thus stops right after lines 1-2. Hence the number of sparse rounds completed by ACCESS is at most one in expectation; the corresponding expected number of queries is then at most n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.5 Proof of Theorem 3</head><p>First of all, note that if the residual graph G r contains O(n 2 /f (n)) edges, from r onwards ACCESS stops at each round independently with constant probability. The expected number of queries performed before stopping is therefore O(n), and the expected error incurred is obviously at most O(n 2 /f (n)).</p><p>We shall then bound the expected number of queries required before the residual graph contains O(n 2 /f (n)) edges. In fact, by definition of i , if ACCESS removes C i , . . . , C , then the residual graph contains O(n 2 /f (n)) edges. We therefore bound the expected number of queries before C i , . . . , C are removed.</p><p>First of all recall that, when pivoting on a cluster of size c, the probability that the cluster is not removed is at most e -cf (n)/n . Thus the probability that the cluster is not removed after Ω(c) of its nodes have been used as pivot is e -Ω(c 2 )f (n)/n . Hence the probability that any of C i , . . . , C is not removed after Ω(c) of its nodes are used as pivot is, setting c = Ω h(n) and using a union bound, at most</p><formula xml:id="formula_53">p = ne -Ω(h(n) 2 )f (n)/n . Observe that h(n) = Ω n/f (n) , for otherwise i j=1 Cj 2 = o n 2 /f (n) , a contradiction. Therefore p ≤ ne -Ω(h(n))</formula><p>. Note also that we can assume h(n) = ω(ln n), else the theorem bound is trivially O(n 2 ). This gives p = O ne -ω(ln n) = o 1/ poly(n) . We can thus condition on the events that, at any point along the algorithm, every cluster among C i , . . . , C that is still in the residual graph has size Ω h(n) ; the probability of any other event changes by an additive O(p), which can be ignored.</p><p>Let now k =i + 1, and suppose at a generic point k ≤ k of the clusters C i , . . . , C are in the residual graph. Their total size is therefore Ω k h(n) . Therefore O n/k h(n) rounds in expectation are needed for the pivot to fall among those clusters. Each time this happens, with probability 1e -Ω(h(n))f (n)/n = Ω(1) the cluster containing the pivot is removed. Hence, in expectation a new cluster among C i , . . . , C is removed after O n/k h(n) rounds. By summing over all values of k , the number of expected rounds to remove all of C i , . . . , C is</p><formula xml:id="formula_54">O k k =1 n k h(n) = O n(ln n)/h(n)</formula><p>Since each round involves O(n) queries, the bound follows.</p><p>C Supplementary Material for Section 4</p><p>C.1 Proof of Theorem 4</p><p>Fix any C that is (1ε)-knit. We show that ACC outputs a C such that</p><formula xml:id="formula_55">E | C ∩ C| ≥ max 1 - 5 2 ε |C| -2 n f (n) , f (n) n - 5 2 ε |C| and E | C ∩ C| ≤ ε 2 |C| (7)</formula><p>One can check that these two conditions together imply the first two terms in the bound. We start by deriving a lower bound on</p><formula xml:id="formula_56">E | C ∩ C| for KwikCluster assuming |E C | = |C| 2 .</formula><p>Along the way we introduce most of the technical machinery. We then port the bound to ACC, relax the assumption to</p><formula xml:id="formula_57">|E C | ≥ (1 -ε) |C| 2 ,</formula><p>and bound E | C ∩ C| from above. Finally, we add the |C|e -|C|f (n)/5n part of the bound. To lighten the notation, from now on C denotes both the cluster and its cardinality |C|.</p><p>For the sake of analysis, we see KwikCluster as the following equivalent process. First, we draw a random permutation π of V . This is the ordered sequence of candidate pivots. Then, we set G 1 = G, and for each i = 1, . . . , n we proceed as follows. If π i ∈ G i , then π i is used as an actual pivot; in this case we let</p><formula xml:id="formula_58">G i+1 = G i \ (π i ∪ N πi ) where N v is the set of neighbors of v. If instead π i / ∈ G i , then we let G i+1 = G i .</formula><p>Hence, G i is the residual graph just before the i-th candidate pivot π i is processed. We indicate the event π i ∈ G i by the random variable P i :</p><formula xml:id="formula_59">P i = I {π i ∈ G i } = I {π i is used as pivot}<label>(8)</label></formula><p>More in general, we define a random variable indicating whether node v is "alive" in G i :</p><formula xml:id="formula_60">X(v, i) = I {v ∈ G i } = I v / ∈ ∪ j&lt;i : Pj =1 (π j ∪ N πj )<label>(9)</label></formula><p>Let i C = min{i : π i ∈ C} be the index of the first candidate pivot of C. Define the random variable:</p><formula xml:id="formula_61">S C = |C ∩ G i C | = v∈C X(v, i C )<label>(10)</label></formula><p>In words, S C counts the nodes of C still alive in G i C . Now consider the following random variable:</p><formula xml:id="formula_62">S = P i C • S C<label>(11)</label></formula><p>Let C be the cluster that contains π i C in the output of KwikCluster. It is easy to see that |C ∩ C| ≥ S. Indeed, if Before continuing, we simplify the analysis by assuming KwikCluster runs on the graph G after all edges not incident on C have been deleted. We can easily show that this does not increase S. First, by (9) each X(v, i C ) is a nonincreasing function of {P i : i &lt; i C }. Second, by <ref type="bibr" target="#b9">(10)</ref> and <ref type="bibr" target="#b10">(11)</ref>, S is a nondecreasing function of {X(v, i C ) : v ∈ C}. Hence, S is a nonincreasing function of {P i : i &lt; i C }. Now, the edge deletion forces P i = 1 for all i &lt; i C , since any π i : i &lt; i C has no neighbor π j : j &lt; i. Thus the edge deletion does not increase S (and, obviously, E[S]). We can then assume G[V \ C] is an independent set. At this point, any node not adjacent to C is isolated and can be ignored. We can thus restrict the analysis to C and its neighborhood in G. Therefore we let C = {v : {u, v} ∈ E, u ∈ C, v / ∈ C} denote both the neighborhood and the complement of C.</p><formula xml:id="formula_63">P i C = 1 then C includes C ∩ G i C , so |C ∩ C| ≥ P i C S C = S. If instead P i C = 0, then S =</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>We turn to bounding E[S]</head><p>. For now we assume G[C] is a clique; we will then relax the assumption to</p><formula xml:id="formula_64">|E C | ≥ (1 -ε) C 2 .</formula><p>Since by hypothesis cut(C, C) &lt; εC 2 , the average degree of the nodes in C is less than εC 2 /C. This is also a bound on the expected number of edges between C and a node drawn u.a.r. from C. But, for any given i, conditioned on i C -1 = i the nodes π 1 , . . . , π i C -1 are indeed drawn u.a.r. from C, and so have a total of at most iεC 2 /C edges towards C in expectation. Thus, over the distribution of π, the expected number of edges between C and π 1 , . . . , π i C -1 is at most:</p><formula xml:id="formula_65">n i=0 iεC 2 C P(i C -1 = i) = εC 2 C E[i C -1] = εC 2 C C C + 1 &lt; εC<label>(12)</label></formula><p>where we used the fact that E[i C -1] = C/(C + 1). Now note that ( <ref type="formula" target="#formula_65">12</ref>) is a bound on C -E[S C ], the expected number of nodes of C that are adjacent to π 1 , . . . ,</p><formula xml:id="formula_66">π i C -1 . Therefore, E[S C ] ≥ (1 -ε)C.</formula><p>Recall that P i C indicates whether π i C is not adjacent to any of π 1 , . . . , π i C -1 . Since the distribution of</p><formula xml:id="formula_67">π i C is uniform over C, P(P i C | S C ) = S C /C. But S = P i C S C , hence E[S | S C ] = (S C ) 2 /C, and thus E[S] = E (S C ) 2 /C. Using E[S C ] ≥ (1 -ε)C</formula><p>and invoking Jensen's inequality we obtain</p><formula xml:id="formula_68">E[S] ≥ E[S C ] 2 C ≥ (1 -ε) 2 C ≥ (1 -2ε)C<label>(13)</label></formula><p>which is our bound on E |C ∩ C| for KwikCluster.</p><p>Let us now move to ACC. We have to take into account the facts that ACC performs f (|G r | -1) queries on the pivot before deciding whether to perform |G r | -1 queries, and that ACC stops after f (n -1) rounds. We start by addressing the first issue, assuming for the moment ACC has no restriction on the number of rounds.</p><p>Recall that</p><formula xml:id="formula_69">P(P i C | S C ) = S C /C. Now, if P i C = 1, then we have S C -1 edges incident on π i C .</formula><p>It is easy to check that the probability that ACC finds some of them is at least</p><formula xml:id="formula_70">1 -e -f (n) S C -1 n and, if this event occurs, then S = S C . Thus E[S | S C ] = P(P i C | S C )S C ≥ 1 -e -f (n) S C -1 n S 2 C C ≥ S 2 C C -S C 2n f (n)C<label>(14)</label></formula><p>where we used the facts that for S C ≤ 1 the middle expression in <ref type="bibr" target="#b13">(14)</ref> vanishes, that e -x &lt; 1/x for x &gt; 0, and that 1/x &lt; 2/(x + 1) for all x ≥ 2. Simple manipulations, followed by Jensen's inequality and an application of</p><formula xml:id="formula_71">E[S C ] ≥ (1 -ε)C, give E[S] ≥ (1 -ε) 2 C -(1 -ε)C 2n f (n)C ≥ (1 -2ε)C -2 n f (n)<label>(15)</label></formula><p>We next generalize the bound to the case</p><formula xml:id="formula_72">E C ≥ (1 -ε) C 2 .</formula><p>To this end note that, since at most ε C 2 edges are missing from any subset of C, then any subset of S C nodes of C has average degree at least</p><formula xml:id="formula_73">max 0, S C -1 - C 2 2ε S C ≥ S C - εC(C -1) 2S C -1<label>(16)</label></formula><p>We can thus re-write ( <ref type="formula" target="#formula_70">14</ref>) as</p><formula xml:id="formula_74">E[S | S C ] ≥ S C C 1 -e -f (n) S C -1 n S C - εC(C -1) 2S C<label>(17)</label></formula><p>Standard calculations show that this expression is bounded from below by</p><formula xml:id="formula_75">S 2 C C -S C 2n f (n)C -εC<label>2</label></formula><p>, which by calculations akin to the ones above leads to</p><formula xml:id="formula_76">E[S] ≥ (1 -5 2 ε)C -2 n f (n) .</formula><p>Similarly, we can show that</p><formula xml:id="formula_77">E[S] ≥ f (n) n -5 2 ε C.</formula><p>To this end note that when ACC pivots on π i C all the remaining cluster nodes are found with probability at least f (n) n (this includes the cases S C ≤ 1, when such a probability is indeed 1). In <ref type="bibr" target="#b13">(14)</ref>, we can then replace 1e -f (n</p><formula xml:id="formula_78">) S C -1 n with f (n) n , which leads to E[S] ≥ f (n) n -5 2 ε C.</formula><p>This proves the first inequality in <ref type="bibr" target="#b6">(7)</ref>. For the second inequality in <ref type="bibr" target="#b6">(7)</ref>, note that any subset of S C nodes has cut(C, C) ≤ ε C 2 . Thus, π i C is be incident to at most ε As far as the O(Ce -Cf (n)/n ) part of the bound is concerned, simply note that the bounds obtained so far hold unless i C &gt; f (n -1), in which case ACC stops before ever reaching the first node of C. If this happens, C = {π i C } and | C ⊕ C| &lt; |C|. The event i C &gt; f (n -1) is the event that no node of C is drawn when sampling f (n -1) nodes from V without replacement. We can therefore apply Chernoff-type bounds to the random variable X counting the number of draws of nodes of C and get</p><formula xml:id="formula_79">P X &lt; (1 -β)E[X]) ≤ exp(-β 2 E[X]</formula><p>/2 for all β &gt; 0. In our case E[X] = f (n -1)|C|/n, and we have to bound the probability that X equals 0</p><formula xml:id="formula_80">&lt; (1 -β)E[X]. Thus P(X = 0) ≤ exp - β 2 E[X] 2 = exp - β 2 f (n -1)|C| 2n</formula><p>Since f (n -1) ≥ f (n)/2 (otherwise n = 1 and V is trivial), choosing, e.g., β &gt; 4/5 yields P(X = 0) &lt; exp -|C|f (n)/5n . This case therefore adds at most</p><formula xml:id="formula_81">|C| exp(-|C|f (n)/5n) to E[| C ⊕ C|].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.2 Proof of Theorem 5</head><p>Before moving to the actual proof, we need some ancillary results. The next lemma bounds the probability that ACC does not pivot on a node of C in the first k rounds. Lemma 2. Fix a subset C ⊆ V and an integer k ≥ 1, and let π 1 , . . . , π n be a random permutation of V . For any v ∈ C let X v = I {v ∈ {π 1 , . . . , π k }}, and let X C = v∈C X v . Then E[X C ] = k|C| n , and P(X C = 0) &lt; e -k|C| 3n .</p><p>Proof. Since π is a random permutation, then for each v ∈ C and each each i = 1, . . . , k we have</p><formula xml:id="formula_82">P(π i = v) = 1 n . Therefore E[X v ] = k n and E[X C ] = k|C| n .</formula><p>Now, the process is exactly equivalent to sampling without replacement from a set of n items of which |C| are marked. Therefore, the X v 's are non-positively correlated and we can apply standard concentration bounds for the sum of independent binary random variables. In particular, for any η ∈ (0, 1) we have:</p><formula xml:id="formula_83">P(X C = 0) ≤ P(X C &lt; (1 -η)E[X C ]) &lt; exp - η 2 E[X C ] 2</formula><p>which drops below e -k|C| 3n by replacing E[X C ] and choosing η ≥ 2/3.</p><p>The next lemma is the crucial one. Proof. We bound from above the probability that any of three "bad" events occurs. As in the proof of Theorem 4, we equivalently see ACC as going through a sequence of candidate pivots π 1 , . . . , π n that is a uniform random permutation of V . Let i C = min{i : π i ∈ C} be the index of the first node of C in the random permutation of candidate pivots. The first event,</p><formula xml:id="formula_84">B 1 , is {i C &gt; f (n -1)}.</formula><p>Note that, if B 1 does not occur, then ACC will pivot on π i C . The second event, B 2 , is the event that For B 1 , we apply Lemma 2 by observing that i C &gt; f (n -1) corresponds to the event X C = 0 with k = f (n -1). Thus</p><formula xml:id="formula_85">π i C ∈ V sing if ACC pivots on π i C (</formula><formula xml:id="formula_86">P(i C &gt; f (n -1)) &lt; e -f (n-1)|C| 3n ≤ e -f (n-1) 3n 10 n f (n) = e -f (n-1) f (n) 10 3 &lt; e -3</formula><p>where we used the fact that n ≥ |C| ≥ 11 and therefore f (n -1) ≥ 10  11 f (n). For B 2 , recall that by definition every v ∈ C has at least (1ε)c edges. Thus, if ACC pivots on π i C , we have:</p><formula xml:id="formula_87">P(π i C ∈ V sing ) ≤ exp - f (n -1) n -1 (1 -ε)c ≤ exp - f (n -1) n -1 1 - 1 10 10 n f (n) ≤ e -9</formula><p>where we used the fact that f (n-1)</p><p>n-1 n f (n) ≥ 1. For B 3 , note that the distribution of π i C is uniform over C. Now, let N u C and N v be the neighbor sets of u C and v in C, and let P = N u C ∩ N v . We call P the set of good pivots. Since C is strongly (1ε)-knit, both u C and v have at least (1ε)c neighbors in C. But then |C \ P | ≤ 2εc and</p><formula xml:id="formula_88">P(π i C / ∈ P ) = |C \ P | |C| ≤ 2ε ≤ 1/5</formula><p>By a union bound, then, P(B 1 ∪ B 2 ∪ B 3 ) ≤ e -3 + e -9 + 1/5 &lt; 1/3.</p><p>We are now ready to conclude the proof. Suppose we execute ACC independently K = 48 ln(n/p) times with the min-tagging rule. For a fixed v ∈ G let X v be the number of executions giving id(v) = u C . On the one hand, by Lemma 3, E[X v ] ≥ 2 3 K. On the other hand, v will not be assigned to the cluster with id u C by the majority voting rule only if</p><formula xml:id="formula_89">X v ≤ 1 2 K ≤ E[X v ](1 -δ) where δ = 1 4 . By standard concentration bounds, then, P(X v ≤ 1 2 K) ≤ exp(-δ 2 E[Xv]</formula><p>2 ) = exp(-K 48 ). By setting K = 48 ln(n/p), the probability that v is not assigned id u C is thus at most p/n. A union bound over all nodes concludes the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Supplementary Material for Section 6 D.1 Proof of Theorem 8</head><p>We prove that there exists a distribution over labelings σ with OPT = 0 on which any deterministic algorithm has expected cost at least nε 2 8 . Yao's minimax principle then implies the claimed result. Given V = {1, . . . , n}, we define σ by a random partition of the vertices in d ≥ 2 isolated cliques T 1 , . . . , T d such that σ(v, v ) = +1 if and only if v and v belong to the same clique. The cliques are formed by assigning each node v ∈ V to a clique I v drawn uniformly at random with replacement from {1, . . . , d}, so that </p><formula xml:id="formula_90">T i = {v ∈ V : I v = i}.</formula><formula xml:id="formula_91">P(E i ) &gt; d 2 .</formula><p>Proof. For each query {s t , r t } we define the set L t of all cliques T i such that s t ∈ T i and some edge containining both s t and a node of T i was previously queried. The set R t is defined similarly using r t . Formally, </p><formula xml:id="formula_92">L t = {i : (∃τ &lt; t) s τ = s t ∧ r τ ∈ T i ∧ σ(s τ , r τ ) = -1} R t = {i : (∃τ &lt; t) r τ = r t ∧ s τ ∈ T i ∧ σ(s τ , r τ ) = -1} . Let D t be</formula><formula xml:id="formula_93">I {D t } = B t=1 I {D t ∧ P t &lt; d/2} + B t=1 I {D t ∧ P t ≥ d/2} N .<label>(18)</label></formula><p>We will now show that unless B ≥ . Therefore, N ≤ d 2 . Using the same logic as before, in order to have</p><formula xml:id="formula_94">I {D t ∧ P t ≥ d/2} = 1 for N ≤ d 2 times, at least d 2 + d 2 -1 + • • • + d 2 -N + 1</formula><p>queries must be made. So, it must be</p><formula xml:id="formula_95">B ≥ N k=1 d 2 -(k -1) = (d + 1) N 2 - N 2<label>2</label></formula><p>or, equivalently, N 2 -(d + 1)N + 2B ≥ 0. Solving this quadratic inequality for N , and using the</p><formula xml:id="formula_96">hypothesis N ≤ d 2 , we have that N ≤ (d+1)- √ (d+1) 2 -8B<label>2</label></formula><p>. Using the assumption that B ≤ d 2 50 we get that N ≤ √ 2B.</p><p>We now bound the first term of (18) in expectation. The event D t is equivalent to s t , r t ∈ T i for some i ∈ ¬L t ∩ ¬R t , where for any S ⊆ {1, . . . , d} we use ¬S to denote {1, . . . , d} \ S.</p><p>Let P t = P • | P t &lt; d/2 . For L , R ranging over all subsets of {1, . . . , d} of size strictly less than</p><formula xml:id="formula_97">d 2 , P t (D t ) = L ,R i∈¬L ∩¬R P t s t ∈ T i ∧ r t ∈ T i L t = L , R t = R P t (L t = L ∧ R t = R ) = L ,R i∈¬L ∩¬R P t s t ∈ T i L t = L P t r t ∈ T i R t = R P t (L t = L ∧ R t = R ) (19) = L ,R i∈¬L ∩¬R 1 |¬L | 1 |¬R | P t (L t = L ∧ R t = R ) (20) = L ,R |¬L ∩ ¬R | |¬L | |¬R | P t (L t = L ∧ R t = R ) ≤ 2 d .<label>(21)</label></formula><p>Equality ( <ref type="formula">19</ref>) holds because P t = max{L t , R t } &lt; d 2 implies that there are at least two remaining cliques to which s t and r t could belong, and each node is independently assigned to one of these cliques. Equality <ref type="bibr" target="#b19">(20)</ref> holds because, by definition of L t , the clique of s t is not in L t , and there were no previous queries involving s t and a node belonging to a clique in ¬L t (similarly for r t ). Finally, <ref type="bibr" target="#b20">(21)</ref>  </p><formula xml:id="formula_98">I {D t } ≤ 2B d + √ 2B .<label>(22)</label></formula><p>On the other hand, we have</p><formula xml:id="formula_99">B t=1 I {D t } = d i=1 I |T i | ≥ n 2d -I {E i } = d - d i=1 I |T i | &lt; n 2d + I {E i }<label>(23)</label></formula><p>Combining ( <ref type="formula" target="#formula_98">22</ref>) and ( <ref type="formula" target="#formula_99">23</ref>), we get that</p><formula xml:id="formula_100">d i=1 P(E i ) ≥ d - d i=1 P |T i | &lt; n 2d - 2B d - √<label>2B</label></formula><p>.</p><p>By Chernoff-Hoeffding bound,</p><formula xml:id="formula_101">P |T i | &lt; n 2d ≤ 1 d 2 for each i = 1, . . . , d when n ≥ 16d ln d. Therefore, d i=1 P(E i ) ≥ d - 2B + 1 d - √ 2B .</formula><p>To finish the proof, suppose on the contrary that</p><formula xml:id="formula_102">d i=1 P(E i ) ≤ d 2 .</formula><p>Then from the inequality above, we would get that</p><formula xml:id="formula_103">d 2 ≥ d - 2B + 1 d - √ 2B which implies B ≥ 2- √ 2 4 2 d 2 &gt; d 2</formula><p>50 , contradicting the assumptions. Therefore, we must have</p><formula xml:id="formula_104">d i=1 P(E i ) &gt; d 2 as required.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.2 Proof of Theorem 9</head><p>Choose a suitably large n and let V = [n]. We partition V in two sets A and B, where |A| = αn and |B| = (1α)n; we will eventually set α = 0.9, but for now we leave it free to have a clearer proof. The set A is itself partitioned into k = 1/ε subsets A 1 , . . . , A k , each one of equal size αn/k (the subsets are not empty because of the assumption on ε). The labeling σ is the distribution defined as follows. For each i = 1, . . . , k, for each pair u, v ∈ A i , σ(u, v) = +1; for each u, v ∈ B, σ(u, v) = -1. Finally, for each v ∈ B we have a random variable i v distributed uniformly over [k].</p><p>Then, σ(u, v) = +1 for all u ∈ A iv and σ(u, v) = -1 for all u ∈ A \ A iv . Note that the distribution of i v is independent of the (joint) distributions of the i w 's for all w ∈ B \ {v}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let us start by giving an upper bound on E[OPT].</head><p>To this end consider the (possibly suboptimal)</p><formula xml:id="formula_105">clustering C = {C i : i ∈ [k]} where C i = A i ∪ {v ∈ B : i v = i}. One can check that C is a partition of V . The expected cost E[∆ C</formula><p>] of C can be bound as follows. First, note the only mistakes are due to pairs u, v ∈ B. However, for any such fixed pair u, v, the probability of a mistake (taken over σ) is P(i u = i v ) = 1/k. Thus,</p><formula xml:id="formula_106">E[OPT] ≤ E[∆ 0 ] &lt; |B| 2 k = (1 -α) 2 n 2 k (<label>24</label></formula><formula xml:id="formula_107">)</formula><p>Let us now turn to the lower bound on the expected cost of the clustering produced by an algorithm.</p><p>For each v ∈ B let Q v be the total number of distinct queries the algorithm makes to pairs {u, v} with u ∈ A and v ∈ B. Let Q be the total number of queries made by the algorithm; obviously, Q ≥ v∈B Q v . Now let S v be the indicator variable of the event that one of the queries involving v returned +1. Both Q v and S v as random variables are a function of the input distribution and of the choices of the algorithm. The following is key:</p><formula xml:id="formula_108">P(S v ∧ Q v &lt; k /2) &lt; 1 2<label>(25)</label></formula><p>The validity of ( <ref type="formula" target="#formula_108">25</ref>) is seen by considering the distribution of the input limited to the pairs {u, v}. Indeed, S v ∧ Q v &lt; k /2 implies the algorithm discovered the sole positive pair involving v in less than k/2 queries. Since there are k pairs involving v, and for any fixed j the probability (taken over the input) that the algorithm finds that particular pair on the j-th query is exactly 1/k. Now,</p><formula xml:id="formula_109">P(S v ∧ Q v &lt; k /2) + P(S v ∧ Q v &lt; k /2) + P(Q v ≥ k /2) = 1<label>(26)</label></formula><p>and therefore</p><formula xml:id="formula_110">P(S v ∧ Q v &lt; k /2) + P(Q v ≥ k /2) &gt; 1 2<label>(27)</label></formula><p>Let us now consider R v , the number of mistakes involving v made by the algorithm. We analyse</p><formula xml:id="formula_111">E[R v | S v ∧ Q v &lt; k /2]</formula><p>. For all i ∈ [k] let Q i v indicate the event that, for some u ∈ A i , the algorithm queried the pair {u, v}. Let I = {i ∈ [k] : Q i v = 0}; thus I contains all i such that the algorithm did not query any pair u, v with u ∈ A i . Suppose now the event S v ∧ Q v &lt; k /2 occurs. On the one hand, S v implies that:</p><formula xml:id="formula_112">P(σ(u, v) = +1 | I) = 1 /|I| u ∈ A i , i ∈ I 0 u ∈ A i , i ∈ [k] \ I<label>(28)</label></formula><p>Informally speaking, this means that the random variable i v is distributed uniformly over the (random) set I. Now observe that, again conditioning on the joint event S v ∧ Q v &lt; k /2, whatever label s the algorithm assigns to a pair u, v with u ∈ A i where i ∈ I, the distribution of σ(u, v) is independent of s. This holds since s can obviously be a function only of I and of the queries made so far, all of which returned -1, and possibly of the algorithm's random bits. In particular, it follows that: We can now turn to back to R v , the number of total mistakes involving v. Clearly, R v ≥ k i=1 u∈Ai I {σ(u, v) = s}. Then:</p><formula xml:id="formula_113">P(σ(u, v) = s | I) ≥ min 1 /|I|, 1 -1 /|I| (29) However, Q v &lt; k /2 implies that |I| ≥ k -Q v &gt; k /2 = 2 /</formula><formula xml:id="formula_114">E[R v | E] = E k i=1 u∈Ai I {σ(u, v) = s} S v ∧ Q v &lt; k /2 (30) = E E k i=1 u∈Ai I {σ(u, v) = s} I S v ∧ Q v &lt; k /2<label>(31)</label></formula><p>≥ E E i∈I u∈Ai</p><formula xml:id="formula_115">I {σ(u, v) = s} I S v ∧ Q v &lt; k /2<label>(32)</label></formula><p>≥ E E i∈I u∈Ai</p><formula xml:id="formula_116">1 |I| I S v ∧ Q v &lt; k /2 (33) = E E αn k S v ∧ Q v &lt; k /2 (34) = αn k<label>(35)</label></formula><p>And therefore:</p><formula xml:id="formula_117">E[R v ] ≥ E[R v | S v ∧ Q v &lt; k /2] • P(S v ∧ Q v &lt; k /2) &gt; αn k • P(S v ∧ Q v &lt; k /2)</formula><p>This concludes the bound on</p><formula xml:id="formula_118">E[R v ]. Let us turn to E[Q v ]</formula><p>. Just note that:</p><formula xml:id="formula_119">E[Q v ] ≥ k 2 • P(Q v ≥ k /2)<label>(36)</label></formula><p>By summing over all nodes, we obtain:</p><formula xml:id="formula_120">E[Q] ≥ v∈B E[Q v ] ≥ k 2 v∈B P(Q v ≥ k /2) (37) E[∆] ≥ v∈B E[R v ] &gt; αn k v∈B P(S v ∧ Q v &lt; k /2)<label>(38)</label></formula><p>to which, by virtue of (27), applies the constraint:</p><formula xml:id="formula_121">v∈B P(Q v ≥ k /2) + v∈B P(S v ∧ Q v &lt; k /2) &gt; |B| 1 2 = (1 -α)n 2<label>(39)</label></formula><p>This constrained system gives the bound. Indeed, by (37), ( <ref type="formula" target="#formula_120">38</ref>) and (39), it follows that if E[Q] &lt; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Supplementary Material for Section 7</head><p>We report the complete experimental evaluation of ACC including error bars (see the main paper for a full description of the experimental setting). The details of the datasets are found in Table <ref type="table" target="#tab_5">1</ref>.   (f) captchas.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>and yet when pivoting on any v ∈ C ACC will inevitably produce a cluster C with | C ⊕ C| ≥ ε|C|, since the pivot has edges to less than (1ε)|C| other nodes of C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Clustering cost vs. number of queries. The curves show the average value of ∆. The circular outliers mark the performance of KwikCluster.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2</head><label>2</label><figDesc>Figure2shows the measured clustering cost ∆ against the number of queries Q performed by ACC. For each value of p ∈ {0, 0.1, 0.2, 0.3}, each curve in the plot is obtained by setting the query rate f (n) to n α for 20 distinct values of α ∈ [0, 3/4]. For each value of α we ran ACC fifty times. The curve shows the average value of ∆ (standard deviations, which are small, are omitted to avoid cluttering the figure). The performance of KwikCluster is shown by the circular marker. On both datasets, the error of ACC shows a nice sublinear drop as the number of queries increases, quickly approaching the performance of KwikCluster. Ignoring lower order terms, Theorem 1 gives an expected cost bounded by about 3.8n 3 /Q for the case OPT = 0 (recall that OPT is unknown). Placing this curve in our plots, shows that ACC is a factor of two or three better than the theoretical bound (which is not shown in Figure2due to scaling issues).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>then RETURN 2 :</head><label>2</label><figDesc>Draw pivot π r u.a.r. from V r 3: C r ← {π r } Create new cluster and add the pivot to it 4: Draw a random subset S r of f (|V r | -1) nodes from V r \ {π r } 5: for each u ∈ S r do query σ(π r , u) 6: if ∃ u ∈ S r such that σ(π r , u) = +1 then Check if there is at least an edge 7:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>us then bound T ∈T P(A T ). Let T (e) ≡ {T ∈ T : e ∈ T }. We use the following fact extracted from the proof of [2, Theorem 6.1]. If {β T ≥ 0 : T ∈ T } is a set of weights on the bad triangles such that T ∈T (e) β T 1 for all e ∈ E, then T ∈T β T ≤ OPT. Given e ∈ E and T ∈ T , let F T (e) be the event corresponding to T being the first triangle in the set T (e) such that T ∈ V r and π r ∈ T \ e for some r. Now if F T (e) holds then A T holds and no other A T for T ∈ T (e) \ {T } holds. Therefore T ∈T (e) I {A T ∧ F T (e)} = 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>1 =T</head><label>1</label><figDesc>∈T (e) P A T ∧ F T (e) = T ∈T (e) P F T (e) | A T P(A T ) = T ∈T (e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>fin ] which implies E[S fin ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>r = 1 1 : 2 :</head><label>112</label><figDesc>is the index of the recursive call. Parameters: Query rate function f : N → N. Sample the labels of |Vr| 2 f (n)/n 2 edges chosen u.a.r. from Vr 2 if no label is positive then 3:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>0 and obviously |C ∩ C| ≥ 0. Hence in any case |C ∩ C| ≥ S, and E |C ∩ C| ≥ E[S]. Therefore we can bound E |C ∩ C| from below by bounding E[S] from below.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>S C C 2</head><label>2</label><figDesc>such edges in expectation. The expected number of nodes of C that ACC assigns to C, as a function of S C , can thus be bounded by S C</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Lemma 3 .</head><label>3</label><figDesc>Let ε ≤ 1 10 . Consider a strongly (1ε)-knit set C with |C| &gt; 10n f (n) . Let u C = min{v ∈ C} be the id of C. Then, for any v ∈ C, in any single run of ACC we have P(id(v) = u C ) ≥ 2 3 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>we measure the probability of B 2 conditioned on B 1 ). The third event,B 3 , is {π i C / ∈ P } where P = N u C ∩ N v . If none among B 1 , B 2 , B3occurs, then ACC forms a cluster C containing both u C and v, and by the min-tagging rule sets id(v) = min u∈ C = u C . We shall then show that P(B 1 ∪ B 2 ∪ B 3 ) ≤ 1/3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>ε &gt; 2, which implies min{ 1 /|I|, 1-1 /|I|} ≥ 1 /|I|. Therefore, P(σ(u, v) = s | I) ≥ 1 /|I| for all u ∈ A i with i ∈ I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>2 4k. 2 4k = 9n 2 400k = 9εn 2</head><label>2222</label><figDesc>It just remains to set α and k properly so to get the statement of the theorem.Let α = 9 /10 and recall that k = 1/ε. Then, first, (1-α)nk 8 = nk 80 = n 80 ε . Second,<ref type="bibr" target="#b23">(24)</ref> givesE[OPT] &lt; (1-α) 2 n 2 k = n 2 100k = εn 2 100 . Third, α(1-α)n 400 &gt; E[OPT] + εn 2 80 . The above statement hence becomes: if E[Q] &lt; n 80ε , then E[∆] &gt; E[OPT] + εn 280 . An application of Yao's minimax principle completes the proof.As a final note, we observe that for every c ≥ 1 the bound can be put in the form E[∆] ≥ c • E[OPT] + Ω(n 2 ε) by choosing α ≥ c/(c + 1 /4).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Clustering cost vs. number of queries. The dotted curves are the average cost and the shaded areas around them measure the standard deviation. The trailing diamonds refer to KwikCluster's performance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>To this end we see the input as a graph G with edges corresponding to positive labels (see above). Suppose then G contains a sufficiently small number O(n 2 /f (n)) of edges. Since ACC deterministically performs f (n -1) rounds, it could makeQ = Θ(f (n) 2 ) queries. However, with just Q = f (n) queries one could detect that G contains O(n 2 /f (n))edges, and immediately return the trivial clustering formed by all singletons. The expected error would obviously be at most OPT + O(n 2 /f (n)), i.e. the same of Theorem 1. More generally, at each round r with f (n r ) queries one can check if the residual graph contains at least n 2 /f (n) edges; if the test fails, declaring all nodes in V r as singletons gives expected additional error O(n 2 /f (n)). The resulting algorithm is a variant of ACC that we call ACCESS (ACC with Early Stopping Strategy). The pseudocode can be found in the supplementary material.</figDesc><table /><note><p>First, we show ACCESS gives guarantees virtually identical to ACC (only, with Q in expectation). Formally: Theorem 2. For any query rate function f and any labeling σ on n nodes, the expected cost E[∆ A ] of the clustering output by ACCESS satisfies</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Consider a deterministic algorithm making queries {s t , r t } ∈ E. Let E i be the event that the algorithm never queries a pair of nodes in T i with |T i | ≥ n 2d &gt; 5. Apply Lemma 4 below with d = 1 Lemma 4. Suppose d &gt; 0 is even, n ≥ 16d ln d, and B &lt; d 2 50 . Then for any deterministic learning algorithm making at most B queries,</figDesc><table><row><cell>ε . This implies that the expected number of 2 = 1 2d is at least d non-queried clusters of size at least n 2ε . The overall expected cost of ignoring these clusters is therefore at least d 2 n 2d 2 = n 2 8d εn 2 = 8</cell></row><row><cell>and this concludes the proof.</cell></row><row><cell>d</cell></row><row><cell>i=1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>the event that the t-th query discovers a new clique of size at least n 2d , and let P t = max |L t |, |R t | . Using this notation,</figDesc><table><row><cell>B</cell></row><row><cell>t=1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Suppose N &gt; d 2 , and let t 1 , . . . , t N be the times t k such that I {D t k ∧ P t k ≥ d/2} = 1. Now fix some k and note that, because the clique to which s t k and r t k both belong is discovered, neither s t k nor r t k can occur in a future query {s t , r t }) that discovers a new clique. Therefore, in order to have I {D t ∧ P t ≥ d/2} = 1 for N &gt; d queries must be made, since each one of the other N -1 ≥ d 2 discovered cliques can contribute with at most a query to making P t ≥ d 2 . So, it takes at least B ≥ d 2 8 queries to discover the first d 2 cliques of size at least two, which contradicts the lemma's assumption that B ≤ d 2 16</figDesc><table><row><cell cols="2">2 times, at least</cell><cell></cell></row><row><cell>N 2</cell><cell>≥</cell><cell>d 2 8</cell></row></table><note><p>d 2 50 , we can upper bound N deterministically by √ 2B.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>holds because |¬L | ≥ d 2 , |¬R | ≥ d 2 , and |¬L ∩ ¬R | ≤ min{|¬L |, |¬R |}. Therefore,</figDesc><table><row><cell>B t=1</cell><cell>P D t ∧ P t &lt; d/2 ≤</cell><cell>B t=1</cell><cell>P D t | P t &lt; d/2 ≤</cell><cell>2B d</cell><cell>.</cell></row><row><cell cols="2">Putting everything together,</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>B</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>E</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>t=1</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 1 :</head><label>1</label><figDesc>Description of the datasets.</figDesc><table><row><cell>Datasets captchas</cell><cell>Type Real</cell><cell>|V | 244</cell><cell>#Clusters 69</cell></row><row><cell>cora</cell><cell cols="2">Real-world 1879</cell><cell>191</cell></row><row><cell>gym</cell><cell>Real</cell><cell>94</cell><cell>12</cell></row><row><cell>landmarks</cell><cell>Real</cell><cell>266</cell><cell>12</cell></row><row><cell>skew</cell><cell>Synthetic</cell><cell>900</cell><cell>30</cell></row><row><cell>sqrt</cell><cell>Synthetic</cell><cell>900</cell><cell>30</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Preprint. Under review.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>The authors gratefully acknowledge partial support by the <rs type="funder">Google Focused Award "Algorithms and Learning for AI</rs>" (ALL4AI). <rs type="person">Marco Bressan</rs> and <rs type="person">Fabio Vitale</rs> are also supported in part by the <rs type="grantName">ERC Starting Grant</rs> <rs type="grantNumber">DMAP 680153</rs> and by the "<rs type="programName">Dipartimenti di Eccellenza 2018-2022</rs>" grant awarded to the <rs type="institution">Department of Computer Science of the Sapienza University of Rome</rs>. <rs type="person">Nicolò Cesa-Bianchi</rs> is also supported by the <rs type="funder">MIUR PRIN grant Algorithms, Games</rs>, and <rs type="funder">Digital Markets (ALGADIMAR)</rs></p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_au6cRqE">
					<idno type="grant-number">DMAP 680153</idno>
					<orgName type="grant-name">ERC Starting Grant</orgName>
					<orgName type="program" subtype="full">Dipartimenti di Eccellenza 2018-2022</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Community detection in general stochastic block models: Fundamental limits and efficient algorithms for recovery</title>
		<author>
			<persName><forename type="first">Emmanuel</forename><surname>Abbe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colin</forename><surname>Sandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 56th Annual Symposium on Foundations of Computer Science</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="670" to="688" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Aggregating inconsistent information: Ranking and clustering</title>
		<author>
			<persName><forename type="first">Nir</forename><surname>Ailon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moses</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alantha</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="23" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Correlation clustering</title>
		<author>
			<persName><forename type="first">Nikhil</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avrim</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuchi</forename><surname>Chawla</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine learning</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="89" to="113" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Clustering gene expression patterns</title>
		<author>
			<persName><forename type="first">Amir</forename><surname>Ben-Dor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ron</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zohar</forename><surname>Yakhini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of computational biology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="281" to="297" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Bonchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>García-Soriano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantin</forename><surname>Kutzkov</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1312.5105</idno>
		<title level="m">Local correlation clustering</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A correlation clustering approach to link classification in signed networks</title>
		<author>
			<persName><forename type="first">Nicolo</forename><surname>Cesa-Bianchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Gentile</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabio</forename><surname>Vitale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Zappella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference on Learning Theory</title>
		<imprint>
			<publisher>Microtome</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="34" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the complexity of learning with kernels</title>
		<author>
			<persName><forename type="first">Nicolo</forename><surname>Cesa-Bianchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yishay</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ohad</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Learning Theory</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="297" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Clustering with qualitative information</title>
		<author>
			<persName><forename type="first">Moses</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Venkatesan</forename><surname>Guruswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Wirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="360" to="383" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Near optimal lp rounding algorithm for correlationclustering on complete and complete k-partite graphs</title>
		<author>
			<persName><forename type="first">Shuchi</forename><surname>Chawla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Konstantin</forename><surname>Makarychev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tselil</forename><surname>Schramm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grigory</forename><surname>Yaroslavtsev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Forty-seventh Annual ACM Symposium on Theory of Computing, STOC &apos;15</title>
		<meeting>the Forty-seventh Annual ACM Symposium on Theory of Computing, STOC &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="219" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Clustering partially observed graphs via convex optimization</title>
		<author>
			<persName><forename type="first">Yudong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Jalali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sujay</forename><surname>Sanghavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huan</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2213" to="2238" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Community recovery in graphs with locality</title>
		<author>
			<persName><forename type="first">Yuxin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Govinda</forename><surname>Kamath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changho</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Tse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="689" to="698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Prediction and clustering in signed networks: a local to global perspective</title>
		<author>
			<persName><forename type="first">Kai-Yang</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cho-Jui</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nagarajan</forename><surname>Natarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ambuj</forename><surname>Inderjit S Dhillon</surname></persName>
		</author>
		<author>
			<persName><surname>Tewari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1177" to="1213" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Learning to match and cluster large high-dimensional data sets for data integration</title>
		<author>
			<persName><forename type="first">W</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacob</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><surname>Richman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eighth ACM SIGKDD international conference on Knowledge discovery and data mining</title>
		<meeting>the eighth ACM SIGKDD international conference on Knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="475" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Correlation clustering in general weighted graphs</title>
		<author>
			<persName><forename type="first">Dotan</forename><surname>Erik D Demaine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amos</forename><surname>Emanuel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicole</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName><surname>Immorlica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">361</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="172" to="187" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Concentration of Measure for the Analysis of Randomized Algorithms</title>
		<author>
			<persName><forename type="first">Devdatt</forename><surname>Dubhashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Panconesi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Cambridge University Press</publisher>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
	<note>1st edition</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Entity resolution: theory, practice &amp; open challenges</title>
		<author>
			<persName><forename type="first">Lise</forename><surname>Getoor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashwin</forename><surname>Machanavajjhala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="2018" to="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Stochastic blockmodels: First steps</title>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">W</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathryn</forename><forename type="middle">Blackmond</forename><surname>Laskey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Leinhardt</surname></persName>
		</author>
		<idno type="DOI">10.1016/0378-8733(83)90021-7</idno>
		<ptr target="http://www.sciencedirect.com/science/article/pii/0378873383900217" />
	</analytic>
	<monogr>
		<title level="j">Social Networks</title>
		<idno type="ISSN">0378-8733</idno>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="109" to="137" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Higher-order correlation clustering for image segmentation</title>
		<author>
			<persName><forename type="first">Sungwoong</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Nowozin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pushmeet</forename><surname>Kohli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chang</forename><forename type="middle">D</forename><surname>Yoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1530" to="1538" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Community detection thresholds and the weak ramanujan property</title>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Massoulié</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the forty-sixth annual ACM symposium on Theory of computing</title>
		<meeting>the forty-sixth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="694" to="703" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Query complexity of clustering with side information</title>
		<author>
			<persName><forename type="first">Arya</forename><surname>Mazumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barna</forename><surname>Saha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Neural Information Processing Systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Clustering with noisy queries</title>
		<author>
			<persName><forename type="first">Arya</forename><surname>Mazumdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barna</forename><surname>Saha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="5788" to="5799" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A proof of the block model threshold conjecture</title>
		<author>
			<persName><forename type="first">Elchanan</forename><surname>Mossel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joe</forename><surname>Neeman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Allan</forename><surname>Sly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Combinatorica</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="665" to="708" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Understanding Machine Learning: From Theory to Algorithms</title>
		<author>
			<persName><forename type="first">Shai</forename><surname>Shalev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-Shwartz</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Shai</forename><surname>Ben-David</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>Cambridge University Press</publisher>
			<biblScope unit="page">9781107057135</biblScope>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A survey of signed network mining in social media</title>
		<author>
			<persName><forename type="first">Jiliang</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charu</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Huan</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">42</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Correlation clustering</title>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Wirth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Encyclopedia of machine learning and data mining</title>
		<editor>
			<persName><forename type="first">Claude</forename><surname>Sammut</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">I</forename><surname>Webb</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer US</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="227" to="231" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
