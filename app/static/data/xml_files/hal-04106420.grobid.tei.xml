<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Earliest Query Answering for Deterministic Stepwise Hedge Automata</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Antonio</forename><surname>Al Serhali</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Lille</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Lille</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Earliest Query Answering for Deterministic Stepwise Hedge Automata</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EBF17E60BB3494F0FD2558CA06252C6E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Earliest query answering (EQA) is the problem to enumerate certain query answers on streams at the earliest events. We consider EQA for regular monadic queries on hedges or nested words defined by deterministic stepwise hedge automata (dShas). We present an EQA algorithm for dShas that requires time O(c m) per event, where m is the size of the automata and c the concurrency of the query. We show that our EQA algorithm runs efficiently on regular XPath queries in practice.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Streaming algorithms for hedges or nested words were widely studied for complex event processing <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b6">7]</ref> and for transforming XML documents in an online manner <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b3">4]</ref>. The open end of a stream can be instantiated continuously. Therefore, streams can be seen as incomplete databases, for which the notion of certain query answers (CQAs) was widely studied <ref type="bibr" target="#b8">[9]</ref>. An element is a certain query answer if it is selected by all completions of the incomplete database. For instance, the XPath query following::a[following::b] selects all a-elements of a nested word (modeling an XML document) that are followed eventually by some b-element. On the stream aabaabaaaaa . . . all a-positions before the b are CQAs of this query, while those after are not.</p><p>Earliest query answering (EQA) is the problem of detecting CQAs on streams at the earliest event <ref type="bibr" target="#b5">[6]</ref>. We study EQA for regular monadic queries which select nodes of trees or hedges. For this, we consider streams that elongate prefixes of nested words such as aa b a b . . . to well-nested words. EQA requires to decide the existence of CQAs which is computationally hard problem even for tiny fragments of regular XPath queries <ref type="bibr" target="#b2">[3]</ref>, since Cqa is a universality problem concerning all completions of the stream. Gauwin et al. <ref type="bibr" target="#b5">[6]</ref> showed that EQA can be done in polynomial time for monadic queries defined by deterministic nested word automata (dNwas) <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b14">15]</ref>. Their algorithm, however, requires time O(c n 2 ) per event, where the concurrency c is the number of alive candidates of the query (not of the algorithm) and n the number of the automaton states. In the worst case c may be the length of the stream for monadic queries, so the overall complexity may be quadratic in the size of the stream too.</p><p>For complex event processing <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b6">7]</ref> EQA has often been avoided, by restricting the class of queries such that the certainty of an answer candidate depends only on the past of the stream and not on its future <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b6">7]</ref>. This rules out XPath query with filters such as following::a[following::b]. Riveros et al. <ref type="bibr" target="#b11">[12]</ref> proposed instead to enumerate the query answers late at the end of the stream, which however requires to buffer a large number of candidates. For XML streaming, EQA was often approximated <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b3">4]</ref> so that all CQAs are eventually selected but not always earliest. Or else, as done by Saxon <ref type="bibr" target="#b7">[8]</ref>, only very restricted regular XPath queries were permitted.</p><p>A major bottleneck for automata based EQA algorithms in practice <ref type="bibr" target="#b3">[4]</ref> was the difficulty to compile regular path queries on nested words to deterministic automata that are reasonably small. This problem was solved recently <ref type="bibr" target="#b0">[1]</ref> based on stepwise hedge automata (Shas) <ref type="bibr" target="#b12">[13]</ref> and schema-based determinization <ref type="bibr" target="#b13">[14]</ref>. Shas naturally generalize on finite state automata for words and trees. They can recognize all regular languages of hedges equally to Nwas but don't have any explicit stack (such as tree automata). Shas can always be determinized in a bottom-up and left-to-right manner. Nwas can also be determinized but differently, since their determinization has to deal with top-down processing via explicit stacks, often leading to a huge size increase.</p><p>The availability of dShas for regular path queries gave new hope for the feasibility of EQA in practice. For this, however, more efficient EQA algorithms are needed. In particular, the time per event should no more be quadratic in n and neither should the preprocessing time be cubic in n. Sakho <ref type="bibr" target="#b16">[17]</ref> showed recently that EQA for boolean dSha queries can be done time O(m) per event, where m is the overall size of the automaton. This improvement relies on the fact, that the set of accessible states of an dSha can be computed time O(m), while for dNwas it requires time O(n 2 ) after O(n 3 ) preprocessing, where n the number of the states of the automaton.</p><p>In the present paper, we present a new EQA algorithm for monadic dSha queries. Our approach is to adapt the general idea's of Gauwin from dNwas to dShas. This yields an EQA algorithm in time O(c m) per event where c is the concurrency c of the query. Gauwin's quadratic factor n 2 is reduced to m while the cubic preprocessing in time O(n 3 ) is removed. The algorithm obtained is more efficient than the best previous EQA algorithm, based on a reduction to Gauwin's EQA algorithm by compiling dShas to dNwas in linear time.</p><p>We implemented our new EQA algorithm in the AStream tool and applied it the regular XPath queries from the XPathMark collection <ref type="bibr" target="#b4">[5]</ref> scaling to huge documents, and to the regular XPath queries extracted from practical XSLT programs by Lick and Schmitz <ref type="bibr" target="#b9">[10]</ref> but on smaller documents. It turns out that AStream runs efficiently on huge XML documents (&gt;100GB) for all queries with low concurrency. Some queries can be answered in streaming mode where the best existing non earliest query answering algorithm failed to be earliest <ref type="bibr" target="#b3">[4]</ref>.</p><p>Outline. We start with preliminaries in Section 2, 3, and 4. An earliest membership tester for dShas is presented in Section 5 and a late streaming algorithm for answering monadic queries in Section 6. We then present our new EQA algorithm in Section 7 and discuss experimental results with AStream in Section 8. Complete proofs and supplementary material are given in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Let A and B be sets. A partial function f :</p><formula xml:id="formula_0">A → B is a relation f ⊆ A × B that is functional. The domain of a partial function is dom(f ) = {a ∈ A | f (a) ∈ B}. A total function f : A → B is a partial function f : A → B with dom(f ) = A.</formula><p>Let N be the set of natural numbers including 0. Words. Let alphabet Ω be a set. The set of words over Ω is Ω * = ∪ ∞ n∈N Ω n . A word (a 1 , . . . , a n ) ∈ Ω n is written as a 1 . . . a n . We denote the empty word of length ε ∈ Ω 0 and by</p><formula xml:id="formula_1">v 1 • v 2 ∈ Ω * the concatenation of two words v 1 , v 2 ∈ Ω * .</formula><p>For any word v ∈ Ω * let prefs(v) ⊆ Ω * be the set of its prefixes. For any v ∈ Ω * and a ∈ Ω let # a (v) be the number of occurrences of a in v. Hedges. Hedges are sequences of letters and trees h with some hedge h. More formally, a hedge h ∈ H Ω has the following abstract syntax: </p><formula xml:id="formula_2">h, h ∈ H Ω ::= ε | a | h | h • h where a ∈ Ω We assume ε • h = h • ε = h and (h • h 1 ) • h 2 = h • (h 1 • h 2 ).</formula><formula xml:id="formula_3">H Ω → (Ω ∪ { , }) * such that: nw (ε) = ε, nw ( h ) = • nw (h) • , nw (a) = a, and nw (h • h ) = nw (h) • nw (h ).</formula><p>The set of nested word prefixes is nwprefs Ω = prefs(nw (H Ω )) ⊆ Ω * . Note that nested word prefixes may lack closing parenthesis, in which case they are not well-nested. Monadic Queries. Let Σ be a set. A monadic query Q on hedges with signature Σ is a function that maps any hedge h ∈ H Σ to a subset of its positions Q(h) ⊆ pos(h). We next relate monadic queries on hedges to hedge languages. For this, we fix a selection variable x ∈ Σ arbitrarily and consider hedge languages over signature Σ x = Σ ∪ {x}. For any h ∈ H Σ let h ∈ H Σ∪pos(h) be its annotation with its positions. For instance aa a = a1a2 3 a4. For any variable assignment α : {x} → pos(h) we define the hedge h * α ∈ H Σ x annotated with x by substituting in h the position α(x) by x and removing all other positions. For instance, aa a * [x/2] = aax a. The monadic query on hedges with signature Σ defined by a hedge language L ⊆ H</p><formula xml:id="formula_4">Σ x is qry L (h) = {α(x) | α : {x} → pos(h), h * α ∈ L}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Stepwise Hedge Automata</head><p>We define regular hedge languages by stepwise hedge automata (dShas).</p><formula xml:id="formula_5">Definition 1. A d Sha is a tuple A = (Ω, Q, δ, q init , F )</formula><p>where Ω and Q are finite sets, q init ∈ Q, F ⊆ Q, and δ = ((a δ ) a∈Ω , δ , @ δ ) where:  There are states q ∈ Q, an initial state is q init and final states in F . The transition rules in δ have three forms: If a δ (q) = q then we have an internal rule q a -→ q , if q@ δ p = q then we have an apply rule q p q , and if q = δ ∈ Q then we have a tree initial rule -→ q. We denote by n = |Q| the number of states of A, and by m = n + |Ω| + a∈Ω |a δ | + |@ δ | + |F | + 2 its overall size. Note that m ∈ O(n 2 + |Ω| n) by determinism. For any hedge h ∈ H Σ we define the transition h δ = h : Q → Q such that for all q ∈ Q, a ∈ Ω, and h, h ∈ H Σ :</p><formula xml:id="formula_6">a δ : Q → Q, δ ∈ Q, and @ δ : Q × Q → Q.</formula><formula xml:id="formula_7">ε (q) = q a (q) = a δ (q) h • h (q) = h ( h (q)) h (q) = q@ δ ( h ( δ ))</formula><p>A hedge is accepted if its transition from the initial state yields some final state. The language L(A) is the set of all accepted hedges:</p><formula xml:id="formula_8">L(A) = {h ∈ H Ω | h (q init ) ∈ F }.</formula><p>We call a hedge language L ⊆ H Ω regular if it can be defined by some dSha. A monadic query over hedges in H Σ is called regular if it is equal to qry L for some regular hedge language L ⊆ H Σ x . For example let Ω = Σ x where Σ = {a}. We draw in Fig. <ref type="figure" target="#fig_0">1</ref> the graph of a dSha for the query on hedges in H Σ that selects the positions 1, . . . , n -1 on hedges of the form a n • h • h if h does not start with letter "a" and position n otherwise. The drawing of dShas are similar as for usual finite state automata, except that now, edges may also be labeled by states and not only by letters.</p><p>A successful run of this automaton on the hedge aaax a a is given in Fig. <ref type="figure" target="#fig_1">2</ref>. In state 5 the transition must suspend on the result of the evaluation of the subhedge, which is started by the tree initial rule -→ 1. The two edges 5 and 3 are justified by the apply rule 5 3 9: the suspended computation in state 5 is resumed in state 9 when going up from the subtree in state 3.</p><p>The set of states that are accessible from a state q ∈ Q through some hedge is acc δ (q) = {q | q = h (q), h ∈ H Ω }. For any Q ⊆ Q, the set acc δ (Q) can be computed in time O(m) as well as invacc δ (Q) = {q | q ∈ acc δ (q ), q ∈ Q}. A tree state is a state in P = acc δ ( δ ). We call a set of transition rules δ complete if @ δ | Q×P is a total function, as well as all a δ where a ∈ Ω. For instance, the dSha in Fig. <ref type="figure" target="#fig_0">1</ref> has the tree states P = {1, 3, 7}. Note that δ is not complete since x δ is not total. But its restriction to the letters in Σ = {a} is complete due to the sink state 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Nested Word Automata</head><p>We define streaming algorithms for dShas by infinitary nested word automata (dNWAs ∞ ). These have the advantage to run naturally in streaming mode, while being able to pass information top-down, bottom-up, and left to right. In contrast, dShas cannot pass any information top-down. Definition 2. An dNWA ∞ is a tuple B = (Ω, Q, Γ, δ, q init , F ), where Ω, Γ and Q are sets, q init ∈ Q, F ⊆ Q, and δ = ((a δ ) a∈Ω , δ , δ ) contains partial functions</p><formula xml:id="formula_9">a δ : Q → Q, δ : Q → Γ × Q, and δ : Q × Γ → Q. A d Nwa is a dNWA ∞ whose sets Q, Ω, and Γ are finite.</formula><p>The elements of Γ are called stack symbols. The transition rules in δ have three forms: letter rules q a -→ q , opening rules q ↓γ --→ q for pushing a stack symbol if δ (q) = (q , γ) and closing rules q ↑γ --→ q popping a stack symbol if δ (q, γ) = q . Any dNWA ∞ defines a pushdown machine that runs on words with parenthesis. A configuration of this machine is a pair in K = Q × Γ * of a state and a stack. For any word v ∈ Ω * , we define a streaming transition v δ str = v str : K → K such that for all q ∈ Q, stacks s ∈ Γ * and γ ∈ Γ : a str (q, s) = (a δ (q), s) str (q, s • γ) = ( δ (q, γ), s) ε str (q, s) = (q, s) str (q, s) = (q , s • γ) where (q , γ) = δ (q) v • v str (q, s) = v str (q , s ) where (q , s ) = v str (q, s)</p><formula xml:id="formula_10">A word v ∈ Ω * is accepted if nw (h) str (q init , ε) yields a final configuration in F × {ε}:</formula><p>The language of a dNWA ∞ is the set of nested words that it accepts:</p><formula xml:id="formula_11">L(B) = {v ∈ Ω * | v str (q init , ε) ∈ F × {ε}}.</formula><p>Since the initial and final stack are required to be empty it follows that any word L(B) is well-nested.</p><p>For any dSha A = (Ω, Q, δ, q init , F ) we define the dNwa A nwa = (Ω, Q, Γ, δ nwa , q init , F ) with Γ = Q such that δ nwa contains for all a ∈ Ω and q, p ∈ Q the rules q a -→ a δ (q), q ↓q --→ δ , and q ↑p --→ p@ δ q. In Fig. <ref type="figure">5</ref> we draw a run of the dNwa A nwa for the dSha in Fig. <ref type="figure" target="#fig_0">1</ref>. The graph of this dNwa is in Fig. <ref type="figure">6</ref>.</p><formula xml:id="formula_12">Lemma 3. L(A nwa ) = nw (L(A)).</formula><p>Intuitively, the lemma follows since the run of any dSha A can be identified with the run of the dNwa A nwa . To illustrate this, we reconsider the run of the dSha in Fig. <ref type="figure" target="#fig_1">2</ref> and compare it to the run of corresponding dNwa in Fig. <ref type="figure">5</ref>. The transition 5</p><p>1 of A nwa is justified by the opening rule 5</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>↓5</head><p>--→ 1: when entering the subtree, the current state 5 is pushed to the stack and the computation is continued in state 1. The edges 5 9 and 3 for the apply rule 5@3 → 9 of the dSha are mimicked by the closing rule 3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>↑5</head><p>--→ 9 of the dNwa: when going up from the subtree in state 3, the state 5 is popped from the stack and the computation continues in state 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Earliest Membership</head><p>A late streaming evaluator of a dSha A on hedges h ∈ H Ω can be obtained by evaluating the dNwa A nwa in streaming mode on the nested word of h, i.e., by testing nw (h) δ nwa str (q init , ε) ∈ F × {ε}. In this manner, h is never loaded into the memory. Instead, only a state and a stack are stored at any event, i.e. at any prefix of nw (h). The memory costs thus only depend on the depth of the hedge.</p><p>The decision of whether membership holds, however, is taken at the very end of the stream. Instead, we want to decide language membership at the earliest event when it becomes certain. We consider Σ-certain membership to languages L ⊆ H Ω where Ω ⊇ Σ as needed for certain query answering later on.</p><formula xml:id="formula_13">Definition 4. Let Σ ⊆ Ω and L ⊆ H Ω . A nested word prefix v with letter in Ω satisfies cert-mem L Σ (v) if ∀h ∈ H Ω . (∃w ∈ Σ * . v • w = nw (h)) → h ∈ L.</formula><p>In other words, a nested word prefix v is Σ-certain for membership in L ⊆ H Ω , if any completion of v with letters from Σ to a hedge in H Ω belongs to L. For instance, if Σ = {a} then the prefix v = aaax a is Σ-certain for the language of the dSha A with signature Ω = {a, x} in Fig. <ref type="figure" target="#fig_0">1</ref>, since any completion of v without further x'es will be accepted by A.</p><p>Since certain membership is a universality property, we need to consider universal automata states. Given a state q ∈ Q let A[q init /q] = (Ω, Q, δ, q, F ) be obtained from A by replacing its initial state by q. We define:</p><formula xml:id="formula_14">q ∈ universal A Σ ⇔ H Σ ⊆ L(A[q init /q])</formula><p>In order to characterize universality by accessibility, we define for all Q ⊆ Q:</p><formula xml:id="formula_15">safe δ (Q) = {q ∈ Q | acc δ (q) ⊆ Q} If δ is complete then safe δ (Q) = Q \ invacc δ (Q \ Q), so it can be computed in O(m).</formula><p>For any Σ ⊆ Ω, let δ| Σ be the restriction of δ to the letters of Σ, i.e., δ| Σ = ((a δ ) a∈Σ , δ , @ δ ).</p><p>Lemma 5. Let A = (Ω, Q, δ, q init , F ) be a d Sha and Σ ⊆ Ω such that δ| Σ is complete, and q ∈ Q. Then:</p><formula xml:id="formula_16">q ∈ universal A Σ ⇔ q ∈ safe δ| Σ (F ).</formula><p>Safety can be used to detect certain language membership. For this we define for any Q ⊆ Q and q ∈ Q such that q@ δ p is well-defined for some p ∈ Q:</p><formula xml:id="formula_17">d δ (q, Q) = safe δ (dn @ δ (q, Q)) where dn @ δ (q, Q) = {p ∈ Q | q@ δ p ∈ Q}.</formula><p>Note that if q@ δ p is undefined for all p then d δ (q, Q) remains undefined too. We define the dNwa A c Σ for testing certain Σ-membership to L(A) as follows.</p><formula xml:id="formula_18">Q c Σ = Q × 2 Q = Γ c Σ , q init c Σ = (q init , safe δ| Σ (F )).</formula><p>The transition rules in δ c Σ allow for all S ⊆ Q, q, p ∈ Q, and a ∈ Ω:</p><p>(q, S)</p><formula xml:id="formula_19">↓(q,S) ----→ ( δ , d δ| Σ (q, S)), p ↑(q,S)</formula><p>----→ (q@ δ p, S), (q, S) a -→ (a δ (q), S).</p><formula xml:id="formula_20">Finally, let A c Σ = (Ω, Q c Σ , Γ c Σ , δ c Σ , q init c Σ , F c Σ ) where F c Σ = F × 2 Q . In the first component A c Σ behaves like A nwa , while in the second component it computes safety information. Therefore, L(A) = L(A nwa ) = L(A c Σ )</formula><p>. We next show that the streaming evaluator of A c Σ detects certain membership at any time.</p><formula xml:id="formula_21">Proposition 6. Let A = (Ω, Q, δ, q init , ) be a d Sha, v ∈ nwprefs Ω a nested word prefix, and Σ ⊆ Ω such that δ| Σ is complete. If q ∈ Q and S ⊆ Q such that ((q, S), ) = v δ c Σ str (q init c Σ , ε) then: cert-mem L(A) Σ (v) ⇔ q ∈ S.</formula><p>We illustrate Proposition 6 in Fig. <ref type="figure">7</ref> at the dSha A from Fig. <ref type="figure" target="#fig_0">1</ref>. Recall that it has signature Ω = Σ x where Σ = {a}. Given that δ| Σ is complete, Σcertain membership of aaax a a to L(A) can be detected at the earliest event aaax a, by running the streaming evaluator of earliest automaton A c Σ . Note that the earliest automaton is a dNwa passing safety information top-down (while dShas cannot pass any information top-down). We have safe δ| Σ ({9}) = {9} and d δ| Σ (5, {9}) = {3}. Hence aaax</p><formula xml:id="formula_22">δ c Σ str (q init c Σ ) = ((1, {3}), s)</formula><p>where the stack is s = (5, {9}). Since 1 ∈ {3}, membership is not yet Σ-certain. Indeed, the Σ-completion aaax is not accepted. After reading the next letter a, we have aaax a δ c Σ str = ((3, {3}), s). Since the current state 3 belongs to the current set of safe states {3}, membership is Σ-certain, i.e., membership of all completions without further x'es.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Late Monadic Query Answering</head><p>We study the problem of how to answer monadic queries on hedges in streaming mode, while selecting query answers lately at end of the stream.</p><p>Our algorithm will generate candidates [x/π] binding the selection variable x to positions π of the input hedge. We want to formulate the streaming algorithm without fixing the input hedge a priori, thus we consider the infinite set of candidates Cands = {α | α : {x} → N}. Given a dSha A with signature Σ x and a hedge h ∈ H Σ , our algorithm computes the answer set qry L(A) (h) in streaming mode. For this, we compile A to the late dNWA ∞ A l and run the streaming</p><formula xml:id="formula_23">0[]∅ 2[]∅ 5[x/1]∅ 4 = 2@ δ 3 9 = 8@ δ 3 4 = 5@ δ 3 D 4[]∅ 9[x/2]∅ 4[x/1]∅ 1[]∅ 1[x/1]{x} 1[x/2]{x} ↓D ↑D D=    2[]∅ 8[x/1]∅ 5[x/2]∅ 3[]∅ 3[x/1]{x} 3[x/2]{x}    = E E a a a @ @ @</formula><p>Fig. <ref type="figure">3</ref>: The run of the late dNwa A l for the dSha A in Fig. <ref type="figure" target="#fig_0">1</ref> on aa a .</p><p>evaluator of A l on the nested word nw (h). The aphabet of A l is Σ ∪ N. It has the state set Q l = 2 Q×Cands×2 {x} = Γ l and the initial state q l init = {(q init , [], ∅)}. If the evaluator goes into some state D ∈ Q l , then (q, α, V ) ∈ D means that the candidate α is in state q with A nwa while the variables in V ⊆ dom(α) were bound in the context, i.e., before the last dangling opening parenthesis (so a preceding node that is not a preceding sibling). The set δ l contains the following transition rules for all D, E ∈ Q l , a ∈ Σ, V ⊆ {x}, and π ∈ N:</p><formula xml:id="formula_24">D a -→ {(a δ (q), α, V ) | (q, α, V ) ∈ D} D π -→ {(x δ (q), [x/π], ∅) | (q, [], ∅) ∈ D} ∪ D D ↓D --→ {( δ , α, dom(α)) | (q, α, V ) ∈ D} E ↑D --→ {(q@ δ p, α , V ) | (q, α, V ) ∈ D, (p, α , dom(α)) ∈ E, α ∈ {[], α }}</formula><p>When reading a position π ∈ N in a state D that contains a triple with the empty candidate (q, [], ∅), a new candidate [x/π] is created, and the triple (x δ (q), [x/π], ∅) is added to D. At opening events, the current state D of A l is pushed onto the stack. It is also updated for continuation: if D contains a triple with candidate α, then the next state of A l contains ( δ , α, dom(α)). At closing events, the state D of the parent hedge is popped from the stack. Let E be the current state. Any (q, α, V ) ∈ D must be matched with some (p, α , dom(α)) ∈ E, so that A l can continue in q@ δ p. Matching here means that either α = α or, α = [x/π] and α = []. This is expressed by the condition α ∈ {[], α }. Note that if α = [] matches α = [x/π] then dom(α) = ∅ so that π was not bound in the context. This is where the knowledge on the context is needed.</p><p>An example run of A l on the hedge aa a is given in Fig. <ref type="figure">3</ref>, where A is the dSha A from When reading the closing parenthesis D is popped from the stack, its tuples in state q are matched with tuples in state p those from with E as illustrated in the figure, so that one can apply the apply rules q@ δ p of A. The tuple in state 5 of D, for instance, matches the tuple in state 3 of E, so A l continues the candidate [x/2] in state 9 = 5@ δ 3. Since 9 ∈ F A , position 2 is selected, i.e. 2 ∈ qry L(A) (aa a ).</p><p>Proposition 7 (Correctness of the late streaming evaluator).</p><formula xml:id="formula_25">If (D, ε) = nw ( h) δ l str (q l init , ε) then qry L(A) (h) = {π | (q, [x/π], ∅) ∈ D, q ∈ F }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Certain Answers and Earliest Query Answering</head><p>In order to justify early selection, we need the concept of certain answers. Let Q be a monadic query on H Σ and v ∈ nwprefs Σ a nested word prefix.</p><formula xml:id="formula_26">Definition 8. A position π ∈ N is a certain answer of Q at prefix v -written π ∈ CA Q (v) -if π ∈ pos(v) ∧ ∀h ∈ H Σ . v ∈ prefs(nw (h)) → π ∈ Q(h).</formula><p>A position π is thus a certain answer of query Q at prefix v of the stream if it answers the query for all completions h of v. Certain answers can be safely selected however the stream continues. For instance, the position 3 is a certain answer on the prefix aaa a for the query defined by the dSha in Fig. <ref type="figure" target="#fig_0">1</ref>.</p><p>In analogy we can define that π is certainly a nonanswer of Q at v, and denote this by π ∈ CNA Q (v). Once π becomes a certain nonanswer then it can be safely rejected. The positions 1, ..., n -1, for instance, are certain nonanswers on our example query on a n a. We call a position π alive for Q at v it it is neither a certain answer nor a certain nonanswer of Q at v. The concurrency c of Q at v is its number of alive candidates. For the shorter prefix aaa , for instance, all n positions 1, . . . , n are alive, so the concurrency is n.</p><p>We next want to link certain answers to certain Σ-membership. For this we need to annotate nested word prefixes with positions and variables, similarly as for hedges. Given a word v ∈ Σ, the set of positions of v then is pos(v) = {1, . . . , # Σ∪{ } (v)}. We can define the annotation of v with its positions as a word v ∈ ( Σ ∪ pos(v)) * . For any variable assignment α : {x} → pos(v) we define an annotated word v * α ∈ Σ x * in analogy as for hedges.</p><formula xml:id="formula_27">Lemma 9. For any prefix v ∈ prefs(nw (H Σ )), language L ⊆ H Σ x and candi- date α = [x/π] with π ∈ pos(v): cert-mem L Σ (v * α) ⇔ π ∈ CA qry L (v).</formula><p>Proposition 10 (Corollary of Proposition 6 and Lemma 9). Let A = (Σ x , , δ, q init , ) be a d Sha such that δ| Σ is complete. For any v ∈ nwprefs Σ , π ∈ pos(v), and ((q, S),</p><formula xml:id="formula_28">) = v * [x/π] δ c Σ str (q init c Σ , ε): π ∈ CA qry L(A) (v) ⇔ q ∈ S .</formula><p>For any dSha A over Σ x , we construct the earliest dNWA ∞ A e with alphabet Σ ∪ N, testing for all candidates [x/π] on prefixes v, whether π is certain for selection. For this A e simulates the runs of</p><formula xml:id="formula_29">A c Σ on all v * [x/π]. It has the states Q e = Q × Cands × 2 {x} × 2 Q = Γ e and q e init = {(q init , [], ∅, safe δ| Σ (F ))}. Initially, 0[]∅{9} 2[]∅{9} 5[x/1]∅{9} 2[]∅{9} 5[x/2]∅{9} 8[x/1]∅{9} 4[]∅{9} 9[x/2]∅{9} 4[x/1]∅{9} 1[]∅∅ 1[x/2]{x}{3} 1[x/1]{x}{7} 3[]∅∅ 3[x/2]{x}{3} 3[x/1]{x}{7} a a a</formula><p>Fig. <ref type="figure">4</ref>: A run of the earliest automaton A e for the dSha A in Fig. <ref type="figure" target="#fig_0">1</ref>.</p><p>all states in safe δ| Σ (F ) are safe for selection. Let δ e contain the following rules for all M, N ∈ Q e , a ∈ Σ, π ∈ N, S ⊆ Q and q ∈ Q:</p><formula xml:id="formula_30">M a -→ {(a δ (q), α, V, S) | (q, α, V, S) ∈ M } M π -→ {(x δ (q), [x/π], ∅, S) | (q, [], ∅, S) ∈ M } ∪ M M ↓M ---→ {( δ , α, dom(α), d δ| Σ (q, S)) | (q, α, V, S) ∈ M } N ↑M ---→ ({(q@ δ p, α , V, S) | (q, α, V, S) ∈ M, (p, α , dom(α), S ) ∈ N, α ∈ {[], α }}</formula><p>For the dSha A in Fig. <ref type="figure" target="#fig_0">1</ref>, for instance, a run of A e is given in Fig. <ref type="figure">4</ref>. It satisfies a1a2 3a4 δ e str (q e init , ε) = ({(3, [x/2], {x}, {3, 4}), (3, [x/1], {x}, {4, 9})}, ). The certain answer [x/2] is in a safe state now, while the other candidate [x/1] can be seen to be safe for rejection so it could be removed. Proposition 11. Let A be a d Sha with signature Σ x such that δ| Σ is complete. For any nested word prefix v ∈ nwprefs Σ with v δ e str (q e init , ε) = (M, ):</p><formula xml:id="formula_31">CA qry L(A) (v) = {α(x) | q ∈ S ∧ (q, α, ∅, S) ∈ M ∧ dom(α) = {x}}</formula><p>We can thus obtain an EQA algorithm by running the streaming evaluator of the earliest automaton A e . Without removing candidates that are certainly nonanswers, however, it would maintain and update many candidates that are no more alive, leading to quadratic time in O(m 2 ) even for bounded concurrency. This complexity for dShas improves on Gauwin et al. <ref type="bibr" target="#b5">[6]</ref> for dNwas, which required time O(c n 2 ) per event after O(n 3 ) preprocessing time. Note also that EQA for monadic queries can also be used to detect certain membership for language of dShas. In this case, we have c = 1 so the time per event is reduced to O(m). Finally, for monadic queries where c is bounded for all events and input hedges, the complexity per event is also reduced to O(m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Experimentation</head><p>We present experimental results of our EQA algorithm that we implemented in the AStream tool, with current version 3.36. The objective is to relate the theoretical complexity to practical efficiency. We note that we implemented AStream in Scala while using Java's abc-datalog for safety computation.</p><p>First, we consider a collection of 77 regular XPath queries <ref type="bibr" target="#b0">[1]</ref> that was selected from the larger collection of XPath queries harvested by Lick and Schmitz <ref type="bibr" target="#b9">[10]</ref> from real-world XSLT program. The queries are listed in Table <ref type="table" target="#tab_2">2</ref>. A single matching XML document per XSLT program of size less than 2MB was provided too. We used the dShas for these XPath queries from <ref type="bibr" target="#b0">[1]</ref> as inputs (so the time for the automaton construction is ignored here). We could correctly answer all the 77 queries, yielding the same answer set as with Saxon. The overall time for computing the 77 answer sets was in 1:50 minute on a Macbook pro Apple M1 laptop with 16GB of RAM. With Saxon in-memory evaluation it required 0:45 minutes. The low running time of AStream reflects the low concurrency of all the queries on all these documents according to Theorem 1. There are 12 queries with concurrency 1, 47 with concurrency 2, 6 with concurrency 3, and 12 with concurrency 4. Our efficiency results for AStream thus show for the first time, that EQA is indeed feasible in practical scenarios with queries of low concurrency.</p><p>Second, we compare AStream to existing streaming tools for regular XPath queries with large coverage. We focus on the most efficient streaming evaluator called QuiXPath <ref type="bibr" target="#b3">[4]</ref>. A detailed comparison to the many alternative tools is given there too. We note that QuiXPath is not always earliest, but still earliest in most cases. As done there, we consider the queries A1-A8 of the XPathMark collection <ref type="bibr" target="#b4">[5]</ref>, see Table <ref type="table" target="#tab_1">1</ref>. The other queries are either not regular or contain backward axis that our compiler to Shas does not support. We also added the queries O1 and O2 from <ref type="bibr" target="#b3">[4]</ref>, in order to illustrate difficulties of non-earliest query answering and high concurrency. The XPathMark collection also provides a generator for scalable XML documents. We run AStream on XML documents of increasing size up to 1.2GB, but can also stream much larger documents &gt;100GB. Up to 1GB we verified the correctness of the answer sets by comparison to Saxon's inmemory evaluator (which is limited to 1GB).</p><p>The running times on the scaling documents are reported in Fig. <ref type="figure" target="#fig_5">8</ref>. The times grow linearly for all these queries except O1, given that their concurrency is bounded to 2. In contrast the time grows quadratically for query O1, since its concurrency grows linearly with the size of the document. The quadratic growth can be observed more clearly in Fig. <ref type="figure" target="#fig_6">9</ref> on smaller documents scaling from 27KB to 5MB. In average on the XPathMark queries A1-A8, AStream 3.36 is by a factor of 60 slower than QuiXPath, so requiring minutes instead of seconds. The main reason for this is the lack of streaming projection algorithms for dShas. In contrast, QuiXPath uses streaming projection for queries defined by dNwas with selection states <ref type="bibr" target="#b17">[18]</ref>. On the one hand side, QuiXPath cannot stream query O2 on large documents, since not being earliest. While the concurrency of O2 is 1, linearly many candidates are buffered by QuiXPath, until the buffer overflows for documents larger than 5GB. For AStream's EQA algorithm, this query is not a problem since having low concurrency. On the other hand, QuiXPath can stream queries with high concurrency such as O1, where AStream 3.36 runs out of time for documents of 1MB. This is due to QuiXPath's state sharing, i.e. the sharing of the computations of all concurrent candidates in the same state. Conclusion and Future Work. We introduced an EQA algorithm for regular monadic queries represented by dShas with a time complexity of O(c m) per event. Its implementation in the AStream tool has demonstrated its efficiency on queries in practical scenarios with low concurrency. However, in order to compete with the current best non-earliest streaming algorithms, we need to develop streaming projection for dShas (as done previously for NWAs <ref type="bibr" target="#b17">[18]</ref>), and to add some kind of factorization for candidates in the same state <ref type="bibr" target="#b3">[4]</ref>. Additionally, we plan to extend our streaming algorithm to hyperstreaming, which involves handling multiple streams with references and holes <ref type="bibr" target="#b16">[17]</ref>.</p><p>A Proofs for Section 2 (Preliminaries) Also, we define for any n ∈ N a hedge h n ∈ H Σ∪{n,...,n+|h|-1} by induction on the structure of h:</p><formula xml:id="formula_32">ε n = ε, a n = a • n, h • h n = h n • h n+|h| , h n = n • h n+1 • We then set h = h 1 . That is: h * α = h[α(x)/x][π/ε | π = α(x)]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Proofs for Section 3 (Stepwise Hedge Automata)</head><p>Accessibility can be defined equivalently by the following inference rules:</p><formula xml:id="formula_33">q a -→ q a ∈ Ω q ∈ acc δ (q) q 1 @ δ p = q 2 p ∈ acc δ ( δ ) q 1 ∈ acc δ (q) q 2 ∈ acc δ (q)</formula><p>For completing transition rules in linear time generally, we need to add else rules q --→ q that represent a set of |Ω| internal rules and apply else rules q -q that can represent a set of n apply rules. When doing so, m = n 2 +|Ω| n remains possible after completion.</p><p>C Proofs for Section 4 (Nested Word Automata)</p><p>Alternatively, dNWAs ∞ can also directly be run on hedges rather than on nested words. For this, we define transitions h δ = h : Q → Q for any hedge h ∈ H Σ , such that for all q ∈ Q:</p><formula xml:id="formula_34">ε (q) = q h • h (q) = h ( h (q)) a (q) = a δ (q)</formula><p>h (q) = δ ( h (q ), γ) where (q , γ) = δ (q) Lemma 12. nw (h) str (q, ε) = ( h (q), ε).</p><p>Proof. First, we prove a more general equality for any dNWA ∞ B = (Ω, Q, Γ, δ, q init , F ) and for all h ∈ H Ω , q ∈ Q and s ∈ Γ * such that:</p><formula xml:id="formula_35">nw (h) δ str (q, s) = ( h δ (q), s)</formula><p>The proof is done by induction on the structure of h. Let s ∈ Γ * and q ∈ Q be arbitrary, we then distinguish four cases of h: Case h = ε. So nw (h) = ε, we then have: nw (h) str (q, s) = ε str (q, s) = (q, s) = ( ε (q), s) = ( h (q), s)</p><p>Case h = a. With nw (h) = a, we have : nw (h) str (q, s) = a str (q, s) = (a δ (q), s) = ( a (q), s) = ( h (q), s)</p><formula xml:id="formula_36">0 2 2 2 5 1 3 ↓ 5 ↑ 5 9 9</formula><p>a a a x a a Fig. <ref type="figure">5</ref>: A successful run of the dNwa A nwa in Fig. <ref type="figure">6</ref> on aaax a a.</p><formula xml:id="formula_37">Case h = h 1 • h 2 . Thus, nw (h) = nw (h 1 ) • nw (h 2 )</formula><p>. The induction hypothesis applied to h 1 yields nw (h 1 ) str (q, s) = ( h 1 (q), s). Hence:</p><formula xml:id="formula_38">nw (h) str (q, s) = nw (h 1 ) • nw (h 2 ) str (q, s) = nw (h 2 ) str ( h 1 (q), s) streaming transition = ( h 2 ( h 1 (q)), s) induction on h 2 = ( h 1 • h 2 (q), s) Nwa transition = ( h (q), s) Case h = h 1 : We have nw (h) = • nw (h 1 ) • . Let (q , γ) = δ (q), thus: nw (h) str (q, s) = δ str ( nw (h 1 ) str ( str (q, s))) streaming transition = δ str ( nw (h 1 ) str (q , s • γ)) with (q , γ) = δ (q) = δ str ( h 1 (q ), s • γ) induction on h 1 = ( δ ( h 1 (q ), γ), s) streaming transition = ( h 1 (q), s)</formula><p>Nwa transition = ( h (q), s)</p><p>For s = ε, our lemma holds.</p><p>Lemma 13. The language of nested words accepted by a dNWAs ∞ satisfies:</p><formula xml:id="formula_39">L(B) = {nw (h) | h ∈ H Ω , h (q init ) ∈ F }</formula><p>Proof. This follows immediately from Lemma 12.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3. L(A nwa ) = nw (L(A)).</head><p>Proof. Based on Lemma 13 it is sufficient to show that:</p><formula xml:id="formula_40">L(A) = {h ∈ H Ω | h δ nwa (q init ) ∈ F }</formula><p>This follows from h δ (q) = h δ nwa (q) for all hedge h ∈ H Ω and q ∈ Q. So we prove this by induction on the structure of h.</p><p>Case h = ε. h δ (q) = ε δ (q) = q = ε δ nwa (q) = h δ nwa (q) Case h = a. h δ (q) = a δ (q) = a δ (q) = a δ nwa (q) = h δ nwa (q) Fig. <ref type="figure">6</ref>: The dNwa A nwa for the dSha in Fig. <ref type="figure" target="#fig_0">1</ref>.</p><formula xml:id="formula_41">Case h = h 1 • h 2 .</formula><p>With the induction hypothesis applied to h 1 yields h 1 δ (q) = h 1 δ nwa (q):</p><formula xml:id="formula_42">h δ (q) = h 1 • h 2 δ (q) = h 2 δ ( h 1 δ nwa (q)) Sha transition = h 2 δ nwa ( h 1 δ nwa (q)) induction on h 2 = h 1 • h 2 δ nwa (q) Nwa transition = h δ nwa (q)</formula><p>Case h = h 1 : Let ( δ , q) = δ (q) by the rules of A nwa , thus:</p><formula xml:id="formula_43">h δ nwa (q) = h 1 δ nwa (q) = δ ( h 1 δ nwa ( δ ), q) Nwa transition = δ ( h 1 δ ( δ ), q) induction on h 1 = q@ δ ( h 1 δ ( δ )) A nwa rules = h 1 δ (q) Sha transition = h δ nwa (q)</formula><p>D Proofs for Section 5 (Earliest Membership) Lemma 5. Let A = (Ω, Q, δ, q init , F ) be a d Sha and Σ ⊆ Ω such that δ| Σ is complete, and q ∈ Q. Then: q ∈ universal A Σ ⇔ q ∈ safe δ| Σ (F ).</p><p>Proof. Let q ∈ Q and Σ ⊆ Ω. For the direction "⇐" we assume that q ∈ safe δ| Σ (F ). To show q ∈ universal A Σ , we have to show for any h ∈ H Σ that h ∈ L(A[q init /q])). So let h ∈ H Σ be arbitrary. Since δ| Σ is complete, there exists q = h (q). Hence, q ∈ acc δ (q). Since q ∈ safe δ| Σ (F ), this implies q ∈ F and so h ∈ L(A[q init /q])). For the direction "⇒" we assume that q ∈ universal A Σ . So H Σ ⊆ L(A[q init /q]), i.e., for any h ∈ H Σ we have h (q) ∈ F . Hence acc δ | Σ (q) ⊆ F , i.e., q ∈ safe δ| Σ (F ). Proposition 6. Let A = (Ω, Q, δ, q init , ) be a d Sha, v ∈ nwprefs Ω a nested word prefix, and</p><formula xml:id="formula_44">Σ ⊆ Ω such that δ| Σ is complete. If q ∈ Q and S ⊆ Q such that ((q, S), ) = v δ c Σ str (q init c Σ , ε) then: cert-mem L(A) Σ (v) ⇔ q ∈ S.</formula><p>Proof. Nested word prefixes may contain dangling opening parenthesis but no dangling closing parenthesis. We prove the equivalence for all v and A by induction on the number of dangling opening parenthesis in v. So let ((q, S), s) = v δ c Σ str (q init c Σ , ε) for some stack s ∈ (Γ c Σ ) * . In the base case, v does not have dangling opening parenthesis, so v is wellnested. The transition rules of δ c Σ change the states in the first component in the same manner than δ. Furthermore, the subset S of target states in the second component remains unchanged when reading letters in Ω. The same holds when processing trees w where w is well-nested: the target set S is pushed to the stack at the opening parenthesis and popped from the stack at the closing parenthesis for continuation. Therefore the assumption v δ c Σ str (q init c Σ , ε) = ((q, S), s) implies that S = safe δ| Σ (F ), s = ε and v δ (q init ) = q. Hence, cert-mem</p><formula xml:id="formula_45">L(A) Σ (v) ⇔ H Ω ⊆ L(A[q init /</formula><p>q]). By Lemma 5 and the completeness of δ| Σ , this is equivalent to q ∈ safe δ| Σ (F ) and thus to q ∈ S.</p><p>For the induction step, we consider a nested word prefix v with at least one dangling opening parenthesis. We split v at the first dangling parenthesis such that v = v 1 • • v 2 for some v 1 and v 2 . This implies that v 1 ∈ nw (H Ω ) in contrast to v 2 . Let ((q 1 , S 1 ), s 1 ) = v 1 δ c Σ str ((q init c Σ , ε). Since the word v 1 is well-nested, we will reach the first dangling parenthesis with the empty stack, so s 1 = ε and S 1 = safe δ| Σ (F ). Reading the first dangling opening parenthesis in this configuration yields</p><formula xml:id="formula_46">δ c Σ str ((q 1 , S 1 ), ε) = ((t, S 2 ), γ) where S 2 = d δ| Σ (q 1 , S 1 ) and γ = (q 1 , S 1 ). Let A 2 = A[q init / δ , F/F 2 )] where F 2 = dn @ δ (q 1 , S 1 ). Let I = ( δ , safe δ| Σ (F 2 )) be the initial state of A 2 c Σ . Note that safe δ| Σ (F 2 ) = d δ| Σ (q 1 , S 1 ). The assumption v δ c Σ str (q init c Σ , ε) = ((q, S), s) implies: v 2 δ c</formula><p>Σ str (I, γ) = ((q, S), s). Since the first dangling opening parenthesis of v will never be closed, the first stack symbol γ is never popped when reading v 2 , so we have s = γ • s for some stack s . Therefore, γ can be canceled out, showing: v 2 δ c Σ str (I, ε) = ((q, S), s ). Hence, cert-mem</p><formula xml:id="formula_47">L(A) Σ (w) is equivalent to cert-mem L(A2) Σ (w 2 )</formula><p>. By induction hypothesis applied to v 2 and A 2 , this is equivalent to q ∈ S.</p><formula xml:id="formula_48">0{9} 2{9} 2{9} 2{9} 5{9} 1{3} 3{3} ↓ 5{9} ↑ 5{9}</formula><p>9{9} 9{9} a a a x a a Fig. <ref type="figure">7</ref>: A successful run of the dNwa A c Σ on aaax a a.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Proofs for Section 6 (Late Monadic Query Answering)</head><p>The correctness of the late automaton is stated by the following lemma.</p><formula xml:id="formula_49">Lemma 14. h δ l (q l init ) = {(q, α, ∅) | q = h * α δ (q init ), α : {x} → pos(h)}}</formula><p>Proof. We call a state D ∈ Q l admissible if any (q, α, V ) ∈ D satisfies V ⊆ dom(α). Note that all states accessible from q l init via δ l are admissible. For any n ∈ N and variable assignment α : {x} → {n, . . . , n + |h| -1} we define a hedge h * n α ∈ H Σ x by substituting in h n the position α(x) if defined by x and removing all other positions:</p><formula xml:id="formula_50">h * n α = h n [α(x)/x][π/ε | π = α(x)]</formula><p>Clearly, h * α = h * 1 α. We call a state D ∈ Q l applicable to h with offset n if ( , [x/π], V ) ∈ D implies π &lt; n. We will prove for all h ∈ H Σ , n ∈ N, and admissible states D ∈ Q l that are applicable with offset n:</p><formula xml:id="formula_51">h n δ l (D) = {( h * n [x/π] δ (q), [x/π], ∅) π ∈ {n, . . . , n + |h| -1}, (q, [], ∅) ∈ D } ∪{( h δ (q), α, V ) (q, α, V ) ∈ D }</formula><p>Applied with D = q l init and n = 0 this claim yields exactly the lemma. The proof is by induction on the structure of h, using the facts that admissibility and applicability are maintained while the offsets are adapted.</p><p>So let h ∈ H Σ , n ∈ N, and D ∈ Q l an admissible state that is applicable with offset n. We distinguish cases according to all possible forms of h:</p><formula xml:id="formula_52">Case h = a. We have h n = a • n and h * n [x/n] = a • x. h n δ l (D) = a • n δ l (D) = {(x δ (a δ (q)), [x/n], ∅) | (q, [], ∅) ∈ D} ∪ {(a δ (q), α, V ) | (q, α, V ) ∈ D} = {( a • n δ (q), [x/n], ∅) (q, [], ∅) ∈ D } ∪ {( a δ (q), α, V ) (q, α, V ) ∈ D } = {( h * n [x/n] δ (q), [x/n], ∅) (q, [], ∅) ∈ D } ∪ {( h δ (q), α, V ) (q, α, V ) ∈ D } Case h = ε. We have h n = ε and h * n [] = ε. h n δ l (D) = ε δ l (D) = D = {( h * n [x/π] δ (q), [x/π], ∅) π ∈ ∅, (q, [], ∅) ∈ D } ∪ {( h δ (q), α, V ) (q, α, V ) ∈ D } Case h = h 1 • h 2 . Let n 1 = n + |h 1 |. Then we have h n = h 1 n • h 2 n1</formula><p>. Hence:</p><formula xml:id="formula_53">h n δ l (D) = h 2 n1 δ l ( h 1 n δ l (D)) Let D 1 = h 1 n δ l (D), D 2 = h 2 n1 δ l (D 1 ) and n 2 = n 1 + |h 2 |.</formula><p>The induction hypothesis applied to h 1 , D, and n yields:</p><formula xml:id="formula_54">D 1 = ({( h 1 * n [x/π] δ (q), [x/π], ∅) π ∈ {n, . . . , n 1 -1}, (q, [], ∅) ∈ D} ∪ {( h 1 δ (q), α, V ) (q, α, V ) ∈ D })</formula><p>Note that D 1 is applicable with offset n 1 . The induction hypothesis applied to h 2 , D 1 , and n 1 yields:</p><formula xml:id="formula_55">D 2 = {( h 2 * n1 [x/π] δ (q 1 ), [x/π], ∅) π ∈ {n 1 , . . . , n 2 -1}, (q 1 , [], ∅) ∈ D 1 } ∪ {( h 2 δ (q 1 ), α, V ) (q 1 , α, V ) ∈ D 1 }</formula><p>Hence,</p><formula xml:id="formula_56">h n δ l (D) = {( h 2 * n1 [x/π] δ ( h 1 δ (q)), [x/π], ∅) π ∈ {n 1 , . . . , n 2 -1}, (q, [], ∅) ∈ D} ∪ {( h 2 δ ( h 1 * n [x/π] δ (q)), [x/π], ∅) π ∈ {n, . . . , n 1 -1}, (q, [], ∅) ∈ D} ∪ {( h 2 δ ( h 1 δ (q)), α, V ) (q, α, V ) ∈ D } Note that h 2 * n1 [x/π] δ ( h 1 δ (q)) = ( h 1 • h 2 * n [x/π] δ<label>(</label></formula><p>q) for any π ∈ {n, . . . , n 2 -1}, and similarly,</p><formula xml:id="formula_57">h 2 δ ( h 1 * n [x/π] δ (q)) = ( h 1 •h 2 * n [x/π] δ<label>(</label></formula><p>q) for any π ∈ {n, . . . , n 1 -1}. Thus</p><formula xml:id="formula_58">h n δ l (D) = {( h 1 • h 2 * n [x/π] δ (q), [x/π], ∅) π ∈ {n, . . . , n 2 -1}, (q, [], ∅) ∈ D} ∪ {( h 1 • h 2 δ (q), α, V ) (q, α, V ) ∈ D } = {( h * n [x/π] δ (q), [x/π], ∅) π ∈ {n, . . . , n + |h| -1}, (q, [], ∅) ∈ D} ∪ {( h δ (q), α, V ) (q, α, V ) ∈ D } Case h = h 1 . Thus h n = n • h 1 n+1</formula><p>• . Let:</p><formula xml:id="formula_59">D = {( δ , α, dom(α)) (q, α, V ) ∈ D} Thus (D , D) = δ l</formula><p>(D) and:</p><formula xml:id="formula_60">h n δ l (D) = n • h 1 n+1 • δ l (D) = δ l ( n • h 1 n+1 δ l (D ), D) = δ l ( h 1 n+1 δ l ( n δ l (D )), D) Let D 1 = D ∪ {(x δ ( δ ), [x/n], ∅) (q, [], ∅) ∈ D} and D 2 = h 1 n+1 δ l (D 1 ).</formula><p>Then:</p><formula xml:id="formula_61">h n δ l (D) = δ l ( h 1 n+1 δ l (D 1 ), D) = δ l (D 2 , D)</formula><p>Let and n 1 = n+|h 1 |.Note that D 1 is applicable with offset n 1 . The induction hypothesis applied to h 1 , D 1 and n + 1 shows:</p><formula xml:id="formula_62">D 2 = {( h 1 δ (q 1 ), α, V ) (q 1 , α, V ) ∈ D 1 } ∪ {( h 1 * n+1 [x/π] δ (q 1 ), [x/π], ∅) π ∈ {n + 1, . . . , n 1 }, (q 1 , [], ∅) ∈ D 1 }</formula><p>Thereby and by the definition of D 1 we obtain: I put n as correction for x. Also dom(α) instead of V as for D</p><formula xml:id="formula_63">D 2 = {( h 1 δ ( δ )), α, dom(α)) (q, α, V ) ∈ D} ∪ {( h 1 δ (n δ ( δ )), [x/n], ∅) (q, [], ∅) ∈ D} ∪ {( h 1 * n+1 [x/π] δ ( δ ), [x/π], ∅) π ∈ {n + 1, . . . , n 1 }, (q, [], ∅) ∈ D}</formula><p>With this equation, we can develop the right hand side of the equation</p><formula xml:id="formula_64">h n δ l (D) = δ l (D 2 , D</formula><p>) by applying the definition of the closing rule of δ l : at closing time, we take back V , not dom(α)</p><formula xml:id="formula_65">δ l (D 2 , D) = {(q@ h 1 δ ( δ ), α, V ) (q, α, V ) ∈ D} ∪ {(q@ n • h 1 δ ( δ ), [x/n], ∅) (q, [], ∅) ∈ D} ∪ {(q@ h 1 * n+1 [x/π] δ ( δ ), [x/π], ∅) π ∈ {n + 1, . . . , n 1 }, (q, [], ∅) ∈ D}</formula><p>Note that the admissibility of D ensures above that [x/n] cannot match with any (q, [], {x}) ∈ D. We next apply the definition of . δ to show:</p><formula xml:id="formula_66">δ l (D 2 , D) = {( h 1 δ (q), α, V ) (q, α, V ) ∈ D} ∪ {( n • h 1 δ (q), [x/n], ∅) (q, [], ∅) ∈ D} ∪ {( h 1 * n+1 [x/π] δ (q), [x/π], ∅) π ∈ {n + 1, . . . , n 1 }, (q, [], ∅) ∈ D} Since h = h 1 we get: δ l (D 2 , D) = {( h δ (q), α, V ) (q, α, V ) ∈ D} ∪ {( h * n [x/n] δ (q), [x/n], ∅) (q, [], ∅) ∈ D} ∪ {( h * n [x/π] δ (q), [x/π], ∅) π ∈ (n + 1, . . . , n 1 ), (q, [], ∅) ∈ D} = {( h δ (q), α, V ) (q, α, V ) ∈ D} ∪ {( h * n [x/π] δ (q), [x/π], ∅) π ∈ (n, . . . , |h| -1), (q, [], ∅) ∈ D} Since, h n δ l (D) = δ l (D 2 , D) the inductive statement follows.</formula><p>We finally notice that the restriction of states D to be applicable with offset n is not strictly necessary. The claim remains true when omitting it.</p><p>The late automaton thus computes the answer set of the query as follows:</p><formula xml:id="formula_67">Lemma 15. qry L(A) (h) = {π | (q, [x/π], ∅) ∈ h δ l (q l init ), q ∈ F } Proof. Let α = [x/π]</formula><p>for some π ∈ N. By Lemma 14, we have that q = h * α δ (q init ) iff (q, α, ∅) ∈ h δ l (q l init ). Hence:</p><formula xml:id="formula_68">π ∈ qry L(A) (h) iff π = α(x) and h * α ∈ L(A) iff π = α(x) and h * α δ (q init ) ∈ F iff π = α(x) and ∃q ∈ F. (q, α, ∅) ∈ h δ l (q l init ).</formula><p>Proposition 7 (Correctness of the late streaming evaluator).</p><formula xml:id="formula_69">If (D, ε) = nw ( h) δ l str (q l init , ε) then qry L(A) (h) = {π | (q, [x/π], ∅) ∈ D, q ∈ F }.</formula><p>Proof. This is an immediate consequence of Lemma 15 and nw ( h) δ l str (q l init , ε) = ( h δ l (q l init ), ε) as shown in Lemma 12.</p><p>For finalizing the definition of</p><formula xml:id="formula_70">A l = (Σ ∪ N, Q l , Γ l , δ l , q l init , F l ) we set F l = {D ∈ Q l | (q, α, ∅) ∈ D, q ∈ F, dom(α) = {x}}. Corollary 16. qry L(A) (h) = ∅ ⇔ nw ( h) ∈ L(A l )</formula><p>Proof. By Proposition 7, qry L(A) (h) = ∅ if and only if there exists q ∈ F and α : {x} → N such that (q, α, ∅) ∈ h δ l (q l init ). This is equivalent to h δ l (q l init ) ∈ F l and thus to h ∈ L(A l ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F Proofs for Section 7 (Certain Answers and Earliest</head><p>Query Answering) Definition 17. A natural number π is certainly a nonanswer of a monadic query Q at nested word prefix v, denoted by π ∈ CNA Q (v), if:</p><formula xml:id="formula_71">π ∈ pos(v) ∧ ∀h ∈ H Σ . v ∈ prefs(nw (h)) → π ∈ Q(h)</formula><p>More generally, we define a position annotated word v n ∈ (Σ ∪ {n, . . . , n + </p><formula xml:id="formula_72">|pos(v)|-1}) * for any n ∈ N such that ε n = ε a n = a•n, v • v n = v n • v n+|pos(v</formula><formula xml:id="formula_73">v * α = v[α(x)/x][π/ε | π = α(x)]. Lemma 9. For any prefix v ∈ prefs(nw (H Σ )), language L ⊆ H Σ x and candidate α = [x/π] with π ∈ pos(v): cert-mem L Σ (v * α) ⇔ π ∈ CA qry L (v).</formula><p>Proof. For the forwards implication "⇒" we assume cert-mem L Σ (v * α). We fix h ∈ H Σ arbitrarily such that v ∈ prefs(nw (h)). Then there exists w ∈ Σ * such that v • w = nw (h). Let h = h * α. Since h = nw ((v * α) • w), the certainty of Σ-membership of v * α for L yields h ∈ L. For the backwards implication "⇐" we assume π ∈ CA qry L (v). We fix h ∈ H Σ x and w ∈ Σ * arbitrarily such that (v * α) • w ∈ nw (h ). Let h = nw (v • w). Then v ∈ prefs(nw (h)), and since π is a certain answer of qry L on v, it follows that h * α ∈ L. Hence h = h * α ∈ L.</p><p>Proposition 10 (Corollary of Proposition 6 and Lemma 9). Let A = (Σ x , , δ, q init , ) be a d Sha such that δ| Σ is complete. For any v ∈ nwprefs Σ , π ∈ pos(v), and ((q, S),</p><formula xml:id="formula_74">) = v * [x/π] δ c Σ str (q init c Σ , ε): π ∈ CA qry L(A) (v) ⇔ q ∈ S .</formula><p>Proof. Let α = [x/π] and ((q, S), ) = v * α δ c Σ str (q init c Σ , ε). For the direction "⇒", we assume α(x) ∈ CA qry L(A) (v). Lemma 9 yields cert-mem L(A) Σ (v * α). Since δ| Σ is complete, Proposition 6 shows q ∈ S. For the other direction "⇐", we assume that q ∈ S. Since δ| Σ is complete, Proposition 6 shows cert-mem</p><formula xml:id="formula_75">L(A) Σ (v * α). Lemma 9 proves α(x) ∈ CA qry L(A) (v).</formula><p>Lemma 18. Let A be a d Sha with signature Σ x such that δ| Σ is complete. For any nested word prefix v ∈ nwprefs Σ , pair (M, ) = v δ e str (q e init , ε) and variable assignment α : {x} → pos(v), q ∈ Q and S ⊆ Q:</p><formula xml:id="formula_76">((q, S), ) = v * α δ c Σ str (q init c Σ , ε) ⇔ (q, α, , S) ∈ M Proof. By induction on the structure of v. Assume v ∈ nwprefs Σ , (M, ) = v δ e</formula><p>str (q e init , ε), variable assignment α : {x} → pos(v), q ∈ Q and S ⊆ Q. In the base case, v is the empty word:</p><formula xml:id="formula_77">Case v = ε. Hence, v = ε and v δ e</formula><p>str (q e init , ε) = (q e init , ε). Also, M = q e init = {(q init , [], ∅, safe δ| Σ (F ))}. On the other hand, v * α</p><formula xml:id="formula_78">δ c Σ str (q init c Σ , ε) is defined only if α = [],</formula><p>and in this case, it is equal to (q init c Σ , ε) = ((q init , safe δ| Σ (F )), ε) So (q, α, , S) ∈ M iff q = q init , α = [] and S = safe δ| Σ (F ) iff ((q, S),</p><formula xml:id="formula_79">) = v * α δ c Σ str (q init c Σ , ε).</formula><p>For the inductive step, there are three cases depending on the type of the last letter of v. Then, there are a ∈ Σ or v , v ∈ nwprefs Σ such that:</p><formula xml:id="formula_80">Case v = v • a. So there exists π ∈ N such that v = v • a • π. Let (M , ) =</formula><p>v δ e str (q e init , ε). We consider two cases depending on whether α binds x to the last position π or not: Case α = [x/π]. We have (q, α, , S) ∈ M iff exists q and q such that (q , [], ∅, S) ∈ M and q a -→ q</p><p>x -→ q ∈ δ. By induction hypothesis, (q , [], ∅, S) ∈ M is equivalent to ((q , S),</p><formula xml:id="formula_81">) = v * [] δ c Σ str (q init c Σ , ε).</formula><p>Hence, (q, α, , S) ∈ M iff exists q and q such that ((q , S),</p><formula xml:id="formula_82">) = v * [] δ c Σ str (q init c Σ , ε). and q a -→ q x -→ q ∈ δ. And this is equivalent to ((q, S), ) = v * α δ c Σ str (q init c Σ , ε). Case α = [x/π].</formula><p>We have (q, α, , S) ∈ M iff exists q such that (q , α, , S) ∈ M and q a -→ q ∈ δ. By induction hypothesis, (q , α, , S) ∈ M is equivalent to ((q , S), ) = v * α δ c Σ str (q init c Σ , ε). Hence, (q, α, , S) ∈ M iff exists q such that ((q , S), ) = v * α δ c Σ str (q init c Σ , ε) and q a -→ q ∈ δ. And this is equivalent to ((q, S),</p><formula xml:id="formula_83">) = v * α δ c Σ str (q init c Σ , ε). Case v = v • . Hence, v = v • . Let (M , ) = v δ e</formula><p>str (q e init , ε). If α binds some position to x then it must be a position of v . So, (q, α, , S) ∈ M iff q = δ and there exist q ∈ Q and S ⊆ Q such that (q , α, , S ) ∈ M and d δ| Σ (q , S ) = S. By induction hypothesis, (q , α, , S ) ∈ M is equivalent to ((q , S ), ) = v * α δ c Σ str (q init c Σ , ε). Hence, (q, α, , S) ∈ M iff q = δ and there exist q ∈ Q and S ⊆ Q such that ((q , S ), ) = v * α δ c Σ str (q init c Σ , ε) and d δ| Σ (q , S ) = S. The latter is equivalent to ((q, S),</p><formula xml:id="formula_84">) = v * α δ c Σ str (q init c Σ , ε). Case v = v • • v • and v is well-nested. Let n = # Σ (v). We have v = v • • n • v n+1</formula><p>. Let s be the stack in the second component of (M, ). The run of A e leading to (M, s) must have the following form: Let (M , s) = v δ e str (q e init , ε), and</p><formula xml:id="formula_85">M 0 = {(q init , α , dom(α ), d δ| Σ (q , S )) | (q , α , , S ) ∈ M }. Let (M , ) = n • v δ e str (M 0 , s • M ).</formula><p>We distinguish two cases, depending on whether α binds x to a position of v or not. Case α = [x/π] where π ∈ pos(v ). We have v * α = (v * α) • v . We consider both implications independently. "⇒" We suppose that (q, α, , S) ∈ M and have to show that ((q, S), ) = v * α δ c Σ str (q init , ε). Since (q, α, , S) ∈ M there is (q , α, {x}, S ) ∈ M , (q , α, , S) ∈ M such that S = d δ| Σ (q , S) and q = q @ δ q . By induction hypothesis, (M , s) = v δ e str (q e init , ε) and (q , α, , S) ∈ M imply that there exists s such that ((q , S), s ) = v * α δ c Σ str (q init , ε). The induction hypothesis applied to (q , α, {x}, S ) ∈ M implies that ((q , S ), ) = v δ c Σ str ( δ , s • (q , S)). Since v is well nested, the stack component of ((q , S ), ) must be unchanged, i.e. equal to s • (q , S). Hence, we can apply the closing rule of A c Σ showing that ((q @ δ q , S), s ) = v * α δ c Σ str (q init , s). Since q @ δ q = q it follows that ((q, S), ) = v * α δ c Σ str (q init , ε) as required. "⇐" We suppose that ((q, S), ) = v * α δ c Σ str (q init , s) and have to show that (q, α, , S) ∈ M . Let ((q , S ), ) = v * α δ c Σ str (q init , s). By induction hypothesis, we have (q , α, , S ) ∈ M . Let ((q , S ), ) = v δ c Σ str (q init , s•(q , S ). So S = d δ| Σ (q , S ). By induction hypothesis, we have (q , [], , S ) ∈ M . Hence also (q , α, {x}, S ) ∈ M . The closing rule permits to metch the tuples with α of M and M yielding (q @ δ q , α, , S ) ∈ M . Since α can only belong to a single tuple of M it follows that q @q = q and S = S. Hence, (q, α, , S) ∈ M . Case α = [x/n]. So we have v * α = v • x•v . We consider both implications independently. "⇒" We suppose that (q, α, , S) ∈ M and have to show that ((q, S), ) = v * α δ c Σ str (q init , ε). Since (q, α, , S) there are (q , α, {x}, S ) ∈ M and (q , [], ∅, S) ∈ M such that S = d δ| Σ (q , S) and q = q @ δ q . By induction hypothesis, (M , s) = v δ e str (q e init , ε) and (q , [], ∅, S) ∈ M imply that there exists s such that ((q , S), s ) = v * [] δ c Σ str (q init , ε). The induction hypothesis applied to (q , α, {x}, S ) ∈ M implies that ((q , S ), ) = x • v δ c Σ str ( δ , s • (q , S)). Since v is well nested, the stack component of ((q , S ), ) must be unchanged, i.e. equal to s • (q , S). Hence, we can apply the closing rule of A c Σ showing that ((q @ δ q , S), s ) = v * α δ c Σ str (q init , s). Since q @ δ q = q it follows that ((q, S), ) = v * α δ c Σ str (q init , ε) as required. "⇐" We suppose that ((q, S), ) = v * α δ c Σ str (q init , s) and have to show that (q, α, , S) ∈ M . Let ((q , S ), ) = v δ c Σ str (q init , s). By induction hypothesis, we have (q , [], , S ) ∈ M . Let ((q , S ), ) = x • v δ c Σ str (q init , s • (q , S ). So S = d δ| Σ (q , S ). By induction hypothesis, we have (q , α, , S ) ∈ M . The closing rule permits to match the tuple with α in M with the tuple with [] of M . This yields (q @ δ q , α, , S ) ∈ M . Since α can only belong to a single tuple of M it follows that q @q = q and S = S. Hence, (q, α, , S) ∈ M . Case else. So now either α = [] or α = [x/π] with π-n-1 ∈ pos(v ) and we have v * α = v * • v * α . We consider both implications independently. "⇒" We suppose that (q, α, , S) ∈ M and have to show that ((q, S), ) = v * α δ c Σ str (q init , ε). Since (q, α, , S) there are (q , α, ∅, S ) ∈ M and (q , [], ∅, S) ∈ M such that S = d δ| Σ (q , S) and q = q @ δ q . By induction hypothesis, (M , ) = v δ e str (q e init , ε) and (q , [], , S) ∈ M imply that there exists s such that ((q , S), s</p><formula xml:id="formula_86">) = v * [] δ c Σ str (q init , ε).</formula><p>The induction hypothesis applied to (q , α, , S ) ∈ M implies that ((q , S ), ) = v * α δ c Σ str ( δ , s • (q , S)). Since v is well nested, the stack component of ((q , S ), ) must be unchanged, i.e. equal to s • (q , S). Hence, we can apply the closing rule of A c Σ showing that ((q @ δ q , S), s ) = v * α δ c Σ str (init, s). Since q @ δ q = q it follows that ((q, S), ) = v * α δ c Σ str (init, ε) as required. "⇐" We suppose that ((q, S), ) = v * α δ c Σ str (init, s) and have to show that (q, α, , S) ∈ M . Let ((q , S ), ) = v δ c Σ str (q init , s). By induction hypothesis, we have (q , [], , S ) ∈ M . Let ((q , S ), ) = v * α δ c Σ str (q init , s • (q , S ). So S = d δ| Σ (q , S ). By induction hypothesis, we have (q , α, , S ) ∈ M . The closing rule permits to match the tuple with α in M with the tuple with [] of M . This yields (q @ δ q , α, , S ) ∈ M . Since α can only belong to a single tuple of M it follows that q @q = q and S = S. Hence, (q, α, , S) ∈ M . Proposition 11. Let A be a d Sha with signature Σ x such that δ| Σ is complete. For any nested word prefix v ∈ nwprefs Σ with v δ e str (q e init , ε) = (M, ):</p><p>CA qry L(A) (v) = {α(x) | q ∈ S ∧ (q, α, ∅, S) ∈ M ∧ dom(α) = {x}} Proof. Let π ∈ pos(v), α = [x/π], and ((q, S), ) = v * [x/π] δ c Σ str (q init c Σ , ε). By Lemma 18, we have (q, α, , S) ∈ M . Proposition 10 shows that π ∈ CA qry L(A) (v) is equivalent to q ∈ S, and thus to π ∈ {α(x) | q ∈ S∧(q, α, ∅, S) ∈ M ∧dom(α) = {x}}.</p><p>Certain nonanswers can be detected in analogy to certain answers. For this we can add a set of states that are safe for rejection. At the beginning, this is safe δ (Q \ F ) lateron we have to use the function d δ to update it when moving down into subtrees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G Earliest Automaton with Safe Rejection</head><p>We next extend the earliest automaton with safe states for rejection. Given an dSha A over Σ x , we next construct the earliest automaton with rejection A er . Its extends the states of A e with a component with a subset of rejection states:</p><formula xml:id="formula_87">Q er = Q × Cands × 2 {x} × (2 Q ) 2 = Γ er q er init = {( δ , [],</formula><p>∅, safe δ| Σ (F ), safe δ (Q \ F ))}. At the beginning all states in safe δ (Q \ F ) are safe for rejection. Let δ er contain the following rules for all M, N ∈ Q er , a ∈ Σ, and π ∈ N: M a -→ {(a δ (q), α, V, S, R) | (q, α, V, S, R) ∈ M } M π -→ {(x δ (q), [x/π], ∅, S, R) | (q, [], ∅, S, R) ∈ M } ∪ M M ↓M ---→ {( δ , α, dom(α), d δ| Σ (q, S), d δ (q, R)) | (q, α, V, S, R) ∈ M } N ↑M ---→ ({(q@ δ p, α , V, S, R) | (q, α, V, S, R) ∈ M, (p, α , dom(α), S , R ) ∈ N, α ∈ {[], α }} Theorem 1. EQA for monadic d Sha queries can be done in time O(c m) per event, where c is the concurrency of the query at the event.</p><p>Proof. We run the streaming evaluator of earliest automaton with safe rejection with two exceptions:</p><p>1. Whenever creating or updating a tuple (q, α, V, S, R) in the current set M , we test whether x ∈ dom(α) and q ∈ S, and if so we output α(x) and remove the tuple from M . 2. Whenever creating or updating a tuple (q, α, V, S, R) in the current set M , we test whether q ∈ R and if so we remove the tuple from M .</p><p>This algorithm soundly outputs all certain query answers at the earliest time spoint by Proposition 11. It remains to argue the complexity per event. Since the candidates of all tuples in the current state M are pairwise distinct and alive, the cardinality of M is bounded by the number c of alive candidates of the query (not of the algorithm). For each tuple (q, α, V, S, R) ∈ M , we need to compute d δ| Σ (q, S) and d δ (q, R) or some transitions a δ (q) and x δ (q) where a ∈ Σ. The costs for this are in O(m).</p><p>H Proofs for Section 8 (Experimentation)    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: A dSha for the monadic query on hedges with letters in Σ = {a} that selects the positions 1, . . . , n -1 on hedges of the form a n • h • h if h does not start with letter "a" and position n otherwise.</figDesc><graphic coords="5,240.21,135.40,256.70,90.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig.2:A successful run of the dSha A in Fig.1on aaax a a.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 1 .</head><label>1</label><figDesc>The tuples are written there without commas and parenthesis. The run of A l first consumes aa and goes into state D = {(2, [], ∅), (8, [x/1], ∅), (5, [x/2], ∅)}. It contains the candidates [x/1] and [x/2] for the two leading a position, plus the empty candidate []. After the following open parenthesis , the run goes into the set {(1, [], ∅), (1, [x/1], {x}), (1, [x/2], {x})}. The state of each of the candidates got set to δ = 1. Furthermore, the set memoizes that the candidates [x/1] and [x/2] were bound in the context. It then consumes the letter a and reaches E = {(3, [], ∅), (3, [x/1], {x}), (3, [x/2], {x})}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 1 .</head><label>1</label><figDesc>EQA for monadic d Sha queries can be done in time O(c m) per event, where c is the concurrency of the query at the event.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>substituting in v, the position α(x) by x if x ∈ dom(α), and removing all other positions:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Running times of AStream 3.36 for streaming XPathMark queries on XML documents whose size scale from 27 KB to 1.2GB. Only the running time of query O1 is not scaling up linearly, and thus running out of time for 128KB already. The concurrency of all other queries is bounded on these documents.</figDesc><graphic coords="26,138.12,115.84,339.12,191.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9 :</head><label>9</label><figDesc>Fig. 9: The quadratic running time of AStream 3.36 on XPath query O1 with linear concurrency on XML documents ranging from 27 KB to 5 MB.</figDesc><graphic coords="27,134.77,116.83,359.20,222.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="16,106.42,115.83,396.80,224.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>XPathMark list of queries.</figDesc><table><row><cell>Id</cell><cell>XPath Query</cell></row><row><cell>A1:</cell><cell>/site/closed auctions/closed auction/annotation/</cell></row><row><cell></cell><cell>description/text/keyword</cell></row><row><cell>A2:</cell><cell>//closed auction//keyword</cell></row><row><cell>A3:</cell><cell>/site/closed auctions/closed auction//keyword</cell></row><row><cell>A4:</cell><cell>/site/closed auctions/closed auction[annotation/description/</cell></row><row><cell></cell><cell>text/keyword]/date</cell></row><row><cell>A5:</cell><cell>/site/closed auctions/closed auction[descendant::keyword]/</cell></row><row><cell></cell><cell>date</cell></row><row><cell>A6:</cell><cell>/site/people/person[profile/gender and profile/age]/name</cell></row><row><cell>A7:</cell><cell>/site/people/person[phone or homepage]/name</cell></row><row><cell>A8:</cell><cell>/site/people/person[address and (phone or homepage) and</cell></row><row><cell></cell><cell>(creditcard or profile)]/name</cell></row><row><cell>O1:</cell><cell>/site[closed auctions/closed auction/type]//item</cell></row><row><cell>O2:</cell><cell>/site[c or not(c)]//bidder</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>The 77 queries of the XPath corpus of Lick and Schmitz without dublicates up to renaming. Id XPath Query 18330 / descendant-or-self::node()/child::parts-of-speech 17914 / descendant-or-self::node()/child::tei:back/descendant-orself::node()/child::tei:interpGrp 10745 *//tei:imprint/tei:date[@type='access'] 02091 * | .//refentry 00744 .//@id | .//@xml:id 12060 .//attDef 02762 .//authorgroup/author | .//author 06027 .//authorinitials | .//author 02909 .//bibliomisc[@role='serie'] 06415 .//email | address/otheraddr/ulink 03257 .//equation[title or info/title] 05122 .//procedure[title] 09138 .//rng:ref | .//tei:elementRef | .//tei:classRef | .//tei:macroRef | .//tei:dataRef</figDesc><table /></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>or @rnd:style = 'bibliography-title' or @rnd:style = 'glossary' or @rnd:style = 'glossary-title' or @rnd:style = 'qandaset' or @rnd:style   </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Benchmark Collection of Deterministic Automata for XPath Queries</title>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Al</forename><surname>Serhali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">XML Prague 2022</title>
		<meeting><address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2022-06">June 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Marrying words and trees</title>
		<author>
			<persName><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PODS</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Stream Firewalling of XML Constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jeffrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ley-Wild</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Int. Conf. Manag. Data</title>
		<meeting>ACM SIGMOD Int. Conf. Manag. Data</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Early nested word automata for XPath query answering on XML streams</title>
		<author>
			<persName><forename type="first">D</forename><surname>Debarbieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zergaoui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Franceschet</surname></persName>
		</author>
		<ptr target="https://users.dimi.uniud.it/~massimo.franceschet/xpathmark/PTbench.html" />
		<title level="m">XPathMark performance test</title>
		<imprint>
			<date type="published" when="2020-10-25">2020-10-25</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Earliest query answering for deterministic nested word automata</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gauwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FCT</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A formal framework for complex event processing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Grez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riveros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ugarte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDT</title>
		<imprint>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="5" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Streaming in the saxon XSLT processor</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">XML Prague</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="81" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">How to define certain answers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI 2015</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">XPath Benchmark</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sylvain</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Last visited</title>
		<imprint>
			<date type="published" when="2022-04-13">April 13th 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">High-performance complex event processing over XML streams</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mozafari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Streaming enumeration on nested documents</title>
		<author>
			<persName><forename type="first">M</forename><surname>Muñoz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riveros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDT</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Determinization and minimization of automata for nested words revisited</title>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sakho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">68</biblScope>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Schema-based automata determinization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sakho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Serhali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">GandALF</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Complexity of input-driven pushdown automata</title>
		<author>
			<persName><forename type="first">A</forename><surname>Okhotin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Salomaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="47" to="67" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">SPEX: Streamed and progressive evaluation of XPath</title>
		<author>
			<persName><forename type="first">D</forename><surname>Olteanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Know. Data Eng</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="934" to="949" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Certain Query Answering on Hyperstreams</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sakho</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020-07">July 2020</date>
		</imprint>
	</monogr>
	<note type="report_type">Theses</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Projection for nested word automata speeds up xpath evaluation on XML streams</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<ptr target="2016.05460.//table//footnote|.//informaltable//footnote12404.//tei:dataRef[@name]10337.//tei:note[@place=&apos;end&apos;]06639.//tgroup//footnote14340//*13804//GAP/@DISP13896//HEADER//IDNO[@TYPE=&apos;evanscitation&apos;]02194//annotation06726//doc:table|//doc:informaltable13640//equiv[@filter]05735//glossary[@role=&apos;auto&apos;]15766//h:body/h:section[@data-type=&apos;titlepage&apos;]15524//h:section[@data-type=&apos;titlepage&apos;]06512//refentry//text()06176//set|//book|//part|//reference|//preface|//chapter|//appendix|//article|//colophon|//refentry|//section|//sect1|//sect2|//sect3|//sect4|//sect5|//indexterm|//glossary|//bibliography|//*[@id]12539//tei:elementSpec|//tei:classSpec[@type=&apos;atts&apos;]11780//tei:ref[@type=&apos;cite&apos;]|//tei:ptr[@type=&apos;cite&apos;]11478//xhtml:p[@class]11227/tei:TEI/tei:text//tei:note[@type=&apos;action&apos;]05684@abbr|@align|@axis|@bgcolor|@border|@cellpadding|@cellspac-ing|@char|@charoff|@class|@dir|@frame|@headers|@height|@id|@lang|@nowrap|@onclick|@ondblclick|@onkeydown|@on-keypress|@onkeyup|@onmousedown|@onmousemove|@onmouseout|@onmouseover|@onmouseup|@rules|@scope|@style|@summary|@title|@valign|@valign|@width|@xml:id|@xml:lang06947anchor|areaset|audiodata|audioobject|beginpage|constraint|indexterm|itermset|keywordset|msg|doc:anchor|doc:areaset|doc:audiodata|doc:audioobject|doc" />
	</analytic>
	<monogr>
		<title level="m">SOFSEM</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
