{"application": "software-mentions", "version": "0.8.0", "date": "2024-10-07T11:37+0000", "md5": "1A92AC7DCB4F5473D83C31014C176D97", "mentions": [{"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 0, "offsetEnd": 3}, "context": "SQL-like query or vertex-centric graphic abstraction; then, the specification is transformed into an internal representation in the form of a data-flow DAG; and finally, code is generated to execute the workflow against the target platform.", "mentionContextAttributes": {"used": {"value": false, "score": 0.03070157766342163}, "created": {"value": false, "score": 0.00016021728515625}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 0, "offsetEnd": 4}, "context": "Hive gives a relational view of HDFS stored unstructured data. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.000133514404296875}, "created": {"value": false, "score": 9.775161743164062e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "HiveQL", "normalizedForm": "HiveQL", "offsetStart": 0, "offsetEnd": 6}, "context": "HiveQL is the query language of the data warehousing solution Hive, built on top of Hadoop MapReduce [35]. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.002870023250579834}, "created": {"value": false, "score": 7.49826431274414e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.0003439188003540039}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "HiveQL", "normalizedForm": "HiveQL", "offsetStart": 0, "offsetEnd": 6}, "context": "HiveQL queries are decomposed to relational operators, which are then compiled to MapReduce jobs to be executed on Hadoop. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 4.4465065002441406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.0003439188003540039}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Impala", "normalizedForm": "Impala", "offsetStart": 0, "offsetEnd": 6}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019916892051696777}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 0, "offsetEnd": 6}, "context": "Hadoop, Spark, Giraph, etc.). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.11209100484848022}, "created": {"value": false, "score": 6.318092346191406e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 0, "offsetEnd": 6}, "context": "Hadoop HDFS), and big data processing frameworks (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0040413737297058105}, "created": {"value": false, "score": 3.647804260253906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 0, "offsetEnd": 7}, "context": "MongoDB subqueries show lowest performance as data retrieval passes through the embedded JavaScript interpreter at each worker.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5013464093208313}, "created": {"value": false, "score": 1.7881393432617188e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "QoX", "normalizedForm": "QoX", "offsetStart": 0, "offsetEnd": 8}, "context": "QoX [33] integrates data from RDBMS and HDFS data stores through an XML common data model. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005319714546203613}, "created": {"value": false, "score": 5.7220458984375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0005319714546203613}, "created": {"value": false, "score": 1.6808509826660156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Teradata", "normalizedForm": "Teradata", "offsetStart": 0, "offsetEnd": 8}, "context": "Teradata IntelliSphere [7] addresses the problem of accessing multiple data stores (called \"remote systems\") that may be heterogeneous, but must have an SQL-like interface. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.663799285888672e-05}, "created": {"value": false, "score": 6.711483001708984e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.43760091066360474}, "created": {"value": false, "score": 0.01322019100189209}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Teradata", "normalizedForm": "Teradata", "offsetStart": 0, "offsetEnd": 8}, "context": "Teradata is responsible for building an SQL query plan and deciding where each SQL operator (e.g. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0034809112548828125}, "created": {"value": false, "score": 0.01322019100189209}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.43760091066360474}, "created": {"value": false, "score": 0.01322019100189209}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 0, "offsetEnd": 9}, "context": "Spark SQL provides a DataFrame API that can map to relations arbitrary object collections and thus enables relational operations across Spark's RDDs and external data sources. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.463859558105469e-05}, "created": {"value": false, "score": 0.0007729530334472656}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 3.2186508178710938e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 0, "offsetEnd": 9}, "context": "Spark SQL can access a MongoDB cluster through its MongoDB connector that maps a sharded document collection to a Data-Frame, partitioned as per the collection's sharding setup. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0013504624366760254}, "created": {"value": false, "score": 2.5033950805664062e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 3.2186508178710938e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 0, "offsetEnd": 9}, "context": "LeanXcale is a scalable distributed SQL database management system with OLTP and OLAP support and full ACID capabilities. ", "mentionContextAttributes": {"used": {"value": false, "score": 9.131431579589844e-05}, "created": {"value": false, "score": 0.0007436871528625488}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 0, "offsetEnd": 9}, "context": "LeanXcale solves this problem through its patented technology for scalable transaction processing [21]. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.851818084716797e-05}, "created": {"value": false, "score": 0.004270017147064209}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 0, "offsetEnd": 9}, "context": "LeanXcale's distributed query engine (DQE) is designed to process OLAP workloads over the operational data, so that analytical queries are answered over real-time data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001322031021118164}, "created": {"value": false, "score": 0.014199316501617432}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL++", "normalizedForm": "SQL++", "offsetStart": 0, "offsetEnd": 10}, "context": "SQL++ [30] mediates SQL and NoSQL data sources through a semi-structured common data model. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0027878880500793457}, "created": {"value": false, "score": 4.649162292480469e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0027878880500793457}, "created": {"value": false, "score": 4.649162292480469e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 0, "offsetEnd": 10}, "context": "PostgreSQL or MySQL) deployed across a cluster, as in a sharednothing parallel DBMS. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9520650506019592}, "created": {"value": false, "score": 9.775161743164062e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9520650506019592}, "created": {"value": false, "score": 9.775161743164062e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Impala", "normalizedForm": "Impala", "offsetStart": 0, "offsetEnd": 10}, "context": "Impala [5] is an open-source distributed SQL engine operating over Hadoop data processing environment. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019916892051696777}, "created": {"value": false, "score": 1.609325408935547e-05}, "shared": {"value": false, "score": 0.01025998592376709}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019916892051696777}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 0, "offsetEnd": 10}, "context": "CloudMdsQL also provides a CREATE NAMED EXPRESSION command that allows an expression to be defined and stored in a global catalog in order to be referenced in several queries, similarly to SQL views and stored procedures/functions. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.6133995056152344e-05}, "created": {"value": false, "score": 0.00011742115020751953}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 0, "offsetEnd": 10}, "context": "SparkAgent is the component, which accepts TCP connections from Spark executors to push RDD partition data. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.04578143358230591}, "created": {"value": false, "score": 7.867813110351562e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "HadoopDB", "normalizedForm": "HadoopDB", "offsetStart": 0, "offsetEnd": 12}, "context": "HadoopDB [1] provides Hadoop MapReduce/HDFS access to multiple single-node RDBMS servers (e.g. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00031435489654541016}, "created": {"value": false, "score": 1.0848045349121094e-05}, "shared": {"value": false, "score": 9.775161743164062e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00031435489654541016}, "created": {"value": false, "score": 1.0848045349121094e-05}, "shared": {"value": false, "score": 9.775161743164062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 0, "offsetEnd": 13}, "context": "Spark SQL [6] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022155046463012695}, "created": {"value": false, "score": 0.01336449384689331}, "shared": {"value": false, "score": 2.5033950805664062e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 3.2186508178710938e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale DQE", "normalizedForm": "LeanXcale DQE", "offsetStart": 0, "offsetEnd": 13}, "context": "LeanXcale DQE is designed to integrate with arbitrary data management clusters, where data resides in its natural format and can be retrieved (in parallel) by running specific scripts or declarative queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.221366882324219e-05}, "created": {"value": false, "score": 0.2625940442085266}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 5.221366882324219e-05}, "created": {"value": false, "score": 0.2625940442085266}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Musketeer", "normalizedForm": "Musketeer", "offsetStart": 0, "offsetEnd": 14}, "context": "Musketeer [18] achieves this through a model that breaks the execution of a data processing workflow in three layers: first, the workflow is specified using a front-end framework of user's choice, e.g. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00026553869247436523}, "created": {"value": false, "score": 1.9550323486328125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0010941028594970703}, "created": {"value": false, "score": 2.7418136596679688e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop MapReduce", "normalizedForm": "Hadoop MapReduce", "offsetStart": 0, "offsetEnd": 16}, "context": "Hadoop MapReduce, Apache Spark, or Apache Flink), specialized for different kinds of data and tasks and able to scale and perform orders of magnitude better than traditional relational DBMS. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002870023250579834}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Drill", "normalizedForm": "Apache Drill", "offsetStart": 0, "offsetEnd": 16}, "context": "Apache Drill [4] is a distributed query engine for large-scale datasets, designed to scale to thousands of nodes and query at low latency petabytes of data from various data sources through storage plugins. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.76837158203125e-05}, "created": {"value": false, "score": 0.014595568180084229}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 4.76837158203125e-05}, "created": {"value": false, "score": 0.014595568180084229}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 0, "offsetEnd": 18}, "context": "CloudMdsQL [23,26] with its MFR (map/filter/reduce) extensions [9] even allows data store native queries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.92605972290039e-05}, "created": {"value": false, "score": 1.537799835205078e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "BigIntegrator", "normalizedForm": "BigIntegrator", "offsetStart": 0, "offsetEnd": 18}, "context": "BigIntegrator [29] integrates data from cloud-based NoSQL big data stores, such as Google's Bigtable, and relational databases. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016045570373535156}, "created": {"value": false, "score": 7.987022399902344e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00016045570373535156}, "created": {"value": false, "score": 7.987022399902344e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "QoX", "normalizedForm": "QoX", "offsetStart": 4, "offsetEnd": 7}, "context": "The QoX optimizer uses a dataflow approach for optimizing queries over data stores, with a black box approach for cost modeling.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0004521012306213379}, "created": {"value": false, "score": 1.6808509826660156e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0005319714546203613}, "created": {"value": false, "score": 1.6808509826660156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 4, "offsetEnd": 7}, "context": "The SQL table expression T1 is defined by an SQL subquery, while T2 is a native expression (identified by the special bracket symbols {* *}) expressed as a native MongoDB API call or JavaScript code.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05572444200515747}, "created": {"value": false, "score": 4.172325134277344e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 4, "offsetEnd": 9}, "context": "For Spark result sets, this overhead is a bit higher, because of the additional serialization/deserialization that takes place between Spark executors and SparkAgent instances.", "mentionContextAttributes": {"used": {"value": false, "score": 0.034141361713409424}, "created": {"value": false, "score": 2.0742416381835938e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 4, "offsetEnd": 11}, "context": "The MongoDB storage allows running Drill and MongoDB together in distributed mode, by assigning shards to different drillbits to exploit parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003085136413574219}, "created": {"value": false, "score": 5.8650970458984375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 4, "offsetEnd": 12}, "context": "\u2022 A DataLake wrapper must have multiple instances, each linked to a DQE worker.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007180571556091309}, "created": {"value": false, "score": 4.780292510986328e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 4, "offsetEnd": 13}, "context": "The LeanXcale database has derived its OLAP query engine from Apache Calcite [8], a Java-based open-source framework for SQL query processing and optimization.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6484058499336243}, "created": {"value": false, "score": 0.00020927190780639648}, "shared": {"value": false, "score": 8.463859558105469e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 4, "offsetEnd": 14}, "context": "The CloudMdsQL language [26] is SQL-based with the extended capabilities for embedding subqueries expressed in terms of each data store's native query interface. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.002769768238067627}, "created": {"value": false, "score": 0.000152587890625}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26, "offsetStart": 28800, "offsetEnd": 28804}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26, "offsetStart": 28800, "offsetEnd": 28804}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "findSharded", "normalizedForm": "findSharded", "offsetStart": 4, "offsetEnd": 15}, "language": {"rawForm": "JavaScript", "normalizedForm": "JavaScript"}, "context": "The findSharded() method accepts the same arguments as the native MongoDB find() operator, in order to provide the native flexible querying functionality, complemented with the ability to handle parallel iteration on the sharded result set.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013506412506103516}, "created": {"value": false, "score": 4.076957702636719e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7317386269569397}, "created": {"value": false, "score": 4.076957702636719e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 5, "offsetEnd": 10}, "context": "What Spark SQL is not capable of is bind join through SQL queries; to perform a bind join, one has to write a Spark program, which limits the use cases.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00010180473327636719}, "created": {"value": false, "score": 0.00010180473327636719}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 5, "offsetEnd": 14}, "context": "With LeanXcale, once the named tables (subqueries to data stores) are defined by the system developer or administrator, they can be easily used and involved in joins (including bind joins) through the SQL interface. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.000822603702545166}, "created": {"value": false, "score": 5.221366882324219e-05}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 6, "offsetEnd": 13}, "context": "Since MongoDB collections are used directly in the FROM clause as tables, the storage plugin translates relational operators to native MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.09908062219619751}, "created": {"value": false, "score": 1.1801719665527344e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 8, "offsetEnd": 13}, "context": "Hadoop, Spark, Giraph, etc.).", "mentionContextAttributes": {"used": {"value": false, "score": 0.11209100484848022}, "created": {"value": false, "score": 6.318092346191406e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 8, "offsetEnd": 17}, "context": "JEN and LeanXcale are applying semi-joins as an optimization technique -JEN with its efficient zigzag join that exchanges bloom filters between the HDFS and RDBMS datasets and LeanXcale through bind joins. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.008451223373413086}, "created": {"value": false, "score": 4.76837158203125e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 9, "offsetEnd": 15}, "context": "Rule #2: REDUCE(<transformation>).FILTER(<predicate>) is equivalent to FILTER(<predicate>).REDUCE(<transformation>), if predicate condition is a function only of the KEY, because thus, applying the FILTER before the REDUCE will preserve the values associated to those keys that satisfy the filter condition as they would be if the FILTER was applied after the REDUCE.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9831936359405518}, "created": {"value": false, "score": 2.9802322387695312e-06}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 9, "offsetEnd": 22}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.011867344379425049}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 10, "offsetEnd": 14}, "context": "Note that Hive is interfaced only for getting metadata, while the data rows are read directly from HDFS.", "mentionContextAttributes": {"used": {"value": false, "score": 0.12792009115219116}, "created": {"value": false, "score": 9.5367431640625e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 11, "offsetEnd": 14}, "context": "What Spark SQL is not capable of is bind join through SQL queries; to perform a bind join, one has to write a Spark program, which limits the use cases.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00010180473327636719}, "created": {"value": false, "score": 0.00010180473327636719}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 11, "offsetEnd": 20}, "context": "This turns LeanXcale DQE into a powerful \"big data lake\" polyglot query engine that can process data from its original format, taking full advantage of both expressive scripting and massive parallelism. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.0531158447265625e-05}, "created": {"value": false, "score": 0.00699925422668457}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 12, "offsetEnd": 15}, "context": "It produces SQL statements for relational data stores, and Pig/Hive code for interfacing Hadoop to access HDFS data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00014781951904296875}, "created": {"value": false, "score": 0.0006140470504760742}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 12, "offsetEnd": 19}, "context": "To access a MongoDB cluster, Presto uses a connector that allows the parallel retrieval of sharded collections, which is typically configured with a list of MongoDB servers.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0041727423667907715}, "created": {"value": false, "score": 6.330013275146484e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 12, "offsetEnd": 19}, "context": "Even if the MongoDB data has to undergo transformations, expressed through user-defined JavaScript functions, this can still be handled in parallel by making each worker initiate the execution of the custom JavaScript code against the MongoDB shard assigned to it and collect its partition of the intermediate data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.008358001708984375}, "created": {"value": false, "score": 0.00038951635360717773}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 12, "offsetEnd": 24}, "context": "In terms of Apache Spark, a dataset corresponds to an RDD (Resilient Distributed Dataset -the basic programming unit of Spark). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": false, "score": 2.658367156982422e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "HiveQL", "normalizedForm": "HiveQL", "offsetStart": 13, "offsetEnd": 19}, "context": "In addition, HiveQL allows custom scripts, defining MapReduce jobs, to be referred in queries and used in combination with relational operators. ", "mentionContextAttributes": {"used": {"value": false, "score": 2.9921531677246094e-05}, "created": {"value": false, "score": 0.0003439188003540039}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.0003439188003540039}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MySQL", "normalizedForm": "MySQL", "offsetStart": 14, "offsetEnd": 19}, "context": "PostgreSQL or MySQL) deployed across a cluster, as in a sharednothing parallel DBMS. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9520650506019592}, "created": {"value": false, "score": 9.775161743164062e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9520650506019592}, "created": {"value": false, "score": 9.775161743164062e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 14, "offsetEnd": 19}, "context": "The choice of Spark SQL for a state-of-the-art representative to compare our work with is justified by the fact that it supports most of the features our approach targets and hereby evaluates, namely: (a) parallel MongoDB subqueries through the use of the MongoDB connector that also supports native Mon-goDB operators (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001291513442993164}, "created": {"value": false, "score": 0.045391619205474854}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 14, "offsetEnd": 20}, "context": ".MAP(KEY, 1) .REDUCE(SUM) .FILTER( KEY LIKE '%cloud%' ) *}", "mentionContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 6.794929504394531e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 14, "offsetEnd": 21}, "context": "Subqueries to MongoDB are expressed natively in JavaScript.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5642318725585938}, "created": {"value": false, "score": 1.6808509826660156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MapReduce", "normalizedForm": "MapReduce", "offsetStart": 14, "offsetEnd": 23}, "context": "It interfaces MapReduce with RDBMS through database connectors that execute SQL queries to return key-value pairs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00026601552963256836}, "created": {"value": false, "score": 8.702278137207031e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.2296445369720459}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "BigDAWG", "normalizedForm": "BigDAWG", "offsetStart": 14, "offsetEnd": 29}, "context": "The polystore BigDAWG [16,17] goes one step further by defining \"islands of information\", where each island corresponds to a specific data model and its language and provides transparent access to a subset of the underlying data stores through the island's data model. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00021463632583618164}, "created": {"value": false, "score": 2.09808349609375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00021463632583618164}, "created": {"value": false, "score": 2.09808349609375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Giraph", "normalizedForm": "Giraph", "offsetStart": 15, "offsetEnd": 21}, "context": "Hadoop, Spark, Giraph, etc.). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.11209100484848022}, "created": {"value": false, "score": 6.318092346191406e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.11209100484848022}, "created": {"value": false, "score": 6.318092346191406e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 16, "offsetEnd": 25}, "context": "Comparison with Spark SQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0011861324310302734}, "created": {"value": false, "score": 1.895427703857422e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 3.2186508178710938e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 18, "offsetEnd": 23}, "context": "For example, with Spark SQL it is possible to do a bind join, but this must be defined programmatically by a developer.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011670589447021484}, "created": {"value": false, "score": 0.00022798776626586914}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 18, "offsetEnd": 23}, "context": "MFR subqueries to Spark are defined as single SCAN operators, translated to Scala commands.", "mentionContextAttributes": {"used": {"value": false, "score": 0.011382758617401123}, "created": {"value": false, "score": 6.318092346191406e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 18, "offsetEnd": 25}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 18, "offsetEnd": 30}, "context": "Hadoop MapReduce, Apache Spark, or Apache Flink), specialized for different kinds of data and tasks and able to scale and perform orders of magnitude better than traditional relational DBMS. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 19, "offsetEnd": 24}, "context": "Without bind join, Spark SQL shows a slight advantage compared to LeanXcale DQE, which is explainable by the overhead of the JavaScript interpreting that takes place at DQE wrappers for MongoDB. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.004089474678039551}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 19, "offsetEnd": 32}, "context": "At this point, the ShardedCursor object does not yet initiate the query execution, but only memorizes the query filter object.", "mentionContextAttributes": {"used": {"value": false, "score": 0.011867344379425049}, "created": {"value": false, "score": 2.288818359375e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.011867344379425049}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 20, "offsetEnd": 23}, "context": "SQL++ [30] mediates SQL and NoSQL data sources through a semi-structured common data model.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0027878880500793457}, "created": {"value": false, "score": 4.649162292480469e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 20, "offsetEnd": 23}, "context": "The choice of Spark SQL for a state-of-the-art representative to compare our work with is justified by the fact that it supports most of the features our approach targets and hereby evaluates, namely: (a) parallel MongoDB subqueries through the use of the MongoDB connector that also supports native Mon-goDB operators (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001291513442993164}, "created": {"value": false, "score": 0.045391619205474854}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 21, "offsetEnd": 30}, "context": "Therefore, we target Spark SQL as the only relevant system to evaluate our contributions against.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9132312536239624}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 3.2186508178710938e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 22, "offsetEnd": 28}, "context": "The following MAP and REDUCE count the frequencies of each such pair. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9280750751495361}, "created": {"value": false, "score": 5.364418029785156e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop MapReduce", "normalizedForm": "Hadoop MapReduce", "offsetStart": 22, "offsetEnd": 38}, "context": "HadoopDB [1] provides Hadoop MapReduce/HDFS access to multiple single-node RDBMS servers (e.g. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00031435489654541016}, "created": {"value": false, "score": 1.0848045349121094e-05}, "shared": {"value": false, "score": 9.775161743164062e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002870023250579834}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 23, "offsetEnd": 30}, "context": "Spark SQL can access a MongoDB cluster through its MongoDB connector that maps a sharded document collection to a Data-Frame, partitioned as per the collection's sharding setup.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0013504624366760254}, "created": {"value": false, "score": 2.5033950805664062e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "findSharded", "normalizedForm": "findSharded", "offsetStart": 23, "offsetEnd": 34}, "language": {"rawForm": "JavaScript", "normalizedForm": "JavaScript", "wikidataId": "Q2005", "offsetStart": 214, "offsetEnd": 224}, "context": "Thus, a composition of findSharded and map/flatMap (such as in the BookOrders example above) makes a user script expressive enough, so as to request a specific MongoDB dataset, retrieve the result set in parallel, and transform it in order to fit the named table signature and further be consumed by relational operators at the DQE level. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0015254616737365723}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7317386269569397}, "created": {"value": false, "score": 4.076957702636719e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 24, "offsetEnd": 27}, "context": "For example, with Spark SQL it is possible to do a bind join, but this must be defined programmatically by a developer.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011670589447021484}, "created": {"value": false, "score": 0.00022798776626586914}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 24, "offsetEnd": 29}, "context": "However, in the case of Spark, there is no way to directly access the data of an RDD partition.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023788213729858398}, "created": {"value": false, "score": 0.00023311376571655273}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 24, "offsetEnd": 33}, "context": "Hybrid systems (besides LeanXcale) usually access document data stores through extended relational mappings, with the added support of flattening operators (UNNEST) to express queries over nested documents. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.8770179748535156e-05}, "created": {"value": false, "score": 0.0006375908851623535}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 25, "offsetEnd": 28}, "context": "Without bind join, Spark SQL shows a slight advantage compared to LeanXcale DQE, which is explainable by the overhead of the JavaScript interpreting that takes place at DQE wrappers for MongoDB.", "mentionContextAttributes": {"used": {"value": false, "score": 0.004089474678039551}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 25, "offsetEnd": 28}, "context": "The concept relies on an API that allows its generalization to multiple script engines and data stores.", "mentionContextAttributes": {"used": {"value": false, "score": 4.0531158447265625e-05}, "created": {"value": false, "score": 0.035234153270721436}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 25, "offsetEnd": 34}, "context": "When LINEITEM resides at LeanXcale, the performance is highest, as the query engine processes it natively.", "mentionContextAttributes": {"used": {"value": false, "score": 0.018893957138061523}, "created": {"value": false, "score": 9.298324584960938e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 26, "offsetEnd": 29}, "context": "With respect to combining SQL and map/reduce operators, a number of SQL-like query languages have been introduced.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001055002212524414}, "created": {"value": false, "score": 0.012389898300170898}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Bigtable", "normalizedForm": "Bigtable", "offsetStart": 27, "offsetEnd": 35}, "publisher": {"rawForm": "Google", "normalizedForm": "Google"}, "context": "However, it only works for Bigtable-like systems and cannot integrate data from HDFS.", "mentionContextAttributes": {"used": {"value": false, "score": 6.771087646484375e-05}, "created": {"value": false, "score": 0.00018328428268432617}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0007173418998718262}, "created": {"value": false, "score": 0.00023955106735229492}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 28, "offsetEnd": 31}, "context": "Spark SQL [6] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022155046463012695}, "created": {"value": false, "score": 0.01336449384689331}, "shared": {"value": false, "score": 2.5033950805664062e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 28, "offsetEnd": 35}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 29, "offsetEnd": 32}, "context": "Presto [32] is a distributed SQL query engine, running on a shared-nothing cluster of machines, and designed to process interactive analytic queries against data sources of any size.", "mentionContextAttributes": {"used": {"value": false, "score": 4.8160552978515625e-05}, "created": {"value": false, "score": 0.113475501537323}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 29, "offsetEnd": 34}, "context": "Since this necessitates that Spark workers find and connect to DataLake wrapper instances, it results in a different, more complex architecture of the distributed Spark wrapper.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006530880928039551}, "created": {"value": false, "score": 6.139278411865234e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 30, "offsetEnd": 37}, "context": "Intermediate result sets from MongoDB, HDFS, and Spark are retrieved in parallel, as described in Section 5. Fig. 8 shows the performance measurements on queries of the first test case, executing joins between LINEITEM and ORDERS tables in any configuration of pairs between the three data stores.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9919283390045166}, "created": {"value": false, "score": 7.867813110351562e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 31, "offsetEnd": 34}, "context": "Spark SQL provides a DataFrame API that can map to relations arbitrary object collections and thus enables relational operations across Spark's RDDs and external data sources.", "mentionContextAttributes": {"used": {"value": false, "score": 8.463859558105469e-05}, "created": {"value": false, "score": 0.0007729530334472656}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 32, "offsetEnd": 35}, "context": "The CloudMdsQL language [26] is SQL-based with the extended capabilities for embedding subqueries expressed in terms of each data store's native query interface.", "mentionContextAttributes": {"used": {"value": false, "score": 0.002769768238067627}, "created": {"value": false, "score": 0.000152587890625}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 32, "offsetEnd": 39}, "context": "Non-relational systems, such as MongoDB, are supported by defining relational semantics for their operations and adding rules to translate them properly into the relational algebra, used by Myria's relational algebra compiler RACO.", "mentionContextAttributes": {"used": {"value": false, "score": 6.103515625e-05}, "created": {"value": false, "score": 0.0007066726684570312}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 33, "offsetEnd": 43}, "context": "We start with an overview of the CloudMdsQL query language focusing on the polyglot capabilities and optimization techniques. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.009201526641845703}, "created": {"value": true, "score": 0.9829022884368896}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 34, "offsetEnd": 41}, "context": "In addition, HiveQL allows custom scripts, defining MapReduce jobs, to be referred in queries and used in combination with relational operators.", "mentionContextAttributes": {"used": {"value": false, "score": 2.9921531677246094e-05}, "created": {"value": false, "score": 0.0003439188003540039}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 34, "offsetEnd": 44}, "context": "For example, the following simple CloudMdsQL query contains two subqueries, defined by the named table expressions T1 and T2, and addressed respectively against the data stores rdb (an SQL database) and mongo (a MongoDB database):", "mentionContextAttributes": {"used": {"value": false, "score": 0.0022200942039489746}, "created": {"value": false, "score": 3.7550926208496094e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 35, "offsetEnd": 38}, "context": "SCOPE has been extended to combine SQL and MapReduce operators in a single language [40].", "mentionContextAttributes": {"used": {"value": false, "score": 0.00015783309936523438}, "created": {"value": false, "score": 0.0009505152702331543}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Flink", "normalizedForm": "Apache Flink", "offsetStart": 35, "offsetEnd": 47}, "context": "Hadoop MapReduce, Apache Spark, or Apache Flink), specialized for different kinds of data and tasks and able to scale and perform orders of magnitude better than traditional relational DBMS. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 36, "offsetEnd": 39}, "context": "LeanXcale is a scalable distributed SQL database management system with OLTP and OLAP support and full ACID capabilities.", "mentionContextAttributes": {"used": {"value": false, "score": 9.131431579589844e-05}, "created": {"value": false, "score": 0.0007436871528625488}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 36, "offsetEnd": 41}, "context": "The coordinating components for the Spark subsystem, Livy and AgentRegistry, are running on one of the nodes.", "mentionContextAttributes": {"used": {"value": true, "score": 0.847385823726654}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 36, "offsetEnd": 43}, "context": "The full scripting functionality of MongoDB JavaScript library is still provided, but in case parallel execution constraints fail, the execution falls back to a sequential one. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.002060830593109131}, "created": {"value": false, "score": 0.0003560781478881836}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 36, "offsetEnd": 44}, "context": "By interfacing wrappers through the DataLake API, the DQE has the possibility to retrieve in parallel disjoint subsets of the result set, much like it does with LeanXcale tables.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0095023512840271}, "created": {"value": false, "score": 6.711483001708984e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 37, "offsetEnd": 40}, "context": "Existing polystore solutions provide SQL mappings to underlying data objects (document collections, raw files, etc.).", "mentionContextAttributes": {"used": {"value": false, "score": 3.421306610107422e-05}, "created": {"value": false, "score": 0.00281447172164917}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 37, "offsetEnd": 44}, "context": "First, the wrapper verifies that the MongoDB balancer is not running in background, because otherwise it may be moving chunks of data across MongoDB shards at the same time the query is being executed, which may result in inconsistent reads. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.10765993595123291}, "created": {"value": false, "score": 1.3828277587890625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 37, "offsetEnd": 44}, "context": "To evaluate BookOrders, we created a MongoDB nested document collection named Orders_Items, where we combined the ORDERS and LINEITEM datasets as follows.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9208794832229614}, "created": {"value": true, "score": 0.9981260895729065}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 38, "offsetEnd": 45}, "context": "Moreover, enabling native queries and scripts allows to fully exploit the power of the underlying data stores, as opposed to using static mappings to a common data model.", "mentionContextAttributes": {"used": {"value": false, "score": 4.8995018005371094e-05}, "created": {"value": false, "score": 0.00838625431060791}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 38, "offsetEnd": 46}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 38, "offsetEnd": 47}, "context": "In particular, even in the context of LeanXcale DQE with 2 bind joins sophisticated subqueries expressed as JavaScript or Scala code, parallel join processing shows good speedup with increase of the parallelism level.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001138448715209961}, "created": {"value": false, "score": 7.867813110351562e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 39, "offsetEnd": 42}, "context": "Each wrapper typically uses the client API of the corresponding data management cluster and implements the following DataLake API methods to be invoked by the query engine in order to provide parallel retrieval of shards (Fig. 3).", "mentionContextAttributes": {"used": {"value": false, "score": 0.031944215297698975}, "created": {"value": false, "score": 8.988380432128906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 39, "offsetEnd": 46}, "context": "For example, Q1 ML joins LINEITEM from MongoDB with ORDERS from LeanXcale.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005032002925872803}, "created": {"value": false, "score": 4.172325134277344e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 39, "offsetEnd": 48}, "context": "Fig. 1 illustrates the architecture of LeanXcale's Distributed Query Engine (DQE).", "mentionContextAttributes": {"used": {"value": false, "score": 0.05967438220977783}, "created": {"value": false, "score": 0.0003097057342529297}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 40, "offsetEnd": 43}, "context": "Teradata is responsible for building an SQL query plan and deciding where each SQL operator (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0034809112548828125}, "created": {"value": false, "score": 0.01322019100189209}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL Server Parallel", "normalizedForm": "SQL Server Parallel", "offsetStart": 40, "offsetEnd": 59}, "publisher": {"rawForm": "Microsoft", "normalizedForm": "Microsoft", "offsetStart": 30, "offsetEnd": 39}, "context": "Polybase [15] is a feature of Microsoft SQL Server Parallel Data Warehouse to access HDFS data using SQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00020509958267211914}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 5.841255187988281e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00020509958267211914}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 5.841255187988281e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 41, "offsetEnd": 44}, "context": "Impala [5] is an open-source distributed SQL engine operating over Hadoop data processing environment.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019916892051696777}, "created": {"value": false, "score": 1.609325408935547e-05}, "shared": {"value": false, "score": 0.01025998592376709}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 41, "offsetEnd": 50}, "context": "All the queries were run on a cluster of LeanXcale DQE instances, running the distributed wrappers for MongoDB, Hive, and Spark.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 2.777576446533203e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 42, "offsetEnd": 46}, "context": "Therefore, a wrapper instance can use the Hive metastore API to get schema and partitioning information for the subqueried HDFS table and hence to enable iteration on a particular split (shard) of the table. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.013434112071990967}, "created": {"value": false, "score": 1.6689300537109375e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 42, "offsetEnd": 48}, "context": "Then, after grouping by keyword, the last REDUCE selects, for each keyword, the (user, frequency) pair that has the greatest value of frequency.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04892706871032715}, "created": {"value": false, "score": 6.4373016357421875e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 43, "offsetEnd": 46}, "context": "aggregation pipelines), beyond the trivial SQL mappings; (b) parallel map/filter/reduce subqueries, done natively through Spark RDD transformations; (c) parallel joins and scalability.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04849100112915039}, "created": {"value": false, "score": 5.7220458984375e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 43, "offsetEnd": 50}, "context": "The concept of parallel querying against a MongoDB cluster is built on the assumption that each DQE worker can access directly a MongoDB shard, bypassing the MongoDB router in order to sustain parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023823976516723633}, "created": {"value": false, "score": 0.0005996227264404297}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MapReduce", "normalizedForm": "MapReduce", "offsetStart": 43, "offsetEnd": 52}, "context": "SCOPE has been extended to combine SQL and MapReduce operators in a single language [40]. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00015783309936523438}, "created": {"value": false, "score": 0.0009505152702331543}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.2296445369720459}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 43, "offsetEnd": 52}, "context": "All the generated datasets were: loaded in LeanXcale as relational tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables and through Spark by means of scans expressed as simple MFR/Scala statements.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9994305968284607}, "created": {"value": false, "score": 2.86102294921875e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 43, "offsetEnd": 53}, "context": "When tuples are received and deserialized, SparkAgent buffers them to a queue, from where they are pulled by the query engine through calls of the next() method of the wrapper instance.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04876130819320679}, "created": {"value": false, "score": 9.417533874511719e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "AgentRegistry", "normalizedForm": "AgentRegistry", "offsetStart": 43, "offsetEnd": 56}, "context": "It requests from a common component, named AgentRegistry, the address of an available SparkAgent (waiting for such availability, if necessary) and makes a socket connection to it.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005658268928527832}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.847385823726654}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 44, "offsetEnd": 49}, "context": "Doing this in parallel and uniformly across Spark and query engine workers is the major challenge of the current extension of our work.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001723766326904297}, "created": {"value": false, "score": 0.35488808155059814}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 45, "offsetEnd": 48}, "context": "The SQL table expression T1 is defined by an SQL subquery, while T2 is a native expression (identified by the special bracket symbols {* *}) expressed as a native MongoDB API call or JavaScript code.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05572444200515747}, "created": {"value": false, "score": 4.172325134277344e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 45, "offsetEnd": 48}, "context": "By interfacing wrappers through the DataLake API, the DQE has the possibility to retrieve in parallel disjoint subsets of the result set, much like it does with LeanXcale tables.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0095023512840271}, "created": {"value": false, "score": 6.711483001708984e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 45, "offsetEnd": 50}, "context": "To enable remote submission of the generated Scala script for Spark by the master wrapper, our setup relies on Apache Livy2 , which provides a REST service for easy submission of Spark jobs and Spark context management.", "mentionContextAttributes": {"used": {"value": false, "score": 0.13044780492782593}, "created": {"value": false, "score": 0.08340555429458618}, "shared": {"value": false, "score": 1.4781951904296875e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 45, "offsetEnd": 52}, "context": "The MongoDB storage allows running Drill and MongoDB together in distributed mode, by assigning shards to different drillbits to exploit parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003085136413574219}, "created": {"value": false, "score": 5.8650970458984375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 46, "offsetEnd": 51}, "context": "To make the CLICKS dataset accessible by both Spark and LeanXcale, it is generated as an HDFS file. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.04405397176742554}, "created": {"value": false, "score": 7.140636444091797e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 46, "offsetEnd": 51}, "context": "At this moment, the execution of the prepared Spark job gets initiated by calling through the same Livy session the following foreachPartition action function that makes each partition connect to an available wrapper instance and send its data: In this code, connectSparkAgent is a function that the master wrapper preliminarily generates and defines in the Livy session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.02586996555328369}, "created": {"value": false, "score": 1.4066696166992188e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 47, "offsetEnd": 50}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 47, "offsetEnd": 52}, "context": "PrepareScript is responsible for preparing the Scala script to be submitted as a Spark job and is active only at the master wrapper for a particular query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0041013360023498535}, "created": {"value": false, "score": 0.0053519606590271}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 47, "offsetEnd": 56}, "context": "Performance benefits are noticeable when using LeanXcale with bind join, where smaller values of the selectivity factor SF result in shorter lists of outer keys for the bind join condition and hence faster execution of the BookOrders subquery.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00203019380569458}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 48, "offsetEnd": 51}, "context": "Normally, a transformation is expressed with an SQL-like expression that involves special variables; however, more specific transformations may be defined through the use of lambda functions.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008026957511901855}, "created": {"value": false, "score": 6.508827209472656e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 48, "offsetEnd": 55}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 48, "offsetEnd": 58}, "context": "To illustrate it, let us consider the following CloudMdsQL query:", "mentionContextAttributes": {"used": {"value": false, "score": 0.06672507524490356}, "created": {"value": false, "score": 0.0001843571662902832}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Livy", "normalizedForm": "Livy", "offsetStart": 49, "offsetEnd": 53}, "context": "To figure out this number, PrepareScript opens a Livy session, initializes the rdd variable using the above Scala statement, and then calls rdd.getNumPartitions().", "mentionContextAttributes": {"used": {"value": true, "score": 0.9127829670906067}, "created": {"value": false, "score": 1.0728836059570312e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9127829670906067}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 49, "offsetEnd": 54}, "context": "Intermediate result sets from MongoDB, HDFS, and Spark are retrieved in parallel, as described in Section 5. Fig. 8 shows the performance measurements on queries of the first test case, executing joins between LINEITEM and ORDERS tables in any configuration of pairs between the three data stores.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9919283390045166}, "created": {"value": false, "score": 7.867813110351562e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 50, "offsetEnd": 57}, "context": "The level of parallelism was set to 512, i.e. 512 MongoDB shards, 512 LeanXcale DQE instances, and 512 Spark executors.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998719692230225}, "created": {"value": false, "score": 9.298324584960938e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 51, "offsetEnd": 57}, "language": {"rawForm": "Scala", "normalizedForm": "Scala", "wikidataId": "Q460584", "offsetStart": 45, "offsetEnd": 50}, "context": "To enable remote submission of the generated Scala script for Spark by the master wrapper, our setup relies on Apache Livy2 , which provides a REST service for easy submission of Spark jobs and Spark context management. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.13044780492782593}, "created": {"value": false, "score": 0.08340555429458618}, "shared": {"value": false, "score": 1.4781951904296875e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 51, "offsetEnd": 58}, "context": "Spark SQL can access a MongoDB cluster through its MongoDB connector that maps a sharded document collection to a Data-Frame, partitioned as per the collection's sharding setup.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0013504624366760254}, "created": {"value": false, "score": 2.5033950805664062e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MapReduce", "normalizedForm": "MapReduce", "offsetStart": 52, "offsetEnd": 61}, "context": "In addition, HiveQL allows custom scripts, defining MapReduce jobs, to be referred in queries and used in combination with relational operators. ", "mentionContextAttributes": {"used": {"value": false, "score": 2.9921531677246094e-05}, "created": {"value": false, "score": 0.0003439188003540039}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.2296445369720459}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 52, "offsetEnd": 61}, "context": "Then we discuss the distributed architecture of the LeanXcale query engine, which we use to enable the parallel capabilities of our polystore.", "mentionContextAttributes": {"used": {"value": false, "score": 0.007561743259429932}, "created": {"value": true, "score": 0.9993625283241272}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Livy", "normalizedForm": "Livy", "offsetStart": 53, "offsetEnd": 57}, "context": "The coordinating components for the Spark subsystem, Livy and AgentRegistry, are running on one of the nodes. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.847385823726654}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9127829670906067}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 53, "offsetEnd": 59}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "PrepareScript is responsible for preparing the Scala script to be submitted as a Spark job and is active only at the master wrapper for a particular query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0041013360023498535}, "created": {"value": false, "score": 0.0053519606590271}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 54, "offsetEnd": 57}, "context": "What Spark SQL is not capable of is bind join through SQL queries; to perform a bind join, one has to write a Spark program, which limits the use cases.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00010180473327636719}, "created": {"value": false, "score": 0.00010180473327636719}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 54, "offsetEnd": 60}, "context": "As opposed to typical batch processing frameworks for Hadoop, Impala provides low latency and high concurrency for analytical queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.0040740966796875e-05}, "created": {"value": false, "score": 0.0002314448356628418}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 54, "offsetEnd": 60}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "The DQE initiates the subquery request by passing the script code to each wrapper instance through a call to its init() method.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20907801389694214}, "created": {"value": false, "score": 7.343292236328125e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 54, "offsetEnd": 63}, "context": "Moreover, joins across any native datasets, including LeanXcale tables, can be applied, exploiting efficient parallel join algorithms. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013780593872070312}, "created": {"value": false, "score": 0.006434619426727295}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 54, "offsetEnd": 66}, "context": "To address distributed processing frameworks (such as Apache Spark) as data stores, CloudMdsQL introduces a formal notation that enables the adhoc usage of user-defined map/filter/reduce (MFR) operators as subqueries to request data processing in an underlying big data processing framework [9]. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.16312026977539e-05}, "created": {"value": false, "score": 0.003075540065765381}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 55, "offsetEnd": 65}, "context": "Each wrapper instance is composed of PrepareScript and SparkAgent components. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 4.780292510986328e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 55, "offsetEnd": 67}, "context": "Spark SQL [6] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022155046463012695}, "created": {"value": false, "score": 0.01336449384689331}, "shared": {"value": false, "score": 2.5033950805664062e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 56, "offsetEnd": 61}, "context": "Fig. 11 shows the times for processing Q3 queries: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9697527885437012}, "created": {"value": false, "score": 4.649162292480469e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 56, "offsetEnd": 62}, "context": "Each of the three major MFR operations (MAP, FILTER and REDUCE) takes as input a dataset and produces another dataset by performing the corresponding transformation. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.014665365219116211}, "created": {"value": false, "score": 2.5510787963867188e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 56, "offsetEnd": 65}, "context": "To make the CLICKS dataset accessible by both Spark and LeanXcale, it is generated as an HDFS file. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.04405397176742554}, "created": {"value": false, "score": 7.140636444091797e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 57, "offsetEnd": 60}, "context": "Therefore, a wrapper instance can use the Hive metastore API to get schema and partitioning information for the subqueried HDFS table and hence to enable iteration on a particular split (shard) of the table.", "mentionContextAttributes": {"used": {"value": false, "score": 0.013434112071990967}, "created": {"value": false, "score": 1.6689300537109375e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 57, "offsetEnd": 62}, "context": "We also apply our approach for parallel integration with Spark, together with its architectural and implementation details (Section 5.5). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0016289353370666504}, "created": {"value": false, "score": 0.4057772755622864}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 58, "offsetEnd": 63}, "context": "Execution times (in seconds) of Q2 queries on complex MFR/Scala queries to Spark with scales of data from 60 to 240 GB and levels of parallelism from 32 to 512.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998712539672852}, "created": {"value": false, "score": 4.5299530029296875e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache", "normalizedForm": "Apache", "offsetStart": 58, "offsetEnd": 64}, "context": "As stated in Section 3, the major challenge of supporting Apache Spark as an underlying data management cluster is to enable parallel data movement from Spark workers to DataLake wrappers. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023478269577026367}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00023478269577026367}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 58, "offsetEnd": 65}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": false, "score": 9.369850158691406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 59, "offsetEnd": 64}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 59, "offsetEnd": 65}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "The method init(ScriptContext) requests the execution of a script to retrieve data from the data store.", "mentionContextAttributes": {"used": {"value": false, "score": 0.10563671588897705}, "created": {"value": false, "score": 6.0558319091796875e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Pig/Hive code", "normalizedForm": "Pig/Hive code", "offsetStart": 59, "offsetEnd": 72}, "context": "It produces SQL statements for relational data stores, and Pig/Hive code for interfacing Hadoop to access HDFS data. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00014781951904296875}, "created": {"value": false, "score": 0.0006140470504760742}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00014781951904296875}, "created": {"value": false, "score": 0.0006140470504760742}, "shared": {"value": false, "score": 1.430511474609375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 60, "offsetEnd": 67}, "context": "In this section, we introduce the design of the distributed MongoDB wrapper. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.410743713378906e-05}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 60, "offsetEnd": 67}, "context": "To better illustrate the necessity of enabling user-defined scripts to MongoDB as subqueries, rather than defining SQL mappings to document collections, let us consider the following MongoDB collection orders that has a highly non-relational structure:", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022834539413452148}, "created": {"value": false, "score": 0.0009965300559997559}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 61, "offsetEnd": 65}, "context": "The DQE initiates the subquery request by passing the script code to each wrapper instance through a call to its init() method.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20907801389694214}, "created": {"value": false, "score": 7.343292236328125e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 61, "offsetEnd": 67}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "Normally, the wrapper does not initiate the execution of the script before a shard is assigned by the setShard method (see below).", "mentionContextAttributes": {"used": {"value": false, "score": 0.002154111862182617}, "created": {"value": false, "score": 8.654594421386719e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 62, "offsetEnd": 65}, "context": "A named table expression can be defined by means of either an SQL SELECT statement (that the query compiler is able to analyze and possibly rewrite) or a native expression (that the query engine considers as a black box and delegates its processing directly to the data store).", "mentionContextAttributes": {"used": {"value": false, "score": 0.000891268253326416}, "created": {"value": false, "score": 0.00023430585861206055}, "shared": {"value": false, "score": 1.5497207641601562e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 62, "offsetEnd": 65}, "context": "Fig. 11 shows the times for processing Q3 queries: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9697527885437012}, "created": {"value": false, "score": 4.649162292480469e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 62, "offsetEnd": 66}, "context": "HiveQL is the query language of the data warehousing solution Hive, built on top of Hadoop MapReduce [35]. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.002870023250579834}, "created": {"value": false, "score": 7.49826431274414e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 62, "offsetEnd": 67}, "context": "To enable remote submission of the generated Scala script for Spark by the master wrapper, our setup relies on Apache Livy2 , which provides a REST service for easy submission of Spark jobs and Spark context management.", "mentionContextAttributes": {"used": {"value": false, "score": 0.13044780492782593}, "created": {"value": false, "score": 0.08340555429458618}, "shared": {"value": false, "score": 1.4781951904296875e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Impala", "normalizedForm": "Impala", "offsetStart": 62, "offsetEnd": 68}, "context": "As opposed to typical batch processing frameworks for Hadoop, Impala provides low latency and high concurrency for analytical queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.0040740966796875e-05}, "created": {"value": false, "score": 0.0002314448356628418}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019916892051696777}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "AgentRegistry", "normalizedForm": "AgentRegistry", "offsetStart": 62, "offsetEnd": 75}, "context": "The coordinating components for the Spark subsystem, Livy and AgentRegistry, are running on one of the nodes. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.847385823726654}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.847385823726654}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Calcite", "normalizedForm": "Apache Calcite", "offsetStart": 62, "offsetEnd": 79}, "context": "The LeanXcale database has derived its OLAP query engine from Apache Calcite [8], a Java-based open-source framework for SQL query processing and optimization. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.6484058499336243}, "created": {"value": false, "score": 0.00020927190780639648}, "shared": {"value": false, "score": 8.463859558105469e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.6484058499336243}, "created": {"value": false, "score": 0.00020927190780639648}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 63, "offsetEnd": 71}, "context": "Since this necessitates that Spark workers find and connect to DataLake wrapper instances, it results in a different, more complex architecture of the distributed Spark wrapper.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006530880928039551}, "created": {"value": false, "score": 6.139278411865234e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 63, "offsetEnd": 73}, "context": "\u2022 Highly expressive queries: adopt he polyglot approach of the CloudMdsQL query language to allow data store native queries or scripts to be expressed as inline subqueries.", "mentionContextAttributes": {"used": {"value": false, "score": 2.7418136596679688e-05}, "created": {"value": false, "score": 0.005428016185760498}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 64, "offsetEnd": 69}, "context": "This allows for distributed data processing frameworks, such as Spark, to be supported by the DQE.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013184547424316406}, "created": {"value": false, "score": 0.09245717525482178}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 64, "offsetEnd": 69}, "context": "A discovery service is introduced through the special component Spark Agent Registry that keeps information about available Spark wrapper instances and dispatches them to the requesting Spark workers so that parallelism is fully exploited in moving data from a Spark RDD to the DQE.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005214512348175049}, "created": {"value": false, "score": 0.003361940383911133}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 64, "offsetEnd": 69}, "context": "SparkAgent is the component, which accepts TCP connections from Spark executors to push RDD partition data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04578143358230591}, "created": {"value": false, "score": 7.867813110351562e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 64, "offsetEnd": 73}, "context": "For example, Q1 ML joins LINEITEM from MongoDB with ORDERS from LeanXcale.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005032002925872803}, "created": {"value": false, "score": 4.172325134277344e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 65, "offsetEnd": 70}, "context": "As stated in Section 3, the major challenge of supporting Apache Spark as an underlying data management cluster is to enable parallel data movement from Spark workers to DataLake wrappers.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023478269577026367}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 65, "offsetEnd": 71}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "It provides connection details to address the data store and the script as text.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011587142944335938}, "created": {"value": false, "score": 0.009908437728881836}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Warehouse", "normalizedForm": "Warehouse", "offsetStart": 65, "offsetEnd": 74}, "context": "Polybase [15] is a feature of Microsoft SQL Server Parallel Data Warehouse to access HDFS data using SQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00020509958267211914}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 5.841255187988281e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00020509958267211914}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 5.841255187988281e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 66, "offsetEnd": 72}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "\u2022 A wrapper instance must be able to execute a native subquery or script against a particular shard of the underlying data store cluster.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00017142295837402344}, "created": {"value": false, "score": 6.222724914550781e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 66, "offsetEnd": 73}, "context": "The findSharded() method accepts the same arguments as the native MongoDB find() operator, in order to provide the native flexible querying functionality, complemented with the ability to handle parallel iteration on the sharded result set.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013506412506103516}, "created": {"value": false, "score": 4.076957702636719e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 66, "offsetEnd": 75}, "context": "Without bind join, Spark SQL shows a slight advantage compared to LeanXcale DQE, which is explainable by the overhead of the JavaScript interpreting that takes place at DQE wrappers for MongoDB. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.004089474678039551}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 67, "offsetEnd": 70}, "context": "With GQL, the task is achievable because it represents a subset of SQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007592439651489258}, "created": {"value": false, "score": 0.00015854835510253906}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 67, "offsetEnd": 70}, "context": "This can facilitate the work of data analysts who just need to run SQL queries on predefined views over the underlying data stores, without the need to deeply understand the specifics of the data technologies and data organization.", "mentionContextAttributes": {"used": {"value": false, "score": 3.445148468017578e-05}, "created": {"value": false, "score": 0.013608694076538086}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 67, "offsetEnd": 71}, "context": "We assume that each accessed HDFS file is registered as table in a Hive metastore.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9806443452835083}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 67, "offsetEnd": 73}, "context": "Impala [5] is an open-source distributed SQL engine operating over Hadoop data processing environment. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019916892051696777}, "created": {"value": false, "score": 1.609325408935547e-05}, "shared": {"value": false, "score": 0.01025998592376709}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 67, "offsetEnd": 73}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "Query Q2 M evaluates just the parallel execution of the BookOrders script in MongoDB, while Q2 ML involves a join between MongoDB and the CUSTOMER table from the LeanXcale data store: Fig. 9 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7139509320259094}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 67, "offsetEnd": 74}, "context": "This allows data store native subqueries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration statements. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016188621520996094}, "created": {"value": false, "score": 0.0001990199089050293}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 67, "offsetEnd": 74}, "context": "We introduced architectural extensions that enable specific native scripts to be handled in parallel at data store shards, so that efficient and scalable parallel joins take place at query engine level.", "mentionContextAttributes": {"used": {"value": false, "score": 6.914138793945312e-05}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 68, "offsetEnd": 71}, "context": "With respect to combining SQL and map/reduce operators, a number of SQL-like query languages have been introduced.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001055002212524414}, "created": {"value": false, "score": 0.012389898300170898}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 69, "offsetEnd": 72}, "context": "An important problem the system focuses on is the cost estimation of SQL operators over remote systems.", "mentionContextAttributes": {"used": {"value": false, "score": 6.0558319091796875e-05}, "created": {"value": false, "score": 0.0021062493324279785}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 69, "offsetEnd": 72}, "context": "In particular, the parallel query processing with bind joins through SQL queries is not supported by any of the hybrid systems.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0038103461265563965}, "created": {"value": false, "score": 6.61611557006836e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 69, "offsetEnd": 74}, "context": "This can be expressed with the following MFR subquery, with embedded Scala lambda functions to define custom transformation logic: In this sequence of operations, the first MAP takes a tuple (corresponding to a row from the input file) as an array of string values (tup) and maps the username (tup(2)) to the keywords subarray (tup.slice(\u2026)).", "mentionContextAttributes": {"used": {"value": true, "score": 0.5007937550544739}, "created": {"value": false, "score": 6.079673767089844e-06}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MapReduce", "normalizedForm": "MapReduce", "offsetStart": 69, "offsetEnd": 78}, "context": "Let us consider the following simple example inspired by the popular MapReduce tutorial application \"word count\". ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023597478866577148}, "created": {"value": false, "score": 0.2296445369720459}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.2296445369720459}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 70, "offsetEnd": 75}, "context": "Then, the PrepareScript component of the master wrapper generates the Scala code that corresponds to the MFR query, to initialize a variable named rdd: val rdd = sc.textFile( ", "mentionContextAttributes": {"used": {"value": false, "score": 0.198736310005188}, "created": {"value": false, "score": 2.002716064453125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 70, "offsetEnd": 75}, "context": "In general, the execution of these queries is much slower, as, at the Spark level, it involves shuffles of significant amounts of intermediate data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0011293292045593262}, "created": {"value": false, "score": 5.9604644775390625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 70, "offsetEnd": 76}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 70, "offsetEnd": 79}, "context": "The level of parallelism was set to 512, i.e. 512 MongoDB shards, 512 LeanXcale DQE instances, and 512 Spark executors.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998719692230225}, "created": {"value": false, "score": 9.298324584960938e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 71, "offsetEnd": 78}, "context": "To better illustrate the necessity of enabling user-defined scripts to MongoDB as subqueries, rather than defining SQL mappings to document collections, let us consider the following MongoDB collection orders that has a highly non-relational structure:", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022834539413452148}, "created": {"value": false, "score": 0.0009965300559997559}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 72, "offsetEnd": 75}, "context": "And third, the query needs to be expressive enough, so as to combine an SQL subquery (to the relational database) with an arbitrary code in a scripting language (e.g. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05599552392959595}, "created": {"value": false, "score": 5.316734313964844e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 72, "offsetEnd": 80}, "context": "For a particular data store, each DQE worker creates an instance of the DataLake wrapper that is generally used for querying and retrieval of shards of data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.004917621612548828}, "created": {"value": false, "score": 0.0001308917999267578}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 72, "offsetEnd": 81}, "context": "Fig. 11 shows the times for processing Q3 queries: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9697527885437012}, "created": {"value": false, "score": 4.649162292480469e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script engines", "normalizedForm": "script engines", "offsetStart": 72, "offsetEnd": 86}, "context": "The concept relies on an API that allows its generalization to multiple script engines and data stores. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.0531158447265625e-05}, "created": {"value": false, "score": 0.035234153270721436}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0018170475959777832}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 1.0728836059570312e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 73, "offsetEnd": 78}, "context": "On the other hand, as described above, when processing a partition, each Spark executor finds and sends to an available Spark agent all tuples of the partition.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0023292899131774902}, "created": {"value": false, "score": 4.673004150390625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 74, "offsetEnd": 77}, "context": "But they are limited to accessing only specific data stores, usually with SQL mappings of the data stores' query interfaces.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001907944679260254}, "created": {"value": false, "score": 0.00029712915420532227}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 75, "offsetEnd": 80}, "context": "Fig. 12 shows the times for processing Q4 queries, involving 2 joins: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.986201822757721}, "created": {"value": false, "score": 1.0967254638671875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 75, "offsetEnd": 80}, "context": "Execution times (in seconds) of Q2 queries on complex MFR/Scala queries to Spark with scales of data from 60 to 240 GB and levels of parallelism from 32 to 512.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998712539672852}, "created": {"value": false, "score": 4.5299530029296875e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 76, "offsetEnd": 79}, "context": "It interfaces MapReduce with RDBMS through database connectors that execute SQL queries to return key-value pairs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00026601552963256836}, "created": {"value": false, "score": 8.702278137207031e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 76, "offsetEnd": 80}, "context": "Then, the PrepareScript component of the master wrapper generates the Scala code that corresponds to the MFR query, to initialize a variable named rdd: val rdd = sc.textFile( ", "mentionContextAttributes": {"used": {"value": false, "score": 0.198736310005188}, "created": {"value": false, "score": 2.002716064453125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 76, "offsetEnd": 81}, "context": "MFR subqueries to Spark are defined as single SCAN operators, translated to Scala commands. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.011382758617401123}, "created": {"value": false, "score": 6.318092346191406e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 76, "offsetEnd": 83}, "context": "Although these systems enable parallel integration with data clusters (like MongoDB), none of them supports the combination of massive parallelism with native queries and the optimization of bind joins, which is addressed by the LeanXcale distributed query engine.", "mentionContextAttributes": {"used": {"value": false, "score": 4.6133995056152344e-05}, "created": {"value": false, "score": 0.0024118423461914062}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 76, "offsetEnd": 83}, "context": "The list of shards is then reported to the DQE scheduler, which assigns one MongoDB shard to each of the workers by calling the setShard() method.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9479722380638123}, "created": {"value": false, "score": 4.506111145019531e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 77, "offsetEnd": 81}, "context": "MISO [28] is a method for tuning the physical design of a multistore system (Hive/HDFS and RDBMS), i.e. deciding in which data store the data should reside, in order to improve the performance of big data query processing.", "mentionContextAttributes": {"used": {"value": false, "score": 4.887580871582031e-05}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 77, "offsetEnd": 82}, "context": "Query Q2 S evaluates just the parallel execution of the Experts MFR query on Spark, while Q2 SL involves a join with the CUSTOMER table from the LeanXcale data store: Fig. 10 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of MFR/Scala queries against Spark, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9895273447036743}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 77, "offsetEnd": 83}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "JavaScript), that requests a dataset from the document database, and another script (e.g. in Python or Scala for Spark), that requests a chain of transformations on the unstructured data from the HDFS log before involving it into relational joins. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.005140185356140137}, "created": {"value": false, "score": 3.910064697265625e-05}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 77, "offsetEnd": 83}, "context": "Tightly-coupled polystores have been introduced with the goal of integrating Hadoop or Spark for big data analysis with traditional (parallel) RDBMSs. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003224611282348633}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MyriaL", "normalizedForm": "MyriaL", "offsetStart": 77, "offsetEnd": 83}, "context": "Its extended relational model and the imperative-declarative hybrid language MyriaL span well all the underlying data models, where rewrite rules apply to transform expressions into specific API calls, queries, etc. for each of the data stores. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.594989776611328e-05}, "created": {"value": false, "score": 0.0023530125617980957}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 8.594989776611328e-05}, "created": {"value": false, "score": 0.0023530125617980957}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 77, "offsetEnd": 84}, "context": "Query Q2 M evaluates just the parallel execution of the BookOrders script in MongoDB, while Q2 ML involves a join between MongoDB and the CUSTOMER table from the LeanXcale data store: Fig. 9 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.7139509320259094}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 78, "offsetEnd": 88}, "context": "Upon a subsequent call of setShard() to a wrapper instance, the corresponding SparkAgent reports to the AgentRegistry its availability to receive partition data for this particular query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04014432430267334}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 79, "offsetEnd": 82}, "context": "Teradata is responsible for building an SQL query plan and deciding where each SQL operator (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0034809112548828125}, "created": {"value": false, "score": 0.01322019100189209}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 79, "offsetEnd": 88}, "context": "In this paper, we introduced a parallel polystore system that builds on top of LeanXcale's distributed query engine and processes queries in the CloudMdsQL query language. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.62396240234375e-05}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Teradata", "normalizedForm": "Teradata", "offsetStart": 80, "offsetEnd": 88}, "context": "join or aggregation) will execute on one of the IntelliSphere's systems (either Teradata or a remote system).", "mentionContextAttributes": {"used": {"value": false, "score": 0.43760091066360474}, "created": {"value": false, "score": 0.000538170337677002}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.43760091066360474}, "created": {"value": false, "score": 0.01322019100189209}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 80, "offsetEnd": 89}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": false, "score": 9.369850158691406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 3.2186508178710938e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 80, "offsetEnd": 89}, "context": "Presto follows the classical distributed DBMS architecture, which, similarly to LeanXcale, consists of a coordinator, multiple workers and connectors (storage plugins that interface external data stores and provide metadata to the coordinator and data to workers).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008665919303894043}, "created": {"value": false, "score": 0.0003376007080078125}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 81, "offsetEnd": 84}, "context": "Fig. 12 shows the times for processing Q4 queries, involving 2 joins: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join.", "mentionContextAttributes": {"used": {"value": true, "score": 0.986201822757721}, "created": {"value": false, "score": 1.0967254638671875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 81, "offsetEnd": 86}, "context": "Thus, even a distributed query engine cannot exploit parallelism in retrieving a Spark RDD, since only one worker will collect the entire RDD through the Spark driver, which is the limitation we want to overcome in this paper as an extended version of [24].", "mentionContextAttributes": {"used": {"value": false, "score": 0.00014734268188476562}, "created": {"value": false, "score": 0.027856826782226562}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 81, "offsetEnd": 86}, "context": "PrepareScript is responsible for preparing the Scala script to be submitted as a Spark job and is active only at the master wrapper for a particular query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0041013360023498535}, "created": {"value": false, "score": 0.0053519606590271}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 82, "offsetEnd": 87}, "context": "However, the collection of this intermediate result set is centralized, since the Spark driver simply merges the data from all the partitions of the final RDD into a single non-partitioned result set.", "mentionContextAttributes": {"used": {"value": false, "score": 0.2654303312301636}, "created": {"value": false, "score": 2.288818359375e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MapReduce", "normalizedForm": "MapReduce", "offsetStart": 82, "offsetEnd": 91}, "context": "HiveQL queries are decomposed to relational operators, which are then compiled to MapReduce jobs to be executed on Hadoop. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 4.4465065002441406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.2296445369720459}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 83, "offsetEnd": 95}, "context": "The new material addresses the support of distributed processing platforms such as Apache Spark by enabling the ad-hoc usage of user defined map/filter/reduce (MFR) operators as subqueries, yet allowing for pushing down predicates (e.g. for bind join conditions) and parallel retrieval of intermediate results. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.5789947509765625e-05}, "created": {"value": false, "score": 0.312763512134552}, "shared": {"value": false, "score": 2.0265579223632812e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 84, "offsetEnd": 94}, "context": "To address distributed processing frameworks (such as Apache Spark) as data stores, CloudMdsQL introduces a formal notation that enables the adhoc usage of user-defined map/filter/reduce (MFR) operators as subqueries to request data processing in an underlying big data processing framework [9]. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.16312026977539e-05}, "created": {"value": false, "score": 0.003075540065765381}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop MapReduce", "normalizedForm": "Hadoop MapReduce", "offsetStart": 84, "offsetEnd": 104}, "context": "HiveQL is the query language of the data warehousing solution Hive, built on top of Hadoop MapReduce [35]. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.002870023250579834}, "created": {"value": false, "score": 7.49826431274414e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002870023250579834}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 85, "offsetEnd": 92}, "context": "Thus, each DQE worker gets exactly one partition of both tables by connecting to one MongoDB shard (through a wrapper instance) and one KVDS (Fig. 4).", "mentionContextAttributes": {"used": {"value": false, "score": 0.10965794324874878}, "created": {"value": false, "score": 8.463859558105469e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 85, "offsetEnd": 92}, "context": "All the generated datasets were: loaded in LeanXcale as relational tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables and through Spark by means of scans expressed as simple MFR/Scala statements.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9994305968284607}, "created": {"value": false, "score": 2.86102294921875e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 86, "offsetEnd": 96}, "context": "It requests from a common component, named AgentRegistry, the address of an available SparkAgent (waiting for such availability, if necessary) and makes a socket connection to it.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005658268928527832}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 87, "offsetEnd": 92}, "context": "Tightly-coupled polystores have been introduced with the goal of integrating Hadoop or Spark for big data analysis with traditional (parallel) RDBMSs. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003224611282348633}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 88, "offsetEnd": 91}, "context": "For example, let us consider a banking institution that keeps its operational data in a SQL database, but stores data about bank transactions in a document database, because each record typically contains data in just a few fields, so this makes use of the semistructured nature of documents.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00017982721328735352}, "created": {"value": false, "score": 0.0014139413833618164}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 89, "offsetEnd": 95}, "context": "It produces SQL statements for relational data stores, and Pig/Hive code for interfacing Hadoop to access HDFS data. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00014781951904296875}, "created": {"value": false, "score": 0.0006140470504760742}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive metastore", "normalizedForm": "Hive metastore", "offsetStart": 89, "offsetEnd": 103}, "context": "For HDFS tables, some overhead is added, due to data conversions, communication with the Hive metastore, and possibly accessing HDFS splits through the network. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0026704072952270508}, "created": {"value": false, "score": 3.814697265625e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0026704072952270508}, "created": {"value": false, "score": 3.814697265625e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 90, "offsetEnd": 93}, "context": "The first group evaluates the scalability of the system in the context of straightforward SQL mappings with the underlying data stores.", "mentionContextAttributes": {"used": {"value": false, "score": 0.023896872997283936}, "created": {"value": false, "score": 0.008063793182373047}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 90, "offsetEnd": 99}, "context": "Each table is stored as a KiVi table, where the key corresponds to the primary key of the LeanXcale table and all the columns are stored as they are into KiVi columns.", "mentionContextAttributes": {"used": {"value": false, "score": 0.17349380254745483}, "created": {"value": false, "score": 5.900859832763672e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 90, "offsetEnd": 99}, "context": "Fig. 12. Execution times (in seconds) of Q4 queries joining the result of Q3 queries (1TB LeanXcale table joining 600GB MongoDB collection) with an MFR/Scala/Spark subquery against 240GB HDFS file.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": false, "score": 4.0411949157714844e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 91, "offsetEnd": 94}, "context": "These data management clusters can range from distributed raw data files, through parallel SQL databases, to sharded NoSQL databases (such as MongoDB, where queries can be expressed as JavaScript programs) and parallel data processing frameworks (such as Apache Spark, where data retrieval and/or transformation can be requested by means of Python or Scala scripting).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007843971252441406}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 91, "offsetEnd": 97}, "context": "Rule #2: REDUCE(<transformation>).FILTER(<predicate>) is equivalent to FILTER(<predicate>).REDUCE(<transformation>), if predicate condition is a function only of the KEY, because thus, applying the FILTER before the REDUCE will preserve the values associated to those keys that satisfy the filter condition as they would be if the FILTER was applied after the REDUCE.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9831936359405518}, "created": {"value": false, "score": 2.9802322387695312e-06}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 91, "offsetEnd": 98}, "context": "Document collections are exposed as tables to Presto, keeping schema mappings in a special MongoDB collection.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6295751929283142}, "created": {"value": false, "score": 0.00012600421905517578}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 91, "offsetEnd": 98}, "context": "Let us assume for simplicity a cluster of equal numbers of: DQE workers, KVDS servers, and MongoDB shards.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9932975172996521}, "created": {"value": false, "score": 3.528594970703125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 91, "offsetEnd": 100}, "context": "Fig. 12 shows the times for processing Q4 queries, involving 2 joins: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.986201822757721}, "created": {"value": false, "score": 1.0967254638671875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Bigtable", "normalizedForm": "Bigtable", "offsetStart": 92, "offsetEnd": 100}, "publisher": {"rawForm": "Google", "normalizedForm": "Google", "offsetStart": 83, "offsetEnd": 89}, "context": "BigIntegrator [29] integrates data from cloud-based NoSQL big data stores, such as Google's Bigtable, and relational databases. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016045570373535156}, "created": {"value": false, "score": 7.987022399902344e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0007173418998718262}, "created": {"value": false, "score": 0.00023955106735229492}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 92, "offsetEnd": 100}, "context": "\u2022 The scheduler must be able to assign shards to DQE workers and hence to the corresponding DataLake wrapper instances.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05084586143493652}, "created": {"value": false, "score": 2.181529998779297e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Python", "normalizedForm": "Python", "offsetStart": 93, "offsetEnd": 99}, "context": "JavaScript), that requests a dataset from the document database, and another script (e.g. in Python or Scala for Spark), that requests a chain of transformations on the unstructured data from the HDFS log before involving it into relational joins.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005140185356140137}, "created": {"value": false, "score": 3.910064697265625e-05}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 93, "offsetEnd": 99}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "Normally, this is the point where the connection to the data store shard takes place and the script execution is initiated.", "mentionContextAttributes": {"used": {"value": false, "score": 0.008256137371063232}, "created": {"value": false, "score": 0.0003540515899658203}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 94, "offsetEnd": 97}, "context": "Among hybrid systems, although Presto and Drill support well parallel query processing across SQL and NoSQL stores, the only one that provides parallel support of distributed data platforms is Spark SQL, as it uses Spark natively.", "mentionContextAttributes": {"used": {"value": false, "score": 7.045269012451172e-05}, "created": {"value": false, "score": 0.00028401613235473633}, "shared": {"value": false, "score": 3.2186508178710938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 94, "offsetEnd": 97}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale  Distributed Query Engine (DQE)", "normalizedForm": "LeanXcale Distributed Query Engine (DQE)", "offsetStart": 94, "offsetEnd": 135}, "context": "And to enable the parallel query processing, we incorporated the polyglot approach within the LeanXcale1 Distributed Query Engine (DQE), which provides a query engine with intra-query and intra-operator parallelism that operates over a standard SQL interface. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0017653703689575195}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0017653703689575195}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 96, "offsetEnd": 101}, "context": "Fig. 7 shows in detail the flow of operations for processing an MFR subquery by the distributed Spark wrapper.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7658796906471252}, "created": {"value": false, "score": 1.3828277587890625e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 98, "offsetEnd": 105}, "context": "A typical wrapper implementation should use a scripting engine and/or a client library to execute scripts (client-or server-side) against the data store.", "mentionContextAttributes": {"used": {"value": false, "score": 7.557868957519531e-05}, "created": {"value": false, "score": 0.0004601478576660156}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Livy", "normalizedForm": "Livy", "offsetStart": 99, "offsetEnd": 103}, "context": "At this moment, the execution of the prepared Spark job gets initiated by calling through the same Livy session the following foreachPartition action function that makes each partition connect to an available wrapper instance and send its data: In this code, connectSparkAgent is a function that the master wrapper preliminarily generates and defines in the Livy session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.02586996555328369}, "created": {"value": false, "score": 1.4066696166992188e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9127829670906067}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 99, "offsetEnd": 105}, "context": "In the example above, since the FILTER predicate involves only the KEY, it can be swapped with the REDUCE, thus allowing the filter to be applied earlier in order to avoid unnecessary and expensive computation.", "mentionContextAttributes": {"used": {"value": false, "score": 0.024402916431427002}, "created": {"value": false, "score": 1.704692840576172e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 99, "offsetEnd": 108}, "context": "Prof. Jose Pereira, Ricardo Vila\u00e7a, and Rui Gon\u00e7alves contributed to this work when they were with LeanXcale.", "mentionContextAttributes": {"used": {"value": false, "score": 0.1675979495048523}, "created": {"value": false, "score": 0.006302297115325928}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive API", "normalizedForm": "Hive API", "offsetStart": 100, "offsetEnd": 108}, "context": "This information is used by the master wrapper, which reports the list of file splits (instances of Hive API's InputSplit class) to the DQE scheduler upon a call to the listShards() method. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.40946561098098755}, "created": {"value": false, "score": 3.0517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.40946561098098755}, "created": {"value": false, "score": 3.0517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 100, "offsetEnd": 113}, "context": "The client library is therefore extended with the following document collection methods that return ShardedCursor and provide the targeted operators (find, map, and flat map) in user scripts.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0025481581687927246}, "created": {"value": false, "score": 0.00027638673782348633}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.011867344379425049}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 101, "offsetEnd": 104}, "context": "Polybase [15] is a feature of Microsoft SQL Server Parallel Data Warehouse to access HDFS data using SQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00020509958267211914}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 5.841255187988281e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 101, "offsetEnd": 104}, "context": "This allows data store native subqueries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration statements.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016188621520996094}, "created": {"value": false, "score": 0.0001990199089050293}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 101, "offsetEnd": 106}, "context": "For comparison with the state of the art, the large-scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 101, "offsetEnd": 113}, "context": "This problem was addressed in [9], by allowing distributed data processing frameworks (in particular Apache Spark) to be accessed as data stores and queried through the semideclarative MFR notation. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0013478398323059082}, "created": {"value": false, "score": 0.00011563301086425781}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 102, "offsetEnd": 107}, "context": "We address this problem by introducing an architecture, where each RDD partition (more precisely, the Spark worker that processes the partition) is instructed through generated code to find and connect to a query engine worker and to push the partition data.", "mentionContextAttributes": {"used": {"value": false, "score": 8.428096771240234e-05}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "environment", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 103, "offsetEnd": 108}, "context": "JavaScript), that requests a dataset from the document database, and another script (e.g. in Python or Scala for Spark), that requests a chain of transformations on the unstructured data from the HDFS log before involving it into relational joins. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.005140185356140137}, "created": {"value": false, "score": 3.910064697265625e-05}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 103, "offsetEnd": 108}, "context": "The level of parallelism was set to 512, i.e. 512 MongoDB shards, 512 LeanXcale DQE instances, and 512 Spark executors.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998719692230225}, "created": {"value": false, "score": 9.298324584960938e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 103, "offsetEnd": 110}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": false, "score": 9.369850158691406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 103, "offsetEnd": 110}, "context": "All the queries were run on a cluster of LeanXcale DQE instances, running the distributed wrappers for MongoDB, Hive, and Spark.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 2.777576446533203e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 104, "offsetEnd": 112}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 104, "offsetEnd": 114}, "context": "To provide bind join as an efficient method for performing semi-joins across heterogeneous data stores, CloudMdsQL uses subquery rewriting to push the join conditions. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.747245788574219e-05}, "created": {"value": false, "score": 2.4437904357910156e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "AgentRegistry", "normalizedForm": "AgentRegistry", "offsetStart": 104, "offsetEnd": 117}, "context": "Upon a subsequent call of setShard() to a wrapper instance, the corresponding SparkAgent reports to the AgentRegistry its availability to receive partition data for this particular query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04014432430267334}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.847385823726654}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 105, "offsetEnd": 108}, "context": "It allows HDFS data to be referenced through external PDW tables and joined with native PDW tables using SQL queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016224384307861328}, "created": {"value": false, "score": 9.1552734375e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 105, "offsetEnd": 112}, "context": "ordered by a given customer, would be defined by means of a flatMap operator in Ja-vaScript, following a MongoDB find() operator.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9996516704559326}, "created": {"value": false, "score": 2.181529998779297e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 106, "offsetEnd": 111}, "context": "Therefore, the query engine would be forced to use a single worker to retrieve the entire RDD through the Spark driver, serially. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9983766078948975}, "created": {"value": false, "score": 0.00014138221740722656}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 106, "offsetEnd": 112}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "Thus, a composition of findSharded and map/flatMap (such as in the BookOrders example above) makes a user script expressive enough, so as to request a specific MongoDB dataset, retrieve the result set in parallel, and transform it in order to fit the named table signature and further be consumed by relational operators at the DQE level.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0015254616737365723}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 107, "offsetEnd": 110}, "context": "For comparison with the state of the art, the large-scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 107, "offsetEnd": 113}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "In order to make a document result set fit the relational schema required by a Cloud-MdsQL query, the user script can further take advantage of the map() and flatMap() operators.", "mentionContextAttributes": {"used": {"value": false, "score": 0.007219493389129639}, "created": {"value": false, "score": 0.00012242794036865234}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 107, "offsetEnd": 114}, "context": "We compare the systems with respect to the features that we hereby address, mainly the parallel support of MongoDB, data processing platforms, and optimizability of selective joins through semi joins across data stores.", "mentionContextAttributes": {"used": {"value": false, "score": 0.015684068202972412}, "created": {"value": false, "score": 0.04509371519088745}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 107, "offsetEnd": 114}, "context": "In particular, we want to stress on the full parallelism to access the underlying datasets, in our case, a MongoDB collection and a Spark RDD, in the context of expressive subqueries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00029140710830688477}, "created": {"value": true, "score": 0.852452278137207}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 108, "offsetEnd": 113}, "context": "To figure out this number, PrepareScript opens a Livy session, initializes the rdd variable using the above Scala statement, and then calls rdd.getNumPartitions().", "mentionContextAttributes": {"used": {"value": true, "score": 0.9127829670906067}, "created": {"value": false, "score": 1.0728836059570312e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 109, "offsetEnd": 112}, "context": "The second group adds higher expressivity to the subqueries, which cannot be easily achieved through trivial SQL mappings, while still assessing the scalability.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016939640045166016}, "created": {"value": false, "score": 0.00011205673217773438}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 109, "offsetEnd": 113}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 110, "offsetEnd": 115}, "context": "What Spark SQL is not capable of is bind join through SQL queries; to perform a bind join, one has to write a Spark program, which limits the use cases.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00010180473327636719}, "created": {"value": false, "score": 0.00010180473327636719}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 110, "offsetEnd": 115}, "context": "The last test case extends the Q3 query by adding another join with the result of the Experts MFR subquery to Spark against the 240GB version of the generated posts log file.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9965709447860718}, "created": {"value": false, "score": 1.049041748046875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Bigtable", "normalizedForm": "Bigtable", "offsetStart": 110, "offsetEnd": 118}, "publisher": {"rawForm": "Google", "normalizedForm": "Google"}, "context": "The system relies on mapping a limited set of relational operators to native queries expressed in GQL (Google Bigtable query language). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007173418998718262}, "created": {"value": false, "score": 0.00023955106735229492}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0007173418998718262}, "created": {"value": false, "score": 0.00023955106735229492}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CUSTOMER", "normalizedForm": "CUSTOMER", "offsetStart": 110, "offsetEnd": 118}, "context": "The data used was based on the TPC-H benchmark schema [37], particularly for the tables LINEITEM, ORDERS, and CUSTOMER.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999274015426636}, "created": {"value": false, "score": 2.384185791015625e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999274015426636}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "InputSplit", "normalizedForm": "InputSplit", "offsetStart": 111, "offsetEnd": 121}, "context": "This information is used by the master wrapper, which reports the list of file splits (instances of Hive API's InputSplit class) to the DQE scheduler upon a call to the listShards() method. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.40946561098098755}, "created": {"value": false, "score": 3.0517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.40946561098098755}, "created": {"value": false, "score": 3.0517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 111, "offsetEnd": 121}, "context": "serialize is another function that serializes each entry of the RDD partition to a byte array in a format that SparkAgent can interpret, which is then sent to the SparkAgent through the socket. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.002984285354614258}, "created": {"value": false, "score": 3.266334533691406e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Livy", "normalizedForm": "Apache Livy", "offsetStart": 111, "offsetEnd": 123}, "context": "To enable remote submission of the generated Scala script for Spark by the master wrapper, our setup relies on Apache Livy2 , which provides a REST service for easy submission of Spark jobs and Spark context management. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.13044780492782593}, "created": {"value": false, "score": 0.08340555429458618}, "shared": {"value": false, "score": 1.4781951904296875e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.13044780492782593}, "created": {"value": false, "score": 0.08340555429458618}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 112, "offsetEnd": 116}, "context": "All the queries were run on a cluster of LeanXcale DQE instances, running the distributed wrappers for MongoDB, Hive, and Spark.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 2.777576446533203e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 112, "offsetEnd": 119}, "context": "Here, we specifically focus on parallel joins across a relational table, the result of a JavaScript subquery to MongoDB, and the result of an MFR/Scala subquery to Apache Spark, but the concept relies on an API that allows its generalization to other script engines and data stores as well. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0018170475959777832}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 113, "offsetEnd": 116}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Livy", "normalizedForm": "Livy", "offsetStart": 113, "offsetEnd": 117}, "context": "This function is also generated by the master wrapper, once the type of the RDD entries is reported back through Livy after initialization of the rdd variable.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04038149118423462}, "created": {"value": false, "score": 0.0002709031105041504}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9127829670906067}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 113, "offsetEnd": 118}, "context": "JavaScript), that requests a dataset from the document database, and another script (e.g. in Python or Scala for Spark), that requests a chain of transformations on the unstructured data from the HDFS log before involving it into relational joins. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.005140185356140137}, "created": {"value": false, "score": 3.910064697265625e-05}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 113, "offsetEnd": 120}, "context": "Assuming that W1 is the master worker, it calls the listShards() method of its wrapper instance WR1 to query the MongoDB router for a list of MongoDB shards (database instances identified by host address and port), where partitions of the lineitem collection are stored.", "mentionContextAttributes": {"used": {"value": false, "score": 0.14902037382125854}, "created": {"value": false, "score": 1.633167266845703e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 114, "offsetEnd": 117}, "context": "This, however, limits the use cases, since a data analyst cannot easily take advantage of this feature through an SQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00020462274551391602}, "created": {"value": false, "score": 0.0001366138458251953}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 115, "offsetEnd": 118}, "context": "To better illustrate the necessity of enabling user-defined scripts to MongoDB as subqueries, rather than defining SQL mappings to document collections, let us consider the following MongoDB collection orders that has a highly non-relational structure:", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022834539413452148}, "created": {"value": false, "score": 0.0009965300559997559}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 115, "offsetEnd": 121}, "context": "HiveQL queries are decomposed to relational operators, which are then compiled to MapReduce jobs to be executed on Hadoop. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 4.4465065002441406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 116, "offsetEnd": 125}, "context": "Fig. 11 shows the times for processing Q3 queries: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9697527885437012}, "created": {"value": false, "score": 4.649162292480469e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 117, "offsetEnd": 125}, "context": "Each wrapper typically uses the client API of the corresponding data management cluster and implements the following DataLake API methods to be invoked by the query engine in order to provide parallel retrieval of shards (Fig. 3).", "mentionContextAttributes": {"used": {"value": false, "score": 0.031944215297698975}, "created": {"value": false, "score": 8.988380432128906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 118, "offsetEnd": 123}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 118, "offsetEnd": 125}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 118, "offsetEnd": 125}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 119, "offsetEnd": 126}, "context": "The intermediate data are then cached at the workers and a list of distinct values for the UID column is pushed to the MongoDB wrapper instances, to form the bind join condition.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999900221824646}, "created": {"value": false, "score": 7.033348083496094e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 120, "offsetEnd": 125}, "context": "In terms of Apache Spark, a dataset corresponds to an RDD (Resilient Distributed Dataset -the basic programming unit of Spark). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": false, "score": 2.658367156982422e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 120, "offsetEnd": 125}, "context": "On the other hand, as described above, when processing a partition, each Spark executor finds and sends to an available Spark agent all tuples of the partition.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0023292899131774902}, "created": {"value": false, "score": 4.673004150390625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 120, "offsetEnd": 127}, "context": "Fig. 12. Execution times (in seconds) of Q4 queries joining the result of Q3 queries (1TB LeanXcale table joining 600GB MongoDB collection) with an MFR/Scala/Spark subquery against 240GB HDFS file.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": false, "score": 4.0411949157714844e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoCursor", "normalizedForm": "MongoCursor", "offsetStart": 120, "offsetEnd": 131}, "context": "To support parallel data retrieval, we further enhance the client library with JavaScript primitives that wrap standard MongoCursor objects (usually returned by a MongoDB JavaScript query) in Shard-edCursor objects, which are aware of the sharding of the underlying dataset. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0002295374870300293}, "created": {"value": false, "score": 0.07481008768081665}, "shared": {"value": false, "score": 2.6226043701171875e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0002295374870300293}, "created": {"value": false, "score": 0.07481008768081665}, "shared": {"value": false, "score": 2.6226043701171875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 121, "offsetEnd": 124}, "context": "The LeanXcale database has derived its OLAP query engine from Apache Calcite [8], a Java-based open-source framework for SQL query processing and optimization.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6484058499336243}, "created": {"value": false, "score": 0.00020927190780639648}, "shared": {"value": false, "score": 8.463859558105469e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache", "normalizedForm": "Apache", "offsetStart": 121, "offsetEnd": 127}, "context": "In another example, a more sophisticated data transformation logic (such as a chain of user-defined transformations over Apache Spark RDDs) needs to be applied to unstructured data before processing by means of relational operators [9].", "mentionContextAttributes": {"used": {"value": false, "score": 5.364418029785156e-05}, "created": {"value": false, "score": 0.00018161535263061523}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00023478269577026367}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CUSTOMER", "normalizedForm": "CUSTOMER", "offsetStart": 121, "offsetEnd": 129}, "context": "Query Q2 S evaluates just the parallel execution of the Experts MFR query on Spark, while Q2 SL involves a join with the CUSTOMER table from the LeanXcale data store: Fig. 10 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of MFR/Scala queries against Spark, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9895273447036743}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999274015426636}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 122, "offsetEnd": 127}, "context": "All the queries were run on a cluster of LeanXcale DQE instances, running the distributed wrappers for MongoDB, Hive, and Spark.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 2.777576446533203e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 122, "offsetEnd": 127}, "context": "aggregation pipelines), beyond the trivial SQL mappings; (b) parallel map/filter/reduce subqueries, done natively through Spark RDD transformations; (c) parallel joins and scalability.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04849100112915039}, "created": {"value": false, "score": 5.7220458984375e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 122, "offsetEnd": 127}, "context": "In particular, even in the context of LeanXcale DQE with 2 bind joins sophisticated subqueries expressed as JavaScript or Scala code, parallel join processing shows good speedup with increase of the parallelism level.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001138448715209961}, "created": {"value": false, "score": 7.867813110351562e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 122, "offsetEnd": 129}, "context": "Query Q2 M evaluates just the parallel execution of the BookOrders script in MongoDB, while Q2 ML involves a join between MongoDB and the CUSTOMER table from the LeanXcale data store: Fig. 9 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7139509320259094}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 123, "offsetEnd": 126}, "context": "Thus, tightly-coupled systems take advantage of massive parallelism by bringing in parallel shards from HDFS tables to the SQL database nodes and doing parallel joins.", "mentionContextAttributes": {"used": {"value": false, "score": 4.553794860839844e-05}, "created": {"value": false, "score": 0.00011217594146728516}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Cosmos", "normalizedForm": "Cosmos", "offsetStart": 123, "offsetEnd": 129}, "context": "SCOPE [12] is a declarative language from Microsoft designed to specify the processing of large sequential files stored in Cosmos, a distributed computing platform. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011134147644042969}, "created": {"value": false, "score": 0.031117737293243408}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00011134147644042969}, "created": {"value": false, "score": 0.031117737293243408}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 124, "offsetEnd": 129}, "context": "A discovery service is introduced through the special component Spark Agent Registry that keeps information about available Spark wrapper instances and dispatches them to the requesting Spark workers so that parallelism is fully exploited in moving data from a Spark RDD to the DQE.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005214512348175049}, "created": {"value": false, "score": 0.003361940383911133}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 124, "offsetEnd": 131}, "context": "Workflow managers dispatch the execution of a query/workflow plan to underlying data processing platforms, hence can access MongoDB through the platforms, e.g., Spark using the Spark MongoDB connector.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005359172821044922}, "created": {"value": false, "score": 2.8967857360839844e-05}, "shared": {"value": false, "score": 3.5762786865234375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 126, "offsetEnd": 129}, "context": "Each wrapper typically uses the client API of the corresponding data management cluster and implements the following DataLake API methods to be invoked by the query engine in order to provide parallel retrieval of shards (Fig. 3).", "mentionContextAttributes": {"used": {"value": false, "score": 0.031944215297698975}, "created": {"value": false, "score": 8.988380432128906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 126, "offsetEnd": 133}, "context": "Furthermore, we aim at processing this join in the most efficient way, i.e. in parallel, by allowing parallel handling of the MongoDB subquery and parallel retrieval of its result set.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001226663589477539}, "created": {"value": true, "score": 0.9474247694015503}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 127, "offsetEnd": 132}, "context": "All the three data stores and the query engine are evenly distributed across all the nodes, i.e. shards of each data store and Spark workers are collocated at each node.", "mentionContextAttributes": {"used": {"value": false, "score": 0.2777783274650574}, "created": {"value": false, "score": 5.3763389587402344e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 127, "offsetEnd": 133}, "context": "Tightly-coupled systems can perform parallel joins, but since they are focused only on the tight integration between RDBMS and Hadoop stores, cannot be extended to support NoSQL stores.", "mentionContextAttributes": {"used": {"value": false, "score": 8.45193862915039e-05}, "created": {"value": false, "score": 4.3272972106933594e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Python", "normalizedForm": "Python", "offsetStart": 127, "offsetEnd": 133}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 127, "offsetEnd": 134}, "context": "\u2022 Highly expressive queries: adopt he polyglot approach of the CloudMdsQL query language to allow data store native queries or scripts to be expressed as inline subqueries.", "mentionContextAttributes": {"used": {"value": false, "score": 2.7418136596679688e-05}, "created": {"value": false, "score": 0.005428016185760498}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 127, "offsetEnd": 135}, "context": "The query engine architecture is therefore extended to access in parallel shards of the external data store through the use of DataLake distributed wrappers that hide the complexity of the underlying data stores' query/scripting languages and encapsulate their interfaces under a common DataLake API to be interfaced by the query engine. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006234049797058105}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.172325134277344e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 128, "offsetEnd": 132}, "context": "In particular, even in the context of LeanXcale DQE with 2 bind joins sophisticated subqueries expressed as JavaScript or Scala code, parallel join processing shows good speedup with increase of the parallelism level.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001138448715209961}, "created": {"value": false, "score": 7.867813110351562e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 128, "offsetEnd": 133}, "context": "In another example, a more sophisticated data transformation logic (such as a chain of user-defined transformations over Apache Spark RDDs) needs to be applied to unstructured data before processing by means of relational operators [9].", "mentionContextAttributes": {"used": {"value": false, "score": 5.364418029785156e-05}, "created": {"value": false, "score": 0.00018161535263061523}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 128, "offsetEnd": 135}, "context": "Note that, as opposed to the behavior of the original find() method, a call to find-Sharded() does not immediately initiate the MongoDB subquery execution, but only memorizes the filter condition (the method argument), if any, in the returned Shard-edCursor object.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0481799840927124}, "created": {"value": false, "score": 3.409385681152344e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 129, "offsetEnd": 136}, "context": "The concept of parallel querying against a MongoDB cluster is built on the assumption that each DQE worker can access directly a MongoDB shard, bypassing the MongoDB router in order to sustain parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023823976516723633}, "created": {"value": false, "score": 0.0005996227264404297}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 130, "offsetEnd": 137}, "context": "To use the same mechanism for controlling the selectivity of the second join, the keywords for each book item in the Orders_Items MongoDB collection are generated in a way that a selectivity factor SF on the first join results in about the same SF on the second join.", "mentionContextAttributes": {"used": {"value": false, "score": 0.2269761562347412}, "created": {"value": false, "score": 4.887580871582031e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 131, "offsetEnd": 135}, "context": "In order to make the wrapper instances collect in parallel partitions of the resulting RDD, the master wrapper ships an additional code together with the user defined script, that makes each RDD partition push its data directly to the assigned by the registry wrapper instance.", "mentionContextAttributes": {"used": {"value": false, "score": 0.10720360279083252}, "created": {"value": false, "score": 3.1828880310058594e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 131, "offsetEnd": 138}, "context": "CloudMdsQL [23,26] with its MFR (map/filter/reduce) extensions [9] even allows data store native queries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.92605972290039e-05}, "created": {"value": false, "score": 1.537799835205078e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 131, "offsetEnd": 140}, "context": "Section 4 gives an overview of the query language with its polyglot capabilities and discusses the distributed architecture of the LeanXcale query engine. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008639693260192871}, "created": {"value": false, "score": 0.0015274882316589355}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 132, "offsetEnd": 137}, "context": "In particular, we want to stress on the full parallelism to access the underlying datasets, in our case, a MongoDB collection and a Spark RDD, in the context of expressive subqueries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00029140710830688477}, "created": {"value": true, "score": 0.852452278137207}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 132, "offsetEnd": 141}, "context": "The data itself are stored on a proprietary relational key-value store, KiVi, which allows for efficient horizontal partitioning of LeanXcale tables and indexes, based on the primary key or index key.", "mentionContextAttributes": {"used": {"value": false, "score": 0.4903682470321655}, "created": {"value": false, "score": 0.00030303001403808594}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 132, "offsetEnd": 142}, "context": "To preserve the expressivity of the underlying data stores' query/scripting languages, we use the polyglot approach provided by the CloudMdsQL query language, which also enables the use of bind joins [19] to optimize the execution of selective queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": false, "score": 0.0001417398452758789}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake API", "normalizedForm": "DataLake API", "offsetStart": 133, "offsetEnd": 145}, "context": "\u2022 Extensibility: allow for other parallel data stores to be added by implementing adapters through a flexible programming interface (DataLake API, see Section 5.2). ", "mentionContextAttributes": {"used": {"value": false, "score": 7.37905502319336e-05}, "created": {"value": false, "score": 0.0007222294807434082}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 7.37905502319336e-05}, "created": {"value": false, "score": 0.0007222294807434082}, "shared": {"value": false, "score": 1.1920928955078125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 135, "offsetEnd": 140}, "context": "For Spark result sets, this overhead is a bit higher, because of the additional serialization/deserialization that takes place between Spark executors and SparkAgent instances.", "mentionContextAttributes": {"used": {"value": false, "score": 0.034141361713409424}, "created": {"value": false, "score": 2.0742416381835938e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 135, "offsetEnd": 142}, "context": "Since MongoDB collections are used directly in the FROM clause as tables, the storage plugin translates relational operators to native MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.09908062219619751}, "created": {"value": false, "score": 1.1801719665527344e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 135, "offsetEnd": 142}, "context": "As an example, elaborated in our previous work [24], we addressed the scenario of joining a sharded document collection, residing in a MongoDB cluster, with a partitioned table from a distributed relational database or a distributed HDFS dataset.", "mentionContextAttributes": {"used": {"value": false, "score": 0.03199225664138794}, "created": {"value": true, "score": 0.7937899827957153}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 135, "offsetEnd": 144}, "context": "Fig. 12 shows the times for processing Q4 queries, involving 2 joins: with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.986201822757721}, "created": {"value": false, "score": 1.0967254638671875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 136, "offsetEnd": 141}, "context": "Spark SQL provides a DataFrame API that can map to relations arbitrary object collections and thus enables relational operations across Spark's RDDs and external data sources.", "mentionContextAttributes": {"used": {"value": false, "score": 8.463859558105469e-05}, "created": {"value": false, "score": 0.0007729530334472656}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop MapReduce", "normalizedForm": "Hadoop MapReduce", "offsetStart": 136, "offsetEnd": 152}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002870023250579834}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 137, "offsetEnd": 144}, "context": "Thus, Q4 is defined as follows: Using bind join, the query executes as follows: first, the join between CLICKS at HDFS and BookOrders at MongoDB takes place, as in Q3; then, after flattening O.keywords and identifying the list of distinct keywords, another bind join condition is pushed to the Experts subquery to Spark, as described in Section 5.1, to reduce the amount of data processed by Spark transformations.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6308996081352234}, "created": {"value": false, "score": 1.6689300537109375e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 138, "offsetEnd": 143}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 138, "offsetEnd": 143}, "context": "Similarly to the previous test case, the performance evaluation shows that the ability for applying bind join that cannot be handled with Spark SQL gives our approach a significant advantage for selective queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7948044538497925}, "created": {"value": false, "score": 0.00012242794036865234}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 138, "offsetEnd": 144}, "context": "The greatest advantage of these rules can be observed when Rule #2 is applicable, as it enables early filtering of the input to expensive REDUCE operators.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007333159446716309}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 138, "offsetEnd": 145}, "context": "For comparison with the state of the art, the large-scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CUSTOMER", "normalizedForm": "CUSTOMER", "offsetStart": 138, "offsetEnd": 146}, "context": "Query Q2 M evaluates just the parallel execution of the BookOrders script in MongoDB, while Q2 ML involves a join between MongoDB and the CUSTOMER table from the LeanXcale data store: Fig. 9 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.7139509320259094}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999274015426636}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 140, "offsetEnd": 147}, "context": "As our work fits in this category, we will briefly discuss some of the existing solutions, focusing on their capabilities to integrate with MongoDB as a representative example of a non-relational data store.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001659393310546875}, "created": {"value": true, "score": 0.9992098808288574}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 141, "offsetEnd": 148}, "context": "First, the wrapper verifies that the MongoDB balancer is not running in background, because otherwise it may be moving chunks of data across MongoDB shards at the same time the query is being executed, which may result in inconsistent reads. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.10765993595123291}, "created": {"value": false, "score": 1.3828277587890625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 142, "offsetEnd": 145}, "context": "Assuming that the distinct values of B.id are b1 \u2026 bn, the query to retrieve the right-hand side relation of the bind join uses the following SQL approach (or its equivalent according to the data store's query language), thus retrieving from A only the rows that match the join criteria:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9644237756729126}, "created": {"value": false, "score": 1.3113021850585938e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 142, "offsetEnd": 149}, "context": "These data management clusters can range from distributed raw data files, through parallel SQL databases, to sharded NoSQL databases (such as MongoDB, where queries can be expressed as JavaScript programs) and parallel data processing frameworks (such as Apache Spark, where data retrieval and/or transformation can be requested by means of Python or Scala scripting).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007843971252441406}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 142, "offsetEnd": 149}, "context": "Assuming that W1 is the master worker, it calls the listShards() method of its wrapper instance WR1 to query the MongoDB router for a list of MongoDB shards (database instances identified by host address and port), where partitions of the lineitem collection are stored.", "mentionContextAttributes": {"used": {"value": false, "score": 0.14902037382125854}, "created": {"value": false, "score": 1.633167266845703e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 142, "offsetEnd": 151}, "context": "At this point, the DQE is ready to involve the partitioned intermediate relation LINEITEM in the execution of a parallel join with the native LeanXcale partitioned table ORDERS.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0024389028549194336}, "created": {"value": false, "score": 0.0007367730140686035}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 144, "offsetEnd": 147}, "context": "Applications connect to one of the multiple DQE instances running, which exposes a typical JDBC interface to the applications, with support for SQL and transactions.", "mentionContextAttributes": {"used": {"value": false, "score": 0.015118300914764404}, "created": {"value": false, "score": 0.0001729130744934082}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 144, "offsetEnd": 147}, "context": "Similarly to the previous test case, the performance evaluation shows that the ability for applying bind join that cannot be handled with Spark SQL gives our approach a significant advantage for selective queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7948044538497925}, "created": {"value": false, "score": 0.00012242794036865234}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 145, "offsetEnd": 154}, "context": "Query Q2 S evaluates just the parallel execution of the Experts MFR query on Spark, while Q2 SL involves a join with the CUSTOMER table from the LeanXcale data store: Fig. 10 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of MFR/Scala queries against Spark, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9895273447036743}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 145, "offsetEnd": 155}, "context": "In this paper, we introduced a parallel polystore system that builds on top of LeanXcale's distributed query engine and processes queries in the CloudMdsQL query language. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.62396240234375e-05}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 146, "offsetEnd": 151}, "context": "Here, we specifically focus on parallel joins across a relational table, the result of a JavaScript subquery to MongoDB, and the result of an MFR/Scala subquery to Apache Spark, but the concept relies on an API that allows its generalization to other script engines and data stores as well.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0018170475959777832}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 146, "offsetEnd": 151}, "context": "For comparison with the state of the art, the large-scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 146, "offsetEnd": 153}, "context": "Let us consider the following modification Q1 ML of query Q1, which assumes that the LINEITEM table resides as a sharded document collection in a MongoDB cluster and the selection on it is expressed by means of the findSharded() JavaScript method, while ORDERS is still a LeanXcale table, the partitions of which are stored in the KV storage layer.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7317386269569397}, "created": {"value": false, "score": 2.5033950805664062e-06}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 148, "offsetEnd": 154}, "context": "To better illustrate the flow, let us consider another modification Q1 HL of query Q1, which assumes that the LINEITEM table is stored as file in a Hadoop cluster.", "mentionContextAttributes": {"used": {"value": false, "score": 0.07103210687637329}, "created": {"value": false, "score": 1.1444091796875e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 152, "offsetEnd": 157}, "context": "Fig. 12. Execution times (in seconds) of Q4 queries joining the result of Q3 queries (1TB LeanXcale table joining 600GB MongoDB collection) with an MFR/Scala/Spark subquery against 240GB HDFS file.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": false, "score": 4.0411949157714844e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripting", "normalizedForm": "scripting", "offsetStart": 152, "offsetEnd": 161}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 153, "offsetEnd": 156}, "context": "Teradata IntelliSphere [7] addresses the problem of accessing multiple data stores (called \"remote systems\") that may be heterogeneous, but must have an SQL-like interface.", "mentionContextAttributes": {"used": {"value": false, "score": 6.663799285888672e-05}, "created": {"value": false, "score": 6.711483001708984e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 153, "offsetEnd": 158}, "context": "As stated in Section 3, the major challenge of supporting Apache Spark as an underlying data management cluster is to enable parallel data movement from Spark workers to DataLake wrappers.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023478269577026367}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 154, "offsetEnd": 159}, "context": "Thus, even a distributed query engine cannot exploit parallelism in retrieving a Spark RDD, since only one worker will collect the entire RDD through the Spark driver, which is the limitation we want to overcome in this paper as an extended version of [24].", "mentionContextAttributes": {"used": {"value": false, "score": 0.00014734268188476562}, "created": {"value": false, "score": 0.027856826782226562}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 155, "offsetEnd": 165}, "context": "For Spark result sets, this overhead is a bit higher, because of the additional serialization/deserialization that takes place between Spark executors and SparkAgent instances.", "mentionContextAttributes": {"used": {"value": false, "score": 0.034141361713409424}, "created": {"value": false, "score": 2.0742416381835938e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 157, "offsetEnd": 164}, "context": "To access a MongoDB cluster, Presto uses a connector that allows the parallel retrieval of sharded collections, which is typically configured with a list of MongoDB servers.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0041727423667907715}, "created": {"value": false, "score": 6.330013275146484e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 158, "offsetEnd": 163}, "context": "Fig. 12. Execution times (in seconds) of Q4 queries joining the result of Q3 queries (1TB LeanXcale table joining 600GB MongoDB collection) with an MFR/Scala/Spark subquery against 240GB HDFS file.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": false, "score": 4.0411949157714844e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 158, "offsetEnd": 165}, "context": "The concept of parallel querying against a MongoDB cluster is built on the assumption that each DQE worker can access directly a MongoDB shard, bypassing the MongoDB router in order to sustain parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023823976516723633}, "created": {"value": false, "score": 0.0005996227264404297}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 159, "offsetEnd": 164}, "context": "In our work, we focused on parallel joins across a partitioned relational table, the result of a parallel JavaScript subquery to Mon-goDB, and the result of a Spark/Scala script against an HDFS file.", "mentionContextAttributes": {"used": {"value": false, "score": 0.3267180919647217}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 160, "offsetEnd": 167}, "context": "Thus, a composition of findSharded and map/flatMap (such as in the BookOrders example above) makes a user script expressive enough, so as to request a specific MongoDB dataset, retrieve the result set in parallel, and transform it in order to fit the named table signature and further be consumed by relational operators at the DQE level.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0015254616737365723}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 160, "offsetEnd": 168}, "context": "In the subsequent subsections, we give details on how the process of parallel retrieval from Mon-goDB and HDFS datasets is mapped to the methods of the generic DataLake API.", "mentionContextAttributes": {"used": {"value": false, "score": 0.011699140071868896}, "created": {"value": false, "score": 0.008828938007354736}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 161, "offsetEnd": 165}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 161, "offsetEnd": 166}, "context": "Workflow managers dispatch the execution of a query/workflow plan to underlying data processing platforms, hence can access MongoDB through the platforms, e.g., Spark using the Spark MongoDB connector.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005359172821044922}, "created": {"value": false, "score": 2.8967857360839844e-05}, "shared": {"value": false, "score": 3.5762786865234375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 161, "offsetEnd": 170}, "context": "By interfacing wrappers through the DataLake API, the DQE has the possibility to retrieve in parallel disjoint subsets of the result set, much like it does with LeanXcale tables.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0095023512840271}, "created": {"value": false, "score": 6.711483001708984e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 161, "offsetEnd": 173}, "context": "We also show that the same methods abstract well enough even the more sophisticated parallel data push model, necessary to support the parallel integration with Apache Spark, as introduced in Section 3.", "mentionContextAttributes": {"used": {"value": false, "score": 0.006913125514984131}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 162, "offsetEnd": 171}, "context": "Query Q2 M evaluates just the parallel execution of the BookOrders script in MongoDB, while Q2 ML involves a join between MongoDB and the CUSTOMER table from the LeanXcale data store: Fig. 9 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7139509320259094}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 163, "offsetEnd": 168}, "context": "Since this necessitates that Spark workers find and connect to DataLake wrapper instances, it results in a different, more complex architecture of the distributed Spark wrapper.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006530880928039551}, "created": {"value": false, "score": 6.139278411865234e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 163, "offsetEnd": 169}, "context": "Fig. 6 gives a high-level illustration of the processing of the query Q1 SL , assuming a simple MFR subquery that reads the LINEITEM table as a text file from the Hadoop cluster, but this time through Spark.", "mentionContextAttributes": {"used": {"value": false, "score": 0.3648107647895813}, "created": {"value": false, "score": 1.990795135498047e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9755045175552368}, "created": {"value": false, "score": 0.10342848300933838}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 163, "offsetEnd": 170}, "context": "The SQL table expression T1 is defined by an SQL subquery, while T2 is a native expression (identified by the special bracket symbols {* *}) expressed as a native MongoDB API call or JavaScript code. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05572444200515747}, "created": {"value": false, "score": 4.172325134277344e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 163, "offsetEnd": 170}, "context": "To support parallel data retrieval, we further enhance the client library with JavaScript primitives that wrap standard MongoCursor objects (usually returned by a MongoDB JavaScript query) in Shard-edCursor objects, which are aware of the sharding of the underlying dataset. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0002295374870300293}, "created": {"value": false, "score": 0.07481008768081665}, "shared": {"value": false, "score": 2.6226043701171875e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SparkAgent", "normalizedForm": "SparkAgent", "offsetStart": 163, "offsetEnd": 173}, "context": "serialize is another function that serializes each entry of the RDD partition to a byte array in a format that SparkAgent can interpret, which is then sent to the SparkAgent through the socket.", "mentionContextAttributes": {"used": {"value": false, "score": 0.002984285354614258}, "created": {"value": false, "score": 3.266334533691406e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.41534423828125}, "created": {"value": false, "score": 0.00011992454528808594}, "shared": {"value": false, "score": 1.9073486328125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 164, "offsetEnd": 176}, "context": "Here, we specifically focus on parallel joins across a relational table, the result of a JavaScript subquery to MongoDB, and the result of an MFR/Scala subquery to Apache Spark, but the concept relies on an API that allows its generalization to other script engines and data stores as well. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0018170475959777832}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 165, "offsetEnd": 168}, "context": "CloudMdsQL [23,26] with its MFR (map/filter/reduce) extensions [9] even allows data store native queries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration queries.", "mentionContextAttributes": {"used": {"value": false, "score": 6.92605972290039e-05}, "created": {"value": false, "score": 1.537799835205078e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 165, "offsetEnd": 170}, "context": "In our work, we focused on parallel joins across a partitioned relational table, the result of a parallel JavaScript subquery to Mon-goDB, and the result of a Spark/Scala script against an HDFS file.", "mentionContextAttributes": {"used": {"value": false, "score": 0.3267180919647217}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 167, "offsetEnd": 173}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "In order to make the wrapper instances collect in parallel partitions of the resulting RDD, the master wrapper ships an additional code together with the user defined script, that makes each RDD partition push its data directly to the assigned by the registry wrapper instance. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.10720360279083252}, "created": {"value": false, "score": 3.1828880310058594e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 168, "offsetEnd": 178}, "context": "To enable ad-hoc querying of an arbitrary data set, using its scripting mechanism, and then joining the retrieved result set at DQE level, DQE processes queries in the CloudMdsQL query language, where scripts are wrapped as native subqueries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": false, "score": 8.654594421386719e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.10021114349365234}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "references": [{"label": "[26]", "normalizedForm": "[26]", "refKey": 26}, {"label": "[26]", "normalizedForm": "[26]", "refKey": 26}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 169, "offsetEnd": 172}, "context": "In the subsequent subsections, we give details on how the process of parallel retrieval from Mon-goDB and HDFS datasets is mapped to the methods of the generic DataLake API.", "mentionContextAttributes": {"used": {"value": false, "score": 0.011699140071868896}, "created": {"value": false, "score": 0.008828938007354736}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 169, "offsetEnd": 174}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 170, "offsetEnd": 174}, "context": "SQL-like query or vertex-centric graphic abstraction; then, the specification is transformed into an internal representation in the form of a data-flow DAG; and finally, code is generated to execute the workflow against the target platform.", "mentionContextAttributes": {"used": {"value": false, "score": 0.03070157766342163}, "created": {"value": false, "score": 0.00016021728515625}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 170, "offsetEnd": 175}, "context": "Second, in order to do this, the query engine must be able to retrieve in parallel the partitions from the underlying data stores and data processing frameworks (such as Spark). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0017824769020080566}, "created": {"value": false, "score": 0.00012814998626708984}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 170, "offsetEnd": 178}, "context": "As stated in Section 3, the major challenge of supporting Apache Spark as an underlying data management cluster is to enable parallel data movement from Spark workers to DataLake wrappers.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023478269577026367}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 171, "offsetEnd": 174}, "context": "The SQL table expression T1 is defined by an SQL subquery, while T2 is a native expression (identified by the special bracket symbols {* *}) expressed as a native MongoDB API call or JavaScript code.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05572444200515747}, "created": {"value": false, "score": 4.172325134277344e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 171, "offsetEnd": 177}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "In our work, we focused on parallel joins across a partitioned relational table, the result of a parallel JavaScript subquery to Mon-goDB, and the result of a Spark/Scala script against an HDFS file.", "mentionContextAttributes": {"used": {"value": false, "score": 0.3267180919647217}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 172, "offsetEnd": 179}, "context": "For comparison with the state of the art, the large-scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 174, "offsetEnd": 181}, "context": "The definition of the named table is hence slightly modified, to allow for the bind join to apply early filtering to reduce significantly the amount of data processed by the MongoDB JavaScript subquery: The query executes by first applying the filter and retrieving intermediate data from the CLICKS table, where a full scan takes place. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.07281118631362915}, "created": {"value": false, "score": 2.0623207092285156e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 176, "offsetEnd": 183}, "context": "The way to do the bind join counterpart for native queries is through the use of a JOINED ON clause in the named table signature, like in the named table A below, defined as a MongoDB script.", "mentionContextAttributes": {"used": {"value": false, "score": 0.055190205574035645}, "created": {"value": false, "score": 3.135204315185547e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 176, "offsetEnd": 183}, "context": "LeanXcale DQE is designed to integrate with arbitrary data management clusters, where data resides in its natural format and can be retrieved (in parallel) by running specific scripts or declarative queries.", "mentionContextAttributes": {"used": {"value": false, "score": 5.221366882324219e-05}, "created": {"value": false, "score": 0.2625940442085266}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 176, "offsetEnd": 183}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": false, "score": 9.369850158691406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 176, "offsetEnd": 185}, "context": "JEN and LeanXcale are applying semi-joins as an optimization technique -JEN with its efficient zigzag join that exchanges bloom filters between the HDFS and RDBMS datasets and LeanXcale through bind joins.", "mentionContextAttributes": {"used": {"value": false, "score": 0.008451223373413086}, "created": {"value": false, "score": 4.76837158203125e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 177, "offsetEnd": 180}, "context": "Spark SQL [6] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022155046463012695}, "created": {"value": false, "score": 0.01336449384689331}, "shared": {"value": false, "score": 2.5033950805664062e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 177, "offsetEnd": 181}, "context": "We address this problem by introducing an architecture, where each RDD partition (more precisely, the Spark worker that processes the partition) is instructed through generated code to find and connect to a query engine worker and to push the partition data.", "mentionContextAttributes": {"used": {"value": false, "score": 8.428096771240234e-05}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 177, "offsetEnd": 182}, "context": "Workflow managers dispatch the execution of a query/workflow plan to underlying data processing platforms, hence can access MongoDB through the platforms, e.g., Spark using the Spark MongoDB connector.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005359172821044922}, "created": {"value": false, "score": 2.8967857360839844e-05}, "shared": {"value": false, "score": 3.5762786865234375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 179, "offsetEnd": 184}, "context": "To enable remote submission of the generated Scala script for Spark by the master wrapper, our setup relies on Apache Livy2 , which provides a REST service for easy submission of Spark jobs and Spark context management.", "mentionContextAttributes": {"used": {"value": false, "score": 0.13044780492782593}, "created": {"value": false, "score": 0.08340555429458618}, "shared": {"value": false, "score": 1.4781951904296875e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 179, "offsetEnd": 186}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 180, "offsetEnd": 184}, "context": "To schedule parallel retrieval of the LINEITEM table, the DQE redirects the subquery to the HDFS wrapper, preliminarily configured to associate the @hdfs alias with the URI of the Hive metastore, which specifies how the file is parsed and split. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.1626644730567932}, "created": {"value": false, "score": 1.7881393432617188e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 183, "offsetEnd": 189}, "context": "As per the MFR rewrite rules, this would take place immediately after the FLAT_MAP operator, significantly reducing at early stage the amount of data to be processed by the expensive REDUCE operators that follow. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9158031940460205}, "created": {"value": false, "score": 4.029273986816406e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 183, "offsetEnd": 190}, "context": "The client library is therefore extended with the following document collection methods that return ShardedCursor and provide the targeted operators (find, map, and flat map) in user scripts.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0025481581687927246}, "created": {"value": false, "score": 0.00027638673782348633}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 183, "offsetEnd": 190}, "context": "Workflow managers dispatch the execution of a query/workflow plan to underlying data processing platforms, hence can access MongoDB through the platforms, e.g., Spark using the Spark MongoDB connector.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005359172821044922}, "created": {"value": false, "score": 2.8967857360839844e-05}, "shared": {"value": false, "score": 3.5762786865234375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 183, "offsetEnd": 190}, "context": "To better illustrate the necessity of enabling user-defined scripts to MongoDB as subqueries, rather than defining SQL mappings to document collections, let us consider the following MongoDB collection orders that has a highly non-relational structure:", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022834539413452148}, "created": {"value": false, "score": 0.0009965300559997559}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 184, "offsetEnd": 190}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "The way to do the bind join counterpart for native queries is through the use of a JOINED ON clause in the named table signature, like in the named table A below, defined as a MongoDB script.", "mentionContextAttributes": {"used": {"value": false, "score": 0.055190205574035645}, "created": {"value": false, "score": 3.135204315185547e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 185, "offsetEnd": 188}, "context": "For example, the following simple CloudMdsQL query contains two subqueries, defined by the named table expressions T1 and T2, and addressed respectively against the data stores rdb (an SQL database) and mongo (a MongoDB database):", "mentionContextAttributes": {"used": {"value": false, "score": 0.0022200942039489746}, "created": {"value": false, "score": 3.7550926208496094e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 186, "offsetEnd": 190}, "context": "All the generated datasets were: loaded in LeanXcale as relational tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables and through Spark by means of scans expressed as simple MFR/Scala statements. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9994305968284607}, "created": {"value": false, "score": 2.86102294921875e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": false, "score": 0.0001316070556640625}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 186, "offsetEnd": 191}, "context": "A discovery service is introduced through the special component Spark Agent Registry that keeps information about available Spark wrapper instances and dispatches them to the requesting Spark workers so that parallelism is fully exploited in moving data from a Spark RDD to the DQE.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005214512348175049}, "created": {"value": false, "score": 0.003361940383911133}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 186, "offsetEnd": 193}, "context": "This delayed iteration approach allows the DQE to internally manipulate the cursor object before the actual iteration takes place, e.g., to redirect the subquery execution to a specific MongoDB shard.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0012317299842834473}, "created": {"value": false, "score": 0.0003085136413574219}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 186, "offsetEnd": 193}, "context": "Without bind join, Spark SQL shows a slight advantage compared to LeanXcale DQE, which is explainable by the overhead of the JavaScript interpreting that takes place at DQE wrappers for MongoDB.", "mentionContextAttributes": {"used": {"value": false, "score": 0.004089474678039551}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 189, "offsetEnd": 192}, "context": "CloudMdsQL also provides a CREATE NAMED EXPRESSION command that allows an expression to be defined and stored in a global catalog in order to be referenced in several queries, similarly to SQL views and stored procedures/functions.", "mentionContextAttributes": {"used": {"value": false, "score": 4.6133995056152344e-05}, "created": {"value": false, "score": 0.00011742115020751953}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 191, "offsetEnd": 194}, "context": "Its extended relational model and the imperative-declarative hybrid language MyriaL span well all the underlying data models, where rewrite rules apply to transform expressions into specific API calls, queries, etc. for each of the data stores.", "mentionContextAttributes": {"used": {"value": false, "score": 8.594989776611328e-05}, "created": {"value": false, "score": 0.0023530125617980957}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 192, "offsetEnd": 199}, "context": "As for workflow managers, although they can orchestrate efficiently relational operators across platforms, they do not provide query execution themselves; for example, a parallel join between MongoDB and Spark would be dispatched for execution at Spark by both Musketeer and RHEEM, so we would consider this comparison as equivalent to comparing with Spark.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010941028594970703}, "created": {"value": false, "score": 2.7418136596679688e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 192, "offsetEnd": 200}, "context": "The distributed HDFS wrapper is designed to access in parallel tables stored as HDFS files, thus providing the typical functionality of a tightly-coupled polystore, but through the use of the DataLake API.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001202225685119629}, "created": {"value": false, "score": 0.0014584064483642578}, "shared": {"value": false, "score": 1.0848045349121094e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 193, "offsetEnd": 202}, "context": "Among hybrid systems, although Presto and Drill support well parallel query processing across SQL and NoSQL stores, the only one that provides parallel support of distributed data platforms is Spark SQL, as it uses Spark natively. ", "mentionContextAttributes": {"used": {"value": false, "score": 7.045269012451172e-05}, "created": {"value": false, "score": 0.00028401613235473633}, "shared": {"value": false, "score": 3.2186508178710938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9997720122337341}, "created": {"value": true, "score": 0.5916968584060669}, "shared": {"value": false, "score": 3.2186508178710938e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 194, "offsetEnd": 198}, "context": "The SQL table expression T1 is defined by an SQL subquery, while T2 is a native expression (identified by the special bracket symbols {* *}) expressed as a native MongoDB API call or JavaScript code.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05572444200515747}, "created": {"value": false, "score": 4.172325134277344e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 194, "offsetEnd": 199}, "context": "To enable remote submission of the generated Scala script for Spark by the master wrapper, our setup relies on Apache Livy2 , which provides a REST service for easy submission of Spark jobs and Spark context management.", "mentionContextAttributes": {"used": {"value": false, "score": 0.13044780492782593}, "created": {"value": false, "score": 0.08340555429458618}, "shared": {"value": false, "score": 1.4781951904296875e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "programs", "normalizedForm": "programs", "offsetStart": 196, "offsetEnd": 204}, "context": "These data management clusters can range from distributed raw data files, through parallel SQL databases, to sharded NoSQL databases (such as MongoDB, where queries can be expressed as JavaScript programs) and parallel data processing frameworks (such as Apache Spark, where data retrieval and/or transformation can be requested by means of Python or Scala scripting). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007843971252441406}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0007843971252441406}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 197, "offsetEnd": 204}, "context": "This, however, forces the DQE to define certain constraints for parallel processing of document collection subqueries, in order to guarantee consistent results, which is normally guaranteed by the MongoDB router. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0017469525337219238}, "created": {"value": false, "score": 0.000277101993560791}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 198, "offsetEnd": 204}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "A(id int, x int JOINED ON id REFERENCING OUTER AS b_keys)@mongo = {* return db.A.find( {id: {$in: b_keys}} ); *} Thus, when A.id participates in an equi-join, the values b1,\u2026,bn are provided to the script code through the iterator/list object b_keys (in this context, we refer to the table B as the \"outer\" table, and b_keys as the outer keys).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": false, "score": 1.9073486328125e-06}, "shared": {"value": false, "score": 2.0265579223632812e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 201, "offsetEnd": 204}, "context": "With LeanXcale, once the named tables (subqueries to data stores) are defined by the system developer or administrator, they can be easily used and involved in joins (including bind joins) through the SQL interface.", "mentionContextAttributes": {"used": {"value": false, "score": 0.000822603702545166}, "created": {"value": false, "score": 5.221366882324219e-05}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 201, "offsetEnd": 204}, "context": "The distributed HDFS wrapper is designed to access in parallel tables stored as HDFS files, thus providing the typical functionality of a tightly-coupled polystore, but through the use of the DataLake API.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001202225685119629}, "created": {"value": false, "score": 0.0014584064483642578}, "shared": {"value": false, "score": 1.0848045349121094e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 201, "offsetEnd": 206}, "context": "Fig. 6 gives a high-level illustration of the processing of the query Q1 SL , assuming a simple MFR subquery that reads the LINEITEM table as a text file from the Hadoop cluster, but this time through Spark.", "mentionContextAttributes": {"used": {"value": false, "score": 0.3648107647895813}, "created": {"value": false, "score": 1.990795135498047e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 201, "offsetEnd": 208}, "context": "To enable ad-hoc querying of an arbitrary data set, using its scripting mechanism, and then joining the retrieved result set at DQE level, DQE processes queries in the CloudMdsQL query language, where scripts are wrapped as native subqueries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": false, "score": 8.654594421386719e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": true, "score": 0.9998281002044678}, "shared": {"value": false, "score": 7.152557373046875e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 204, "offsetEnd": 209}, "context": "As for workflow managers, although they can orchestrate efficiently relational operators across platforms, they do not provide query execution themselves; for example, a parallel join between MongoDB and Spark would be dispatched for execution at Spark by both Musketeer and RHEEM, so we would consider this comparison as equivalent to comparing with Spark.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010941028594970703}, "created": {"value": false, "score": 2.7418136596679688e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 204, "offsetEnd": 209}, "context": "It parses and interprets a subquery written in MFR notation; then, uses an MFR planner to find optimization opportunities; and finally translates the resulting sequence of MFR operations to a sequence of Spark methods to be executed, expressed as Scala (in our focus for this paper) or Python script.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0921933650970459}, "created": {"value": false, "score": 0.0001443624496459961}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 205, "offsetEnd": 209}, "context": "A(id int, x int JOINED ON id REFERENCING OUTER AS b_keys)@mongo = {* return db.A.find( {id: {$in: b_keys}} ); *} Thus, when A.id participates in an equi-join, the values b1,\u2026,bn are provided to the script code through the iterator/list object b_keys (in this context, we refer to the table B as the \"outer\" table, and b_keys as the outer keys).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": false, "score": 1.9073486328125e-06}, "shared": {"value": false, "score": 2.0265579223632812e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 207, "offsetEnd": 210}, "context": "Here, we specifically focus on parallel joins across a relational table, the result of a JavaScript subquery to MongoDB, and the result of an MFR/Scala subquery to Apache Spark, but the concept relies on an API that allows its generalization to other script engines and data stores as well.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0018170475959777832}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 212, "offsetEnd": 219}, "context": "For example, the following simple CloudMdsQL query contains two subqueries, defined by the named table expressions T1 and T2, and addressed respectively against the data stores rdb (an SQL database) and mongo (a MongoDB database):", "mentionContextAttributes": {"used": {"value": false, "score": 0.0022200942039489746}, "created": {"value": false, "score": 3.7550926208496094e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 213, "offsetEnd": 218}, "context": "All the generated datasets were: loaded in LeanXcale as relational tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables and through Spark by means of scans expressed as simple MFR/Scala statements. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9994305968284607}, "created": {"value": false, "score": 2.86102294921875e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 214, "offsetEnd": 221}, "context": "The choice of Spark SQL for a state-of-the-art representative to compare our work with is justified by the fact that it supports most of the features our approach targets and hereby evaluates, namely: (a) parallel MongoDB subqueries through the use of the MongoDB connector that also supports native Mon-goDB operators (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001291513442993164}, "created": {"value": false, "score": 0.045391619205474854}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 215, "offsetEnd": 220}, "context": "Among hybrid systems, although Presto and Drill support well parallel query processing across SQL and NoSQL stores, the only one that provides parallel support of distributed data platforms is Spark SQL, as it uses Spark natively. ", "mentionContextAttributes": {"used": {"value": false, "score": 7.045269012451172e-05}, "created": {"value": false, "score": 0.00028401613235473633}, "shared": {"value": false, "score": 3.2186508178710938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "findSharded", "normalizedForm": "findSharded", "offsetStart": 215, "offsetEnd": 226}, "language": {"rawForm": "JavaScript", "normalizedForm": "JavaScript"}, "context": "Let us consider the following modification Q1 ML of query Q1, which assumes that the LINEITEM table resides as a sharded document collection in a MongoDB cluster and the selection on it is expressed by means of the findSharded() JavaScript method, while ORDERS is still a LeanXcale table, the partitions of which are stored in the KV storage layer.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7317386269569397}, "created": {"value": false, "score": 2.5033950805664062e-06}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7317386269569397}, "created": {"value": false, "score": 4.076957702636719e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 216, "offsetEnd": 222}, "context": "Rule #2: REDUCE(<transformation>).FILTER(<predicate>) is equivalent to FILTER(<predicate>).REDUCE(<transformation>), if predicate condition is a function only of the KEY, because thus, applying the FILTER before the REDUCE will preserve the values associated to those keys that satisfy the filter condition as they would be if the FILTER was applied after the REDUCE.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9831936359405518}, "created": {"value": false, "score": 2.9802322387695312e-06}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 217, "offsetEnd": 223}, "context": "MFR rewrites can be combined with bind join in the sense that when a bind join condition is pushed down the MFR subquery, it will be applied as early as possible, in many cases reducing significantly the work done by REDUCE operators on the way.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013256072998046875}, "created": {"value": false, "score": 5.507469177246094e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 218, "offsetEnd": 222}, "context": "Even if the MongoDB data has to undergo transformations, expressed through user-defined JavaScript functions, this can still be handled in parallel by making each worker initiate the execution of the custom JavaScript code against the MongoDB shard assigned to it and collect its partition of the intermediate data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.008358001708984375}, "created": {"value": false, "score": 0.00038951635360717773}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "RACO", "normalizedForm": "RACO", "offsetStart": 226, "offsetEnd": 230}, "publisher": {"rawForm": "Myria", "normalizedForm": "Myria", "offsetStart": 190, "offsetEnd": 195}, "context": "Non-relational systems, such as MongoDB, are supported by defining relational semantics for their operations and adding rules to translate them properly into the relational algebra, used by Myria's relational algebra compiler RACO.", "mentionContextAttributes": {"used": {"value": false, "score": 6.103515625e-05}, "created": {"value": false, "score": 0.0007066726684570312}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 6.103515625e-05}, "created": {"value": false, "score": 0.0007066726684570312}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "references": [{"label": "[5]", "normalizedForm": "[5]", "refKey": 5, "offsetStart": 17168, "offsetEnd": 17171}, {"label": "[5]", "normalizedForm": "[5]", "refKey": 5, "offsetStart": 17168, "offsetEnd": 17171}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 229, "offsetEnd": 238}, "context": "Although these systems enable parallel integration with data clusters (like MongoDB), none of them supports the combination of massive parallelism with native queries and the optimization of bind joins, which is addressed by the LeanXcale distributed query engine. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.6133995056152344e-05}, "created": {"value": false, "score": 0.0024118423461914062}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 240, "offsetEnd": 244}, "context": "Spark SQL [6] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022155046463012695}, "created": {"value": false, "score": 0.01336449384689331}, "shared": {"value": false, "score": 2.5033950805664062e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 242, "offsetEnd": 247}, "context": "To achieve this, the query engine creates a session at the Spark driver, then translates the MFR subquery to code (in Scala or Python for Spark), delegates this code to Spark for execution, and collects the intermediate data through the same Spark driver session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 9.882450103759766e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 245, "offsetEnd": 248}, "context": "And to enable the parallel query processing, we incorporated the polyglot approach within the LeanXcale1 Distributed Query Engine (DQE), which provides a query engine with intra-query and intra-operator parallelism that operates over a standard SQL interface.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0017653703689575195}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 247, "offsetEnd": 252}, "context": "It parses and interprets a subquery written in MFR notation; then, uses an MFR planner to find optimization opportunities; and finally translates the resulting sequence of MFR operations to a sequence of Spark methods to be executed, expressed as Scala (in our focus for this paper) or Python script. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0921933650970459}, "created": {"value": false, "score": 0.0001443624496459961}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 247, "offsetEnd": 252}, "context": "As for workflow managers, although they can orchestrate efficiently relational operators across platforms, they do not provide query execution themselves; for example, a parallel join between MongoDB and Spark would be dispatched for execution at Spark by both Musketeer and RHEEM, so we would consider this comparison as equivalent to comparing with Spark.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010941028594970703}, "created": {"value": false, "score": 2.7418136596679688e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script engines", "normalizedForm": "script engines", "offsetStart": 251, "offsetEnd": 265}, "context": "Here, we specifically focus on parallel joins across a relational table, the result of a JavaScript subquery to MongoDB, and the result of an MFR/Scala subquery to Apache Spark, but the concept relies on an API that allows its generalization to other script engines and data stores as well. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0018170475959777832}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0018170475959777832}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 1.0728836059570312e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "code", "normalizedForm": "code", "offsetStart": 253, "offsetEnd": 257}, "context": "At this moment, the execution of the prepared Spark job gets initiated by calling through the same Livy session the following foreachPartition action function that makes each partition connect to an available wrapper instance and send its data: In this code, connectSparkAgent is a function that the master wrapper preliminarily generates and defines in the Livy session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.02586996555328369}, "created": {"value": false, "score": 1.4066696166992188e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 2.5033950805664062e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 255, "offsetEnd": 267}, "context": "These data management clusters can range from distributed raw data files, through parallel SQL databases, to sharded NoSQL databases (such as MongoDB, where queries can be expressed as JavaScript programs) and parallel data processing frameworks (such as Apache Spark, where data retrieval and/or transformation can be requested by means of Python or Scala scripting). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007843971252441406}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.019170165061950684}, "created": {"value": true, "score": 0.779440701007843}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 256, "offsetEnd": 263}, "context": "The choice of Spark SQL for a state-of-the-art representative to compare our work with is justified by the fact that it supports most of the features our approach targets and hereby evaluates, namely: (a) parallel MongoDB subqueries through the use of the MongoDB connector that also supports native Mon-goDB operators (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001291513442993164}, "created": {"value": false, "score": 0.045391619205474854}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "connectSparkAgent", "normalizedForm": "connectSparkAgent", "offsetStart": 259, "offsetEnd": 276}, "context": "At this moment, the execution of the prepared Spark job gets initiated by calling through the same Livy session the following foreachPartition action function that makes each partition connect to an available wrapper instance and send its data: In this code, connectSparkAgent is a function that the master wrapper preliminarily generates and defines in the Livy session. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.02586996555328369}, "created": {"value": false, "score": 1.4066696166992188e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.02586996555328369}, "created": {"value": false, "score": 1.4066696166992188e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SQL", "normalizedForm": "SQL", "offsetStart": 261, "offsetEnd": 264}, "context": "The system applies the principles of Hybrid Transactional and Analytical Processing (HTAP) and addresses the hard problem of scaling out transactions in mixed operational and analytical workloads over big data, possibly coming from different data stores (HDFS, SQL, NoSQL, etc.).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003935694694519043}, "created": {"value": false, "score": 0.008056879043579102}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9934203028678894}, "shared": {"value": false, "score": 0.01025998592376709}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 261, "offsetEnd": 266}, "context": "A discovery service is introduced through the special component Spark Agent Registry that keeps information about available Spark wrapper instances and dispatches them to the requesting Spark workers so that parallelism is fully exploited in moving data from a Spark RDD to the DQE.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005214512348175049}, "created": {"value": false, "score": 0.003361940383911133}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 261, "offsetEnd": 266}, "context": "All the generated datasets were: loaded in LeanXcale as relational tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables and through Spark by means of scans expressed as simple MFR/Scala statements.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9994305968284607}, "created": {"value": false, "score": 2.86102294921875e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Musketeer", "normalizedForm": "Musketeer", "offsetStart": 261, "offsetEnd": 270}, "context": "As for workflow managers, although they can orchestrate efficiently relational operators across platforms, they do not provide query execution themselves; for example, a parallel join between MongoDB and Spark would be dispatched for execution at Spark by both Musketeer and RHEEM, so we would consider this comparison as equivalent to comparing with Spark.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010941028594970703}, "created": {"value": false, "score": 2.7418136596679688e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0010941028594970703}, "created": {"value": false, "score": 2.7418136596679688e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 272, "offsetEnd": 281}, "context": "Let us consider the following modification Q1 ML of query Q1, which assumes that the LINEITEM table resides as a sharded document collection in a MongoDB cluster and the selection on it is expressed by means of the findSharded() JavaScript method, while ORDERS is still a LeanXcale table, the partitions of which are stored in the KV storage layer.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7317386269569397}, "created": {"value": false, "score": 2.5033950805664062e-06}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Python", "normalizedForm": "Python", "offsetStart": 286, "offsetEnd": 292}, "context": "It parses and interprets a subquery written in MFR notation; then, uses an MFR planner to find optimization opportunities; and finally translates the resulting sequence of MFR operations to a sequence of Spark methods to be executed, expressed as Scala (in our focus for this paper) or Python script.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0921933650970459}, "created": {"value": false, "score": 0.0001443624496459961}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 287, "offsetEnd": 295}, "context": "The query engine architecture is therefore extended to access in parallel shards of the external data store through the use of DataLake distributed wrappers that hide the complexity of the underlying data stores' query/scripting languages and encapsulate their interfaces under a common DataLake API to be interfaced by the query engine.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006234049797058105}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.172325134277344e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.021330595016479492}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 288, "offsetEnd": 293}, "context": "Query Q2 S evaluates just the parallel execution of the Experts MFR query on Spark, while Q2 SL involves a join with the CUSTOMER table from the LeanXcale data store: Fig. 10 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of MFR/Scala queries against Spark, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9895273447036743}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 293, "offsetEnd": 299}, "language": {"rawForm": "Scala", "normalizedForm": "Scala"}, "context": "It parses and interprets a subquery written in MFR notation; then, uses an MFR planner to find optimization opportunities; and finally translates the resulting sequence of MFR operations to a sequence of Spark methods to be executed, expressed as Scala (in our focus for this paper) or Python script. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0921933650970459}, "created": {"value": false, "score": 0.0001443624496459961}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9191091656684875}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "API", "normalizedForm": "API", "offsetStart": 296, "offsetEnd": 299}, "context": "The query engine architecture is therefore extended to access in parallel shards of the external data store through the use of DataLake distributed wrappers that hide the complexity of the underlying data stores' query/scripting languages and encapsulate their interfaces under a common DataLake API to be interfaced by the query engine.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006234049797058105}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.172325134277344e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.05537843704223633}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 309, "offsetEnd": 314}, "context": "Thus, RHEEM can integrate data from different data stores (hence act as a polystore) by assigning different operators from the query plan to different engines, e.g., perform selections on base tables and associated joins at the RDBMS to exploit indexes, then ship intermediate data and perform other joins at Spark to exploit parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00041991472244262695}, "created": {"value": false, "score": 2.7894973754882812e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 310, "offsetEnd": 315}, "context": "Query Q2 S evaluates just the parallel execution of the Experts MFR query on Spark, while Q2 SL involves a join with the CUSTOMER table from the LeanXcale data store: Fig. 10 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of MFR/Scala queries against Spark, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9895273447036743}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 314, "offsetEnd": 319}, "context": "Thus, Q4 is defined as follows: Using bind join, the query executes as follows: first, the join between CLICKS at HDFS and BookOrders at MongoDB takes place, as in Q3; then, after flattening O.keywords and identifying the list of distinct keywords, another bind join condition is pushed to the Experts subquery to Spark, as described in Section 5.1, to reduce the amount of data processed by Spark transformations.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6308996081352234}, "created": {"value": false, "score": 1.6689300537109375e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Python", "normalizedForm": "Python", "offsetStart": 341, "offsetEnd": 347}, "context": "These data management clusters can range from distributed raw data files, through parallel SQL databases, to sharded NoSQL databases (such as MongoDB, where queries can be expressed as JavaScript programs) and parallel data processing frameworks (such as Apache Spark, where data retrieval and/or transformation can be requested by means of Python or Scala scripting). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007843971252441406}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.20863866806030273}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 346, "offsetEnd": 355}, "context": "Query Q2 S evaluates just the parallel execution of the Experts MFR query on Spark, while Q2 SL involves a join with the CUSTOMER table from the LeanXcale data store: Fig. 10 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of MFR/Scala queries against Spark, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9895273447036743}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 351, "offsetEnd": 356}, "context": "As for workflow managers, although they can orchestrate efficiently relational operators across platforms, they do not provide query execution themselves; for example, a parallel join between MongoDB and Spark would be dispatched for execution at Spark by both Musketeer and RHEEM, so we would consider this comparison as equivalent to comparing with Spark. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010941028594970703}, "created": {"value": false, "score": 2.7418136596679688e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 351, "offsetEnd": 356}, "context": "These data management clusters can range from distributed raw data files, through parallel SQL databases, to sharded NoSQL databases (such as MongoDB, where queries can be expressed as JavaScript programs) and parallel data processing frameworks (such as Apache Spark, where data retrieval and/or transformation can be requested by means of Python or Scala scripting). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007843971252441406}, "created": {"value": false, "score": 0.0032498836517333984}, "shared": {"value": false, "score": 4.410743713378906e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999206066131592}, "created": {"value": true, "score": 0.9993941783905029}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Livy", "normalizedForm": "Livy", "offsetStart": 358, "offsetEnd": 362}, "context": "At this moment, the execution of the prepared Spark job gets initiated by calling through the same Livy session the following foreachPartition action function that makes each partition connect to an available wrapper instance and send its data: In this code, connectSparkAgent is a function that the master wrapper preliminarily generates and defines in the Livy session.", "mentionContextAttributes": {"used": {"value": false, "score": 0.02586996555328369}, "created": {"value": false, "score": 1.4066696166992188e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9127829670906067}, "created": {"value": false, "score": 0.010139226913452148}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "REDUCE", "normalizedForm": "REDUCE", "offsetStart": 360, "offsetEnd": 366}, "context": "Rule #2: REDUCE(<transformation>).FILTER(<predicate>) is equivalent to FILTER(<predicate>).REDUCE(<transformation>), if predicate condition is a function only of the KEY, because thus, applying the FILTER before the REDUCE will preserve the values associated to those keys that satisfy the filter condition as they would be if the FILTER was applied after the REDUCE.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9831936359405518}, "created": {"value": false, "score": 2.9802322387695312e-06}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995518326759338}, "created": {"value": false, "score": 0.00020498037338256836}, "shared": {"value": false, "score": 2.384185791015625e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 367, "offsetEnd": 376}, "context": "Query Q2 M evaluates just the parallel execution of the BookOrders script in MongoDB, while Q2 ML involves a join between MongoDB and the CUSTOMER table from the LeanXcale data store: Fig. 9 shows the performance measurements of Q2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7139509320259094}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999399185180664}, "created": {"value": true, "score": 0.9999358654022217}, "shared": {"value": false, "score": 8.463859558105469e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 392, "offsetEnd": 397}, "context": "Thus, Q4 is defined as follows: Using bind join, the query executes as follows: first, the join between CLICKS at HDFS and BookOrders at MongoDB takes place, as in Q3; then, after flattening O.keywords and identifying the list of distinct keywords, another bind join condition is pushed to the Experts subquery to Spark, as described in Section 5.1, to reduce the amount of data processed by Spark transformations.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6309000253677368}, "created": {"value": false, "score": 1.6689300537109375e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999768733978271}, "created": {"value": true, "score": 0.9997757077217102}, "shared": {"value": false, "score": 1.4781951904296875e-05}}}], "references": [{"refKey": 26, "tei": "<biblStruct xml:id=\"b26\">\n\t<analytic>\n\t\t<title level=\"a\" type=\"main\">CloudMdsQL: querying heterogeneous cloud data stores with a common language</title>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Boyan</forename><surname>Kolev</surname></persName>\n\t\t\t<idno type=\"ORCID\">0000-0003-4871-0434</idno>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Patrick</forename><surname>Valduriez</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Carlyna</forename><surname>Bondiombouy</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Ricardo</forename><surname>Jim\u00e9nez-Peris</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Raquel</forename><surname>Pau</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Jos\u00e9</forename><surname>Pereira</surname></persName>\n\t\t</author>\n\t\t<idno type=\"DOI\">10.1007/s10619-015-7185-y</idno>\n\t</analytic>\n\t<monogr>\n\t\t<title level=\"j\">Distributed and Parallel Databases</title>\n\t\t<title level=\"j\" type=\"abbrev\">Distrib Parallel Databases</title>\n\t\t<idno type=\"ISSN\">0926-8782</idno>\n\t\t<idno type=\"ISSNe\">1573-7578</idno>\n\t\t<imprint>\n\t\t\t<biblScope unit=\"volume\">34</biblScope>\n\t\t\t<biblScope unit=\"issue\">4</biblScope>\n\t\t\t<biblScope unit=\"page\" from=\"463\" to=\"503\" />\n\t\t\t<date type=\"published\" when=\"2015-09-25\">2015</date>\n\t\t\t<publisher>Springer Science and Business Media LLC</publisher>\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}, {"refKey": 5, "tei": "<biblStruct xml:id=\"b5\">\n\t<monogr>\n\t\t<title level=\"m\">Apache Impala</title>\n\t\t<imprint/>\n\t</monogr>\n</biblStruct>\n"}], "runtime": 21859, "id": "7f52e77db41d708f640acc4135b111ae1743f8cb", "metadata": {"id": "7f52e77db41d708f640acc4135b111ae1743f8cb"}, "original_file_path": "../../datalake/Samuel/SOFTware-Sync/downloads/xml/lirmm-03148271.grobid.tei.xml", "file_name": "lirmm-03148271.grobid.tei.xml"}