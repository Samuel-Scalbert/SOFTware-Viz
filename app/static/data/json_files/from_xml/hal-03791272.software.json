{"application": "software-mentions", "version": "0.8.0", "date": "2024-10-07T11:45+0000", "md5": "B5933CE7A9F64DD1815EDB26CF51978D", "mentions": [{"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 31, "offsetEnd": 41}, "version": {"rawForm": "12.7", "normalizedForm": "12.7", "offsetStart": 43, "offsetEnd": 47}, "context": "Accordingly, we decided to use PostgreSQL v12.7 due to its maturity and its wide adoption.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9987897276878357}, "created": {"value": false, "score": 0.00021713972091674805}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 34, "offsetEnd": 48}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "Looking within the source code of PostgreSQL [2] uncovered a default selectivity of 0.11 in an example case we considered: the optimizer estimated 800.000 rows in the table, combined this with the default selectivity factor, and concluded that approximately 80.000 rows were going to be selected when the true value was closer to 50 (1.600\u00d7 ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999362230300903}, "created": {"value": false, "score": 2.1457672119140625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 37, "offsetEnd": 47}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "However, when we implemented that in PostgreSQL, we noticed that running the queries using the CSR index tables yields slower execution time which was surprising at first (as scanning only the useful part of the edges relation should be faster than scanning the whole relation). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0021432042121887207}, "created": {"value": false, "score": 0.07115060091018677}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 42, "offsetEnd": 52}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "When we investigated the query plans that PostgreSQL optimizer produced on the COS layout, we noticed the following:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999645948410034}, "created": {"value": false, "score": 1.049041748046875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 49, "offsetEnd": 59}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "Therefore, we had to investigate further why the PostgreSQL estimator significantly overestimates the number of rows resulting from the range query. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999480247497559}, "created": {"value": false, "score": 0.0005188584327697754}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 50, "offsetEnd": 60}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "\u2022 It turned out that the cardinality estimator of PostgreSQL significantly overestimates the number of rows in the destination relation that satisfies the range filter to get the set of nodes in the range [offset, offset+length]. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9953199028968811}, "created": {"value": false, "score": 3.4570693969726562e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 54, "offsetEnd": 64}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "A and B are constants written in the query), then the PostgreSQL cardinality estimator uses its materialised statistics available about the column R.c in the system catalogue, such as the histogram of R.c, the set of most common values of R.c, and their frequencies, in order to estimate the number of tuples that satisfy the range predicate [3].", "mentionContextAttributes": {"used": {"value": true, "score": 0.9978604912757874}, "created": {"value": false, "score": 4.5299530029296875e-06}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 58, "offsetEnd": 68}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "Figure 4 shows the runtime of running SNB-M IC queries on PostgreSQL with and without using COS. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9947587847709656}, "created": {"value": false, "score": 5.602836608886719e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 72, "offsetEnd": 82}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "In order to know why the optimizer takes this decision, we investigated PostgreSQL cardinality estimators, which predict the number of output rows that each operator produces. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999802112579346}, "created": {"value": false, "score": 3.0040740966796875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 84, "offsetEnd": 94}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "To explain why the speedup was smaller, we analyzed the execution plans produced by PostgreSQL for each one of the queries. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 6.198883056640625e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 109, "offsetEnd": 119}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "In order to solve the problem discussed, we had to choose a good replacement for the default selectivity the PostgreSQL estimator uses in order to fit our case. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9873400330543518}, "created": {"value": false, "score": 0.0004916191101074219}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 137, "offsetEnd": 147}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "In this section, we explain an important challenge we had when running the set of graph-relational queries using the CSR index on top of PostgreSQL. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999003410339355}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 138, "offsetEnd": 148}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "From that argument, we can recalculate the appropriate default selectivity for a given graph and replace the default selectivity value in PostgreSQL. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.5264614224433899}, "created": {"value": false, "score": 4.0650367736816406e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 181, "offsetEnd": 191}, "version": {"rawForm": "12.7", "normalizedForm": "12.7"}, "context": "For instance, consider the property graph in Figure 1 and the following query asking for the name and age of every person known by a person named Bob: The query then is sent to the PostgreSQL optimizer as any relational query, thus allowing it to be optimized and executed in the standard way.", "mentionContextAttributes": {"used": {"value": false, "score": 0.3169029951095581}, "created": {"value": false, "score": 4.363059997558594e-05}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999916553497314}, "created": {"value": false, "score": 0.14002728462219238}, "shared": {"value": false, "score": 8.344650268554688e-07}}}], "references": [], "runtime": 11113, "id": "7dee39e77ede19ab752cca34ffcd467f91f0ed60", "metadata": {"id": "7dee39e77ede19ab752cca34ffcd467f91f0ed60"}, "original_file_path": "../../datalake/Samuel/SOFTware-Sync/downloads/xml/hal-03791272.grobid.tei.xml", "file_name": "hal-03791272.grobid.tei.xml"}