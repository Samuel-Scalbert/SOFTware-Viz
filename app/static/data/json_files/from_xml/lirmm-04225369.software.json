{"application": "software-mentions", "version": "0.8.0", "date": "2024-10-07T11:58+0000", "md5": "273AC526AC76D8153F2BD56FDFF22B06", "mentions": [{"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 0, "offsetEnd": 5}, "context": "STAMP and STOMP) compute only 1N N MP.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": false, "score": 1.430511474609375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 4, "offsetEnd": 8}, "context": "The MASS algorithm is mentioned in Algorithm 7. In Line 1 of this algorithm, the sliding dot product is calculated by using Algorithm 6.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5126901865005493}, "created": {"value": false, "score": 0.0003897547721862793}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 10, "offsetEnd": 14}, "context": "Then, the MASS algorithm (see Appendix: III for more details) is applied in Line 5 to compute the dot product (QT ) (distance D ignore is ignored) between the first subsequence (subSeq 1 ) and other subsequences of time series T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9987179040908813}, "created": {"value": false, "score": 9.417533874511719e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 10, "offsetEnd": 15}, "context": "STAMP and STOMP) compute only 1N N MP.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": false, "score": 1.430511474609375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 16, "offsetEnd": 21}, "context": "In general, the STOMP algorithm is designed to compute 1N N MP.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00010764598846435547}, "created": {"value": true, "score": 0.955484926700592}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 17, "offsetEnd": 21}, "context": "The arguments of MASS are: 1 st subsequence (subSeq 1 ), mean (\u00b5 T [1]) and STD (\u03c3 T [1]) of subSeq 1 , complete time series T , mean (\u00b5 T ) and STD (\u03c3 T ) vector (i.e., mean and STD of all the subsequences) of T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973811507225037}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 20, "offsetEnd": 25}, "context": "So, in Algorithm 8: STAMP(T , m) Input: The user given time series T , subsequence length m Output: The MP P T and associated matrix profile index I T 1 n T \u2190 length(T ) // get the no. of elements in T 2 P T \u2190 Initialize this 1D vector with inf 3 I T \u2190 Initialize this 1D vector with zeros 4 Idxs \u2190 (n T -m + 1) // total number of possible subsequences 5 \u00b5 T , \u03c3 T \u2190 ComputeM eanStd(T ) // see Equation 26 for i \u2190 1 to Idxs do 7 cutQuery \u2190 T [i to (i + m -1)] // get query subsequence by chopping T from index i to ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973816275596619}, "created": {"value": false, "score": 1.7881393432617188e-06}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 20, "offsetEnd": 25}, "context": "So, in Algorithm 8: STAMP(T , m) Input: The user given time series T , subsequence length m Output: The MP P T and associated matrix profile index I T 1 n T \u2190 length(T ) // get the no. of elements in T 2 P T \u2190 Initialize this 1D vector with inf 3 I T \u2190 Initialize this 1D vector with zeros 4 Idxs \u2190 (n T -m + 1) // total number of possible subsequences 5 \u00b5 T , \u03c3 T \u2190 ComputeM eanStd(T ) // see Equation 26 for i \u2190 1 to Idxs do 7 cutQuery \u2190 T [i to (i + m -1)] // get query subsequence by chopping T from index i to", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973816275596619}, "created": {"value": false, "score": 1.7881393432617188e-06}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 27, "offsetEnd": 32}, "context": "To calculate the distance, STOMP takes benefit of the common part between two adjacent subsequences which is the same except the fist and last elements.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9929240942001343}, "created": {"value": false, "score": 4.291534423828125e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 27, "offsetEnd": 32}, "context": "The pseudocode of modified STOMP algorithm, named as IndependentSTOMP is mentioned in Algorithm 9.", "mentionContextAttributes": {"used": {"value": false, "score": 0.004999697208404541}, "created": {"value": false, "score": 0.09280914068222046}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 33, "offsetEnd": 37}, "context": "In [9] [8], Mueen et al. propose MASS, an efficient algorithm for similarity search in time series.", "mentionContextAttributes": {"used": {"value": false, "score": 6.210803985595703e-05}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 33, "offsetEnd": 38}, "context": "The time complexity of classical STOMP is O(n) 2 which is O(log n) improvement over STAMP algorithm.", "mentionContextAttributes": {"used": {"value": false, "score": 0.42362266778945923}, "created": {"value": false, "score": 3.2067298889160156e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 37, "offsetEnd": 42}, "context": "The Scalable Time Series Anytime MP (STAMP) algorithm, proposed by Yeh et.al [2] (outlined in Algorithm 8) calculates the closest match (1NN) of every subsequence in a time series T , based on the calculated distance (called as distance profile) between any particular subsequence with all the remaining subsequence in T .", "mentionContextAttributes": {"used": {"value": false, "score": 0.0016564130783081055}, "created": {"value": false, "score": 9.548664093017578e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "IndependentSTOMP", "normalizedForm": "IndependentSTOMP", "offsetStart": 38, "offsetEnd": 54}, "context": "The following arguments are passed in IndependentSTOMP for the distance calculation: each subsequences (cutSubSeq), the mean (\u00b5 T [i]) and STD (\u03c3 T [i]) of T , the dot product value (QT initial [i]) of very first subsequence (subSeq 1 ) and i th subsequences (T [i to (i+m-1)]), already computed dot product vector (QT ), mean (\u00b5 T ) and STD (\u03c3 T ) of T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999514818191528}, "created": {"value": false, "score": 2.6226043701171875e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999514818191528}, "created": {"value": false, "score": 0.09280914068222046}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 39, "offsetEnd": 44}, "context": "Let us briefly present the idea behind STOMP.", "mentionContextAttributes": {"used": {"value": false, "score": 9.119510650634766e-05}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 43, "offsetEnd": 48}, "context": "The MP algorithms in the literature (e.g., STAMP and STOMP algorithms [2]) are designed to find the best match (1N N ) of each subsequence.", "mentionContextAttributes": {"used": {"value": false, "score": 0.000410616397857666}, "created": {"value": false, "score": 0.014198362827301025}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 43, "offsetEnd": 48}, "context": "We have compared the computational time of STOMP algorithm by Yeh et.al [2] with our proposed technique for kN N MP.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9960935711860657}, "created": {"value": false, "score": 0.05707043409347534}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 43, "offsetEnd": 48}, "context": "we have explained the general principal of STOMP algorithm for the computation of MP for a single time series.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008766055107116699}, "created": {"value": true, "score": 0.9933843016624451}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 44, "offsetEnd": 49}, "context": "The Scalable Time Series Ordered Search MP (STOMP) algorithm [11] is a variant of STAMP (see Appendix: IV for more details) in which we perform an ordered search (from left to right).", "mentionContextAttributes": {"used": {"value": false, "score": 0.00018233060836791992}, "created": {"value": false, "score": 2.4080276489257812e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 45, "offsetEnd": 50}, "context": "It is an improved version of the earlier GPU-STOMP algorithm.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00012636184692382812}, "created": {"value": false, "score": 0.02635669708251953}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 46, "offsetEnd": 50}, "context": "Thanks to the use of FFT, in recent years the MASS algorithm has emerged as a significant contribution in subsequence similarity search for many similarity based pattern matching problems such as motif and discord discovery, nearest neighbor matching, etc. [10], [11], [12], [13].", "mentionContextAttributes": {"used": {"value": false, "score": 0.000395357608795166}, "created": {"value": false, "score": 0.0004649162292480469}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 46, "offsetEnd": 51}, "context": "Furthermore, an incremental algorithm, called STOMP, is adapted for distance computation of overlapping sequential subsequences in which MASS algorithm is used for time series similarity search by computing z-normalized euclidean distance between the subsequences.", "mentionContextAttributes": {"used": {"value": false, "score": 9.381771087646484e-05}, "created": {"value": false, "score": 0.03507280349731445}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 47, "offsetEnd": 52}, "context": "Now let's concentrate on the principal part of STOMP.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0021416544914245605}, "created": {"value": false, "score": 0.016082942485809326}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 50, "offsetEnd": 55}, "context": "In case of two independent time series, the basic STOMP algorithm needs to be marginally modified.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003107786178588867}, "created": {"value": false, "score": 6.449222564697266e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 53, "offsetEnd": 58}, "context": "SCAMP [15,16] is an efficient GPU-based extension of STOMP algorithm for computing 1NN matrix profile using GPUs.", "mentionContextAttributes": {"used": {"value": false, "score": 3.314018249511719e-05}, "created": {"value": false, "score": 3.063678741455078e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 53, "offsetEnd": 58}, "context": "The MP algorithms in the literature (e.g., STAMP and STOMP algorithms [2]) are designed to find the best match (1N N ) of each subsequence.", "mentionContextAttributes": {"used": {"value": false, "score": 0.000410616397857666}, "created": {"value": false, "score": 0.014198362827301025}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "IndependentSTOMP", "normalizedForm": "IndependentSTOMP", "offsetStart": 53, "offsetEnd": 69}, "context": "The pseudocode of modified STOMP algorithm, named as IndependentSTOMP is mentioned in Algorithm 9.", "mentionContextAttributes": {"used": {"value": false, "score": 0.004999697208404541}, "created": {"value": false, "score": 0.09280914068222046}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999514818191528}, "created": {"value": false, "score": 0.09280914068222046}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 56, "offsetEnd": 60}, "context": "Only for the first subsequence (when i = 1), it applies MASS algorithm to compute the dot product (QT ) and distance vector (Dist cutSubSeq ) between first target subsequence (cutSubSeq) and the remaining subsequences of time series T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9901680946350098}, "created": {"value": false, "score": 1.4066696166992188e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SCRIMP++", "normalizedForm": "SCRIMP++", "offsetStart": 58, "offsetEnd": 66}, "context": "In [3], the authors introduce an anytime algorithm, named SCRIMP++ by combining the best features of STAMP and STOMP for fast MP computation.", "mentionContextAttributes": {"used": {"value": false, "score": 3.886222839355469e-05}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 8.928775787353516e-05}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 64, "offsetEnd": 69}, "context": "It can be seen that our algorithm outperforms significantly the STOMP technique for computing kN N MP.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0011193156242370605}, "created": {"value": false, "score": 0.0022779107093811035}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 64, "offsetEnd": 69}, "context": "In this experiment, our proposed technique has outperformed the STOMP algorithm.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0004782676696777344}, "created": {"value": true, "score": 0.9927534461021423}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 66, "offsetEnd": 74}, "context": "Efficient algorithms have been proposed for MP computation, e.g., STAMP [2], STOMP [2] and SCRIMP++ [3]. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.928775787353516e-05}, "created": {"value": false, "score": 0.0794798731803894}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2, "offsetStart": 845, "offsetEnd": 848}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 72, "offsetEnd": 77}, "context": "Fig. 12 and13 show the computational time of our proposed algorithm and STOMP algorithm by using the previously mentioned seismic and random walk datasets.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9949023723602295}, "created": {"value": false, "score": 0.11360973119735718}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 75, "offsetEnd": 79}, "context": "al proposed a technique, known as Mueen's Algorithm for Similarity Search (MASS) [9]  [8] for the fast calculation of z-normalized Euclidean Distance between query subsequence and the subsequence of target time series, by exploiting Fast Fourier Transform (FFT).", "mentionContextAttributes": {"used": {"value": false, "score": 0.00015819072723388672}, "created": {"value": false, "score": 0.4651450514793396}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 76, "offsetEnd": 81}, "context": "Our algorithm for computing kN N MP of the time series T is inspired by the STOMP algorithm [18].", "mentionContextAttributes": {"used": {"value": false, "score": 0.00946420431137085}, "created": {"value": true, "score": 0.7833954095840454}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 77, "offsetEnd": 86}, "context": "Efficient algorithms have been proposed for MP computation, e.g., STAMP [2], STOMP [2] and SCRIMP++ [3]. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.928775787353516e-05}, "created": {"value": false, "score": 0.07947927713394165}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 82, "offsetEnd": 87}, "context": "The Scalable Time Series Ordered Search MP (STOMP) algorithm [11] is a variant of STAMP (see Appendix: IV for more details) in which we perform an ordered search (from left to right).", "mentionContextAttributes": {"used": {"value": false, "score": 0.00018233060836791992}, "created": {"value": false, "score": 2.4080276489257812e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 84, "offsetEnd": 89}, "context": "The time complexity of classical STOMP is O(n) 2 which is O(log n) improvement over STAMP algorithm.", "mentionContextAttributes": {"used": {"value": false, "score": 0.42362141609191895}, "created": {"value": false, "score": 3.2067298889160156e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SCRIMP++", "normalizedForm": "SCRIMP++", "offsetStart": 91, "offsetEnd": 102}, "context": "Efficient algorithms have been proposed for MP computation, e.g., STAMP [2], STOMP [2] and SCRIMP++ [3]. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.928775787353516e-05}, "created": {"value": false, "score": 0.07947927713394165}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 8.928775787353516e-05}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 101, "offsetEnd": 106}, "context": "In [3], the authors introduce an anytime algorithm, named SCRIMP++ by combining the best features of STAMP and STOMP for fast MP computation.", "mentionContextAttributes": {"used": {"value": false, "score": 3.886222839355469e-05}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 111, "offsetEnd": 116}, "context": "In [3], the authors introduce an anytime algorithm, named SCRIMP++ by combining the best features of STAMP and STOMP for fast MP computation.", "mentionContextAttributes": {"used": {"value": false, "score": 3.886222839355469e-05}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 118, "offsetEnd": 123}, "context": "The authors use the convolution property of FFT and Inverse FFT for the fast calculation of MP by an algorithm called STAMP.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9872639179229736}, "created": {"value": false, "score": 4.565715789794922e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983214735984802}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 137, "offsetEnd": 141}, "context": "Furthermore, an incremental algorithm, called STOMP, is adapted for distance computation of overlapping sequential subsequences in which MASS algorithm is used for time series similarity search by computing z-normalized euclidean distance between the subsequences. ", "mentionContextAttributes": {"used": {"value": false, "score": 9.381771087646484e-05}, "created": {"value": false, "score": 0.035072386264801025}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "IndependentSTOMP", "normalizedForm": "IndependentSTOMP", "offsetStart": 145, "offsetEnd": 161}, "context": "For i > 1 on-wards, the distance of target subsequence (cutSubSeq) with all the remaining subsequences of T is incrementally calculated by using IndependentSTOMP algorithm (see Appendix: IV.1 for more details). ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9629462361335754}, "created": {"value": false, "score": 7.748603820800781e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999514818191528}, "created": {"value": false, "score": 0.09280914068222046}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STOMP", "normalizedForm": "STOMP", "offsetStart": 180, "offsetEnd": 185}, "context": "In the third experiment (shown in Fig. 13a), where the comparison is performed by increasing the subsequence length, our proposed technique has also better execution time than the STOMP algorithm, for computing kNN matrix profile.", "mentionContextAttributes": {"used": {"value": false, "score": 0.018010497093200684}, "created": {"value": false, "score": 0.10927939414978027}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9998051524162292}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 813, "offsetEnd": 817}, "context": "Input: A query subsequence (q), A target time series (T ) Output: The dot product (qT ) between single query subsequence and all the target subsequences 1 n \u2190 no. of elements in T ; s \u2190 no. of elements in q 2 T a \u2190 double the length of T by appending n number of zeros at the end 3 q a \u2190 reverse the elements in q so that the last element become first and vice versa 4 q ra \u2190 append (2n -m) zeros at the end of q r 5 q raf \u2190 do F F T (q ra ); T af \u2190 do F F T (T a ) 6 M \u2190 elementwise multiplication of q raf and T af // as both q raf and T af are of the same size, so we can easily multiply element to elements 7 qT \u2190 InverseF F T (M ) 8 return P T In Line 4, both vectors q and T are made to be of the same length (see Section Appendix: I.1) by appending the required amount of zeros (2n -m) to the Algorithm 7: MASS (q, \u00b5 q , \u03c3 q , T , \u00b5 T , \u03c3 T ) Input: A query subsequence (q), mean of q (\u00b5 q ), standard deviation of q (\u03c3 q ), Target time series (T ), mean of T (\u00b5 T ), standard deviation of T (\u03c3 T ) Output: Distance profile (D), Dot product (qT ) 1 qT \u2190 SlidingDotP roducts(q, T ) //see Algorithm 6 2 D \u2190 CalculateDistanceP rof ile(qT, \u00b5 q , \u03c3 q , \u00b5 T , \u03c3 T ) // see Equation 33 return qT, D calculate the distance (D i ) is shown below.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 2.0265579223632812e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 813, "offsetEnd": 817}, "context": "Input: A query subsequence (q), A target time series (T ) Output: The dot product (qT ) between single query subsequence and all the target subsequences 1 n \u2190 no. of elements in T ; s \u2190 no. of elements in q 2 T a \u2190 double the length of T by appending n number of zeros at the end 3 q a \u2190 reverse the elements in q so that the last element become first and vice versa 4 q ra \u2190 append (2n -m) zeros at the end of q r 5 q raf \u2190 do F F T (q ra ); T af \u2190 do F F T (T a ) 6 M \u2190 elementwise multiplication of q raf and T af // as both q raf and T af are of the same size, so we can easily multiply element to elements 7 qT \u2190 InverseF F T (M ) 8 return P T In Line 4, both vectors q and T are made to be of the same length (see Section Appendix: I.1) by appending the required amount of zeros (2n -m) to the Algorithm 7: MASS (q, \u00b5 q , \u03c3 q , T , \u00b5 T , \u03c3 T ) Input: A query subsequence (q), mean of q (\u00b5 q ), standard deviation of q (\u03c3 q ), Target time series (T ), mean of T (\u00b5 T ), standard deviation of T (\u03c3 T ) Output: Distance profile (D), Dot product (qT ) 1 qT \u2190 SlidingDotP roducts(q, T ) //see Algorithm 6 2 D \u2190 CalculateDistanceP rof ile(qT, \u00b5 q , \u03c3 q , \u00b5 T , \u03c3 T ) // see Equation 33 return qT, D calculate the distance (D i ) is shown below.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 2.0265579223632812e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.6681177616119385}, "shared": {"value": false, "score": 2.0265579223632812e-06}}}], "references": [{"refKey": 2, "tei": "<biblStruct xml:id=\"b2\">\n\t<monogr>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">C</forename><forename type=\"middle\">C M</forename><surname>Yeh</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Y</forename><surname>Zhu</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">L</forename><surname>Ulanova</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">N</forename><surname>Begum</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Y</forename><surname>Ding</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">H</forename><forename type=\"middle\">A</forename><surname>Dau</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Z</forename><surname>Zimmerman</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">D</forename><forename type=\"middle\">F</forename><surname>Silva</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">A</forename><surname>Mueen</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">E</forename><surname>Keogh</surname></persName>\n\t\t</author>\n\t\t<title level=\"m\">Time series joins, motifs, discords and shapelets: a unifying view that exploits the matrix profile</title>\n\t\t<imprint>\n\t\t\t<date>2018</date>\n\t\t\t<biblScope unit=\"volume\">32</biblScope>\n\t\t\t<biblScope unit=\"page\">123</biblScope>\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}], "runtime": 8969, "id": "5163503516c9a263be4e5c23f8fcfed63d16ae3b", "metadata": {"id": "5163503516c9a263be4e5c23f8fcfed63d16ae3b"}, "original_file_path": "../../datalake/Samuel/SOFTware-Sync/downloads/xml/lirmm-04225369.grobid.tei.xml", "file_name": "lirmm-04225369.grobid.tei.xml"}