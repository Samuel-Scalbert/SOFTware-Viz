{"application": "software-mentions", "version": "0.8.0", "date": "2024-04-12T16:19+0000", "md5": "D2EAAA09A64DA1A0D4CA551129B72472", "mentions": [{"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 0, "offsetEnd": 5}, "context": "STAMP and STOMP) compute only 1N N MP.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": false, "score": 1.4901161193847656e-06}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 4, "offsetEnd": 8}, "context": "The MASS algorithm is mentioned in Algorithm 7. In Line 1 of this algorithm, the sliding dot product is calculated by using Algorithm 6.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5126882791519165}, "created": {"value": false, "score": 0.0003897547721862793}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 10, "offsetEnd": 14}, "context": "Then, the MASS algorithm (see Appendix: III for more details) is applied in Line 5 to compute the dot product (QT ) (distance D ignore is ignored) between the first subsequence (subSeq 1 ) and other subsequences of time series T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9987179636955261}, "created": {"value": false, "score": 9.47713851928711e-06}, "shared": {"value": false, "score": 4.172325134277344e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 17, "offsetEnd": 21}, "context": "The arguments of MASS are: 1 st subsequence (subSeq 1 ), mean (\u00b5 T [1]) and STD (\u03c3 T [1]) of subSeq 1 , complete time series T , mean (\u00b5 T ) and STD (\u03c3 T ) vector (i.e., mean and STD of all the subsequences) of T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973811507225037}, "created": {"value": false, "score": 3.159046173095703e-06}, "shared": {"value": false, "score": 6.556510925292969e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 20, "offsetEnd": 25}, "context": "So, in Algorithm 8: STAMP(T , m) Input: The user given time series T , subsequence length m Output: The MP P T and associated matrix profile index I T 1 n T \u2190 length(T ) // get the no. of elements in T 2 P T \u2190 Initialize this 1D vector with inf 3 I T \u2190 Initialize this 1D vector with zeros 4 Idxs \u2190 (n T -m + 1) // total number of possible subsequences 5 \u00b5 T , \u03c3 T \u2190 ComputeM eanStd(T ) // see Equation 26 for i \u2190 1 to Idxs do 7 cutQuery \u2190 T [i to (i + m -1)] // get query subsequence by chopping T from index i to ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973816275596619}, "created": {"value": false, "score": 1.8477439880371094e-06}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 20, "offsetEnd": 25}, "context": "So, in Algorithm 8: STAMP(T , m) Input: The user given time series T , subsequence length m Output: The MP P T and associated matrix profile index I T 1 n T \u2190 length(T ) // get the no. of elements in T 2 P T \u2190 Initialize this 1D vector with inf 3 I T \u2190 Initialize this 1D vector with zeros 4 Idxs \u2190 (n T -m + 1) // total number of possible subsequences 5 \u00b5 T , \u03c3 T \u2190 ComputeM eanStd(T ) // see Equation 26 for i \u2190 1 to Idxs do 7 cutQuery \u2190 T [i to (i + m -1)] // get query subsequence by chopping T from index i to", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973816275596619}, "created": {"value": false, "score": 1.8477439880371094e-06}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 33, "offsetEnd": 37}, "context": "In [9] [8], Mueen et al. propose MASS, an efficient algorithm for similarity search in time series.", "mentionContextAttributes": {"used": {"value": false, "score": 6.216764450073242e-05}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 37, "offsetEnd": 42}, "context": "The Scalable Time Series Anytime MP (STAMP) algorithm, proposed by Yeh et.al [2] (outlined in Algorithm 8) calculates the closest match (1NN) of every subsequence in a time series T , based on the calculated distance (called as distance profile) between any particular subsequence with all the remaining subsequence in T .", "mentionContextAttributes": {"used": {"value": false, "score": 0.0016564130783081055}, "created": {"value": false, "score": 9.554624557495117e-05}, "shared": {"value": false, "score": 4.172325134277344e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "IndependentSTOMP", "normalizedForm": "IndependentSTOMP", "offsetStart": 38, "offsetEnd": 54}, "context": "The following arguments are passed in IndependentSTOMP for the distance calculation: each subsequences (cutSubSeq), the mean (\u00b5 T [i]) and STD (\u03c3 T [i]) of T , the dot product value (QT initial [i]) of very first subsequence (subSeq 1 ) and i th subsequences (T [i to (i+m-1)]), already computed dot product vector (QT ), mean (\u00b5 T ) and STD (\u03c3 T ) of T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999514222145081}, "created": {"value": false, "score": 2.682209014892578e-06}, "shared": {"value": false, "score": 4.172325134277344e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999514222145081}, "created": {"value": false, "score": 0.09280812740325928}, "shared": {"value": false, "score": 4.172325134277344e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 43, "offsetEnd": 48}, "context": "The MP algorithms in the literature (e.g., STAMP and STOMP algorithms [2]) are designed to find the best match (1N N ) of each subsequence.", "mentionContextAttributes": {"used": {"value": false, "score": 0.000410616397857666}, "created": {"value": false, "score": 0.014198482036590576}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 46, "offsetEnd": 50}, "context": "Thanks to the use of FFT, in recent years the MASS algorithm has emerged as a significant contribution in subsequence similarity search for many similarity based pattern matching problems such as motif and discord discovery, nearest neighbor matching, etc. [10], [11], [12], [13].", "mentionContextAttributes": {"used": {"value": false, "score": 0.000395357608795166}, "created": {"value": false, "score": 0.00046497583389282227}, "shared": {"value": false, "score": 4.172325134277344e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "IndependentSTOMP", "normalizedForm": "IndependentSTOMP", "offsetStart": 53, "offsetEnd": 69}, "context": "The pseudocode of modified STOMP algorithm, named as IndependentSTOMP is mentioned in Algorithm 9.", "mentionContextAttributes": {"used": {"value": false, "score": 0.004999697208404541}, "created": {"value": false, "score": 0.09280812740325928}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999514222145081}, "created": {"value": false, "score": 0.09280812740325928}, "shared": {"value": false, "score": 4.172325134277344e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 56, "offsetEnd": 60}, "context": "Only for the first subsequence (when i = 1), it applies MASS algorithm to compute the dot product (QT ) and distance vector (Dist cutSubSeq ) between first target subsequence (cutSubSeq) and the remaining subsequences of time series T .", "mentionContextAttributes": {"used": {"value": true, "score": 0.990168035030365}, "created": {"value": false, "score": 1.4126300811767578e-05}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SCRIMP++", "normalizedForm": "SCRIMP++", "offsetStart": 58, "offsetEnd": 66}, "context": "In [3], the authors introduce an anytime algorithm, named SCRIMP++ by combining the best features of STAMP and STOMP for fast MP computation.", "mentionContextAttributes": {"used": {"value": false, "score": 3.892183303833008e-05}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 8.934736251831055e-05}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 2.980232238769531e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 66, "offsetEnd": 74}, "context": "Efficient algorithms have been proposed for MP computation, e.g., STAMP [2], STOMP [2] and SCRIMP++ [3]. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.934736251831055e-05}, "created": {"value": false, "score": 0.07948046922683716}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2, "offsetStart": 845, "offsetEnd": 848}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 75, "offsetEnd": 79}, "context": "al proposed a technique, known as Mueen's Algorithm for Similarity Search (MASS) [9]  [8] for the fast calculation of z-normalized Euclidean Distance between query subsequence and the subsequence of target time series, by exploiting Fast Fourier Transform (FFT).", "mentionContextAttributes": {"used": {"value": false, "score": 0.00015807151794433594}, "created": {"value": false, "score": 0.46514493227005005}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 82, "offsetEnd": 87}, "context": "The Scalable Time Series Ordered Search MP (STOMP) algorithm [11] is a variant of STAMP (see Appendix: IV for more details) in which we perform an ordered search (from left to right).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001823902130126953}, "created": {"value": false, "score": 2.4139881134033203e-05}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 84, "offsetEnd": 89}, "context": "The time complexity of classical STOMP is O(n) 2 which is O(log n) improvement over STAMP algorithm.", "mentionContextAttributes": {"used": {"value": false, "score": 0.42361921072006226}, "created": {"value": false, "score": 3.212690353393555e-05}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SCRIMP++", "normalizedForm": "SCRIMP++", "offsetStart": 91, "offsetEnd": 102}, "context": "Efficient algorithms have been proposed for MP computation, e.g., STAMP [2], STOMP [2] and SCRIMP++ [3]. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.934736251831055e-05}, "created": {"value": false, "score": 0.07948046922683716}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 8.934736251831055e-05}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 2.980232238769531e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 101, "offsetEnd": 106}, "context": "In [3], the authors introduce an anytime algorithm, named SCRIMP++ by combining the best features of STAMP and STOMP for fast MP computation.", "mentionContextAttributes": {"used": {"value": false, "score": 3.892183303833008e-05}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "STAMP", "normalizedForm": "STAMP", "offsetStart": 118, "offsetEnd": 123}, "context": "The authors use the convolution property of FFT and Inverse FFT for the fast calculation of MP by an algorithm called STAMP.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9872639179229736}, "created": {"value": false, "score": 4.571676254272461e-05}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9984080195426941}, "created": {"value": true, "score": 0.9983215928077698}, "shared": {"value": false, "score": 1.2516975402832031e-06}}, "references": [{"label": "[2]", "normalizedForm": "[2]", "refKey": 2}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 137, "offsetEnd": 141}, "context": "Furthermore, an incremental algorithm, called STOMP, is adapted for distance computation of overlapping sequential subsequences in which MASS algorithm is used for time series similarity search by computing z-normalized euclidean distance between the subsequences.", "mentionContextAttributes": {"used": {"value": false, "score": 9.387731552124023e-05}, "created": {"value": false, "score": 0.035072386264801025}, "shared": {"value": false, "score": 2.980232238769531e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "IndependentSTOMP", "normalizedForm": "IndependentSTOMP", "offsetStart": 145, "offsetEnd": 161}, "context": "For i > 1 on-wards, the distance of target subsequence (cutSubSeq) with all the remaining subsequences of T is incrementally calculated by using IndependentSTOMP algorithm (see Appendix: IV.1 for more details). ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9629462361335754}, "created": {"value": false, "score": 7.808208465576172e-06}, "shared": {"value": false, "score": 1.7881393432617188e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999514222145081}, "created": {"value": false, "score": 0.09280812740325928}, "shared": {"value": false, "score": 4.172325134277344e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 813, "offsetEnd": 817}, "context": "Input: A query subsequence (q), A target time series (T ) Output: The dot product (qT ) between single query subsequence and all the target subsequences 1 n \u2190 no. of elements in T ; s \u2190 no. of elements in q 2 T a \u2190 double the length of T by appending n number of zeros at the end 3 q a \u2190 reverse the elements in q so that the last element become first and vice versa 4 q ra \u2190 append (2n -m) zeros at the end of q r 5 q raf \u2190 do F F T (q ra ); T af \u2190 do F F T (T a ) 6 M \u2190 elementwise multiplication of q raf and T af // as both q raf and T af are of the same size, so we can easily multiply element to elements 7 qT \u2190 InverseF F T (M ) 8 return P T In Line 4, both vectors q and T are made to be of the same length (see Section Appendix: I.1) by appending the required amount of zeros (2n -m) to the Algorithm 7: MASS (q, \u00b5 q , \u03c3 q , T , \u00b5 T , \u03c3 T ) Input: A query subsequence (q), mean of q (\u00b5 q ), standard deviation of q (\u03c3 q ), Target time series (T ), mean of T (\u00b5 T ), standard deviation of T (\u03c3 T ) Output: Distance profile (D), Dot product (qT ) 1 qT \u2190 SlidingDotP roducts(q, T ) //see Algorithm 6 2 D \u2190 CalculateDistanceP rof ile(qT, \u00b5 q , \u03c3 q , \u00b5 T , \u03c3 T ) // see Equation 33 return qT, D calculate the distance (D i ) is shown below.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998242855072021}, "created": {"value": false, "score": 3.159046173095703e-06}, "shared": {"value": false, "score": 2.086162567138672e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MASS", "normalizedForm": "MASS", "offsetStart": 813, "offsetEnd": 817}, "context": "Input: A query subsequence (q), A target time series (T ) Output: The dot product (qT ) between single query subsequence and all the target subsequences 1 n \u2190 no. of elements in T ; s \u2190 no. of elements in q 2 T a \u2190 double the length of T by appending n number of zeros at the end 3 q a \u2190 reverse the elements in q so that the last element become first and vice versa 4 q ra \u2190 append (2n -m) zeros at the end of q r 5 q raf \u2190 do F F T (q ra ); T af \u2190 do F F T (T a ) 6 M \u2190 elementwise multiplication of q raf and T af // as both q raf and T af are of the same size, so we can easily multiply element to elements 7 qT \u2190 InverseF F T (M ) 8 return P T In Line 4, both vectors q and T are made to be of the same length (see Section Appendix: I.1) by appending the required amount of zeros (2n -m) to the Algorithm 7: MASS (q, \u00b5 q , \u03c3 q , T , \u00b5 T , \u03c3 T ) Input: A query subsequence (q), mean of q (\u00b5 q ), standard deviation of q (\u03c3 q ), Target time series (T ), mean of T (\u00b5 T ), standard deviation of T (\u03c3 T ) Output: Distance profile (D), Dot product (qT ) 1 qT \u2190 SlidingDotP roducts(q, T ) //see Algorithm 6 2 D \u2190 CalculateDistanceP rof ile(qT, \u00b5 q , \u03c3 q , \u00b5 T , \u03c3 T ) // see Equation 33 return qT, D calculate the distance (D i ) is shown below.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": false, "score": 3.0994415283203125e-06}, "shared": {"value": false, "score": 2.0265579223632812e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998243451118469}, "created": {"value": true, "score": 0.668119490146637}, "shared": {"value": false, "score": 2.086162567138672e-06}}}], "references": [{"refKey": 2, "tei": "<biblStruct xml:id=\"b2\">\n\t<monogr>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">C</forename><forename type=\"middle\">C M</forename><surname>Yeh</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Y</forename><surname>Zhu</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">L</forename><surname>Ulanova</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">N</forename><surname>Begum</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Y</forename><surname>Ding</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">H</forename><forename type=\"middle\">A</forename><surname>Dau</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Z</forename><surname>Zimmerman</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">D</forename><forename type=\"middle\">F</forename><surname>Silva</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">A</forename><surname>Mueen</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">E</forename><surname>Keogh</surname></persName>\n\t\t</author>\n\t\t<title level=\"m\">Time series joins, motifs, discords and shapelets: a unifying view that exploits the matrix profile</title>\n\t\t<imprint>\n\t\t\t<date>2018</date>\n\t\t\t<biblScope unit=\"volume\">32</biblScope>\n\t\t\t<biblScope unit=\"page\">123</biblScope>\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}], "runtime": 61445, "id": "0d2fd52e83d1c4d151cf33d3101ef380dae5bb71", "metadata": {"id": "0d2fd52e83d1c4d151cf33d3101ef380dae5bb71"}, "original_file_path": "../../datalake/Samuel/SOFTware-Sync/data/xml_files/lirmm-04225369.grobid.tei.xml", "file_name": "lirmm-04225369.grobid.tei.xml"}