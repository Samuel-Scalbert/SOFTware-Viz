{"application": "software-mentions", "version": "0.8.0", "date": "2024-10-07T12:03+0000", "md5": "6230F877739833483C7401B579E8BE8C", "mentions": [{"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 0, "offsetEnd": 13}, "context": "MultiDijkstra.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0203016996383667}, "created": {"value": false, "score": 2.002716064453125e-05}, "shared": {"value": false, "score": 4.76837158203125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 0, "offsetEnd": 15}, "context": "NodeElimination's perfomance, due to its main loop of creating \"shortcuts\" in the graph, is heavily dependent on the order in which the vertices are eliminated.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008300542831420898}, "created": {"value": false, "score": 3.4809112548828125e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 5, "offsetEnd": 20}, "context": "Only NodeElimination and the matrix asteration algorithms could benefit of a GraphBLAS implementation: this might increase their performance, even when retaining their higher asymptotic complexity with respect to other algorithms.", "mentionContextAttributes": {"used": {"value": false, "score": 0.11510837078094482}, "created": {"value": false, "score": 0.0003521442413330078}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 9, "offsetEnd": 24}, "context": "Finally, NodeElimination is always several orders of magnitude slower than Dijkstra. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005835294723510742}, "created": {"value": false, "score": 1.621246337890625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 13, "offsetEnd": 28}, "context": "Ordering for NodeElimination.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04243677854537964}, "created": {"value": false, "score": 3.790855407714844e-05}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 15, "offsetEnd": 28}, "context": "Interestingly, MultiDijkstra also exhibits a much smaller variance than that of Mohri, whose performance varies by more than one order of magnitude between runs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003097057342529297}, "created": {"value": false, "score": 7.033348083496094e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 16, "offsetEnd": 29}, "context": "We now evaluate MultiDijkstra, our contribution to bridging the gap between absorptive semirings and more general ones.", "mentionContextAttributes": {"used": {"value": false, "score": 0.40019214153289795}, "created": {"value": true, "score": 0.9991627931594849}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 18, "offsetEnd": 33}, "context": "For instance, the NodeElimination algorithm can be used to compute the asteration [2] of a matrix -but, if the semiring is not c-complete, there is no guarantee of a semantics compatible with the intuitive semantics of provenance over graph databases.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00026041269302368164}, "created": {"value": false, "score": 3.898143768310547e-05}, "shared": {"value": false, "score": 1.6689300537109375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 25, "offsetEnd": 40}, "context": "Taking into account that NodeElimination allows for a large class of semirings, this can have a significant real-world application impact.", "mentionContextAttributes": {"used": {"value": false, "score": 8.392333984375e-05}, "created": {"value": false, "score": 0.0002530217170715332}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 27, "offsetEnd": 40}, "context": "In Section 5, we introduce MultiDijkstra and the mathematical theory behind distributive lattices, which Multi-Dijkstra relies on. ", "mentionContextAttributes": {"used": {"value": false, "score": 7.236003875732422e-05}, "created": {"value": true, "score": 0.9998859167098999}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 27, "offsetEnd": 42}, "context": "We compare it to Mohri and NodeElimination in the case of the \ud835\udc58-feature semiring, which is kind of the canonical semiring that is 0-closed and multiplicatively idempotent.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0016369223594665527}, "created": {"value": false, "score": 1.3828277587890625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 28, "offsetEnd": 43}, "context": "we discuss in this section -NodeElimination and Mohrion the other.", "mentionContextAttributes": {"used": {"value": false, "score": 0.035795748233795166}, "created": {"value": false, "score": 0.0014091134071350098}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 30, "offsetEnd": 43}, "context": "We introduce a new algorithm, MultiDijkstra, which bridges the gap between algorithms for absorptive semirings and ones for more general classes.", "mentionContextAttributes": {"used": {"value": false, "score": 4.935264587402344e-05}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 39, "offsetEnd": 54}, "context": "This is important in practice: running NodeElimination on low-treewidth graphs (e.g., infrastructure and transport networks) can be the difference between the algorithm being unusable and allowing reasonable running times. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.618831634521484e-05}, "created": {"value": false, "score": 0.00022286176681518555}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 43, "offsetEnd": 58}, "context": "end for 12: end for 13: return w \ud835\udc60 \u2032 \ud835\udc61 \u2032 NodeElimination.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04952579736709595}, "created": {"value": false, "score": 3.5762786865234375e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 57, "offsetEnd": 72}, "context": "Hence, we have compared different elimination orders for NodeElimination and found out that the minimum degree based elimination order (Degree) greatly improves the efficiency of this algorithm compared to having no such heuristic (Id).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": false, "score": 0.0003216266632080078}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 58, "offsetEnd": 71}, "context": "Finally, Figure 9 presents a comparison between Mohri and MultiDijkstra on large Erd\u0151s-R\u00e9nyi random generated graphs (generated using Python networkx's fast_gnp_generation method, using an average of 1.7 edges per vertex) show that our new algorithm is still tractable for continental-sized graphs of millions of vertices.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6746754050254822}, "created": {"value": false, "score": 0.0012928247451782227}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 70, "offsetEnd": 83}, "context": "In the following, we address this problem and design a new algorithm, MultiDijkstra (for Multidimensional Dijkstra) that applies to the more general case of 0-closed semirings for which multiplication is idempotent (such as the \ud835\udc58-feature semiring, but also the Boolean function semiring used in probabilistic databases, see [34]).", "mentionContextAttributes": {"used": {"value": false, "score": 0.00021284818649291992}, "created": {"value": false, "score": 0.2933432459831238}, "shared": {"value": false, "score": 2.0265579223632812e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 72, "offsetEnd": 85}, "context": "In this paper, we extend this work by: \u2022 Introducing a novel algorithm, MultiDijkstra, for commutative 0-closed (or absorptive) semirings.", "mentionContextAttributes": {"used": {"value": false, "score": 4.267692565917969e-05}, "created": {"value": true, "score": 0.9998658895492554}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "GraphBLAS", "normalizedForm": "GraphBLAS", "offsetStart": 77, "offsetEnd": 86}, "context": "Only NodeElimination and the matrix asteration algorithms could benefit of a GraphBLAS implementation: this might increase their performance, even when retaining their higher asymptotic complexity with respect to other algorithms. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.11510837078094482}, "created": {"value": false, "score": 0.0003521442413330078}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.11510837078094482}, "created": {"value": true, "score": 0.9808567762374878}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 83, "offsetEnd": 98}, "context": "In all cases, our new algorithm is between 3 and 4 orders of magnitude faster than NodeElimination, depending on the network we use, and significantly faster than Mohri.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0004261136054992676}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 87, "offsetEnd": 100}, "context": "We found out that when either one of the two criteria reaches 4, Mohri times out while MultiDijkstra keeps scaling.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": false, "score": 1.4901161193847656e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 88, "offsetEnd": 101}, "context": "To minimize accesses to the decompose subroutine -which can be very costly -we optimize MultiDijkstra by adopting a lazy approach, where the Dijkstra subroutine calls decompose only when needed, storing the decomposition across calls.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003178119659423828}, "created": {"value": false, "score": 8.797645568847656e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 90, "offsetEnd": 103}, "context": "We investigate the running time and the number of relaxation steps performed by Mohri and MultiDijkstra algorithm, using initial weights provided by the dataset Rome99, as well as custom weights (all identical and all random); we then study over all datasets the impact of the elimination order heuristic on the overall performance for NodeElimination.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9961821436882019}, "created": {"value": false, "score": 4.947185516357422e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "GraphBLAS", "normalizedForm": "GraphBLAS", "offsetStart": 96, "offsetEnd": 109}, "context": "Recent work on semiring-based graph processing has provided to the community some tools such as GraphBLAS [23], a library of kernel functions dedicated to optimize linear algebra computations over sparse matrices. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.412101745605469e-05}, "created": {"value": true, "score": 0.9808567762374878}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.11510837078094482}, "created": {"value": true, "score": 0.9808567762374878}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Multi-Dijkstra", "normalizedForm": "Multi-Dijkstra", "offsetStart": 105, "offsetEnd": 119}, "context": "In Section 5, we introduce MultiDijkstra and the mathematical theory behind distributive lattices, which Multi-Dijkstra relies on. ", "mentionContextAttributes": {"used": {"value": false, "score": 7.236003875732422e-05}, "created": {"value": true, "score": 0.9998859167098999}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 7.236003875732422e-05}, "created": {"value": true, "score": 0.9998859167098999}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 113, "offsetEnd": 128}, "context": "The properties of this semiring allow their implementation for the first three algorithms:  Dijkstra, Mohri, and NodeElimination, whereas MultiDijkstra reduces to Dijkstra in that case.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001486361026763916}, "created": {"value": false, "score": 0.0003434419631958008}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DIMACS", "normalizedForm": "DIMACS", "offsetStart": 122, "offsetEnd": 128}, "context": "We also used a real weighted road transportation network dataset Rome99, with tropical semiring annotations, from the 9th DIMACS Implementation Challenge 4 . ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999384880065918}, "created": {"value": false, "score": 1.430511474609375e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999384880065918}, "created": {"value": false, "score": 1.430511474609375e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 138, "offsetEnd": 151}, "context": "The properties of this semiring allow their implementation for the first three algorithms:  Dijkstra, Mohri, and NodeElimination, whereas MultiDijkstra reduces to Dijkstra in that case.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001486361026763916}, "created": {"value": false, "score": 0.0003434419631958008}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MultiDijkstra", "normalizedForm": "MultiDijkstra", "offsetStart": 174, "offsetEnd": 187}, "context": "Unfortunately, this tool focuses essentially on matrix and vector products and is not amenable to express priority queue management such as those needed for Mohri, Dijkstra, MultiDijkstra.", "mentionContextAttributes": {"used": {"value": false, "score": 2.777576446533203e-05}, "created": {"value": false, "score": 0.003812849521636963}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9975480437278748}, "created": {"value": true, "score": 0.9999227523803711}, "shared": {"value": false, "score": 4.76837158203125e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "PostgreSQL", "normalizedForm": "PostgreSQL", "offsetStart": 194, "offsetEnd": 204}, "context": "The notion of provenance has also been initially developed using semirings [18], either for relational databases and Datalog programs, leading to practical systems such as [35], an extension to PostgreSQL adding the support for provenance. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00010764598846435547}, "created": {"value": false, "score": 0.009605228900909424}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00010764598846435547}, "created": {"value": false, "score": 0.009605228900909424}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 212, "offsetEnd": 227}, "context": "It is immediately clear from the figure that the choice of algorithm is crucial: we need the most specialized algorithm for the semiring we use: Dijkstra is more efficient than Mohri which is more efficient than NodeElimination. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.003572404384613037}, "created": {"value": false, "score": 9.334087371826172e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "NodeElimination", "normalizedForm": "NodeElimination", "offsetStart": 336, "offsetEnd": 351}, "context": "We investigate the running time and the number of relaxation steps performed by Mohri and MultiDijkstra algorithm, using initial weights provided by the dataset Rome99, as well as custom weights (all identical and all random); we then study over all datasets the impact of the elimination order heuristic on the overall performance for NodeElimination.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9961821436882019}, "created": {"value": false, "score": 4.947185516357422e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9986081719398499}, "created": {"value": true, "score": 0.6414332985877991}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}], "references": [], "runtime": 8217, "id": "5f38b1f022ee1e9381605f69ac86c779974fc28d", "metadata": {"id": "5f38b1f022ee1e9381605f69ac86c779974fc28d"}, "original_file_path": "../../datalake/Samuel/SOFTware-Sync/downloads/xml/hal-03140067.grobid.tei.xml", "file_name": "hal-03140067.grobid.tei.xml"}