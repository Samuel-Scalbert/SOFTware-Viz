{"application": "software-mentions", "version": "0.8.0", "date": "2024-10-07T12:47+0000", "md5": "598FB9D4CC77A07BFEC51C9FA775B200", "mentions": [{"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 0, "offsetEnd": 4}, "context": "Hive) with an arbitrary code in a scripting language (e.g. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.10808110237121582}, "created": {"value": false, "score": 4.458427429199219e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Impala", "normalizedForm": "Impala", "offsetStart": 0, "offsetEnd": 6}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 0, "offsetEnd": 6}, "context": "Hadoop HDFS), and big data processing frameworks (e.g.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0040413737297058105}, "created": {"value": false, "score": 3.647804260253906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.09944546222686768}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 0, "offsetEnd": 7}, "context": "MongoDB subqueries show lowest performance as data retrieval passes through the embedded at each worker JavaScript interpreter.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5243749618530273}, "created": {"value": false, "score": 1.5497207641601562e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 0, "offsetEnd": 9}, "context": "LeanXcale has three main subsystems: the query engine, the transactional engine and the storage engine, all three distributed and highly scalable (i.e. to 100s of nodes). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0004475712776184082}, "created": {"value": false, "score": 0.0001938939094543457}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 0, "offsetEnd": 9}, "context": "LeanXcale, thus, enables to avoid ETL processes to migrate data from operational databases to data warehouses by providing both functionalities in a single database manager. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.516674041748047e-05}, "created": {"value": false, "score": 0.00023633241653442383}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 0, "offsetEnd": 9}, "context": "Spark SQL provides a DataFrame API that can map to relations arbitrary object collections and thus enables relational operations across Spark's RDDs and external data sources. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.463859558105469e-05}, "created": {"value": false, "score": 0.0007729530334472656}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 0, "offsetEnd": 9}, "context": "Spark SQL can access a MongoDB cluster through its MongoDB connector that maps a sharded document collection to a DataFrame, partitioned as per the collection's sharding setup. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014118552207946777}, "created": {"value": false, "score": 2.2649765014648438e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 0, "offsetEnd": 9}, "context": "LeanXcale database is a scalable distributed Full ACID Full SQL database with OLTP and OLAP support.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0011838674545288086}, "created": {"value": false, "score": 5.9723854064941406e-05}, "shared": {"value": false, "score": 3.933906555175781e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 0, "offsetEnd": 10}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "CloudMdsQL allows named table expressions to be defined as functions in a scripting language (e.g., Python, JavaScript), which is useful for querying data stores that have only API-based query interface. ", "mentionContextAttributes": {"used": {"value": false, "score": 2.1576881408691406e-05}, "created": {"value": false, "score": 0.0005512833595275879}, "shared": {"value": false, "score": 2.86102294921875e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 0, "offsetEnd": 10}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "CloudMdsQL uses bind join as an efficient method for performing semi-joins across heterogeneous data stores that uses subquery rewriting to push the join conditions. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.1948089599609375e-05}, "created": {"value": false, "score": 1.621246337890625e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Impala", "normalizedForm": "Impala", "offsetStart": 0, "offsetEnd": 10}, "context": "Impala [3] is an open-source MPP SQL engine operating over Hadoop data processing environment. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014813542366027832}, "created": {"value": false, "score": 1.2993812561035156e-05}, "shared": {"value": false, "score": 0.0005882978439331055}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Derby", "normalizedForm": "Apache Derby", "offsetStart": 0, "offsetEnd": 12}, "context": "Apache Derby is a centralized OLTP database. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00044220685958862305}, "created": {"value": false, "score": 0.0002231001853942871}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9671032428741455}, "created": {"value": false, "score": 0.0002231001853942871}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale DQE", "normalizedForm": "LeanXcale DQE", "offsetStart": 0, "offsetEnd": 13}, "context": "LeanXcale DQE is designed to integrate with arbitrary data management clusters, where data resides in its natural format and can be retrieved (in parallel) by running specific scripts or declarative queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.221366882324219e-05}, "created": {"value": false, "score": 0.2625940442085266}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 5.221366882324219e-05}, "created": {"value": false, "score": 0.2625940442085266}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 0, "offsetEnd": 13}, "context": "Spark SQL [4] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001703500747680664}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop MapReduce", "normalizedForm": "Hadoop MapReduce", "offsetStart": 0, "offsetEnd": 16}, "context": "Hadoop MapReduce, Apache Spark, or Apache Flink), specialized for different kinds of data and tasks and able to scale and perform orders of magnitude better than traditional relational DBMS. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Drill", "normalizedForm": "Apache Drill", "offsetStart": 0, "offsetEnd": 16}, "context": "Apache Drill [2] is a distributed query engine for largescale datasets, designed to scale to thousands of nodes and query at low latency petabytes of data from various data sources through storage plugins. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.7087669372558594e-05}, "created": {"value": false, "score": 0.01159977912902832}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 4.7087669372558594e-05}, "created": {"value": false, "score": 0.01159977912902832}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 0, "offsetEnd": 18}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "CloudMdsQL [13,15] even allows data store native queries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.470348358154297e-05}, "created": {"value": false, "score": 1.4424324035644531e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 3, "offsetEnd": 11}, "context": "A. DataLake API For a particular data store, each DQE worker creates an instance of the DataLake wrapper that is generally used for querying and retrieval of shards of data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005714297294616699}, "created": {"value": false, "score": 0.00029593706130981445}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 4, "offsetEnd": 11}, "context": "The MongoDB storage allows running Drill and MongoDB together in distributed mode, by assigning shards to different drillbits to exploit parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003085136413574219}, "created": {"value": false, "score": 5.8650970458984375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 4, "offsetEnd": 13}, "context": "The LeanXcale database has derived its OLAP query engine from Apache Derby, a Java-based open-source SQL database.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9671032428741455}, "created": {"value": false, "score": 7.987022399902344e-05}, "shared": {"value": false, "score": 7.37905502319336e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 4, "offsetEnd": 14}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "The CloudMdsQL language is SQL-based with the extended capabilities for embedding subqueries expressed in terms of each data store's native query interface.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0028591156005859375}, "created": {"value": false, "score": 0.0007193684577941895}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 6, "offsetEnd": 13}, "context": "Since MongoDB collections are used directly in the FROM clause as tables, the storage plugin translates relational operators to native MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.09908062219619751}, "created": {"value": false, "score": 1.1801719665527344e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 9, "offsetEnd": 22}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 10, "offsetEnd": 14}, "context": "Note that Hive is interfaced only for getting metadata, while the data rows are read directly from HDFS. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.12792009115219116}, "created": {"value": false, "score": 9.5367431640625e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 11, "offsetEnd": 20}, "context": "This turns LeanXcale DQE into a powerful \"big data lake\" polyglot query engine that can process data from its original format, taking full advantage of both expressive scripting and massive parallelism. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.0531158447265625e-05}, "created": {"value": false, "score": 0.00699925422668457}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 12, "offsetEnd": 19}, "context": "To access a MongoDB cluster, Presto uses a connector that allows the parallel retrieval of sharded collections, which is typically configured with a list of MongoDB servers.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0041727423667907715}, "created": {"value": false, "score": 6.330013275146484e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 14, "offsetEnd": 21}, "context": "Subqueries to MongoDB are expressed natively in JavaScript and intermediate result sets from MongoDB and HDFS retrieved in parallel, as described in Section 4. Figure 6 shows the performance measurements on queries of the first test case, executing joins between LINEITEM and ORDERS tables in any configuration of pairs between the three data stores.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9887704849243164}, "created": {"value": false, "score": 1.5497207641601562e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 18, "offsetEnd": 25}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 18, "offsetEnd": 30}, "context": "Hadoop MapReduce, Apache Spark, or Apache Flink), specialized for different kinds of data and tasks and able to scale and perform orders of magnitude better than traditional relational DBMS. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 19, "offsetEnd": 28}, "context": "Without bind join, Spark SQL shows a slight advantage compared to LeanXcale DQE, which is explainable by the overhead of the JavaScript interpreting that takes place at DQE wrappers for MongoDB. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.004089474678039551}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 19, "offsetEnd": 32}, "context": "At this point, the ShardedCursor object does not yet initiate the query execution, but only memorizes the query filter object.", "mentionContextAttributes": {"used": {"value": false, "score": 0.011867344379425049}, "created": {"value": false, "score": 2.288818359375e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 20, "offsetEnd": 29}, "context": "For comparison with Spark SQL, the CLICKS dataset was loaded as an HDFS file in order to be accessible by Spark.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9945706725120544}, "created": {"value": false, "score": 1.1086463928222656e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 23, "offsetEnd": 30}, "context": "Spark SQL can access a MongoDB cluster through its MongoDB connector that maps a sharded document collection to a DataFrame, partitioned as per the collection's sharding setup.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014118552207946777}, "created": {"value": false, "score": 2.2649765014648438e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 25, "offsetEnd": 34}, "context": "When LINEITEM resides at LeanXcale, the performance is highest, as the query engine processes it natively.", "mentionContextAttributes": {"used": {"value": false, "score": 0.018893957138061523}, "created": {"value": false, "score": 9.298324584960938e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 25, "offsetEnd": 38}, "context": "And since an instance of ShardedCursor is created at every worker, this allows for the parallel assignment of different shards.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00019127130508422852}, "created": {"value": false, "score": 0.005516111850738525}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 26, "offsetEnd": 35}, "context": "The research performed by LeanXcale authors has been also partially funded by the Madrid Regional Council, FSE and FEDER, project Cloud4BigData (S2013TIC2894) and industrial doctorate grant for Pavlos Kranas (IND2017/TIC-7829) and the Ministry of Economy and Competitiveness (MINECO) under projectCloudDB (TIN2016-80350).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9969287514686584}, "created": {"value": false, "score": 1.609325408935547e-05}, "shared": {"value": false, "score": 1.7881393432617188e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 28, "offsetEnd": 35}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MPP", "normalizedForm": "MPP", "offsetStart": 29, "offsetEnd": 32}, "context": "Impala [3] is an open-source MPP SQL engine operating over Hadoop data processing environment. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014813542366027832}, "created": {"value": false, "score": 1.2993812561035156e-05}, "shared": {"value": false, "score": 0.0005882978439331055}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0014813542366027832}, "created": {"value": false, "score": 1.2993812561035156e-05}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 29, "offsetEnd": 39}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "The polyglot approach of the CloudMdsQL query language allows data store native queries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.650520324707031e-05}, "created": {"value": false, "score": 0.00010418891906738281}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 30, "offsetEnd": 37}, "context": "For the purpose, we created a MongoDB nested document collection named Orders_Items, where we combined the ORDERS and LINEITEM datasets as follows.", "mentionContextAttributes": {"used": {"value": false, "score": 0.35624414682388306}, "created": {"value": true, "score": 0.9995753169059753}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 34, "offsetEnd": 44}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "For example, the following simple CloudMdsQL query contains two subqueries, defined by the named table expressions T1 and T2, and addressed respectively against the data stores rdb (an SQL database) and mongo (a MongoDB database): T1(x int, y int)@rdb = (SELECT x, y FROM A) T2(x int, z array)@mongo = {* return db.A.find( {x: {$lt: 10}}, {x:1, z:1} ); *} SELECT T1.x, T2.z ", "mentionContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 35, "offsetEnd": 44}, "context": "The experimental evaluation of the LeanXcale parallel query engine on various join queries illustrates well the performance benefits of exploiting the parallelism of the underlying data management technologies in combination with the high expressivity provided by their scripting/querying frameworks.", "mentionContextAttributes": {"used": {"value": false, "score": 0.19577383995056152}, "created": {"value": false, "score": 0.0008146166801452637}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Flink", "normalizedForm": "Apache Flink", "offsetStart": 35, "offsetEnd": 47}, "context": "Hadoop MapReduce, Apache Spark, or Apache Flink), specialized for different kinds of data and tasks and able to scale and perform orders of magnitude better than traditional relational DBMS. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.0008356571197509766}, "shared": {"value": false, "score": 3.5762786865234375e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 36, "offsetEnd": 43}, "context": "The full scripting functionality of MongoDB JavaScript library is still provided, but in case parallel execution constraints fail, the execution falls back to a sequential one. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.002060830593109131}, "created": {"value": false, "score": 0.0003560781478881836}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 36, "offsetEnd": 44}, "context": "By interfacing wrappers through the DataLake API, the DQE has the possibility to retrieve in parallel disjoint subsets of the result set, much like it does with LeanXcale tables.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0095023512840271}, "created": {"value": false, "score": 6.711483001708984e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 37, "offsetEnd": 44}, "context": "First, the wrapper verifies that the MongoDB balancer is not running in background, because otherwise it may be moving chunks of data across MongoDB shards at the same time the query is being executed, which may result in inconsistent reads.", "mentionContextAttributes": {"used": {"value": false, "score": 0.10765993595123291}, "created": {"value": false, "score": 1.3828277587890625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 38, "offsetEnd": 46}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 40, "offsetEnd": 47}, "context": "For example, Q 1 ML joins LINEITEM from MongoDB with ORDERS from LeanXcale.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0077558159828186035}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 41, "offsetEnd": 50}, "context": "Figure 1 illustrates the architecture of LeanXcale's Distributed Query Engine (DQE). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.2855460047721863}, "created": {"value": false, "score": 0.0009007453918457031}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 41, "offsetEnd": 50}, "context": "All the queries were run on a cluster of LeanXcale DQE instances, running the distributed wrappers for MongoDB and Hive.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 3.170967102050781e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 42, "offsetEnd": 46}, "context": "Therefore, a wrapper instance can use the Hive metastore API to get schema and partitioning information for the subqueried HDFS table and hence to enable iteration on a particular split (shard) of the table.", "mentionContextAttributes": {"used": {"value": false, "score": 0.013434112071990967}, "created": {"value": false, "score": 1.6689300537109375e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 43, "offsetEnd": 50}, "context": "The concept of parallel querying against a MongoDB cluster is built on the assumption that each DQE worker can access directly a MongoDB shard, bypassing the MongoDB router in order to sustain parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023823976516723633}, "created": {"value": false, "score": 0.0005996227264404297}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 43, "offsetEnd": 52}, "context": "All the generated datasets were: loaded in LeanXcale as tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9995315074920654}, "created": {"value": false, "score": 1.4424324035644531e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 45, "offsetEnd": 52}, "context": "The MongoDB storage allows running Drill and MongoDB together in distributed mode, by assigning shards to different drillbits to exploit parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003085136413574219}, "created": {"value": false, "score": 5.8650970458984375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 48, "offsetEnd": 55}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 48, "offsetEnd": 58}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "To illustrate it, let us consider the following CloudMdsQL query:", "mentionContextAttributes": {"used": {"value": false, "score": 0.06672507524490356}, "created": {"value": false, "score": 0.0001843571662902832}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 51, "offsetEnd": 58}, "context": "Spark SQL can access a MongoDB cluster through its MongoDB connector that maps a sharded document collection to a DataFrame, partitioned as per the collection's sharding setup.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014118552207946777}, "created": {"value": false, "score": 2.2649765014648438e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 52, "offsetEnd": 61}, "context": "Section 3 discusses the distributed architecture of LeanXcale query engine. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.004364430904388428}, "created": {"value": false, "score": 0.14781087636947632}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 54, "offsetEnd": 60}, "context": "The DQE initiates the subquery request by passing the script code to each wrapper instance through a call to its init() method. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.20907801389694214}, "created": {"value": false, "score": 7.343292236328125e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.995309054851532}, "created": {"value": false, "score": 7.343292236328125e-05}, "shared": {"value": false, "score": 2.2649765014648438e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 54, "offsetEnd": 60}, "context": "As opposed to typical batch processing frameworks for Hadoop, Impala provides low latency and high concurrency for analytical queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.0040740966796875e-05}, "created": {"value": false, "score": 0.0002314448356628418}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.09944546222686768}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 54, "offsetEnd": 63}, "context": "Moreover, joins across any native datasets, including LeanXcale tables, can be applied, exploiting efficient parallel join algorithms.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013780593872070312}, "created": {"value": false, "score": 0.006434619426727295}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Spark", "normalizedForm": "Apache Spark", "offsetStart": 55, "offsetEnd": 67}, "context": "Spark SQL [4] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001703500747680664}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00022071599960327148}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark SQL", "normalizedForm": "Spark SQL", "offsetStart": 56, "offsetEnd": 65}, "context": "Figure 8 shows the times for processing Q3 queries with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 8.821487426757812e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 0.016927480697631836}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 58, "offsetEnd": 65}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows: db.orders_items.aggregate([{$unwind:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997177720069885}, "created": {"value": false, "score": 2.4437904357910156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 59, "offsetEnd": 65}, "context": "Impala [3] is an open-source MPP SQL engine operating over Hadoop data processing environment. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014813542366027832}, "created": {"value": false, "score": 1.2993812561035156e-05}, "shared": {"value": false, "score": 0.0005882978439331055}}, "documentContextAttributes": {"used": {"value": false, "score": 0.09944546222686768}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 60, "offsetEnd": 67}, "context": "In this section, we introduce the design of the distributed MongoDB wrapper. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.410743713378906e-05}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 61, "offsetEnd": 70}, "context": "Prof. Jose Pereira contributed to this work when he was with LeanXcale.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006512999534606934}, "created": {"value": false, "score": 0.014644443988800049}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Impala", "normalizedForm": "Impala", "offsetStart": 62, "offsetEnd": 68}, "context": "As opposed to typical batch processing frameworks for Hadoop, Impala provides low latency and high concurrency for analytical queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.0040740966796875e-05}, "created": {"value": false, "score": 0.0002314448356628418}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache Derby", "normalizedForm": "Apache Derby", "offsetStart": 62, "offsetEnd": 74}, "context": "The LeanXcale database has derived its OLAP query engine from Apache Derby, a Java-based open-source SQL database. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9671032428741455}, "created": {"value": false, "score": 7.987022399902344e-05}, "shared": {"value": false, "score": 7.37905502319336e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9671032428741455}, "created": {"value": false, "score": 0.0002231001853942871}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 64, "offsetEnd": 73}, "context": "In this paper, we introduce the distributed architecture of the LeanXcale query engine that processes polyglot queries in the CloudMdsQL query language, yet allowing native scripts to be handled in parallel at data store shards, so that efficient and scalable parallel joins take place at the query engine level. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.520748138427734e-05}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 65, "offsetEnd": 74}, "context": "For example, Q 1 ML joins LINEITEM from MongoDB with ORDERS from LeanXcale.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0077558159828186035}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 66, "offsetEnd": 73}, "context": "The findSharded() method accepts the same arguments as the native MongoDB find() operator, in order to provide the native flexible querying functionality, complemented with the ability to handle parallel iteration on the sharded result set.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013506412506103516}, "created": {"value": false, "score": 4.076957702636719e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 66, "offsetEnd": 75}, "context": "Without bind join, Spark SQL shows a slight advantage compared to LeanXcale DQE, which is explainable by the overhead of the JavaScript interpreting that takes place at DQE wrappers for MongoDB. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.004089474678039551}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 67, "offsetEnd": 71}, "context": "We assume that each accessed HDFS file is registered as table in a Hive metastore.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9806443452835083}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 67, "offsetEnd": 74}, "context": "This allows data store native subqueries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration statements.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016188621520996094}, "created": {"value": false, "score": 0.0001990199089050293}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00016188621520996094}, "created": {"value": false, "score": 0.0001990199089050293}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 70, "offsetEnd": 76}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.09944546222686768}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 71, "offsetEnd": 78}, "context": "To better illustrate the necessity of enabling user-defined scripts to MongoDB as subqueries, rather than defining SQL mappings to document collections, let us consider the following MongoDB collection orders that has a highly non-relational structure: {order_id: 1, customer: \"ACME\", status: \"O\", items: [ {type: \"book\", title: \"Book1\", author: \"A.Z.\"}, {type: \"phone\", brand: \"Samsung\", os: \"Android\"} ] }, ...", "mentionContextAttributes": {"used": {"value": false, "score": 0.039160966873168945}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 3.337860107421875e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 72, "offsetEnd": 77}, "context": "However, the ability for applying bind join that cannot be handled with Spark SQL gives our approach a significant advantage for selective queries, which is very useful in a wide range of industrial scenarios. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.805492401123047e-05}, "created": {"value": false, "score": 0.0018900632858276367}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 72, "offsetEnd": 81}, "context": "Figure 8 shows the times for processing Q3 queries with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 8.821487426757812e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 74, "offsetEnd": 81}, "context": "All the generated datasets were: loaded in LeanXcale as tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9995315074920654}, "created": {"value": false, "score": 1.4424324035644531e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MyriaL", "normalizedForm": "MyriaL", "offsetStart": 76, "offsetEnd": 82}, "context": "Its extended relational model and the imperativedeclarative hybrid language MyriaL span well all the underlying data models, where rewrite rules apply to transform expressions into specific API calls, queries, etc. for each of the data stores. ", "mentionContextAttributes": {"used": {"value": false, "score": 8.606910705566406e-05}, "created": {"value": false, "score": 0.0021227598190307617}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 8.606910705566406e-05}, "created": {"value": false, "score": 0.0021227598190307617}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 76, "offsetEnd": 83}, "context": "The list of shards is then reported to the DQE scheduler, which assigns one MongoDB shard to each of the workers by calling the setShard() method.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9479722380638123}, "created": {"value": false, "score": 4.506111145019531e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 76, "offsetEnd": 83}, "context": "However, although they enable parallel integration with data clusters (like MongoDB), none of these systems support the combination of massive parallelism with native queries and the optimizability of bind joins, the way the LeanXcale engine does.", "mentionContextAttributes": {"used": {"value": false, "score": 6.818771362304688e-05}, "created": {"value": false, "score": 0.001846611499786377}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 79, "offsetEnd": 89}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "In order to make a document result set fit the relational schema required by a CloudMdsQL query, the user script can further take advantage of the map() and flatMap() operators.", "mentionContextAttributes": {"used": {"value": false, "score": 0.008136987686157227}, "created": {"value": false, "score": 7.486343383789062e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 80, "offsetEnd": 85}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows: db.orders_items.aggregate([{$unwind:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997177720069885}, "created": {"value": false, "score": 2.4437904357910156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 83, "offsetEnd": 90}, "context": "CloudMdsQL [13,15] even allows data store native queries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 4.470348358154297e-05}, "created": {"value": false, "score": 1.4424324035644531e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00016188621520996094}, "created": {"value": false, "score": 0.0001990199089050293}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 88, "offsetEnd": 94}, "context": "Thus, when A.id participates in an equi-join, the values b 1 ,\u2026,b n are provided to the script code through the iterator/list object b_keys (in this context, we refer to the table B as the \"outer\" table, and b_keys as the outer keys).", "mentionContextAttributes": {"used": {"value": false, "score": 0.22072267532348633}, "created": {"value": false, "score": 5.459785461425781e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.995309054851532}, "created": {"value": false, "score": 7.343292236328125e-05}, "shared": {"value": false, "score": 2.2649765014648438e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 88, "offsetEnd": 96}, "context": "A. DataLake API For a particular data store, each DQE worker creates an instance of the DataLake wrapper that is generally used for querying and retrieval of shards of data.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005714297294616699}, "created": {"value": false, "score": 0.00029593706130981445}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive metastore", "normalizedForm": "Hive metastore", "offsetStart": 89, "offsetEnd": 103}, "context": "For HDFS tables, some overhead is added, due to data conversions, communication with the Hive metastore, and possibly accessing HDFS splits through the network. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0026704072952270508}, "created": {"value": false, "score": 3.814697265625e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0026704072952270508}, "created": {"value": false, "score": 3.814697265625e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 90, "offsetEnd": 99}, "context": "Each table is stored as a KiVi table, where the key corresponds to the primary key of the LeanXcale table and all the columns are stored as they are into KiVi columns.", "mentionContextAttributes": {"used": {"value": false, "score": 0.17349380254745483}, "created": {"value": false, "score": 5.900859832763672e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 91, "offsetEnd": 98}, "context": "Document collections are exposed as tables to Presto, keeping schema mappings in a special MongoDB collection.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6295751929283142}, "created": {"value": false, "score": 0.00012600421905517578}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 93, "offsetEnd": 100}, "context": "Subqueries to MongoDB are expressed natively in JavaScript and intermediate result sets from MongoDB and HDFS retrieved in parallel, as described in Section 4. Figure 6 shows the performance measurements on queries of the first test case, executing joins between LINEITEM and ORDERS tables in any configuration of pairs between the three data stores.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9887704849243164}, "created": {"value": false, "score": 1.5497207641601562e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale  Distributed Query Engine (DQE)", "normalizedForm": "LeanXcale Distributed Query Engine (DQE)", "offsetStart": 94, "offsetEnd": 135}, "context": "And to enable the parallel query processing, we incorporated the polyglot approach within the LeanXcale1 Distributed Query Engine (DQE), which provides a scalable database that operates over a standard SQL interface.", "mentionContextAttributes": {"used": {"value": false, "score": 0.015098154544830322}, "created": {"value": true, "score": 0.9595616459846497}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.015098154544830322}, "created": {"value": true, "score": 0.9595616459846497}, "shared": {"value": false, "score": 4.76837158203125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 99, "offsetEnd": 106}, "context": "We focused on parallel joins between a relational table and the result of a JavaScript subquery to MongoDB, but the concept relies on an API that allows its generalization to other script engines and data stores as well.", "mentionContextAttributes": {"used": {"value": false, "score": 0.013481438159942627}, "created": {"value": true, "score": 0.9986296892166138}, "shared": {"value": false, "score": 1.1920928955078125e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 100, "offsetEnd": 104}, "context": "This information is used by the master wrapper, which reports the list of file splits (instances of Hive API's InputSplit class) to the DQE scheduler upon a call to the listShards() method. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.40946561098098755}, "created": {"value": false, "score": 3.0517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 100, "offsetEnd": 113}, "context": "The client library is therefore extended with the following document collection methods that return ShardedCursor and provide the targeted operators (find, map, and flat map) in user scripts.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0025481581687927246}, "created": {"value": false, "score": 0.00027638673782348633}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 101, "offsetEnd": 106}, "context": "For comparison with the state of the art, the large scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 1.33514404296875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 103, "offsetEnd": 110}, "context": "All the queries were run on a cluster of LeanXcale DQE instances, running the distributed wrappers for MongoDB and Hive.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 3.170967102050781e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 103, "offsetEnd": 110}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows: db.orders_items.aggregate([{$unwind:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997177720069885}, "created": {"value": false, "score": 2.4437904357910156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 104, "offsetEnd": 112}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 104, "offsetEnd": 113}, "context": "Presto follows the classical MPP (massively parallel processing) DBMS architecture, which, similarly to LeanXcale, consists of a coordinator, multiple workers and connectors (storage plugins that interface external data stores and provide metadata to the coordinator and data to workers).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010686516761779785}, "created": {"value": false, "score": 0.00010287761688232422}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 106, "offsetEnd": 111}, "context": "For comparison with Spark SQL, the CLICKS dataset was loaded as an HDFS file in order to be accessible by Spark.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9945706725120544}, "created": {"value": false, "score": 1.1086463928222656e-05}, "shared": {"value": false, "score": 1.0728836059570312e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripts", "normalizedForm": "scripts", "offsetStart": 114, "offsetEnd": 121}, "context": "The polyglot approach of the CloudMdsQL query language allows data store native queries to be expressed as inline scripts and combined with regular SQL statements in ad-hoc integration queries. ", "mentionContextAttributes": {"used": {"value": false, "score": 5.650520324707031e-05}, "created": {"value": false, "score": 0.00010418891906738281}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00016188621520996094}, "created": {"value": false, "score": 0.0001990199089050293}, "shared": {"value": false, "score": 2.384185791015625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 115, "offsetEnd": 119}, "context": "All the queries were run on a cluster of LeanXcale DQE instances, running the distributed wrappers for MongoDB and Hive. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 3.170967102050781e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 115, "offsetEnd": 122}, "context": "Here we specifically focus on parallel joins between a relational table and the result of a JavaScript subquery to MongoDB, but the concept relies on an API that allows its generalization to other script engines and data stores as well. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011277198791503906}, "created": {"value": true, "score": 0.9835281372070312}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 115, "offsetEnd": 122}, "context": "Assuming that W 1 is the master worker, it calls the listShards() method of its wrapper instance WR 1 to query the MongoDB router for a list of MongoDB shards (database instances identified by host address and port), where partitions of the lineitem collection are stored.", "mentionContextAttributes": {"used": {"value": false, "score": 0.17443352937698364}, "created": {"value": false, "score": 1.5020370483398438e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 116, "offsetEnd": 125}, "context": "Figure 8 shows the times for processing Q3 queries with Spark SQL, with LeanXcale without using bind join, and with LeanXcale using bind join. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9973353743553162}, "created": {"value": false, "score": 8.821487426757812e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 117, "offsetEnd": 124}, "context": "These can range from distributed raw data files, through parallel SQL databases, to sharded NoSQL databases (such as MongoDB, where queries can be expressed as JavaScript programs).", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011730194091796875}, "created": {"value": false, "score": 0.00025719404220581055}, "shared": {"value": false, "score": 1.5497207641601562e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 117, "offsetEnd": 125}, "context": "Each wrapper typically uses the client API of the corresponding data management cluster and implements the following DataLake API methods to be invoked by the query engine in order to provide parallel retrieval of shards (Figure 3).", "mentionContextAttributes": {"used": {"value": false, "score": 0.020277976989746094}, "created": {"value": false, "score": 8.618831634521484e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 118, "offsetEnd": 125}, "context": "In fact, ShardedCursor implements all DataLake API methods and hence serves as a proxy of the API into the JavaScript MongoDB client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0036196112632751465}, "created": {"value": false, "score": 0.0005891323089599609}, "shared": {"value": false, "score": 1.5854835510253906e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 118, "offsetEnd": 125}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 119, "offsetEnd": 126}, "context": "The intermediate data are then cached at the workers and a list of distinct values for the UID column is pushed to the MongoDB wrapper instances, to form the bind join condition. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.999900221824646}, "created": {"value": false, "score": 7.033348083496094e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoCursor", "normalizedForm": "MongoCursor", "offsetStart": 120, "offsetEnd": 131}, "context": "To support parallel data retrieval, we further enhance the client library with JavaScript primitives that wrap standard MongoCursor objects (usually returned by a MongoDB JavaScript query) in ShardedCursor objects, which are aware of the sharding of the underlying dataset. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00024813413619995117}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00024813413619995117}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 2.2649765014648438e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 126, "offsetEnd": 133}, "context": "Furthermore, we aim at processing this join in the most efficient way, i.e. in parallel, by allowing parallel handling of the MongoDB subquery and parallel retrieval of its result set.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001226663589477539}, "created": {"value": true, "score": 0.9474247694015503}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 126, "offsetEnd": 136}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "In this paper, we introduce the distributed architecture of the LeanXcale query engine that processes polyglot queries in the CloudMdsQL query language, yet allowing native scripts to be handled in parallel at data store shards, so that efficient and scalable parallel joins take place at the query engine level. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.520748138427734e-05}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 127, "offsetEnd": 134}, "context": "Note that, as opposed to the behavior of the original find() method, a call to findSharded() does not immediately initiate the MongoDB subquery execution, but only memorizes the filter condition (the method argument), if any, in the returned ShardedCursor object.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 3.1113624572753906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 127, "offsetEnd": 135}, "context": "The query engine architecture is therefore extended to access in parallel shards of the external data store through the use of DataLake distributed wrappers that hide the complexity of the underlying data stores' query/scripting languages and encapsulate their interfaces under a common DataLake API to be interfaced by the query engine. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006234049797058105}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.172325134277344e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 129, "offsetEnd": 136}, "context": "The concept of parallel querying against a MongoDB cluster is built on the assumption that each DQE worker can access directly a MongoDB shard, bypassing the MongoDB router in order to sustain parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023823976516723633}, "created": {"value": false, "score": 0.0005996227264404297}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 131, "offsetEnd": 140}, "context": "The data itself is stored on a proprietary relational key-value store, KiVi, which allows for efficient horizontal partitioning of LeanXcale tables and indexes, based on the primary key or index key. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.2295488715171814}, "created": {"value": false, "score": 0.00048410892486572266}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 132, "offsetEnd": 142}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "To preserve the expressivity of the underlying data stores' query/scripting languages, we use the polyglot approach provided by the CloudMdsQL query language, which also enables the use of bind joins to optimize the execution of selective queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.08206576108932495}, "created": {"value": false, "score": 0.0009074211120605469}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 135, "offsetEnd": 142}, "context": "Since MongoDB collections are used directly in the FROM clause as tables, the storage plugin translates relational operators to native MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.09908062219619751}, "created": {"value": false, "score": 1.1801719665527344e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 136, "offsetEnd": 141}, "context": "Spark SQL provides a DataFrame API that can map to relations arbitrary object collections and thus enables relational operations across Spark's RDDs and external data sources.", "mentionContextAttributes": {"used": {"value": false, "score": 8.463859558105469e-05}, "created": {"value": false, "score": 0.0007729530334472656}, "shared": {"value": false, "score": 1.430511474609375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop MapReduce", "normalizedForm": "Hadoop MapReduce", "offsetStart": 136, "offsetEnd": 152}, "context": "Impala can access MongoDB collections through a MongoDB connector for Hadoop, designed to provide the ability to read MongoDB data into Hadoop MapReduce jobs.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0019540786743164062}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 138, "offsetEnd": 145}, "context": "For comparison with the state of the art, the large scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 1.33514404296875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 138, "offsetEnd": 147}, "context": "Query Q 2 M evaluates just the parallel execution of the BookOrders script, while Q 2 ML involves a join with the CUSTOMER table from the LeanXcale data store: Figure 7 shows the performance measurements of Q 2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": false, "score": 0.26770633459091187}, "created": {"value": false, "score": 4.5299530029296875e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 140, "offsetEnd": 147}, "context": "As our work fits in this category, we will briefly discuss some of the existing solutions, focusing on their capabilities to integrate with MongoDB as a representative example of a nonrelational data store.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016224384307861328}, "created": {"value": true, "score": 0.999244213104248}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 141, "offsetEnd": 148}, "context": "First, the wrapper verifies that the MongoDB balancer is not running in background, because otherwise it may be moving chunks of data across MongoDB shards at the same time the query is being executed, which may result in inconsistent reads. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.10765993595123291}, "created": {"value": false, "score": 1.3828277587890625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 142, "offsetEnd": 151}, "context": "At this point, the DQE is ready to involve the partitioned intermediate relation LINEITEM in the execution of a parallel join with the native LeanXcale partitioned table ORDERS.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0024389028549194336}, "created": {"value": false, "score": 0.0007367730140686035}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 144, "offsetEnd": 151}, "context": "Assuming that W 1 is the master worker, it calls the listShards() method of its wrapper instance WR 1 to query the MongoDB router for a list of MongoDB shards (database instances identified by host address and port), where partitions of the lineitem collection are stored.", "mentionContextAttributes": {"used": {"value": false, "score": 0.17443352937698364}, "created": {"value": false, "score": 1.5020370483398438e-05}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 144, "offsetEnd": 153}, "context": "Q 3 performs a join between a 600GB version of the Orders_Items collection (containing ~770 million documents and ~3 billion order items) and a LeanXcale table CLICKS of size 1TB, containing ~6 billion click log records.", "mentionContextAttributes": {"used": {"value": false, "score": 0.4707913398742676}, "created": {"value": false, "score": 1.3709068298339844e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 146, "offsetEnd": 151}, "context": "For comparison with the state of the art, the large scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 1.33514404296875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 149, "offsetEnd": 156}, "context": "Let us consider the following modification Q 1 ML of query Q 1 , which assumes that the LINEITEM table resides as a sharded document collection in a MongoDB cluster and the selection on it is expressed by means of the findSharded() JavaScript method, while ORDERS is still a LeanXcale table, the partitions of which are stored in the KV storage layer.", "mentionContextAttributes": {"used": {"value": true, "score": 0.8148874044418335}, "created": {"value": false, "score": 2.384185791015625e-06}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hadoop", "normalizedForm": "Hadoop", "offsetStart": 151, "offsetEnd": 157}, "context": "To better illustrate the flow, let us consider another modification Q 1 HL of query Q 1 , which assumes that the LINEITEM table is stored as file in a Hadoop cluster.", "mentionContextAttributes": {"used": {"value": false, "score": 0.09944546222686768}, "created": {"value": false, "score": 8.821487426757812e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.09944546222686768}, "created": {"value": false, "score": 0.0012637972831726074}, "shared": {"value": false, "score": 0.0005882978439331055}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "scripting", "normalizedForm": "scripting", "offsetStart": 152, "offsetEnd": 161}, "language": {"rawForm": "JavaScript", "normalizedForm": "JavaScript", "wikidataId": "Q2005", "offsetStart": 141, "offsetEnd": 151}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 154, "offsetEnd": 164}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 88, "offsetEnd": 97}, "context": "In this paper, we introduced a parallel polyglot polystore system that builds on top of LeanXcale's distributed query engine and processes queries in the CloudMdsQL query language. ", "mentionContextAttributes": {"used": {"value": false, "score": 3.4689903259277344e-05}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 157, "offsetEnd": 164}, "context": "To access a MongoDB cluster, Presto uses a connector that allows the parallel retrieval of sharded collections, which is typically configured with a list of MongoDB servers.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0041727423667907715}, "created": {"value": false, "score": 6.330013275146484e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 158, "offsetEnd": 165}, "context": "The concept of parallel querying against a MongoDB cluster is built on the assumption that each DQE worker can access directly a MongoDB shard, bypassing the MongoDB router in order to sustain parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023823976516723633}, "created": {"value": false, "score": 0.0005996227264404297}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 160, "offsetEnd": 167}, "context": "Thus, a composition of findSharded and map/flatMap (such as in the BookOrders example above) makes a user script expressive enough, so as to request a specific MongoDB dataset, retrieve the result set in parallel, and transform it in order to fit the named table signature and further be consumed by relational operators at the DQE level.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0015254616737365723}, "created": {"value": false, "score": 2.2530555725097656e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 161, "offsetEnd": 170}, "context": "By interfacing wrappers through the DataLake API, the DQE has the possibility to retrieve in parallel disjoint subsets of the result set, much like it does with LeanXcale tables.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0095023512840271}, "created": {"value": false, "score": 6.711483001708984e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 163, "offsetEnd": 170}, "context": "The SQL table expression T1 is defined by an SQL subquery, while T2 is a native expression (identified by the special bracket symbols {* *}) expressed as a native MongoDB call.", "mentionContextAttributes": {"used": {"value": false, "score": 0.06272470951080322}, "created": {"value": false, "score": 1.430511474609375e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 163, "offsetEnd": 170}, "context": "To support parallel data retrieval, we further enhance the client library with JavaScript primitives that wrap standard MongoCursor objects (usually returned by a MongoDB JavaScript query) in ShardedCursor objects, which are aware of the sharding of the underlying dataset.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00024813413619995117}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CloudMdsQL", "normalizedForm": "CloudMdsQL", "offsetStart": 168, "offsetEnd": 178}, "publisher": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale"}, "context": "To enable ad-hoc querying of an arbitrary data set, using its scripting mechanism, and then joining the retrieved result set at DQE level, DQE processes queries in the CloudMdsQL query language, where scripts are wrapped as native subqueries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.002761244773864746}, "created": {"value": false, "score": 8.654594421386719e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": true, "score": 0.9999302625656128}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 172, "offsetEnd": 179}, "context": "For comparison with the state of the art, the large scale test case queries were also performed on a Spark SQL cluster, where we used the MongoDB Spark connector to access MongoDB shards in parallel.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 1.33514404296875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 174, "offsetEnd": 181}, "context": "The definition of the named table is hence slightly modified, to allow for the bind join to apply early filtering to reduce significantly the amount of data processed by the MongoDB JavaScript subquery: The query executes by first applying the filter and retrieving intermediate data from the CLICKS table, which is not indexed, therefore a full scan takes place. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.06650972366333008}, "created": {"value": false, "score": 5.602836608886719e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 175, "offsetEnd": 179}, "context": "All the generated datasets were: loaded in LeanXcale as tables; loaded in MongoDB as document collections; copied to the HDFS cluster as raw CSV files, to be accessed through Hive as tables. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9995315074920654}, "created": {"value": false, "score": 1.4424324035644531e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 175, "offsetEnd": 182}, "context": "A scripting expression can either yield tuples to its result set (like a user-defined table function) or return an iterable object that represents the result set (like in the MongoDB example above).", "mentionContextAttributes": {"used": {"value": false, "score": 0.00014066696166992188}, "created": {"value": false, "score": 9.02414321899414e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 176, "offsetEnd": 183}, "context": "To run an analogue of the BookOrders subquery through the MongoDB connector for Spark SQL, we used the MongoDB aggregation framework against the same sharded collection in our MongoDB cluster as follows: db.orders_items.aggregate([{$unwind:", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997177720069885}, "created": {"value": false, "score": 2.4437904357910156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 179, "offsetEnd": 186}, "context": "The distributed wrapper for MongoDB comprises a number of instances of a Java class that implements the DataLake API, each of which embeds a JavaScript scripting engine that uses MongoDB's JavaScript client library. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0017823576927185059}, "shared": {"value": false, "score": 4.649162292480469e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Hive", "normalizedForm": "Hive", "offsetStart": 180, "offsetEnd": 184}, "context": "To schedule parallel retrieval of the LINEITEM table, the DQE redirects the subquery to the HDFS wrapper, preliminarily configured to associate the @hdfs alias with the URI of the Hive metastore, which specifies how the file is parsed and split.", "mentionContextAttributes": {"used": {"value": false, "score": 0.1626644730567932}, "created": {"value": false, "score": 1.7881393432617188e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": false, "score": 0.00011479854583740234}, "shared": {"value": false, "score": 5.602836608886719e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 183, "offsetEnd": 190}, "context": "To better illustrate the necessity of enabling user-defined scripts to MongoDB as subqueries, rather than defining SQL mappings to document collections, let us consider the following MongoDB collection orders that has a highly non-relational structure: {order_id: 1, customer: \"ACME\", status: \"O\", items: [ {type: \"book\", title: \"Book1\", author: \"A.Z.\"}, {type: \"phone\", brand: \"Samsung\", os: \"Android\"} ] }, ...", "mentionContextAttributes": {"used": {"value": false, "score": 0.039160966873168945}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 3.337860107421875e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 183, "offsetEnd": 190}, "context": "A query that needs to return a table listing the title and author of all books ordered by a given customer, would be defined by means of a flatMap operator in JavaScript, following a MongoDB find() operator.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9691949486732483}, "created": {"value": false, "score": 3.3855438232421875e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 185, "offsetEnd": 192}, "context": "This delayed iteration approach allows the DQE to internally manipulate the cursor object before the actual iteration takes place, e.g. to redirect the subquery execution to a specific MongoDB shard.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014397501945495605}, "created": {"value": false, "score": 0.0002637505531311035}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 186, "offsetEnd": 193}, "context": "Without bind join, Spark SQL shows a slight advantage compared to LeanXcale DQE, which is explainable by the overhead of the JavaScript interpreting that takes place at DQE wrappers for MongoDB.", "mentionContextAttributes": {"used": {"value": false, "score": 0.004089474678039551}, "created": {"value": false, "score": 6.67572021484375e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 192, "offsetEnd": 200}, "context": "The distributed HDFS wrapper is designed to access in parallel tables stored as HDFS files, thus providing the typical functionality of a tightly-coupled polystore, but through the use of the DataLake API.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001202225685119629}, "created": {"value": false, "score": 0.0014584064483642578}, "shared": {"value": false, "score": 1.0848045349121094e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 192, "offsetEnd": 205}, "context": "To support parallel data retrieval, we further enhance the client library with JavaScript primitives that wrap standard MongoCursor objects (usually returned by a MongoDB JavaScript query) in ShardedCursor objects, which are aware of the sharding of the underlying dataset.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00024813413619995117}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 197, "offsetEnd": 204}, "context": "This, however, forces the DQE to define certain constraints for parallel processing of document collection subqueries, in order to guarantee consistent results, which is normally guaranteed by the MongoDB router. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0017469525337219238}, "created": {"value": false, "score": 0.000277101993560791}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script engines", "normalizedForm": "script engines", "offsetStart": 197, "offsetEnd": 211}, "context": "Here we specifically focus on parallel joins between a relational table and the result of a JavaScript subquery to MongoDB, but the concept relies on an API that allows its generalization to other script engines and data stores as well. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011277198791503906}, "created": {"value": true, "score": 0.9835281372070312}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00011277198791503906}, "created": {"value": true, "score": 0.9835281372070312}, "shared": {"value": false, "score": 9.5367431640625e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 212, "offsetEnd": 219}, "context": "For example, the following simple CloudMdsQL query contains two subqueries, defined by the named table expressions T1 and T2, and addressed respectively against the data stores rdb (an SQL database) and mongo (a MongoDB database): T1(x int, y int)@rdb = (SELECT x, y FROM A) T2(x int, z array)@mongo = {* return db.A.find( {x: {$lt: 10}}, {x:1, z:1} ); *} SELECT T1.x, T2.z", "mentionContextAttributes": {"used": {"value": true, "score": 0.7434490323066711}, "created": {"value": false, "score": 2.2649765014648438e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 225, "offsetEnd": 234}, "context": "However, although they enable parallel integration with data clusters (like MongoDB), none of these systems support the combination of massive parallelism with native queries and the optimizability of bind joins, the way the LeanXcale engine does.", "mentionContextAttributes": {"used": {"value": false, "score": 6.818771362304688e-05}, "created": {"value": false, "score": 0.001846611499786377}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Spark", "normalizedForm": "Spark", "offsetStart": 234, "offsetEnd": 239}, "context": "Spark SQL [4] is a parallel SQL engine built on top of Apache Spark and designed to provide tight integration between relational and procedural processing through a declarative API that integrates relational operators with procedural Spark code, taking advantage of massive parallelism.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001703500747680664}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": false, "score": 0.016927361488342285}, "shared": {"value": false, "score": 2.7418136596679688e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ShardedCursor", "normalizedForm": "ShardedCursor", "offsetStart": 242, "offsetEnd": 255}, "context": "Note that, as opposed to the behavior of the original find() method, a call to findSharded() does not immediately initiate the MongoDB subquery execution, but only memorizes the filter condition (the method argument), if any, in the returned ShardedCursor object.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 3.1113624572753906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05411183834075928}, "created": {"value": false, "score": 0.08591103553771973}, "shared": {"value": false, "score": 1.5854835510253906e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 275, "offsetEnd": 284}, "context": "Let us consider the following modification Q 1 ML of query Q 1 , which assumes that the LINEITEM table resides as a sharded document collection in a MongoDB cluster and the selection on it is expressed by means of the findSharded() JavaScript method, while ORDERS is still a LeanXcale table, the partitions of which are stored in the KV storage layer.", "mentionContextAttributes": {"used": {"value": true, "score": 0.814887523651123}, "created": {"value": false, "score": 2.384185791015625e-06}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "DataLake", "normalizedForm": "DataLake", "offsetStart": 287, "offsetEnd": 295}, "context": "The query engine architecture is therefore extended to access in parallel shards of the external data store through the use of DataLake distributed wrappers that hide the complexity of the underlying data stores' query/scripting languages and encapsulate their interfaces under a common DataLake API to be interfaced by the query engine.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006234049797058105}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.172325134277344e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.05950486660003662}, "created": {"value": false, "score": 0.0038558244705200195}, "shared": {"value": false, "score": 4.649162292480469e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "LeanXcale", "normalizedForm": "LeanXcale", "offsetStart": 346, "offsetEnd": 355}, "context": "Query Q 2 M evaluates just the parallel execution of the BookOrders script, while Q 2 ML involves a join with the CUSTOMER table from the LeanXcale data store: Figure 7 shows the performance measurements of Q 2 queries that stress on the evaluation of the parallel processing of highly expressive JavaScript queries, with and without join with a LeanXcale table.", "mentionContextAttributes": {"used": {"value": false, "score": 0.26770609617233276}, "created": {"value": false, "score": 4.5299530029296875e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.999947190284729}, "created": {"value": true, "score": 0.999883770942688}, "shared": {"value": false, "score": 7.37905502319336e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 463, "offsetEnd": 470}, "context": "Assuming that the distinct values of B.id are b 1 \u2026 b n , the query to retrieve the righthand side relation of the bind join uses the following SQL approach (or its equivalent according to the data store's query language), thus retrieving from A only the rows that match the join criteria: The way to do the bind join analogue for native queries is through the use of a JOINED ON clause in the named table signature, like in the named table A below, defined as a MongoDB script.", "mentionContextAttributes": {"used": {"value": true, "score": 0.995309054851532}, "created": {"value": false, "score": 2.6226043701171875e-06}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999759197235107}, "created": {"value": true, "score": 0.9999129772186279}, "shared": {"value": false, "score": 9.059906005859375e-05}}}, {"type": "software", "software-type": "implicit", "software-name": {"rawForm": "script", "normalizedForm": "script", "offsetStart": 471, "offsetEnd": 477}, "context": "Assuming that the distinct values of B.id are b 1 \u2026 b n , the query to retrieve the righthand side relation of the bind join uses the following SQL approach (or its equivalent according to the data store's query language), thus retrieving from A only the rows that match the join criteria: The way to do the bind join analogue for native queries is through the use of a JOINED ON clause in the named table signature, like in the named table A below, defined as a MongoDB script. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.995309054851532}, "created": {"value": false, "score": 2.6226043701171875e-06}, "shared": {"value": false, "score": 2.2649765014648438e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.995309054851532}, "created": {"value": false, "score": 7.343292236328125e-05}, "shared": {"value": false, "score": 2.2649765014648438e-06}}}], "references": [], "runtime": 14381, "id": "bea7c1a8c4e514eb24cb222c9a2780581522e763", "metadata": {"id": "bea7c1a8c4e514eb24cb222c9a2780581522e763"}, "original_file_path": "../../datalake/Samuel/SOFTware-Sync/downloads/xml/lirmm-01921718.grobid.tei.xml", "file_name": "lirmm-01921718.grobid.tei.xml"}