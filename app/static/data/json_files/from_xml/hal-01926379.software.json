{"application": "software-mentions", "version": "0.8.0", "date": "2024-10-07T12:45+0000", "md5": "7D56CA2E16542F5657FAF305556A5F63", "mentions": [{"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 0, "offsetEnd": 5}, "context": "Morph-xR2RML is the prototype implementation we developped to evaluate the effectiveness of the xR2RML mapping language and the SPARQL-to-MongoDB method proposed in this paper.", "mentionContextAttributes": {"used": {"value": false, "score": 7.641315460205078e-05}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 0, "offsetEnd": 5}, "context": "Morph-xR2RML is available on GitHub9 under the Apache 2.0 license, it is written in the Scala programming language.", "mentionContextAttributes": {"used": {"value": false, "score": 0.022618770599365234}, "created": {"value": false, "score": 0.00012445449829101562}, "shared": {"value": true, "score": 0.8194966912269592}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 0, "offsetEnd": 5}, "context": "Morph-xR2RML relies on several open-source Java APIs, the most salient ones are listed here.", "mentionContextAttributes": {"used": {"value": false, "score": 0.029741764068603516}, "created": {"value": false, "score": 1.3232231140136719e-05}, "shared": {"value": false, "score": 0.0013640522956848145}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 0, "offsetEnd": 5}, "context": "Morph-xR2RML retrieves JSON documents from Jongo as Java strings in order to evaluate them with JSONPath expressions.", "mentionContextAttributes": {"used": {"value": false, "score": 0.39713233709335327}, "created": {"value": false, "score": 1.7881393432617188e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 0, "offsetEnd": 6}, "context": "SPARQL rewriting methods reviewed in section 2 generally adopt a bottom-up approach where, typically, a SPARQL FIL-TER translates into an encapsulating query (e.g. a SELECT-WHERE clause in the case of SQL).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0002289414405822754}, "created": {"value": false, "score": 8.189678192138672e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 0, "offsetEnd": 6}, "context": "SPARQL query Q 2 , depicted in Listing 1.3, contains the graph pattern gp 2 that consists of three triple patterns tp 1 , tp 2 and tp 3 , and a filter consisting of the conjunction of two conditions c 1 and c 2 :", "mentionContextAttributes": {"used": {"value": true, "score": 0.537365198135376}, "created": {"value": false, "score": 1.8477439880371094e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 0, "offsetEnd": 6}, "context": "SPARQL query Q2", "mentionContextAttributes": {"used": {"value": false, "score": 0.09741741418838501}, "created": {"value": false, "score": 4.887580871582031e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 0, "offsetEnd": 6}, "context": "SPARQL-to-SQL methods proposed various SQL query optimizations such as [39,32,14].", "mentionContextAttributes": {"used": {"value": false, "score": 0.0138167142868042}, "created": {"value": false, "score": 0.022350192070007324}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 0, "offsetEnd": 6}, "context": "SPARQL 1.0 filters come with a broad set of conditional expressions including logical comparisons, literal manipulation expressions (string, numerical, boolean), XPath constructor functions, casting functions for additional data types of the RDF data model, and SPARQL built-in functions (lang, langmatches, datatype, bound, sameTerm, isIRI, isURI, isBlank, isLiteral, regex ).", "mentionContextAttributes": {"used": {"value": false, "score": 0.005820035934448242}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 0, "offsetEnd": 6}, "version": {"rawForm": "9.0", "normalizedForm": "9.0"}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "TAXREF [15] is the French national taxonomic register for fauna, flora and fungus, maintained and distributed by the French National Museum of Natural History (MNHN).", "mentionContextAttributes": {"used": {"value": false, "score": 0.31194907426834106}, "created": {"value": false, "score": 3.0875205993652344e-05}, "shared": {"value": false, "score": 1.1086463928222656e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15, "offsetStart": 62451, "offsetEnd": 62455}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 0, "offsetEnd": 6}, "context": "SPARQL query Q 7 , depicted below, looks for taxa (variable ?t) that are present in the overseas collectivity of Saint-Pierre-et-Miquelon (http://sws.geonames.org/3424932/).", "mentionContextAttributes": {"used": {"value": false, "score": 0.024929583072662354}, "created": {"value": false, "score": 5.245208740234375e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 0, "offsetEnd": 7}, "context": "MongoDB comes with a rich set of APIs to allow applications to query a database in an imperative way. ", "mentionContextAttributes": {"used": {"value": false, "score": 2.300739288330078e-05}, "created": {"value": false, "score": 0.0018894672393798828}, "shared": {"value": false, "score": 3.933906555175781e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 0, "offsetEnd": 7}, "context": "MongoDB collection \"people\" containing two documents respectively <#Knows>, is a MongoDB query that retrieves documents having a non-null emails field, respectively a contacts array field with at least one element.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0028051137924194336}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 0, "offsetEnd": 7}, "context": "MongoDB find queries do not support joins.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005042016506195068}, "created": {"value": false, "score": 2.6226043701171875e-06}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 0, "offsetEnd": 7}, "context": "MongoDB comes with a native Java API 11 that allows for imperative style querying only.", "mentionContextAttributes": {"used": {"value": false, "score": 3.2067298889160156e-05}, "created": {"value": false, "score": 0.0004437565803527832}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 0, "offsetEnd": 8}, "context": "JSONPath expressions for MongoDB) that must be projected.", "mentionContextAttributes": {"used": {"value": false, "score": 0.01938718557357788}, "created": {"value": false, "score": 9.298324584960938e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoGraph", "normalizedForm": "MongoGraph", "offsetStart": 0, "offsetEnd": 10}, "context": "MongoGraph 5 is an extension of the AllegroGraph triple store to query arbitrary MongoDB documents with SPARQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00136643648147583}, "created": {"value": false, "score": 5.626678466796875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00136643648147583}, "created": {"value": false, "score": 5.626678466796875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 2, "offsetEnd": 8}, "context": "A SPARQL query and an R2RML mapping graph are translated into a Datalog program.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9479452967643738}, "created": {"value": false, "score": 0.00011205673217773438}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 2, "offsetEnd": 8}, "context": "A SPARQL 1.0 graph pattern is rewritten into an abstract expression exhibiting operators of the abstract query language.", "mentionContextAttributes": {"used": {"value": false, "score": 0.007620453834533691}, "created": {"value": false, "score": 0.0002422928810119629}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 2, "offsetEnd": 8}, "context": "A SPARQL query is rewritten into relational algebra (RA) query, and RA expressions over the relational view are translated into MongoDB aggregate queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5742892026901245}, "created": {"value": false, "score": 3.814697265625e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 4, "offsetEnd": 11}, "context": "The MongoDB engine and the Morph-xR2RML Java virtual machine alike were running on the same server. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9979150891304016}, "created": {"value": false, "score": 2.682209014892578e-05}, "shared": {"value": false, "score": 2.86102294921875e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 4, "offsetEnd": 11}, "context": "The MongoDB find query method takes two arguments formatted as JSON documents.", "mentionContextAttributes": {"used": {"value": false, "score": 0.02203226089477539}, "created": {"value": false, "score": 2.6226043701171875e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 4, "offsetEnd": 11}, "context": "The MongoDB documentation provides a rich description of the find query that however lacks precision as to the formal semantics of some operators.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00026339292526245117}, "created": {"value": false, "score": 7.164478302001953e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 6, "offsetEnd": 11}, "context": "Since Morph-xR2RML relies on the Jongo API to process a MongoDB query, we also measured the time needed by Jongo to parse the query, pass it on to MongoDB and retrieve the results from MongoDB.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999884843826294}, "created": {"value": false, "score": 3.4332275390625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 7, "offsetEnd": 13}, "context": "4 From SPARQL to Abstract Queries Section 2 emphasized that SPARQL rewriting methods for SQL or XQuery rely on prior knowledge about the target query language expressiveness.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 2.181529998779297e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 8, "offsetEnd": 15}, "context": "a valid MongoDB query, i.e.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7601473927497864}, "created": {"value": false, "score": 4.76837158203125e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 9, "offsetEnd": 16}, "context": "Besides, MongoDB has become a popular NoSQL actor in recent years.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006734132766723633}, "created": {"value": false, "score": 0.0031249523162841797}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 10, "offsetEnd": 17}, "context": "(iii) The MongoDB $where operator passes a JavaScript expression or function to the query system.", "mentionContextAttributes": {"used": {"value": false, "score": 0.14733368158340454}, "created": {"value": false, "score": 1.5139579772949219e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 11, "offsetEnd": 17}, "context": "Firstly, a SPARQL query is translated into a pivot abstract query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04195624589920044}, "created": {"value": false, "score": 7.343292236328125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 13, "offsetEnd": 19}, "context": "Typically, a SPARQL FILTER is translated into an encapsulating For-Let-Where XQuery clause.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008735060691833496}, "created": {"value": false, "score": 1.2040138244628906e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 13, "offsetEnd": 19}, "context": "Dealing with SPARQL filters.", "mentionContextAttributes": {"used": {"value": false, "score": 0.014264285564422607}, "created": {"value": false, "score": 2.9921531677246094e-05}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 13, "offsetEnd": 19}, "context": "In turn, the SPARQL rewriting process must handle conditions on JSONPath expressions.", "mentionContextAttributes": {"used": {"value": false, "score": 0.07729023694992065}, "created": {"value": false, "score": 1.8358230590820312e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 14, "offsetEnd": 20}, "context": "For instance, SPARQL2XQuery [4] relies on the ability of XQuery to support joins, nested queries and complex filtering.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00012755393981933594}, "created": {"value": false, "score": 8.58306884765625e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4, "offsetStart": 9632, "offsetEnd": 9635}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4, "offsetStart": 9632, "offsetEnd": 9635}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 15, "offsetEnd": 22}, "context": "In the case of MongoDB, the processing of joins is shifted to the query processing engine, and can ensue poor performances when joined sub-queries are not selective enough.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005235075950622559}, "created": {"value": false, "score": 7.176399230957031e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 17, "offsetEnd": 24}, "context": "In addition, the MongoDB interactive interface defines a JSON-based declarative query language consisting of two query methods. ", "mentionContextAttributes": {"used": {"value": false, "score": 6.80685043334961e-05}, "created": {"value": false, "score": 0.0011358261108398438}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 18, "offsetEnd": 24}, "context": "After a review of SPARQL query rewriting approaches in section 2, we quickly remind the principles and main features of the xR2RML mapping language in section 3.", "mentionContextAttributes": {"used": {"value": false, "score": 0.11450904607772827}, "created": {"value": false, "score": 0.0010554194450378418}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 18, "offsetEnd": 24}, "context": "Let us consider a SPARQL filter f as a conjunction of n conditions (n \u2265 1): C1 \u2227 ... Cn.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9482345581054688}, "created": {"value": false, "score": 9.655952453613281e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 18, "offsetEnd": 24}, "context": "-Can we rewrite a SPARQL graph pattern in a way that facilitates the production of an efficient abstract query?", "mentionContextAttributes": {"used": {"value": false, "score": 0.00016486644744873047}, "created": {"value": false, "score": 0.319685697555542}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 18, "offsetEnd": 25}, "context": "Let us consider a MongoDB database with a collection people depicted in Listing 1.2: each JSON document provides the identifier, email addresses and contacts of a person; contacts are identified by their email addresses.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005258679389953613}, "created": {"value": false, "score": 0.0001360177993774414}, "shared": {"value": false, "score": 1.6689300537109375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ontop", "normalizedForm": "ontop", "offsetStart": 20, "offsetEnd": 25}, "context": "So far though, this ontop version is not available for test, which hinders possible performance comparison. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001043081283569336}, "created": {"value": false, "score": 0.0008080601692199707}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}, {"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ontop", "normalizedForm": "ontop", "offsetStart": 20, "offsetEnd": 25}, "context": "Furthermore, unlike ontop, xR2RML allows for rich JSONPath expressions to evaluate a JSON document and generate RDF terms.", "mentionContextAttributes": {"used": {"value": false, "score": 6.42538070678711e-05}, "created": {"value": false, "score": 3.1113624572753906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}, {"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 20, "offsetEnd": 27}, "context": "Comparison with the MongoDB-enabled ontop.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": false, "score": 1.5854835510253906e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "XQuery", "normalizedForm": "XQuery", "offsetStart": 21, "offsetEnd": 27}, "context": "For instance, SPARQL2XQuery [4] relies on the ability of XQuery to support joins, nested queries and complex filtering.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00012755393981933594}, "created": {"value": false, "score": 8.58306884765625e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4, "offsetStart": 9632, "offsetEnd": 9635}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4, "offsetStart": 9632, "offsetEnd": 9635}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 21, "offsetEnd": 27}, "context": "The translation of a SPARQL graph pattern into an abstract query consists of four steps, sketched in Fig. 1 and described in the next sub-sections.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00970602035522461}, "created": {"value": false, "score": 6.973743438720703e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 22, "offsetEnd": 28}, "version": {"rawForm": "9.0", "normalizedForm": "9.0"}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "Habitats are coded in TAXREF with integer values, e.g. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9147000312805176}, "created": {"value": false, "score": 7.510185241699219e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 22, "offsetEnd": 28}, "context": "We therefore consider SPARQL filters at the earliest stage: function trans m pushes SPARQL filters down into the translation of each inner query in order to return only necessary intermediate results.", "mentionContextAttributes": {"used": {"value": false, "score": 0.13791906833648682}, "created": {"value": false, "score": 4.3272972106933594e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 22, "offsetEnd": 28}, "context": "When FILTER and LIMIT SPARQL clauses cannot be pushed down in atomic queries, they end up as abstract operators with the same names, FILTER and LIMIT.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005905032157897949}, "created": {"value": false, "score": 8.58306884765625e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 23, "offsetEnd": 29}, "context": "Similar to the case of SPARQL filters, the common bottom-up approach of SQL rewriting methods consists in rewriting a LIMIT into an encapsulating query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011086463928222656}, "created": {"value": false, "score": 6.0439109802246094e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 23, "offsetEnd": 30}, "context": "Botoeva et al. produce MongoDB aggregate queries, with the major advantage of ensuring a semantics-preserving SPARQL-to-MongoDB query translation, thus delegating the whole processing to MongoDB and making the query translation simpler.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010126233100891113}, "created": {"value": false, "score": 0.0009582638740539551}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 24, "offsetEnd": 30}, "context": "Furthermore, real-world SPARQL queries often contain substantial graph patterns with multiple joined triple patterns.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001024007797241211}, "created": {"value": false, "score": 7.748603820800781e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 25, "offsetEnd": 31}, "version": {"rawForm": "9", "normalizedForm": "9", "offsetStart": 33, "offsetEnd": 34}, "url": {"rawForm": "/example", "normalizedForm": "/example", "offsetStart": 106, "offsetEnd": 114}, "context": "xR2RML mapping graph for TAXREF v9: https://github.com/frmichel/morph-xr2rml/blob/master/morph-xr2rml-dist/example ", "mentionContextAttributes": {"used": {"value": false, "score": 0.008655428886413574}, "created": {"value": false, "score": 2.1457672119140625e-06}, "shared": {"value": false, "score": 0.012064814567565918}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 25, "offsetEnd": 31}, "context": "If this is verified, the SPARQL query is rewritten such that the values of the projected variables be provided as an inline solution sequence using the SPARQL 1.1 VALUES clause.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9243999719619751}, "created": {"value": false, "score": 1.1682510375976562e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 25, "offsetEnd": 32}, "context": "We applied xR2RML to the MongoDB NoSQL document store2 and we implemented the graph materialization strategy.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998224377632141}, "created": {"value": true, "score": 0.7723169922828674}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 25, "offsetEnd": 32}, "context": "JSONPath expressions for MongoDB) that must be projected.", "mentionContextAttributes": {"used": {"value": false, "score": 0.01938718557357788}, "created": {"value": false, "score": 9.298324584960938e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 26, "offsetEnd": 32}, "context": "In our attempt to rewrite SPARQL queries in the general case, such optimization are performed earlier, regardless of the target database capabilities.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00726318359375}, "created": {"value": false, "score": 0.027204275131225586}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 26, "offsetEnd": 32}, "context": "A notable difference with SPARQL is that, in the tree representation of a query, the leaves of a SPARQL query are triple patterns.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006150007247924805}, "created": {"value": false, "score": 7.95125961303711e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 26, "offsetEnd": 32}, "context": "Let gp be a well-designed SPARQL graph pattern, f be a SPARQL filter and l an integer limit value representing the maximum number of results.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9592442512512207}, "created": {"value": false, "score": 0.0003069639205932617}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 26, "offsetEnd": 32}, "context": "Similarly, we translate a SPARQL query into an abstract representation (that is not relational algebra) under xR2RML mappings.", "mentionContextAttributes": {"used": {"value": false, "score": 0.11644119024276733}, "created": {"value": false, "score": 0.00037026405334472656}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 26, "offsetEnd": 34}, "context": "This occurs with specific JSONPath array slice notations, or in JSONPath expressions assuming that the root document is an array field and not a document field (which is forbidden in MongoDB).", "mentionContextAttributes": {"used": {"value": false, "score": 0.008662819862365723}, "created": {"value": false, "score": 1.1920928955078125e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 27, "offsetEnd": 34}, "context": "Tomaszuk proposed to use a MongoDB database as an RDF triple store [37].", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010606646537780762}, "created": {"value": false, "score": 9.179115295410156e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 27, "offsetEnd": 34}, "context": "<op> stands for one of the MongoDB comparison operators: $eq, $ne, $lt, $lte, $gt, $gte, $size and $regex.", "mentionContextAttributes": {"used": {"value": false, "score": 0.19151932001113892}, "created": {"value": false, "score": 1.9073486328125e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph-xR2", "normalizedForm": "Morph-xR2", "offsetStart": 27, "offsetEnd": 36}, "context": "The MongoDB engine and the Morph-xR2RML Java virtual machine alike were running on the same server. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9979150891304016}, "created": {"value": false, "score": 2.682209014892578e-05}, "shared": {"value": false, "score": 2.86102294921875e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9979150891304016}, "created": {"value": false, "score": 2.682209014892578e-05}, "shared": {"value": false, "score": 2.86102294921875e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 28, "offsetEnd": 34}, "context": "Fig. 3 summarizes the whole SPARQL-to-MongoDB process orchestration, from the graph pattern translation to the subsequent MongoDB queries evaluation and the production of RDF triples.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9730534553527832}, "created": {"value": false, "score": 5.841255187988281e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 29, "offsetEnd": 35}, "context": "A query processor rewrites a SPARQL query into the query language of the target database.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001510024070739746}, "created": {"value": false, "score": 4.6133995056152344e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 29, "offsetEnd": 36}, "context": "Abstract representation of a MongoDB query and translation to a concrete query string.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00034999847412109375}, "created": {"value": false, "score": 6.771087646484375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 29, "offsetEnd": 36}, "context": "To this end, we consider the MongoDB NoSQL database.", "mentionContextAttributes": {"used": {"value": false, "score": 0.2557886838912964}, "created": {"value": false, "score": 0.27348828315734863}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 30, "offsetEnd": 36}, "context": "To avoid defining yet another SPARQL translation method for each and every database, we propose a two-phase method.", "mentionContextAttributes": {"used": {"value": false, "score": 5.5909156799316406e-05}, "created": {"value": true, "score": 0.9998928308486938}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 30, "offsetEnd": 36}, "context": "In such cases, given that the SPARQL query retrieves only DISTINCT values of the predicate variable ?p, no query needs to be run against the database at all: it is sufficient to collect the distinct constant values that variable ?p can be matched with.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00935298204421997}, "created": {"value": false, "score": 1.239776611328125e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 30, "offsetEnd": 36}, "context": "Let us consider the following SPARQL graph pattern, where tp n is any triple pattern: { tp1.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5219761729240417}, "created": {"value": false, "score": 1.0251998901367188e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 30, "offsetEnd": 37}, "context": "and $.id translate into their MongoDB projection counterparts: \"emails\":true and \"id\":true.", "mentionContextAttributes": {"used": {"value": true, "score": 0.964638888835907}, "created": {"value": false, "score": 1.430511474609375e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 30, "offsetEnd": 37}, "context": "As a consequence, an abstract MongoDB query may be rewritten into a union of valid, concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0002637505531311035}, "created": {"value": false, "score": 6.35385513305664e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph-", "normalizedForm": "Morph", "offsetStart": 31, "offsetEnd": 37}, "context": "It is based on and extends the Morph-RDB [29] R2RML implementation. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.31987249851226807}, "created": {"value": false, "score": 0.00817263126373291}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}, "references": [{"label": "[29]", "normalizedForm": "[29]", "refKey": 28, "offsetStart": 60973, "offsetEnd": 60977}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 32, "offsetEnd": 37}, "context": "A tentative explanation is that Morph-xR2RML may be faster when producing blank nodes than when producing URIs, unless this difference lies in the Jena API on which Morph-xR2RML relies to handle RDF triples.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001653432846069336}, "created": {"value": false, "score": 2.193450927734375e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 32, "offsetEnd": 38}, "context": "Typically, a conjunction of two SPARQL basic graph patterns (BGP) results in the inner join of their respective translations; their union results in a SQL UNION ALL clause; the SPARQL OPTIONAL clause results in a left outer join, and a SPARQL FILTER results in an encapsulating SQL SELECT WHERE clause.", "mentionContextAttributes": {"used": {"value": false, "score": 0.024011552333831787}, "created": {"value": false, "score": 2.1457672119140625e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 32, "offsetEnd": 38}, "context": "Finally, we summarize the whole SPARQL-to-MongoDB process orchestration, from the SPARQL graph pattern translation until the generation of the RDF triples that match this graph pattern (section 5.3).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9703912138938904}, "created": {"value": false, "score": 0.0001481771469116211}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MySQL", "normalizedForm": "MySQL", "offsetStart": 33, "offsetEnd": 38}, "context": "It comes with connectors for the MySQL and Postgres relational databases, and for the MongoDB document store. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006810426712036133}, "created": {"value": false, "score": 0.0002269148826599121}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0006810426712036133}, "created": {"value": false, "score": 0.0002269148826599121}, "shared": {"value": false, "score": 2.5510787963867188e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 34, "offsetEnd": 41}, "context": "-Our implementation of xR2RML for MongoDB relies on JSONPath to extract data elements from MongoDB results.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006389021873474121}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ontop", "normalizedForm": "ontop", "offsetStart": 36, "offsetEnd": 41}, "context": "Comparison with the MongoDB-enabled ontop. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": false, "score": 1.5854835510253906e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}, {"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 36, "offsetEnd": 43}, "context": "In this context, we imported into a MongoDB database the JSON representation of TAXREF v9.0, wherein each of the 485.189", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": false, "score": 9.310245513916016e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "AllegroGraph", "normalizedForm": "AllegroGraph", "offsetStart": 36, "offsetEnd": 48}, "context": "MongoGraph 5 is an extension of the AllegroGraph triple store to query arbitrary MongoDB documents with SPARQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00136643648147583}, "created": {"value": false, "score": 5.626678466796875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.00136643648147583}, "created": {"value": false, "score": 5.626678466796875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 37, "offsetEnd": 43}, "context": "Hence, to avoid defining yet another SPARQL translation method for each and every database, in this paper we investigate a general two-phase method.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003758668899536133}, "created": {"value": true, "score": 0.9991663694381714}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 37, "offsetEnd": 45}, "context": "com \") }} Function proj converts the JSONPath expressions of the From part into a list of paths to be projected.", "mentionContextAttributes": {"used": {"value": false, "score": 0.08634829521179199}, "created": {"value": false, "score": 4.291534423828125e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 38, "offsetEnd": 45}, "context": "Fig. 3 summarizes the whole SPARQL-to-MongoDB process orchestration, from the graph pattern translation to the subsequent MongoDB queries evaluation and the production of RDF triples.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9730534553527832}, "created": {"value": false, "score": 5.841255187988281e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 39, "offsetEnd": 45}, "context": "Such a profile could be exploited by a SPARQL rewriting engine to enable the querying of document stores with SPARQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.07984358072280884}, "created": {"value": false, "score": 0.001052558422088623}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 39, "offsetEnd": 46}, "context": "Consequently, there does not exist any MongoDB query that would be equivalent to the INNER JOIN and LEFT OUTER JOIN operators.", "mentionContextAttributes": {"used": {"value": false, "score": 0.009936034679412842}, "created": {"value": false, "score": 2.4437904357910156e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 39, "offsetEnd": 46}, "context": "Since joins cannot be processed within MongoDB, the outer UNION operator cannot be processed within Mon-goDB either.", "mentionContextAttributes": {"used": {"value": false, "score": 0.026128113269805908}, "created": {"value": false, "score": 1.6450881958007812e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 39, "offsetEnd": 46}, "context": "Let Q = (Q 1 ... Q n ) be the abstract MongoDB query produced by trans(C).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9995006322860718}, "created": {"value": false, "score": 1.0728836059570312e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 40, "offsetEnd": 47}, "context": "In this section, we first glance at the MongoDB query language, and we describe an abstract representation of MongoDB queries (section 5.1).", "mentionContextAttributes": {"used": {"value": false, "score": 0.08576053380966187}, "created": {"value": false, "score": 0.004223287105560303}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 41, "offsetEnd": 46}, "context": "In any case, the processing performed by Morph-xR2RML adds no more than a 30% overhead to the time needed to query the database and retrieve the results.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6136553883552551}, "created": {"value": false, "score": 1.1086463928222656e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 41, "offsetEnd": 48}, "context": "Optimization and Rewriting into Concrete MongoDB Queries In the previous section, function trans produces abstract MongoDB queries that can be rewritten into concrete queries straightaway.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008686184883117676}, "created": {"value": false, "score": 3.3855438232421875e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 42, "offsetEnd": 49}, "context": "Finally, we summarize the whole SPARQL-to-MongoDB process orchestration, from the SPARQL graph pattern translation until the generation of the RDF triples that match this graph pattern (section 5.3).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9703912138938904}, "created": {"value": false, "score": 0.0001481771469116211}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 43, "offsetEnd": 49}, "context": "More specifically, we focus on rewriting a SPARQL 1.0 graph pattern, whatever the query form (SELECT, ASK, DESCRIBE, etc.).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0012243390083312988}, "created": {"value": false, "score": 0.1056331992149353}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 43, "offsetEnd": 49}, "context": "As mentioned earlier, the translation of a SPARQL filter into an encapsulating SELECT WHERE clause lowers the selectivity of inner queries, and the query evaluation process may have to deal with unnecessarily large intermediate results.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00038504600524902344}, "created": {"value": false, "score": 4.291534423828125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Postgres", "normalizedForm": "Postgres", "offsetStart": 43, "offsetEnd": 51}, "context": "It comes with connectors for the MySQL and Postgres relational databases, and for the MongoDB document store. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006810426712036133}, "created": {"value": false, "score": 0.0002269148826599121}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "documentContextAttributes": {"used": {"value": false, "score": 0.0006810426712036133}, "created": {"value": false, "score": 0.0002269148826599121}, "shared": {"value": false, "score": 2.5510787963867188e-05}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "XQuery", "normalizedForm": "XQuery", "offsetStart": 44, "offsetEnd": 50}, "context": "In the general case however (beyond SQL and XQuery), the target query language may not support joins, unions, sub-queries and/or filtering. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00022596120834350586}, "created": {"value": false, "score": 6.449222564697266e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 44, "offsetEnd": 50}, "context": "It derives from the syntax and semantics of SPARQL [27]: the language keeps the names of several SPARQL operators (UNION, LIMIT, FILTER) and prefers the SQL terms INNER JOIN ON and LEFT OUTER JOIN ON to refer to join operations more explicitly.", "mentionContextAttributes": {"used": {"value": false, "score": 0.020725786685943604}, "created": {"value": false, "score": 2.7418136596679688e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[27]", "normalizedForm": "[27]", "refKey": 26, "offsetStart": 18472, "offsetEnd": 18476}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 44, "offsetEnd": 50}, "context": "Similarly, UNIONs may arise either from the SPARQL UNION operator (Def.", "mentionContextAttributes": {"used": {"value": false, "score": 0.08336412906646729}, "created": {"value": false, "score": 7.271766662597656e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 44, "offsetEnd": 50}, "context": "Additional conditions are entailed from the SPARQL filter f.", "mentionContextAttributes": {"used": {"value": true, "score": 0.8317386507987976}, "created": {"value": false, "score": 1.823902130126953e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 44, "offsetEnd": 50}, "context": "As a result, querying a graph database with SPARQL may be more challenging that it seems, and we believe that our two-phase approach may be relevant in this context too.", "mentionContextAttributes": {"used": {"value": false, "score": 9.250640869140625e-05}, "created": {"value": false, "score": 0.013124704360961914}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 45, "offsetEnd": 51}, "context": "Then, we measured the performances of richer SPARQL queries and we demonstrated the effectiveness of some of the optimizations performed at the level of the abstract query language.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": false, "score": 8.344650268554688e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 46, "offsetEnd": 52}, "context": "They describe a two-step rewriting process of SPARQL queries into a MongoDB aggregate pipeline.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001259148120880127}, "created": {"value": true, "score": 0.9951049089431763}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 46, "offsetEnd": 53}, "context": "We also defined an abstract representation of MongoDB queries, that allows for handy manipulation during the query construction and optimization phases.", "mentionContextAttributes": {"used": {"value": false, "score": 7.128715515136719e-05}, "created": {"value": true, "score": 0.999278724193573}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 46, "offsetEnd": 54}, "context": "(ii) It may not be possible to translate some JSONPath expressions into equivalent MongoDB operators.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00038892030715942383}, "created": {"value": false, "score": 1.52587890625e-05}, "shared": {"value": false, "score": 1.5497207641601562e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Apache", "normalizedForm": "Apache", "offsetStart": 47, "offsetEnd": 53}, "version": {"rawForm": "2.0", "normalizedForm": "2.0", "offsetStart": 54, "offsetEnd": 57}, "context": "Morph-xR2RML is available on GitHub9 under the Apache 2.0 license, it is written in the Scala programming language. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.022618770599365234}, "created": {"value": false, "score": 0.00012445449829101562}, "shared": {"value": true, "score": 0.8194966912269592}}, "documentContextAttributes": {"used": {"value": false, "score": 0.022618770599365234}, "created": {"value": false, "score": 0.00012445449829101562}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CouchDB", "normalizedForm": "CouchDB", "offsetStart": 47, "offsetEnd": 54}, "context": "An early work 3 has tackled the translation of CouchDB 4 documents into RDF, but did not addressed SPARQL rewriting. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023978948593139648}, "created": {"value": false, "score": 0.20570307970046997}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.006013989448547363}, "created": {"value": false, "score": 0.20570307970046997}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 47, "offsetEnd": 54}, "context": "Conversely, the UNION clause has no equivalent MongoDB operator: it is processed outside of MongoDB by the query processing engine.", "mentionContextAttributes": {"used": {"value": false, "score": 0.025749802589416504}, "created": {"value": false, "score": 2.944469451904297e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 48, "offsetEnd": 56}, "context": "Let C be an equality or not-null condition on a JSONPath expression.", "mentionContextAttributes": {"used": {"value": false, "score": 0.2379867434501648}, "created": {"value": false, "score": 0.00017142295837402344}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 49, "offsetEnd": 55}, "context": "Additionally, no benchmark similar to the Berlin SPARQL Benchmark for relational databases [6] exists so far for querying NoSQL databases with SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0015279650688171387}, "created": {"value": false, "score": 2.7894973754882812e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "sparqlFilter", "normalizedForm": "sparqlFilter", "offsetStart": 49, "offsetEnd": 61}, "context": "The Where part consists of isNotNull, equals and sparqlFilter conditions on JSONPath expressions.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7993417978286743}, "created": {"value": false, "score": 3.0517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998844861984253}, "created": {"value": true, "score": 0.9889131188392639}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 50, "offsetEnd": 56}, "version": {"rawForm": "9.0", "normalizedForm": "9.0"}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "We are involved in an on-going collaboration with TAXREF experts from MNHN, aimed to publish TAXREF on the Web of Data as a SKOS thesaurus [9]. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005893707275390625}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 5.8531761169433594e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 50, "offsetEnd": 56}, "context": "More precisely, for each triple pattern tp of the SPARQL graph pattern, we must figure out which mappings can possibly generate triples that match tp.", "mentionContextAttributes": {"used": {"value": false, "score": 0.010584831237792969}, "created": {"value": false, "score": 6.270408630371094e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 50, "offsetEnd": 56}, "context": "A UNION operator can be created either due to the SPARQL UNION operator or during the translation of a triple pattern to which several mappings are bound (in function transT P m ).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003872513771057129}, "created": {"value": false, "score": 4.0411949157714844e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 50, "offsetEnd": 56}, "context": "In section 4, we showed that the FILTER and LIMIT SPARQL solution modifiers are pushed down into relevant atomic abstract queries (as sparqlFilter conditions of the Where part or as the Limit part of an atomic query, respectively).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998844861984253}, "created": {"value": false, "score": 2.5033950805664062e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 50, "offsetEnd": 56}, "version": {"rawForm": "9.0", "normalizedForm": "9.0"}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "The xR2RML mapping graph designed to generate the TAXREF-based SKOS thesaurus is provided in the xR2RML GitHub repository 15 .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9123172163963318}, "created": {"value": false, "score": 0.00014328956604003906}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 50, "offsetEnd": 56}, "context": "To achieve this goal without defining yet another SPARQL translation method for each and every database, we proposed a two-phase approach.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007729530334472656}, "created": {"value": true, "score": 0.9998418092727661}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CouchDB", "normalizedForm": "CouchDB", "offsetStart": 50, "offsetEnd": 57}, "context": "This is the case of other document stores such as CouchDB that are designed in a way very similar to MongoDB. ", "mentionContextAttributes": {"used": {"value": false, "score": 9.846687316894531e-05}, "created": {"value": false, "score": 0.0011251568794250488}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.006013989448547363}, "created": {"value": false, "score": 0.20570307970046997}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 50, "offsetEnd": 58}, "context": "Furthermore, unlike ontop, xR2RML allows for rich JSONPath expressions to evaluate a JSON document and generate RDF terms.", "mentionContextAttributes": {"used": {"value": false, "score": 6.42538070678711e-05}, "created": {"value": false, "score": 3.1113624572753906e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 51, "offsetEnd": 59}, "context": "In step 2, function proj translates each projected JSONPath expression into a MongoDB projection argument, function trans translates each isNotNull and equals condition into an abstract representation of a MongoDB query (section (section 5.2), and function rewrite (section 5.2) optimizes and rewrites this abstract representation into a concrete MongoDB query or a union of concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7843112349510193}, "created": {"value": false, "score": 2.7418136596679688e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 52, "offsetEnd": 60}, "context": "-Our implementation of xR2RML for MongoDB relies on JSONPath to extract data elements from MongoDB results. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006389021873474121}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 53, "offsetEnd": 59}, "context": "In this context, the author devised a translation of SPARQL queries into MongoDB queries, that is however closely tied to the specific database schema and thus is unfit for arbitrary documents.", "mentionContextAttributes": {"used": {"value": false, "score": 6.568431854248047e-05}, "created": {"value": true, "score": 0.9946213960647583}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 53, "offsetEnd": 60}, "context": "Red dots represent the measures when simply querying MongoDB with Jongo, while blue dots represent the measures of the whole process executed by  The distance between the two lines gives an estimation of the overhead imposed by Morph-xR2RML to rewrite the query and generate the triples.", "mentionContextAttributes": {"used": {"value": true, "score": 0.840487003326416}, "created": {"value": false, "score": 6.556510925292969e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 54, "offsetEnd": 60}, "context": "The graph pattern matches 12,708 triples that yield a SPARQL result set of 4,236 solutions.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9991365075111389}, "created": {"value": false, "score": 2.86102294921875e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 55, "offsetEnd": 61}, "context": "Let gp be a well-designed SPARQL graph pattern, f be a SPARQL filter and l an integer limit value representing the maximum number of results.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9592442512512207}, "created": {"value": false, "score": 0.0003069639205932617}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 55, "offsetEnd": 61}, "context": "At this point, the method we have exposed translates a SPARQL graph pattern into an effective abstract query, i.e. that preserves the semantics of the SPARQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00017827749252319336}, "created": {"value": false, "score": 0.2540329694747925}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 55, "offsetEnd": 61}, "context": "In step 1, function trans m (section 4.1) translates a SPARQL graph pattern into an abstract query under a set of xR2RML mappings denoted by m.", "mentionContextAttributes": {"used": {"value": false, "score": 0.12922167778015137}, "created": {"value": false, "score": 6.556510925292969e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 56, "offsetEnd": 63}, "context": "We devised a method to translate an abstract query into MongoDB find queries, and we showed that this translation is challenged by the expressiveness discrepancy between SPARQL and the MongoDB query language.", "mentionContextAttributes": {"used": {"value": false, "score": 0.016974568367004395}, "created": {"value": true, "score": 0.9898433685302734}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 56, "offsetEnd": 63}, "context": "We demonstrate the effectiveness of our method with the MongoDB NoSQL document store, such that arbitrary MongoDB documents can be aligned on existing domain ontologies and accessed with SPARQL.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998729228973389}, "created": {"value": false, "score": 0.25546348094940186}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 56, "offsetEnd": 63}, "context": "Thus, in step 2 (detailed in section 5.2) each abstract MongoDB query is optimized and rewritten into valid, concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.025822341442108154}, "created": {"value": false, "score": 2.3365020751953125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 56, "offsetEnd": 63}, "context": "Since Morph-xR2RML relies on the Jongo API to process a MongoDB query, we also measured the time needed by Jongo to parse the query, pass it on to MongoDB and retrieve the results from MongoDB.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999884843826294}, "created": {"value": false, "score": 3.4332275390625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "XQuery", "normalizedForm": "XQuery", "offsetStart": 57, "offsetEnd": 63}, "context": "For instance, SPARQL2XQuery [4] relies on the ability of XQuery to support joins, nested queries and complex filtering. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00012755393981933594}, "created": {"value": false, "score": 8.58306884765625e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 57, "offsetEnd": 63}, "context": "Let l be the maximum number of query results, and f be a SPARQL filter expression.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999925971031189}, "created": {"value": false, "score": 7.665157318115234e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 57, "offsetEnd": 65}, "context": "To deal with the tree structure of JSON documents we use JSONPath expressions.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": false, "score": 2.86102294921875e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 58, "offsetEnd": 65}, "context": "Handling these expressions within the translation towards MongoDB would yield a significant additional complexity without changing the translation principles though.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9622064232826233}, "created": {"value": false, "score": 7.474422454833984e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 58, "offsetEnd": 65}, "context": "Following this approach, we developed a connector for the MongoDB document store, to translate MongoDB JSON documents into RDF and rewrite SPARQL queries into MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 5.733966827392578e-05}, "created": {"value": true, "score": 0.9996867179870605}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 58, "offsetEnd": 66}, "context": "Lastly, Jayway JsonPath13 is a Java implementation of the JSONPath language.", "mentionContextAttributes": {"used": {"value": false, "score": 8.344650268554688e-05}, "created": {"value": false, "score": 0.1137089729309082}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "XQuery", "normalizedForm": "XQuery", "offsetStart": 59, "offsetEnd": 65}, "context": "Finally, it occurs that the rich expressiveness of SQL and XQuery makes it possible to translate a SPARQL 1.0 query into a single, possibly deeply nested, target query, whose semantics is provably strictly equivalent to that of the SPARQL query. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00018006563186645508}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 59, "offsetEnd": 65}, "version": {"rawForm": "9.0", "normalizedForm": "9.0"}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "As an example, the listing below shows a JSON excerpt from TAXREF's Web service 14 , describing the common dolphin species (Delphinus delphis).", "mentionContextAttributes": {"used": {"value": false, "score": 0.12212234735488892}, "created": {"value": false, "score": 3.3974647521972656e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 59, "offsetEnd": 66}, "context": "Let us consider the following abstract representation of a MongoDB query (or \"abstract MongoDB query\" for short):", "mentionContextAttributes": {"used": {"value": false, "score": 0.001428365707397461}, "created": {"value": false, "score": 0.00017011165618896484}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 60, "offsetEnd": 66}, "context": "4 From SPARQL to Abstract Queries Section 2 emphasized that SPARQL rewriting methods for SQL or XQuery rely on prior knowledge about the target query language expressiveness.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 2.181529998779297e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 61, "offsetEnd": 67}, "context": "These situations pertain to type constraints expressed using SPARQL functions isIRI, isLiteral or isBlank, as well as language and data type constraints expressed using functions lang, langMatches and datatype.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04953968524932861}, "created": {"value": false, "score": 3.337860107421875e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 61, "offsetEnd": 67}, "context": "From a broader perspective, we have shown that translating a SPARQL query into efficient concrete queries can be challenging when it comes to address data sources such as NoSQL databases.", "mentionContextAttributes": {"used": {"value": false, "score": 8.380413055419922e-05}, "created": {"value": true, "score": 0.985375165939331}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 61, "offsetEnd": 68}, "context": "An OR clause represents the $or operator and is processed by MongoDB.", "mentionContextAttributes": {"used": {"value": true, "score": 0.6261749863624573}, "created": {"value": false, "score": 4.756450653076172e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 62, "offsetEnd": 68}, "context": "This makes possible the semantics-preserving translation of a SPARQL query into a single equivalent target query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0003407001495361328}, "created": {"value": false, "score": 0.00012135505676269531}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 63, "offsetEnd": 69}, "context": "In this section, we measure the completion time of two example SPARQL queries involving joins.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9919335246086121}, "created": {"value": false, "score": 2.562999725341797e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 64, "offsetEnd": 70}, "context": "Utilizing the xR2RML mapping language and leveraging R2RMLbased SPARQL-to-SQL works, we introduced a generic method to translate a SPARQL 1.0 graph pattern into an abstract query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0022957921028137207}, "created": {"value": true, "score": 0.9943650960922241}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 64, "offsetEnd": 71}, "context": "A corollary of Theorem 1 is that, using the xR2RML mapping of a MongoDB database to RDF, we can rewrite any SPARQL 1.0 graph pattern into an abstract query whose atomic abstract queries are valid MongoDB queries or unions of valid MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0032104849815368652}, "created": {"value": false, "score": 4.410743713378906e-05}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 64, "offsetEnd": 71}, "context": "The Jongo API 12 builds on top of it to translate a declarative MongoDB query (a find query in our case) into imperative code.", "mentionContextAttributes": {"used": {"value": false, "score": 0.006712377071380615}, "created": {"value": false, "score": 0.0073754191398620605}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 64, "offsetEnd": 71}, "context": "Consequently, it is likely that the hurdles we encountered with MongoDB will be encountered with other NoSQL databases alike.", "mentionContextAttributes": {"used": {"value": false, "score": 0.06291413307189941}, "created": {"value": false, "score": 0.0017750859260559082}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 64, "offsetEnd": 72}, "context": "In turn, the SPARQL rewriting process must handle conditions on JSONPath expressions. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.07729023694992065}, "created": {"value": false, "score": 1.8358230590820312e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 64, "offsetEnd": 72}, "context": "This occurs with specific JSONPath array slice notations, or in JSONPath expressions assuming that the root document is an array field and not a document field (which is forbidden in MongoDB).", "mentionContextAttributes": {"used": {"value": false, "score": 0.008662819862365723}, "created": {"value": false, "score": 1.1920928955078125e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 66, "offsetEnd": 73}, "context": "-Beyond this, another promising lead is to determine what type of MongoDB query should be used preferably: find or aggregate queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00018745660781860352}, "created": {"value": false, "score": 0.18827718496322632}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "sparqlFilter", "normalizedForm": "sparqlFilter", "offsetStart": 67, "offsetEnd": 79}, "context": "In Listing 1.5, the third atomic abstract query is as follows (the sparqlFilter condition has been omitted):", "mentionContextAttributes": {"used": {"value": true, "score": 0.8474036455154419}, "created": {"value": false, "score": 1.0371208190917969e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998844861984253}, "created": {"value": true, "score": 0.9889131188392639}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 68, "offsetEnd": 75}, "context": "They describe a two-step rewriting process of SPARQL queries into a MongoDB aggregate pipeline.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001259148120880127}, "created": {"value": true, "score": 0.9951049089431763}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 68, "offsetEnd": 75}, "context": "Besides, we do not want to define a method specifically tailored to MongoDB; our point is to provide a generic rewriting method that can be applied to the concrete case of MongoDB as well as various other databases.", "mentionContextAttributes": {"used": {"value": false, "score": 4.088878631591797e-05}, "created": {"value": true, "score": 0.7851734161376953}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 69, "offsetEnd": 75}, "context": "Notation v 1 ,... v n , in the join operators, stands for the set of SPARQL variables on which the join is to be performed.", "mentionContextAttributes": {"used": {"value": true, "score": 0.966498076915741}, "created": {"value": false, "score": 2.276897430419922e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 69, "offsetEnd": 75}, "context": "In [22], we show that three types of condition may be created: (i) a SPARQL variable in the triple pattern is turned into a not-null condition on the xR2RML reference corresponding to that variable in the term map, denoted by isNotNull(<xR2RML reference>); (ii) A constant term in the triple pattern (IRI or literal) is turned into an equality condition on the xR2RML reference corresponding to that term in the term map, denoted by equals(<xR2RML reference>, value); (iii) A SPARQL filter condition about a SPARQL variable is turned into a filter condition, denoted by sparqlFilter(<xR2RML reference>, f ).", "mentionContextAttributes": {"used": {"value": true, "score": 0.7912850975990295}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 1.6689300537109375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 69, "offsetEnd": 76}, "context": "We show that we can always rewrite an abstract query into a union of MongoDB find queries that shall return all the documents required to answer the SPARQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.25720494985580444}, "created": {"value": false, "score": 0.001271665096282959}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 69, "offsetEnd": 76}, "context": "Jongo's authors argue that the library is almost as fast as querying MongoDB directly, under the assumption that the marshalling/unmarshalling of JSON documents is left to Jongo.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00024944543838500977}, "created": {"value": false, "score": 0.00032258033752441406}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 69, "offsetEnd": 76}, "context": "Our approach works the other way around: it produces less-expressive MongoDB find queries, leaving much more work to the query-processing engine.", "mentionContextAttributes": {"used": {"value": false, "score": 3.349781036376953e-05}, "created": {"value": true, "score": 0.9061620235443115}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 70, "offsetEnd": 76}, "context": "To generate the abstract query, we rely on and extend the R2RML-based SPARQL rewriting approaches reviewed in section 2, while taking care of avoiding the limitations highlighted.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9918547868728638}, "created": {"value": false, "score": 0.004856109619140625}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 70, "offsetEnd": 77}, "context": "Under some circumstances, a UNION operator may be translated into the MongoDB $or operator.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008638501167297363}, "created": {"value": false, "score": 7.665157318115234e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 71, "offsetEnd": 77}, "context": "The method proposed in this paper aims at fostering the development of SPARQL interfaces to heterogeneous databases, as we believe this is a key to push the Web of Data forward.", "mentionContextAttributes": {"used": {"value": false, "score": 9.393692016601562e-05}, "created": {"value": true, "score": 0.9998430013656616}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 71, "offsetEnd": 78}, "context": "To demonstrate the effectiveness of our approach, we applied it to the MongoDB NoSQL document store.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": false, "score": 0.037976741790771484}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 72, "offsetEnd": 78}, "context": "Let us simply mention that they are managed in the very same way as the SPARQL FILTER clause and LIMIT solution modifier, i.e. as additional parameters of the trans m and transTP m functions, and additional operators of the abstract query language.", "mentionContextAttributes": {"used": {"value": false, "score": 0.12482559680938721}, "created": {"value": false, "score": 0.00010192394256591797}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 73, "offsetEnd": 80}, "context": "In this context, the author devised a translation of SPARQL queries into MongoDB queries, that is however closely tied to the specific database schema and thus is unfit for arbitrary documents.", "mentionContextAttributes": {"used": {"value": false, "score": 6.568431854248047e-05}, "created": {"value": true, "score": 0.9946213960647583}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 73, "offsetEnd": 80}, "context": "More generally, the translation from the abstract query language towards MongoDB consists of two steps depicted in Fig. 2. In step 1 (detailed in section 5.2), the translation of each atomic abstract query towards MongoDB amounts to translate projections of JSONPath expressions (Project part) into MongoDB projection arguments, and conditions on JSONPath expressions (Where part) into equivalent abstract MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7133763432502747}, "created": {"value": false, "score": 5.0067901611328125e-06}, "shared": {"value": false, "score": 2.1457672119140625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ontop", "normalizedForm": "ontop", "offsetStart": 74, "offsetEnd": 79}, "context": "In a somewhat different approach, Rodr\u00edguez-Muro and Rezk [32] extend the ontop Ontology-Based Data Access (OBDA) system to support R2RML mappings.", "mentionContextAttributes": {"used": {"value": false, "score": 8.571147918701172e-05}, "created": {"value": false, "score": 0.00017249584197998047}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}, {"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 74, "offsetEnd": 80}, "context": "In the current status of this work, we do not consider the translation of SPARQL filters (conditions sparqlFilter ) for the sake of simplicity.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0037804245948791504}, "created": {"value": true, "score": 0.9889131188392639}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 74, "offsetEnd": 80}, "context": "Consequently, we have to cope with the expressiveness discrepancy between SPARQL and MongoDB, and between JSONPath and MongoDB alike.", "mentionContextAttributes": {"used": {"value": false, "score": 0.016264140605926514}, "created": {"value": false, "score": 0.0006830692291259766}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 75, "offsetEnd": 81}, "context": "More generally, this optimization checks if the variables projected in the SPARQL query are matched with constant term maps.", "mentionContextAttributes": {"used": {"value": false, "score": 0.12596005201339722}, "created": {"value": false, "score": 8.821487426757812e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 75, "offsetEnd": 81}, "context": "We identified another type of optimization that was not implemented in the SPARQL-to-SQL context.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0022649765014648438}, "created": {"value": true, "score": 0.9279507398605347}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 76, "offsetEnd": 84}, "context": "The Where part consists of isNotNull, equals and sparqlFilter conditions on JSONPath expressions.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7993417978286743}, "created": {"value": false, "score": 3.0517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "XQuery", "normalizedForm": "XQuery", "offsetStart": 77, "offsetEnd": 83}, "context": "Typically, a SPARQL FILTER is translated into an encapsulating For-Let-Where XQuery clause.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008735060691833496}, "created": {"value": false, "score": 1.2040138244628906e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 78, "offsetEnd": 84}, "context": "When we put all the pieces together, we can rewrite the graph pattern gp 2 of SPARQL query Q 2 into the abstract query depicted in Listing 1.4.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9731197953224182}, "created": {"value": false, "score": 7.510185241699219e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 78, "offsetEnd": 85}, "context": "In step 2, function proj translates each projected JSONPath expression into a MongoDB projection argument, function trans translates each isNotNull and equals condition into an abstract representation of a MongoDB query (section (section 5.2), and function rewrite (section 5.2) optimizes and rewrites this abstract representation into a concrete MongoDB query or a union of concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7843112349510193}, "created": {"value": false, "score": 2.7418136596679688e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 79, "offsetEnd": 85}, "context": "The latter are ruled out during the query evaluation process by running a late SPARQL query evaluation.", "mentionContextAttributes": {"used": {"value": false, "score": 0.07571786642074585}, "created": {"value": false, "score": 0.0001112222671508789}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 80, "offsetEnd": 86}, "version": {"rawForm": "9.0", "normalizedForm": "9.0", "offsetStart": 88, "offsetEnd": 91}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "In this context, we imported into a MongoDB database the JSON representation of TAXREF v9.0, wherein each of the 485.189 ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": false, "score": 9.310245513916016e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 80, "offsetEnd": 87}, "context": "Leveraging this existing database, we set up an experimentation of the SPARQLto-MongoDB query rewriting.", "mentionContextAttributes": {"used": {"value": false, "score": 0.034557878971099854}, "created": {"value": true, "score": 0.9996784925460815}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 80, "offsetEnd": 87}, "context": "To the best of our knowledge, the only other approach meant to access arbitrary MongoDB documents with SPARQL has been proposed by the authors of ontop, Botoeva et al. [8].", "mentionContextAttributes": {"used": {"value": false, "score": 7.641315460205078e-05}, "created": {"value": false, "score": 0.22565513849258423}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 81, "offsetEnd": 87}, "context": "Interestingly enough, we notice that INNER JOINs may be implied either by shared SPARQL variables (Def.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5613908171653748}, "created": {"value": false, "score": 6.4373016357421875e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 81, "offsetEnd": 88}, "context": "MongoGraph 5 is an extension of the AllegroGraph triple store to query arbitrary MongoDB documents with SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00136643648147583}, "created": {"value": false, "score": 5.626678466796875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 81, "offsetEnd": 88}, "context": "MongoDB collection \"people\" containing two documents respectively <#Knows>, is a MongoDB query that retrieves documents having a non-null emails field, respectively a contacts array field with at least one element.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0028051137924194336}, "created": {"value": false, "score": 1.5735626220703125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 82, "offsetEnd": 88}, "context": "Finally, we summarize the whole SPARQL-to-MongoDB process orchestration, from the SPARQL graph pattern translation until the generation of the RDF triples that match this graph pattern (section 5.3).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9703912138938904}, "created": {"value": false, "score": 0.0001481771469116211}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 83, "offsetEnd": 89}, "context": "Let m be a set of xR2RML mappings, gp be a well-designed graph pattern, and f be a SPARQL filter.", "mentionContextAttributes": {"used": {"value": false, "score": 0.3234855532646179}, "created": {"value": false, "score": 0.00011515617370605469}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 83, "offsetEnd": 90}, "context": "(ii) It may not be possible to translate some JSONPath expressions into equivalent MongoDB operators.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00038892030715942383}, "created": {"value": false, "score": 1.52587890625e-05}, "shared": {"value": false, "score": 1.5497207641601562e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ontop", "normalizedForm": "ontop", "offsetStart": 84, "offsetEnd": 89}, "context": "To date, to our knowledge, the method proposed in this paper and the MongoDBenabled ontop software [8] are the only approaches meant to query arbitrary MongoDB documents with SPARQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013720989227294922}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8, "offsetStart": 59882, "offsetEnd": 59885}, {"label": "[8]", "normalizedForm": "[8]", "refKey": 8, "offsetStart": 59882, "offsetEnd": 59885}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 84, "offsetEnd": 90}, "context": "We therefore consider SPARQL filters at the earliest stage: function trans m pushes SPARQL filters down into the translation of each inner query in order to return only necessary intermediate results.", "mentionContextAttributes": {"used": {"value": false, "score": 0.13791906833648682}, "created": {"value": false, "score": 4.3272972106933594e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 84, "offsetEnd": 90}, "context": "For the sake of simplicity, we do not describe in further details the management of SPARQL solution modifiers OFFSET, ORDER BY and DISTINCT.", "mentionContextAttributes": {"used": {"value": false, "score": 0.030950188636779785}, "created": {"value": false, "score": 0.3663153648376465}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 84, "offsetEnd": 90}, "context": "Finally, in case one atomic abstract query contained a NOT SUPPORTED clause, a late SPARQL evaluation is performed to rule out the RDF triples that do not match the query (as explained in section 5.2).", "mentionContextAttributes": {"used": {"value": false, "score": 0.3374119997024536}, "created": {"value": false, "score": 1.2993812561035156e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 84, "offsetEnd": 91}, "context": "Ultimately, it occurs that only the atomic abstract queries can be processed within MongoDB, while other abstract operators shall be taken care of by the query-processing engine.", "mentionContextAttributes": {"used": {"value": false, "score": 0.005497932434082031}, "created": {"value": false, "score": 3.4689903259277344e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 85, "offsetEnd": 92}, "context": "Hence, given that UNION and INNER/LEFT OUTER JOIN operators are not processed within MongoDB, the FILTER and LIMIT operators cannot be processed within MongoDB either.", "mentionContextAttributes": {"used": {"value": false, "score": 0.46536874771118164}, "created": {"value": false, "score": 1.1324882507324219e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 85, "offsetEnd": 92}, "context": "Consequently, we have to cope with the expressiveness discrepancy between SPARQL and MongoDB, and between JSONPath and MongoDB alike.", "mentionContextAttributes": {"used": {"value": false, "score": 0.016264140605926514}, "created": {"value": false, "score": 0.0006830692291259766}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 85, "offsetEnd": 93}, "context": "Hence, an investigation should figure out whether considering a restricted subset of JSONPath may produce a simpler solution while still enabling to address most mapping situations.", "mentionContextAttributes": {"used": {"value": false, "score": 9.071826934814453e-05}, "created": {"value": false, "score": 0.008993089199066162}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "isLiteral", "normalizedForm": "isLiteral", "offsetStart": 85, "offsetEnd": 94}, "context": "These situations pertain to type constraints expressed using SPARQL functions isIRI, isLiteral or isBlank, as well as language and data type constraints expressed using functions lang, langMatches and datatype. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.04953968524932861}, "created": {"value": false, "score": 3.337860107421875e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.04953968524932861}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 86, "offsetEnd": 93}, "context": "It comes with connectors for the MySQL and Postgres relational databases, and for the MongoDB document store.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006810426712036133}, "created": {"value": false, "score": 0.0002269148826599121}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 86, "offsetEnd": 93}, "context": "We underlined some limitations of the translation from the abstract query language to MongoDB, that can impair performances.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7525110840797424}, "created": {"value": true, "score": 0.9938090443611145}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 86, "offsetEnd": 93}, "context": "Under such reduced bindings, query Q 7 completes in 8.53s in average, the querying to MongoDB accounts for 47% of this total time, the generation of the RDF triples accounts for 11% and the processing of joins for 39%.", "mentionContextAttributes": {"used": {"value": false, "score": 0.010450243949890137}, "created": {"value": false, "score": 1.7881393432617188e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 87, "offsetEnd": 93}, "context": "For instance, if variable ?v is associated with a term map that produces literals, the SPARQL filter isIRI(?v) can never be satisfied, which ensures that the association is invalid.", "mentionContextAttributes": {"used": {"value": false, "score": 0.02818429470062256}, "created": {"value": false, "score": 1.990795135498047e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 87, "offsetEnd": 93}, "context": "First, we defined an abstract query language deriving from the syntax and semantics of SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.24411386251449585}, "created": {"value": true, "score": 0.9992883801460266}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 87, "offsetEnd": 94}, "context": "Let us consider the following abstract representation of a MongoDB query (or \"abstract MongoDB query\" for short):", "mentionContextAttributes": {"used": {"value": false, "score": 0.001428365707397461}, "created": {"value": false, "score": 0.00017011165618896484}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 87, "offsetEnd": 94}, "context": "In section 5, we showed that atomic abstract queries can be translated into equivalent MongoDB queries, but other operators of the abstract query language (INNER JOIN, LEFT OUTER JOIN, UNION) must be computed by the     query along with the corresponding triple pattern and semantics, the number of results it retrieves from the database, and the average time it took to process the query (the query processing spans the SPARQL query rewriting, the query evaluation against MongoDB and the RDF triples generation).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998661279678345}, "created": {"value": false, "score": 3.337860107421875e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Scala", "normalizedForm": "Scala", "offsetStart": 88, "offsetEnd": 93}, "context": "Morph-xR2RML is available on GitHub9 under the Apache 2.0 license, it is written in the Scala programming language. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.022618770599365234}, "created": {"value": false, "score": 0.00012445449829101562}, "shared": {"value": true, "score": 0.8194966912269592}}, "documentContextAttributes": {"used": {"value": false, "score": 0.022618770599365234}, "created": {"value": false, "score": 0.00012445449829101562}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 89, "offsetEnd": 97}, "context": "It is likely that converting documents to strings and evaluating them with a third-party JSONPath library significantly impairs performances. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014888644218444824}, "created": {"value": false, "score": 0.0006510615348815918}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 91, "offsetEnd": 97}, "context": "When the triple pattern term is a variable, incompatibilities may arise from unsatisfiable SPARQL filters.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0022606849670410156}, "created": {"value": false, "score": 2.09808349609375e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 91, "offsetEnd": 98}, "context": "Thus, as a first approach, this work considers the find query method, hereafter called the MongoDB query language.", "mentionContextAttributes": {"used": {"value": false, "score": 4.673004150390625e-05}, "created": {"value": true, "score": 0.9997387528419495}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 91, "offsetEnd": 98}, "context": "-Our implementation of xR2RML for MongoDB relies on JSONPath to extract data elements from MongoDB results.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006389021873474121}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 92, "offsetEnd": 98}, "context": "where compatible verifies the compatibility between a term map, a triple pattern term and a SPARQL filter", "mentionContextAttributes": {"used": {"value": false, "score": 0.00027483701705932617}, "created": {"value": false, "score": 1.71661376953125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 92, "offsetEnd": 99}, "context": "Conversely, the UNION clause has no equivalent MongoDB operator: it is processed outside of MongoDB by the query processing engine.", "mentionContextAttributes": {"used": {"value": false, "score": 0.025749802589416504}, "created": {"value": false, "score": 2.944469451904297e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 93, "offsetEnd": 99}, "context": "The Constant Projection optimization detects cases where the only projected variables in the SPARQL query are matched with constant values in the bound mappings.", "mentionContextAttributes": {"used": {"value": false, "score": 0.001093149185180664}, "created": {"value": false, "score": 4.887580871582031e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 93, "offsetEnd": 99}, "version": {"rawForm": "9.0", "normalizedForm": "9.0"}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "We are involved in an on-going collaboration with TAXREF experts from MNHN, aimed to publish TAXREF on the Web of Data as a SKOS thesaurus [9].", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005893707275390625}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 5.8531761169433594e-05}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 93, "offsetEnd": 100}, "context": "As a consequence, an abstract MongoDB query may be rewritten into a union of valid, concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0002637505531311035}, "created": {"value": false, "score": 6.35385513305664e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 95, "offsetEnd": 101}, "context": "Typically, when the translation of an R2RML template relies on the SQL string concatenation, a SPARQL query can ben rewritten into something like this: In our approach, equality conditions apply to xR2RML references rather than on the template-generated values, hence the Filter Optimization is enforced by construction.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0026337504386901855}, "created": {"value": false, "score": 6.365776062011719e-05}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 95, "offsetEnd": 101}, "context": "In the previous section, we have exhibited an abstract query model and a method to translate a SPARQL graph pattern into an optimized abstract query, relying on the xR2RML mapping of a target database to RDF.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010805130004882812}, "created": {"value": true, "score": 0.98876953125}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 95, "offsetEnd": 102}, "context": "When we put all the pieces together, the atomic abstract query is translated into the concrete MongoDB query below, where all conditions are operands of an $and operator: db .", "mentionContextAttributes": {"used": {"value": true, "score": 0.9997404217720032}, "created": {"value": false, "score": 2.47955322265625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 95, "offsetEnd": 102}, "context": "Following this approach, we developed a connector for the MongoDB document store, to translate MongoDB JSON documents into RDF and rewrite SPARQL queries into MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 5.733966827392578e-05}, "created": {"value": true, "score": 0.9996867179870605}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "XQuery", "normalizedForm": "XQuery", "offsetStart": 96, "offsetEnd": 102}, "context": "4 From SPARQL to Abstract Queries Section 2 emphasized that SPARQL rewriting methods for SQL or XQuery rely on prior knowledge about the target query language expressiveness. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 2.181529998779297e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 96, "offsetEnd": 104}, "context": "Morph-xR2RML retrieves JSON documents from Jongo as Java strings in order to evaluate them with JSONPath expressions.", "mentionContextAttributes": {"used": {"value": false, "score": 0.39713233709335327}, "created": {"value": false, "score": 1.7881393432617188e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 97, "offsetEnd": 103}, "context": "It derives from the syntax and semantics of SPARQL [27]: the language keeps the names of several SPARQL operators (UNION, LIMIT, FILTER) and prefers the SQL terms INNER JOIN ON and LEFT OUTER JOIN ON to refer to join operations more explicitly.", "mentionContextAttributes": {"used": {"value": false, "score": 0.020725786685943604}, "created": {"value": false, "score": 2.7418136596679688e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 97, "offsetEnd": 103}, "context": "A notable difference with SPARQL is that, in the tree representation of a query, the leaves of a SPARQL query are triple patterns.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0006150007247924805}, "created": {"value": false, "score": 7.95125961303711e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 97, "offsetEnd": 103}, "context": "In our approach, Filter pushing is enforced by construction by the sparqlCond function: relevant SPARQL conditions are pushed down, as much as possible, in the translation of individual triple patterns.", "mentionContextAttributes": {"used": {"value": false, "score": 0.008298695087432861}, "created": {"value": false, "score": 0.001677095890045166}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 98, "offsetEnd": 104}, "context": "Since the early 2000's, various works have investigated methods to query legacy data sources with SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00014650821685791016}, "created": {"value": true, "score": 0.922702431678772}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "isBlank", "normalizedForm": "isBlank", "offsetStart": 98, "offsetEnd": 105}, "context": "These situations pertain to type constraints expressed using SPARQL functions isIRI, isLiteral or isBlank, as well as language and data type constraints expressed using functions lang, langMatches and datatype. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.04953968524932861}, "created": {"value": false, "score": 3.337860107421875e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.04953968524932861}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 99, "offsetEnd": 105}, "context": "Finally, it occurs that the rich expressiveness of SQL and XQuery makes it possible to translate a SPARQL 1.0 query into a single, possibly deeply nested, target query, whose semantics is provably strictly equivalent to that of the SPARQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00018006563186645508}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 99, "offsetEnd": 105}, "context": "An early work 3 has tackled the translation of CouchDB 4 documents into RDF, but did not addressed SPARQL rewriting.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00023978948593139648}, "created": {"value": false, "score": 0.20570307970046997}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 100, "offsetEnd": 107}, "context": "More in line with our work, Botoeva et al. proposed a generalization of the OBDA principles [30] to MongoDB [8].", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001271963119506836}, "created": {"value": true, "score": 0.8728270530700684}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8, "offsetStart": 11452, "offsetEnd": 11455}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Mon-goDB", "normalizedForm": "Mon-goDB", "offsetStart": 100, "offsetEnd": 108}, "context": "Since joins cannot be processed within MongoDB, the outer UNION operator cannot be processed within Mon-goDB either. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.026128113269805908}, "created": {"value": false, "score": 1.6450881958007812e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.026128113269805908}, "created": {"value": false, "score": 1.6450881958007812e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 101, "offsetEnd": 107}, "context": "While we must cope with the earlier (our goal is specifically to access heterogeneous databases with SPARQL), the latter is somewhat more an implementation choice.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00011444091796875}, "created": {"value": false, "score": 0.08738195896148682}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 101, "offsetEnd": 108}, "context": "This is the case of other document stores such as CouchDB that are designed in a way very similar to MongoDB.", "mentionContextAttributes": {"used": {"value": false, "score": 9.846687316894531e-05}, "created": {"value": false, "score": 0.0011251568794250488}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "sparqlFilter", "normalizedForm": "sparqlFilter", "offsetStart": 101, "offsetEnd": 113}, "context": "In the current status of this work, we do not consider the translation of SPARQL filters (conditions sparqlFilter ) for the sake of simplicity.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0037804245948791504}, "created": {"value": true, "score": 0.9889131188392639}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998844861984253}, "created": {"value": true, "score": 0.9889131188392639}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 103, "offsetEnd": 109}, "context": "To the best of our knowledge, the only other approach meant to access arbitrary MongoDB documents with SPARQL has been proposed by the authors of ontop, Botoeva et al. [8].", "mentionContextAttributes": {"used": {"value": false, "score": 7.641315460205078e-05}, "created": {"value": false, "score": 0.22565513849258423}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 104, "offsetEnd": 110}, "context": "MongoGraph 5 is an extension of the AllegroGraph triple store to query arbitrary MongoDB documents with SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00136643648147583}, "created": {"value": false, "score": 5.626678466796875e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 104, "offsetEnd": 110}, "context": "SPARQL rewriting methods reviewed in section 2 generally adopt a bottom-up approach where, typically, a SPARQL FIL-TER translates into an encapsulating query (e.g. a SELECT-WHERE clause in the case of SQL).", "mentionContextAttributes": {"used": {"value": false, "score": 0.0002289414405822754}, "created": {"value": false, "score": 8.189678192138672e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 106, "offsetEnd": 113}, "context": "We demonstrate the effectiveness of our method with the MongoDB NoSQL document store, such that arbitrary MongoDB documents can be aligned on existing domain ontologies and accessed with SPARQL.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998729228973389}, "created": {"value": false, "score": 0.25546348094940186}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 106, "offsetEnd": 114}, "context": "Consequently, we have to cope with the expressiveness discrepancy between SPARQL and MongoDB, and between JSONPath and MongoDB alike. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.016264140605926514}, "created": {"value": false, "score": 0.0006830692291259766}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 107, "offsetEnd": 113}, "context": "Function compatible checks whether a term map is compatible with (i) a term of a triple pattern and (ii) a SPARQL filter, so as to rule out incompatible associations.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0007918477058410645}, "created": {"value": false, "score": 7.510185241699219e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 107, "offsetEnd": 113}, "context": "In turn, the transformation of this superset into RDF triples shall produce all the triples that match the SPARQL query, in addition to triples that may not match the query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.019830763339996338}, "created": {"value": false, "score": 0.00010001659393310547}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 108, "offsetEnd": 114}, "context": "A corollary of Theorem 1 is that, using the xR2RML mapping of a MongoDB database to RDF, we can rewrite any SPARQL 1.0 graph pattern into an abstract query whose atomic abstract queries are valid MongoDB queries or unions of valid MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0032104849815368652}, "created": {"value": false, "score": 4.410743713378906e-05}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 110, "offsetEnd": 116}, "context": "Such a profile could be exploited by a SPARQL rewriting engine to enable the querying of document stores with SPARQL. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.07984358072280884}, "created": {"value": false, "score": 0.001052558422088623}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 110, "offsetEnd": 116}, "context": "Botoeva et al. produce MongoDB aggregate queries, with the major advantage of ensuring a semantics-preserving SPARQL-to-MongoDB query translation, thus delegating the whole processing to MongoDB and making the query translation simpler.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010126233100891113}, "created": {"value": false, "score": 0.0009582638740539551}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 110, "offsetEnd": 117}, "context": "In this section, we first glance at the MongoDB query language, and we describe an abstract representation of MongoDB queries (section 5.1).", "mentionContextAttributes": {"used": {"value": false, "score": 0.08576053380966187}, "created": {"value": false, "score": 0.004223287105560303}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 111, "offsetEnd": 117}, "context": "Utilizing a mapping of this database to a SKOS thesaurus, we first measured performances in the case of single SPARQL triple patterns that translate into single MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998853206634521}, "created": {"value": false, "score": 0.07021617889404297}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 113, "offsetEnd": 120}, "context": "Finally, we conducted an experimentation based on the real-world use case of a taxonomical reference stored in a MongoDB database.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999802112579346}, "created": {"value": true, "score": 0.9716842174530029}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 114, "offsetEnd": 119}, "context": "To investigate this question, we compared the time it takes to run a query (i) through the Jongo API (the case of Morph-xR2RML) and (ii) directly through MongoDB's own Java API.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": false, "score": 4.017353057861328e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 114, "offsetEnd": 120}, "context": "We demonstrate the effectiveness of our method in the case of MongoDB, accessing arbitrary MongoDB documents with SPARQL.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999784231185913}, "created": {"value": false, "score": 0.25273579359054565}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "TAXREF", "normalizedForm": "TAXREF", "offsetStart": 115, "offsetEnd": 121}, "version": {"rawForm": "9.0", "normalizedForm": "9.0"}, "url": {"rawForm": "/example", "normalizedForm": "/example"}, "context": "It consists of 90 mappings, a somewhat high number that spawns from the distance between the internal structure of TAXREF JSON documents and the targeted SKOS modeling.", "mentionContextAttributes": {"used": {"value": false, "score": 0.08291256427764893}, "created": {"value": false, "score": 4.088878631591797e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999501705169678}, "created": {"value": true, "score": 0.9785605072975159}, "shared": {"value": false, "score": 0.012064814567565918}}, "references": [{"label": "[15]", "normalizedForm": "[15]", "refKey": 15}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 115, "offsetEnd": 122}, "context": "Further works could attempt to characterize more specifically the situations where a UNION can be processed within MongoDB.", "mentionContextAttributes": {"used": {"value": false, "score": 8.738040924072266e-05}, "created": {"value": true, "score": 0.9570794701576233}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 115, "offsetEnd": 122}, "context": "Optimization and Rewriting into Concrete MongoDB Queries In the previous section, function trans produces abstract MongoDB queries that can be rewritten into concrete queries straightaway.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008686184883117676}, "created": {"value": false, "score": 3.3855438232421875e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "XQuery", "normalizedForm": "XQuery", "offsetStart": 116, "offsetEnd": 122}, "context": "Hence, the above reviewed methods are tailored to the expressiveness of the target query language, such that SQL or XQuery specificities are woven into the translation method itself, which undermines the ability to use such methods beyond their initial scope.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0004552006721496582}, "created": {"value": false, "score": 0.00026744604110717773}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9822252988815308}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 116, "offsetEnd": 122}, "context": "In addition, we propose a new optimization, the Filter Propagation, that, to our knowledge, was not proposed in any SPARQL-to-SQL rewriting method.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00018519163131713867}, "created": {"value": true, "score": 0.9998519420623779}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 117, "offsetEnd": 123}, "context": "Unbehauen et al. [38] clear the first limitation by defining the concept of compatibility between the RDF terms of a SPARQL triple pattern and R2RML mappings, which enables managing variable predicates.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0008652806282043457}, "created": {"value": false, "score": 3.933906555175781e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 118, "offsetEnd": 125}, "context": "Thus, in step 2 (detailed in section 5.2) each abstract MongoDB query is optimized and rewritten into valid, concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.025822341442108154}, "created": {"value": false, "score": 2.3365020751953125e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 119, "offsetEnd": 125}, "context": "Leveraging the formal semantics of NO-RL, they propose an algorithm to reformulate a query under a NO-RL ontology, but SPARQL is not considered.", "mentionContextAttributes": {"used": {"value": false, "score": 7.641315460205078e-05}, "created": {"value": true, "score": 0.9614656567573547}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 119, "offsetEnd": 125}, "context": "The first query transformation step is implemented by function trans m depicted in Def. 2. It rewrites a well-designed SPARQL graph pattern [27] into an abstract query while making no assumption with respect to the target database query capabilities.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00045162439346313477}, "created": {"value": false, "score": 0.005897700786590576}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 119, "offsetEnd": 126}, "context": "Consequently, we have to cope with the expressiveness discrepancy between SPARQL and MongoDB, and between JSONPath and MongoDB alike.", "mentionContextAttributes": {"used": {"value": false, "score": 0.016264140605926514}, "created": {"value": false, "score": 0.0006830692291259766}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 120, "offsetEnd": 127}, "context": "Botoeva et al. produce MongoDB aggregate queries, with the major advantage of ensuring a semantics-preserving SPARQL-to-MongoDB query translation, thus delegating the whole processing to MongoDB and making the query translation simpler.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010126233100891113}, "created": {"value": false, "score": 0.0009582638740539551}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 120, "offsetEnd": 127}, "context": "Note that the Project and Where parts have been merged, and the three bindings now apply to this atomic query: the same MongoDB query is", "mentionContextAttributes": {"used": {"value": false, "score": 0.3714730143547058}, "created": {"value": false, "score": 2.765655517578125e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 122, "offsetEnd": 129}, "context": "Fig. 3 summarizes the whole SPARQL-to-MongoDB process orchestration, from the graph pattern translation to the subsequent MongoDB queries evaluation and the production of RDF triples.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9730534553527832}, "created": {"value": false, "score": 5.841255187988281e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 124, "offsetEnd": 130}, "context": "An important step in the rewriting process consists in figuring out which of the mappings are good candidates to answer the SPARQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.007462441921234131}, "created": {"value": false, "score": 0.00035500526428222656}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 126, "offsetEnd": 133}, "context": "This approach starts with deriving a set of type constraints (literal, object, array) from the mapping assertions, called the MongoDB database schema.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0002213120460510254}, "created": {"value": false, "score": 0.00025027990341186523}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 128, "offsetEnd": 134}, "context": "Morph-xR2RML is the prototype implementation we developped to evaluate the effectiveness of the xR2RML mapping language and the SPARQL-to-MongoDB method proposed in this paper.", "mentionContextAttributes": {"used": {"value": false, "score": 7.641315460205078e-05}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 128, "offsetEnd": 135}, "context": "A SPARQL query is rewritten into relational algebra (RA) query, and RA expressions over the relational view are translated into MongoDB aggregate queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.5742892026901245}, "created": {"value": false, "score": 3.814697265625e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 131, "offsetEnd": 137}, "context": "Utilizing the xR2RML mapping language and leveraging R2RMLbased SPARQL-to-SQL works, we introduced a generic method to translate a SPARQL 1.0 graph pattern into an abstract query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0022957921028137207}, "created": {"value": true, "score": 0.9943650960922241}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 131, "offsetEnd": 138}, "context": "The NOT SUPPORTED clause helps keep track of any location, within the query, where a condition cannot translate into an equivalent MongoDB query element.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0009977221488952637}, "created": {"value": false, "score": 6.520748138427734e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 133, "offsetEnd": 140}, "context": "Additionally, several leads could be investigated to overcome the limitations of the translation from the abstract query language to MongoDB.", "mentionContextAttributes": {"used": {"value": false, "score": 0.4111921191215515}, "created": {"value": false, "score": 0.025340557098388672}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 134, "offsetEnd": 140}, "context": "In this paper, we tackle the challenge of bridging the gap between the Semantic Web and NoSQL worlds, by fostering the development of SPARQL interfaces to heterogeneous databases.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00010347366333007812}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "sparqlFilter", "normalizedForm": "sparqlFilter", "offsetStart": 134, "offsetEnd": 146}, "context": "In section 4, we showed that the FILTER and LIMIT SPARQL solution modifiers are pushed down into relevant atomic abstract queries (as sparqlFilter conditions of the Where part or as the Limit part of an atomic query, respectively).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998844861984253}, "created": {"value": false, "score": 2.5033950805664062e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998844861984253}, "created": {"value": true, "score": 0.9889131188392639}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 138, "offsetEnd": 145}, "context": "Morph-xR2RML is the prototype implementation we developped to evaluate the effectiveness of the xR2RML mapping language and the SPARQL-to-MongoDB method proposed in this paper.", "mentionContextAttributes": {"used": {"value": false, "score": 7.641315460205078e-05}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 139, "offsetEnd": 145}, "context": "Following this approach, we developed a connector for the MongoDB document store, to translate MongoDB JSON documents into RDF and rewrite SPARQL queries into MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 5.733966827392578e-05}, "created": {"value": true, "score": 0.9996867179870605}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 143, "offsetEnd": 149}, "context": "Additionally, no benchmark similar to the Berlin SPARQL Benchmark for relational databases [6] exists so far for querying NoSQL databases with SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0015279650688171387}, "created": {"value": false, "score": 2.7894973754882812e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ontop", "normalizedForm": "ontop", "offsetStart": 145, "offsetEnd": 150}, "context": "We address this question in section 7, as part of a broader discussion about the similarities and discrepancies between our approach and that of ontop's authors.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0016962289810180664}, "created": {"value": false, "score": 0.2749786972999573}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}, {"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "ontop", "normalizedForm": "ontop", "offsetStart": 146, "offsetEnd": 151}, "context": "To the best of our knowledge, the only other approach meant to access arbitrary MongoDB documents with SPARQL has been proposed by the authors of ontop, Botoeva et al. [8]. ", "mentionContextAttributes": {"used": {"value": false, "score": 7.641315460205078e-05}, "created": {"value": false, "score": 0.22565513849258423}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9735612869262695}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}, {"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 147, "offsetEnd": 154}, "context": "Since Morph-xR2RML relies on the Jongo API to process a MongoDB query, we also measured the time needed by Jongo to parse the query, pass it on to MongoDB and retrieve the results from MongoDB.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999884843826294}, "created": {"value": false, "score": 3.4332275390625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 149, "offsetEnd": 155}, "context": "We show that we can always rewrite an abstract query into a union of MongoDB find queries that shall return all the documents required to answer the SPARQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.25720494985580444}, "created": {"value": false, "score": 0.001271665096282959}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 150, "offsetEnd": 158}, "context": "In Listing 1.4, the atomic query in transTPm(tp2, true) and the second atomic query in transTPm(tp3, c2) have the same From part and project the same JSONPath expression as variable ?y.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7662299275398254}, "created": {"value": false, "score": 6.079673767089844e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 151, "offsetEnd": 157}, "context": "At this point, the method we have exposed translates a SPARQL graph pattern into an effective abstract query, i.e. that preserves the semantics of the SPARQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00017827749252319336}, "created": {"value": false, "score": 0.2540329694747925}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 152, "offsetEnd": 158}, "context": "If this is verified, the SPARQL query is rewritten such that the values of the projected variables be provided as an inline solution sequence using the SPARQL 1.1 VALUES clause.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9243999719619751}, "created": {"value": false, "score": 1.1682510375976562e-05}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 152, "offsetEnd": 159}, "context": "Hence, given that UNION and INNER/LEFT OUTER JOIN operators are not processed within MongoDB, the FILTER and LIMIT operators cannot be processed within MongoDB either.", "mentionContextAttributes": {"used": {"value": false, "score": 0.46536874771118164}, "created": {"value": false, "score": 1.1324882507324219e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 152, "offsetEnd": 159}, "context": "To date, to our knowledge, the method proposed in this paper and the MongoDBenabled ontop software [8] are the only approaches meant to query arbitrary MongoDB documents with SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013720989227294922}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 154, "offsetEnd": 160}, "context": "It takes into account join constraints implied by shared variables and by cross-references defined in the mapping (xR2RML referencingobject map), and the SPARQL filter constraints whose unsatisfiability can be verified statically.", "mentionContextAttributes": {"used": {"value": false, "score": 0.04384845495223999}, "created": {"value": false, "score": 8.58306884765625e-06}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 154, "offsetEnd": 161}, "context": "To investigate this question, we compared the time it takes to run a query (i) through the Jongo API (the case of Morph-xR2RML) and (ii) directly through MongoDB's own Java API. ", "mentionContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": false, "score": 4.017353057861328e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 156, "offsetEnd": 164}, "context": "Notation <Ref> stands for any valid xR2RML data element reference, i.e. a column name for a tabular data source, an XPath expression for an XML database, a JSONPath expression for a NoSQL document store such as MongoDB and CouchDB, etc.", "mentionContextAttributes": {"used": {"value": false, "score": 0.006013989448547363}, "created": {"value": false, "score": 3.8743019104003906e-05}, "shared": {"value": false, "score": 5.245208740234375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 159, "offsetEnd": 166}, "context": "Following this approach, we developed a connector for the MongoDB document store, to translate MongoDB JSON documents into RDF and rewrite SPARQL queries into MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 5.733966827392578e-05}, "created": {"value": true, "score": 0.9996867179870605}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 161, "offsetEnd": 168}, "context": "Utilizing a mapping of this database to a SKOS thesaurus, we first measured performances in the case of single SPARQL triple patterns that translate into single MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998853206634521}, "created": {"value": false, "score": 0.07021617889404297}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 165, "offsetEnd": 170}, "context": "A tentative explanation is that Morph-xR2RML may be faster when producing blank nodes than when producing URIs, unless this difference lies in the Jena API on which Morph-xR2RML relies to handle RDF triples.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0001653432846069336}, "created": {"value": false, "score": 2.193450927734375e-05}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 170, "offsetEnd": 176}, "context": "We devised a method to translate an abstract query into MongoDB find queries, and we showed that this translation is challenged by the expressiveness discrepancy between SPARQL and the MongoDB query language.", "mentionContextAttributes": {"used": {"value": false, "score": 0.016974568367004395}, "created": {"value": true, "score": 0.9898433685302734}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 172, "offsetEnd": 179}, "context": "Besides, we do not want to define a method specifically tailored to MongoDB; our point is to provide a generic rewriting method that can be applied to the concrete case of MongoDB as well as various other databases.", "mentionContextAttributes": {"used": {"value": false, "score": 4.088878631591797e-05}, "created": {"value": true, "score": 0.7851734161376953}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 175, "offsetEnd": 181}, "context": "To date, to our knowledge, the method proposed in this paper and the MongoDBenabled ontop software [8] are the only approaches meant to query arbitrary MongoDB documents with SPARQL.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00013720989227294922}, "created": {"value": true, "score": 0.724317193031311}, "shared": {"value": false, "score": 1.1920928955078125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 177, "offsetEnd": 183}, "context": "Typically, a conjunction of two SPARQL basic graph patterns (BGP) results in the inner join of their respective translations; their union results in a SQL UNION ALL clause; the SPARQL OPTIONAL clause results in a left outer join, and a SPARQL FILTER results in an encapsulating SQL SELECT WHERE clause.", "mentionContextAttributes": {"used": {"value": false, "score": 0.024011552333831787}, "created": {"value": false, "score": 2.1457672119140625e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 183, "offsetEnd": 190}, "context": "This occurs with specific JSONPath array slice notations, or in JSONPath expressions assuming that the root document is an array field and not a document field (which is forbidden in MongoDB).", "mentionContextAttributes": {"used": {"value": false, "score": 0.008662819862365723}, "created": {"value": false, "score": 1.1920928955078125e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 183, "offsetEnd": 191}, "context": "On the one hand, this avoids the definition of a relational view over the database, but this comes with additional complexity in the translation process, as translating conditions on JSONPath expressions is not straightforward.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0005595088005065918}, "created": {"value": false, "score": 7.128715515136719e-05}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 184, "offsetEnd": 190}, "context": "In the graph materialization strategy, the transformation is applied exhaustively to the database content, the resulting RDF graph is loaded into a triple store and accessed through a SPARQL query engine [18] or by dereferencing URIs (as Linked Data).", "mentionContextAttributes": {"used": {"value": true, "score": 0.5848421454429626}, "created": {"value": false, "score": 5.054473876953125e-05}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 185, "offsetEnd": 192}, "context": "Since Morph-xR2RML relies on the Jongo API to process a MongoDB query, we also measured the time needed by Jongo to parse the query, pass it on to MongoDB and retrieve the results from MongoDB.", "mentionContextAttributes": {"used": {"value": true, "score": 0.999884843826294}, "created": {"value": false, "score": 3.4332275390625e-05}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 185, "offsetEnd": 192}, "context": "We devised a method to translate an abstract query into MongoDB find queries, and we showed that this translation is challenged by the expressiveness discrepancy between SPARQL and the MongoDB query language.", "mentionContextAttributes": {"used": {"value": false, "score": 0.016974568367004395}, "created": {"value": true, "score": 0.9898433685302734}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 187, "offsetEnd": 193}, "context": "We demonstrate the effectiveness of our method with the MongoDB NoSQL document store, such that arbitrary MongoDB documents can be aligned on existing domain ontologies and accessed with SPARQL.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998729228973389}, "created": {"value": false, "score": 0.25546348094940186}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 187, "offsetEnd": 194}, "context": "Botoeva et al. produce MongoDB aggregate queries, with the major advantage of ensuring a semantics-preserving SPARQL-to-MongoDB query translation, thus delegating the whole processing to MongoDB and making the query translation simpler.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0010126233100891113}, "created": {"value": false, "score": 0.0009582638740539551}, "shared": {"value": false, "score": 4.76837158203125e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 195, "offsetEnd": 201}, "context": "Especially, the authors did not formally define what the compatibility between a term map and a triple pattern term means, and they did not investigate the compatibility between a term map and a SPARQL filter.", "mentionContextAttributes": {"used": {"value": true, "score": 0.9933239817619324}, "created": {"value": false, "score": 0.0001207590103149414}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 196, "offsetEnd": 202}, "context": "The Semantic Web and NoSQL worlds build upon very different paradigms that are challenging to bridge over: whereas the former handles highly connected graphs along with the rich expressiveness of SPARQL, the latter trades off query expressiveness for scalability and fast retrieval of denormalized data1 .", "mentionContextAttributes": {"used": {"value": false, "score": 8.082389831542969e-05}, "created": {"value": false, "score": 0.0006304383277893066}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 196, "offsetEnd": 203}, "context": "A corollary of Theorem 1 is that, using the xR2RML mapping of a MongoDB database to RDF, we can rewrite any SPARQL 1.0 graph pattern into an abstract query whose atomic abstract queries are valid MongoDB queries or unions of valid MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0032104849815368652}, "created": {"value": false, "score": 4.410743713378906e-05}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 206, "offsetEnd": 213}, "context": "In step 2, function proj translates each projected JSONPath expression into a MongoDB projection argument, function trans translates each isNotNull and equals condition into an abstract representation of a MongoDB query (section (section 5.2), and function rewrite (section 5.2) optimizes and rewrites this abstract representation into a concrete MongoDB query or a union of concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7843112349510193}, "created": {"value": false, "score": 2.7418136596679688e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 211, "offsetEnd": 218}, "context": "Notation <Ref> stands for any valid xR2RML data element reference, i.e. a column name for a tabular data source, an XPath expression for an XML database, a JSONPath expression for a NoSQL document store such as MongoDB and CouchDB, etc. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.006013989448547363}, "created": {"value": false, "score": 3.8743019104003906e-05}, "shared": {"value": false, "score": 5.245208740234375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 212, "offsetEnd": 218}, "context": "if gp consists of a single triple pattern tp, transm(gp, f, l) = transTPm(tp, spar-qlCond(tp, f ), l) where transTPm translates a single triple pattern into an abstract query ( \u00a74.3) and sparqlCond discriminates SPARQL filter conditions ( \u00a74.1).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9936047196388245}, "created": {"value": false, "score": 2.0265579223632812e-06}, "shared": {"value": false, "score": 3.5762786865234375e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 214, "offsetEnd": 221}, "context": "More generally, the translation from the abstract query language towards MongoDB consists of two steps depicted in Fig. 2. In step 1 (detailed in section 5.2), the translation of each atomic abstract query towards MongoDB amounts to translate projections of JSONPath expressions (Project part) into MongoDB projection arguments, and conditions on JSONPath expressions (Where part) into equivalent abstract MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7133763432502747}, "created": {"value": false, "score": 5.0067901611328125e-06}, "shared": {"value": false, "score": 2.1457672119140625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "CouchDB", "normalizedForm": "CouchDB", "offsetStart": 223, "offsetEnd": 230}, "context": "Notation <Ref> stands for any valid xR2RML data element reference, i.e. a column name for a tabular data source, an XPath expression for an XML database, a JSONPath expression for a NoSQL document store such as MongoDB and CouchDB, etc. ", "mentionContextAttributes": {"used": {"value": false, "score": 0.006013989448547363}, "created": {"value": false, "score": 3.8743019104003906e-05}, "shared": {"value": false, "score": 5.245208740234375e-06}}, "documentContextAttributes": {"used": {"value": false, "score": 0.006013989448547363}, "created": {"value": false, "score": 0.20570307970046997}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "Morph", "normalizedForm": "Morph", "offsetStart": 228, "offsetEnd": 233}, "context": "Red dots represent the measures when simply querying MongoDB with Jongo, while blue dots represent the measures of the whole process executed by  The distance between the two lines gives an estimation of the overhead imposed by Morph-xR2RML to rewrite the query and generate the triples.", "mentionContextAttributes": {"used": {"value": true, "score": 0.840487003326416}, "created": {"value": false, "score": 6.556510925292969e-06}, "shared": {"value": false, "score": 2.384185791015625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999161958694458}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": true, "score": 0.8194966912269592}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 231, "offsetEnd": 238}, "context": "A corollary of Theorem 1 is that, using the xR2RML mapping of a MongoDB database to RDF, we can rewrite any SPARQL 1.0 graph pattern into an abstract query whose atomic abstract queries are valid MongoDB queries or unions of valid MongoDB queries.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0032104849815368652}, "created": {"value": false, "score": 4.410743713378906e-05}, "shared": {"value": false, "score": 1.3113021850585938e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 232, "offsetEnd": 238}, "context": "Finally, it occurs that the rich expressiveness of SQL and XQuery makes it possible to translate a SPARQL 1.0 query into a single, possibly deeply nested, target query, whose semantics is provably strictly equivalent to that of the SPARQL query.", "mentionContextAttributes": {"used": {"value": false, "score": 0.00018006563186645508}, "created": {"value": false, "score": 0.000292360782623291}, "shared": {"value": false, "score": 7.152557373046875e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 236, "offsetEnd": 242}, "context": "Typically, a conjunction of two SPARQL basic graph patterns (BGP) results in the inner join of their respective translations; their union results in a SQL UNION ALL clause; the SPARQL OPTIONAL clause results in a left outer join, and a SPARQL FILTER results in an encapsulating SQL SELECT WHERE clause.", "mentionContextAttributes": {"used": {"value": false, "score": 0.024011552333831787}, "created": {"value": false, "score": 2.1457672119140625e-06}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 244, "offsetEnd": 251}, "context": "$and : [ {\" p .0\": {$eq :10}} , {\" q \": {$elemMatch : {$eq :\" val \"}}} ] To achieve a translation from the abstract query language towards the Mon-goDB query language, we must figure out which components of an abstract query have an equivalent MongoDB rewriting, and, conversely, which components shall be computed by the query-processing engine.", "mentionContextAttributes": {"used": {"value": false, "score": 0.34386783838272095}, "created": {"value": false, "score": 1.6689300537109375e-06}, "shared": {"value": false, "score": 1.5497207641601562e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 258, "offsetEnd": 266}, "context": "More generally, the translation from the abstract query language towards MongoDB consists of two steps depicted in Fig. 2. In step 1 (detailed in section 5.2), the translation of each atomic abstract query towards MongoDB amounts to translate projections of JSONPath expressions (Project part) into MongoDB projection arguments, and conditions on JSONPath expressions (Where part) into equivalent abstract MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7133763432502747}, "created": {"value": false, "score": 5.0067901611328125e-06}, "shared": {"value": false, "score": 2.1457672119140625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 262, "offsetEnd": 268}, "context": "SPARQL 1.0 filters come with a broad set of conditional expressions including logical comparisons, literal manipulation expressions (string, numerical, boolean), XPath constructor functions, casting functions for additional data types of the RDF data model, and SPARQL built-in functions (lang, langmatches, datatype, bound, sameTerm, isIRI, isURI, isBlank, isLiteral, regex ). ", "mentionContextAttributes": {"used": {"value": false, "score": 0.005820035934448242}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 275, "offsetEnd": 283}, "context": "Term maps extract data from query results by evaluating xR2RML references whose syntax depends on the target database and is an implementation choice: typically, this may be a column name in case of a relational database, an XPath expression in case of an XML database, or a JSONPath When the evaluation of an xR2RML reference produces several RDF terms, the xR2RML processor creates one triple for each term.", "mentionContextAttributes": {"used": {"value": false, "score": 0.05944794416427612}, "created": {"value": false, "score": 5.0067901611328125e-06}, "shared": {"value": false, "score": 2.86102294921875e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 284, "offsetEnd": 290}, "context": "Two limitations can be emphasized though: (i) R2RML mappings must have constant predicates, i.e. the predicate term of the generated RDF triples cannot be built from database values; (ii) Triple patterns are considered and translated independently of each other, even when they share SPARQL variables.", "mentionContextAttributes": {"used": {"value": false, "score": 0.0014500021934509277}, "created": {"value": false, "score": 0.0001277923583984375}, "shared": {"value": false, "score": 8.344650268554688e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 299, "offsetEnd": 306}, "context": "More generally, the translation from the abstract query language towards MongoDB consists of two steps depicted in Fig. 2. In step 1 (detailed in section 5.2), the translation of each atomic abstract query towards MongoDB amounts to translate projections of JSONPath expressions (Project part) into MongoDB projection arguments, and conditions on JSONPath expressions (Where part) into equivalent abstract MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7133763432502747}, "created": {"value": false, "score": 5.0067901611328125e-06}, "shared": {"value": false, "score": 2.1457672119140625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 347, "offsetEnd": 354}, "context": "In step 2, function proj translates each projected JSONPath expression into a MongoDB projection argument, function trans translates each isNotNull and equals condition into an abstract representation of a MongoDB query (section (section 5.2), and function rewrite (section 5.2) optimizes and rewrites this abstract representation into a concrete MongoDB query or a union of concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7843112349510193}, "created": {"value": false, "score": 2.7418136596679688e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "JSONPath", "normalizedForm": "JSONPath", "offsetStart": 347, "offsetEnd": 355}, "context": "More generally, the translation from the abstract query language towards MongoDB consists of two steps depicted in Fig. 2. In step 1 (detailed in section 5.2), the translation of each atomic abstract query towards MongoDB amounts to translate projections of JSONPath expressions (Project part) into MongoDB projection arguments, and conditions on JSONPath expressions (Where part) into equivalent abstract MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7133763432502747}, "created": {"value": false, "score": 5.0067901611328125e-06}, "shared": {"value": false, "score": 2.1457672119140625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9995517134666443}, "created": {"value": true, "score": 0.9427881836891174}, "shared": {"value": false, "score": 5.245208740234375e-06}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "isBlank", "normalizedForm": "isBlank", "offsetStart": 349, "offsetEnd": 356}, "context": "SPARQL 1.0 filters come with a broad set of conditional expressions including logical comparisons, literal manipulation expressions (string, numerical, boolean), XPath constructor functions, casting functions for additional data types of the RDF data model, and SPARQL built-in functions (lang, langmatches, datatype, bound, sameTerm, isIRI, isURI, isBlank, isLiteral, regex ).", "mentionContextAttributes": {"used": {"value": false, "score": 0.005820035934448242}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.04953968524932861}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "isLiteral", "normalizedForm": "isLiteral", "offsetStart": 358, "offsetEnd": 367}, "context": "SPARQL 1.0 filters come with a broad set of conditional expressions including logical comparisons, literal manipulation expressions (string, numerical, boolean), XPath constructor functions, casting functions for additional data types of the RDF data model, and SPARQL built-in functions (lang, langmatches, datatype, bound, sameTerm, isIRI, isURI, isBlank, isLiteral, regex ).", "mentionContextAttributes": {"used": {"value": false, "score": 0.005820035934448242}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}, "documentContextAttributes": {"used": {"value": false, "score": 0.04953968524932861}, "created": {"value": false, "score": 4.0531158447265625e-06}, "shared": {"value": false, "score": 5.960464477539062e-07}}}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 384, "offsetEnd": 391}, "context": "In step 2, function proj translates each projected JSONPath expression into a MongoDB projection argument, function trans translates each isNotNull and equals condition into an abstract representation of a MongoDB query (section (section 5.2), and function rewrite (section 5.2) optimizes and rewrites this abstract representation into a concrete MongoDB query or a union of concrete MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7843112349510193}, "created": {"value": false, "score": 2.7418136596679688e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 406, "offsetEnd": 413}, "context": "More generally, the translation from the abstract query language towards MongoDB consists of two steps depicted in Fig. 2. In step 1 (detailed in section 5.2), the translation of each atomic abstract query towards MongoDB amounts to translate projections of JSONPath expressions (Project part) into MongoDB projection arguments, and conditions on JSONPath expressions (Where part) into equivalent abstract MongoDB queries.", "mentionContextAttributes": {"used": {"value": true, "score": 0.7133763432502747}, "created": {"value": false, "score": 5.0067901611328125e-06}, "shared": {"value": false, "score": 2.1457672119140625e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 421, "offsetEnd": 427}, "context": "In section 5, we showed that atomic abstract queries can be translated into equivalent MongoDB queries, but other operators of the abstract query language (INNER JOIN, LEFT OUTER JOIN, UNION) must be computed by the     query along with the corresponding triple pattern and semantics, the number of results it retrieves from the database, and the average time it took to process the query (the query processing spans the SPARQL query rewriting, the query evaluation against MongoDB and the RDF triples generation).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998661279678345}, "created": {"value": false, "score": 3.337860107421875e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "MongoDB", "normalizedForm": "MongoDB", "offsetStart": 474, "offsetEnd": 481}, "context": "In section 5, we showed that atomic abstract queries can be translated into equivalent MongoDB queries, but other operators of the abstract query language (INNER JOIN, LEFT OUTER JOIN, UNION) must be computed by the     query along with the corresponding triple pattern and semantics, the number of results it retrieves from the database, and the average time it took to process the query (the query processing spans the SPARQL query rewriting, the query evaluation against MongoDB and the RDF triples generation).", "mentionContextAttributes": {"used": {"value": true, "score": 0.9998661279678345}, "created": {"value": false, "score": 3.337860107421875e-06}, "shared": {"value": false, "score": 9.5367431640625e-07}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999961853027344}, "created": {"value": true, "score": 0.9997939467430115}, "shared": {"value": false, "score": 2.5510787963867188e-05}}, "references": [{"label": "[8]", "normalizedForm": "[8]", "refKey": 8}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 476, "offsetEnd": 482}, "context": "In [22], we show that three types of condition may be created: (i) a SPARQL variable in the triple pattern is turned into a not-null condition on the xR2RML reference corresponding to that variable in the term map, denoted by isNotNull(<xR2RML reference>); (ii) A constant term in the triple pattern (IRI or literal) is turned into an equality condition on the xR2RML reference corresponding to that term in the term map, denoted by equals(<xR2RML reference>, value); (iii) A SPARQL filter condition about a SPARQL variable is turned into a filter condition, denoted by sparqlFilter(<xR2RML reference>, f ).", "mentionContextAttributes": {"used": {"value": true, "score": 0.7912859916687012}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 1.6689300537109375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "SPARQL", "normalizedForm": "SPARQL", "offsetStart": 508, "offsetEnd": 514}, "context": "In [22], we show that three types of condition may be created: (i) a SPARQL variable in the triple pattern is turned into a not-null condition on the xR2RML reference corresponding to that variable in the term map, denoted by isNotNull(<xR2RML reference>); (ii) A constant term in the triple pattern (IRI or literal) is turned into an equality condition on the xR2RML reference corresponding to that term in the term map, denoted by equals(<xR2RML reference>, value); (iii) A SPARQL filter condition about a SPARQL variable is turned into a filter condition, denoted by sparqlFilter(<xR2RML reference>, f ).", "mentionContextAttributes": {"used": {"value": true, "score": 0.7912859916687012}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 1.6689300537109375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9999957084655762}, "created": {"value": true, "score": 0.9999123811721802}, "shared": {"value": false, "score": 2.384185791015625e-06}}, "references": [{"label": "[4]", "normalizedForm": "[4]", "refKey": 4}, {"label": "[4]", "normalizedForm": "[4]", "refKey": 4}]}, {"type": "software", "software-type": "software", "software-name": {"rawForm": "sparqlFilter", "normalizedForm": "sparqlFilter", "offsetStart": 570, "offsetEnd": 582}, "context": "In [22], we show that three types of condition may be created: (i) a SPARQL variable in the triple pattern is turned into a not-null condition on the xR2RML reference corresponding to that variable in the term map, denoted by isNotNull(<xR2RML reference>); (ii) A constant term in the triple pattern (IRI or literal) is turned into an equality condition on the xR2RML reference corresponding to that term in the term map, denoted by equals(<xR2RML reference>, value); (iii) A SPARQL filter condition about a SPARQL variable is turned into a filter condition, denoted by sparqlFilter(<xR2RML reference>, f ). ", "mentionContextAttributes": {"used": {"value": true, "score": 0.7912859916687012}, "created": {"value": false, "score": 3.933906555175781e-06}, "shared": {"value": false, "score": 1.6689300537109375e-06}}, "documentContextAttributes": {"used": {"value": true, "score": 0.9998844861984253}, "created": {"value": true, "score": 0.9889131188392639}, "shared": {"value": false, "score": 1.6689300537109375e-06}}}], "references": [{"refKey": 4, "tei": "<biblStruct xml:id=\"b4\">\n\t<analytic>\n\t\t<title level=\"a\" type=\"main\">The SPARQL2XQuery interoperability framework</title>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Nikos</forename><surname>Bikakis</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Chrisa</forename><surname>Tsinaraki</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Ioannis</forename><surname>Stavrakantonakis</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Nektarios</forename><surname>Gioldasis</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Stavros</forename><surname>Christodoulakis</surname></persName>\n\t\t</author>\n\t\t<idno type=\"DOI\">10.1007/s11280-013-0257-x</idno>\n\t</analytic>\n\t<monogr>\n\t\t<title level=\"j\">World Wide Web</title>\n\t\t<title level=\"j\" type=\"abbrev\">World Wide Web</title>\n\t\t<idno type=\"ISSN\">1386-145X</idno>\n\t\t<idno type=\"ISSNe\">1573-1413</idno>\n\t\t<imprint>\n\t\t\t<biblScope unit=\"volume\">18</biblScope>\n\t\t\t<biblScope unit=\"issue\">2</biblScope>\n\t\t\t<biblScope unit=\"page\" from=\"403\" to=\"490\" />\n\t\t\t<date type=\"published\" when=\"2014-01-14\">Mar 2015</date>\n\t\t\t<publisher>Springer Science and Business Media LLC</publisher>\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}, {"refKey": 15, "tei": "<biblStruct xml:id=\"b15\">\n\t<analytic>\n\t\t<title level=\"a\" type=\"main\">TAXREF v9. 0, r\u00e9f\u00e9rentiel taxonomique pour la France: M\u00e9thodologie</title>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">P</forename><surname>Gargominy</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">S</forename><surname>Tercerie</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">C</forename><surname>R\u00e9gnier</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">T</forename><surname>Ramage</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">P</forename><surname>Dupont</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">E</forename><surname>Vandel</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">P</forename><surname>Daszkiewicz</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">L</forename><surname>Poncet</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">C</forename><surname>Schoelink</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">O</forename><surname>G\u00f6rlitz</surname></persName>\n\t\t</author>\n\t</analytic>\n\t<monogr>\n\t\t<title level=\"m\">SPLENDID: SPARQL Endpoint Federation Exploiting VOID Descriptions</title>\n\t\t<imprint>\n\t\t\t<publisher>Intl. Ws. COLD</publisher>\n\t\t\t<date>2011</date>\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}, {"refKey": 8, "tei": "<biblStruct xml:id=\"b8\">\n\t<analytic>\n\t\t<title level=\"a\" type=\"main\">Beyond OWL 2 QL in OBDA: Rewritings and Approximations</title>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Elena</forename><surname>Botoeva</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Diego</forename><surname>Calvanese</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Valerio</forename><surname>Santarelli</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Domenico</forename><surname>Savo</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Alessandro</forename><surname>Solimando</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Guohui</forename><surname>Xiao</surname></persName>\n\t\t</author>\n\t\t<idno type=\"DOI\">10.1609/aaai.v30i1.10102</idno>\n\t</analytic>\n\t<monogr>\n\t\t<title level=\"j\">Proceedings of the AAAI Conference on Artificial Intelligence</title>\n\t\t<title level=\"j\" type=\"abbrev\">AAAI</title>\n\t\t<idno type=\"ISSN\">2159-5399</idno>\n\t\t<idno type=\"ISSNe\">2374-3468</idno>\n\t\t<imprint>\n\t\t\t<biblScope unit=\"volume\">30</biblScope>\n\t\t\t<biblScope unit=\"issue\">1</biblScope>\n\t\t\t<date type=\"published\" when=\"2016-02-21\">2016</date>\n\t\t\t<publisher>Association for the Advancement of Artificial Intelligence (AAAI)</publisher>\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}, {"refKey": 28, "tei": "<biblStruct xml:id=\"b28\">\n\t<analytic>\n\t\t<title level=\"a\" type=\"main\">Formalisation and experiences of R2RML-based SPARQL to SQL query translation using morph</title>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Freddy</forename><surname>Priyatna</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Oscar</forename><surname>Corcho</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Juan</forename><surname>Sequeda</surname></persName>\n\t\t</author>\n\t\t<idno type=\"DOI\">10.1145/2566486.2567981</idno>\n\t</analytic>\n\t<monogr>\n\t\t<title level=\"m\">Proceedings of the 23rd international conference on World wide web</title>\n\t\t<meeting>the 23rd international conference on World wide web</meeting>\n\t\t<imprint>\n\t\t\t<publisher>ACM</publisher>\n\t\t\t<date type=\"published\" when=\"2014-04-07\">2014</date>\n\t\t\t<biblScope unit=\"volume\">124</biblScope>\n\t\t\t<biblScope unit=\"page\" from=\"479\" to=\"490\" />\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}, {"refKey": 26, "tei": "<biblStruct xml:id=\"b26\">\n\t<analytic>\n\t\t<title level=\"a\" type=\"main\">Semantics and complexity of SPARQL</title>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Jorge</forename><surname>P\u00e9rez</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Marcelo</forename><surname>Arenas</surname></persName>\n\t\t</author>\n\t\t<author>\n\t\t\t<persName><forename type=\"first\">Claudio</forename><surname>Gutierrez</surname></persName>\n\t\t</author>\n\t\t<idno type=\"DOI\">10.1145/1567274.1567278</idno>\n\t</analytic>\n\t<monogr>\n\t\t<title level=\"j\">ACM Transactions on Database Systems</title>\n\t\t<title level=\"j\" type=\"abbrev\">ACM Trans. Database Syst.</title>\n\t\t<idno type=\"ISSN\">0362-5915</idno>\n\t\t<idno type=\"ISSNe\">1557-4644</idno>\n\t\t<imprint>\n\t\t\t<biblScope unit=\"volume\">34</biblScope>\n\t\t\t<biblScope unit=\"issue\">3</biblScope>\n\t\t\t<biblScope unit=\"page\" from=\"1\" to=\"45\" />\n\t\t\t<date type=\"published\" when=\"2009-08\">Aug 2009</date>\n\t\t\t<publisher>Association for Computing Machinery (ACM)</publisher>\n\t\t</imprint>\n\t</monogr>\n</biblStruct>\n"}], "runtime": 27721, "id": "a600b766bea9005f13537b556b5813185d89bcfc", "metadata": {"id": "a600b766bea9005f13537b556b5813185d89bcfc"}, "original_file_path": "../../datalake/Samuel/SOFTware-Sync/downloads/xml/hal-01926379.grobid.tei.xml", "file_name": "hal-01926379.grobid.tei.xml"}