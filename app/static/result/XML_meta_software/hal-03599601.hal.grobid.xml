<?xml version='1.0' encoding='utf-8'?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 http://api.archives-ouvertes.fr/documents/aofr-sword.xsd">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>HAL TEI export of hal-03599601</title>
      </titleStmt>
      <publicationStmt>
        <distributor>CCSD</distributor>
        <availability status="restricted">
          <licence target="http://creativecommons.org/licenses/by/4.0/">Distributed under a Creative Commons Attribution 4.0 International License</licence>
        </availability>
        <date when="2024-04-29T11:44:59+02:00" />
      </publicationStmt>
      <sourceDesc>
        <p part="N">HAL API platform</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <listBibl>
        <biblFull>
          <titleStmt>
            <title xml:lang="en">A Journey to the Frontiers of Query Rewritability</title>
            <author role="aut">
              <persName>
                <forename type="first">Piotr</forename>
                <surname>Ostropolski-Nalewaja</surname>
              </persName>
              <idno type="halauthorid">2446504-0</idno>
              <affiliation ref="#struct-136847" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Jerzy</forename>
                <surname>Marcinkowski</surname>
              </persName>
              <idno type="halauthorid">600106-0</idno>
              <affiliation ref="#struct-136847" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">David</forename>
                <surname>Carral</surname>
              </persName>
              <email type="md5">6d4c8b0246d7867f952bd8ea95d621e8</email>
              <email type="domain">inria.fr</email>
              <idno type="idhal" notation="string">david-carral</idno>
              <idno type="idhal" notation="numeric">748575</idno>
              <idno type="halauthorid" notation="string">54533-748575</idno>
              <idno type="ORCID">https://orcid.org/0000-0001-7287-4709</idno>
              <affiliation ref="#struct-1102911" />
              <affiliation ref="#struct-1100620" />
              <affiliation ref="#struct-34586" />
              <affiliation ref="#struct-1100589" />
              <affiliation ref="#struct-441569" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Sebastian</forename>
                <surname>Rudolph</surname>
              </persName>
              <email type="md5">ac5938c3dc736d968f5495c4280ba2ad</email>
              <email type="domain">tu-dresden.de</email>
              <idno type="idhal" notation="numeric">950283</idno>
              <idno type="halauthorid" notation="string">536461-950283</idno>
              <orgName ref="#struct-0" />
              <affiliation ref="#struct-96520" />
            </author>
            <editor role="depositor">
              <persName>
                <forename>David</forename>
                <surname>Carral</surname>
              </persName>
              <email type="md5">6d4c8b0246d7867f952bd8ea95d621e8</email>
              <email type="domain">inria.fr</email>
            </editor>
            <funder ref="#projanr-48388" />
            <funder>Ostropolski-Nalewaja and Marcinkowski were supported by the Polish National Science Centre (NCN) grant2016/23/B/ST6/01438. Carral was supported by the ANR project CQFD (ANR-18-CE23-0003), the DFG project 389792660 (TRR 248, Center for Perspicuous Systems) and by the BMBF in the Center for Scalable Data Analytics and Artificial Intelligence (ScaDS.AI). Rudolph was supported by the European Research Council through the ERC Consolidator Grant DeciGUT (project number 771779).</funder>
          </titleStmt>
          <editionStmt>
            <edition n="v1" type="current">
              <date type="whenSubmitted">2022-03-14 14:19:29</date>
              <date type="whenModified">2024-03-07 14:26:04</date>
              <date type="whenReleased">2022-03-14 15:31:43</date>
              <date type="whenProduced">2022-06-12</date>
              <date type="whenEndEmbargoed">2022-03-14</date>
              <ref type="file" target="https://hal.science/hal-03599601/document">
                <date notBefore="2022-03-14" />
              </ref>
              <ref type="file" subtype="author" n="1" target="https://hal.science/hal-03599601/file/fus-fes-conjecture-pods-2022-tr.pdf">
                <date notBefore="2022-03-14" />
              </ref>
              <ref type="externalLink" target="http://arxiv.org/pdf/2012.11269" />
            </edition>
            <respStmt>
              <resp>contributor</resp>
              <name key="1070220">
                <persName>
                  <forename>David</forename>
                  <surname>Carral</surname>
                </persName>
                <email type="md5">6d4c8b0246d7867f952bd8ea95d621e8</email>
                <email type="domain">inria.fr</email>
              </name>
            </respStmt>
          </editionStmt>
          <publicationStmt>
            <distributor>CCSD</distributor>
            <idno type="halId">hal-03599601</idno>
            <idno type="halUri">https://hal.science/hal-03599601</idno>
            <idno type="halBibtex">ostropolskinalewaja:hal-03599601</idno>
            <idno type="halRefHtml">&lt;i&gt;PODS 2022 - 41st ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems&lt;/i&gt;, Jun 2022, Philadelphia, United States. pp.359-367, &lt;a target="_blank" href="https://dx.doi.org/10.1145/3517804.3524163"&gt;&amp;#x27E8;10.1145/3517804.3524163&amp;#x27E9;&lt;/a&gt;</idno>
            <idno type="halRef">PODS 2022 - 41st ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, Jun 2022, Philadelphia, United States. pp.359-367, &amp;#x27E8;10.1145/3517804.3524163&amp;#x27E9;</idno>
          </publicationStmt>
          <seriesStmt>
            <idno type="stamp" n="CNRS">CNRS - Centre national de la recherche scientifique</idno>
            <idno type="stamp" n="INRIA">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="INRIA-SOPHIA">INRIA Sophia Antipolis - MÃ©diterranÃ©e</idno>
            <idno type="stamp" n="IATE">IngÃ©nierie des agropolymÃ¨res et technologies Ã©mergentes</idno>
            <idno type="stamp" n="INRIASO">INRIA-SOPHIA</idno>
            <idno type="stamp" n="INRIA_TEST">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="TESTALAIN1">TESTALAIN1</idno>
            <idno type="stamp" n="LIRMM">Laboratoire d'Informatique de Robotique et de MicroÃ©lectronique de Montpellier</idno>
            <idno type="stamp" n="INRIA2">INRIA 2</idno>
            <idno type="stamp" n="UNIV-MONTPELLIER">UniversitÃ© de Montpellier</idno>
            <idno type="stamp" n="INSTITUT-AGRO-MONTPELLIER">Institut Agro Montpellier</idno>
            <idno type="stamp" n="INRAE">Institut National de Recherche en Agriculture, Alimentation et Environnement</idno>
            <idno type="stamp" n="INRAEOCCITANIEMONTPELLIER" corresp="INRAE">INRAE Occitanie Montpellier</idno>
            <idno type="stamp" n="ANR">ANR</idno>
            <idno type="stamp" n="UM-2015-2021" corresp="UNIV-MONTPELLIER">UniversitÃ© de Montpellier (2015-2021)</idno>
            <idno type="stamp" n="UM-EPE" corresp="UNIV-MONTPELLIER">UniversitÃ© de Montpellier - EPE</idno>
            <idno type="stamp" n="BOREAL" corresp="LIRMM">ReprÃ©sentation de Connaissances et Langages Ã  Base de RÃ¨gles pour Raisonner sur les DonnÃ©es</idno>
            <idno type="stamp" n="INSTITUT-AGRO">Institut Agro</idno>
            <idno type="stamp" n="INRIA-ALLEMAGNE">INRIA-ALLEMAGNE</idno>
          </seriesStmt>
          <notesStmt>
            <note type="audience" n="2">International</note>
            <note type="invited" n="0">No</note>
            <note type="popular" n="0">No</note>
            <note type="peer" n="1">Yes</note>
            <note type="proceedings" n="1">Yes</note>
          </notesStmt>
          <sourceDesc>
            <biblStruct>
              <analytic>
                <title xml:lang="en">A Journey to the Frontiers of Query Rewritability</title>
                <author role="aut">
                  <persName>
                    <forename type="first">Piotr</forename>
                    <surname>Ostropolski-Nalewaja</surname>
                  </persName>
                  <idno type="halauthorid">2446504-0</idno>
                  <affiliation ref="#struct-136847" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Jerzy</forename>
                    <surname>Marcinkowski</surname>
                  </persName>
                  <idno type="halauthorid">600106-0</idno>
                  <affiliation ref="#struct-136847" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">David</forename>
                    <surname>Carral</surname>
                  </persName>
                  <email type="md5">6d4c8b0246d7867f952bd8ea95d621e8</email>
                  <email type="domain">inria.fr</email>
                  <idno type="idhal" notation="string">david-carral</idno>
                  <idno type="idhal" notation="numeric">748575</idno>
                  <idno type="halauthorid" notation="string">54533-748575</idno>
                  <idno type="ORCID">https://orcid.org/0000-0001-7287-4709</idno>
                  <affiliation ref="#struct-1102911" />
                  <affiliation ref="#struct-1100620" />
                  <affiliation ref="#struct-34586" />
                  <affiliation ref="#struct-1100589" />
                  <affiliation ref="#struct-441569" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Sebastian</forename>
                    <surname>Rudolph</surname>
                  </persName>
                  <email type="md5">ac5938c3dc736d968f5495c4280ba2ad</email>
                  <email type="domain">tu-dresden.de</email>
                  <idno type="idhal" notation="numeric">950283</idno>
                  <idno type="halauthorid" notation="string">536461-950283</idno>
                  <orgName ref="#struct-0" />
                  <affiliation ref="#struct-96520" />
                </author>
              </analytic>
              <monogr>
                <meeting>
                  <title>PODS 2022 - 41st ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
                  <date type="start">2022-06-12</date>
                  <date type="end">2022-06-17</date>
                  <settlement>Philadelphia</settlement>
                  <country key="US">United States</country>
                </meeting>
                <imprint>
                  <biblScope unit="pp">359â€“367</biblScope>
                </imprint>
              </monogr>
              <idno type="arxiv">2012.11269</idno>
              <idno type="doi">10.1145/3517804.3524163</idno>
              <ref type="publisher">https://2022.sigmod.org/</ref>
            </biblStruct>
          </sourceDesc>
          <profileDesc>
            <langUsage>
              <language ident="en">English</language>
            </langUsage>
            <textClass>
              <classCode scheme="halDomain" n="info">Computer Science [cs]</classCode>
              <classCode scheme="halTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halOldTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halTreeTypology" n="COMM">Conference papers</classCode>
            </textClass>
            <abstract xml:lang="en">
              <p>We consider (first-order) query rewritability in the context of theorymediated query answering. The starting point of our journey is the FUS/FES conjecture, which states that any theory that is a finite expansion set (FES) and admits query rewriting (BDD, FUS) must be uniformly bounded. We show that this conjecture holds for a large class of BDD theories, which we call "local". Upon investigating how "non-local" BDD theories can actually get, we discover unexpected phenomena that, we think, are at odds with prevailing intuitions about BDD theories.</p>
            </abstract>
          </profileDesc>
        </biblFull>
      </listBibl>
    </body>
    <back>
      <listOrg type="structures">
        <org type="laboratory" xml:id="struct-136847" status="VALID">
          <orgName>Institute of Mathematics and Computer Science [Wroclaw]</orgName>
          <orgName type="acronym">IMCS</orgName>
          <desc>
            <address>
              <addrLine>ul. Wybrzeze Wyspianskiego 27 50-370 Wroclaw</addrLine>
              <country key="PL" />
            </address>
            <ref type="url">http://www.im.pwr.wroc.pl/en/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-461233" type="direct" />
          </listRelation>
        </org>
        <org type="researchteam" xml:id="struct-1102911" status="VALID">
          <idno type="RNSR">202224285F</idno>
          <orgName>ReprÃ©sentation de Connaissances et Langages Ã  Base de RÃ¨gles pour Raisonner sur les DonnÃ©es</orgName>
          <orgName type="acronym">BOREAL</orgName>
          <date type="start">2022-06-01</date>
          <desc>
            <address>
              <addrLine>LIRMM, 161 rue Ada, 34000 Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.lirmm.fr/equipes/BOREAL</ref>
          </desc>
          <listRelation>
            <relation active="#struct-34586" type="direct" />
            <relation active="#struct-300009" type="indirect" />
            <relation active="#struct-1100620" type="direct" />
            <relation name="UMR5506" active="#struct-441569" type="indirect" />
            <relation name="UMR5506" active="#struct-1100589" type="indirect" />
            <relation active="#struct-1100827" type="direct" />
            <relation name="UMR1208" active="#struct-577435" type="indirect" />
            <relation active="#struct-1096330" type="indirect" />
            <relation active="#struct-1042499" type="indirect" />
            <relation active="#struct-1100589" type="indirect" />
          </listRelation>
        </org>
        <org type="laboratory" xml:id="struct-1100620" status="VALID">
          <idno type="IdRef">139590827</idno>
          <idno type="ISNI">0000000405990488</idno>
          <idno type="RNSR">199111950H</idno>
          <idno type="ROR">https://ror.org/013yean28</idno>
          <orgName>Laboratoire d'Informatique de Robotique et de MicroÃ©lectronique de Montpellier</orgName>
          <orgName type="acronym">LIRMM</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>161 rue Ada - 34095 Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.lirmm.fr</ref>
          </desc>
          <listRelation>
            <relation name="UMR5506" active="#struct-441569" type="direct" />
            <relation name="UMR5506" active="#struct-1100589" type="direct" />
          </listRelation>
        </org>
        <org type="laboratory" xml:id="struct-34586" status="VALID">
          <idno type="RNSR">198318250R</idno>
          <idno type="ROR">https://ror.org/01nzkaw91</idno>
          <orgName>Inria Sophia Antipolis - MÃ©diterranÃ©e</orgName>
          <orgName type="acronym">CRISAM</orgName>
          <desc>
            <address>
              <addrLine>2004 route des Lucioles BP 93 06902 Sophia Antipolis</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/centre/sophia/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300009" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-1100589" status="VALID">
          <idno type="ROR">https://ror.org/051escj72</idno>
          <orgName>UniversitÃ© de Montpellier</orgName>
          <orgName type="acronym">UM</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>163 rue Auguste Broussonnet - 34090 Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.umontpellier.fr/</ref>
          </desc>
        </org>
        <org type="regroupinstitution" xml:id="struct-441569" status="VALID">
          <idno type="IdRef">02636817X</idno>
          <idno type="ISNI">0000000122597504</idno>
          <idno type="ROR">https://ror.org/02feahw73</idno>
          <orgName>Centre National de la Recherche Scientifique</orgName>
          <orgName type="acronym">CNRS</orgName>
          <date type="start">1939-10-19</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cnrs.fr/</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-96520" status="VALID">
          <idno type="ROR">https://ror.org/042aqky30</idno>
          <orgName>Technische UniversitÃ¤t Dresden = Dresden University of Technology</orgName>
          <orgName type="acronym">TU Dresden</orgName>
          <desc>
            <address>
              <addrLine>TU Dresden 01062 Dresden</addrLine>
              <country key="DE" />
            </address>
            <ref type="url">http://tu-dresden.de/</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-461233" status="VALID">
          <idno type="ROR">https://ror.org/008fyn775</idno>
          <orgName>Wroclaw University of Science and Technology</orgName>
          <desc>
            <address>
              <addrLine>27 WybrzeÅ¼e WyspiaÅ„skiego St50-370 WrocÅ‚aw</addrLine>
              <country key="PL" />
            </address>
            <ref type="url">http://pwr.edu.pl/en/</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-300009" status="VALID">
          <idno type="ROR">https://ror.org/02kvxyf05</idno>
          <orgName>Institut National de Recherche en Informatique et en Automatique</orgName>
          <orgName type="acronym">Inria</orgName>
          <desc>
            <address>
              <addrLine>Domaine de VoluceauRocquencourt - BP 10578153 Le Chesnay Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/en/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-1100827" status="VALID">
          <idno type="ISNI">0000000403736662</idno>
          <idno type="RNSR">200317667V</idno>
          <idno type="ROR">https://ror.org/0000n5x09</idno>
          <orgName>IngÃ©nierie des Agro-polymÃ¨res et Technologies Ã‰mergentes</orgName>
          <orgName type="acronym">UMR IATE</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>Campus de la Gaillarde 2, place Pierre Viala 34 060 Montpellier CÃ©dex 02 - FRANCE</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://umr-iate.cirad.fr/</ref>
          </desc>
          <listRelation>
            <relation name="UMR1208" active="#struct-577435" type="direct" />
            <relation active="#struct-1096330" type="direct" />
            <relation active="#struct-1042499" type="indirect" />
            <relation active="#struct-1100589" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-577435" status="VALID">
          <idno type="ROR">https://ror.org/003vg9w96</idno>
          <orgName>Institut National de Recherche pour lâ€™Agriculture, lâ€™Alimentation et lâ€™Environnement</orgName>
          <orgName type="acronym">INRAE</orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
          </desc>
        </org>
        <org type="institution" xml:id="struct-1096330" status="VALID">
          <idno type="IdRef">261038990</idno>
          <idno type="ROR">https://ror.org/03rnk6m14</idno>
          <orgName>Institut Agro Montpellier</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>2, place Viala - Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.institut-agro-montpellier.fr/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-1042499" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-1042499" status="VALID">
          <idno type="IdRef">260373249</idno>
          <orgName>Institut national d'enseignement supÃ©rieur pour l'agriculture, l'alimentation et l'environnement</orgName>
          <orgName type="acronym">Institut Agro</orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.institut-agro.fr</ref>
          </desc>
        </org>
      </listOrg>
      <listOrg type="projects">
        <org type="anrProject" xml:id="projanr-48388" status="VALID">
          <idno type="anr">ANR-18-CE23-0003</idno>
          <idno type="program">APPEL Ã€ PROJETS GÃ‰NÃ‰RIQUE 2018</idno>
          <orgName>CQFD</orgName>
          <desc>RequÃªtes Ontologiques Complexes sur des FÃ©dÃ©rations de DonnÃ©es HÃ©tÃ©rogÃ¨nese</desc>
          <date type="start">2018</date>
        </org>
      </listOrg>
    </back>
  <teiCorpus>
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Journey to the Frontiers of Query Rewritability (Extended Technical Report)</title>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Piotr</forename><surname>Ostropolski-Nalewaja</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution">University of WrocÅ‚aw</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jerzy</forename><surname>Marcinkowski</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution">University of WrocÅ‚aw</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<affiliation key="aff2">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
							<affiliation key="aff3">
								<orgName type="laboratory">Computational Logic Group</orgName>
								<orgName type="institution">TU Dresden</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Journey to the Frontiers of Query Rewritability (Extended Technical Report)</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">5FE289DB1942158B81DA9BCDEE9ABE27</idno>
					<idno type="DOI">10.1145/3517804.3524163</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>We consider (first-order) query rewritability in the context of theorymediated query answering. The starting point of our journey is the FUS/FES conjecture, which states that any theory that is a finite expansion set (FES) and admits query rewriting (BDD, FUS) must be uniformly bounded. We show that this conjecture holds for a large class of BDD theories, which we call "local". Upon investigating how "non-local" BDD theories can actually get, we discover unexpected phenomena that, we think, are at odds with prevailing intuitions about BDD theories.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>The scenario we consider in this paper has been studied extensively both in database theory and in knowledge representation: consider a database instance D (also called fact set, or structure) and a theory T (or rule set) that consists of tuple generating dependencies (or rules). For a given conjunctive query ğœ™, we ask if D and T together logically entail ğœ™, written: D, T |= ğœ™. This problem is also referred to as ontology-mediated query answering. The chase. The notion of the chase is fundamental in this context. It denotes a structure obtained from D via the chase procedure, which iteratively adds new terms and atoms in order to satisfy the constraints from T , producing a growing sequence of structures D=ğ¶â„ 0 (D, T ), ğ¶â„ 1 (D, T ), ğ¶â„ 2 (D, T ), . . .. The chase ğ¶â„(D, T ) is then obtained as the corresponding fixpoint ğ‘– âˆˆN ğ¶â„ ğ‘– (D, T ).</p><p>It is known <ref type="bibr" target="#b0">[1]</ref> that a conjunctive query is entailed if and only if it holds in the corresponding chase, which allows for reducing entailment to model checking:</p><formula xml:id="formula_0">âˆ€T âˆ€D âˆ€ğœ™ ğ¶â„(D, T ) |= ğœ™ â‡” D, T |= ğœ™ .</formula><p>Finite expansion sets. We say T enjoys the finite expansion set property <ref type="bibr" target="#b1">[2]</ref> (or simply is FES) if, for every D, all conjunctive queries satisfied in ğ¶â„(D, T ) are already jointly satisfied after finitely many chase steps. More precisely, T is FES if:</p><formula xml:id="formula_1">âˆ€D âˆƒğ‘– âˆˆ N âˆ€ğœ™ ğ¶â„(D, T ) |= ğœ™ â‡” ğ¶â„ ğ‘– (D, T ) |= ğœ™ (FES)</formula><p>This is an important property, since ğ¶â„(D, T ) is typically an infinite structure, only existing as an abstract mathematical object, and impossible to query, whereas ğ¶â„ ğ‘– (D, T ) is always finite and so in principle it can be computed and queried. Bounded derivation depth. An arguably even more beneficial property a theory can enjoy in this context is the following: We say T has the bounded derivation depth property (or is BDD) if which means that, in order to evaluate ğœ™, it is enough to run only the first ğ‘– steps of the chase, with ğ‘– depending on ğœ™ but not on D.</p><p>As it turns out, BDD is equivalent <ref type="bibr" target="#b2">[3]</ref> to FUS (finite unification set) <ref type="bibr" target="#b1">[2]</ref>. FUS is the class ensuring that conjunctive queries always rewrite: for each ğœ™ one can compute a query ğœ™ T , being a union of conjunctive queries, such that for each D we have that ğ¶â„(D, T ) |= ğœ™ exactly if D |= ğœ™ T -this is known to be equivalent to the existence of an arbitrary first-order rewriting <ref type="bibr" target="#b3">[4]</ref>.</p><p>Behold the extreme usefulness of this property: instead of querying ğ¶â„(D, T ), an elusive infinite structure, we can equivalently query D, the only structure we have immediate access to.</p><p>No wonder the BDD/FUS property has been considered in literally hundreds of papers. Numerous classes of BDD theories have been identified and intensively studied, among them subclasses with decidable membership like: â€¢ linear theories, where rules have at most one body atom; â€¢ guarded BDD theories (while not all guarded theories are BDD, it is decidable to determine if a guarded theory is BDD <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>), generalizing linear theories; â€¢ sticky theories, defined by a reasonably natural syntactic restriction on the use of joins <ref type="bibr" target="#b6">[7]</ref>.</p><p>Apart from the decidable subclasses of BDD, there are also natural undecidable subclasses: â€¢ bounded Datalog theories, already studied decades before the class BDD itself was discovered <ref type="bibr" target="#b7">[8]</ref>; â€¢ binary BDD theories, where the arity of relation symbols is at most 2 (also studied in the context of description logics <ref type="bibr" target="#b8">[9]</ref>); â€¢ backward shy theories <ref type="bibr" target="#b9">[10]</ref>, a superclass of sticky theories.</p><p>As we expose in this paper, despite this extensive body of work, we still understand very little about the deeper mathematical properties of BDD theories. In particular, we are going to show that the intuition of BDD theories as being "local", "only depending on the small pieces of D", and "unable to look too far" while (more or less) correct for all aforementioned classes of BDD theories is blatantly incorrect for BDD theories in general.</p><p>The FUS/FES conjecture. There is a striking similarity between formulas (BDD) and (FES), inspiring a natural conjecture, which we call the FUS/FES conjecture: For any BDD theory that is also FES, it should be possible to choose the number ğ‘– in a uniform way, independently from both D and ğœ™. In other words, the conjecture says that if T is both BDD and FES then:</p><formula xml:id="formula_2">âˆƒğ‘– âˆˆ N âˆ€ğœ™ âˆ€D ğ¶â„(D, T ) |= ğœ™ â‡” ğ¶â„ ğ‘– (D, T ) |= ğœ™ (UBDD)</formula><p>This conjecture was studied earlier <ref type="bibr" target="#b10">[11]</ref> and a proof was proposed, which however turned out to be incorrect and was later withdrawn.</p><p>Later, it was shown that the conjecture would hold if the assumption that T is FES were replaced by a stronger property <ref type="bibr" target="#b11">[12]</ref>.</p><p>Main results. We identify the new, generic class of local BDD theories. Informally, such theories enforce that the creation of every chase atom depends only on a constant number of facts from the database. Importantly, this new class not only includes most of the aforementioned subclasses of BDD (with sticky and backward shy being notable exceptions) but also all BDD theories over signatures with a maximum predicate arity of 2.</p><p>With this new class of theories defined (and the above inclusions proved), we present our three main results: First that the FUS/FES conjecture holds for local theories (Theorem 2). Second that the conjecture holds for every BDD theory over a binary signature (Corollary 1) -an immediate consequence of the fact that such theories are local (Theorem 1).</p><p>Yet, as least as interesting as these insights we find our third result (reflected in Theorem 3): the discovery of very much nonlocal (and not even what we call bounded-degree local) theories that are still BDD. Such theories not only defy many of the popular intuitions about the BDD class, but also shows that all previous investigations into that class have probably barely scratched its surface and that there is a lot of room for new decidable/syntactic classes of BDD theories, richer than all hitherto considered. One plausible reason why this new world exhibits counterintuitive phenomena and has gone entirely unnoticed is that it requires theories of arity higher than 2. Binary theories are much easier to imagine and they are mainly responsible for shaping our intuitions.</p><p>Summarizing, the main message of this paper is: even if a (finite) counterexample to the FUS/FES conjecture should exist, it is going to be found nowhere near the familiar avenues of the BDD class. But we also show that the known avenues only reach a small part of the BDD class and there is a lot of uncharted territory left. Organisation of this paper. Apart from its preliminary sections (Sections 2-7), the paper is organized as follows:</p><p>In Section 8 we define local theories. Later we state our first result Theorem 1 and present a brief insight into its proof.</p><p>In Section 9 we state our second result -that the FUS/FES conjecture holds for local theories (Theorem 2) -and prove it. Also we note that the conjecture holds for theories over binary signatures (Corollary 1).</p><p>In Section 10, we notice that sticky theories, while BDD, are not always local. We define another, weaker, notion, of bounded-degreelocal theories (or bd-local) and note that it covers sticky. Later we discuss properties of this newly defined class.</p><p>In Section 11 we examine the intuition that "BDD theories are unable to look too far". We define the notion of distancing theories, and show that if a theory is local then it is also distancing. We also notice that backward shy theories are distancing, so that most of the previously known examples of BDD theories are indeed distancing. We show however, that there exists a BDD theory T ğ‘‘ that is not distancing. As a corollary we get that, for this BDD theory, the rewriting ğœ™ T ğ‘‘ (which is a disjunction of conjunctive queries) of a query ğœ™ can require disjuncts of exponential size with respect to the size of ğœ™. This is in stark contrast to any BDD theories previously considered.</p><p>Finally in Section 12, we conclude and discuss future work.</p><p>This is an extended technical report of an article with the same title published at PODS 2022. It includes the complete formal proofs for all results in the appendix.</p></div>
<div><head n="2">PRELIMINARIES</head><p>Queries and TGDs. A conjunctive query (CQ) is a formula ğœ“ ( È³) = âˆƒ x ğ›½ ( x, È³) with ğ›½ being a non-empty conjunction of atomic formulas over some signature (or schema) Î£ (which is a finite set of relation symbols) and over some set of variables and set of constants. So, for example âˆƒğ‘¥ ğ‘†ğ‘–ğ‘ğ‘™ğ‘–ğ‘›ğ‘”ğ‘  (ğ´ğ‘ğ‘’ğ‘™, ğ‘¥), ğ¹ğ‘’ğ‘šğ‘ğ‘™ğ‘’ (ğ‘¥) is a CQ.</p><p>A boolean CQ (short: BCQ) is a CQ with all variables quantified (as in the preceding example). We refer to ğ›½ as the body of ğœ“ ( È³). By a union of conjunctive queries (UCQ) we mean a formula being a disjunction of CQs. By the size of a CQ, denoted |ğœ“ ( È³)|, we mean the number of atomic formulas it is built of. By the width of a UCQ we will mean the size of its greatest disjunct. Also, we will sometimes treat UCQs as sets of CQs.</p><p>A theory or a rule set is a finite set of tuple generating dependencies (TGDs, often just referred to as rules). A rule is a first-order logic formula of the form âˆ€x, È³ ğ›½ ( x, È³) â‡’ âˆƒ w ğ›¼ ( È³, w) , where x, È³ and w are pairwise disjoint lists of variables, ğ›½ ( x, È³) (the rule's body) is a conjunction of atomic formulas and ğ›¼ ( È³, w) (the rule's head) is an atomic formula. The frontier È³ of a rule ğœŒ, denoted fr (ğœŒ), is the set of all variables that occur both in the body and the head of the rule. We omit universal quantifiers when writing rules and treat conjunctions of atoms (such as ğ›½) as sets of atoms.</p><p>Note that, in database theory terminology, our rules are "single head" TGDs. This is the only reasonable choice in this context, since we want to talk about theories over a binary signature: if we allowed rule heads to comprise several atoms, then rules with predicates of any arity could be easily simulated using only arity 2 predicates. On the other hand, this does not restrict our results in the cases where we do not assume that the signature is binary, since every multi-head theory can be rewritten into a single-head one, using higher-arity auxiliary predicates, and this rewriting does not affect the property of being FUS or FES. Structures and entailment. A database instance (or structure or fact set) is a set of facts -atomic formulas over Î£. For a structure F over Î£ we let ğ‘‘ğ‘œğ‘š(F) denote its active domain -the set of all terms that appear in the facts of F. For ğ‘, ğ‘ â€² âˆˆ ğ‘‘ğ‘œğ‘š(F), we let ğ‘‘ğ‘–ğ‘ ğ‘¡ F (ğ‘, ğ‘ â€² ) denote the distance between ğ‘ and ğ‘ â€² in the Gaifman graph of F: the vertices of this graph are elements of ğ‘‘ğ‘œğ‘š(F) and two vertices are connected by an edge if and only if they appear in the same fact. We define the degree of F as the degree of F's Gaifman graph.</p><p>F is a model of T (written: Homomorphisms and query containment. For structures D, F, a homomorphism from D to F is a function â„ : ğ‘‘ğ‘œğ‘š(D) â†’ ğ‘‘ğ‘œğ‘š(F) such that ğ´(â„( Ã¬ ğ‘¥)) âˆˆ F for each fact ğ´( Ã¬ ğ‘¥) âˆˆ D and that â„(ğ‘) = ğ‘ for any constant ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D). Given a fact ğ›¼ = ğ´( Ã¬ ğ‘¥) âˆˆ D, we will use â„(ğ›¼) to denote ğ´(â„( Ã¬ ğ‘¥)). For two CQs ğœ™ ( È³) and ğœ“ ( È³), with the same set of free variables, we say that ğœ™ ( È³) contains ğœ“ ( È³) if for every structure D and for every tuple Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | if D |= ğœ“ ( Ä) than also D |= ğœ™ ( Ä). It is well known that ğœ™ ( È³) contains ğœ“ ( È³) if and only if there is a homomorphism <ref type="foot" target="#foot_0">1</ref> from ğœ™ ( È³) to ğœ“ ( È³) that is the identity on È³. Core of a structure. A substructure H of a finite structure G is a core of G (see <ref type="bibr" target="#b12">[13]</ref>) if there exists a homomorphism â„ : G â†’ H but there is no homomorphism from G to H â€² where H â€² is a proper substructure of H. Note that the definition of homomorphisms ensures that â„(ğ‘) = ğ‘ for every constant ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(G).</p><formula xml:id="formula_3">F |= T ) if F</formula><p>It is well known that <ref type="bibr" target="#b12">[13]</ref>:</p><p>(1) Every finite structure has a core.</p><p>(2) Cores of a finite structure are unique up to isomorphism.</p><p>(3) If H is a core (of any structure) then it is a core of itself.</p><p>Given a (finite) structure G, we let ğ¶ğ‘œğ‘Ÿğ‘’ (G) denote a function that returns some induced substructure of G that is a core. Connected queries, rules and theories. For a CQ, one can define its Gaifman graph in the natural way: Variables are the vertices of this graph and two variables are connected by an edge if and only if they both appear in the same atomic formula. A conjunctive query is connected if its Gaifman graph is connected. A TGD is connected if its body is. A theory is connected if each of its rules is.</p><p>All the theories we consider in this paper are connected with the important exception of theories over a binary signature. Forcing theories to be connected will help us to better express the nuances of the BDD class in Sections 10-11. This assumption does not reduce the expressive power of such theories due to the following trivial trick: add a fresh variable as an additional, first variable in all the atoms appearing in the rules of the theory. This will make the theory connected, and it will obviously preserve its BDD and FES status. But it will increase the arity -so if we care about the arity we do not get connectivity for free.</p><p>Note that after applying the trivial trick to an instance F the distance between each ğ‘ and ğ‘ â€² from ğ‘‘ğ‘œğ‘š(F) will be at most 2. Also, applying this trick turns any instance with a Gaifman graph of a low (bounded) degree into one with a high degree Gaifman graph.</p></div>
<div><head n="3">THE SKOLEM CHASE.</head><p>The chase procedure is a standard algorithm, studied in a plethora of papers. It can be used to semi-decide whether T , D |= ğœ™ ( Ä) for given theory T , instance D, CQ ğœ™ ( È³) and tuple Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | . In fact the algorithm comes in many variants and flavors. The best way to present our results is by using a variant of the the semi-oblivious Skolem chase, which we define in this section.</p><p>We say that two CQs have the same isomorphism type when one can be obtained from the other by means of bijective renaming of variables. For a CQ Î¦ define ğœ (Î¦) as the isomorphism type of Î¦.</p><p>For each possible isomorphism type ğœ = ğœ (ğœ™ ( È³)) of some atomic conjunctive query ğœ™ ( È³), and for each natural number 1 â‰¤ ğ‘– â‰¤ ğ‘ğ‘Ÿğ‘–ğ‘¡ğ‘¦ (ğ¸), where ğ¸ is the relation symbol of ğœ™ ( È³), let ğ‘“ ğœ ğ‘– be a function symbol, with arity equal to | È³|, that is the number of free variables in ğœ™ ( È³).</p><p>Definition 2 (Skolemization). For a given TGD ğœŒ, of the form ğ›½ ( x, È³) â‡’ âˆƒ w ğ›¼ ( x, w) by sh(ğœŒ) we denote the Skolemization of the head of ğœŒ, that is the atom ğ›¼ ( x, w), with each variable ğ‘¤ âˆˆ w replaced by the term ğ‘“ ğœ ğ‘– ( x), where ğ‘– is the earliest position in ğ›¼ ( x, w) where the variable ğ‘¤ occurs.</p><p>Let, for example ğœŒ be ğ¸ (ğ‘¥, ğ‘¦, ğ‘§), ğ‘ƒ (ğ‘¥) â‡’ âˆƒğ‘£ ğ‘…(ğ‘¦, ğ‘£, ğ‘§, ğ‘£). Then sh(ğœŒ) will be the atom ğ‘…(ğ‘¦, ğ‘“ ğœ 2 (ğ‘¦, ğ‘§), ğ‘§, ğ‘“ ğœ 2 (ğ‘¦, ğ‘§)) where ğœ is the isomorphism type of âˆƒğ‘£ ğ‘…(ğ‘¦, ğ‘£, ğ‘§, ğ‘£). Notice that sh(ğœŒ) does not depend on the body of ğœŒ, only on its head. In particular it does not depend on the non-frontier variables 2 of the body of ğœŒ.</p><p>Now we can define the procedure of rule application. Parameters of this procedure are an instance F, a rule ğœŒ, and a mapping ğœ assigning elements of the active domain of F to the variables that occur in the body of ğœŒ: Definition 3 (Rule application). Let ğœŒ be a rule of the form ğ›½ ( x, È³) â‡’ âˆƒ w ğ›¼ ( È³, w), and let F be a fact set.</p><p>â€¢ Define Hğ‘œğ‘š(ğœŒ, F) as the set of all mappings ğœ from variables in x âˆª È³ to ğ‘‘ğ‘œğ‘š(F) such that ğœ (ğ›½ ( x, È³)) âŠ† F (which means that all the atoms from ğ›½ are in F after we apply ğœ to them). â€¢ For ğœ âˆˆ Hğ‘œğ‘š(ğœŒ, F), define ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) = ğœ (sh(ğœŒ)).</p><p>With these notions in place, we can now define the chase procedure as a whole. Given an instance D and a theory T , it produces a sequence (Ch ğ‘– (T , D)) ğ‘– âˆˆN of instances and the structure Ch(T , D), according to the following definition. It is well known that Ch(T , D) is a universal model for T and D (i.e., a model that can be homomorphically mapped into any other model). Thus, this structure can be used to solve CQ entailment: for any theory T , CQ ğœ™ ( È³), instance D and Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | , we have:</p><formula xml:id="formula_4">ğ¶â„(T , D) |= ğœ™ ( Ä) â‡” D, T |= ğœ™ ( Ä)</formula><p>Example 5. Let T ğ‘ and D ğ‘ be as in Example 1, then</p><formula xml:id="formula_5">â€¢ Ch 0 (T ğ‘ , D ğ‘ ) = D ğ‘ = {ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ´ğ‘ğ‘’ğ‘™)}, â€¢ Ch 1 (T ğ‘ , D ğ‘ ) = Ch 0 (T ğ‘ , D ğ‘ ) âˆª {ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ´ğ‘ğ‘’ğ‘™, ğ‘šğ‘¢ğ‘š(ğ´ğ‘ğ‘’ğ‘™))}, â€¢ Ch 2 (T ğ‘ , D ğ‘ ) = Ch 1 (T ğ‘ , D ğ‘ ) âˆª {ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘šğ‘¢ğ‘š(ğ´ğ‘ğ‘’ğ‘™), ğ‘šğ‘¢ğ‘š(ğ‘šğ‘¢ğ‘š(ğ´ğ‘ğ‘’ğ‘™))</formula><p>)}, and so on (we use the function symbol "mum" as an alias for the ugly Skolem function symbol from Definition 2). Now note that there is nothing in Definition 4 that could prevent us from taking D = Ch 2 (T ğ‘ , D ğ‘ ) and running the chase for such D. It is easy to see that in that case we obtain Ch(T ğ‘ , D) = Ch(T ğ‘ , D ğ‘ ). This leads to the following easy insight: Observation 6. If D âŠ† F âŠ† Ch(T, D) then Ch(T, F) = Ch(T, D). 2 Including non-frontier variables as arguments of the functions ğ‘“ ğœ ğ‘– (like ğ‘¥ in the current example) would lead to the oblivious chase. Also note that the names of the terms do not identify ğœŒ (their "rule of origin"). This is going to be important in the proof of Theorem 1.</p><p>Note that that equality in Observation 6 is to be understood literally (rather than "up to isomorphism"). This is crucial for our treatise and it constitutes the main reason why we use the Skolem naming convention.</p><p>Finally, let us state another property of the chase -a direct consequence of the fact that Ch(T , D) is a universal model. Property 7. Let T be a theory and let D and F be fact sets satisfying D âŠ† F âŠ† Ch(T , D) as well as F |= T . Then there exists a homomorphism from Ch(T , D) to F that is the identity on ğ‘‘ğ‘œğ‘š(F).</p><p>Frontier and birth atoms. Let ğ›¼ be an atom from ğ¶â„(T , D) \ D, created as ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) for some ğœŒ âˆˆ T and ğœ âˆˆ ğ»ğ‘œğ‘š(ğœŒ, D). We let the frontier of ğ›¼ (written: fr (ğ›¼)) denote the set of terms ğœ (fr (ğœŒ)). Notice that there may be more than one rule application creating the same atom ğ›¼, but: Observation 8. For every ğœŒ, ğœŒ â€² âˆˆ T and every ğœ âˆˆ ğ»ğ‘œğ‘š(ğœŒ, D) if ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) = ğ‘ğ‘ğ‘ğ‘™ (ğœŒ â€² , ğœ â€² ) then heads of ğœŒ and ğœŒ â€² when treated as CQs have the same isomorphism type.</p><p>Clearly, for each ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(T , D)) either ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D) or ğ‘¡ was created by the chase procedure as a Skolem term. Notice that, despite the name of the rule of T that created ğ‘¡ not being indicated in the name of ğ‘¡ (as per our Skolem naming convention), the following still holds: Observation 9. Suppose ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(T , D)) \ ğ‘‘ğ‘œğ‘š(D). Then there exists exactly one atom ğ›¼ âˆˆ ğ¶â„(T , D) such that ğ‘¡ appears in ğ›¼, but ğ‘¡ âˆ‰ fr (ğ›¼).</p><p>We will refer to such an atom ğ›¼ as the birth atom of ğ‘¡. For the proof of the last observation notice that one can uniquely reconstruct ğ›¼ using only ğ‘¡. This is because ğ‘¡ contains both the isomorphism type of ğ›¼ (so that one can reconstruct ğ›¼ up to bijective renaming of its terms) and its frontier terms.</p></div>
<div><head n="4">THE THREE CLASSES</head><p>For a theory T , an instance D, a natural number ğ‘› and a conjunctive query ğœ™ (ğ‘¦) we will write ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘›, ğœ™ (ğ‘¦), D, T ) as a shorthand for:</p><formula xml:id="formula_6">âˆ€Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | ğ¶â„(T , D) |= ğœ™ ( Ä) â‡” ğ¶â„ ğ‘› (T , D) |= ğœ™ ( Ä) .</formula><p>Meaning that "it is enough to run ğ‘› steps of the T -chase on D to fully evaluate ğœ™". Now we will provide definitions for three separate classes: BDD, FES, and UBDD <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b13">14]</ref>.</p></div>
<div><head>Definition 10 (BDD). A theory T has the bounded derivation depth property if:</head><p>âˆ€Î¦ âˆƒğ‘› Î¦ âˆ€D ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘› Î¦ , Î¦, D, T )</p></div>
<div><head>Definition 11 (FES). A theory T has the finite expansion set property if:</head><p>âˆ€D âˆƒğ‘› D âˆ€Î¦ ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘› D , Î¦, D, T )</p><formula xml:id="formula_7">Definition 12 (UBDD). Theory T is uniformly BDD if: âˆƒğ‘ T âˆ€D âˆ€Î¦ ğ¸ğ‘›ğ‘œğ‘¢ğ‘”â„(ğ‘ T , Î¦, D, T )</formula><p>Notice the striking similarity between the above expressions. Connections between those classes will be discussed later in Section 7, but before we need to explore BDD and FES in greater detail.</p></div>
<div><head n="5">BDD AND FINITE UNIFICATION SETS</head><p>As with many important notions, it happens that the same concept is defined by multiple communities using different properties. This is exactly the case with finite unification set property <ref type="bibr" target="#b1">[2]</ref> and BDD. Definition 13 (FUS). A theory T has the finite unification set property if every conjunctive query ğœ“ ( È³) has a rewriting -a UCQ, denoted ğœ“ rew ( È³), such that the following holds: For each instance D and each tuple Ä âˆˆ ğ‘‘ğ‘œğ‘š(D)</p><formula xml:id="formula_8">| È³ | we have ğ¶â„(T , D), Ä |= ğœ“ ( È³) â‡â‡’ D, Ä |= ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( È³)).</formula><p>It is well known that T is BDD if and only if it is FUS <ref type="bibr" target="#b2">[3]</ref>, so we will use the two terms interchangeably. For simplicity of our arguments and without loss of generality, we will require the set ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( È³)) to be minimal:</p><formula xml:id="formula_9">If ğœ™ ( È³) â‰  ğœ™ â€² ( È³) are two elements of ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( È³)) then ğœ™ ( È³) is not contained in ğœ™ â€² ( È³).</formula><p>The BDD/FUS class admits several interesting properties. The following will be used later: facts about terms are produced by the chase soon after the terms are created (with only a constant delay). Observation 14. There exists a natural number ğ‘› ğ‘ğ‘¡ (depending only on T ) such that for any instance D, for any ğ‘– âˆˆ N, for any tuple t of domain elements from ğ‘‘ğ‘œğ‘š(ğ¶â„ ğ‘– (T , D)) and for any ğ‘… âˆˆ Î£,</p><formula xml:id="formula_10">ğ¶â„(T , D) |= ğ‘…( t) implies ğ¶â„ ğ‘–+ğ‘› ğ‘ğ‘¡ (T , D) |= ğ‘…( t).</formula><p>Proof (sketch). For any query ğœ™, let ğ‘› ğœ™ denote the constant from Definition 10. Note, that there is only a finite number of non-isomorphic atomic queries. Therefore, we can obtain ğ‘› ğ‘ğ‘¡ as max({ğ‘› ğœ™ | ğœ™ is an atomic query}). â–¡</p><p>The BDD property -exercises. Now, we would like to encourage the reader to solve a few exercises. While they are not part of the actual proofs, we believe they might provide valuable insights.</p><p>Exercise 15. Consider the theory T ğ‘ over schema {ğ¸} consisting of just one rule ğ¸ (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘§ ğ¸ (ğ‘¦, ğ‘§). Show that this theory is BDD.</p><p>Comment: This can be easily generalized: it is well known that all linear theories are BDD <ref type="bibr" target="#b13">[14]</ref> (a theory is linear if each rule only has one atom in its body).</p><p>Exercise 16. Show that, if T is BDD and connected then there exists some ğ‘‘ âˆˆ N such that for each D and for each two terms</p><formula xml:id="formula_11">ğ‘, ğ‘ â€² of ğ‘‘ğ‘œğ‘š(D), if ğ‘‘ğ‘–ğ‘ ğ‘¡ ğ¶â„ ( T,D) (ğ‘, ğ‘ â€² ) = 1 then ğ‘‘ğ‘–ğ‘ ğ‘¡ D (ğ‘, ğ‘ â€² ) â‰¤ ğ‘‘.</formula><p>Comment: the didactic purpose of Exercise 16 is to evoke or reinforce the intuition of BDD as a "locality" property: if terms from ğ‘‘ğ‘œğ‘š(D) appear in one atom somewhere in ğ¶â„(T , D) then they could not possibly be far away from each other already in D.</p></div>
<div><head n="6">FES AND CORE TERMINATION</head><p>FES theories always (regardless of the initial structure D) produce all the positive information present in ğ¶â„(T , D) already after a finite number of chase steps (this number can depend on D though). This is, as well, the case with the core termination [1, 2]: Definition 17. A theory T is core-terminating if for each fact set D there exists a ğ‘˜ âˆˆ N such that for each ğ‘– â‰¥ ğ‘˜:</p><formula xml:id="formula_12">ğ¶ğ‘œğ‘Ÿğ‘’ (Ch ğ‘– (T , D)) is isomorphic to ğ¶ğ‘œğ‘Ÿğ‘’ (Ch ğ‘–+1 (T , D)).</formula><p>It is well known that T is core-terminating if and only if it is FES <ref type="bibr" target="#b14">[15]</ref>, so we will use the two terms interchangeably. Moreover, the smallest numbers ğ‘› D and ğ‘˜ satisfying Definitions 11 and 17 (respectively) are equal; from now on this number will be denoted with ğ‘ T,D . It is also known <ref type="bibr" target="#b0">[1]</ref> that ğ¶ğ‘œğ‘Ÿğ‘’ (Ch ğ‘ T,D (T , D)) |= T , D.</p><p>Definition 18. Given a FES theory T and an instance D, we let ğ¶ğ‘œğ‘Ÿğ‘’ (T , D) denote ğ¶ğ‘œğ‘Ÿğ‘’ (Ch ğ‘ T,D (T , D)).</p><p>Exercises Also this section comes with a few exercises. Again, we expect them to provide valuable insight, but they are not required for our subsequent proofs.</p><p>Exercise 19. Show that the theory from Exercise 15 is not FES.</p><p>Exercise 20. Show that the theory consisting of two rules ğ¸ (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘§ ğ¸ (ğ‘¦, ğ‘§) and ğ¸ (ğ‘¥, ğ‘¥ â€² ) â‡’ ğ¸ (ğ‘¥, ğ‘¥) is FES.</p></div>
<div><head n="7">THE FUS/FES CONJECTURE</head><p>It is very easy to produce examples of BDD theories that are not UBDD (see <ref type="bibr">Exercise 15)</ref>. However, all examples we could produce are not core-terminating. Likewise, it is easy to produce examples of core-terminating theories that are not UBDD, but they are not BDD either (all unbounded Datalog theories will be very happy to serve as examples). This gives rise to the following conjecture.</p><p>Conjecture 1 (The FUS/FES conjecture). Any theory that is both FUS and FES is also UBDD.</p><p>This conjecture was studied in <ref type="bibr" target="#b10">[11]</ref> where an incorrect proof was proposed, and in <ref type="bibr" target="#b11">[12]</ref> where it was proved that it would hold true if the assumption that T is FES was replaced by the significantly stronger assumption that it is all-instances Skolem chase terminating. Note that the conjecture would be false if infinite theories, over infinite (yet just binary) schemas were allowed:</p><p>Example 21. Suppose a relation symbol ğ¸ ğ‘– for every ğ‘– âˆˆ N. Let the theory T âˆ consist of all rules of the form ğ¸ ğ‘– (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘§ ğ¸ ğ‘–-1 (ğ‘¦, ğ‘§) for ğ‘– âˆˆ N + . Then T âˆ is BDD and core-terminating, but it is not UBDD. To see why this is the case, notice that only facts from a finite number of relations can appear in every given finite instance.</p></div>
<div><head n="8">LOCAL THEORIES.</head><p>We are now ready to introduce the central notion of local theories. As it will turn out, not only the FUS/FES conjecture holds for these (Theorem 2) but they also subsume all BDD theories over binary signatures (Theorem 1). Notwithstanding, as we will argue near the end of the paper, there exists an untapped potential within the BDD class beyond the veils of locality (Theorem 3). Definition 22. A theory T is local if there exists some number ğ‘™ T âˆˆ N such that for every instance D the following holds:</p><formula xml:id="formula_13">Ch(T , D) = FâŠ†D, |F| â‰¤ğ‘™ T Ch(T , F)</formula><p>Note that the Skolem naming convention is important here. Without it, it would be unclear or at least ambiguous what a union of chases is supposed to mean. Importantly, we obtain that locality implies the BDD property. The detailed proof will be presented in Appendix A. Here, we just outline the proof idea. We start by observing that the atoms created in the chase by rules that contain existentially quantified variables form a forest. This is a crucial property of single-head rule sets over binary signatures as any such rule must have a frontier of size â‰¤1. (Obviously, this property ceases to hold for signatures of higher arities.) Essentially, as the chase progresses, the existential atoms (those produced through "proper" existential rules) are created further and further away from the instance. If we were able to bound the number of each such atom's ancestors -the atom set required for its creation -then we could finish the proof by slightly extending Observation 14. The forest shape, however, is not immediately sufficient to bound the ancestors of its atoms. To overcome this issue, we propose a normalization technique, that, given a BDD theory T over binary signature, produces a new theory T ğ‘ ğ¹ , which might no longer be BDD but admits two important properties: First, the sets of existential atoms produced by T and by T ğ‘ ğ¹ on any instance coincide (Lemma 48). Second, it is straightforward to find the mentioned bound on the number of ancestors for every atom produced by T ğ‘ ğ¹ (Lemma 57). These two properties grant us Theorem 1. But how does such a normalization work? In simple words, it relies on the fact that T is BDD. In the absence of both disconnected and Datalog rules, the normalization would be rather simple: we could take any existential rule ğ›½ â‡’ ğ›¼ âˆˆ T and replace it with rules ğ›¾ â‡’ ğ›¼ for all ğ›¾ âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğ›½). Dealing with disconnected bodies and Datalog rules complicates matters somewhat.</p><p>We are very confident that our proof can be generalized to all frontier-guarded BDD theories. As this is not yet spelled out in full detail, we prefer to be cautious and formulate it as conjecture.</p><p>Conjecture 2. Every frontier-guarded BDD theory is local.</p></div>
<div><head n="9">THE FUS/FES CONJECTURE IS TRUE FOR LOCAL THEORIES</head><p>We proceed by presenting the second of our three main results.</p><p>Theorem 2. If a theory T is FES and local then it is UBDD.</p><p>This means that the FUS/FES conjecture holds for local theories. Before we start our proof, let us note that by Theorem 1 and Theorem 2, we can immediately conclude that Conjecture 1 holds for theories over binary signatures: Corollary 1. If a theory T over a binary signature is both FES and BDD then it is UBDD. Also, Theorem 1 implies that any counterexample to the conjecture -should it exist -would have to be outside the realm of local classes. We explore this uncharted lands in Section 11.</p></div>
<div><head>Proof of Theorem 2</head><p>As any UBDD theory is core-terminating as well, it is easy to see that a theory T is UBDD if and only if there exists some ğ‘ T âˆˆ N such that ğ¶ğ‘œğ‘Ÿğ‘’ (T , D) âŠ† Ch ğ‘ T (T , D) holds for any instance D. Note that the numbers ğ‘ T here and in Definition 12 are equal. Thus we can reformulate Theorem 2 as follows:</p><p>Theorem 2 (alternative). Let T be a core-terminating local theory. Then there exists a ğ‘ T âˆˆ N such that ğ¶ğ‘œğ‘Ÿğ‘’ (T , D) âŠ† Ch ğ‘ T (T , D) holds for any instance D .</p><p>Until the end of this section, we will consider T a fixed theory that is both core-terminating and local (so also BDD). To simplify notation, Ch(T , D) will be shortened to Ch(D).</p><p>Definition 24. For an instance D define I D as the family of sets</p><formula xml:id="formula_14">{F | F âŠ† D, |F| â‰¤ ğ‘™ T }. Define C D = FâˆˆI D ğ¶ğ‘œğ‘Ÿğ‘’ (T , F).</formula><p>Lemma 25. There exists a ğ‘˜ T âˆˆ N depending only on T (but not on D), such that C D âŠ† Ch ğ‘˜ T (D).</p></div>
<div><head>Proof. The set</head><formula xml:id="formula_15">A = {F | |F| â‰¤ ğ‘™ T } of all instances (over Î£) of size at most ğ‘™ T is finite (up to isomorphisms). Recall that T is core-terminating and let ğ‘˜ T = max{ğ‘ T,D | D âˆˆ A}. â–¡</formula><p>If we were able able to find a homomorphism hD from ğ¶â„(D) to C D , the alternative formulation of Theorem 2 would be proved. Also, since T is core-terminating, we know that for each F âˆˆ I D there exists a homomorphism â„ F from ğ¶â„(F) to C D and we know that FâˆˆI D ğ¶â„(F) = ğ¶â„(D). So can't we just define hD = FâˆˆI D â„ F ? Unfortunately not, because the domains of â„ F and â„ F â€² may overlap (for some F â‰  F â€² ) and there is no guarantee that â„ F and â„ F â€² will agree on the terms that are in both domains. If hD could be produced this way, C D |= T would always hold. Yet, we found an example (not included here) of a pair D, T for which C D Ì¸ |= T .</p><p>Luckily, the idea to build a global homomorphism hD using the local homomorphisms â„ F can be put to use in a different way, and the set of facts C D will indeed prove very useful in this context. The following lemma will be crucial in this endeavor: Lemma 26. For any instance D there exists a homomorphism hD from ğ¶â„(D) to ğ¶â„(D) such that for each ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)) there is</p><formula xml:id="formula_16">hD (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(C D ).</formula><p>Let us first discuss how Theorem 2 can be concluded from Lemma 26. Suppose some D is fixed and hD is a homomorphism as in Lemma 26. We know that ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)) implies hD (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(C D ) and we know that C D âŠ† ğ¶â„ ğ‘˜ T (D). So one might be tempted to immediately conclude hD (Ch(D)) âŠ† ğ¶â„ ğ‘˜ T (D). But it is not quite that simple. Admittedly, Lemma 26 tells us that all the terms of hD (Ch(D)) will indeed appear in ğ¶â„ ğ‘˜ T (D). But it says nothing like that about the atoms of hD (Ch(D)). Rather, it might be that there are atoms in hD (Ch(D)) that, despite having all their terms in ğ‘‘ğ‘œğ‘š(C D ) are not themselves in C D . To overcome this little problem, we recall Observation 14 and let ğ‘ T = ğ‘˜ T +ğ‘› ğ‘ğ‘¡ . Then hD (Ch(D)) âŠ† ğ¶â„ ğ‘ T (D) follows as desired.</p><p>This means what remains to be presented in this section is the proof of Lemma 26: Definition 27. Let D be a set of facts and let F âŠ† D. We let ğ‘€ F denote<ref type="foot" target="#foot_1">3</ref> the substructure of Ch(D) induced by the set of terms ğ‘‘ğ‘œğ‘š(Ch(D)) \ ğ‘‘ğ‘œğ‘š(Ch(F)) \ ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F)) .</p><p>In the following, the terms of ğ‘‘ğ‘œğ‘š(Ch(F)) \ ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F) will be referred to as banned terms. In the following, the atom ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) will be mentioned often enough to deserve a shorter name, so we will call it ğ›¼.</p><p>It is now sufficient (and necessary) to prove that there exists a homomorphism from ğ›¼ to some atom ğ›¼ â€² âˆˆ ğ‘€ F , that is the identity on fr (ğ›¼). In other words, we need to show that if the body of the rule ğœŒ matches ğ‘€ F (via mapping ğœ), then we can find an atom in ğ‘€ F that witnesses satisfaction of ğœŒ. Such an ğ›¼ â€² needs to have the same terms as ğ›¼ in the frontier positions and may have arbitrary terms in the positions of the existentially quantified variables in â„ğ‘’ğ‘ğ‘‘ (ğœŒ), except that if ğ›¼ had equal terms on two such positions then the respective terms in ğ›¼ â€² must also be equal.</p><p>If ğ›¼ âˆˆ ğ‘€ F then of course we pick ğ›¼ â€² = ğ›¼. So, for the rest of the proof, assume ğ›¼ âˆ‰ ğ‘€ F . Note that the only reason for ğ›¼ to be in Ch(D) but not in ğ‘€ F is that ğ›¼ contains some banned term ğ‘¡.</p><p>But ğœ (ğ‘ğ‘œğ‘‘ğ‘¦ (ğœŒ)) âŠ† ğ‘€ F . Thus fr (ğ›¼) âŠ† ğ‘‘ğ‘œğ‘š(ğ‘€ F ) and so ğ‘¡ âˆ‰ fr (ğ›¼). At this point, we can be sure that ğœŒ is not a Datalog rule -atoms derived via a Datalog rule do not have non-frontier terms.</p><p>Term ğ‘¡ being a non-frontier term of ğ›¼ means that ğ›¼ is the birth atom of ğ‘¡ in Ch(D). But ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(Ch(F)) so from Observation 9, we know that ğ›¼ is the birth atom of ğ‘¡ in Ch(F) and thus ğ›¼ âˆˆ Ch(F).</p><p>Note This means that one can compose such homomorphisms, and the resulting function will also be a homomorphism from Ch(D) to Ch(D) (and it will be the identity on ğ‘‘ğ‘œğ‘š(D), since each â„ ğ‘€ F is). Now the rabbit is going to be pulled out of the hat: let us compose all homomorphisms â„ ğ‘€ F âˆˆ H D , in any order. Call the resulting ("global") homomorphism hD . Now recall that the proof of Lemma 26 (and thus also of Theorem 2) will be finished once we can show that hD (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(C D ) does indeed hold for each term ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)).</p><p>Recall our notion of banned terms. Now F is no longer fixed, i.e., for each F âˆˆ I D there is a set ğ‘ğ‘ğ‘› F of terms that occur somewhere in Ch(F) but not in ğ¶ğ‘œğ‘Ÿğ‘’ (T , F). Each â„ * ğ‘€ F âˆˆ H D is the identity on all terms except those of ğ‘ğ‘ğ‘› F , and maps the terms from ğ‘ğ‘ğ‘› F into ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F)), which means into ğ‘‘ğ‘œğ‘š(C D ).</p><p>Now suppose we apply hD to any ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)). If there is any â„</p><formula xml:id="formula_17">* ğ‘€ F âˆˆ H D with â„ * ğ‘€ F (ğ‘¡) â‰  ğ‘¡ then of course hD (ğ‘¡) âˆˆ ğ‘‘ğ‘œğ‘š(C D ). In case â„ * ğ‘€ F (ğ‘¡) = ğ‘¡ for each â„ * ğ‘€ F , consider any F ğ‘¡ âˆˆ I D for which ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(F ğ‘¡ )). Then ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F ğ‘¡ )) âŠ† ğ‘‘ğ‘œğ‘š(C D ).</formula></div>
<div><head n="10">SLIGHTLY BEYOND LOCALITY: STICKY THEORIES</head><p>Unfortunately, our notion of locality fails to characterize the entire BDD class, as demonstrated in the following example.</p><p>Example 30. Let ğ¸ be a relation of arity 4 and ğ‘… one of arity 2. Read ğ¸ (ğ‘, ğ‘, ğ‘ â€² , ğ‘) as "ğ‘ sees an edge from ğ‘ to ğ‘ â€² colored with color ğ‘" and ğ‘…(ğ‘, ğ‘) as "ğ‘ considers ğ‘ a color". The following one-rule sticky theory T is not local: ğ¸ (ğ‘¥, ğ‘¦, ğ‘¦ â€² , ğ‘¡), ğ‘…(ğ‘¥, ğ‘¡ â€² ) â‡’ âˆƒğ‘¦ â€²â€² ğ¸ (ğ‘¥, ğ‘¦ â€² , ğ‘¦ â€²â€² , ğ‘¡ â€² ) (meaning "if ğ‘¥ sees an edge from ğ‘¦ to ğ‘¦ â€² and considers ğ‘¡ â€² a color, then ğ‘¥ must also see another edge from ğ‘¦ â€² to some ğ‘¦ â€²â€² of color ğ‘¡ â€² ").</p><p>To see that it is indeed not local, suppose it were and let ğ‘™ T be the corresponding constant as in Definition 22. Now take an instance D consisting of ğ‘™ T +1 atoms: one atom ğ¸ (ğ‘, ğ‘ 1 , ğ‘ 2 , ğ‘ 1 ) and atoms ğ‘…(ğ‘, ğ‘ ğ‘– ) for 1 â‰¤ ğ‘– â‰¤ ğ‘™ T . It is not hard to see that there are atoms in ğ¶â„(T , D) that require all the atoms from D to be produced.</p><p>The only reason, however, for connected sticky theories to be non-local are high-degree vertices, like the ğ‘ in the example. This leads to a natural generalization of the notion of locality: Definition 31. A theory T will be called bounded-degree local (or bd-local) if for any ğ‘˜ âˆˆ N there exists a constant ğ‘™ T (ğ‘˜) such that for every instance D having degree at most ğ‘˜, the following holds:</p><formula xml:id="formula_18">FâŠ†D, |F | â‰¤ğ‘™ T (ğ‘˜) Ch(T , F) = Ch(T , D)</formula><p>As of yet, we have been unable to show that the FUS/FES conjecture holds for bounded-degree local theories, but we believe that with some additional effort, the ideas from Section 9 could probably be adapted to work also for such theories. And of course they do work if only instances of fixed degree are considered.</p><p>It is not hard to show that sticky theories are indeed bd-local (cf. Appendix E). Hence, in view of Conjecture 2, it seems that most known decidable BDD classes are bounded-degree local. Perhaps surprisingly, unlike local theories, not all bounded-degree local theories are BDD:</p><p>Example 32. It is easy to see that the following single-rule theory is bounded-degree local but not BDD: ğ¸ (ğ‘¥, ğ‘¦, ğ‘§), ğ‘…(ğ‘¥, ğ‘§) â‡’ ğ‘…(ğ‘¦, ğ‘§).</p><p>But even if not all bd-local theories are BDD, it is not straightforward to come up with a BDD theory that is not bd-local. So a natural question arises: are there BDD theories that are not local in this generalized sense? We found it quite surprising to realize that the answer is positive:</p><p>Example 33. The following BDD theory T ğ‘ is not bd-local:</p><formula xml:id="formula_19">ğ¸ (ğ‘¥, ğ‘¦) â‡’ âˆƒğ‘¥ â€² , ğ‘¦ â€² ğ‘…(ğ‘¥, ğ‘¦, ğ‘¥ â€² , ğ‘¦ â€² ) ğ‘…(ğ‘¥, ğ‘¦, ğ‘¥ â€² , ğ‘¦ â€² ), ğ¸ (ğ‘¦, ğ‘§) â‡’ âˆƒğ‘§ â€² ğ‘…(ğ‘¦, ğ‘§, ğ‘¦ â€² , ğ‘§ â€² )</formula><p>To prove that it is BDD one can notice that if T ğ‘ , D |= ğœ™ ( Ä), for some D and some Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | Ä | then ğ¶â„ |ğœ™ ( È³) | |= ğœ™ ( Ä). In order to prove that it is not bd-local consider, for each ğ‘› âˆˆ N, the instance D ğ‘› consisting of atoms ğ¸ (ğ‘ 1 , ğ‘ 2 ), ğ¸ (ğ‘ 2 , ğ‘ 3 ) . . ., ğ¸ (ğ‘ ğ‘› , ğ‘ 1 ). The degree of this instance is 2. And there are atoms in ğ¶â„ ğ‘› (T ğ‘ , D ğ‘› ) that are not in ğ¶â„ ğ‘› (T ğ‘ , F) for any proper subset F of D ğ‘› .</p><p>We were, however, not able to find an example of a theory that would be hereditary BDD -a BDD theory such that every its subsets is BDD as well -but not bd-local. We think it reasonable to conjecture that there are no such theories.</p></div>
<div><head n="11">FAR BEYOND LOCALITY: BDD THEORIES WITHOUT SMALL REWRITINGS</head><p>As we know, any local theory is also BDD. Additionally, local theories admit rewritings of linear width:</p><p>Observation 34. For each local theory T and for each CQ Î¨, the size of the greatest disjunct in the rewriting is at most ğ‘™ T |Î¨|.</p><p>Clearly, the linear bound on the width of ğ‘Ÿğ‘’ğ‘¤ (Î¨) gives us an immediate exponential upper bound on the number of its disjuncts. A matching lower bound is trivial to obtain: Observation 35. Let T consist of the two rules: ğ¸ (ğ‘¥, ğ‘¦) â‡’ ğ‘…(ğ‘¥, ğ‘¦) and ğ¸ â€² (ğ‘¥, ğ‘¦) â‡’ ğ‘…(ğ‘¥, ğ‘¦). Then T is BDD and the number of disjuncts in ğ‘Ÿğ‘’ğ‘¤ (Î¨) can be exponential in the size of Î¨.</p><p>Recall the notion of backwards shy theories <ref type="bibr" target="#b9">[10]</ref> -these are BDD theories such that, for every query ğœ“ ( È³) if ğœ™ ( È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( È³)) then only variables from È³ can occur more than once in ğœ™ ( È³). Sticky theories are backward shy. It is easy to see that backward shy theories admit rewritings of linear width as well and, in consequence, also all sticky theories do. This is related to another notion of locality: Definition 36. We call a theory T distancing if there is a ğ‘‘ T âˆˆ N such that for any instance D, any ğ‘, ğ‘ â€² âˆˆ ğ‘‘ğ‘œğ‘š(D), and any ğ‘› âˆˆ N if</p><formula xml:id="formula_20">ğ‘‘ğ‘–ğ‘ ğ‘¡ ğ¶â„ ( T,D) (ğ‘, ğ‘ â€² ) â‰¤ ğ‘› then ğ‘‘ğ‘–ğ‘ ğ‘¡ D (ğ‘, ğ‘ â€² ) â‰¤ ğ‘‘ T ğ‘›.</formula><p>Is every BDD theory distancing? It might seem that this can be shown using Exercise 16. However, this is not the case, since the path from ğ‘ to ğ‘ â€² in ğ¶â„(T , D) might lead through atoms not containing any constants from the original D. What can be proven is the following correspondency: Observation 37. If a BDD theory admits rewritings of linear width, then it is distancing.</p><p>Assuming Conjecture 2, this implies that all theories from previously known BDD classes are distancing. The converse of Observation 37 does not hold, and such theories can be easily found: Observation 38. The theory consisting of the single Datalog rule ğ´(ğ‘¥), ğ¸ (ğ‘¥, ğ‘¦) â‡’ ğ´(ğ‘¦) is distancing but not BDD.</p><p>So do there exist non-distancing BDD theories at all? Do there exist BDD theories that do not admit rewritings of linear width? The answer is given by Theorem 3, which constitutes the third main result of this paper: Theorem 3. There exists a BDD theory that is non-distancing and does not even admit rewritings of polynomial width.</p><p>To see how this is possible, consider the following theory: Definition 39. Consider a signature with two binary predicates ğ‘… and ğº. Let the theory T ğ‘‘ consist of the following rules: (loop) ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘¥ ğ‘…(ğ‘¥, ğ‘¥), ğº (ğ‘¥, ğ‘¥) (pins) âˆ€ğ‘¥ (ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘§, ğ‘§ â€² ğ‘…(ğ‘¥, ğ‘§), ğº (ğ‘¥, ğ‘§ â€² )) (grid) ğ‘…(ğ‘¥, ğ‘¥ â€² ), ğº (ğ‘¥, ğ‘¢), ğº (ğ‘¢, ğ‘¢ â€² ) â‡’ âˆƒğ‘§ ğ‘…(ğ‘¢ â€² , ğ‘§), ğº (ğ‘¥ â€² , ğ‘§)</p><p>Note that the rules of T ğ‘‘ are not single-head and some of them have empty bodies. One could easily reformulate them to avoid this at the cost of readability (see Appendix D). We will think of instances over our signature (and of bodies of queries) as graphs with edges colored in red or green. For ğ‘› âˆˆ N, let ğº ğ‘› (ğ‘¥ 0 , ğ‘¥ ğ‘› ) denote the CQ âˆƒğ‘¥ 1 . . . ğ‘¥ ğ‘›-1 ğº (ğ‘¥ 0 , ğ‘¥ 1 ), . . . , ğº (ğ‘¥ ğ‘›-1 , ğ‘¥ ğ‘› ) and ğ‘… ğ‘› (ğ‘¥ 0 , ğ‘¥ ğ‘› ) likewise. Define conjunctive queries ğœ™ ğ‘› ğ‘… (ğ‘¥, ğ‘¦) by âˆƒğ‘¥ â€² , ğ‘¦ â€² ğ‘… ğ‘› (ğ‘¥, ğ‘¥ â€² ), ğ‘… ğ‘› (ğ‘¦, ğ‘¦ â€² ), ğº (ğ‘¥ â€² , ğ‘¦ â€² ) and let G ğ‘› (ğ‘, ğ‘) be a path of ğ‘› green edges, with ğ‘ as the first vertex and ğ‘ as the last.</p><p>The following technical lemma substantiates Theorem 3:</p><formula xml:id="formula_21">Lemma 40. (A) The theory T ğ‘‘ is BDD. (B) ğº 2 ğ‘› (ğ‘¥, ğ‘¦) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T ğ‘‘ (ğœ™ ğ‘›</formula><p>ğ‘… (ğ‘¥, ğ‘¦)) holds for every ğ‘› âˆˆ N. Let us first prove claim (B) of the theorem, which implies that T ğ‘‘ is not distancing. The claim follows once we notice that: (i) Ch(T ğ‘‘ , G 2 ğ‘› (ğ‘, ğ‘)) |= ğœ™ ğ‘› ğ‘… (ğ‘, ğ‘) and (ii) if D is a proper subset of G 2 ğ‘› (ğ‘, ğ‘) then ğ¶â„(T ğ‘‘ , D) Ì¸ |= ğœ™ ğ‘› ğ‘… (ğ‘, ğ‘). Establishing (i) is immediate, as exemplified in Fig. <ref type="figure" target="#fig_1">1</ref> displaying the case ğ‘› = 3. To show (ii), we note that if D is a proper subset of G 2 ğ‘› (ğ‘, ğ‘) then ğ‘ and ğ‘ are in two different connected components of D and, since T ğ‘‘ is connected, they are in two different connected components of ğ¶â„(T ğ‘‘ , D). The proof of claim (A) is much harder (see Appendix B). It defines a rewriting procedure in the spirit of <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b15">16]</ref>, whose termination for any given query ğœ™ (ğ‘¦) is shown, via an invariant defined by a complicated multiset ordering.</p><p>As our final exercise illustrates, the reasons why T ğ‘‘ is BDD are quite subtle indeed: Exercise 41. Show that without rule (loop), T ğ‘‘ would not be BDD. Hint: Consider the CQ âˆƒğ‘¥, ğ‘¦ ğ‘…(ğ‘¥, ğ‘¦), ğº (ğ‘¥, ğ‘¦).</p><p>A remark on Theorem 3. A folklore belief seems to be that the existence of BDD theories that enforce rewritings of unbounded width is a consequence of the the fact that it is undecidable to check if a theory is BDD (see e.g. a recent stackexchange post <ref type="bibr" target="#b16">[17]</ref>). Our results call this belief into question, because being BDD is undecidable for theories with a binary signature, and yet such theories, if BDD, are local and thus admit rewritings of linear width. Remark on distancing and linear width rewritings. One may ask whether distancing is the same as admitting rewritings of linear width. The answer is no. While Observation 37 shows one implication, the converse is not true. Consider theory T ğ‘‘ from Definition 39, but with every predicate's arity increased by one, and the new variable ğ‘Ÿ occurring in the last position in every atom. Then the new theory is distancing (unlike T ğ‘‘ ), but it still requires exponential size rewritings (and, of course, it will remain BDD).</p></div>
<div><head n="12">CONCLUSIONS AND FUTURE WORK</head><p>Our major motivation to embark on this journey was the pending status of the FUS/FES conjecture. On our way, we realized that any progress in that direction requires to significantly advance our understanding of the BDD class, seperating folklore beliefs from hard facts. To this end, we introduced several new notions, characterizing specific properties of theories, and investigated their correspondencies. Most notably, we defined local theories, a BDD subclass. Our major results are the following:</p><p>â€¢ We show that the FUS/FES conjecture holds for all local theories (Theorem 2), which include all theories over binary signatures (Corollary 1). If the conjecture holds in the general case, then our work may provide the basis for a complete proof. If it does not, we now know that we must look for counter-examples of higher arity to disprove it. â€¢ We show that there are BDD theories that are non-distancing and even necessitate rewritings of exponential width (Theorem 3). This result highlights the limitations of existing BDD classes <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>, which can only characterise rule sets that admit rewritings of polynomial width. As for future work, we intend to explore the following:</p><p>â€¢ Study the relation between distancing and bd-local. More precisely, find out if there are theories that are BDD and bd-local but are not distancing. </p></div>
<div><head>Appendices Appendix A PROOF OF THEOREM 1</head><p>Let us now fix a binary signature Î£ and a BDD theory T over Î£. By T ğ·ğ¿ we will denote the Datalog rules of T and by T âˆƒ its proper existential rules.</p><p>First we will need to distinguish, among all elements of T âˆƒ , detached <ref type="foot" target="#foot_2">4</ref> rules that are of the form ğœ™ ( x) â†’ âˆƒğ‘¦, ğ‘§ğœ“ (ğ‘¦, ğ‘§) or ğœ™ ( x) â†’ âˆƒğ‘¦ğœ“ (ğ‘¦), that is, rules having empty frontier. Note that when firing a detached rule, the newly created atom, has no common terms with the rest of the chase. Notice that, since we only consider binary schemas, the non-empty frontier of an existential rule always consists of exactly one variable <ref type="foot" target="#foot_3">5</ref> . Rules from T âˆƒ which are not detached will be called sensible Clearly, whatever fact set D we consider, the structure Ch(T , D) is a disjoint union of three sets of atoms. One set consists of the original facts from D. Second contains existential atoms, that is facts created in the process of the chase, by rules of T âˆƒ . The third set consists of atoms that are created by the rules of T ğ·ğ¿ which be called Datalog atoms. We will denote the set of existential atoms of Ch(T , D) together with atoms of D with Ch âˆƒ (T , D).</p><p>Let us now concentrate on the structure of Ch âˆƒ (T , D). Notice that there are again two kinds of atoms there: detached atoms, created by detached rules and sensible atoms, created by sensible rules. Notice also that our taxonomy of atoms implies a taxonomy of the terms of Ch âˆƒ (T , D) (that is the elements of ğ‘‘ğ‘œğ‘š(Ch(T , D)) \ ğ‘‘ğ‘œğ‘š(D)): there are sensible terms, created by sensible rules and detached terms, created by detached rules. The set of detached terms will be called ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)).</p><p>Observation 42. The graph whose vertices are the terms from ğ‘‘ğ‘œğ‘š(Ch(T , D)) and whose edges are sensible atoms of Ch âˆƒ (T , D) is a forest. The set of the roots of the trees of this forest is equal to ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)). The number of children of any of the vertices of this forest is bounded by the number of existential rules in T .</p><p>For any ğ‘ âˆˆ ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)) let S(ğ‘) be the set of all atoms of Ch âˆƒ (T , D) which are edges of the tree rooted in ğ‘. Following the naming convention, we call trees that are rooted in detached terms detached trees.</p></div>
<div><head>A.1 First (failed) attempt at the Crucial Lemma</head><p>For any given set of facts D let a parent function ğ‘ğ‘ğ‘Ÿ T be any function from Ch(T , D) \ D to the power set of Ch(T , D) such that for any atom ğ›¼ âˆˆ Ch(T , D) there exists a rule ğœŒ and a mapping ğœ satisfying:</p><p>â€¢ ğ›¼ = ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ),</p><p>â€¢ ğœ (ğ‘ğ‘œğ‘‘ğ‘¦ (ğœŒ)) = ğ‘ğ‘ğ‘Ÿ T (ğ›¼).</p><p>The parent function points to some (arbitrarily chosen) set of atoms that leads to the creation of ğ›¼. Note that there may be more than one such function as ğ›¼ could be created in more than one way during the chase.</p><p>Let D be any set of facts and let ğ‘ğ‘ğ‘Ÿ T be some parent function. Then we define an ancestor function ğ‘ğ‘›ğ‘ T as follows:</p><p>â€¢ ğ‘ğ‘›ğ‘ T (ğ›¼) = {ğ›¼ } for an atom ğ›¼ âˆˆ D,</p><p>â€¢ ğ‘ğ‘›ğ‘ T (ğ›¼) = ğ›¼ â€² âˆˆğ‘ğ‘ğ‘Ÿ T (ğ›¼) ğ‘ğ‘›ğ‘ T (ğ›¼ â€² ) for atoms of Ch(T , D) \ D. Intuitively the set ğ‘ğ‘›ğ‘ T (ğ›¼) consists of facts from D which were used during the chase, to prove ğ›¼. Of course there might be more than one ancestor function for any given set of facts as that function is strictly associated with a particular parent function. This freedom in taking parents, and so in picking ancestors, leads to some problems, as we will soon discover.</p><p>We would be one step from proving Theorem 1 if we had:</p><p>Lemma 43 (Crucial Lemma, first attempt, false). There is a natural number ğ‘€, depending on the rule set T but not on the fact set D, such that for every ancestor function ğ‘ğ‘›ğ‘ T , for each constant and any detached term ğ‘¡ in Ch(T , D) holds:</p><formula xml:id="formula_22">ğ›¼ âˆˆS(ğ‘¡ ) ğ‘ğ‘›ğ‘ T (ğ›¼) â‰¤ ğ‘€</formula><p>But that lemma is unfortunately not true. For a counterexample see:</p><p>Example 44. Let T consist of two rules:</p><p>â€¢ ğ¸ (ğ‘¥, ğ‘¦), ğ‘…(ğ‘§, ğ‘¦) â†’ âˆƒğ‘£ ğ¸ (ğ‘¦, ğ‘£) â€¢ ğ¸ (ğ‘¥, ğ‘¦), ğ‘ƒ (ğ‘§) â†’ ğ‘…(ğ‘§, ğ‘¦) Suppose that ğ‘€ as in the lemma exists and that D consists of atom ğ¸ (ğ‘ 0 , ğ‘ 1 ) and atoms ğ‘ƒ (ğ‘ ğ‘– ) for each 1 â‰¤ ğ‘– â‰¤ ğ‘€.</p><p>Then Ch(T , D) will consist of an infinite number of new facts ğ¸ (ğ‘ 1 , ğ‘ 2 ), ğ¸ (ğ‘ 2 , ğ‘ 3 ),ğ¸ (ğ‘ 3 , ğ‘ 4 ) . . .. In order to build them, however, some facts about relation ğ‘… will need to be proven by the second rule using a number of ğ‘ƒ atoms from D. And it might happen (Skolem/semioblivious chase is non-deterministic in that aspect) that the proven ğ‘…-facts will be ğ‘…(ğ‘ 1 , ğ‘ 1 ), ğ‘…(ğ‘ 2 , ğ‘ 2 ), . . . ğ‘…(ğ‘ ğ‘€ , ğ‘ ğ‘€ ), meaning that S(ğ‘ 1 ) uses during its creation all the ğ‘€ + 1 facts of D. But of course this is for irrelevant reasons: the same chase could be built if ğ‘ƒ (ğ‘ 1 ) was used each time some ğ‘ƒ was needed.</p></div>
<div><head>A.2 The normalization of T</head><p>In order to circumvent the problems highlighted by Example 44, we will now transform the rule set T into another rule set T ğ‘ ğ¹ which, apart from some other useful properties, will satisfy the equality</p><formula xml:id="formula_23">( * ) Ch âˆƒ (T ğ‘ ğ¹ , D) = Ch âˆƒ (T , D).</formula><p>First we will define the signature of T ğ‘ ğ¹ . Let us take a fresh set of nullary predicates M = {ğ‘€ ğœ™ | ğœ™ is a boolean CQ over Î£}. Then our new signature 6 Î£ â€² is Î£ âˆª M.</p><p>Two procedures will be used during the normalization: body rewriting and body separation.</p><p>Definition 45 (Body rewriting). Let ğœŒ be some rule with body ğ›½ ( x, È³) over Î£ and a head ğ›¾ ( È³) which is an atom from Î£ â€² possibly preceded with the existential quantifier (or two). Then by ğ‘…ğ‘’ğ‘¤ (ğœŒ) we denote the set: 6 We briefly forget here about our promise that signatures would be finite.</p><formula xml:id="formula_24">{ğ›½ â€² ( x, È³) â‡’ ğ›¾ ( È³) : ğ›½ â€² ( x, È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ x ğ›½ ( x, È³))}</formula><p>While body rewriting can be applied both to existential rules and Datalog rules, the second procedure will only be applied to existential rules. It separates the disconnected fragment of body of given existential rule and "encapsulates" that fragment in a single nullary predicate from M. That is, given a rule, the procedure returns a pair of rules. One being almost the original rule, but with its body changed to consist of nullary predicate and a connected conjunction of atoms. The second being a rule whose job is to prove the aforementioned nullary predicate.</p><p>Definition 46 (Body separation). If ğœŒ is an existential rule of the form ğ›½ ( x, È³) âˆ§ ğœ™ ( z) â‡’ âˆƒ Å«ğ›¾ ( È³, Å«) such that:</p><formula xml:id="formula_25">â€¢ ( x âˆª È³) âˆ© z = âˆ…, â€¢ ğ›½ ( x, È³) is connected, then â€¢ ğ‘ ğ‘’ğ‘ ğ‘ğ‘ (ğœŒ) = ğ›½ ( x, È³) âˆ§ ğ‘€ ğœ™ â‡’ âˆƒ Å« ğ›¾ ( È³, Å«) â€¢ ğ‘ ğ‘’ğ‘ ğ‘€ (ğœŒ) = ğœ™ ( z) â‡’ ğ‘€ ğœ™</formula><p>If the body of ğœŒ is connected, we assume that ğœ™ ( z) is empty. And we have a nullary predicate ğ‘€ âˆ… âˆˆ Î£ â€² for this occasion.</p><p>The normalization algorithm is performed in three steps:</p></div>
<div><head>Normalization Algorithm</head><p>Step One:</p><formula xml:id="formula_26">T ğ¼ = ğœŒ âˆˆT âˆƒ ğ‘…ğ‘’ğ‘¤ (ğœŒ)</formula><p>Step two:</p><formula xml:id="formula_27">T ğ¼ ğ¼ = {ğ‘ ğ‘’ğ‘ ğ‘ğ‘ (ğœŒ) : ğœŒ âˆˆ T ğ¼ }</formula><p>Step three: T ğ¼ ğ¼ ğ¼ = ğœŒ âˆˆT ğ¼ ğ‘…ğ‘’ğ‘¤ (ğ‘ ğ‘’ğ‘ ğ‘€ (ğœŒ))</p><formula xml:id="formula_28">Return: T ğ‘ ğ¹ = T ğ¼ ğ¼ âˆª T ğ¼ ğ¼ ğ¼</formula><p>The normalization allows us to attack the source of the problem highlighted in the previous section by separating the "disconnected ancestors" required by existential rules and encapsulating those ancestors within rules producing nullary predicates.</p><p>Observation 47. Let ğœŒ be a rule that creates a detached atom in Ch(T ğ‘ ğ¹ , D) for some fact set D. Then ğœŒ is a rule from T ğ¼ ğ¼ and its body consists of a single nullary atom.</p><p>Lemma 48. For any set of facts D over Î£:</p><formula xml:id="formula_29">Ch âˆƒ (T , D) = Ch âˆƒ (T ğ‘ ğ¹ , D)</formula><p>Here, our choice of the Skolem naming convention can be explained. We want to show equality of the structures in Lemma 48 and so if we choose our Skolem naming convention to be dependent on rule names then Lemma 48 would obviously be false.</p></div>
<div><head>A.3 Proof of Lemma 48</head><p>This entire subsection is devoted to the proof of Lemma 48, which will follow directly from Lemma 52 and Lemma 55. But first, as a warm-up, notice that: Exercise 51. Suppose (âˆƒ t, Å« ğœ™ ( t, È³) âˆ§ ğ›¾ ( Å«)) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ xğ›½ ( x, È³)) for some CQs ğœ™, ğ›¾ and ğ›½, where the tuples of variables t âˆª È³ and Å« are disjoint. And suppose âˆƒv ğœ ( v) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Å« ğ›¾ ( Å«)). Then there exists a query âˆƒz ğœš ( z, È³)</p><formula xml:id="formula_30">âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ xğ›½ ( x, È³)) which is contained in (âˆƒ t, v ğœ™ ( t, È³) âˆ§ ğœ ( v)). Hint: Let database D be a frozen body of âˆƒ t, v ğœ™ ( t, È³) âˆ§ ğœ ( v) and observe that D |= ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ x ğ›½ ( x, È³))</formula><p>Notice that the only existential rules in T ğ‘ ğ¹ are the ones in T ğ¼ ğ¼ . Notice also that the only Datalog rules in T ğ‘ ğ¹ are the ones in T ğ¼ ğ¼ ğ¼ and hence the only atoms which are in Ch(T ğ‘ ğ¹ , D) but not in Ch âˆƒ (T ğ‘ ğ¹ , D) are the nullary atoms from the set M.</p><p>By Ch ğ‘–,âˆƒ (T , D) we denote the intersection of Ch ğ‘– (T , D) and Ch âˆƒ (T , D).</p><p>Lemma 52. For each fact set D over Î£ and each ğ‘˜ âˆˆ N:</p><formula xml:id="formula_31">Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D) âŠ† Ch âˆƒ (T , D).</formula><p>Proof. We will show this by induction on ğ‘˜. The case for ğ‘˜ = 0 is trivial. Assume the claim is true for some ğ‘˜ âˆˆ N. We are going to show that it is also true for ğ‘˜ + 1.</p><p>Let ğ›¼ be an atom from Ch ğ‘˜+1,âˆƒ (T ğ‘ ğ¹ , D), which is not in Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D). Then ğ›¼ = ğ‘ğ‘ğ‘ğ‘™ (ğœŒ ğ›¼ , ğœ ğ›¼ ) for some:</p><p>-ğœŒ ğ›¼ âˆˆ T ğ¼ ğ¼ , the rule which actually created ğ›¼, of the form ğœ™ ( t, È³) âˆ§ ğ‘€ ğ›¾ â‡’ âˆƒz ğ›¼ 0 ( È³, z), -ğœ ğ›¼ such that ğœ ğ›¼ (ğœ™ ( t, È³)) âŠ† Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D), (â™¥) -ğ‘€ ğ›¾ such that Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D) |= ğ‘€ ğ›¾ .</p><p>It follows from the construction of T ğ‘ ğ¹ that there must exist:</p><p>(1) A rule ğœŒ â€² âˆˆ T ğ¼ of the form:</p><formula xml:id="formula_32">ğœ™ ( t, È³) âˆ§ ğ›¾ ( Å«) â‡’ âˆƒz ğ›¼ 0 ( È³, z) which, by</formula><p>Step II of the normalization algorithm, led to the creation of ğœŒ ğ›¼ , such that the tuple Å« of variables is disjoint with È³ and with t, and that ğœ™ ( t, È³) is a connected query.</p><p>(2) A rule ğœŒ âˆˆ T âˆƒ of the form:</p><formula xml:id="formula_33">ğ›½ ( x, È³) â‡’ âˆƒz ğ›¼ 0 ( È³, z)</formula><p>which, by Step I of the normalization algorithm, led to the creation of ğœŒ â€² , such that:</p><formula xml:id="formula_34">(âˆƒ t, Å« ğœ™ ( t, È³) âˆ§ ğ›¾ ( Å«)) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ x ğ›½ ( x, È³)) (â™£) (3) A rule ğœŒ ğ‘€ ğ›¾ in T ğ¼ ğ¼ ğ¼ of the form ğœ ( Å«) â‡’ ğ‘€ ğ›¾ such that âˆƒ Å« ğœ ( Å«) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ Å« ğ›¾ ( Å«)</formula><p>) and a substitution ğœ ğœ from the variables in Å« to ğ‘‘ğ‘œğ‘š(Ch ğ‘˜-1,âˆƒ (T ğ‘ ğ¹ , D)) such that ğœ ğœ (ğœ ( Å«)) âŠ† Ch ğ‘˜-1,âˆƒ (T ğ‘ ğ¹ , D). This is because, for ğœŒ ğ›¼ to be applicable in Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D), there must be Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D) |= ğ‘€ ğ›¾ , and since D Ì¸ |= ğ‘€ ğ›¾ , a rule able to produce ğ‘€ ğ›¾ must have earlier been applied.</p><p>In order to complete the induction step, we need to show that ğ›¼ âˆˆ Ch âˆƒ (T , D). Since ğœŒ is a rule of T this claim will follow once we can prove that:</p><formula xml:id="formula_35">Ch âˆƒ (T , D) |= âˆƒ x ğ›½ ( x, ğœ ğ›¼ ( È³)) (â™¦)</formula><p>And (â™¦) will follow (using Exercise 49) once we can show that for some query ğœš ( È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ x ğ›½ ( x, È³)) there is:</p><formula xml:id="formula_36">Ch âˆƒ (T , D) |= ğœš (ğœ ğ›¼ ( È³)) (â™ )</formula><p>Recall that from (â™¥) we know that:</p><formula xml:id="formula_37">Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D) |= âˆƒ t ğœ™ ( t, ğœ ğ›¼ ( È³)).</formula><p>By hypothesis this implies that:</p><formula xml:id="formula_38">Ch âˆƒ (T , D) |= âˆƒ t ğœ™ ( t, ğœ ğ›¼ ( È³)).</formula><p>The claim (â™ ) would be now proven, using (â™£), if we could also show that:</p><formula xml:id="formula_39">Ch âˆƒ (T , D) |= âˆƒ Å« ğ›¾ ( Å«),</formula><p>But this may not be the case. All we know is that:</p><formula xml:id="formula_40">Ch ğ‘˜,âˆƒ (T ğ‘ ğ¹ , D) |= âˆƒ Å« ğœ ( Å«)</formula><p>and therefore (using the hypothesis again) that:</p><formula xml:id="formula_41">Ch âˆƒ (T , D) |= âˆƒ Å« ğœ ( Å«).</formula><p>So we get that Ch âˆƒ (T , D) |= âˆƒs, t ğœ™ ( t, ğœ ğ›¼ ( È³)) âˆ§ ğœ (s). Now use Exercise 51 to get (â™ ). â–¡</p><p>The proof of the following lemma seems overly complicated. Why doesn't it just follow from Exercise 50? This is because, while we assume that T is BDD, we never proved that T ğ‘ ğ¹ is BDD too. Lemma 53. Suppose Ch(T ğ‘ ğ¹ , D) |= ğ‘€ ğœ™ for some nullary fact ğ‘€ ğœ™ . Then ğ¶â„ 1 (T ğ‘ ğ¹ , D) |= ğ‘€ ğœ™ .</p><p>Proof. Suppose Ch(T ğ‘ ğ¹ , D) |= ğ‘€ ğœ™ and let ğ›½ ( x) be the body of the rule from T ğ¼ ğ¼ ğ¼ that created ğ‘€ ğœ™ .</p><p>Recall that ğ›½ ( x) does not contain nullary predicates and that T ğ‘ ğ¹ consists only of existential rules (from T ğ¼ ğ¼ ) and of Datalog rules that prove nullary facts (from T ğ¼ ğ¼ ğ¼ ). This means that Ch âˆƒ (T ğ‘ ğ¹ , D) |= âˆƒ x ğ›½ ( x). Now we can use Lemma 52 and get: Ch âˆƒ (T , D) |= âˆƒ x ğ›½ ( x). Now recall that âˆƒ x ğ›½ ( x) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (ğœ™). From Exercise 50 we get that there exists another boolean query ğ›½ 0 such that ğ›½ 0 âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (ğœ™) and that D |= ğ›½ 0 . And from this we can immediately conclude that Ch Let ğ›¼ be an atom produced by an existential rule during the ğ‘– + 1-th step of Ch(T , D). Let a rule ğœŒ âˆˆ T and a mapping ğœ be such that ğ›¼ = ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) and let ğ›¾ ( x, È³) be a body of ğœŒ where È³ are the frontier variables.</p><p>While we know that Ch ğ‘– (T , D) |= ğœ (ğ›¾ ( x, È³)) we are not sure if Ch ğ‘–,âˆƒ (T , D) |= ğœ (ğ›¾ ( x, È³)): some of the atoms in ğœ (ğ›¾ ( x, È³)) could be produced by Datalog rules of T .</p><p>But ğ¶â„(T , D) = ğ¶â„(T , Ch ğ‘–,âˆƒ (T , D)), so if Ch ğ‘– (T , D) |= ğœ (ğ›¾ ( x, È³)) then we can be sure that there exists a query âˆƒzğ›½ ( z, È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ T (âˆƒ xğ›¾ ( x, È³)) such that Ch ğ‘–,âˆƒ (T , D) |= âˆƒzğ›½ ( z, Ïƒ (ğ‘¦)) or, in other words, Ch ğ‘–,âˆƒ (T , D) |= ğ›½ (ğœ ğ›½ ( z), Ïƒ ( È³)) for some substitution ğœ ğ›½ .</p><p>Observe that from the induction hypothesis we know that Ch ğ‘–+2,âˆƒ (T ğ‘ ğ¹ , D) |= ğ›½ (ğœ ğ›½ ( z), Ïƒ ( È³)).</p><p>Let now ğœŒ â€² be the rule from T ğ‘ ğ¹ (or, to be more precise, from T ğ¼ ğ¼ ), such that â„ğ‘’ğ‘ğ‘‘ (ğœŒ â€² ) = â„ğ‘’ğ‘ğ‘‘ (ğœŒ) and that the body of ğœŒ â€² is of the form ğ›½ 0 ( Å«, È³) âˆ§ ğ‘€ ğœ™ , where ğ›½ ( z, È³) = ğ›½ 0 ( Å«, È³) âˆ§ ğœ™ ( v) for some v disjoint from Å« âˆª È³. It follows from the construction of T ğ‘ ğ¹ that such a ğœŒ â€² exits.</p><p>Let us consider the second case. Note that Ch ğ‘–+2,âˆƒ (T ğ‘ ğ¹ , D) |= ğœ ğ›½ (ğ›½ â€² ( x, È³)) and so all we need to show in order to complete our induction step is that Ch ğ‘–+2 (T ğ‘ ğ¹ , D) |= ğ‘€ ğœ™ .</p><p>Clearly Ch ğ‘–+2,âˆƒ (T ğ‘ ğ¹ , D) |= âˆƒzğœ™ ( z) as we know that ğœ™ âŠ† ğ›½. From this we can conclude that D |= ğ‘Ÿğ‘’ğ‘¤ T (ğœ™) and thus ğ‘€ ğœ™ âˆˆ Ch 2,âˆƒ (T ğ‘ ğ¹ , D).</p><p>This ends the proof of Lemma 55 and therefore of Lemma 48. â–¡ Note that this implies that the sensible and non-nullary atoms of Ch(T ğ‘ ğ¹ , D) form a set of trees having a tree S(ğ‘¡) for each term ğ‘¡ that is a constant of D or detached term of Ch âˆƒ (T ğ‘ ğ¹ , D). And that this set of trees is exactly this same set of trees as in the case of rule set T . Also, note that having Lemma 48 we get a very important: A. <ref type="bibr" target="#b3">4</ref> The Crucial Lemma</p><p>In this section, we state and prove the Crucial Lemma. Recall, that we want to prove, that for any term ğ‘¡ being a constant of D or a detached term of Ch âˆƒ (T ğ‘ ğ¹ , D), the tree S(ğ‘¡) rooted in ğ‘¡ and consisting of sensible atoms of Ch âˆƒ (T ğ‘ ğ¹ , D) requires only a small subset of D to be built by the chase Ch(T ğ‘ ğ¹ , D). First let us distinguish, among the parents and ancestors of some atom in Ch(T ğ‘ ğ¹ , D), its connected parents and connected ancestors: given some parent function ğ‘ğ‘ğ‘Ÿ T ğ‘ ğ¹ for Ch(T ğ‘ ğ¹ , D) and an atom ğ›¼ of Ch(T ğ‘ ğ¹ , D) we define the set of connected parents ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) as the set of all the non-nullary atoms of ğ‘ğ‘ğ‘Ÿ T ğ‘ ğ¹ (ğ›¼). Then for atoms of Ch(T ğ‘ ğ¹ , D) we define their respective sets of connected ancestors as follows:</p><p>â€¢ ğ‘ğ‘ğ‘›ğ‘ (ğ›¼) = {ğ›¼ } for an atom ğ›¼ âˆˆ D,</p><p>â€¢ ğ‘ğ‘ğ‘›ğ‘ (ğ›¼) = ğ›¼ â€² âˆˆğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) ğ‘ğ‘ğ‘›ğ‘ (ğ›¼ â€² ), otherwise.</p><p>Before proceeding, let us define a number of measures, depending on T ğ‘ ğ¹ .</p><p>â€¢ Let ğ‘˜ be the number of nullary predicates in T ğ‘ ğ¹ .</p><p>â€¢ Let â„ be the maximal number of atoms in the body of a rule from T ğ‘ ğ¹ . â€¢ Let ğ‘› be the number of rules in T ğ‘ ğ¹ .</p><p>â€¢ Let ğ‘ be the number of elements of a full ğ‘›-ary tree of depth â„.</p><p>â€¢ Let ğ‘€ = ğ‘â„ + ğ‘˜â„ Now having prepared everything we are going to prove the Crucial Lemma: Lemma 57 (crucial). For every set of facts D, every term ğ‘¡ that is constant of D or detached term of Ch âˆƒ (T ğ‘ ğ¹ , D) and every ancestor function ğ‘ğ‘›ğ‘ T ğ‘ ğ¹ :</p><p>ğ›¼ âˆˆS(ğ‘¡ ) ğ‘ğ‘›ğ‘ T ğ‘ ğ¹ (ğ›¼) â‰¤ ğ‘€ Notice that we now count ancestors with respect to T ğ‘ ğ¹ instead of ancestors with respect to T . This is, in fact, the only difference between this lemma and the (false) Lemma 43.</p><p>Proof. The atoms of S(ğ‘¡) are all produced by the rules of T ğ¼ ğ¼ . Recall that bodies of those rules consist of one connected ğ¶ğ‘„ and one nullary atom. The number of atoms that are ancestors of nullary atoms can easily be bounded by ğ‘˜â„ using Lemma 53.</p><p>What is left to be bound is the number of connected ancestors of S(ğ‘¡). Recall that for ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(T ğ‘ ğ¹ , D)) the set of facts S(ğ‘¡) is a tree with ğ‘¡ as its root. This gives us a natural notion of depth of atoms in S(ğ‘¡), with atoms containing ğ‘¡ being at depth one.</p><p>First we will consider the easier case when ğ‘¡ âˆˆ ğ‘‘ğ‘’ğ‘¡ (Ch(T , D)). Then S(ğ‘¡) is a detached tree, not connected by atoms of Ch(T ğ‘ ğ¹ , D)) to D. Moreover the connected parents and connected ancestors are defined in such a way that every atom is in one connected component of Ch(T ğ‘ ğ¹ , D)) with all its connected ancestors. So, no atom in S(ğ‘¡) has any connected ancestors, and thus the entire S(ğ‘¡) has in total at most ğ‘˜â„ ancestors.</p><p>Let us now move to the case when ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D). Clearly, to be a connected ancestor of someone in S(ğ‘¡) an atom in D must be a connected parent of someone in S(ğ‘¡): Observe that, if an application of an existential rule ğœŒ created an atom at depth greater than â„ then the connected part of the body ğœŒ, of size at most â„, could not "reach" the atoms of D. From this we get ğ‘â„ as bound for the number of connected ancestors of S(ğ‘¡) which implies that ğ‘€ is a bound on the number of ancestors of S(ğ‘¡) for any ğ‘¡. Proof. From Observation 14 the size of D â€² can easily be bounded by â„ ğ‘› ğ‘ğ‘¡ where â„ is the maximal number of atoms in a rule of T and ğ‘› ğ‘ğ‘¡ is the constant from Observation 14. â–¡ Thus ğ‘€ğ‘‘ T is a locality constant for Datalog atoms of Ch(T , D). This concludes the proof of Theorem 1.</p><p>It follows from the above lemma that each S ğ‘– satisfies Condition (â™ ). What we still need to show is that the process terminates: at some point we will get S ğ‘– without live queries. To this end, we are going to use ranks.</p></div>
<div><head>B.2 High-level proof of claim (A).</head><p>Termination.</p><p>For a marked query ğ‘„ and an atom ğ›¼ âˆˆ ğ‘„ G the edge rank ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) will be defined (Definition 75) as some natural number, reflecting "the minimal cost of hiking from a marked variable to ğ›¼". Then we will prove that:</p><p>Lemma 66. Suppose a marked query ğ‘„ â€² is returned as a result of applying one of the five operations to ğ‘„. Then:</p><formula xml:id="formula_42">(i) If the operation is cut-red or fuse-red then |ğ‘„ R | &gt; |ğ‘„ â€² R |. (ii) If the operation is cut-green then |ğ‘„ R | = |ğ‘„ â€² R | and for each ğ›¼ âˆˆ ğ‘„ G there is ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€² ). (iii) If the operation is fuse-green then |ğ‘„ R | &gt; |ğ‘„ â€² R | or |ğ‘„ R | â‰¥ |ğ‘„ â€² R | and ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€² ) for each ğ›¼ âˆˆ ğ‘„ G .</formula><p>(iv) If the operation is reduce and if ğ›¼ âˆˆ ğ‘„ G is the green atom removed by the operation and if ğ›¼ â€² âˆˆ ğ‘(ğ‘„ â€² ) is any of the two green atoms added by the operation then:</p><formula xml:id="formula_43">(a) |ğ‘„ R | = |ğ‘„ â€² R |; (b) ğ‘’ğ‘Ÿğ‘˜ (ğ›¼ â€² , ğ‘„ â€² ) &lt; ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„); (c) if ğ›½ âˆˆ ğ‘„ G âˆ© ğ‘„ â€² G then ğ‘’ğ‘Ÿğ‘˜ (ğ›½, ğ‘„ â€² ) â‰¤ ğ‘’ğ‘Ÿğ‘˜ (ğ›½, ğ‘„).</formula><p>Recall that all the operations except for reduce will decrease the number of variables and of atoms in ğ‘„. Multisets. Using Lemma 66 we are going to prove that our process indeed terminates. To this end we borrow a technique from the term rewriting community. We will use the notation {. . .} ğ‘š to denote a multiset. ğ‘€ (ğ´) will denote the family of all finite multisets with elements from ğ´. By &lt; ğ‘š we will denote the (strict) mutiset ordering on ğ‘€ (N). By R we will mean the set of all possible pairs âŸ¨ğ‘˜, ğ´âŸ© where ğ‘˜ âˆˆ N and ğ´ âˆˆ ğ‘€ (N). For âŸ¨ğ‘˜, ğ´âŸ©, âŸ¨ğ‘˜ â€² , ğ´ â€² âŸ© âˆˆ R define âŸ¨ğ‘˜, ğ´âŸ© &lt; R âŸ¨ğ‘˜ â€² , ğ´ â€² âŸ© if ğ‘˜ &lt; ğ‘˜ â€² , or ğ‘˜ = ğ‘˜ â€² and ğ´ &lt; ğ‘š ğ´ â€² . Finally, let &lt; ğ‘€ be the (strict) multiset ordering on ğ‘€ (R). It is well known ( <ref type="bibr" target="#b18">[19]</ref>) that (â™¥) if ğ´ is well-ordered then the multiset ordering on ğ‘€ (ğ´) is also a well-ordering. So &lt; ğ‘š is a well-ordering. In consequence &lt; R , which is the lexicographic ordering on the Cartesian product of two well-ordered sets is a well-ordering too. And, again using (â™¥), we get that &lt; ğ‘€ is a well-ordering. Definition 67.</p><p>â€¢ For a marked query ğ‘„ define its rank</p><formula xml:id="formula_44">ğ‘ğ‘Ÿğ‘˜ (ğ‘„) âˆˆ R as âŸ¨|ğ‘„ R |, {ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) : ğ›¼ âˆˆ ğ‘„ G } ğ‘š âŸ©.</formula><p>â€¢ For a set of marked queries S define its rank ğ‘ ğ‘Ÿğ‘˜ (S) âˆˆ ğ‘€ (R)</p><p>as the multiset {ğ‘ğ‘Ÿğ‘˜ (ğ‘„) : ğ‘„ âˆˆ S} ğ‘š . Now, since the set ğ‘€ (R) is well-ordered by &lt; ğ‘€ , to prove termination of our process it is enough to show that whenever it produces two subsequent sets S ğ‘– and S ğ‘–+1 there must be ( * ) ğ‘ ğ‘Ÿğ‘˜ (S ğ‘–+1 ) &lt; ğ‘€ ğ‘ ğ‘Ÿğ‘˜ (S ğ‘– ). But recall that S ğ‘–+1 is S ğ‘– with one marked query, call it ğ‘„, replaced by one of the five operations, with a set Q consisting of one or several marked queries. So (this is how the multiset ordering works) in order to show ( * ) it is enough to show that for each ğ‘„ â€² âˆˆ Q we have ğ‘„ â€² &lt; R ğ‘„.</p><p>But this follows immediately from Lemma 66, from the definition of the lexicographic ordering &lt; R (if the operation in question is cut-red or fuse-red) and from the definition of the multiset ordering &lt; ğ‘š (for the remaining three operations).</p></div>
<div><head>B.3 Proof of Lemma 40 (A).</head><p>Five operations. As promised, now we can define the five operations. Suppose ğ‘„ = âŸ¨ğœ™ ( È³), ğ‘‰ âŸ© is a live query and ğ‘¥ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„).</p><p>Definition 69 (cut-red). Suppose ğ‘¥ is as in Lemma 68(i), with ğ¸ = ğ‘…. Define cut-red(ğ‘„, ğ‘¥) as âŸ¨ğœ™ â€² ( È³), ğ‘‰ (ğ‘„)âŸ© where ğœ™ â€² ( È³) is created from ğœ™ ( È³) by removing the sole atom containing ğ‘¥.</p><p>Operation cut-green is defined in an analogous way.</p><p>Definition 70 (fuse-red). Let ğ‘¥, ğ‘§ and ğ‘§ â€² be as in Lemma 68 (iii), with ğ¸ = ğ‘…. Then fuse-red(ğ‘„, ğ‘¥, ğ‘§, ğ‘§ â€² ) = âŸ¨ğœ™ â€² ( È³), ğ‘‰ âŸ© where ğœ™ â€² ( È³) is ğœ™ ( È³) with all occurences of ğ‘§ â€² renamed<ref type="foot" target="#foot_4">7</ref> as ğ‘§.</p><p>Operation fuse-green is defined in an analogous way.</p><p>Definition 71 (reduce). Suppose ğ‘¥ is as in Lemma 68 (ii). Let ğœ™ â€² ( È³) be a query obtained from ğœ™ ( È³) by removing atoms ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥) and ğº (ğ‘¥ ğ‘” , ğ‘¥) and replacing them with atoms ğº (ğ‘¥ â€² , ğ‘¥ â€²â€² ), ğº (ğ‘¥ â€²â€² , ğ‘¥ ğ‘Ÿ ), ğ‘…(ğ‘¥ â€² , ğ‘¥ ğ‘” ) where ğ‘¥ â€² and ğ‘¥ â€²â€² are fresh variables. Then define reduce(ğ‘„, ğ‘¥) as the set of four marked queries âŸ¨ğœ™ â€² ( È³), ğ‘‰ (ğ‘„)âŸ©, âŸ¨ğœ™ â€² ( È³), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€² }âŸ©, âŸ¨ğœ™ â€² ( È³), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€² , ğ‘¥ â€²â€² }âŸ© and âŸ¨ğœ™ â€² ( È³), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€²â€² }âŸ©<ref type="foot" target="#foot_5">8</ref> . Now, Lemma 64 easily follows from Lemma 68 and from Definitions 69-71.</p><p>The next thing left to be proven in this section is Lemma 66. Notice that claim (i) of the Lemma is now obvious: cut-red just removes a single red edge and fuse-red merges two red edges into one. In order to prove claims (ii)-(iv) however one needs to work a little bit harder.</p><p>Ranks. We are now going to define the rank ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) for a live query ğ‘„ and an atom ğ›¼ âˆˆ ğ‘„ G . To this end we consider paths, from some marked variable to ğ›¼, traversing edges of ğ‘(ğ‘„) (in both directions). To be more precise: Definition 72. Given a live query ğ‘„ an ğ‘…-path is a finite sequence ğ‘ƒ such that: â€¢ each of the elements of ğ‘ƒ is either ğ¸ (ğ‘¡, ğ‘§) or ğ¸ -1 (ğ‘§, ğ‘¡) for some ğ¸ (ğ‘¡, ğ‘§) from ğ‘(ğ‘„), where ğ¸ âˆˆ {ğº, ğ‘…} (obviously, ğ¸ -1 (ğ‘§, ğ‘¡) means that we traverse ğ¸ (ğ‘¡, ğ‘§) backwards);</p><p>â€¢ if ğ¸ (ğ‘ , ğ‘¡) and ğ¸ â€² (ğ‘¢, ğ‘§) are two consecutive elements of ğ‘ƒ then ğ‘¡ = ğ‘¢ (where ğ¸, ğ¸ â€² âˆˆ {ğº, ğ‘…, ğº -1 , ğ‘… -1 }); (â˜…) if ğ‘…(ğ‘¡, ğ‘§) is an atom of ğ‘(ğ‘„) then only one of ğ‘…(ğ‘¡, ğ‘§) or ğ‘… -1 (ğ‘§, ğ‘¡) can appear in ğ‘ƒ and it can appear at most once.</p><p>Notice that an atom ğº (ğ‘¡, ğ‘§) of ğ‘(ğ‘„), as well as ğº -1 (ğ‘§, ğ‘¡), can appear any number of times in a ğ‘…-path. Each ğ‘…-path has its elevation and its cost<ref type="foot" target="#foot_6">9</ref> : Definition 73 (elevation and cost). For an empty ğ‘…-path âˆ… we define ğ‘ğ‘œğ‘ ğ‘¡ (âˆ…) = 0 and ğ‘’ğ‘™ğ‘’ğ‘£ (âˆ…) = 3 |ğ‘„ R | . For a path ğ‘ƒ = ğ‘ƒ â€² ğ¸ (ğ‘¥, ğ‘§) we define:</p><formula xml:id="formula_45">â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) = ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€² ) if ğ¸ âˆ‰ {ğ‘…, ğ‘… -1 } â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) = 3 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€² ) if ğ¸ = ğ‘… â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) = 1 3 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€² ) if ğ¸ = ğ‘… -1 â€¢ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) + ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ â€² ) if ğ¸ âˆˆ {ğº, ğº -1 } â€¢ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) if ğ¸ âˆ‰ {ğº, ğº -1 }</formula><p>Notice that it follows from condition (â˜…) of Definition 72 that ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ) is always a positive natural number. Definition 74. For an atom ğ›¼ = ğº (ğ‘¢, ğ‘¢ â€² ) in ğ‘(ğ‘„) by an ğ›¼-hike we mean an ğ‘…-path such that: â€¢ if ğ¸ (ğ‘¡, ğ‘§) or ğ¸ -1 (ğ‘¡, ğ‘§) is the first atom of ğ‘ƒ then ğ‘¡ âˆˆ ğ‘‰ (ğ‘„);</p><p>â€¢ the last element of ğ‘ƒ is either ğº (ğ‘¢, ğ‘¢ â€² ) or ğº -1 (ğ‘¢ â€² , ğ‘¢).</p><p>For ğ›¼ âˆˆ ğ‘„ G we denote the set of all ğ›¼-hikes as â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„).</p><p>Definition 75. For an atom ğ›¼ âˆˆ ğ‘„ G its rank is defined as: ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) = ğ‘šğ‘–ğ‘›({ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) : ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„)}).</p><p>It is easy to see that: Observation 76. For a marked query ğ‘„ and for ğ›¼ = ğº (ğ‘¢, ğ‘¢ â€² ) in ğ‘„ G , if ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) then any of ğ›¼ or ğº -1 (ğ‘¢ â€² , ğ‘¢) can occur only as the last atom of ğ‘ƒ. Now we can finally prove Lemma 66. Proof of Lemma 66 (ii). Let ğ‘„ â€² = cut-green(ğ‘„, ğ‘¥). It follows directly from the construction that |ğ‘„ R | = |ğ‘„ â€² R |. Now take any ğ›¼ âˆˆ ğ‘„ â€² G . We need to show that ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€² ). Let ğ‘§ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„) be such that ğº (ğ‘§, ğ‘¥) is an atom of ğ‘(ğ‘„). Consider any ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„). Let ğ‘ƒ â€² be a path obtained from ğ‘ƒ by deleting each occurrence of ğº (ğ‘§, ğ‘¥) and ğº -1 (ğ‘¥, ğ‘§). Then ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„ â€² ) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) â‰¤ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ). â–¡</p><p>Proof of Lemma 66 (iii). Let ğ‘„ â€² = fuse-green(ğ‘„, ğ‘¥, ğ‘§, ğ‘§ â€² ). If ( * ) there exists a variable ğ‘¢ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„) such that atoms ğ‘…(ğ‘§, ğ‘¢) and ğ‘…(ğ‘§ â€² , ğ‘¢) are in ğ‘(ğ‘„), or that ğ‘…(ğ‘¢, ğ‘§) and ğ‘…(ğ‘¢, ğ‘§ â€² ) are in ğ‘(ğ‘„), then the two red edges merge in ğ‘(ğ‘„ â€² ) and |ğ‘„ R | &gt; |ğ‘„ â€² R |. Also, if ( * * ) at least two of the atoms ğ‘…(ğ‘§, ğ‘§ â€² ), ğ‘…(ğ‘§ â€² , ğ‘§), ğ‘…(ğ‘§, ğ‘§), and ğ‘…(ğ‘§ â€² , ğ‘§ â€² ) are in ğ‘(ğ‘„) then |ğ‘„ R | &gt; |ğ‘„ â€² R |. So suppose there is neither ( * ) nor ( * * ). Take any ğ›¼ âˆˆ ğ‘„ â€² G and ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„). Consider path ğ‘ƒ â€² obtained from ğ‘ƒ by replacing each occurrence of ğ‘§ â€² in ğ‘ƒ with ğ‘§. Obviously, ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ). We now will show that ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„ â€² ). Clearly, one only needs to worry if condition (â˜…) of Definition 72 holds. Suppose towards contradiction that it does not. It can only happen when there exist ğ‘ , ğ‘¡ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„ â€² ) such that two atoms from {ğ‘…(ğ‘ , ğ‘¡), ğ‘… -1 (ğ‘¡, ğ‘ )} appear in ğ‘ƒ.</p><p>Let us assume that ğ‘…(ğ‘ , ğ‘¡) (other cases are analogous) appears twice in ğ‘ƒ â€² . But of course ğ‘…(ğ‘ , ğ‘¡) could not appear twice in ğ‘ƒ, which is an ğ‘…-path. So at least one occurrence of ğ‘…(ğ‘ , ğ‘¡) in ğ‘ƒ â€² results from the unification of ğ‘§ and ğ‘§ â€² .</p><p>There are two cases: either (a) ğ‘  = ğ‘¡ = ğ‘§ or (b) exactly one of ğ‘ , ğ‘¡ equals ğ‘§. So suppose (b) happened and without loss of generality assume that ğ‘  = ğ‘§. We know that there was ğ‘…(ğ‘§, ğ‘¡) and ğ‘…(ğ‘§ â€² , ğ‘¡) in ğ‘ƒ and they both unified to ğ‘…(ğ‘§, ğ‘¡) in ğ‘ƒ â€² . But this would imply ( * ), leading to a contradiction. The remaining case (a) is that ğ‘…(ğ‘§, ğ‘§) occurs twice in ğ‘ƒ â€² . But this would need ( * * ) to be true, which is a contradiction again.</p><p>So Let us first show claim (c). Take some ğ›½ âˆˆ ğ‘„ G âˆ© ğ‘„ â€² G and ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„) such that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘’ğ‘Ÿğ‘˜ (ğ›½, ğ‘„). Our goal is to find ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„ â€² ) such that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) â‰¤ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ).</p><p>Obviously, one can assume that ğ‘ƒ does not contain, as a connected subsequence, ğº (ğ‘¥ ğ‘” , ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ ğ‘” ). If it did, we could remove such subsequence to get a new ğ‘ƒ with lower cost. And, as an R-path, ğ‘ƒ does not contain subsequence ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥)ğ‘… -1 (ğ‘¥, ğ‘¥ ğ‘Ÿ ) either.</p><p>If no atom of ğ‘ƒ contains ğ‘¥ then ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„ â€² ) and thus we set ğ‘ƒ â€² = ğ‘ƒ. Otherwise it contains exactly one of ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ ğ‘” ) or ğº (ğ‘¥ ğ‘” , ğ‘¥)ğ‘… -1 (ğ‘¥, ğ‘¥ ğ‘Ÿ ) as a connected subsequence. Suppose ğ‘ƒ = ğ‘ƒ 0 ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ ğ‘” )ğ‘ƒ 1 . Let ğ´ = ğº -1 (ğ‘¥ ğ‘Ÿ , ğ‘¥ â€²â€² )ğº -1 (ğ‘¥ â€²â€² , ğ‘¥ â€² )ğ‘…(ğ‘¥ â€² , ğ‘¥ ğ‘” ) and consider path ğ‘ƒ â€² = ğ‘ƒ 0 ğ´ğ‘ƒ 1 . Note that ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›½, ğ‘„). Now we need to show that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) &gt; ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ). But: The case when ğ‘ƒ = ğ‘ƒ 0 ğº (ğ‘¥ ğ‘” , ğ‘¥)ğ‘… -1 (ğ‘¥, ğ‘¥ ğ‘Ÿ )ğ‘ƒ 1 , is similar.</p><p>Let us now move to claim (b). Take ğ‘ƒ âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„) such that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„). We are going to build a path ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼ â€² , ğ‘„ â€² ) such that ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) &lt; ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ).</p><p>There are two cases depending on the last atom of ğ‘ƒ:</p><p>In the first case ğ‘ƒ is ğ‘ƒ 0 ğº (ğ‘¥ ğ‘” , ğ‘¥). Let then ğ‘ƒ â€² be ğ‘ƒ 0 ğ‘… -1 (ğ‘¥ ğ‘” , ğ‘¥ â€² )ğº (ğ‘¥ â€² , ğ‘¥ â€²â€² ) or ğ‘ƒ 0 ğ‘… -1 (ğ‘¥ ğ‘” , ğ‘¥ â€² )ğº (ğ‘¥ â€² , ğ‘¥ â€²â€² )ğº (ğ‘¥ â€²â€² , ğ‘¥ ğ‘Ÿ ) (depending on whether ğ›¼ â€² is ğº (ğ‘¥ â€² , ğ‘¥ â€²â€² ) or ğº (ğ‘¥ â€²â€² , ğ‘¥ ğ‘Ÿ )). Then of course ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼ â€² , ğ‘„) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 0 ) + ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ) while ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) â‰¤ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 0 ) + 2  3 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ). The second case is that ğ‘ƒ = ğ‘ƒ 0 ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥)ğº -1 (ğ‘¥, ğ‘¥ ğ‘” ). Here the argument is similar. Now we take ğ‘ƒ â€² = ğ‘ƒ 0 ğº -1 (ğ‘¥ ğ‘Ÿ , ğ‘¥ â€²â€² ) or ğ‘ƒ â€² = ğ‘ƒ 0 ğº -1 (ğ‘¥ ğ‘Ÿ , ğ‘¥ â€²â€² )ğº -1 (ğ‘¥ â€²â€² , ğ‘¥ â€² ) (again depending on whether ğ›¼ â€² is ğº (ğ‘¥ â€² , ğ‘¥ â€²â€² ) or ğº (ğ‘¥ â€²â€² , ğ‘¥ ğ‘Ÿ )). Then ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼ â€² , ğ‘„) and ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 0 ) + 3 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ) while ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) â‰¤ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 0 ) + 2 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ) . â–¡</p></div>
<div><head>B.4 Proof of Lemma 65</head><p>Let ğ‘„ = âŸ¨ğœ™ ( È³), ğ‘‰ âŸ© be any live marked query.</p><p>Lemma 65 will follow directly from Lemmas 77-79:</p><p>Lemma 77. For any set of facts D, tuple Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | and ğ‘¥ such that ğ‘„ â€² = cut-green(ğ‘„, ğ‘¥) (or ğ‘„ â€² = cut-red(ğ‘„, ğ‘¥)) the following</p></div><figure xml:id="fig_0"><head /><label /><figDesc>âˆ€ğœ™ âˆƒğ‘– âˆˆ N âˆ€D ğ¶â„ (D, T) |= ğœ™ â‡” ğ¶â„ ğ‘– (D, T) |= ğœ™ , (BDD)</figDesc></figure>
<figure xml:id="fig_1"><head>Example 1 .</head><label>1</label><figDesc>satisfies all TGDs from T . For a pair T , D, a CQ ğœ™ ( È³), and a tuple Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | , we write T , D |= ğœ™ ( Ä) (or T , D, Ä |= ğœ™ ( È³)) to indicate that T and D jointly entail ğœ™ ( Ä), which means that ğœ™ ( Ä) holds in each structure F satisfying F |= T , D, which serves as a shortcut for F |= T âˆ§ D âŠ† F. Consider the instance D ğ‘ = {ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ´ğ‘ğ‘’ğ‘™)} and the theory T ğ‘ consisting of the following two rules: ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ‘¦) â‡’ âˆƒğ‘§ ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘¦, ğ‘§) ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘¥, ğ‘¦) â‡’ ğ»ğ‘¢ğ‘šğ‘ğ‘›(ğ‘¦) Then T ğ‘ , D ğ‘ |= âˆƒğ‘¦, ğ‘§ ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ´ğ‘ğ‘’ğ‘™, ğ‘¦), ğ‘€ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ (ğ‘¦, ğ‘§).</figDesc></figure>
<figure xml:id="fig_2"><head>Definition 4 (</head><label>4</label><figDesc>Semi-oblivious Skolem chase procedure). â€¢ Ch 0 (T , D) = D, â€¢ Ch ğ‘–+1 (T , D) = Ch ğ‘– (T , D) âˆª {ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) | ğœŒ âˆˆ T , ğœ âˆˆ Hğ‘œğ‘š(ğœŒ, Ch ğ‘– (T , D))}, â€¢ Ch(T , D) = ğ‘– âˆˆN Ch ğ‘– (T , D).</figDesc></figure>
<figure xml:id="fig_3"><head>Observation 23 .</head><label>23</label><figDesc>If a theory is local then it is BDD. Proof (sketch). Given a local theory T and a CQ Î¦, we show that there exists a natural number ğ‘› Î¦ satisfying Definition 10. Due to T being local, we can, for every F with F |= Î¦, identify some D âŠ† F with D |= Î¦ and |D| â‰¤ ğ‘™ T |Î¦|. Therefore, we let F = {D | Ch(T , D) |= Î¦ âˆ§ |D| â‰¤ ğ‘™ T |Î¦|}. For any D âˆˆ F , define ğ‘› D as the minimal natural number such that Ch ğ‘› D (T , D) |= Î¦. As F contains just a finite number of non-isomorphic instances, picking ğ‘› Î¦ = max{ğ‘› D | D âˆˆ F } witnesses that Definition 10 applies. â–¡ We defer any further discussion about locality until later sections. And now, let us state our first result. Theorem 1. Every BDD theory over binary signature is local.</figDesc></figure>
<figure xml:id="fig_4"><head>Lemma 28 .</head><label>28</label><figDesc>For any instance D and for any F âŠ† D, the structure ğ‘€ F is a model of T and D. Proof. Clearly ğ‘€ F |= D. In order to prove ğ‘€ F |= T , consider any ğœŒ âˆˆ T and any ğœ âˆˆ Hğ‘œğ‘š(ğœŒ, ğ‘€ F ). Of course, ğ‘ğ‘ğ‘ğ‘™ (ğœŒ, ğœ) âˆˆ Ch(D), since Ch(D) is by definition closed under rule applications.</figDesc></figure>
<figure xml:id="fig_5"><head /><label /><figDesc>that fr (ğ›¼) âŠ† ğ‘‘ğ‘œğ‘š(ğ¶ğ‘œğ‘Ÿğ‘’ (T , F)) ( * ), as fr (ğ›¼) âŠ† ğ‘‘ğ‘œğ‘š(Ch(F)) and none of the terms in fr (ğ›¼) are banned. Now let â„ * F : Ch(F) â†’ ğ¶ğ‘œğ‘Ÿğ‘’ (T , F) be a homomorphism as in Property 7. Since ğ›¼ âˆˆ Ch(F), we obtain â„ * F (ğ›¼) âˆˆ ğ¶ğ‘œğ‘Ÿğ‘’ (T , F) and thus â„ * F (ğ›¼) âˆˆ ğ‘€ F . As â„ * F is a retraction, â„ * F (fr (ğ›¼)) = fr (ğ›¼) follows from ( * ). Hence, â„ * F (ğ›¼) can serve as our ğ›¼ â€² , concluding the proof. â–¡ Lemma 29. For any instance D and any F âŠ† D there exists a homomorphism â„ * ğ‘€ F from Ch(D) to itself that maps all terms to ğ‘‘ğ‘œğ‘š(ğ‘€ F ) and is the identity on ğ‘‘ğ‘œğ‘š(ğ‘€ F ). Proof. Note that ğ‘€ F |= T (Lemma 28) and D âŠ† ğ‘€ F . Then Property 7 ensures the existence of the claimed homomorphism. â–¡ Let H D be the set of all homomorphisms â„ * ğ‘€ F for F âˆˆ I D . Each â„ * ğ‘€ F âˆˆ H D has as its domain the set ğ‘‘ğ‘œğ‘š(Ch(ğ‘€ F )), that is equal to ğ‘‘ğ‘œğ‘š(Ch(D)), and has as its image a subset of this domain.</figDesc></figure>
<figure xml:id="fig_6"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Fragment of ğ¶â„(T ğ‘‘ , G 8 (ğ‘ 0 , ğ‘ 8 )) (print in colors!)</figDesc></figure>
<figure xml:id="fig_7"><head>Exercise 49 .</head><label>49</label><figDesc>Let D be any instance and let Ä âˆˆ ğ‘‘ğ‘œğ‘š(ğ¶â„(T , D)) | È³ | . Let ğœ™ ( È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( È³)) (whereğœ“ ( È³) is some CQ) and suppose ğ¶â„(T , D) |= ğœ™ ( Ä). Then ğ¶â„(T , D) |= ğœ“ ( Ä). Hint: Recall that ğ¶â„(T , ğ¶â„(T , D)) = ğ¶â„(T , D). Exercise 50. Let ğœ“ ( È³) be any CQ and ğœ™ ( È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( È³)). Let D be any instance and Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | . Suppose ğ¶â„(T , D) |= ğœ™ ( Ä). Then there exists query ğœ™ â€² ( È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ“ ( È³)) such that D |= ğœ™ â€² ( Ä). Hint: Notice that ğ¶â„(T , ğ¶â„(T , D)) = ğ¶â„(T , D).</figDesc></figure>
<figure xml:id="fig_8"><head /><label /><figDesc>1 (T ğ‘ ğ¹ , D) |= ğ‘€ ğœ™ . â–¡ Combining Lemma 53 and Observation 47 we get: Corollary 54. If Ch(T ğ‘ ğ¹ , D) |= ğ›¼ for some detached atom ğ›¼ then ğ¶â„ 2 (T ğ‘ ğ¹ , D) |= ğ›¼. The last lemma we need for the proof of Lemma 48 is: Lemma 55. Ch ğ‘–,âˆƒ (T , D) âŠ† Ch ğ‘–+2,âˆƒ (T ğ‘ ğ¹ , D) Proof. The induction base D âŠ† Ch 2,âˆƒ (T ğ‘ ğ¹ , D) is clearly true. And so let us move to the induction step.</figDesc></figure>
<figure xml:id="fig_9"><head>Corollary 56 .</head><label>56</label><figDesc>For any set of facts D: Ch(T ğ·ğ¿ , Ch âˆƒ (T ğ‘ ğ¹ , D) âˆª D) = Ch(T , D)</figDesc></figure>
<figure xml:id="fig_10"><head>ğ›¼</head><label /><figDesc>âˆˆS(ğ‘¡ ) ğ‘ğ‘ğ‘›ğ‘ (ğ›¼) = ğ›¼ âˆˆS(ğ‘¡ ) ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) âˆ© D. Using the above equality, one can bound the number of ancestors of atoms in the connected ancestors of someone in S(ğ‘¡) in the following way: ğ›¼ âˆˆS(ğ‘¡ ) ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) âˆ© D â‰¤ ğ›¼ âˆˆS(ğ‘¡ ) |ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) âˆ© D| . Now, we can easily bound |ğ‘ğ‘ğ‘ğ‘Ÿ (ğ›¼) âˆ© D| with â„ for any atom ğ›¼ of Ch(T ğ‘ ğ¹ , D). Finally we are going to show that only a finite (and bounded) number of atoms of S(ğ‘¡) have any connected parents in D.</figDesc></figure>
<figure xml:id="fig_11"><head>â–¡ A.5 Proving Theorem 1</head><label>1</label><figDesc>Now we can finally prove Theorem 1. The following is an easy corollary of Lemma 57 and Corollary 56: Corollary 58. For any term ğ‘¡ âˆˆ ğ‘‘ğ‘œğ‘š(D) âˆª ğ‘‘ğ‘’ğ‘¡ (Ch(T ğ‘ ğ¹ , D)) there exists a subset D â€² of D of size at most ğ‘€ such that S(ğ‘¡) âŠ† Ch(T , D â€² ).This is almost Theorem 1, but only for existential atoms of Ch(T , D). However, observe that:Observation 59. There exists a constant ğ‘‘ T such that for any set of facts D and for any atom ğ›¼ of Ch(T ğ·ğ¿ , D) there exists a subset D â€² of D such that |D â€² | &lt; ğ‘‘ T and ğ›¼ âˆˆ Ch(T , D â€² ).</figDesc></figure>
<figure xml:id="fig_12"><head /><label /><figDesc>ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 0 ) + 3 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ) + 3 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ) â€¢ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 1 ) ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 0 ) + 2 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ) + 3 â€¢ ğ‘’ğ‘™ğ‘’ğ‘£ (ğ‘ƒ 0 ) â€¢ ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ 1 )</figDesc></figure>
<figure type="table" xml:id="tab_0"><head>â€¢</head><label /><figDesc>Extend the proof of Theorem 1 to show Conjecture 2, i.e., that all BDD frontier-guarded theories<ref type="bibr" target="#b1">[2]</ref> are local and thus the FUS/FES conjecture holds for them. Also, show if the FUS/FES conjecture holds for bd-local theories and then, of course, try to show the conjecture in the general case! â€¢ Define a class of BDD theories that contains rule sets such as the one from Definition 39. Also, define an expressive class that captures the intuitive notion of locality, contains all known BDD classes, and implies BDD membership. â€¢ Even though we extend Theorem 3 in the appendix (see Lemma 40), we wonder if there is a theory that does not admit an elementary bound on the width of its rewritings. Acknowledgements. Ostropolski-Nalewaja and Marcinkowski were supported by the Polish National Science Centre (NCN) grant 2016/23/B/ST6/01438. Carral was supported by the ANR project CQFD (ANR-18-CE23-0003), the DFG project 389792660 (TRR 248, Center for Perspicuous Systems) and by the BMBF in the Center for Scalable Data Analytics and Artificial Intelligence (ScaDS.AI). Rudolph was supported by the European Research Council through the ERC Consolidator Grant DeciGUT (project number 771779).</figDesc><table /></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>It easily follows from Observation 63 that for every live query ğ‘„ there must exist a maximal variable ğ‘¥ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„). By this we mean that ğ‘¥ âˆ‰ ğ‘‰ and that no atom of the form ğ¸ (ğ‘¥, ğ‘§) occurs in ğ‘(ğ‘„) for ğ¸ âˆˆ {ğº, ğ‘…}. Note that: Lemma 68. Let ğ‘¥ be a maximal variable of a live query âŸ¨ğœ™ ( È³), ğ‘‰ âŸ©. Then one of the following condition holds:(i) ğ‘¥ occurs in exactly one atom ğ¸ (ğ‘§, ğ‘¥), with ğ¸ âˆˆ {ğº, ğ‘…};(ii) ğ‘¥ occurs in exactly two atoms ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥) and ğº (ğ‘¥ ğ‘” , ğ‘¥) for some ğ‘¥ ğ‘Ÿ , ğ‘¥ ğ‘” ; (iii) there exist at least two vertices ğ‘§ â‰  ğ‘§ â€² and ğ¸ âˆˆ {ğº, ğ‘…} such that ğ¸ (ğ‘§, ğ‘¥) and ğ¸ (ğ‘§ â€² , ğ‘¥) are atoms of ğœ™ ( È³).</figDesc><table /></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>ğ‘ƒ â€² âˆˆ â„ğ‘–ğ‘˜ğ‘’ğ‘  (ğ›¼, ğ‘„ â€² ) and ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„) â‰¥ ğ‘’ğ‘Ÿğ‘˜ (ğ›¼, ğ‘„ â€² ). â–¡ Proof of Lemma 66 (iv). Let ğ‘„ â€² be any of the marked queries in reduce(ğ‘„, ğ‘¥). Let ğ‘¥ ğ‘Ÿ and ğ‘¥ ğ‘” be variables of ğ‘„ such that ğº (ğ‘¥ ğ‘” , ğ‘¥) and ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥) are atoms of ğ‘(ğ‘„). Recall that ğ‘¥ â€² , ğ‘¥ â€²â€² âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„ â€² ) are two new variables added by reduce.Clearly, |ğ‘„ â€² R | = |ğ‘„ R |, since when creating ğ‘(ğ‘„ â€² ) from ğ‘(ğ‘„) we have just replaced one red edge with another.</figDesc><table /></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>The queries ğœ™ ( È³) and ğœ“ ( È³) are seen as structures here: the active domains of these structures are the sets of variables of ğœ™ ( È³) and ğœ“ ( È³).</p></note>
			<note place="foot" n="3" xml:id="foot_1"><p>To be precise we should call this new structure ğ‘€ D,F , but D will be fixed and clear from the context.</p></note>
			<note place="foot" n="4" xml:id="foot_2"><p>Such rules are called disconnected in<ref type="bibr" target="#b17">[18]</ref>, however we think that calling those rules detached might help the reader to distinguish those from rules that have disconnected bodies.</p></note>
			<note place="foot" n="5" xml:id="foot_3"><p>Actually, the assumption we really use in the proof of Theorem 1 is not that relations are at most binary, but that the existential rules are "frontier one".</p></note>
			<note place="foot" n="7" xml:id="foot_4"><p>One could wonder what happens if one of the two variables we unify is in ğ‘‰ and the other is not in ğ‘‰ . But this is prohibited by Observation 63 (iii).</p></note>
			<note place="foot" n="8" xml:id="foot_5"><p>Note that âŸ¨ğœ™ â€² ( È³), ğ‘‰ (ğ‘„) âˆª {ğ‘¥ â€²â€² }âŸ© is not properly marked, and thus not live, and it will in no way contribute to our process any more.</p></note>
			<note place="foot" n="9" xml:id="foot_6"><p>The cost of making a step depends on the current elevation. Current elevation depends on the difference between the total ascent and total descent.</p></note>
		</body>
		<back>
			<div type="annex">
<div><head>Appendix B PROOF OF LEMMA 40 (A).</head><p>THE HIGH-LEVEL VIEW.</p><p>Since T ğ‘‘ is fixed, we will use the notation ğ¶â„(F) instead of ğ¶â„(T ğ‘‘ , F) Clearly, to prove that T ğ‘‘ is BDD, it is enough to consider only connected queries, since a bound for any non-connected query can be derived from bounds of its connected components. Additionally, notice that due to the rule (loop), if ğœ™ is a boolean query and if D is any instance then ğ¶â„ 1 (D) |= ğœ™. So for the rest of the proof of Lemma 40 (A) we will consider only connected non-boolean queries. Let us start with: Definition 60 (Marked qery). We define a marked query as a pair âŸ¨ğœ™ ( È³), ğ‘‰ âŸ© where ğœ™ ( È³) = âˆƒ xğ›½ ( x, È³) is a CQ and ğ‘‰ is a subset of variables of ğœ™ ( È³) such that È³ âŠ† ğ‘‰ âŠ† È³ âˆª x.</p><p>We say that the variables in ğ‘‰ are marked. It will often be more convenient to refer to a marked query without (or before) specifying its components. The letter ğ‘„ will be used for that. If ğ‘„ = âŸ¨ğœ™ ( È³), ğ‘‰ âŸ© then by ğ‘‰ (ğ‘„) we mean ğ‘‰ , and ğ‘(ğ‘„) denotes ğœ™ ( È³). By ğ‘£ğ‘ğ‘Ÿ (ğ‘„) we mean the set of all variables of ğ‘(ğ‘„), and ğ‘„ R (ğ‘„ G ) is the set of red (green) atoms in ğ‘(ğ‘„).</p><p>For a marked query ğ‘„ the intention behind the set of marked variables ğ‘‰ (ğ‘„) is that the variables of ğ‘‰ (ğ‘„) should not be mapped onto the chase-produced Skolem terms: Definition 61. For a marked query ğ‘„ = âŸ¨ğœ™ ( È³), ğ‘‰ âŸ©, a fact set D, and Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | we say that ğ¶â„(D) |= ğ‘„ ( Ä) if there exists a homomorphism â„ : ğ‘£ğ‘ğ‘Ÿ (ğ‘„) â†’ ğ‘‘ğ‘œğ‘š(ğ¶â„(D)) witnessing ğ¶â„(D) |= ğœ™ ( Ä) such that for every ğ‘£ there is â„(ğ‘£) âˆˆ ğ‘‘ğ‘œğ‘š(D) if and only if ğ‘£ âˆˆ ğ‘‰ . Some marked queries are false -it follows directly from Definition 39 that they cannot be satisfied in any ğ¶â„(D): Marked queries satisfying conditions (i)-(iii) of Observation 63 will be called properly marked. Marked queries whose all variables are marked will be called totally marked. Properly marked queries that are not totally marked will be called live. Notice that for a totally marked query âŸ¨ğœ™ ( Ä), ğ‘‰ âŸ©, an instance D and a tuple Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | there is ğ¶â„(D) |= âŸ¨ğœ™ ( Ä), ğ‘‰ âŸ© if and only if D |= ğœ™ ( Ä).</p></div>
<div><head>B.1 High-level proof of claim (A). The process.</head><p>Now we get some conjunctive query ğœ™ ( È³), that will be fixed till the end of this proof, and we want to show that there exists a rewriting of ğœ™, i.e. a finite set ğ‘Ÿğ‘’ğ‘¤ (ğœ™ ( È³)) of CQs such that for each D and Ä âˆˆ ğ‘‘ğ‘œğ‘š(D) | È³ | there is ğ¶â„(D) |= ğœ™ ( Ä) if and only if there exists a ğœ“ ( È³) âˆˆ ğ‘Ÿğ‘’ğ‘¤ (ğœ™ ( È³)) such that D |= ğœ“ ( Ä).</p><p>Notice that ğ‘Ÿğ‘’ğ‘¤ (ğœ™ ( È³)) will be constructed if we can produce a finite set S of marked queries, such that: S will be constructed as the result of some process. As the starting point of this process let S 0 = {ğ‘„ : ğ‘(ğ‘„) = ğœ™ ( È³)}, the set of all possible markings of ğœ™ ( È³). One can easily see that S 0 satisfies Condition (â™ ) above, but there is no reason to think that it also satisfies Condition (â™£). Now, the plan is as follows. Five operations are going to be defined in Appendix B.3, called cut-red, cut-green, fuse-red, fuse-green, and reduce. Each of them will:</p><p>â€¢ take, as an input, some marked query ğ‘„;</p><p>â€¢ remove from ğ‘(ğ‘„), one variable and some atoms (operation reduce will remove one red atom and one green) ; â€¢ keep the marking of the surviving variables unchanged; â€¢ in one case (of operation reduce) add two new variables, one red atom, and two green atoms); â€¢ return the resulting marked query (except for operation reduce which will return four marked queries: one for each of the four possible markings of the two new variables).</p><p>It will be shown in Appendix B.3 that:</p><p>Lemma 64 (Completness). If a query is live then at least one of the five operations can be applied to it.</p><p>At this point we can define our process, which is supposed to ultimately create S. Start from S 0 . Once S ğ‘– is defined, which does not satisfy condition (â™£), take any live query ğ‘„ âˆˆ S ğ‘– , apply one of the five operations to this query, and define S ğ‘–+1 as S ğ‘– with ğ‘„ replaced by the query (or queries) resulting from this application. Clearly, for the process to make sense we will need to prove (in Appendix B.  Proof. Let ğ‘¥ â€² , ğ‘¥ â€²â€² , ğ‘¥ ğ‘Ÿ , and ğ‘¥ ğ‘” be variables of ğ‘(ğ‘„) such that ğ‘…(ğ‘¥ ğ‘Ÿ , ğ‘¥), ğº (ğ‘¥ ğ‘” , ğ‘¥) âˆˆ ğ‘(ğ‘„) and that ğ‘…(ğ‘¥ â€² , ğ‘¥ ğ‘” ), ğº (ğ‘¥ â€² , ğ‘¥ â€²â€² ), ğº (ğ‘¥ â€²â€² , ğ‘¥ ğ‘Ÿ ) âˆˆ ğ‘(ğ‘„ â€² ).</p><p>(â‡). Let ğ‘„ â€² âˆˆ Q be such that Ch(T ğ‘‘ , D) |= ğ‘„ â€² ( Ä) and let â„ â€² be a homomorphism witnessing that. We need to show that there exists a homomorphism â„ witnessing Ch(T ğ‘‘ , D) |= ğ‘„ ( Ä).</p><p>Since ğ‘…(ğ‘¥ â€² , ğ‘¥ ğ‘” ), ğº (ğ‘¥ â€² , ğ‘¥ â€²â€² ), ğº (ğ‘¥ â€²â€² , ğ‘¥ ğ‘Ÿ ) are atoms of ğ‘(ğ‘„), and â„ â€² is a homomorphism, we know that ğ‘…(â„ â€² (ğ‘¥ ğ‘” ), â„ â€² (ğ‘¥ â€² )), ğº (â„ â€² (ğ‘¥ â€² ), â„ â€² (ğ‘¥ â€²â€² )) and ğº (â„ â€² (ğ‘¥ â€²â€² ), â„ â€² (ğ‘¥ ğ‘Ÿ )) are atoms of Ch(T ğ‘‘ , D). But, since (ğ‘”ğ‘Ÿğ‘–ğ‘‘) is a rule of T ğ‘‘ , this implies that there exists an element ğ‘¡ âˆˆ Ch(T ğ‘‘ , D), such that ğº (â„ â€² (ğ‘¥ ğ‘” ), â„ â€² (ğ‘¡)) and ğ‘…(â„ â€² (ğ‘¥ ğ‘Ÿ ), â„ â€² (ğ‘¡)) are also in Ch(T ğ‘‘ , D).</p><p>Define â„ by: â€¢ â„(ğ‘¢) = â„ â€² (ğ‘¢) for ğ‘¢ âˆˆ ğ‘£ğ‘ğ‘Ÿ (ğ‘„) \ {ğ‘¥ }.</p><p>â€¢ â„(ğ‘¥) = ğ‘¡. (â‡’). Let â„ be a homomorphism witnessing that Ch(T ğ‘‘ , D) |= ğ‘„ ( Ä). We will show that there exist ğ‘„ â€² âˆˆ Q and a homomorphism â„ â€² such that â„ â€² is witnessing Ch(T ğ‘‘ , D) |= ğ‘„ â€² ( Ä). Again recall that ğ‘¥ is an unmarked variable and so let us find parents of â„(ğ‘¥) in Ch(T ğ‘‘ , D). Note that â„(ğ‘¥) could be created only by rule (ğ‘”ğ‘Ÿğ‘–ğ‘‘) as it has an in-degree of two. Let ğœ be such that ğ‘ğ‘ğ‘ğ‘™ ((ğ‘”ğ‘Ÿğ‘–ğ‘‘), ğœ) = ğ‘…(â„(ğ‘¥ ğ‘Ÿ ), â„(ğ‘¥)), ğº (â„(ğ‘¥ ğ‘” ), â„(ğ‘¥)). We set:</p><p>There are four possible picks for ğ‘„ â€² from Q. While homomorphism â„ â€² works for any of them as elements of Q differ only by markings, we need to make sure that the marking of ğ‘„ â€² agrees with â„ â€² . Obviously for every variable of ğ‘„ this is the case. However we have two new variables to consider, namely ğ‘¥ â€² and ğ‘¥ â€²â€² . Thus we need to take ğ‘„ â€² such that it satisfies:</p><p>This is trivially possible due to Definition 71. â–¡</p></div>
<div><head>Appendix C GENERALIZATION OF LEMMA 40</head><p>For ğ¾ âˆˆ N define T ğ¾ ğ‘‘ as the theory, over Î£ ğ¾ = {ğ¼ ğ¾ , ğ¼ ğ¾-1 , . . . ğ¼ 1 } (each ğ¼ ğ‘˜ is a binary relation symbol), comprising, for each 1 â‰¤ ğ‘– &lt; ğ¾ and each 1 â‰¤ ğ‘˜ â‰¤ ğ¾ the following 2ğ¾ + 1 rules:</p><p>Using the ideas from Appendix B one can now show that:</p><p>Lemma 80. For each ğ¾ âˆˆ N: A. theory T ğ¾ ğ‘‘ is BDD; B. there is a query ğœ“ (ğ‘¦, ğ‘¦ â€² ) such that ğ‘Ÿğ‘’ğ‘¤ T ğ¾ ğ‘‘ (ğœ“ (ğ‘¦, ğ‘¦ â€² )) contains a CQ of size (ğ¾-1)-fold exponential in the size of ğœ“ .</p><p>Like in the case of Lemma 40, claim B of Lemma 80 is relatively easy to prove.</p><p>For the proof of claim A, properly marked queries first need to be slightly redefined (but let us skip it here). Then the five operations need to be generalized in the natural way: we will now have ğ¾ cut operations, ğ¾ fuse operations, and ğ¾-1 reduce operations.</p><p>The non-obvious part is how to modify the ranks ğ‘’ğ‘Ÿğ‘˜ and ğ‘ğ‘Ÿğ‘˜ so that they do their job correctly in the new circumstances. For that ğ¼ ğ‘– -paths need to be defined (for 1 â‰¤ ğ‘– &lt; ğ¾), analogous to ğ‘…-paths in Definition 72. But now the condition (â˜…) will apply to atoms of the relation ğ¼ ğ‘– (including ğ¼ -1 ğ‘– ). Then ğ‘–-elevation (ğ‘’ğ‘™ğ‘’ğ‘£ ğ‘– ) will be defined, like in Definition 73. And finally, we will need ğ‘ğ‘œğ‘ ğ‘¡ ğ‘– of a path, calculated almost like the cost of the path in Definition 73: for a path ğ‘ƒ = ğ‘ƒ â€² ğ¸ (ğ‘¥, ğ‘§) we have ğ‘ğ‘œğ‘ ğ‘¡ ğ‘– (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) + ğ‘’ğ‘™ğ‘’ğ‘£ ğ‘– (ğ‘ƒ â€² ) if ğ¸ = ğ¼ ğ‘–-1 or ğ¼ -1  ğ‘–-1 and ğ‘ğ‘œğ‘ ğ‘¡ ğ‘– (ğ‘ƒ) = ğ‘ğ‘œğ‘ ğ‘¡ (ğ‘ƒ â€² ) otherwise. Notice that ğ¼ ğ‘– is the new red and ğ¼ ğ‘–-1 is the new green. Note also that we have a new situation: ğ¸ may now very well be neither "green" nor "red". And that is fine, in such case it neither contributes to the elevation nor to the cost of the path.</p><p>Having the function ğ‘ğ‘œğ‘ ğ‘¡ ğ‘– , rank ğ‘’ğ‘Ÿğ‘˜ (ğ›¼) of an atom ğ›¼ of the relation ğ¼ ğ‘–-1 is (like in Appendix B.3) defined as minimal ğ‘ğ‘œğ‘ ğ‘¡ ğ‘– of an ğ¼ ğ‘– -path from some marked variable to ğ›¼, and rank ğ‘ğ‘Ÿğ‘˜ ğ‘– (ğ‘„) is the multiset of all ranks ğ‘’ğ‘Ÿğ‘˜ (ğ›¼) of all atoms ğ›¼ of ğ¼ ğ‘–-1 in ğ‘„. Finally, ğ‘ğ‘Ÿğ‘˜ (ğ‘„) is the tuple:</p><p>where |ğ‘„ ğ‘– | is the number of the atoms of the relation ğ¼ ğ‘– in ğ‘„. Clearly, the lexicographic ordering on the set of such ranks is a well ordering. Now, a careful case inspection shows that each of the 3ğ¾-1 operations decreases the rank of a query.</p></div>
<div><head>Appendix D REMARKS ON T ğ‘‘</head><p>There are two technical problems one needs to deal with here:</p><p>A Journey to the Frontiers of Query Rewritability (Extended Technical Report)</p><p>(1) There are conjunctions in the heads of rules (loop) and (grid) (notice that the rule (pins) can be simply split into two singlehead rules).</p><p>(2) we have predicate "true" in the bodies of rules (loop) and (pins) To deal with the first problem we could introduce a new ternary predicate ğ‘‡ , and rewrite the rules as:</p><p>(ğ‘™ğ‘œğ‘œğ‘) ğ‘¡ğ‘Ÿğ‘¢ğ‘’ â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥) (ğ‘”ğ‘Ÿğ‘–ğ‘‘) ğ‘…(ğ‘¥, ğ‘¥ â€² ), ğº (ğ‘¥, ğ‘¢), ğº (ğ‘¢, ğ‘¢ â€² ) â‡’ âˆƒğ‘§ğ‘‡ (ğ‘¢ â€² , ğ‘¥ â€² , ğ‘§)</p><p>Then add Datalog rules: ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§) â‡’ ğ‘…(ğ‘¥, ğ‘§) ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§) â‡’ ğº (ğ‘¦, ğ‘§) ğ‘…(ğ‘¥, ğ‘§), ğº (ğ‘¦, ğ‘§) â‡’ ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§) In this way ğ‘‡ (ğ‘¥, ğ‘¦, ğ‘§) is just a macro for ğ‘…(ğ‘¥, ğ‘§) and ğº (ğ‘¦, ğ‘§) and clearly the transformation does not change the BDD status of the theory.</p><p>To deal with the second problem we need to replace the predicate "true" with something like "if anything at all exists". For rule (loop) it would mean that it should be replaced with three rules: ğ‘…(ğ‘¦, ğ‘§) â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥) ğº (ğ‘¦, ğ‘§) â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥) ğ‘‡ (ğ‘¡, ğ‘¦, ğ‘§) â‡’ âˆƒğ‘¥ğ‘‡ (ğ‘¥, ğ‘¥, ğ‘¥) This transformation leads to a theory which is equivalent to our T ğ‘‘ on all nonempty instances, but this is of course good enough.</p><p>An analogous (albeit slightly more complicated) trick works for (pins).</p></div>
<div><head>Appendix E STICKY AND BD-LOCAL</head><p>Here we prove the following observation: Observation 81. Every connected sticky theory is bd-local Proof. Let T be a connected sticky theory and D be any instance with ğ‘˜ being its degree. Let ğ´( Ã¬ ğ‘) be an atom of Ch(T , D) and F be the minimal subset of D such that ğ´( Ã¬ ğ‘) âˆˆ Ch(T , F). We show that |F| depends only on T and ğ‘˜. As T is connected and sticky we know that if |F| &gt; 1 then every fact of F needs to contain some term of Ã¬ ğ‘. From this we conclude that |F| â‰¤ | Ã¬ ğ‘|ğ‘˜, thus we know that T is local. â–¡</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The chase revisited</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</editor>
		<meeting>of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems<address><addrLine>PODS</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Datalog Â± : a unified approach to ontologies and integrity constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 12th International Conference on Database Theory, ICDT 2009</title>
		<title level="s">ACM International Conference Proceeding Series</title>
		<editor>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</editor>
		<meeting>of the 12th International Conference on Database Theory, ICDT 2009</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">361</biblScope>
			<biblScope unit="page" from="14" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Sound, complete and minimal UCQ-rewriting for existential rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>KÃ¶nig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="451" to="475" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">First-order rewritability of frontierguarded ontology-mediated queries</title>
		<author>
			<persName><forename type="first">P</forename><surname>BarcelÃ³</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 27th International Joint Conference on Artificial Intelligence, IJCAI 2018</title>
		<meeting>of the 27th International Joint Conference on Artificial Intelligence, IJCAI 2018</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1707" to="1713" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">On the first-order rewritability of conjunctive queries over binary guarded existential rules</title>
		<author>
			<persName><forename type="first">C</forename><surname>Civili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 30th Italian Conference on Computational Logic</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Ancona</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Maratea</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Mascardi</surname></persName>
		</editor>
		<meeting>of the 30th Italian Conference on Computational Logic</meeting>
		<imprint>
			<publisher>CEUR-WS.org</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">1459</biblScope>
			<biblScope unit="page" from="25" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Advanced processing for ontological queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="554" to="565" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Undecidable optimization problems for database logic programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gaifman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">G</forename><surname>Mairson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="683" to="713" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The DL-Lite family and relations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Artale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1" to="69" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Conjunctive Query Answering Under Existential Rules -Decidability, Complexity, and Algorithms</title>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<pubPlace>France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Montpellier 2 University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the k-boundedness for existential rules</title>
		<author>
			<persName><forename type="first">S</forename><surname>Delivorias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ulliana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 2nd International Joint Conference on Rules and Reasoning</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">C</forename><surname>BenzmÃ¼ller</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Ricca</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">X</forename><surname>Parent</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Roman</surname></persName>
		</editor>
		<meeting>of 2nd International Joint Conference on Rules and Reasoning<address><addrLine>RuleML+RR</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">11092</biblScope>
			<biblScope unit="page" from="48" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Oblivious and semi-oblivious boundedness for existential rules</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ulliana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gallois</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 28th International Joint Conference on Artificial Intelligence, IJCAI 2019</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kraus</surname></persName>
		</editor>
		<meeting>of the 28th International Joint Conference on Artificial Intelligence, IJCAI 2019</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1581" to="1587" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The core of a graph</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nesetril</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discret. Math</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="117" to="126" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A general datalog-based framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="57" to="83" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Revisiting chase termination for existential rules and their extension to nonmonotonic negation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Garreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rocher</surname></persName>
		</author>
		<idno>abs/1405.1071</idno>
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Query rewriting and optimization for ontological databases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Orsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014-10">Oct. 2014</date>
			<biblScope unit="volume">39</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>KrÃ¶tzsch</surname></persName>
		</author>
		<ptr target="https://cstheory.stackexchange.com/questions/4859/what-is-first-order-rewritable-and-fo-query" />
		<title level="m">What is first-order rewritable (and fo-query)?</title>
		<imprint>
			<date type="published" when="2020-11-27">2020-11-27</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Extending decidable cases for rules with existential variables</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st International Joint Conference on Artificial Intelligence, IJCAI 2009</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Boutilier</surname></persName>
		</editor>
		<meeting>of the 21st International Joint Conference on Artificial Intelligence, IJCAI 2009</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="677" to="682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Proving termination with multiset orderings</title>
		<author>
			<persName><forename type="first">N</forename><surname>Dershowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Manna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="465" to="476" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</teiCorpus></text>
</TEI>