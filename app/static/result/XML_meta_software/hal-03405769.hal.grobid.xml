<?xml version='1.0' encoding='utf-8'?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 http://api.archives-ouvertes.fr/documents/aofr-sword.xsd">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>HAL TEI export of hal-03405769</title>
      </titleStmt>
      <publicationStmt>
        <distributor>CCSD</distributor>
        <availability status="restricted">
          <licence target="http://creativecommons.org/licenses/by/4.0/">Distributed under a Creative Commons Attribution 4.0 International License</licence>
        </availability>
        <date when="2024-04-19T18:27:10+02:00" />
      </publicationStmt>
      <sourceDesc>
        <p part="N">HAL API platform</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <listBibl>
        <biblFull>
          <titleStmt>
            <title xml:lang="en">Cardinality Queries over DL-Lite Ontologies</title>
            <author role="aut">
              <persName>
                <forename type="first">Meghyn</forename>
                <surname>Bienvenu</surname>
              </persName>
              <email type="md5">ab9cbd012f00b78d105744080ad4455d</email>
              <email type="domain">labri.fr</email>
              <idno type="idhal" notation="string">meghyn</idno>
              <idno type="idhal" notation="numeric">183255</idno>
              <idno type="halauthorid" notation="string">46841-183255</idno>
              <idno type="ORCID">https://orcid.org/0000-0001-6229-8103</idno>
              <affiliation ref="#struct-3102" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Quentin</forename>
                <surname>Manière</surname>
              </persName>
              <email type="md5">5a94309b022f2580bb8af48192b0cca4</email>
              <email type="domain">u-bordeaux.fr</email>
              <idno type="idhal" notation="string">quentin-maniere</idno>
              <idno type="idhal" notation="numeric">1146841</idno>
              <idno type="halauthorid" notation="string">2018340-1146841</idno>
              <idno type="ORCID">https://orcid.org/0000-0001-9618-8359</idno>
              <affiliation ref="#struct-3102" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Michaël</forename>
                <surname>Thomazo</surname>
              </persName>
              <email type="md5">1655ea762ee3d1ef66244716bb693bcc</email>
              <email type="domain">inria.fr</email>
              <idno type="idhal" notation="string">michael-thomazo</idno>
              <idno type="idhal" notation="numeric">8241</idno>
              <idno type="halauthorid" notation="string">16765-8241</idno>
              <idno type="IDREF">https://www.idref.fr/177303972</idno>
              <affiliation ref="#struct-478610" />
            </author>
            <editor role="depositor">
              <persName>
                <forename>Michaël</forename>
                <surname>Thomazo</surname>
              </persName>
              <email type="md5">1655ea762ee3d1ef66244716bb693bcc</email>
              <email type="domain">inria.fr</email>
            </editor>
            <funder ref="#projanr-48388" />
            <funder>This work was partially supported by ANR project CQFD (ANR-18-CE23-0003).</funder>
          </titleStmt>
          <editionStmt>
            <edition n="v1" type="current">
              <date type="whenSubmitted">2021-10-27 13:58:53</date>
              <date type="whenModified">2024-04-19 16:18:58</date>
              <date type="whenReleased">2021-10-27 15:12:05</date>
              <date type="whenProduced">2021-08-19</date>
              <date type="whenEndEmbargoed">2021-10-27</date>
              <ref type="file" target="https://inria.hal.science/hal-03405769/document">
                <date notBefore="2021-10-27" />
              </ref>
              <ref type="file" subtype="author" n="1" target="https://inria.hal.science/hal-03405769/file/main.pdf">
                <date notBefore="2021-10-27" />
              </ref>
            </edition>
            <respStmt>
              <resp>contributor</resp>
              <name key="338284">
                <persName>
                  <forename>Michaël</forename>
                  <surname>Thomazo</surname>
                </persName>
                <email type="md5">1655ea762ee3d1ef66244716bb693bcc</email>
                <email type="domain">inria.fr</email>
              </name>
            </respStmt>
          </editionStmt>
          <publicationStmt>
            <distributor>CCSD</distributor>
            <idno type="halId">hal-03405769</idno>
            <idno type="halUri">https://inria.hal.science/hal-03405769</idno>
            <idno type="halBibtex">bienvenu:hal-03405769</idno>
            <idno type="halRefHtml">&lt;i&gt;IJCAI 2021 - 30th International Joint Conference on Artificial Intelligence&lt;/i&gt;, Aug 2021, Montreal, Canada</idno>
            <idno type="halRef">IJCAI 2021 - 30th International Joint Conference on Artificial Intelligence, Aug 2021, Montreal, Canada</idno>
          </publicationStmt>
          <seriesStmt>
            <idno type="stamp" n="ENS-PARIS">Ecole Normale Supérieure de Paris</idno>
            <idno type="stamp" n="CNRS">CNRS - Centre national de la recherche scientifique</idno>
            <idno type="stamp" n="INRIA">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="INRIA-ROCQ">INRIA Paris - Rocquencourt</idno>
            <idno type="stamp" n="TESTALAIN1">TESTALAIN1</idno>
            <idno type="stamp" n="TESTBORDEAUX">TESTBORDEAUX</idno>
            <idno type="stamp" n="INRIA2">INRIA 2</idno>
            <idno type="stamp" n="PSL">Université Paris sciences et lettres</idno>
            <idno type="stamp" n="INRIA-PSL">INRIA-PSL</idno>
            <idno type="stamp" n="TEST-HALCNRS">Collection test HAL CNRS</idno>
            <idno type="stamp" n="ENS-PSL" corresp="PSL">École normale supérieure - PSL</idno>
            <idno type="stamp" n="ANR">ANR</idno>
            <idno type="stamp" n="DIENS" corresp="ENS-PARIS">Département d'informatique de l'ENS-PSL</idno>
          </seriesStmt>
          <notesStmt>
            <note type="audience" n="2">International</note>
            <note type="invited" n="0">No</note>
            <note type="popular" n="0">No</note>
            <note type="peer" n="1">Yes</note>
            <note type="proceedings" n="1">Yes</note>
          </notesStmt>
          <sourceDesc>
            <biblStruct>
              <analytic>
                <title xml:lang="en">Cardinality Queries over DL-Lite Ontologies</title>
                <author role="aut">
                  <persName>
                    <forename type="first">Meghyn</forename>
                    <surname>Bienvenu</surname>
                  </persName>
                  <email type="md5">ab9cbd012f00b78d105744080ad4455d</email>
                  <email type="domain">labri.fr</email>
                  <idno type="idhal" notation="string">meghyn</idno>
                  <idno type="idhal" notation="numeric">183255</idno>
                  <idno type="halauthorid" notation="string">46841-183255</idno>
                  <idno type="ORCID">https://orcid.org/0000-0001-6229-8103</idno>
                  <affiliation ref="#struct-3102" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Quentin</forename>
                    <surname>Manière</surname>
                  </persName>
                  <email type="md5">5a94309b022f2580bb8af48192b0cca4</email>
                  <email type="domain">u-bordeaux.fr</email>
                  <idno type="idhal" notation="string">quentin-maniere</idno>
                  <idno type="idhal" notation="numeric">1146841</idno>
                  <idno type="halauthorid" notation="string">2018340-1146841</idno>
                  <idno type="ORCID">https://orcid.org/0000-0001-9618-8359</idno>
                  <affiliation ref="#struct-3102" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Michaël</forename>
                    <surname>Thomazo</surname>
                  </persName>
                  <email type="md5">1655ea762ee3d1ef66244716bb693bcc</email>
                  <email type="domain">inria.fr</email>
                  <idno type="idhal" notation="string">michael-thomazo</idno>
                  <idno type="idhal" notation="numeric">8241</idno>
                  <idno type="halauthorid" notation="string">16765-8241</idno>
                  <idno type="IDREF">https://www.idref.fr/177303972</idno>
                  <affiliation ref="#struct-478610" />
                </author>
              </analytic>
              <monogr>
                <meeting>
                  <title>IJCAI 2021 - 30th International Joint Conference on Artificial Intelligence</title>
                  <date type="start">2021-08-19</date>
                  <date type="end">2021-08-26</date>
                  <settlement>Montreal</settlement>
                  <country key="CA">Canada</country>
                </meeting>
                <imprint />
              </monogr>
            </biblStruct>
          </sourceDesc>
          <profileDesc>
            <langUsage>
              <language ident="en">English</language>
            </langUsage>
            <textClass>
              <classCode scheme="halDomain" n="info.info-lo">Computer Science [cs]/Logic in Computer Science [cs.LO]</classCode>
              <classCode scheme="halDomain" n="info.info-db">Computer Science [cs]/Databases [cs.DB]</classCode>
              <classCode scheme="halDomain" n="info.info-cc">Computer Science [cs]/Computational Complexity [cs.CC]</classCode>
              <classCode scheme="halDomain" n="info.info-ai">Computer Science [cs]/Artificial Intelligence [cs.AI]</classCode>
              <classCode scheme="halTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halOldTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halTreeTypology" n="COMM">Conference papers</classCode>
            </textClass>
            <abstract xml:lang="en">
              <p>Ontology-mediated query answering (OMQA) employs structured knowledge and automated reasoning in order to facilitate access to incomplete and possibly heterogeneous data. While most research on OMQA adopts (unions of) conjunctive queries as the query language, there has been recent interest in handling queries that involve counting. In this paper, we advance this line of research by investigating cardinality queries (which correspond to Boolean atomic counting queries) coupled with DL-Lite ontologies. Despite its apparent simplicity, we show that such an OMQA setting gives rise to rich and complex behaviour. While we prove that cardinality query answering is tractable (TC 0) in data complexity when the ontology is formulated in DL-Lite core , the problem becomes coNP-hard as soon as role inclusions are allowed. For DL-Lite H pos (which allows only positive axioms), we establish a P-coNP dichotomy and pinpoint the TC 0 cases; for DL-Lite H core (allowing also negative axioms), we identify new sources of coNP complexity and also exhibit L-complete cases. Interestingly, and in contrast to related tractability results, we observe that the canonical model may not give the optimal count value in the tractable cases, which led us to develop an entirely new approach based upon exploring a space of strategies to determine the minimum possible number of query matches.</p>
            </abstract>
          </profileDesc>
        </biblFull>
      </listBibl>
    </body>
    <back>
      <listOrg type="structures">
        <org type="laboratory" xml:id="struct-3102" status="VALID">
          <orgName>Laboratoire Bordelais de Recherche en Informatique</orgName>
          <orgName type="acronym">LaBRI</orgName>
          <date type="start">1988-01-01</date>
          <desc>
            <address>
              <addrLine>Domaine Universitaire 351, cours de la Libération 33405 Talence Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.labri.fr</ref>
          </desc>
          <listRelation>
            <relation active="#struct-259761" type="direct" />
            <relation active="#struct-300366" type="direct" />
            <relation name="UMR5800 / URA1304" active="#struct-441569" type="direct" />
          </listRelation>
        </org>
        <org type="researchteam" xml:id="struct-478610" status="VALID">
          <idno type="RNSR">201622223R</idno>
          <orgName>Value from Data</orgName>
          <orgName type="acronym">VALDA </orgName>
          <date type="start">2016-12-01</date>
          <desc>
            <address>
              <addrLine>ENS Paris</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.inria.fr/equipes/valda</ref>
          </desc>
          <listRelation>
            <relation active="#struct-25027" type="direct" />
            <relation active="#struct-59704" type="indirect" />
            <relation active="#struct-564132" type="indirect" />
            <relation active="#struct-300009" type="indirect" />
            <relation name="UMR8548" active="#struct-441569" type="indirect" />
            <relation active="#struct-454310" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-259761" status="VALID">
          <idno type="ROR">https://ror.org/057qpr032</idno>
          <orgName>Université de Bordeaux</orgName>
          <orgName type="acronym">UB</orgName>
          <desc>
            <address>
              <addrLine>35, place Pey Berland - 33076 Bordeaux</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.u-bordeaux.fr/</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-300366" status="VALID">
          <orgName>École Nationale Supérieure d'Électronique, Informatique et Radiocommunications de Bordeaux (ENSEIRB)</orgName>
          <desc>
            <address>
              <country key="FR" />
            </address>
          </desc>
        </org>
        <org type="regroupinstitution" xml:id="struct-441569" status="VALID">
          <idno type="IdRef">02636817X</idno>
          <idno type="ISNI">0000000122597504</idno>
          <idno type="ROR">https://ror.org/02feahw73</idno>
          <orgName>Centre National de la Recherche Scientifique</orgName>
          <orgName type="acronym">CNRS</orgName>
          <date type="start">1939-10-19</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cnrs.fr/</ref>
          </desc>
        </org>
        <org type="regrouplaboratory" xml:id="struct-25027" status="VALID">
          <idno type="IdRef">148034055</idno>
          <idno type="RNSR">199812876J</idno>
          <orgName>Département d'informatique - ENS Paris</orgName>
          <orgName type="acronym">DI-ENS</orgName>
          <date type="start">1999-01-01</date>
          <desc>
            <address>
              <addrLine>École normale supérieure 45 rue d'Ulm F-75230 Paris Cedex 05</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.di.ens.fr/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-59704" type="direct" />
            <relation active="#struct-564132" type="indirect" />
            <relation active="#struct-300009" type="direct" />
            <relation name="UMR8548" active="#struct-441569" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-59704" status="VALID">
          <idno type="IdRef">031738419</idno>
          <idno type="ISNI">0000000123532622</idno>
          <idno type="ROR">https://ror.org/05a0dhs15</idno>
          <orgName>École normale supérieure - Paris</orgName>
          <orgName type="acronym">ENS-PSL</orgName>
          <date type="start">1985-07-24</date>
          <desc>
            <address>
              <addrLine>45, Rue d'Ulm - 75230 Paris cedex 05</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.ens.psl.eu/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-564132" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-564132" status="VALID">
          <idno type="IdRef">241597595</idno>
          <idno type="ISNI">0000 0004 1784 3645</idno>
          <orgName>Université Paris Sciences et Lettres</orgName>
          <orgName type="acronym">PSL</orgName>
          <desc>
            <address>
              <addrLine>60 rue Mazarine 75006 Paris</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.psl.eu/</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-300009" status="VALID">
          <idno type="ROR">https://ror.org/02kvxyf05</idno>
          <orgName>Institut National de Recherche en Informatique et en Automatique</orgName>
          <orgName type="acronym">Inria</orgName>
          <desc>
            <address>
              <addrLine>Domaine de VoluceauRocquencourt - BP 10578153 Le Chesnay Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/en/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-454310" status="VALID">
          <idno type="IdRef">241614864</idno>
          <idno type="RNSR">196718247G</idno>
          <orgName>Inria de Paris</orgName>
          <date type="start">2016-03-10</date>
          <desc>
            <address>
              <addrLine>2 rue Simone Iff -CS 42112 -75589 Paris Cedex 12</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/centre/paris</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300009" type="direct" />
          </listRelation>
        </org>
      </listOrg>
      <listOrg type="projects">
        <org type="anrProject" xml:id="projanr-48388" status="VALID">
          <idno type="anr">ANR-18-CE23-0003</idno>
          <idno type="program">APPEL À PROJETS GÉNÉRIQUE 2018</idno>
          <orgName>CQFD</orgName>
          <desc>Requêtes Ontologiques Complexes sur des Fédérations de Données Hétérogènese</desc>
          <date type="start">2018</date>
        </org>
      </listOrg>
    </back>
  <teiCorpus>
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Cardinality Queries over DL-Lite Ontologies</title>
				<funder ref="#_x8c6Crc">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
							<email>meghyn.bienvenu@u-bordeaux.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Bordeaux INP</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">University of Bordeaux</orgName>
								<orgName type="institution" key="instit3">LaBRI</orgName>
								<address>
									<settlement>Talence</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Quentin</forename><surname>Manière</surname></persName>
							<email>quentin.maniere@u-bordeaux.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Bordeaux INP</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">University of Bordeaux</orgName>
								<orgName type="institution" key="instit3">LaBRI</orgName>
								<address>
									<settlement>Talence</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
							<email>michael.thomazo@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">ENS</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">University PSL</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Cardinality Queries over DL-Lite Ontologies</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">AAE8CF0BF74E6D760B7E1F6A0820BC20</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Ontology-mediated query answering (OMQA) employs structured knowledge and automated reasoning in order to facilitate access to incomplete and possibly heterogeneous data. While most research on OMQA adopts (unions of) conjunctive queries as the query language, there has been recent interest in handling queries that involve counting. In this paper, we advance this line of research by investigating cardinality queries (which correspond to Boolean atomic counting queries) coupled with DL-Lite ontologies. Despite its apparent simplicity, we show that such an OMQA setting gives rise to rich and complex behaviour. While we prove that cardinality query answering is tractable (TC 0 ) in data complexity when the ontology is formulated in DL-Lite core , the problem becomes coNP-hard as soon as role inclusions are allowed. For DL-Lite H pos (which allows only positive axioms), we establish a P-coNP dichotomy and pinpoint the TC 0 cases; for DL-Lite H core (allowing also negative axioms), we identify new sources of coNP complexity and also exhibit L-complete cases. Interestingly, and in contrast to related tractability results, we observe that the canonical model may not give the optimal count value in the tractable cases, which led us to develop an entirely new approach based upon exploring a space of strategies to determine the minimum possible number of query matches.</p></div>
<div><head n="2">Preliminaries</head><p>We recall standard definitions and notation for OMQA in DL-Lite and introduce the particular setting studied in this paper.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">Introduction</head><p>In ontology-mediated query answering (OMQA) <ref type="bibr" target="#b27">[Poggi et al., 2008;</ref><ref type="bibr" target="#b8">Bienvenu and Ortiz, 2015;</ref><ref type="bibr" target="#b31">Xiao et al., 2018]</ref>, data is enriched with an ontology, which serves both to provide a user-friendly vocabulary for query formulation and to capture domain knowledge that is exploited at query time to obtain a more complete set of answers. While the OMQA approach offers many advantages, it also makes the query answering task more challenging than 'plain' query evaluation. Indeed, instead of having to evaluate the query over the single explicitly given data instance, one must identify the certain answers, i.e. those holding in all possible situations (models) compatible with the data and the ontology.</p><p>A major topic in OMQA research has thus been to understand the complexity of OMQA and identify tractable settings. Nowadays, for the most commonly considered query language, namely, conjunctive queries (CQs), we have an almost complete picture of the complexity landscape for ontologies formulated in a wide range of different description logics (DLs) <ref type="bibr" target="#b4">[Baader et al., 2017]</ref> and rule-based languages <ref type="bibr" target="#b6">[Baget et al., 2011;</ref><ref type="bibr" target="#b10">Calì et al., 2012]</ref>. In particular, it has been shown that CQ answering is tractable in data complexity for ontologies expressed in the most commonly considered dialects of the DL-Lite family <ref type="bibr" target="#b12">[Calvanese et al., 2007;</ref><ref type="bibr" target="#b2">Artale et al., 2009]</ref>, which are often employed in OMQA. A well-known and frequently used property of such DL-Lite dialects and other Horn DLs is that they admit a canonical model, which is a single (possibly infinite) model that, by virtue of being homomorphically embeddable into every model, is guaranteed to give the correct answers to all CQs.</p><p>While CQs are a natural and well-studied class of queries, there are many other relevant forms of database queries that could be potentially be employed in OMQA. In the present paper, our focus will be on counting queries, which together with other forms of aggregate queries, are widely used for data analysis, yet still not well understood in the context of OMQA. A natural way to equip CQs with counting is to count the number of distinct query matches for each answer. As the count value may differ between models, <ref type="bibr" target="#b25">Kostylev and Reutter (2015)</ref> advocated a form of certain answer semantics that considers lower and upper bounds on the count value across different models. Their work provided the first investigation of the complexity of answering counting CQs in the presence of ontologies, revealing such queries to be much more challenging to handle than plain CQs: coNP-complete in data complexity for the well-known DL-Lite core and DL-Lite H core dialects. A recent work by <ref type="bibr" target="#b9">Bienvenu et al. (2020)</ref> refined and generalized the complexity results from Kostylev and Reutter to a wider class of counting queries and identified a restricted scenario with very low (TC 0 -complete) data complexity: rooted CQs coupled with DL-Lite core ontologies. A similar tractability result for connected rooted CQs was proven independently by <ref type="bibr">Calvanese et al. (2020a)</ref>, who also initiated a study of the impact of other restrictions on query shape and developed the first query rewriting procedure for counting CQs. Notably, both the aforementioned TC 0 result and the rewriting procedure crucially relied upon showing that the canonical model gives the right answers under the considered restrictions. We briefly mention two alternative approaches to counting queries: an epistemic semantics for aggregate queries (which only counts query matches over the data constants, ignoring unnamed elements) was explored by <ref type="bibr" target="#b14">Calvanese et al. (2008)</ref>, while another very recent study by <ref type="bibr" target="#b23">Feier et al. (2021)</ref> classifies the complexity of counting the number of certain answers (rather than the number of ways a certain answer is obtained) for guarded existential rules.</p><p>While recent studies have improved our understanding of the complexity of counting CQs, there nevertheless remain many unanswered questions. In this paper, we focus on Boolean atomic counting queries of the form ∃z.A(z) and ∃z 1 , z 2 .R(z 1 , z 2 ), which we term cardinality queries as they correspond to the natural task of determining (bounds on) the cardinality of a given concept or role name. The data complexity of answering such basic counting queries remains completely open for DL-Lite core ontologies, whilst for DL-Lite H core , the problem is known to be P-hard and in coNP <ref type="bibr">[Calvanese et al., 2020a]</ref>. The main results of our investigation are displayed in Table <ref type="table">1</ref>. We show that when ontologies are expressed in DL-Lite core , cardinality query answering is tractable in data complexity and enjoys the lower possible complexity (TC 0 -complete). For cardinality queries based upon a concept atom, TC 0 membership holds even for the fragment of DL-Lite H core obtained by disallowing negative role inclusions. By contrast, for role cardinality queries, we show that coNP-hard situations arise in DL-Lite H pos , which allows only positive concept and role inclusions. In fact, we obtain a complete data complexity classification for DL-Lite H pos , showing that every ontology-mediated query is either TC 0complete, coNP-complete, or is in P and logspace-equivalent to the complement of PERFECT MATCHING (whose precise complexity is a longstanding open problem). The preceding classification does not extend to DL-Lite H core : we identify new sources of coNP-hardness and further exhibit Lcomplete cases. We find it intriguing that such complex behaviour arises in what appears at first glance to be a simple OMQA setting. Moreover, in all of the tractable cases we identify, the canonical model may not yield the minimum cardinality, and query answering involves solving non-trivial optimization problems. This led us to devise an entirely new approach based upon exploring a space of strategies to find the optimal way of merging witnesses for existential axioms.</p><p>The paper is organized as follows. Section 2 recalls relevant background material and presents the considered OMQA setting. Section 3 introduces strategies and uses them to establish TC 0 membership. Our complexity classification for DL-Lite H pos is the topic of Section 4, while Section 5 presents our results for DL-Lite H core . Section 6 concludes with a brief discussion of related and future work.</p><p>An appendix with full proofs can be found in the long version of this paper, available on arXiv.</p><p>Table <ref type="table">1</ref>: Data complexity of cardinality queries based upon concept and role atoms for various DL-Lite dialects. † : upper bound holds for all DL-Lite H core ontologies without negative role inclusions.</p><p>Knowledge Bases. We assume mutually disjoint sets N C of concept names (unary predicates), N R of role names (binary predicates), and N I of individual names (constants). We denote by N ± R the set N R ∪ {R -| R ∈ N R } of role names and their inverses. A knowledge base (KB) K = (T , A) consists of an ABox (dataset) A and a TBox (ontology) T . An ABox is a finite set of concept assertions A(b) (with A ∈ N C , b ∈ N I ) and role assertions P(a, b) (with P ∈ N R , a, b ∈ N I ), while the TBox consists of a finite set of axioms, whose forms are dictated by the considered description logic.</p><p>In this paper, our focus will be on DL-Lite H core (alternatively referred to as DL-Lite R ), which is the logic underlying the OWL 2 QL profile. DL-Lite H core TBoxes contain four types of axioms: positive concept inclusions B 1 B 2 , negative concept inclusions B 1 ¬B 2 , positive role inclusions R 1 R 2 , and negative role inclusions R 1 ¬R 2 , where the B i and R i are positive concepts and roles given by:</p><formula xml:id="formula_0">B i := A | ∃R i R i : = P | P - (A ∈ N C , P ∈ N R )</formula><p>The sublogic DL-Lite core allows only concept inclusions (which may be either positive or negative), while DL-Lite H pos is restricted to positive (concept and role) inclusions. We denote by Ind(A) the set of individuals occurring in an ABox A. A signature is a finite set of concept and role names. Given a signature Σ, we denote by Σ ± C (resp. Σ ± R ) the set of positive concepts (resp. roles) built from Σ. The signature of a TBox T (resp. ABox A) is the set of concept and role names it contains, denoted sig(T ) (resp. sig(A)). To simplify the presentation, we will assume w.l.o.g. that sig(A) ⊆ sig(T ). Semantics of KBs. An interpretation takes the form I = (∆ I , • I ), where ∆ I is a non-empty set (called the domain) and • I is the interpretation function that maps each A ∈ N C to A I ⊆ ∆ I , each P ∈ N R to P I ⊆ ∆ I × ∆ I , and each a ∈ N I to a I . In this paper, we will make the Standard Names Assumption by setting a I = a. Note however that our results only rely upon the weaker Unique Names Assumption (UNA), which stipulates that a I = b I whenever a = b. The UNA is commonly adopted for DL-Lite KBs and enables more interesting reasoning in the context of counting queries.</p><p>The function • I is extended to general concepts and roles as follows:</p><formula xml:id="formula_1">(P -) I = {(e, d) | (d, e) ∈ P I }, (∃R) I = {d | (d, e) ∈ R I }, and (¬G) I = ∆ I \G I . An inclusion G H is satisfied in I if G I ⊆ H I ; an assertion A(b) (resp. P(a, b)) is satisfied in I if b ∈ A I (resp. (a, b) ∈ P I ).</formula><p>An interpretation is a model of a TBox T (resp. ABox A)) if it satisfies all axioms in T (resp. assertions in A), and it is a model of a KB K = (T , A) if it is a model of both T and A. A KB • a1  is satisfiable if it has at least one model. An inclusion (resp. assertion)</p><formula xml:id="formula_2">• a1 • a1T1 • a1T1S • • • • a2 • a2S • • • • a2S - • a2T2 • a2T2S • • • • b1 • b1S • • • • b1R1 • b1R1S • • • • b1R1S - • b2 • b2R2 • b2R2S • • • • b2R2S - R1 T 1 T 2 R 1 R 2 S S</formula><formula xml:id="formula_3">• α • a2 • b1 • b2 • β R1,S R2,S T 2 , S T 1 R 1 S S S S (b) Another model of Ke. • a1 • ⊥1 • a2 • b1 • b2 • ⊥2 R1 R2,S R 1 , S T 2 T 1 S S S<label>(</label></formula><formula xml:id="formula_4">Φ is entailed from T (resp. K), written T |= Φ (resp. K |= Φ), if Φ is satisfied in every model of T (resp. K). We use K |= ∃R(a) (resp. K |= R(a, b) with R ∈ N ± R ) to indicate a ∈ ∃R I (resp. (a, b) ∈ R I ) for every model I of K.</formula><p>Example 1. As a running example, we will consider the KB K e = (T e , A e ) whose TBox contains the following inclusions</p><formula xml:id="formula_5">A 1 ∃T 1 A 2 ∃T 2 ∃T - 1 ∃S ∃R - 1 ¬∃R - 2 B 1 ∃R 1 B 2 ∃R 2 ∃R - 1 ∃S -∃R - 1 ¬∃T - 1 ∃T - 2 ∃S ∃S -∃S ∃R - 2</formula><p>∃S - and whose ABox contains the assertions {A 1 (a 1 ), A 2 (a 2 ), B 1 (b 1 ), B 2 (b 2 ), R 1 (a 1 , a 2 ), S(b 2 , b 1 )} Two finite models of K e are displayed in Figures <ref type="figure" target="#fig_2">1b</ref> and<ref type="figure" target="#fig_2">1c</ref>. Canonical Model. Every satisfiable DL-Lite H core KB K = (T , A) has a canonical model C K , defined as follows. The domain of C K contains Ind(A) and all words aR 1 . . . R n , with a ∈ Ind(A), R i ∈ N ± R , and n 1, such that:</p><formula xml:id="formula_6">• K |= ∃R 1 (a) and there is no R 1 (a, b) ∈ A; • for 1 ≤ i &lt; n, T |= ∃R - i ∃R i+1 and R - i = R i+1 .</formula><p>Concept and role names are interpreted as follows:</p><formula xml:id="formula_7">A C K = {a ∈ Ind(A) | K |= A(a)} ∪ {aR 1 . . . R n ∈ ∆ C K \ Ind(A) | T |= ∃R - n A} P C K = {(a, b) | P(a, b) ∈ A} ∪ {(e 1 , e 2 ) | e 2 = e 1 R and T |= R P} ∪ {(e 2 , e 1 ) | e 2 = e 1 R and T |= R P -} We use gen K to refer to the set of generated roles, i.e. those R ∈ N ± R such that ∆ C K contains an element wR. Example 2. An initial portion of (the infinite) canonical model of K e is displayed in Figure 1a. Observe that gen K = {S, S -, R 1 , R 2 , T 1 , T 2 }.</formula><p>It is well known (see e.g. <ref type="bibr" target="#b12">[Calvanese et al., 2007]</ref>) that, for every model I of K, there is a homomorphism from C K to I, i.e. a function f :</p><formula xml:id="formula_8">∆ C K → ∆ I such that (i) f (a) = a for all a ∈ Ind, (ii) e ∈ A C K implies f (e) ∈ A I , and (iii) (d, e) ∈ P C K implies (f (d), f (e)) ∈ P I .</formula><p>Cardinality Queries. A cardinality query is either a concept cardinality query ∃z.C(z) or a role cardinality query ∃z 1 , z 2 .S(z 1 , z 2 ). Throughout the paper, we use q C (resp. q S ) as a shorthand for the cardinality query based upon C (resp. S). A match for a cardinality query q C (resp. q S ) in an interpretation I is an element of C I (resp. S I ). We define the answer to a cardinality query q in an interpretation I, denoted q I , as the number of matches of q in I, or equivalently, as the cardinality of F I , with F the concept or role name in q. A certain answer to q w.r.</p><formula xml:id="formula_9">t. K is an interval [m, M ] ∈ N × N such that q I ∈ [m, M ] for every model I of K.</formula><p>Example 3. Consider the role cardinality query q S . The answer to q S is +∞ in C Ke , 6 in the model from Figure <ref type="figure" target="#fig_2">1b</ref>, and 5 in the model from Figure <ref type="figure" target="#fig_2">1c</ref>. The latter implies that [6, +∞] is not a certain answer. We leave it is an exercise to find a model with 3 matches and show there is no model with fewer matches, which means that [m, +∞] is a certain answer to q S over K e if and only if m ≤ 3.</p><p>Cardinality queries as defined above correspond to a special case of the counting queries considered in <ref type="bibr" target="#b25">[Kostylev and Reutter, 2015;</ref><ref type="bibr" target="#b9">Bienvenu et al., 2020;</ref><ref type="bibr">Calvanese et al., 2020a]</ref>.</p><p>Observe that since DL-Lite H core cannot restrict the size of models, the value M in a certain answer [m, M ] must be +∞ whenever the query predicate F is satisfiable w.r.t. T (i.e. there is a model I of T such that F I = ∅). For this reason, we assume the latter condition holds and focus on identifying certain answers of the form [m, +∞]. Complexity. We will be interested in classifying the complexity of the following problem: OMQA(q, T ): Given A and an integer m ≥ 1 (in binary), decide whether [m, +∞] is a certain answer to q w.r.t. K.</p><p>where (q, T ) is an ontology-mediated query (OMQ) based upon a cardinality query q and a TBox T formulated in DL-Lite H core or one of its sublogics. Note that we are adopting the data complexity measure as (q, T ) is fixed.</p><p>Beyond well-known complexity classes such as P and coNP, we will refer to the following classes: TC 0 is the class of problems solvable by families of constant-depth polynomial-size circuits based upon AND, OR, NOT, and threshold gates, and L (resp. NL) is the class of problems solvable in deterministic (resp. nondeterministic) logarithmic space. It is known that: TC 0 ⊆ L ⊆ NL ⊆ ... ⊆ P ⊆ coNP.</p></div>
<div><head n="3">Tractable Cases</head><p>In this section, we identify two settings in which cardinality queries can be answered with the lowest possible complexity: Theorem 1. OMQA(q, T ) is TC 0 -complete if either (i) q is a role cardinality query and T a DL-Lite core TBox, or (ii) q is a concept cardinality query and T is a DL-Lite H core TBox without negative role inclusions.</p><p>The remainder of this section is devoted to establishing TC 0 membership for case (i) where our query is q S = ∃z 1 , z 2 .S(z 1 , z 2 ). A similar but simpler argument can be used for the membership half of case (ii), while TC 0hardness is easily shown by reduction from the TC 0 -complete NUMONES problem <ref type="bibr" target="#b0">[Aehlig et al., 2007]</ref> asking, given a binary string X and k ≥ 1, whether X contains at least k 1-bits.</p><p>Existing proofs of sub-polynomial data complexity for restricted classes of counting queries rely on the canonical model minimizing the number of matches <ref type="bibr" target="#b9">[Bienvenu et al., 2020;</ref><ref type="bibr">Calvanese et al., 2020a]</ref>. However, for the class of cardinality queries, the canonical model may not yield the minimum value. Therefore, we develop a different approach based upon a systematic exploration of a set of models that is guaranteed to contain an optimal model and whose size depends only on the TBox. This special set of models will be induced from strategies that dictate how to merge elements of the canonical model. To show such models contain the optimal value, we show that if we extract a strategy σ from an arbitrary model I and consider any model J induced by σ, then J has at most as many matches as the initial model I.</p><p>We now formalize this approach. In order to abstract from specific ABox individuals, we introduce types. Definition 1. A type for a TBox T is a subset of sig(T ) ± C . The set of all types is Θ T = 2 sig(T ) ± C . We denote by θ K (d) the type of a domain element d w.r.t. K and define it by: θ</p><formula xml:id="formula_10">K (d) = B ∈ sig(T ) ± C | K |= B(d) if d ∈ Ind(A), else θ K (d) = ∅. Example 4. In our running example, θ Ke (a 1 ) = {A 1 , ∃R 1 , ∃T 1 } and θ Ke (α) = ∅ (since α ∈ Ind(A e )).</formula><p>Strategies indicate for each generated role R the type onto which all elements wR should merge. Several copies of a type might be required to comply with negative inclusions (e.g. R 1 and R 2 associated to the same type but</p><formula xml:id="formula_11">T |= ∃R - 1 ¬∃R - 2 ). Definition 2. A strategy σ for the KB K is a function from gen K to Θ T × {1, . . . , sig(T ) ± R }, that satisfies: 1. ∀R ∈ gen K : σ(R) = (t, i) ∧ B ∈ t ⇒ T |= ∃R -¬B. 2. ∀R 1 , R 2 ∈ gen K : σ(R 1 ) = σ(R 2 ) ⇒ T |= ∃R - 1 ¬∃R - 2 . 3. ∀t ∈ Θ T , if t = ∅, then |{i | ∃R ∈ gen K , σ(R) = (t, i)}| ≤ |{a | a ∈ Ind(A) ∧ θ K (a) = t}|.</formula><p>Conditions 1 and 2 ensure that merging will not violate any negative inclusions. Condition 3 ensures the ABox provides at least as many individuals of a non-empty type as the strategy requires copies of this type.</p><p>Example 5. The following mapping σ e is a strategy for K e :</p><formula xml:id="formula_12">T 1 → (∅, 1) R 2 → ({B 1 , ∃R 1 , ∃S, ∃S -}, 1) T 2 → (∅, 2) S → (∅, 2) R 1 → (∅, 2) S -→ ({A 1 , ∃R 1 , ∃T 1 }, 1)</formula><p>To construct a model from a strategy σ, the basic idea is to merge elements wR with an element of type σ(R), with the latter selected according to a choice of well-typed elements: Definition 3. A mapping ch : gen K → Ind(A) {⊥ i | i = 1, . . . , sig(T ) ± R }, is a choice of well-typed elements for σ over K if it satisfies the following conditions:</p><formula xml:id="formula_13">1. ∀R ∈ gen K , ∃i such that σ(R) = (θ K (ch(R)), i) 2. ∀R 1 , R 2 ∈ gen K , ch(R 1 ) = ch(R 2 ) ⇔ σ(R 1 ) = σ(R 2 ).</formula><p>Example 6. The function ch e , defined as below, is a choice of well-typed elements for σ e over K e :</p><formula xml:id="formula_14">T 1 → ⊥ 1 T 2 → ⊥ 2 R 1 → ⊥ 2 R 2 → b 1 S → ⊥ 2 S -→ a 1</formula><p>It turns out however that when R = S or R = S -, it is useful to depart from this guideline in order to reduce the number of query matches, as this stand-alone example illustrates: Example 7. Consider T = {A ∃S, B ∃S -} and A = {A(a 1 ), A(a 2 ), B(b 1 ), B(b 2 )}. If we merge a 1 S with a 2 S, and b 1 S -with b 2 S -, then there will be at least three matches of q S , no matter which further merges are performed. However, by 'pairing' a 1 with b 1 and a 2 with b 2 , we can obtain a model with only two matches: (a 1 , b 1 ), (a 2 , b 2 ).</p><p>The next three definitions serve to identify the critical elements for which such a pairing operation is useful. Definition 4. We set</p><formula xml:id="formula_15">D + K = a | a ∈ Ind(A) ∧ aS ∈ ∆ C K and D - K = a | a ∈ Ind(A) ∧ aS -∈ ∆ C K . Definition 5. Given a strategy σ, we set D + σ = {R | R ∈ dom(σ) \ {S, S -} ∧ T |= ∃R - ∃S ∧ ∃S / ∈ t if σ(R) = (t, k)} and D - σ = {R | R ∈ dom(σ)\{S, S -}∧T |= ∃R - ∃S -∧ ∃S -/ ∈ t if σ(R) = (t, k)}. Definition 6.</formula><p>Let ch be a choice of well-typed elements for σ. We set crit + = D + K ∪ ch(D + σ ) and crit -= D - K ∪ ch(D - σ ) and use critical elements to refer to the elements of these sets. Example 8. For σ e and ch e as defined in Examples 5 and 6, we have crit</p><formula xml:id="formula_16">+ = {a 2 , b 1 , ⊥ 1 , ⊥ 2 } and crit -= {a 2 , ⊥ 2 }.</formula><p>Intuitively, a pairing matches critical elements from crit + (which require an outgoing S) with those from crit -(which require an incoming S). Definition 7. A pairing for ch and σ consists of two partial functions p + : crit + → crit -and p -: crit -→ crit + such that one of the functions is total and injective, and the other is its partial inverse. Example 9. A pairing for ch e and σ e is given by p</p><formula xml:id="formula_17">+ e = {a 2 → a 2 , b 1 → ⊥ 2 } and p - e = {a 2 → a 2 , ⊥ 2 → b 1 }.</formula><p>We are now ready to define the interpretation of a strategy. Definition 8. Consider a strategy σ, choice of well-typed elements ch, and pairing (p + , p -) for ch. For every R ∈ sig(T ) ± R , pick a function s R that maps every individual in</p><formula xml:id="formula_18">{a | K |= R(a, b) for some b ∈ N I } to an individual s R (a) such that K |= R(a, s R (a)</formula><p>). Define function χ as follows:</p><formula xml:id="formula_19">∆ C K → Ind(A) ∪ {⊥ i | i = 1, . . . , sig(T ) ± R } a → a wS → s S (χ(w)) if s S (χ(w)) is defined p + (χ(w)) else if p + (χ(w)) is defined ch(S) otherwise wS -→    s S -(χ(w)) if s S -(χ(w)) is defined p -(χ(w)) else if p -(χ(w)) is defined ch(S -) otherwise wR → ch(R)</formula><p>The interpretation of σ (according to ch, (p + , p -) and the s R ) has domain χ(∆ C K ) and interpretation function χ </p><formula xml:id="formula_20">χ(b 2 R 2 ) = ch(R 2 ) = b 1 , χ(b 2 R 2 S) = p + e (b 1 ) = ⊥ 2 , and χ(b 2 R 2 S -) = s S -(b 1 ) = b 2 (</formula><p>observe that on our example, the function s S -is uniquely defined, and the same is true for the other roles). Figure <ref type="figure" target="#fig_2">1c</ref> displays the interpretation of σ e .</p><p>Observe that the interpretation of a strategy σ depends not only on σ but also on the functions ch, p + , p -, s R . Importantly, however, the key property of such interpretations (stated in Lemma 1 later in this section) holds for any particular choice of these functions.</p><p>It remains to prove that a model minimizing the number of matches can be found among the interpretations of strategies. The first step is to to extract a strategy from a model. Definition 9. Let I be a model of K, f : C K → I be a homomorphism, and repr be a function mapping each role R ∈ gen K to an element with shape wR from ∆ C K . Then P = {P 1 , . . . , P k }, defined by</p><formula xml:id="formula_21">{P 1 , . . . , P k } = {(f • repr) -1 (w) | w ∈ ∆ I } \ {∅}</formula><p>is a partition of gen K . The strategy extracted from I (for f and repr) is defined as:</p><formula xml:id="formula_22">gen K → Θ T × {1, . . . , sig(T ) ± R } R → ((θ K • f • repr)(R), i) with R ∈ P i</formula><p>Example 11. In our running example, there is a unique homomorphism f e from C Ke to the model displayed in Figure <ref type="figure" target="#fig_2">1b</ref>. Let repr e be:</p><formula xml:id="formula_23">T 1 → a 1 T 1 R 2 → b 2 R 2 T 2 → a 2 T 2 S → b 1 SSS R 1 → b 1 R 1 S -→ a 2 S -</formula><p>The strategy extracted from this model (for f e and repr e ) is the strategy provided in Example 5.</p><p>By applying the next lemma to a model I having the fewest possible number of matches, we obtain the desired conclusion: there is a model minimizing the number of matches among the models obtained by interpreting a strategy. Lemma 1. Let I be a model of K, and J an interpretation of a strategy extracted from I. J is a model of K and q J S ≤ q I S . We now sketch how to construct a family of TC 0 circuits (one for each size of ABox) to decide OMQA(q S , T ). Each such circuit first computes the set gen K and the type of each ABox individual. Next, for each function : gen K → Θ T × {1, . . . , sig(T ) ± R } satisfying Conditions 1 and 2 of Definition 2, the circuit decides whether is a strategy for K (i.e. Condition 3 holds), and if so, computes the number of matches of q S in interpretations induced by . Importantly, this can be done without actually building interpretations: in the appendix we give an explicit formula for this number and show it can be computed with a TC 0 circuit. Moreover, the number of strategies depends only on |T |, so is constant w.r.t. data complexity. Finally, the circuit computes the minimum value across strategies and compares it with the input number.</p><p>4 Complexity Classification for DL-Lite H pos In this section, we consider DL-Lite H pos TBoxes. We show that coNP-hard OMQs exist and prove a complexity trichotomy which precisely delineates the tractability boundary.</p><p>We begin by exhibiting a coNP-complete 1 situation.</p><formula xml:id="formula_24">Example 12. OMQA(q S , {B ∃R 1 , R 1 S, ∃R - 1 ∃R 2 , R 2 S}) is coNP-complete.</formula><p>We consider the NPcomplete SET COVER problem: given a set U, set of subsets S ⊆ 2 U whose union is U, and number k, decide whether there exists a k-cover, i.e. a subset C of S with |C| ≤ k whose union is U. We prove that there exists a k-cover iff</p><formula xml:id="formula_25">[Σ s∈S |s| + k + 1, +∞] is not a certain answer on the follow- ing ABox: {B(u) | u ∈ U} ∪ {S(u, s) | u ∈ s, s ∈ S}. Intu- itively, from a k-cover C</formula><p>, we obtain a countermodel in which role R 1 contains pairs (u, s) such that u ∈ s and s ∈ C, and there is one outgoing R 2 role from each s ∈ C.</p><p>The following definition abstracts the preceding example. Definition 10. A TBox T admits a propagation of role W by a concept B ∈ sig(T</p><formula xml:id="formula_26">) ± C and roles R 1 , R 2 if T entails {B ∃R 1 , R 1 W, ∃R - 1 ∃R 2 , R 2 W}.</formula><p>A propagation of S (or S -) is not sufficient to ensure coNPhardness: the reduction sketched in Example 12 will fail in the presence of 'interferences', which can be of three types. Definition 11. A role U interferes with the propagation of W by B, R 1 , R 2 if it satisfies one of the following conditions:</p><formula xml:id="formula_27">1. T |= {B ∃U, U W, U W -}; 2. T |= {∃W - ∃U, U W} and either T |= U W - or T |= R 2 W -; 3. if B = ∃T and T W, then T |= {∃T -∃U, U W} and either T |= U W -or T |= R 2 W -.</formula><p>Remarkably, the existence of a propagation without any interfering role (which we call a non-trivial propagation) ensures coNP-hardness, while its absence ensures that OMQA(q S , T ) is in P. We further distinguish two tractable cases, depending on the existence of a non-trivial pairing. Definition 12. A TBox T admits a non-trivial pairing of S if there exist B ∈ sig(T</p><formula xml:id="formula_28">) ± C and R ∈ sig(T ) ± R such that T |= B ∃R T |= R S T |= R S -T |= S S - and if B = ∃T, then either T |= T S or T |= T S -.</formula><p>1 A P upper bound for atomic counting queries in DL-Lite H pos erroneously appears in Table <ref type="table">1</ref> of <ref type="bibr">[Calvanese et al., 2020a]</ref>, but was corrected in a later arXiv version <ref type="bibr">[Calvanese et al., 2020b]</ref>.</p><p>To formulate our trichotomy result, we recall that a matching in a graph (V, E) is a set of edges that are pairwise vertexdisjoint. The PERFECT MATCHING problem (abbreviated to PM) asks whether there exists a matching such that every vertex is incident to one of its edges. Despite being the focus of intensive research, its exact complexity remains open: in P <ref type="bibr">[Edmonds, 1965]</ref> and NL-hard <ref type="bibr" target="#b17">[Chandra et al., 1984]</ref>.</p><p>Theorem 2. Let T be a DL-Lite H pos TBox. OMQA(q S , T ) is coNP-complete if T admits a non-trivial propagation of either S or S -, is L-equivalent to the complement of PM if it does not admit such a non-trivial propagation but admits a non-trivial pairing of S, and is in TC 0 otherwise.</p><p>Proof sketch. The coNP-hardness proof generalizes the reduction sketched in Example 12. If there is a non-trivial pairing (but no non-trivial propagation), we show that, up to trivial cases solvable in TC 0 , the existence of a model with few matches is equivalent to the existence of a large matching between critical individuals. This yields L-equivalence with the MAXIMUM MATCHING decision problem, which is L-equivalent to the better-known PM problem <ref type="bibr" target="#b29">[Rabin and Vazirani, 1989]</ref>. TC 0 membership is proven by case analysis, where we exhibit for each case a model with an optimal (and easily computable) number of matches.</p><p>5 First Look at DL-Lite H core We now turn to DL-Lite H core and exhibit new situations that are not captured by the preceding complexity classification.</p><p>First, we observe that negative concept and role inclusions introduce two new sources of coNP-hardness. Theorem 3.</p><formula xml:id="formula_29">For T = {B ∃U, U S, C ∃V, V S, ∃U -¬∃V -}, OMQA(q S , T ) is coNP-complete.</formula><p>Proof sketch. Let (U, S, k) be an instance of SET COVER, and consider the ABox</p><formula xml:id="formula_30">A = {B(u) | u ∈ U } ∪ {S(u, s * ) | u ∈ s, s ∈ S} ∪ {C(s) | s ∈ S} ∪ {S(s, s * ) | s ∈ S}. It can be shown that no k-cover exists iff every model of (T , A) has at least |S| + s∈S |s| + k + 1 matches. Theorem 4. For T = { B ∃U, U S, ∃U -∃V, V S -, V ¬W }, OMQA(q S , T ) is coNP-complete.</formula><p>Perhaps more surprising, we show that there exist coNPhard OMQs based upon concept cardinality queries. Theorem 5.</p><formula xml:id="formula_31">For T = {A ∃U, ∃U -C, U ¬U , B ∃V, ∃V -C, V ¬V , ∃U -¬∃V -}, OMQA(q C , T ) is coNP-complete.</formula><p>Proof sketch. Hardness is shown by reducing the tautology problem. Three individuals are introduced per propositional variable (one for the variable itself with concept A, two for its possible truth values), as well as one individual per clause (with concept B). Each variable should have a truth value given by U (whose possible values in the ABox are restricted through the use of U ), and each clause should have a falsified literal given by V (whose possibles values in the ABox are restricted, according to the input formula, with V ). The input formula is a tautology iff every model introduces a new element marked C (as a witness for either ∃U or ∃V).</p><p>Moreover, we further show that L-complete OMQs exist. The next result employs a role cardinality query, but a similar result can be obtained using a concept cardinality query. Theorem 6.</p><formula xml:id="formula_32">For T = { B ∃R, R S, R ¬R -}, OMQA(q S , T ) is L-complete.</formula><p>Proof. Hardness is by reduction from the L-complete problem UNDIRECTED FOREST ACCESSIBILITY (UFA) <ref type="bibr" target="#b19">[Cook and McKenzie, 1987]</ref>, which takes as input an undirected acyclic graph (V, E) with two connected components, vertices s, t ∈ V, and asks if t is reachable from s. We set</p><formula xml:id="formula_33">A = {B(u) | u ∈ V} ∪ {S(u, v) | {u, v} ∈ E} ∪ {S(s, v * ), S(t, v * )} ∪ {R(s, v * ), R(t, v * )} and observe that ((V, E), s, t) ∈ UFA iff [2|E| + 3, +∞]</formula><p>is a certain answer. Indeed, there are 2|E| + 2 matches in the ABox, and a further match arises if we add R-atoms to satisfy B ∃R in a connected component that contains neither s nor t (such a match can be avoided if it contains s or t). For the upper bound, we characterize the minimum number of matches based upon the graph structure of the ABox and show it can be computed in L, by using an oracle for undirected reachability.</p><p>Our results imply that, under standard complexity-theoretic assumptions, at least four different complexities are possible for cardinality queries coupled with DL-Lite H core ontologies.</p></div>
<div><head n="6">Conclusion</head><p>In this paper, we investigated the complexity of answering cardinality queries in the presence of DL-Lite ontologies.</p><p>Our study provides several novel insights into the challenge of adopting counting queries in OMQA. On the one hand, we identified new sources of coNP-hardness, showing that even single-atom counting queries can be difficult to handle (which closes some questions about restricted forms of counting queries left open in <ref type="bibr">[Calvanese et al., 2020a]</ref>). On the other hand, we exhibited several settings in which cardinality queries can be answered with (sub-)polynomial data complexity; in particular, the problem is in TC 0 when the ontology is formulated in DL-Lite core . Interestingly, our tractability results do not rely on the canonical model yielding the minimum number of matches, but instead involve a sophisticated analysis of how to best merge witnesses for existential axioms. Differently from <ref type="bibr" target="#b25">[Kostylev and Reutter, 2015;</ref><ref type="bibr">Calvanese et al., 2020a;</ref><ref type="bibr" target="#b9">Bienvenu et al., 2020]</ref>, we conducted our complexity analysis on the level of ontology-mediated queries, and notably obtained a full classification of the complexity of OMQs based upon DL-Lite H pos ontologies. We find it promising that very low data complexity can be obtained even for settings in which non-trivial optimization is required, and we plan to explore how to extend and adapt our techniques to identify further tractability results for counting queries. Another important topic for future work is to transform our TC 0 procedures into more practical algorithms that are suitable for implementation on top of database systems.</p><p>A Proof of Theorem 1.</p><p>Theorem 1 will be proven in stages. First, we will give the proof of TC 0 membership for the case where q is a role cardinality query and T a DL-Lite core TBox (Appendix A.1), and show how to adapt it to the case where q is a concept cardinality query and T is a DL-Lite H core TBox without negative role inclusions (Appendix A.2). The TC 0 lower bound is given in Appendix A.3. To prepare for the membership proofs in A.1 and A.2, we give some additional technical preliminaries and insights that are relevant for both proofs.</p><p>We first slightly modify the notion of strategy as defined in Definition 2, by splitting it into a more ABox-independent notion of strategy (Definition 13), coupled with a notion of legal strategy for a particular K (Definition 14). This enables us to speak about the underlying set of abstract strategies we will explore (which depends only on the TBox), among which only some strategies are relevant, that is legal, for a particular ABox.</p><p>Definition 13 (Strategy). A strategy σ for the TBox T is a partial function from sig(T ) ± R to Θ T × {1, . . . sig(T ) ± R }, satisfying the following two conditions:</p><formula xml:id="formula_34">1. Type compatibility: ∀R ∈ dom(σ) : σ(R) = (t, i) ∧ B ∈ t ⇒ T |= ∃R -¬B. 2. Pseudo-injectivity: ∀R 1 , R 2 ∈ dom(σ), σ(R 1 ) = σ(R 2 ) ⇒ T |= ∃R - 1 ¬∃R -</formula><p>2 . We denote by dom(σ) the subset of sig(T ) ± R on which σ is defined. Definition 14 (Legal strategy). Let A be an ABox and K := (T , A). A strategy σ for T is legal for K if it satisfies the following two conditions:</p><formula xml:id="formula_35">1. Coverage: gen K = dom(σ) 2. Availability: ∀t ∈ Θ T \ {∅}, |{i | ∃R ∈ gen K , σ(R) = (t, i)}| ≤ a a ∈ Ind(A) θ K (a) = t .</formula><p>Note that legal strategies from the preceding definition correspond precisely to the strategies of Definition 2. We further introduce the following useful lemma, stating that a choice of well-typed elements for a strategy σ extracted from a model provides, as one would expect, elements with the same type as those used in the first place to extract the strategy σ.</p><p>Lemma 2 (Properties of extracted strategies). Let A be an ABox and K := (T , A). Let repr K be a function mapping each role R ∈ gen K to an element with shape wR from ∆ C K . Let I be a model of K, and let f : C K → I be a homomorphism. Let ch be a choice of well-typed elements for σ f •repr K over A. The strategy σ f •repr K extracted from I (for f and repr K ) preserves both:</p><formula xml:id="formula_36">1. ∀R ∈ gen K , θ K (ch(R)) = θ K (f (repr K (R))) 2. ∀R, T ∈ gen K , ch(R) = ch(T) ⇔ f (repr K (R)) = f (repr K (T)) Proof. 1. Let R ∈ gen K . By definition of σ f •repr K , there exists i ∈ {1, . . . |sig(T )|} such that σ f •repr K (R) = ((θ K • f • repr K )(R), i) with R ∈ P i . From Condition 1 of Definition 3, we get σ f •repr K (R) = (θ K (ch(R)), i), which gives the desired equality of types. 2. From Condition 2 of Definition 3, ch(R) = ch(T) iff σ f •repr K (R) = σ f •repr K (T). If f (repr K (R)) = f (repr K (T)),</formula><p>then by the definition of the extracted strategy, we have</p><formula xml:id="formula_37">σ f •repr K (R) = σ f •repr K (T), so we are done. Conversely, if ch(R) = ch(T), then σ f •repr K (R) = σ f •repr K (T).</formula><p>This implies in particular that R and T belong to the same P i , hence</p><formula xml:id="formula_38">f (repr K (R)) = f (repr K (T)).</formula><p>We extend the functions s R from Definition 8 as follows and introduce terminology to speak about such functions.</p><p>Definition 15 (Certain successor preference, successor preference). The family of functions (s R ) R from Definition 8 is called a certain successor preference and will also be denoted (succ K R ) R . For a given interpretation I, a family of functions</p><formula xml:id="formula_39">(succ I R ) R mapping an element d ∈ (∃R) I to an element e ∈ ∆ I such that (d, e) ∈ R I is a successor preference in I.</formula><p>Finally, before diving into the details of the proof, we give an idea for why this OMQA setting requires such an involved construction. Recall that our construction involves exploring a set of strategies, whose size is constant w.r.t data complexity. In the end, we prove that for each KB, there exists some best strategies among this set, which provide the minimum amount of matches. One might ask, starting from our input KB, why don't we simply exhibit one of these best strategies, instead of exploring all possible ones? First, this is due to the set of legal strategies varying according to the ABoxes: deciding if a given strategy is legal already requires computing statistics on the input ABox (see both conditions from Definition 14). Furthermore, even with a fixed ABox, deciding if a legal strategy is "the best" is in general a coNP-complete problem w.r.t the TBox. This is formalized by the following two results which concern single-individual ABoxes.</p><p>Theorem 7. Given a DL-Lite core TBox T and an integer m, deciding if [m, +∞] is a certain answer to q := ∃z 1 , z 1 .S(z 1 , z 2 ) over K := (T , {A(a)}) is coNP-complete.</p><p>Proof. Let G := (V, E) be an undirected graph. Consider the TBox given by:</p><formula xml:id="formula_40">T G := v∈V {A ∃V, ∃V -∃S} ∪ {v1,v2}∈E {∃V - 1 ¬∃V - 2 }. It is easily verified that G ∈ 3COL ⇐⇒ [4, +∞] / ∈ q K G for K G := (T G , {A(a)})</formula><p>, where 3COL is the well-known NP-complete problem of determining if a graph has a 3-colouring.</p><p>An analogous statement holds for concept cardinality queries. Theorem 8. Given a DL-Lite core TBox T and an integer m, deciding if [m, +∞] is a certain answer for q := ∃z.C(z) over</p><formula xml:id="formula_41">K := (T , {A(a)}) is coNP-complete.</formula><p>Proof. Let G := (V, E) be an undirected graph. Consider the TBox given by:</p><formula xml:id="formula_42">T G := v∈V {A ∃V, ∃V -C} ∪ {v1,v2}∈E {∃V - 1 ¬∃V - 2 }.</formula><p>We have</p><formula xml:id="formula_43">G ∈ 3COL ⇐⇒ [4, +∞] / ∈ q K G for K G := (T G , {A(a)}).</formula><p>A.1 Proof of Theorem 1.i: Role Cardinality Queries and DL-Lite core .</p><p>We prove TC 0 membership for OMQA based upon a DL-Lite core TBox T and a role cardinality query q S .</p><p>Proof of Lemma 1.</p><p>We first prove the first point of Lemma 1, stating the interpretation of a strategy extracted from a model is also a model, in the following stronger form, which does not require the strategy to be extracted from a model in the first place. Lemma 3. Let A be an ABox and K := (T , A) a satisfiable KB. Let (succ K R ) R be a certain successor preference. Let σ be a legal strategy for K. Let ch be a choice of well-typed elements for σ over K. Let p := (p + , p -) be a pairing for ch and σ. Then the interpretation J of σ (according to ch, p, and</p><formula xml:id="formula_44">(succ K R ) R ) is a model. Proof.</formula><p>Assertions from the ABox and positive inclusions from T are satisfied since the interpretation J is built from C K . Indeed, suppose that B C ∈ T and d ∈ B J . Then from the definition of J , there exists w  </p><formula xml:id="formula_45">∈ ∆ C K such that w ∈ B C K and d = χ(w). Since C K satisfies B C, we have w ∈ C C K . If C ∈ N C , this immediately gives d ∈ C J . If C = ∃R, there exists w such that (w, w ) ∈ R C K ,</formula><formula xml:id="formula_46">(a) If d = succ K R (χ(w)) with R ∈ {S, S -}, then R(χ(w), d) ∈ A, contradicting K |= B(d). (b) If d = p + (χ(w)) with R = S, then in particular d ∈ crit - ch . • If d ∈ D - K , then it contradicts K |= B(d). • If d = ch(R 0 ) with R 0 ∈ D - σ , then in particular T |= ∃R - 0 ∃S -. i. If d = succ K T (χ(w )) with T ∈ {S, S -}, then it contradicts K |= C(d).</formula><p>ii. In order to prove the second point of Lemma 2, stating that the interpretation J of the strategy extracted from a model I has at most as many matches as the initial model I, we need to understand which pairs appear in the role of interest S in an interpretation of our strategy. This is is the purpose of the following result. Lemma 4 (Matches in a model interpreting a strategy). Let A be an ABox and K := (T , A). Let (succ K R ) R be a certain successor preference. Let σ be a legal strategy for K. Let ch be a choice of well-typed elements for σ over K. Let p := (p + , p -) be a pairing for ch. Denote by J the interpretation of σ (according to ch, p, and</p><formula xml:id="formula_47">If d = p + (χ(w )) with T = S, then T |= ∃S -¬∃S -. Contradiction. iii. If d = p -(χ(w )) with T = S -, in particular d ∈ crit + ch . -If d ∈ D + K then it contradicts K |= C(d). -If d = ch(T 0 ) with T 0 ∈ D + σ ,</formula><formula xml:id="formula_48">(succ K R ) R ) S J = {(a, b) | K |= S(a, b) } (Shape 1) ∪ (x, y) (x, y) ∈ crit + ch × crit - ch p + (x) = y (Shape 2) ∪ (x, ch(S)) x ∈ crit + ch \ dom(p + ) (Shape 3 + ) ∪ (ch(S -), y) y ∈ crit - ch \ dom(p -) (Shape 3 -) ∪      (ch(S), ch(S)) crit + ch &gt; crit - ch T |= ∃S -∃S ∃S / ∈ θ K (ch(S)) ch(S) / ∈ ch(D + σ )      (Shape 4 + ) ∪      (ch(S -), ch(S -)) crit - ch &gt; crit + ch T |= ∃S ∃S - ∃S -/ ∈ θ K (ch(S -)) ch(S -) / ∈ ch(D - σ )      (Shape 4 -)</formula><p>Notice there can be no overlap between two distinct shapes and that shapes with opposite superscripts cannot coexist.</p><p>Proof. The first inclusion (⊆) is rather straightforward. We focus on the other way around.</p><p>(⊇) We consider each of the shapes in turn and show their elements belong to S J . </p><formula xml:id="formula_49">1. Let (a, b) such that K |= S(a, b). Therefore (a, b) ∈ C K . By definition: χ(a) = a and χ(b) = b, hence (a, b) ∈ S J . 2. Let (x, y) such that (x, y) ∈ crit + ch × crit - ch and p + (x) = y. Distinguish two cases based on x ∈ crit + ch : • If x ∈ D + K . By definition, we must have x ∈ Ind(A), so χ(x) = x. Moreover, xS ∈ C K , hence succ K S (x) is not defined. Together with x ∈ dom(p + ), this gives χ(xS) = p + (x). Since (x, xS) ∈ S C K , we have (x, p + (x)) ∈ S J . • If x = ch(R) with R ∈ D + σ . By definition of gen K , there exists wR ∈ C K . Since R / ∈ {S, S -}, we have χ(wR) = ch(R). From R ∈ D + σ , we know that T |= ∃R -∃S, which ensures wRS ∈ ∆ C K . The definition of D + σ further tells us that ∃S / ∈ θ K (ch(R)). As χ(wR) = x ∈ dom(p + ), we must have χ(wRS) = p + (x). Finally (wR, wRS) ∈ S C K ensures (x, p + (x)) ∈ S J . 3 + . Let (x, ch(S)) such that x ∈ crit + ch \ dom(p + ). Distinguish two cases based on x ∈ crit + ch : • If x ∈ D + K . By definition x ∈ Ind(A), so χ(x) = x. Moreover, xS ∈ C K , hence succ K S (x) is not defined. Combined with x / ∈ dom(p + ), we obtain χ(xS) = ch(S). Since (x, xS) ∈ S C K , we have (x, ch(S)) ∈ S J . • If x = ch(R) with R ∈ D + σ . By definition of gen K , there exists wR ∈ ∆ C K . Since R / ∈ {S, S -}, it gives χ(wR) = ch(R). The hypothesis T |= ∃R -∃S ensures wRS ∈ ∆ C K . Since ∃S / ∈ θ K (ch(R)) and χ(wR) = x / ∈ dom(p + ), it gives χ(wRS) = ch(S). Finally (wR, wRS) ∈ S C K ensures (x, ch(S)) ∈ S J . 3 -. Symmetric to Case 3 + . 4 + . Let (ch(S), ch(S)) with crit + ch &gt; crit - ch , T |= ∃S - ∃S, ∃S / ∈ θ K (ch(S)) and ch(S) / ∈ ch(D + σ ). Because of crit + ch &gt; crit - ch ,</formula><formula xml:id="formula_50">(ch(S), ch(S)) ∈ S J . • If x = ch(R) with R ∈ D + σ .</formula><p>By definition of gen K , there exists wR ∈ ∆ C K . From R ∈ D + σ , we have R / ∈ {S, S -}, which gives χ(wR) = ch(R). Moreover, we also have that T |= ∃R -∃S, which ensures wRS ∈ ∆ C K . Since ∃S / ∈ θ K (ch(R)) and χ(wR) = x / ∈ dom(p + ), we have χ(wRS) = ch(S). Furthermore, we assumed ∃S / ∈ θ K (ch(S)) and ch(S) / ∈ ch(D + σ ), ensuring in particular ch(S) / ∈ crit + ch . Hence χ(wRSS) = ch(S). We conclude by using (wRS, wRSS) ∈ S C K to infer (ch(S), ch(S)) ∈ S J . 4 -. Symmetric to Case 4 + .</p><p>We next need to understand how to relate the elements of J with the elements of the original model I. In particular, we are interested in critical elements, which motivates the following definition. Definition 16 (Origin of critical elements). Let A be an ABox and K := (T , A). Let repr K be function mapping each role R ∈ gen K to an element with shape wR from ∆ C K . Let I be a model of K and f : C K → I be a homomorphism. Let σ be the strategy extracted from I (for f and repr K ). Let ch be a choice of well-typed elements for σ over K. The origins of critical elements are given by: ori</p><formula xml:id="formula_51">+ : crit + ch → ∆ I x → x if x ∈ D + K f (repr K (R)) if x = ch(R) with R ∈ D + σ ori -: crit - ch → ∆ I y → y if y ∈ D - K f (repr K (T)) if y = ch(T) with T ∈ D - σ</formula><p>Notice the second point in Lemma 2 ensures that ori + , resp. ori -, is well defined, that is, it does not depend on the choice of the role R, resp. T.</p><p>Observe that this way of associating critical elements with elements of the original model is injective. Lemma 5. The functions ori + and ori -as defined in Definition 16, are injective.</p><p>Proof. Let x, x ∈ crit + ch such that ori + (x) = ori + (x ). We consider the four possible cases.</p><formula xml:id="formula_52">1. Suppose x ∈ D + K . (a) Suppose x ∈ D + K . Trivial: x = ori + (x) = ori + (x ) = x . (b) Suppose x = ch(R ) with R ∈ D +</formula><p>σ . On the one hand, statement 1 from Lemma 2 ensures θ K (x ) = θ K (f (repr K (R )). Since by our assumptions we have</p><formula xml:id="formula_53">x = ori + (x) = ori + (x ) = f (repr K (R ), we get θ K (x) = θ K (f (repr K (R )), hence θ K (x ) = θ K (x). Since x ∈ D + K , this means in particular that ∃S ∈ θ K (x ).</formula><p>On the other hand, ch must satisfy Condition 1 of the definition of choice of well-typed elements, so σ(R ) = (θ K (x ), i) for some i. However, from R ∈ D + σ , we have that ∃S / ∈ θ K (x ), a contradiction.</p></div>
<div><head n="2.">Suppose</head><formula xml:id="formula_54">x = ch(R) with R ∈ D + σ . (a) Suppose x ∈ D + K . Symmetric to Case 1.b. (b) Suppose x = ch(R ) with R ∈ D + σ . Then θ K (f (repr K (R)) = θ K (f (repr K (R )). Statement 2 from Lemma 2 yields ch(R) = ch(R ), hence x = x.</formula><p>Therefore, ori + is injective. The argument for ori -is symmetric.</p><p>We are now ready to prove the second point of Lemma 1, which is formulated in full detail in the following statement. Lemma 6. Let A be an ABox and K := (T , A). Let repr K be function mapping each role R ∈ gen K to an element with shape wR from ∆ C K . Let I be a model of K and f : C K → I be a homomorphism. Let σ be the strategy extracted from I (for f and repr K ). Let ch be a choice of well-typed elements for σ over K. Let p be a pairing for ch. Denote by J the model resulting from interpreting the strategy σ (according to ch, p, and any certain successor preference). Then we have:</p><formula xml:id="formula_55">q J S ≤ q I S .</formula><p>Proof. In the following, assume crit + ch ≥ crit - ch so that the only possible shapes for matches are 1, 2, 3 + and 4 + . The case crit - ch &gt; crit + ch with possible shapes 1, 2, 3 -and 4 -is symmetrical. Pick some successor preference (succ I R ) R for I (refer back to Definition 15). We associate with each match π of q S in J a match ρ(π) in I depending on the shape of π: ρ(π) :</p><formula xml:id="formula_56">     (a, b) if π = (a, b) is of Shape 1 (ori + (x), succ I S (ori + (x))) if π = (x, y) is of Shape 2 or 3 + (f (repr K (S)), succ I S (f (repr K (S)))) if π = (ch(S), ch(S)) is of Shape 4 +</formula><p>Notice that in all cases ρ(π) is indeed a match in I. This is obvious if π is of Shape 1. When π of Shape 2 or 3 + , ori + (x) is an element of ∆ I that possesses an S-successor, so succ I S (ori + (x)) is well defined, and we have ρ(π) = (ori + (x), succ I S (ori + (x))) ∈ S I . Finally, if π is of Shape 4 + , this means T |= ∃S - ∃S, succ I S (f (repr K (S)))) is well defined, and (f (repr K (S)), succ I S (f (repr K (S)))) ∈ S I . Now we prove that ρ is injective. Consider two matches π 1 , π 2 of q S in J such that ρ(π 1 ) = ρ(π 2 ). We will use π</p><formula xml:id="formula_57">1 [1], π 1 [2]</formula><p>to refer to the first and second arguments of π 1 , and similarly for π 2 . We consider all nine cases, showing in each case that either the situation cannot occur or that π 1 = π 2 :</p><p>1. 1. When π 1 , π 2 are both of Shape 1, we have</p><formula xml:id="formula_58">π 1 = ρ(π 1 ) = ρ(π 2 ) = π 2 . 2, 3 + . π 1 = (a, b) is of Shape 1, so π 1 = ρ(π 1 ), while π 2 = (x, y) is of Shape 2 or 3 + , which implies that x ∈ crit + ch . • If x ∈ D + K , then ρ(π 2 )[1] = ori + (x) = x. It follows that ρ(π 1 )[1] = a = x. But a / ∈ D + K since S(a, b) ∈ A, which is a contradiction. • If x = ch(R) with R ∈ D + σ , then in particular ∃S / ∈ θ K (ch(R)). Lemma 2 tells us that θ K (ch(R)) = θ K (f (repr K (R))). We also have ori + (x) = f (repr K (R)), so ρ(π 2 )[1] = f (repr K (R)). From ρ(π 1 ) = ρ(π 2 )</formula><p>we get a = f (repr K (R)). Putting this together, we get ∃S / ∈ θ K (a), which contradicts S(a, b) ∈ A. 4 + . In particular ∃S / ∈ θ K (ch(S)) and ρ(π</p><formula xml:id="formula_59">2 )[1] = f (repr K (S)). Lemma 2 provides θ K (ch(S)) = θ K (ρ(π 2 )[1]). Recall π 1 = ρ(π 1 ) = (a, b) and ρ(π 1 ) = ρ(π 2 ), hence ∃S / ∈ θ K (π 1 [1]</formula><p>). Contradiction with S(a, b) ∈ A.</p><p>2, 3 + . 1. Symmetric to Case 1.(2, 3 + ). 2, 3 + . As both π 1 and π 2 are of Shapes 2 / 3 + , we have ori</p><formula xml:id="formula_60">+ (π 1 [1]) = ori + (π 2 [1]</formula><p>). We can apply Lemma 5 to obtain</p><formula xml:id="formula_61">π 1 [1] = π 2 [1]</formula><p>. By examining the conditions of Shapes 2 and 3 + , we can see that π 1 and π 2 must have the same shape, and moreover, their second arguments must coincide, yielding</p><formula xml:id="formula_62">π 1 = π 2 . 4 + . As π 1 = (x, y) is of Shape 2 / 3 + , we have x = π 1 [1] ∈ crit + ch . As π 2 = (ch(S), ch(S)) is of Shape 4, we have T |= ∃S -∃S, ∃S / ∈ θ K (ch(S)), ch(S) / ∈ ch(D + σ ), and ρ(π 2 ) = (f (repr K (S)), succ I S (f (repr K (S)))). • If x ∈ D + K , then ρ(π 1 )[1] = ori + (x) = x ∈ Ind(A). From ρ(π 1 ) = ρ(π 2 ) and above, we get x = ρ(π 1 )[1] = ρ(π 2 )[1] = f (repr K (S)). By statement 1 of Lemma 2, we have θ K (ch(S)) = θ K (f (repr K (S))), yielding θ K (x) = θ K (ch(S)). Recall that x ∈ D + K ensures in particular ∃S ∈ θ K (x), it contradicts the assumption ∃S / ∈ θ K (ch(S)). • If x = ch(R) with R ∈ D + σ , then ρ(π 1 )[1] = f (repr K (R)). As ρ(π 1 ) = ρ(π 2 ) and ρ(π 2 )[1] = f (repr K (S)), we have f (repr K (R)) = f (repr K (S)).</formula><p>The second statement of Lemma 2 gives us ch(R) = ch(S). Since R ∈ D + σ , we get a contradiction with ch(S) / ∈ ch(D + σ ). 4 + . 1. Symmetric to Case 1.4 + .</p><p>2, 3 + . Symmetric to Case (2, 3 + ).4 + . 4 + . By definition π 1 = π 2 = (ch(S), ch(S)).</p><p>Explicit formula for number of matches in the interpretation of a strategy.</p><p>To avoid computing an actual model interpreting a strategy and then computing its number of matches, it is useful to observe that this amount is easily decided in advance and, in particular, is independent of the choice of well-typed elements and of the pairing. This is expressed by the following lemma.</p><p>Lemma 7. Let A be an ABox and K := (T , A). Let σ be a legal strategy over K. Every model interpreting the strategy σ provides the following amount λ σ/K of matches:</p><formula xml:id="formula_63">λ σ/K := |{(a, b) | K |= S(a, b)}| + max D + K + |σ(D + σ )|, D - K + |σ(D - σ )| +1 if D + K + |σ(D + σ )| &gt; D - K + |σ(D - σ )| T |= ∃S -∃S ∃S / ∈ t if σ(S) = (t, k) σ(S) / ∈ σ(D + σ ) +1 if D - K + |σ(D - σ )| &gt; D + K + |σ(D + σ )| T |= ∃S ∃S - ∃S -/ ∈ t if σ(S -) = (t, k) σ(S -) / ∈ σ(D - σ )</formula><p>Before giving the proof of the preceding lemma, it will helpful to first establish the relationship holding between the sizes of the sets D + K , D + σ , D - K , D - σ and the sets of critical elements. Lemma 8. Let ch be a choice of well-typed elements for a legal strategy σ over K. Then the sets crit + ch and crit - ch satisfy the following:</p><formula xml:id="formula_64">crit + ch = D + K + σ(D + σ ) crit - ch = D - K + σ(D - σ ) .</formula><p>In particular, the sizes of crit + ch and crit - ch do not depend on ch.</p><p>Proof. First we prove that D + K and ch(D + σ ) are disjoint. Notice that if a ∈ D + K , then ∃S ∈ θ K (a). Therefore, if ever ch(R) = a, then by Condition 1 from the definition of a choice of well-typed elements:</p><formula xml:id="formula_65">σ(R) = (θ K (a), k), which would contradict R ∈ D + σ . Hence D + K ∩ ch(D + σ ) = ∅.</formula><p>We conclude by applying Condition 2 from the definition of a choice of well-typed elements, which ensures that |ch(D</p><formula xml:id="formula_66">+ σ )| = |σ(D + σ )|. The case of crit - ch is symmetric.</formula><p>We now return to the proof of Lemma 7:</p><p>Proof of Lemma 7. Let J be the interpretation of σ obtained according to a choice of well-typed element ch, a pairing p, and some certain successor preference. From Lemma 4, and recalling that distinct shapes are incompatible, we have:</p><formula xml:id="formula_67">S J = |{(a, b) | K |= S(a, b) }| + min crit + ch , crit - ch + max crit + ch -crit - ch , 0 + max crit - ch -crit + ch , 0 +1 if crit + ch &gt; crit - ch ∧ T |= ∃S -∃S ∧ ∃S / ∈ θ K (ch(S)) ∧ ch(S) / ∈ ch(D + σ ) +1 if crit - ch &gt; crit + ch ∧ T |= ∃S ∃S -∧ ∃S -/ ∈ θ K (ch(S -)) ∧ ch(S -) / ∈ ch(D - σ ) = |{(a, b) | K |= S(a, b) }| + max crit + ch , crit - ch +1 if crit + ch &gt; crit - ch ∧ T |= ∃S -∃S ∧ ∃S / ∈ θ K (ch(S)) ∧ ch(S) / ∈ ch(D + σ ) +1 if crit - ch &gt; crit + ch ∧ T |= ∃S ∃S -∧ ∃S -/ ∈ θ K (ch(S -)) ∧ ch(S -) / ∈ ch(D - σ )</formula><p>We can then apply Lemma 8 to express crit + ch and crit - ch in terms of the sets</p><formula xml:id="formula_68">D + K , D + σ , D - K , D - σ .</formula><p>We also need to use Condition 1 from the definition of a choice of well-typed elements in order to replace ∃S / ∈ θ K (ch(S)) by ∃S / ∈ t if σ(S) = (t, k), and Condition 2 to replace ch(S) / ∈ ch(D + σ ) by σ(S) / ∈ σ(D + σ ) (and similarly for S -). It can be verified that this indeed yields the desired number λ σ/K .</p></div>
<div><head>Proof of TC 0 membership for Theorem 1(i).</head><p>With Lemma 1 in hand, we can now describe how to construct a family of TC 0 circuits to decide our problem. We need a family of circuits in order to be able to handle ABoxes of different sizes. More precisely, we will create one circuit for each possible number of individual names. We can assume w.l.o.g. that the same set of individuals, denoted Ind , is used for all of the ABoxes having individuals. In what follows, we introduce the different gates which are used for computing the various sets and values used in the construction and how they are connected to each other. We start by the input gates which show how we represent an input (A * , m * ) to the circuit that handles -individual ABoxes. It can be verified that for each of the gates we introduce decides the statement or property occurring in its label (with A * , resp. K * = (T , A * ) substituted for A, resp. K).</p></div>
<div><head>Input gates.</head><p>• Each atomic role P appearing in T is represented by input gates P(a,b)∈A for a, b ∈ Ind . The gate P(a,b)∈A is set to</p><formula xml:id="formula_69">1 iff P(a, b) ∈ A * .</formula><p>• Each atomic concept A appearing in T is represented by input gates A(a)∈A for a ∈ Ind . The gate A(a)∈A is set to 1 iff A(a) ∈ A * .</p><p>• The integer m * is represented in binary by input gates b k =1 for each 0</p><formula xml:id="formula_70">≤ k &lt; log 2 (|Ind(A * )| + |T |) |q| ). The gate b k =1</formula><p>is set to 1 iff the k th bit of m * is 1 (with 0 th -bit being the least significant bit). Regarding the last point, we use the observation from <ref type="bibr" target="#b25">[Kostylev and Reutter, 2015]</ref> that if m * is a certain answer for q over K * , then Gates for computing available roles and entailed concepts for ABox individuals.</p><p>For each positive role R and each individual name a ∈ Ind , introduce a disjunctive gate ∨ ∃b,K|=R(a,b) taking as inputs:</p><formula xml:id="formula_71">• R(a,b)∈A for each b ∈ Ind(A), if R ∈ N R . • P(b,a)∈A for each b ∈ Ind(A), if R = P -with P ∈ N R .</formula><p>For each positive concept B and each individual name a ∈ Ind , introduce a disjunctive gate ∨ K|=B(a) taking as inputs:</p><formula xml:id="formula_72">• A(a)∈A for each atomic concept A such that T |= A B. • ∨ ∃b,K|=R(a,b) for all role R ∈ N ± R such that T |= ∃R B.</formula><p>Computing types and counting number of occurring types.</p><p>For each type t ∈ Θ T and each individual name a ∈ Ind , introduce a conjunctive gate ∧ θ K (a)=t taking as inputs: • ∨ K|=B(a) for each positive concept B such that B ∈ t. • the negation of ∨ K|=B(a) for each positive concept B such that B / ∈ t.</p><p>For each type t ∈ Θ T and each k ∈ {0, . . . sig(T ) ± R }, introduce a threshold gate k ∃ ≥k ind. of type t taking as inputs:</p><formula xml:id="formula_73">∧ θ K (a)=t</formula><p>for each individual name a ∈ Ind .</p><p>Remark: Notice here that k ranges up to sig(T ) ± R as any strategy requires at most this many copies of a type (see availability condition from Definition 14). Notice also the label "∃ ≥k ind. of type t", which stands for |{a ∈ Ind | θ K (a) = t}| ≥ k.</p></div>
<div><head>Identifying generated roles.</head><p>For each individual name a ∈ Ind and each positive role R, introduce a conjunctive gate ∧ aR∈∆ C K taking as inputs: ∨ K|=∃R(a) and the negation of ∨ ∃b,K|=R(a,b) . For each positive role R, introduce a disjunctive gate ∨ R∈gen K taking as inputs: ∧ aT∈∆ C K for each positive role T such that T ensures that if aT ∈ ∆ C K , then there exists a word w starting with T and ending by R s.t aw ∈ ∆ C K .</p></div>
<div><head>Identifying demanding individuals (see Definition 4).</head><p>For each a ∈ Ind , introduce a conjunctive gate ∧ Subcircuit for each strategy σ ∈ (Θ T ×{1, . . . Computing λ σ/K for each strategy σ (see Lemma 7).</p><formula xml:id="formula_74">N ± R }) N ± R (</formula></div>
<div><head>A threshold gate</head><formula xml:id="formula_75">k m A +|D + K |+|σ(D + σ )|≥k</formula><p>for each k ∈ {0, . . . , K} taking as inputs:</p><formula xml:id="formula_76">• S(a,b)∈A for each (a, b) ∈ Ind × Ind , • ∧ a∈D + K for each a ∈ D + K , • |σ(D + σ )| copies of a true gate 1 . A threshold gate k m A +|D - K |+|σ(D - σ )|≥k</formula><p>for each k ∈ {0, . . . , K} taking as inputs:</p><formula xml:id="formula_77">• S(a,b)∈A for each (a, b) ∈ Ind × Ind , • ∧ a∈D - K for each a ∈ D - K , • |σ(D - σ )| copies of a true gate 1 . Introduce ∧ |D + K |+|σ(D + σ )|=|D - K |+|σ(D - σ )|=k-m A</formula><p>for each k ∈ {0, . . . , K} taking as inputs:</p><formula xml:id="formula_78">• k m A +|D + K |+|σ(D + σ )|≥k</formula><p>and the negation of k+1</p><formula xml:id="formula_79">m A +|D + K |+|σ(D + σ )|≥k+1 , • k m A +|D - K |+|σ(D - σ )|≥k</formula><p>and the negation of k+1</p><formula xml:id="formula_80">m A +|D - K |+|σ(D - σ )|≥k+1</formula><p>,</p><p>• ∧ legal σ . Notice that for the latter and upcoming gates of this block, we omit "legal σ" from the labels for clarity.</p><formula xml:id="formula_81">Introduce ∧ |D + K |+|σ(D + σ )|&lt;|D - K |+|σ(D - σ )|=k-m A</formula><p>for each k ∈ {0, . . . , K} taking as inputs:</p><p>• the negation of k</p><formula xml:id="formula_82">m A +|D + K |+|σ(D + σ )|≥k , • k m A +|D - K |+|σ(D - σ )|≥k</formula><p>and the negation of</p><formula xml:id="formula_83">k+1 m A +|D - K |+|σ(D - σ )|≥k+1 , • ∧ legal σ . Introduce ∧ |D - K |+|σ(D - σ )|&lt;|D + K |+|σ(D + σ )|=k-m A</formula><p>for each k ∈ {0, . . . , K} taking as inputs:</p><formula xml:id="formula_84">• k m A +|D + K |+|σ(D + σ )|≥k</formula><p>and the negation of</p><formula xml:id="formula_85">k+1 m A +|D + K |+|σ(D + σ )|≥k+1 , • the negation of k m A +|D - K |+|σ(D - σ )|≥k , • ∧ legal σ .</formula><p>For each k ∈ {0, . . . , K}, introduce a disjunctive gate ∨ λ σ/K =k taking as inputs:</p><formula xml:id="formula_86">• ∧ |D + K |+|σ(D + σ )|=|D - K |+|σ(D - σ )|=k-m A , • If T |= ∃S ∃S -, ∃S - / ∈ t with σ(S -) = (t, k) and σ(S -) / ∈ σ(D - σ ), then gate ∧ |D + K |+|σ(D + σ )|&lt;|D - K |+|σ(D - σ )|=k-1-m A , otherwise gate ∧ |D + K |+|σ(D + σ )|&lt;|D - K |+|σ(D - σ )|=k-m A , • If T |= ∃S - ∃S, ∃S / ∈ t with σ(S) = (t, k), and σ(S) / ∈ σ(D + σ ), then gate ∧ |D - K |+|σ(D - σ )|&lt;|D + K |+|σ(D + σ )|=k-1-m A , otherwise gate ∧ |D + K |+|σ(D + σ )|&lt;|D - K |+|σ(D - σ )|=k-m A .</formula><p>We are now able to compute the minimal amount of matches given by legal strategies. Final comparison with the input integer (see Lemma 1).</p><p>For each k ∈ {0, . . . , K}, introduce a disjunctive gate ∨ min legal σ λ σ/K &lt;k taking as inputs: ∧</p><formula xml:id="formula_87">λ σ/K =k legal σ</formula><p>for each strategy σ and each k &lt; k. For each k ∈ {0, . . . , K}, introduce a conjunctive gate ∧ m=k taking as inputs: • bj =1 such that the j th bit of the binary encoding of k is 1, • the negation of bj =1 such that the j th bit of the binary encoding of k is 0.</p><p>For each k ∈ {0, . . . , K}, introduce a conjunctive gate ∧ To complete the proof, we observe that, since the TBox T is fixed, the number of gates is polynomial in the described family of circuits. Moreover, all circuits in the family have the same depth (13). Thus, the construction yields a TC 0 of circuits for deciding OMQA(q S , T ) and establishes membership in TC 0 .</p><p>A.2 Proof of Theorem 1.ii: Concept Cardinality Queries and DL-Lite H core without negative role inclusions.</p><p>We now turn to the case where T is a DL-Lite H core TBox without negative role inclusions and q C is the concept cardinality query: ∃z C(z).</p><p>Due to a simpler shape of the query, several notions simplify. In particular, distinguishing between positive and negative critical elements is no longer necessary and these notions can be unified as follows. Definition 17 (Demanding roles, critical elements). Let σ be a strategy. Define demanding roles D σ as:</p><formula xml:id="formula_88">D σ := R R ∈ dom(σ) T |= ∃R -C C / ∈ t if σ(R) = (t, k)</formula><p>Let ch be a choice of well-typed elements for σ over K. Define the set of critical elements as:</p><formula xml:id="formula_89">crit ch = ch(D σ )</formula><p>Pairing is also no longer necessary, which means the interpretation of a strategy can be drastically simplified as follows. Definition 18 (Interpretation of a strategy). Let A be an ABox and K := (T , A). Let σ be a legal strategy over K. Let ch be a choice of well-typed elements for σ over A. Consider the following mapping:</p><formula xml:id="formula_90">χ : ∆ C K → Ind(A) ∪ {⊥ i | i = 1, . . . sig(T ) ± R } a → a wR → ch(R)</formula><p>The interpretation J of σ w.r.t. ch is defined as the image of • C K through χ: its domain is ∆ J = χ(∆ C K ), and its interpretation function is</p><formula xml:id="formula_91">• J = χ • • C K .</formula><p>Under these updated definitions, notice the Lemma 1 still makes perfect sense, and we start by proving it, following closely the analogous proof for role cardinality queries.</p></div>
<div><head>Proof of Lemma 1 for concept cardinality queries</head><p>We first prove the first point of Lemma 1, stating that the interpretation of a strategy extracted from a model is also a model, in the following stronger form, not requiring the strategy to be extracted from a model in the first place. Lemma 9. Let A be an ABox and K := (T , A) be a satisfiable KB. Let σ be a legal strategy over K. Let ch be a choice of well-typed elements for σ over A. The interpretation J of the strategy σ w.r.t. ch is a model. Proof. Assertions from the ABox and axioms without negation are satisfied since the interpretation J is built from C K . Consider now a negative concept inclusion B 1 ¬B 2 . Assume for a contradiction that there is an element d such that d ∈ B 1 J ∩ B 2 J . There are four cases to consider:</p><formula xml:id="formula_92">1. If K |= B 1 (d) and K |= B 2 (d), then this contradicts K being satisfiable. 2. If K |= B 1 (d) and K |= B 2 (d), then d = χ(wR) with R ∈ gen K and T |= ∃R - B 2 .</formula><p>In particular, d = ch(R) and T |= ∃R -¬B 1 . Condition 1 from the definition of choice of well-typed elements ensures σ(R) = (θ K (d), i) for some i. Condition 1 from the definition of a strategy implies that</p><formula xml:id="formula_93">B 1 / ∈ θ K (d), contradicting K |= B 1 (d). 3. If K |= B 1 (d) and K |= B 2 (d). Symmetric to Case 2. 4. If K |= B 1 (d) and K |= B 2 (d), then d = χ(w 1 R 1 ) = χ(w 2 R 2 ) with R 1 ∈ gen K , R 2 ∈ gen K , T |= ∃R - 1 B 1 and T |= ∃R - 2 B 2 . In particular, d = ch(R 1 ) = ch(R 2 ).</formula><p>Condition 2 in the definition of the choice of well-typed elements ensures: σ(R 1 ) = σ(R 2 ). Condition 2 in the definition of a strategy ensures:</p><formula xml:id="formula_94">T |= ∃R - 1 ¬∃R - 2 , contradicting T |= B 1 ¬B 2 .</formula><p>In order to prove the second point of Lemma 2, stating an interpretation J of the strategy extracted from a model I has at most as matches as the original model I, we need to better understand what kinds of matches of q C can be found in J . This is achieved by the following result which precisely characterizes C J Lemma 10 (Matches in a model interpreting a strategy). Let A be an ABox, and K := (T , A) be satisfiable KB. Let σ be a legal strategy over K, and let ch be a choice of well-typed elements for σ over K. Denote by J the interpretation of σ w.r.t. ch. Then we have:</p><formula xml:id="formula_95">C J = {a | K |= C(a) } (Shape 1) ∪ {ch(R) | R ∈ D σ } (Shape 2)</formula><p>Furthermore, there is no overlap between these two distinct shapes.</p><p>Proof. The first inclusion (⊆) is rather straightforward. We therefore focus on proving the direction (⊇).</p><p>1. Let a be such that K |= C(a), in particular a ∈ Ind(A). By definition, χ(a) = a, hence a ∈ C J .</p><p>2. Let R ∈ D σ . By definition of gen K , there exists wR ∈ C K . By definition of the interpretation of a strategy, χ(wR</p><formula xml:id="formula_96">) = ch(R). Moreover, R ∈ D σ implies that T |= ∃R -C, which ensures wR ∈ C C K . Therefore ch(R) ∈ C J .</formula><p>We can now prove the second point of Lemma 1, recalled in the following statement.</p><p>Lemma 11. Let A be an ABox and K := (T , A). Let I be a model of K. Let σ be the strategy extracted from I. Let ch be a choice of well-typed elements for σ over K. Denote J the resulting interpretation of σ. We have:</p><formula xml:id="formula_97">q J ≤ q I .</formula><p>Proof. Associate each match π of q in J to a match ρ(π) in I depending of the shape of π:</p><formula xml:id="formula_98">ρ(π) : z → π(z) if π has Shape 1 z → f (repr K (R)) if π has Shape 2 with π(z) = ch(R)</formula><p>Notice ρ(π) is indeed a match in I. Now prove that ρ is injective. Let π 1 , π 2 : q → J σ f •repr K be two matches such that ρ(π 1 ) = ρ(π 2 ). We consider all four cases:</p><formula xml:id="formula_99">1. 1. π 1 (z 1 ) = ρ(π 1 )(z 1 ) = ρ(π 2 )(z 1 ) = π 2 (z 1 ) and π 1 (z 2 ) = ρ(π 1 )(z 2 ) = ρ(π 2 )(z 2 ) = π 2 (z 2 ). 2. We have π 2 (z) = ch(R) with R ∈ D σ . Therefore C / ∈ θ K (ch(R)). Lemma 2 provides θ K (ch(R)) = θ K (ρ(π 2 )(z)). Recall ρ(π 1 ) = ρ(π 2 ), hence C / ∈ θ K (π 1 (z)). Contradiction with K |= C(π 1 (z)). 2. 1. Symmetric to Case 1.2. 2. We have π 1 (z) = ch(R 1 ) with R 1 ∈ D σ and π 2 (z) = ch(R 2 ) with R 2 ∈ D σ . Therefore f (repr K (R 1 )) = f (repr K (R 2 )). Lemma 2 provides π 1 (z) = π 2 (z),.</formula><p>Explicit formula for number of matches in the interpretation of a strategy.</p><p>We will again avoid having to produce interpretations of strategies by showing that we can directly determine the number of matches occurring in such models. This is the purpose of the following lemma.</p><p>Theorem 9. Let A be an ABox, and K := (T , A) be a satisfiable KB. Let σ be a legal strategy over K. Any interpretation J of the strategy σ has the following amount λ σ/K of matches:</p><formula xml:id="formula_100">λ σ/K = |{a | K |= C(a)}| + |σ(D σ )|</formula><p>Proof. The equation immediately follows from Lemma 10 and by noticing that |crit ch | = |σ(D σ )| due to second condition in the definition of a choice of well-typed elements.</p><p>The family of circuits.</p><p>To complete the proof, we describe how to construct a family of TC 0 circuits that can be used to decide our problem. The construction is very similar to the one given for role cardinality queries, so we simply mention the updates required to adapt the family of circuits to concept cardinality queries.</p><p>• We need to introduce further gates in the second block to compute entailed role assertions.</p><p>• The circuits in the block "Deciding demanding individuals" are no longer required.</p><p>• Each block dedicated to a particular strategy simplifies as we no longer need to compare the size of positive vs negative critical elements: each strategy still comes with a specific amount of additional matches |σ(D σ )| due to demanding roles, again introduced through constant gates, and counting ABox matches needs to be slightly updated from the role setting to the concept one.</p><p>A.3 TC 0 -hardness.</p><p>To match our TC 0 membership results, it is natural to investigate the TC 0 -hardness of our problem in these situations. Recall that we assumed, in order to exclude trivial cases, that our query predicate is satisfiable (Section 2, Cardinality Queries). We show that this assumption is sufficient to obtain TC 0 -hardness (for any DL-Lite H core TBox), and it also necessary as the excluded situations can be decided within AC 0 (which we recall is the circuit complexity class obtained from TC 0 by disallowing threshold gates). We thus prove the following statement:</p><p>Theorem 10 (TC 0 -hard / in AC 0 ). Let q F be a cardinality query and T be a DL-Lite H core TBox. If the query predicate F is satisfiable w.r.t. T , then OMQA(T , q) is TC 0 -hard. Otherwise it is in AC 0 .</p><p>The argument for AC 0 membership is trivial: a cardinality query with an unsatisfiable predicate admits as certain answers precisely those intervals of the form [0, M ], since every model will contain 0 matches.</p><p>For both concept and role cardinality queries, we show TC 0 -hardness by AC 0 -reduction from the NUMONES problem, known to be TC 0 -complete <ref type="bibr" target="#b0">[Aehlig et al., 2007]</ref>.</p></div>
<div><head>NUMONES</head></div>
<div><head>Input</head><p>Integer k ≥ 1 (given in binary) and binary string X. Output Is the number of 1-bits in X at least k?</p><p>We note that we cannot reuse the TC 0 -hardness proof given in <ref type="bibr" target="#b9">[Bienvenu et al., 2020]</ref>, since that result used a rooted counting query coupled with an empty TBox. By contrast, we consider non-empty TBoxes which may include existential axioms, and our queries may match to unnamed elements.</p><p>Proof for concept cardinality queries. Let q C be our concept cardinality query and assume C is satisfiable w.r.t. our TBox T . Set K (T ,q) := (T , {C(a)}). Our assumption ensures K (T ,q) is satisfiable hence its canonical interpretation (model) C K (T ,q) is indeed a model. Let (k, X) be an instance of NUMONES. Consider the following ABox:</p><formula xml:id="formula_101">A ={A(aux 1 ) | a ∈ A C K (T ,q) } ∪ {R (aux 1 , aux R ) | aR ∈ ∆ C K (T ,q) , T |= R R } ∪ {A(b) | bit b of X is equal to 1, a ∈ A C K (T ,q) } ∪ {R (b, aux R ) | bit b of X is equal to 1, aR ∈ ∆ C K (T ,q) , T |= R R } ∪ {A(aux R ) | wR ∈ ∆ C K (T ,q) , T |= ∃R -A} ∪ {R (aux T , aux R ) | wTR ∈ ∆ C K (T ,q) , T |= R R }</formula><p>Note that in particular that A will contain C(b) for every 1-bit b of X, as well as C(aux 1 ). The auxiliary individual aux 1 mimics a 1-bit from X in order to appropriately handle the case in which X doesn't contain any such bit. As the notation suggests, auxiliary individuals aux R are intended to receive all needed outgoing roles R from other elements (so aux R is intended to satisfy the concept ∃R -). Note that by construction the interpretation based upon A already satisfies all of the TBox axioms. In particular, this means that there exists a model of (T , A) all of whose matches are already present in A. We can thus focus on counting the matches explicitly given in A.</p><p>Observe that the number m of matches of q C among the auxiliary elements only depends on the OMQ (q C , T ). In particular notice that aux 1 always provides a match, hence m ≥ 1. It is straightforward to verify that m + k is a certain answer for q over K := (T , A) iff (k, X) ∈ NUMONES. Moreover, the input (A, m + k) to our OMQA problem can be computed from (k, X) by an AC 0 circuit (recall that binary integer addition is known to be computable in AC 0 ).</p><p>The proof for role cardinality queries is a bit more involved but follows the same idea.</p><p>Proof for role cardinality queries. Let q S be our concept cardinality query and assume S is satisfiable w.r.t. our TBox T . Set K (T ,q) := (T , {S(a 1 , a 2 )}). Our assumption ensures K (T ,q) is satisfiable hence its canonical interpretation C K (T ,q) is indeed a model. Let (k, X) be an instance of NUMONES. Consider the ABox A containing assertions:</p><formula xml:id="formula_102">{R(aux 1 , aux 2 ) | (a 1 , a 2 ) ∈ R C K (T ,q) } ∪ {A(aux j ) | j ∈ {1, 2}, a j ∈ A C K (T ,q) } ∪ {R(b 1 , b 2 ) | bit b of X is equal to 1, (a 1 , a 2 ) ∈ R C K (T ,q) } ∪ {A(b j ) | j ∈ {1, 2}, bit b of X is equal to 1, a j ∈ A C K (T ,q) } ∪ {R (aux j , aux R ) | j ∈ {1, 2}, a j R ∈ ∆ C K (T ,q) , T |= R R } ∪ {R (b j , aux R ) | j ∈ {1, 2}, bit b of X is equal to 1, a j R ∈ ∆ C K (T ,q) , T |= R R } ∪ {A(aux R ) | wR ∈ ∆ C K (T ,q) , T |= ∃R -A} ∪ {R (aux T , aux R ) | wTR ∈ ∆ C K (T ,q) , T |= R R }</formula><p>Here again we note that by construction all of the TBox axioms are already satisfied, so we only need to concern ourselves with matches explicitly given in the ABox. In order to compute this number, let us first denote by n the number of matches in C K (T ,q) that involve either a 1 , a 2 , or both individuals. Observe that n only depends on the OMQ (q S , T ) and that we have n ≥ 1 due to the assertion S(a 1 , a 2 ). Considering now the ABox A, we will denote by m the number of matches of q S in A which only involve auxiliary elements; this value depends solely on the OMQ (q S , T ). It is not hard to see that m + k × n is a certain answer for q over K := (T , A) iff (k, X) ∈ NUMONES.</p><p>To complete the proof, we note that we can compute (A, m + k × n) from (k, X) in AC 0 due to the fact that n is a constant. Indeed, k × n can be computed by performing a constant number of additions of k with itself, there is one more addition step to combine with m, and we can compute the addition of a constant number of binary numbers in AC 0 . We point out that it is essential here that n be a constant value, since the problem of multiplying two arbitrary binary inputs is known to not be computable in AC 0 .</p><p>B Proof of Theorem 2.</p><p>The following definition introduces terminology for speaking about a specific kind of match that is guaranteed to be found in any model: Definition 19 (ABox matches). Let A be an ABox and K = (T , A). An ABox match for q S is a pair (a, b) ∈ Ind(A) such that K |= S(a, b).</p><p>B.1 Proof of coNP-hardness.</p><p>We begin by proving coNP-hardness of OMQA(q S , T ) in the case where the input DL-Lite H pos TBox T admits a non-trivial propagation of either S or S -. Note that membership in coNP is an immediate consequence of existing results on counting queries <ref type="bibr" target="#b25">[Kostylev and Reutter, 2015]</ref>.</p><p>Let us thus assume that T has a non-trivial propagation B, R 1 , R 2 of S (the case of a non-trivial propagation of S -being symmetrical). We proceed by reduction from the SET COVER problem, and distinguish two cases based on the shape of B.</p><p>Consider an instance (U, S, k) of SET COVER: each element u ∈ U occurs in at least one subset of S, we denote s u by such a subset. We introduce an individual name u for each u ∈ U, and an individual name s for each s ∈ S. The individual introduced for the subset s u is denoted s u . We further introduce auxiliary individuals a and b.</p><p>We now provide the reductions for the two cases.</p><p>Case 1: B ∈ N C or B = ∃T with T |= T S. Consider the ABox: Consider the KB K := (T , A). Notice that due to the many role assertions included in the ABox, all of the anonymous elements in C K are of the form uUw with u ∈ U, w some word, and T |= U S but T |= U - S (because we are considering a non-trivial propagation, the role U cannot satisfy Condition 1 of Definition 11). Notice also that (the negation of) Condition 2 from the same definition further ensures that there is no ABox match (b, s), with s ∈ S.</p><formula xml:id="formula_103">A := {B(u) | u ∈ U} if B ∈ N C {T(u, a) | u ∈ U} else, with B = ∃T (Representation of the elements) ∪ {S(u, s) | u ∈ s, s ∈ S} (Representation of the subsets) ∪    U(u, a) U ∈ N ± R , u ∈ U T |= B ∃U T |= U S    (Introduction of non-relevant roles for elements) ∪    U(s, b) U ∈ N ± R , s ∈ S T |= ∃S -∃U T |= U S    (Introduction</formula><p>Let us denote by m A be the number of matches for q S present in the ABox A. In particular, m A ≥ s∈S |s| + 1, due to the representation of the subsets and the saturation of a. We claim: <ref type="bibr">⇒)</ref>. Assume (U, S, k) ∈ SET COVER. Take some k-cover F ⊆ S of U. For each u ∈ s with s ∈ F and each positive role U such that T |= B ∃U and T |= U S, enrich the ABox A with the assertion U(u, s). Saturate now the used subsets, that is, for each s ∈ F , add the assertions U(s, s) for all U ∈ sig(T ) R .</p><formula xml:id="formula_104">[m A + k + 1, +∞] is a certain answer for q S w.r.t. K ⇔ (U, S, k) / ∈ SET COVER<label>(</label></formula><p>Up to introducing the entailed concepts, the resulting interpretation I F (based upon the described enriched ABox) is a model, as we introduced the missing roles for the elements, the used subsets are now saturated, and the non-used subsets were already given their needed roles.</p><p>In addition to the m A ABox matches, each used subset provides one additional match since the assertion S(s, s) has been added. Recall Condition 1 from Definition 11 which ensures no match with shape S(s, u) is introduced, hence the roles added between the elements and subset individuals only reuse pre-existing matches. We thus obtain a model with exactly m A + k matches, and thus a countermodel for [m A + k + 1, +∞] being a certain answer.</p><p>(⇐). Assume (U, S, k) / ∈ SET COVER. Consider a model I of K and a homomorphism f : C K → I. For each u ∈ U, we associate a subset ρ(u) := s if f (uR 1 ) = s and u ∈ s ∈ S, otherwise set ρ(u) := s u . The image ρ(U) is a covering of U, hence |ρ(U)| ≥ k + 1. By definition, for each s ∈ ρ(U) there exists u ∈ U such that: either f (uR 1 ) = s with u ∈ s ∈ S, or f (uR 1 ) = s for all u ∈ s ∈ S.</p><p>In the first case, since T |= {R 1 S, ∃R - 1 ∃R 2 , R 2 S} (due to the assumed non-trivial propagation), we focus on the pair (f (uR 1 ), f (uR 1 R 2 )). If (f (uR 1 ), f (uR 1 R 2 )) is not already an ABox match, then we have found an additional match. Otherwise (f (uR 1 ), f (uR 1 R 2 )) is an ABox match (i.e. K |= S(f (uR 1 ), f (uR 1 R 2 )). By construction of A, this must be due to S propagating a subrole U of S (see 'Introduction of subroles of S for subsets' in the definition of the ABox), which means we have</p><formula xml:id="formula_105">f (uR 1 R 2 ) = b. Condition 2 from Definition 11 applied with U provides T |= R - 2 S, hence (f (uR 1 R 2 ), f (uR 1 ))</formula><p>is a new match (recall that (b, s) is not an ABox match!). In the second case, (f (u), f (uR 1 )) is a new match (in the case where B = ∃T, simply recall that T |= T S). Therefore we can conclude that there are at least m A + k + 1 matches in I.</p><p>Case 2: B = ∃T with T |= T S. Consider the ABox:</p><formula xml:id="formula_106">A := {T(u, s) | u ∈ s ∈ S} (Representation of the subsets) ∪    U(u, a) U ∈ N ± R , u ∈ U T |= ∃T ∃U T |= U S    (Introduction of non-relevant roles for elements) ∪    U(s, b) U ∈ N ± R , s ∈ S T |= ∃S -∃U ∨ T |= ∃T -∃U T |= U S    (Introduction of subroles of S for subsets) ∪    U(s, a) U ∈ N ± R , s ∈ S T |= ∃S -∃U T |= U S    (Introduction of other roles for subsets) ∪ {U(a, a) | U ∈ sig(T ) R } (Saturation of the auxiliary individual a) ∪ {U(b, b) | U ∈ sig(T ) R } (Saturation of the auxiliary individual b)</formula><p>We again set K := (T , A) and observe that the anonymous elements in C K are all of the form uUw with u ∈ U, T |= U S, and w a word. Notice again that no pair (b, s), with s ∈ S, is an ABox match, which is due here to both Conditions 2 and 3 from Definition 11.</p><p>As before, we denote by m A the number of matches for q S in the ABox A. In particular m A ≥ s∈S |s| + 1, due to the representation of the problem instance and the saturation of a. We claim:</p><formula xml:id="formula_107">[m A + k + 1, +∞]</formula><p>is a certain answer for q S w.r.t. K ⇐⇒ (U, S, k) / ∈ SET COVER (⇒). The proof is essentially the same as for Case 1.</p><p>(⇐). Assume (U, S, k) / ∈ SET COVER. Consider a model I of K and a homomorphism f : C K → I. For each u ∈ U, we associate a subset ρ(u) := s if f (uR 1 ) = s and u ∈ s ∈ S, otherwise set ρ(u) := s u . The image ρ(U) is a covering of U, hence |ρ(U)| ≥ k + 1. By definition, for each s ∈ ρ(U), there exists u ∈ U such that: either f (uR 1 ) = s with u ∈ s ∈ S, or f (uR 1 ) = s for all u ∈ s ∈ S.</p><p>In the first case, since T |= {R 1 S, ∃R - 1 ∃R 2 , R 2 S} (due to the assumed non-trivial propagation), we focus on the pair (f (uR 1 ), f (uR 1 R 2 )). If (f (uR 1 ), f (uR 1 R 2 )) is not already an ABox match, then we are done. Otherwise (f (uR 1 ), f (uR 1 R 2 )) is an ABox match, then by construction of A, it must be due to either S or T propagating a subrole U of S, in particular, we get f</p><formula xml:id="formula_108">(uR 1 R 2 ) = b. Condition 2 (resp. Condition 3) from Definition 11 applied with U provides T |= R - 2 S, hence (f (uR 1 R 2 ), f (uR 1 )) is a new match (recall (b, s) is not an ABox match!). In the second case, (f (u), f (uR 1 )) is a new match.</formula><p>Therefore there are at least m A + k + 1 matches in I.</p></div>
<div><head>B.2 Proof of reduction from co-Maximum-Matching.</head><p>We now turn to the second part of Theorem 2, which characterizes the complexity of OMQA(T , q S ) in the case in which the DL-Lite H pos TBox T admits a non-trivial pairing of S but does not have any non-trivial propagation of S or S -. We start by proving a logspace reduction from the complement of MAXIMUM MATCHING to our problem OMQA(T , q S ). Let us first recall the definition of MAXIMUM MATCHING:</p><p>As explained in the main text, the latter problem is known to be equivalent, up to logspace reductions, to the better known PERFECT MATCHING problem <ref type="bibr" target="#b29">[Rabin and Vazirani, 1989</ref>]. Thus, the reduction we give in this subsection also proves a reduction from PERFECT MATCHING to our problem. (A reduction in the other direction is the object of the next subsection.)</p></div>
<div><head>MAXIMUM MATCHING Input</head><p>Non-oriented graph G, integer k. Output Decide if there exists a matching of G with size at least k.</p></div>
<div><head>Consider a DL-Lite H</head><p>pos TBox T that admits a non-trivial pairing of S and does not admit any non-trivial propagation of S or S -. Let B and R verify the pairing conditions, that is,</p><formula xml:id="formula_109">T |= B ∃R T |= R S T |= R S -T |= S S - and if B = ∃T, then either T |= T S or T |= T S -.</formula><p>Consider an instance of MAXIMUM MATCHING given by the undirected graph G := (V, E) and integer k. Let ≤ V be any total order on the vertices of G. We encode G using the following ABox A G :</p><formula xml:id="formula_110">A G := {B(u) | u ∈ V} if B ∈ N C {T(u, a) | u ∈ V} else, with B = ∃T (Representation of the vertices) ∪ {S(u, v) | {u, v} ∈ E, u ≤ V v} (Representation of the edges) ∪ {U(a, a) | U ∈ sig(T ) R } (Saturation of the auxiliary individual)</formula><p>Let K G be the KB (T , A G ). Let m A be the number of matches in the ABox. Notice each edge {u, v} gives one match in the ABox, through the added assertion S(u, v) with u ≤ V v, and exactly one as T |= S -S. We claim:</p><formula xml:id="formula_111">[m A + |V| -k + 1, +∞] is a certain answer for q S w.r.t. K G ⇔ (G, k) / ∈ MAXIMUM MATCHING</formula><p>Notice that both A G and the integer m A + |V| -k + 1 are easily computable in logarithmic space from any reasonable representation of the instance (G, k), so we will get the desired within logspace reduction. . This yields exactly one additional match per edge in M , again because exactly one match per edge was already present. For each u ∈ V such that u is not incident to any edge in M , also add all the assertions U(u, u) ∈ A M . This yields exactly one new match per vertex not incident to any edge in M . Up to adding the entailed concepts wherever needed, this provides a model with at most: m A + |E| + |V| -2|E| ≤ m A + |V| -k matches of q S , being a counter model for [m A + |V| -k + 1, +∞].</p></div>
<div><head>B.3 Proof of reduction to co-Maximum-Matching.</head><p>In this subsection, we complete the proof of the second part of Theorem 2 by showing how OMQA(T , q S ) can be reduced, via logspace reductions, to the complement of MAXIMUM MATCHING in the case in which T is a DL-Lite H pos without non-trivial propagation. Again, this yields a logspace reduction to the complement of PERFECT MATCHING due to the previously cited logspace-equivalence between these two matching problems. We start with some general remarks.</p><p>Compared with the tractable settings of Section 3, with DL-Lite H pos , we no longer need to take care of negative concept inclusions, but we will now need to take into account role inclusions when handling role cardinality queries. In particular, role inclusions allow for a class B T of what we call bipotent roles, i.e., subroles of both S and S -(formally: positive roles U such that T |= U S and T |= U S -). On the other hand, the class N T of positive roles not being a subrole of S nor a subrole of S -are called nilpotent (formally: positive roles U such that T |= U S and T |= U S -).</p><p>Recall that our previous notion of type aimed to characterize individuals based on their ability to receive some roles (is there a negative concept preventing my anonymous element to merge with this individual?) and to provide ABox matches on which to fold (is there an ABox match on which to fold matches propagated by a given anonymous element?). This typing notion needs to be modified for the setting we consider here. On the one hand, negative inclusions being disallowed, all individuals are able to receive all roles. On the other hand, we must now distinguish ABox matches on which we can fold bipotent roles from those on which we can only fold non-bipotent roles. We also extend our typing notion to nilpotent roles: their type being a characterization of the subroles they propagate. </p><formula xml:id="formula_112">   D ± σ := R R ∈ gen K {S, S -} ∈ θ K (R)</formula><p>Notice here the assumptions that bidemanding roles should be nilpotent and not only "non-bipotent" (which should feel more natural in this case... but would provide a non-trivial propagation schema!).</p><p>We now redefine for our setting the notions of positive / negative demanding individuals. Definition 22 (Demanding individuals in a KB). Let A be an ABox and K := (T , A). Define positive demanding individuals D + K , resp. negative demanding individuals D - K as:</p><formula xml:id="formula_113">D + K :=      a a ∈ Ind(A) a / ∈ D ± K {S} ∈ θ K (a) ∀b ∈ Ind(A), K |= S(a, b)      D - K :=      a a ∈ Ind(A) a / ∈ D ± K {S -} ∈ θ K (a) ∀b ∈ Ind(A), K |= S -(a, b)     </formula><p>Strategies are no longer needed in our setting, as negative inclusions have been removed. Due to the adaptation of our notions of types, a choice of well-typed elements is redefined to now apply to types (of roles) instead of applying to the positive roles themselves. This is simply because the absence of negative concept inclusions allows us to apply the same choice to all nilpotent roles having the same type. Definition 23 (Choice of well-typed element). Let A be an ABox and K := (T , A). A choice of well-typed elements for K is a function choice K : Θ → Ind(A) such that for each type t ∈ Θ, if there exists a nilpotent generated role R ∈ gen K ∩ N T such that θ K (R) = t, then we have t ⊆ θ K (choice K (t)).</p><p>We now state our fundamental theorem, which proves that, if a choice of well-typed elements is available and in the absence of demanding individuals, then the canonical model can fully fold on the individuals without creating any additional match. This central property crucially relies on the absence of a non-trivial propagation schema. Theorem 11 (Fitting model). Let A be an ABox and K := (T , A). If there is a choice choice K of well-typed elements over Ind(A) and if K admits no bidemanding individuals, then there exists a mapping χ : ∆ C K → Ind(A) s.t the matches in the resulting model χ(C K ) are exactly the ABox matches.</p><p>Before starting with the proper proof, we need some additional definitions. First, why do we start from a demanding individual free KB? We want to take advantage of the absence of non-trivial propagation, in particular of violation of its Condition 2 (see Definition 11), which is involving roles generated by ∃S -(resp ∃S). Therefore, we somehow need these generated roles to be here as soon as possible: we need their causes, that are Sassertions, in our initial ABox.</p><p>Speaking about causes, take a look at Condition 3 from Definition 11. Here is a handy definition to take advantage of the cases in which this latter condition is broken. Definition 24 (Cause of an element). Let wR be an anonymous element of ∆ C K . A cause of wR is a positive concept such that: if w ∈ Ind(A), then cause(wR) is either an atomic concept B such that K |= B(w) and T |= B ∃R, or a positive concept ∃T such that there exists some b with K |= T(w, b) and T |= ∃T ∃R. Otherwise w = w 0 T, then cause(wR) := ∃T -.</p><p>Following this line, here is a definition capturing the role provided by a violation of Condition 1 (again from Definition 11). Definition 25 (Leader of an element). For an element w ∈ ∆ C K , if there exists a positive role U such that wU ∈ ∆ C K , T |= U S and T |= U S -, then we pick such a role U and say it is the leader of the element w, denoted leader(w).</p></div><figure xml:id="fig_0"><head /><label /><figDesc>Initial portion of the canonical model of Ke.</figDesc></figure>
<figure xml:id="fig_1"><head /><label /><figDesc>c) Interpretation of strategy σe.</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Models of the example KB Ke. For readability, we have omitted concepts and highlighted the role S from the cardinality query.</figDesc></figure>
<figure xml:id="fig_3"><head /><label /><figDesc>and hence we will have (χ(w), χ(w )) ∈ R J , which yields w ∈ C C K . Consider now a negative axiom of the form B ¬C. By contradiction assume there is an element d such that d ∈ B J ∩ C J . In what follows, χ is the function used in the definition of J . 1. If K |= B(d) and K |= C(d), then this contradicts K being satisfiable. 2. If K |= B(d) and K |= C(d), then d = χ(wT) with T ∈ gen K and T |= ∃T -C. Indeed K |= C(d) ensures d is not the image through χ of some individual certainly satisfiying C. Nevertheless, since d ∈ C J , it must be that d is the image through χ of some anonymous element, say wT, such that wT ∈ C C K . By definition of C C K , it yields T |= ∃T -C. (a) If d = succ K T (χ(w)) with T ∈ {S, S -}, then T(χ(w), d) ∈ A, contradicting K |= C(d). (b) If d = p + (χ(w)) with T = S, then in particular d ∈ crit - ch . • If d ∈ D - K , then in particular K |= ∃S -(d), contradicting K |= C(d). • If d = ch(T 0 ) with T 0 ∈ D - σ , then in particular T |= ∃T - 0 ∃S -. Hence T |= ∃T - 0 ¬B. Condition 1 in the definition of a choice of well-typed elements ensures σ(T 0 ) = (θ K (d), i). Condition 1 in the definition of a strategy ensures B / ∈ θ K (d), contradicting K |= B(d). (c) If d = p -(χ(w)) with T = S -. Same argument as in Case 2.b, based on d ∈ crit + ch . (d) If d = ch(T). Condition 1 from the definition of choice of well-typed elements ensures σ(T) = (θ K (d), i). Condition 1 from the definition of a strategy ensures B / ∈ θ K (d), contradicting K |= B(d).</figDesc></figure>
<figure xml:id="fig_4"><head>3.</head><label /><figDesc>If K |= B(d) and K |= C(d). Symmetric to Case 2. 4. If K |= B(d) and K |= C(d), then d = χ(wR) = χ(w T) with R, T ∈ gen K such that T |= ∃R -B and T |= ∃T - C, due to the same reason than in Case 2, applied here to both concepts B and C.</figDesc></figure>
<figure xml:id="fig_5"><head /><label /><figDesc>then in particular T |= ∃T - 0 ∃S. Condition 2 in the definition of the choice of well-typed elements ensures: σ(R 0 ) = σ(T 0 ). Condition 2 in the definition of a strategy ensures: T |= ∃R - 0 ¬∃T - 0 , contradicting T |= B ¬C. iv. If d = ch(T). Condition 2 in the definition of the choice of well-typed elements ensures: σ(R 0 ) = σ(T). Condition 2 in the definition of a strategy ensures: T |= ∃R - 0 ¬∃T -, contradicting T |= B ¬C. (c) If d = p -(χ(w)) with R = S -. Analogous argument to Case 4.b. (d) If d = ch(R). i. If d = succ K T (χ(w )) with T ∈ {S, S -}, then it contradicts K |= C(d). ii. If d = p + (χ(w )) with T = S. Symmetric to Case 4.b.iv. iii. If d = p -(χ(w )) with T = S -. Symmetric to Case 4.c.iv. iv. If d = ch(T). Condition 2 in the definition of the choice of well-typed elements ensures: σ(R) = σ(T). Condition 2 in the definition of a strategy ensures: T |= ∃R -¬∃T -, contradicting T |= B ¬C.</figDesc></figure>
<figure xml:id="fig_6"><head /><label /><figDesc>m * cannot exceed (|Ind(A * )| + |T |) |q| = (|Ind | + |T |) |q| . We denote K this upper bound. This is a direct consequence of the fact that every satisfiable DL-Lite H core KB K = (T , A) has a model with at most |Ind(A)| + |T | elements.</figDesc></figure>
<figure xml:id="fig_7"><head /><label /><figDesc>a∈D + K taking as inputs: ∨ K|=∃S(a) and the negation of ∨ ∃b,K|=S(a,b) . For each a ∈ Ind , introduce a conjunctive gate ∧ a∈D - K taking as inputs: ∨ K|=∃S -(a) and the negation of ∨ ∃b,K|=S -(a,b) .</figDesc></figure>
<figure xml:id="fig_8"><head /><label /><figDesc>K ≥m=k taking as inputs: ∧ m=k and the negation of ∨ min legal σ λ σ/K &lt;k . Introduce an output disjunctive gate ∨ min legal σ λ σ/K ≥m taking as inputs: ∧ min legal σ λ σ/K ≥m=k for each k ∈ {0, . . . , K}.</figDesc></figure>
<figure xml:id="fig_9"><head /><label /><figDesc>of subroles of S for subsets) other roles for subsets) ∪ {U(a, a) | U ∈ sig(T ) R } (Saturation of the auxiliary individual a) ∪ {U(b, b) | U ∈ sig(T ) R } (Saturation of the auxiliary individual b)</figDesc></figure>
<figure xml:id="fig_10"><head>(</head><label /><figDesc>⇐). Assume (G, k) / ∈ MAXIMUM MATCHING. Consider a model I of K and a homomorphism f : C K → I. Consider the following matching:M I := {{u, v} ∈ E | f (uR) = v, f (vR) = u} As f is a function, it isclear that each vertex is incident to at most one of the edges from M I , ensuring M I is a matching. In particular, it yields |M I | &lt; k. Each edge from M I provides exactly one additional match, since there was already exactly one match per edge, and the role R is a subrole of both S and S -. Each vertex that is not incident to any edge in M I provides at least one additional match: recall that since T |= T S or T |= T - S, either (f (u), f (uR)) or (f (uR), f (u)) is a new match.Therefore there are at least m A + |M I | + |V| -2|M I | &gt; m A + |V| -k matches in I. (⇒). Assume (G, k) ∈ MAXIMUM MATCHING. Consider a matching M ⊆ E with |M | ≥ k. Consider the enriched ABox A M such that for each {u, v} ∈ M and each positive role U ∈ N ± R , we have U(u, v) ∈ A M</figDesc></figure>
<figure xml:id="fig_11"><head>Definition 20 (</head><label>20</label><figDesc>Type of an individual, of a nilpotent role). Let A be an ABox and K := (T , A). The type θ K (d) of an element d ∈ Ind(A) over K is the set:θ K (d) := R R ∈ {{S, S -}, {S}, {S -}} ∃e ∈ ∆ C K ∀R ∈ R, C K |= R(d, e) .The type θ K (R) of a nilpotent role R ∈ N T over K is the set:θ K (R) := U U ∈ {{S, S -}, {S}, {S -}} ∃V ∈ N ± R , ∀U ∈ U, T |= ∃R -∃V ∧ T |= V U .The set of possible types is Θ := {{{S, S -}, {S}, {S -}}, {{S}, {S -}}, {{S -}}, {{S}}, ∅}.Following the line of the TC 0 membership proofs for role cardinality queries, we are still interested in demanding elements. In particular, bipotent roles might create a new kind of such elements: bidemanding elements, which are defined as follows. Definition 21 (Bidemanding elements). We distinguish bidemanding individuals D ± K and bidemanding roles D ± σ : {S, S -} ∈ θ K (a) ∀b ∈ Ind(A), (K |= S(a, b)) ∨ (K |= S -(a, b))</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>• • C K . Example 10. With choice ch e and pairing (p + e , p - e ), we get</figDesc><table /></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>we know that there exists some x ∈ crit + ch \ dom(p + ). Distinguish two cases based on x ∈ crit + ch :• If x ∈ D + K . By definition, xS ∈ C K , hence succ K S (x) is not defined. Moreover, we chose x ∈ crit + ch \ dom(p + ), so x ∈ dom(p + ). It follows that χ(xS) = ch(S). Since T |= ∃S - ∃S, we have xSS ∈ ∆ C K . Combined with our assumptions ∃S / ∈ θ K (ch(S)) and ch(S) / ∈ crit + ch , we obtain χ(xSS) = ch(S). Finally from (xS, xSS) ∈ S C K , we can infer</figDesc><table /></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>see Definition 13), to check legality w.r.t. input (Definition 14).</figDesc><table><row><cell cols="4">Introduce a conjunctive gate ∧</cell><cell>coverage σ taking as inputs:</cell></row><row><cell>• ∨</cell><cell>R∈gen K</cell><cell cols="3">for each positive role R ∈ dom(σ),</cell></row><row><cell cols="3">• the negation of ∨</cell><cell>R∈gen K</cell><cell>for each positive role R / ∈ dom(σ).</cell></row><row><cell cols="4">Introduce a conjunctive gate ∧</cell><cell>availability σ taking as inputs: k</cell><cell>∃ ≥k ind. of type t</cell><cell>for each type t being required k times by σ.</cell></row><row><cell cols="4">Introduce a conjunctive gate ∧</cell><cell>legal σ taking as inputs: ∧</cell><cell>coverage σ and ∧</cell><cell>availability σ .</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>This work was partially supported by <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_x8c6Crc">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div><p>Definition 26 (Order on C K ). We pick an order ≤ on ∆ C K such that: ≤ is breadth-first and for all w ∈ C K , if leader(w) is defined, then ∀R, wR ∈ ∆ C K ⇒ w • leader(w) ≤ wR.</p><p>We are now all setup for the main construction. Here is some intuition before this two-page long definition. Recall we explore the canonical model, especially anonymous elements being words ending by a particular positive role. Whenever we encounter a nilpotent role, we send it on its choice, because if ever it propagates some non-nilpotent roles, then the choice of well-typed elements ensures there are some further pre-existing matches on which to fold. Otherwise (and that is a big otherwise), if we previously encountered a bipotent role or a bidirectionnal match (that is a pair of element (a, b) such that both (a, b) and (b, a) are pre-existing matches), then it is costless to reuse it (protip: that's what the "flag" is for!). Otherwise, we look for such a bidirectionnal match around which would solve all further problems. If none, then the role you are encountering surely isn't bipotent: a nilpotent role propagating a bipotent role could not have let you end up on an element without a bidirectionnal match around (it would contradict the definition of a choice of well-typed element!), and non-nilpotent nor bipotent roles propagating a bipotent role could not have either (it would violate the absence of non-trivial propagation!). Therefore, at this point, the role you are encountering is either a subrole of S or of S -, but not both. In both cases, you are ensured to find a pre-existing match on which to fold (otherwise it would again violate either the choice of well-typed elements of the absence of non-trivial propagation).</p><p>Here is the more formal approach. Various properties are carried along the construction. Property 1 ensures nilpotent roles behave as expected. Properties 2 + and 2 -ensures we stay within the ABox matches. Property 3 ensures the flag is used as expected. Property 4 ensures violations of Conditions 1 and 2 are being used. Property 5 + and 5 -ensure violations of Condition 3 are being used.</p><p>Proof. By induction on (∆ C K , ≤), we build two mappings flag : ∆ C K → {0, 1} and χ : ∆ C K → Ind(A) and ensure alongside that any element e ∈ ∆ C K satisfies the following properties:</p><p>1. If e = wR ∈ ∆ C K with R nilpotent, then χ(wR) = choice K (θ K (R)).</p><p>2 + . If e = wR ∈ ∆ C K and T |= R S, then K |= S(χ(w), χ(wR)).</p><p>2 -. If e = wR ∈ ∆ C K and T |= R S -, then K |= S(χ(wR), χ(w)).</p><p>3. If e = wR ∈ ∆ C K and flag(wR), then K |= S(χ(w), χ(wR)) and K |= S(χ(wR), χ(w)).</p><p>4. If e = wR ∈ ∆ C K with R non-nilpotent and leader(w) is defined, then flag(wR) and χ(wR) = χ(w • leader(w)).</p><p>S and ¬flag(wR 1 ) and cause(wR 1 ) = ∃T with T |= T S and such that there exists wR 1 R 2 ∈ ∆ C K with T |= R 2 S, then K |= T(χ(w), χ(wR 1 )) or w = w T -and χ(w T -R 1 ) = χ(w ). Induction: Anonymous elements. Let wR ∈ ∆ C K . Assume all properties hold for e &lt; wR.</p><p>• If R is nilpotent, then we set χ(wR) := choice K (θ K (R)) and flag(wR) := 0. Property 1 is satisfied and all other properties trivially hold.</p><p>• Else if leader(w) is defined and w • leader(w) &lt; wR, then χ(w • leader(w)) is already defined, and we set χ(wR) := χ(w • leader(w)) and flag(wR) := 1. By induction hypothesis, properties hold for w • leader(w) and all transfer to wR, but Property 4. By definition however, Property 4 also holds for wR.</p><p>• Else if flag(w), then w must have shape w = w 0 R 0 (recall the initialization sets the flag of all individuals to 0). We set χ(wR) := χ(w 0 ) and flag(wR) := 1. Property 1, 5 + and 5 -trivially hold for wR. By induction hypothesis on w 0 R 0 , Property 3 for w 0 R 0 ensures that Properties 2 + , 2 -and 3 continue to hold for wR. Property 4 for wR is only relevant if leader(w) = R, in which case it trivially holds.</p><p>• Else if there exists an individual name b such that K |= S(χ(w), b)∧S(b, χ(w)), then we set χ(wR) := b and flag(wR) := 1. Therefore Property 2 + , 2 -, 3 hold for wR. Property 1, 5 + and 5 -trivially hold for wR. Again, Property 4 for wR is only relevant if leader(w) = R, in which case it trivially holds.</p><p>• Else if R is bipotent, that is T |= R S and T |= R S -. We distinguish several subcases, each leading to a contradiction.</p><p>-If w ∈ Ind(A), then w ∈ D ± K . Contradicts the absence of bidemanding individuals.</p><p>-If w = w 0 R 0 with R 0 nilpotent. By induction assumption and Property 1 and the definition of choice K , θ K (χ(w)) = {{S, S }, {S}, {S }}. This is a contradiction with not being in the previous case. -Otherwise w = w 0 R 0 , then leader(w 0 ) is not defined as Property 4 from induction hypothesis on w 0 R 0 would then contradicts flag(w) being false. In particular R 0 cannot be bipotent. Hence either T |= R 0 S or T |= R 0 S -, but not both. Both cases being symmetrical, we now focus on T |= R 0 S. For the triple (cause(w 0 ), R 0 , R), we have a propagation of S. As there are no non-trivial propagation of S, there must be an interference (Definition 11). Note that there cannot be an interference of the first type. Indeed, if U were such an interference, then flag(w) would be set, which we excluded in a previous case. Hence an interference should be of one of the other types: * If it is of type 2, then we have a bipotent U generated by ∃S -. Property 2 + from induction hypothesis gives K |= S(χ(w 0 ), χ(w)). Hence K |= ∃z U(χ(w), z). As U is bipotent and χ(w) cannot be a bidemanding element, there exists an individual b such that K |= S(χ(w), b) and K |= S -(χ(w), b), which we excluded in a previous case. * If it is of type 3, then cause(w 0 R 0 ) = ∃T with ∃T -generating a bipotent role. Property 5 + by induction hypothesis on w 0 R 0 provides either With this key-result in hand, we can now notice that, in the absence of bidemanding individuals, our problem is easy to decide: within TC 0 . Indeed, without bidemanding individuals, the best way to combine positive and negative demanding individual is still to pair them 1-to-1. Therefore, the optimal amount of matches can easily be decided by counting such elements. Lemma 12. Let A be an ABox and K := (T , A). If K admits no bidemanding individuals, then the minimal amount of matches can be decided within TC 0 .</p><p>Proof. Assume K does not admit any bidemanding individuals. Set a classic pairing p := (p + , p -) for positive and negative demanding individuals. We distinguish several cases, but the proof idea is always the same: in each case we exhibit the optimal amount of matches that can be easily computed from the types of individuals. We then prove it is minimal and exhibit a model with this precise amount of matches using Theorem 11 on ABox A * and some choice K * that will be specified in each case:</p><p>The redundant arguments to prove minimality are the following mappings, always defined and injective, I being a model of K:</p><p>reached with A * . A * does not admit demanding elements, and we choose, for all t ∈ Θ, and choice K * (t) := a.</p></div>
<div><head n="2.">Else if D</head><p>reached with A * not admitting demanding elements, assuming w.l.o.g p + (a) = a, and setting ∀t ∈ Θ, choice K * (t) := a.</p></div>
<div><head n="5.">Else if there exists</head><p>reached with A * not admitting demanding elements, assuming w.l.o.g p + (a) = b, and setting ∀t ∈ Θ, choice K * (t) := a.</p></div>
<div><head n="6.">Else if there exists</head><p>} not admitting demanding elements and setting ∀t ∈ Θ, choice K * (t) := ⊥. To ensure this amount of matches is still a lower bound for the amount of matches in any model I, we need to specify where the extra match can be found in any model I of K. Consider f : C K → I a homomorphism. Because of all the excluded previous cases, it can be verified that either (f (repr</p><p>) is an additional match in I (in particular, not already counted by one's favorite mapping ρ + or ρ -).</p></div>
<div><head n="7.">Else if there exists an individual</head><p>} not admitting demanding elements and ∀t ∈ Θ, choice K * (t) := ⊥. Again, we need to specify where the extra match can be found in any model</p><p>) is an additional match in I (in particular, not already counted by one's favorite mapping ρ + or ρ -). </p></div>
<div><head n="9.">Else if there exists an individual</head><p>) is an additional match in I (in particular, not already counted by one's favorite mapping ρ + or ρ -). 11. Otherwise. Optimum is m A with A not admitting demanding elements and setting ∀t ∈ Θ, choice K * (t) := ⊥.</p><p>To conclude the TC 0 membership proof, we describe the slight changes required to adapt the circuits already provided for the role cardinality queries:</p><p>• In the block "A closer look at roles and concepts over the input", one should extend the inputs to all subroles of R.</p><p>• The typing block should be adapted to fit the new typing notion (see Definition 20).</p><p>• All the blocks, each dedicated to a single strategy, can now be united as a single block computing D + K and D - K . • From this previous step, the typing block and the generated roles block, deciding if Situation 6, 8 or 10 occurs is easy, in which case one should add 1 to the final amount of matches.</p><p>We can now prove the desired reduction from our problem to MAXIMUM MATCHING.</p><p>Proof of the reduction. Let A be an ABox and K := (T , A).</p><p>If K does not admit bidemanding individuals, then Lemma 12 ensures we can actually compute the answer within TC 0 , in particular within L, and create a trivial instance of MAXIMUM MATCHING co-equivalent to it.</p><p>Otherwise, there are some bidemanding individuals. Consider then the following graph G K :</p><p>Claim:</p><p>[k, +∞] is a certain answer for q S w.r.</p><p>Notice the graph G and the integer m A + |V| -k + 1 are easily computable within L.</p><p>Consider a model I of K and a homomorphism f : C K → I. For each demanding individual x, we denote R x a role causing this element to be demanding (that is, a bipotent role for bidemanding elements, a subrole of S for positive demanding elements, a subrole of S -for negative demanding elements such that xR x ∈ ∆ C K ). Consider the following matching, induced by I:</p><p>Each edge from M I provides exactly one additional match: either through the pairing of a positive with a negative, or through the pairing of a bidemanding with another demanding given that one match was already present in between. Each non-covered vertex provides one additional match, being (x, succ I Rx (x)) for positive demanding uncovered elements, (succ I Ry (y), y) for negative demanding uncovered elements, and at least one of the latter two shapes for bidemanding elements. In addition with ABox matches, all these matches are distinct, hence there are at least B.4 Proof of TC 0 membership.</p><p>We now prove that if a TBox T does not admit a non-trivial propagation of S or S -, and does not admit a non-trivial pairing, then OMQA(q S , T ) is in TC 0 . Notice that if T satisfies T |= S S -, then for any ABox A, K = (T , A) does not admit bidemanding individuals. Indeed, the existence of a bidemanding individual a implies the existence of B and R such that B(a) ∈ A, T |= B ∃R, T |= R S and T |= R S -. If B is a concept name, this is non-trivial pairing. If B = ∃T, then to prevent a non-trivial pair, T |= T S and T |= T S -, which would prevent a from being bidemanding. In that case, Lemma 12 holds and solves the problem.</p><p>Otherwise T |= S S -, in which case the only possible demanding individuals are bidemanding individuals (which disallows Shapes 2, 3 + and 3 -from the proof just above) not touching any pre-existing match as T |= S S -(which also disallows Shape 4). In particular the easiest way to minimize the amount of matches is simply by introducing a self-S-loop on each bidemanding individual, and the optimal amount of matches is therefore m A + D ± K in general except if m A = D ± K = 0 and there exists a generated bipotent role R, in which case it is exactly 1. This is easily shown through the following injective mapping, providing at least D ± K non-ABox matches in any model I:</p><p>Furthermore, in the exception stated above the single match is found in any model I by considering where the representative repr K (R) = wR ∈ ∆ C K maps in I through a homomorphism f : C K → I. It gives a match (f (w), f (wR)), or alternatively (f (wR), f (w)) as R is bipotent (but if the model I is optimal enough, these two are the same match!). Notice that again, with slight adaptations of the circuits, this is still easily computable within TC 0 , the threshold gates being here essential to count the amount of bidemanding individuals.</p><p>C Proofs for Section 5.</p><p>C.1 Proof of Theorem 3.</p><p>Proof. Consider the ABox:</p><p>and set K = (T , A). Notice there are |S| + s∈S |s| ABox matches. We claim:</p><p>Consider the interpretation obtained from K in which we add, for each u ∈ s ∈ F the fact U(u, s * ) and V(s, s), which provide k additional matches from S(s, s). For the remaining s ∈ S, we can add the fact V(s, s * ), which does not provide an additional match. We obtain a model I F , with exactly |S| + s∈S |s| + k matches, being a countermodel.</p><p>(⇐). Assume (U, S, k) / ∈ SET COVER. Consider a model I of K and a homomorphism f : C K → I. For each u ∈ U, we associate a subset ρ(u) = s if f (uU) = s * and u ∈ s ∈ S, otherwise set ρ(u) = s u , where s u is an arbitrary set containing u. The image ρ(U) is a covering of U, hence |ρ(U)| ≥ k + 1. By definition, for each s ∈ ρ(U) there exists u ∈ S such that: either f (uU) = s * , or f (uU) = ŝ * for all ŝ such that u ∈ ŝ ∈ S. In the first case, (s, f (sV)) must be a new match as f (sV) cannot be s * . In the second case (u, f (uU)) is a new match. Therefore there are at least |S| + s∈S |s| + k + 1 matches in I.</p></div>
<div><head>C.2 Proof of Theorem 4.</head><p>Proof. Consider the ABox:</p><p>and set K = (T , A). Notice there are s∈S |s| ABox matches. We claim:</p><p>Consider the interpretation obtained from K in which we add, for each u ∈ s ∈ F the fact U(u, s) and V(s, s), which provide k additional matches from S(s, s). We obtain a model I F , with exactly s∈S |s| + k matches, being a countermodel.</p><p>(⇐). Assume (U, S, k) / ∈ SET COVER. Consider a model I of K and a homomorphism f : C K → I. For each u ∈ U, we associate a subset ρ(u) = s if f (uU) = s and u ∈ s ∈ S, otherwise set ρ(u) = s u , where s u is an arbitrary set containing u. The image ρ(U) is a covering of U, hence |ρ(U)| ≥ k + 1. By definition, for each s ∈ ρ(U) there exists u ∈ S such that: either f (uU) = s, or f (uU) = ŝ * for all ŝ such that u ∈ ŝ ∈ S. In the first case, (f (uUV), f (uU)) must be a new match as f (uUV) cannot be any v with v ∈ U (roles W prevent it!). In the second case (u, f (uU)) is a new match. Therefore there are at least</p><p>Introduce the following individual names:</p><p>Consider now the ABox given by:</p><p>Set K φ = (T , A φ ). Notice there are 2m ABoxes matches: t 1 . . . t m and f 1 , . . . f m . We claim:</p><p>Let I be a model of K φ and f :</p><p>) is an anonymous element, since U prevents f (x k U) to be equal to other individuals. As f (x k U) ∈ C I , it provides a new match. Otherwise, define the assignment induced by I as ρ I</p><p>, there exists a satisfied clause l i . For this i, the element f (l i V) cannot be equal to any individual (as V and ∃U -prevent it), and therefore provides a new match for q C . In all cases [2m + 1, +∞] is a certain answer of q C w.r.t. K φ .</p><p>(⇒). Assume ∃x ¬φ(x). Consider such a valuation ρ : x → {0, 1} such that ¬φ(ρ(x)). For each clause l i , there exists (at least) a variable x ki which invalidates l i . Consider the interpretation I ρ obtained from K φ in which we add facts</p><p>. By definition of variables x ki , we are ensured this interpretation I ρ is a model. It only has 2m matches, hence [2m + 1, +∞] is not a certain of q C w.r.t. K φ .</p><p>C.4 Proof of Theorem 6.</p><p>For the two L lower bounds, we proceed by reduction from the Undirected Forest Accessibility problem, known to be Lcomplete <ref type="bibr" target="#b19">[Cook and McKenzie, 1987]</ref>.</p><p>Undirected Forest Accessibility (UFA)</p></div>
<div><head>Input</head><p>Undirected acyclic graph (V, E) with two components, vertices s, t ∈ V Output Is t reachable from s ?</p><p>Proof. We start with L membership. Let us first describe how to compute, given an ABox A, the minimal number of matches of q S . Intuitively, whenever an outgoing R(v, v ) is required (by the presence of B(v)) but not already provided in the ABox, one aims at adding R(v, v ) in such a way that S(v, v ) is already present in the ABox. This is always possible, except for two cases: (i) there are no outgoing S from v, or (ii) all the S(v, v ) are such that B(v ) holds and S(v , v) holds as well.</p><p>In case (i), a new atom of the shape S(v, v ) has to be added, creating a new match. In the second case, since R ¬R -, one could create an inconsistency if the choice were to be done in a local fashion. Let us study how to perform optimally these choices.</p><p>We call exit point an individual v such that one of the three following conditions holds:</p><p>Intuitively, an exit point either already satisfies the concept inclusion B ∃R (the first two conditions) or can satisfy it in a globally optimal way by adding R(v, v ) (in the third case, if a model minimizing the number of matches contains R(v , v) and S(v , v), one can get another minimal mode by adding S(v , v * ) and S(v , v * )), where v * is a fresh element).</p><p>Let us thus consider the tradeoff graph of A having as vertices the individuals of A and an edge between u and v if it holds that S(u, v), S(v, u), B(u), B(v) ∈ A, and R(u, v), R(v, u) ∈ A. This graph may contain several connected components, which can be of several types: a. the connected component contains a cycle: there exists a consistent way to add R atoms wherever necessary in such a way that all the new R atoms fold on S atoms present in A; b. the connected component contains an exit point: similarly, add R atoms wherever necessary in such a way that all the new R atoms fold on S atoms present in A; c. the connected component is a tree and does not contain an exit point: an atom R(v, x) for which S(v, x) ∈ A has to be added. v can be chose arbitrarily among the vertices of the connected component, and x can be chosen to be a fresh element. Thus, the minimal number of matches is the number of pairs (v, v ) such that either R(v, v ) or S(v, v ) holds, plus the number of connected components of type c. in the previous case distinction. Algorithm 1 computes this minimum number of matches, and compare it to the number provided in input. Let us notice that checking for the existence of a cycle in a connected component can be done by making calls to an oracle for reachability in undirected graphs.</p><p>Algorithm 1 runs in logarithmic space, as undirected reachability is decidable in L, and L is low for itself. This proves membership to L.</p><p>For the lower bound, let us reduce UFA to our problem. Let G = (V, E) be an undirected acyclic graph with two components and let s, t ∈ V be two vertices. Consider the following ABox:</p><p>Data: An ABox A, an integer n Result: Yes if and only if <ref type="bibr">[n, +∞]</ref> is a certain answer for q S w.r. where v * is a fresh individual. Note that we have thus made both s and t exit points, and they are the only such individuals. Let us notice that A is first-order definable from G. We thus focus on the following claim:</p><p>is a certain answer for q S w.r.t. (T , A)</p><p>Let us first notice that in any model, there are 2|E| + 2 matches of q S , as there are that many matches from q S in A.</p><p>Let us consider the case where s is not reachable from t. As G has exactly two connected components, for any vertex v (distinct from both s and t), there exists a unique vertex among {s, t} that is reachable from v and a unique S-edge S(v, f(v)) outgoing from v on the shortest path to s or t (depending on which connected component v belongs). Let us consider the interpretation</p><p>I is a model of T : for any v such that B(v) holds, there is an atom R(v, v ). Moreover, if v is on the shortest path from v to s (resp. to t), then v cannot be on the shortest path from v to s (resp. to t), hence R I ∩ (R -) I = ∅. I is thus a model of A and T in which there are exactly 2|E| + 2 matches of q S , proving that if ((V, E), s, t) ∈ UFA, then [2|E| + 3, +∞] is not a certain answer of q S w.r.t. (T , A).</p><p>Let us now consider the case where s is reachable from t. We already know that in any model of A and T , there are 2|E| + 2 matches of q S . We prove there must be another match of q S . We show that there must be some R(v, v ) in any model such that S(v, v ) ∈ A. Let v be in the connected component that contains neither s nor t. Let us consider a maximal (possibly infinite) sequence v 1 , v 2 , . . . , v n with v 1 = v and such that for any i, R(v i , v i+1 ) belongs to I. As there are no cycle in G and that R ¬R -, there exists i such that S(v i , v i+1 ) ∈ A, which provides a new match for q S , which concludes the proof.</p><p>C.5 Proof of Theorem 6 for Concept Cardinality Queries.</p><p>Let us first state our theorem in the case of concept cardinality queries.</p><p>Theorem 12 (L-complete situation for concept cardinality queries). For the following TBox:</p><p>Proof. We start by proving L membership. Let us first notice that the minimum number of matches can only be one of the two following values:</p><p>which is the number of matches in the ABox on which concept inclusions have been applied;</p><p>• n + 1, which can be obtained by introducing a fresh element α, and adding R(v, α) for any v in Ind(A), as well C(α).</p><p>Let us consider a model I having n matches. Let f be a homomorphism from C K to I. Let v ∈ Ind(A) such that vR ∈ ∆ C K . Then:</p><p>• f (vR) ∈ Ind(A) (otherwise, a new match would be created);</p><p>• C(f (vR)) ∈ A or there is v s.t. R(v , v) ∈ A (otherwise, a new match would be created);</p><p>• T(v, f (vR)) ∈ A (otherwise I would not be a model)</p><p>• R(f (vR), v) ∈ A (otherwise I would not be a model)</p><p>would not be a model).</p><p>All the conditions except the last one can be checked for each individual separately. We call exit point an individual v for which either vR ∈ ∆ C K or there exists v such that by setting f (vR) = v , the first four conditions are satisfied, and the fifth one is satisfied by vacuity, i.e., v R ∈ ∆ C K .</p><p>Let us define the tradeoff graph G of A having as vertices the individuals of A and an edge {v, v } if and only if</p><p>This is called a tradeoff graph because if {v, v } is an edge, then we could either set f (vR) = v or f (v R) = v without creating new matches, but not both, as this would violate the negative role inclusion R ¬R -.</p><p>We claim that there exists a model with exactly n matches if and only if in every connected component of G there is either an exit point or a cycle. Indeed, notice that if {v, v } is an edge of the tradeoff graph, then adding an atom R(v, v ) does not increase the number of matches of q C . If there is an exit point v * in a connected component, there is a way to add an atom R(v * , v) without adding a match and with v not being in the same connected component as v * (by definition of the tradeoff graph). Then, by a breadth first traversal of the connected component, one can add R atoms as required. Similarly, when there is a cycle, one starts by such a cycle, and add other atoms in a breadth first fashion.</p><p>Conversely, if there exists a model with n matches, then f (vR) ∈ Ind(A) for any v such that aR is defined. Let v 1 , . . . , v n , . . . be a sequence such that f (v i R) = v i+1 whenever v i R ∈ ∆ C K , and such that v i is the last element of the sequence otherwise. If f (v i R) is not an exit point, then there is an edge {v i , v i+1 } in the tradeoff graph. If the sequence if finite, then the one before the last is an exit point. Otherwise, there must be a cycle in the connected component containing v 1 .</p><p>Algorithm 2 checks this condition. As it amounts to several reachability checks in an undirected graph, this algorithm can be made to run in L. There are |V| + 1 matches of q C in A. We prove that:</p><p>((V, E), s, t) ∈ UFA ⇐⇒ [|V| + 2, +∞] is a certain answer of q C w.r.t. (T , A).</p><p>Let us consider the case where s is not reachable from t. As (V, E) has exactly two connected components, for any vertex v (distinct from both s and t), there exists a unique vertex among {s, t} that is reachable from v and a unique vertex f (v) that is on the shortest path from v to s (or t). Let us consider the interpretation I = A ∪ {R(v, f(v)) | v ∈ V \ {s, t}}. I is a model of T : for any v such that B(v) holds, there is an atom R(v, v ). Moreover, if v is on the shortest path from v to s, then v cannot be on the shortest path from v to s, hence R I ∩ (R -) I = ∅. Moreover, {v, f (v)} ∈ E, hence (v, f (v)) ∈ T I . I is thus a model of A and T in which there are exactly |V| + 1 matches of q C , proving that if ((V, E), s, t) ∈ UFA, then [|V| + 2, +∞] ∈ q (T ,A) C . Let us now consider the case where s is reachable from t. We already know that in any model of A and T , there are at least |V| + 1 matches of q C . As there are no cycle in the connected component not containing s and t, in any model of (A, T ) there must be an individual v having an outgoing edge R(v, v ) with {v, v } ∈ E. As T(v, u) holds for any u such that {v, u} ∈ E, as well as for u = v * , v provides a novel match for q C , concluding the proof.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title />
		<author>
			<persName><surname>Aehlig</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Relativizing small complexity classes and their theories</title>
		<author>
			<persName><forename type="first">Klaus</forename><surname>Aehlig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phuong</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st International Workshop on Computer Science Logic (CSL)</title>
		<meeting>of the 21st International Workshop on Computer Science Logic (CSL)</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="374" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title />
		<author>
			<persName><surname>Artale</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The DL-Lite family and relations</title>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Artale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research (JAIR)</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1" to="69" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title />
		<author>
			<persName><surname>Baader</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Franz</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulrike</forename><surname>Sattler</surname></persName>
		</author>
		<title level="m">An Introduction to Description Logic</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title />
		<author>
			<persName><surname>Baget</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">Jean-Franc ¸ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence (JAR)</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Meghyn Bienvenu and Magdalena Ortiz. Ontology-mediated query answering with data-tractable description logics</title>
		<author>
			<persName><forename type="first">Ortiz</forename><surname>Bienvenu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tutorial Lectures of the 11th Reasoning Web International Summer School</title>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="218" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Answering counting queries over DL-Lite ontologies</title>
		<author>
			<persName><surname>Bienvenu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 29th International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>of the 29th International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="page" from="1608" to="1614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title />
		<author>
			<persName><surname>Calì</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A general datalog-based framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics (JWS)</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="57" to="83" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title />
		<author>
			<persName><surname>Calvanese</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Tractable reasoning and efficient query answering in description logics: The DL-Lite family</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning (JAR)</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Aggregate queries over ontologies</title>
		<author>
			<persName><surname>Calvanese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2nd International Workshop on Ontologies and Information Systems for the Semantic Web (ONISW)</title>
		<meeting>of the 2nd International Workshop on Ontologies and Information Systems for the Semantic Web (ONISW)</meeting>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="97" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Counting query answers over a DL-Lite knowledge base</title>
		<author>
			<persName><surname>Calvanese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 29th International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>of the 29th International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="page" from="1658" to="1666" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName><surname>Calvanese</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2005.05886v3</idno>
		<title level="m">Counting query answers over a DL-Lite knowledge base (extended version)</title>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title />
		<author>
			<persName><surname>Chandra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Constant depth reducibility</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ashok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><forename type="middle">J</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uzi</forename><surname>Stockmeyer</surname></persName>
		</author>
		<author>
			<persName><surname>Vishkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="423" to="439" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title />
		<author>
			<persName><forename type="first">Mckenzie</forename><surname>Cook</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Problems complete for deterministic logarithmic space</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Mckenzie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="394" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title />
		<author>
			<persName><surname>Edmonds</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Paths, trees and flowers</title>
		<author>
			<persName><forename type="first">Jack</forename><surname>Edmonds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Canadian Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="449" to="467" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title />
		<author>
			<persName><surname>Feier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Answer counting under guarded TGDs</title>
		<author>
			<persName><forename type="first">Cristina</forename><surname>Feier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcin</forename><surname>Przybylko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 24th International Conference on Database Theory (ICDT)</title>
		<meeting>of the 24th International Conference on Database Theory (ICDT)</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title />
		<author>
			<persName><forename type="first">Reutter</forename><surname>Kostylev</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Complexity of answering counting aggregate queries over DL-Lite</title>
		<author>
			<persName><forename type="first">V</forename><surname>Egor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><surname>Reutter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics (JWS)</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="94" to="111" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title />
		<author>
			<persName><surname>Poggi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Linking data to ontologies</title>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Data Semantics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="133" to="173" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title />
		<author>
			<persName><forename type="first">Vazirani</forename><surname>Rabin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Maximum matchings in general graphs through randomization</title>
		<author>
			<persName><forename type="first">O</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><forename type="middle">V</forename><surname>Rabin</surname></persName>
		</author>
		<author>
			<persName><surname>Vazirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title />
		<author>
			<persName><forename type="first">Xiao</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Ontologybased data access: A survey</title>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 27th International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>of the 27th International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="5511" to="5519" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</teiCorpus></text>
</TEI>