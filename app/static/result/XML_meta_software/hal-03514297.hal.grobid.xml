<?xml version='1.0' encoding='utf-8'?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 http://api.archives-ouvertes.fr/documents/aofr-sword.xsd">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>HAL TEI export of hal-03514297</title>
      </titleStmt>
      <publicationStmt>
        <distributor>CCSD</distributor>
        <availability status="restricted">
          <licence target="http://creativecommons.org/licenses/by/4.0/">Distributed under a Creative Commons Attribution 4.0 International License</licence>
        </availability>
        <date when="2024-04-22T04:08:38+02:00" />
      </publicationStmt>
      <sourceDesc>
        <p part="N">HAL API platform</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <listBibl>
        <biblFull>
          <titleStmt>
            <title xml:lang="en">Computing the Shapley Value of Facts in Query Answering</title>
            <author role="aut">
              <persName>
                <forename type="first">Daniel</forename>
                <surname>Deutch</surname>
              </persName>
              <email type="md5">820217167c4479d871c042ec7d10e2a5</email>
              <email type="domain">post.tau.ac.il</email>
              <idno type="idhal" notation="numeric">1122100</idno>
              <idno type="halauthorid" notation="string">627351-1122100</idno>
              <affiliation ref="#struct-115136" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Nave</forename>
                <surname>Frost</surname>
              </persName>
              <email type="md5">654e9604df3abcc07ee91efb2e3ca950</email>
              <email type="domain">mail.tau.ac.il</email>
              <idno type="idhal" notation="numeric">1122101</idno>
              <idno type="halauthorid" notation="string">2392816-1122101</idno>
              <affiliation ref="#struct-115136" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Benny</forename>
                <surname>Kimelfeld</surname>
              </persName>
              <email type="md5">080ea65593dced79d1f28f624544431b</email>
              <email type="domain">cs.technion.ac.il</email>
              <idno type="idhal" notation="numeric">1122102</idno>
              <idno type="halauthorid" notation="string">425194-1122102</idno>
              <affiliation ref="#struct-84142" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">MikaÃ«l</forename>
                <surname>Monet</surname>
              </persName>
              <email type="md5">6993dabf9e3bed50493f1aeab5876d8c</email>
              <email type="domain">inria.fr</email>
              <idno type="idhal" notation="numeric">1085321</idno>
              <idno type="halauthorid" notation="string">1055808-1085321</idno>
              <affiliation ref="#struct-432648" />
            </author>
            <editor role="depositor">
              <persName>
                <forename>MikaÃ«l</forename>
                <surname>Monet</surname>
              </persName>
              <email type="md5">6993dabf9e3bed50493f1aeab5876d8c</email>
              <email type="domain">inria.fr</email>
            </editor>
          </titleStmt>
          <editionStmt>
            <edition n="v1" type="current">
              <date type="whenSubmitted">2022-01-06 11:27:50</date>
              <date type="whenModified">2024-01-24 09:54:24</date>
              <date type="whenReleased">2022-01-06 11:37:03</date>
              <date type="whenProduced">2022-06-12</date>
              <date type="whenEndEmbargoed">2022-01-06</date>
              <ref type="file" target="https://inria.hal.science/hal-03514297/document">
                <date notBefore="2022-01-06" />
              </ref>
              <ref type="file" subtype="author" n="1" target="https://inria.hal.science/hal-03514297/file/2112.08874.pdf">
                <date notBefore="2022-01-06" />
              </ref>
            </edition>
            <respStmt>
              <resp>contributor</resp>
              <name key="967253">
                <persName>
                  <forename>MikaÃ«l</forename>
                  <surname>Monet</surname>
                </persName>
                <email type="md5">6993dabf9e3bed50493f1aeab5876d8c</email>
                <email type="domain">inria.fr</email>
              </name>
            </respStmt>
          </editionStmt>
          <publicationStmt>
            <distributor>CCSD</distributor>
            <idno type="halId">hal-03514297</idno>
            <idno type="halUri">https://inria.hal.science/hal-03514297</idno>
            <idno type="halBibtex">deutch:hal-03514297</idno>
            <idno type="halRefHtml">&lt;i&gt;SIGMOD Conference 2022&lt;/i&gt;, Jun 2022, Philadelphia, United States</idno>
            <idno type="halRef">SIGMOD Conference 2022, Jun 2022, Philadelphia, United States</idno>
          </publicationStmt>
          <seriesStmt>
            <idno type="stamp" n="CNRS">CNRS - Centre national de la recherche scientifique</idno>
            <idno type="stamp" n="INRIA">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="INRIA-LILLE">INRIA Lille - Nord Europe</idno>
            <idno type="stamp" n="INRIA_TEST">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="TESTALAIN1">TESTALAIN1</idno>
            <idno type="stamp" n="CRISTAL">Centre de Recherche en Informatique, Signal et Automatique de Lille (CRISTAL)</idno>
            <idno type="stamp" n="INRIA2">INRIA 2</idno>
            <idno type="stamp" n="CRISTAL-LINKS" corresp="CRISTAL">CRISTAL-LINKS</idno>
            <idno type="stamp" n="UNIV-LILLE">UniversitÃ© de Lille</idno>
            <idno type="stamp" n="TEST-HALCNRS">Collection test HAL CNRS</idno>
            <idno type="stamp" n="INRIA-ISRAEL">COPUBLICATION INRIA ISRAEL</idno>
          </seriesStmt>
          <notesStmt>
            <note type="audience" n="2">International</note>
            <note type="invited" n="0">No</note>
            <note type="popular" n="0">No</note>
            <note type="peer" n="1">Yes</note>
            <note type="proceedings" n="1">Yes</note>
          </notesStmt>
          <sourceDesc>
            <biblStruct>
              <analytic>
                <title xml:lang="en">Computing the Shapley Value of Facts in Query Answering</title>
                <author role="aut">
                  <persName>
                    <forename type="first">Daniel</forename>
                    <surname>Deutch</surname>
                  </persName>
                  <email type="md5">820217167c4479d871c042ec7d10e2a5</email>
                  <email type="domain">post.tau.ac.il</email>
                  <idno type="idhal" notation="numeric">1122100</idno>
                  <idno type="halauthorid" notation="string">627351-1122100</idno>
                  <affiliation ref="#struct-115136" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Nave</forename>
                    <surname>Frost</surname>
                  </persName>
                  <email type="md5">654e9604df3abcc07ee91efb2e3ca950</email>
                  <email type="domain">mail.tau.ac.il</email>
                  <idno type="idhal" notation="numeric">1122101</idno>
                  <idno type="halauthorid" notation="string">2392816-1122101</idno>
                  <affiliation ref="#struct-115136" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Benny</forename>
                    <surname>Kimelfeld</surname>
                  </persName>
                  <email type="md5">080ea65593dced79d1f28f624544431b</email>
                  <email type="domain">cs.technion.ac.il</email>
                  <idno type="idhal" notation="numeric">1122102</idno>
                  <idno type="halauthorid" notation="string">425194-1122102</idno>
                  <affiliation ref="#struct-84142" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">MikaÃ«l</forename>
                    <surname>Monet</surname>
                  </persName>
                  <email type="md5">6993dabf9e3bed50493f1aeab5876d8c</email>
                  <email type="domain">inria.fr</email>
                  <idno type="idhal" notation="numeric">1085321</idno>
                  <idno type="halauthorid" notation="string">1055808-1085321</idno>
                  <affiliation ref="#struct-432648" />
                </author>
              </analytic>
              <monogr>
                <meeting>
                  <title>SIGMOD Conference 2022</title>
                  <date type="start">2022-06-12</date>
                  <settlement>Philadelphia</settlement>
                  <country key="US">United States</country>
                </meeting>
                <imprint />
              </monogr>
            </biblStruct>
          </sourceDesc>
          <profileDesc>
            <langUsage>
              <language ident="en">English</language>
            </langUsage>
            <textClass>
              <classCode scheme="halDomain" n="info">Computer Science [cs]</classCode>
              <classCode scheme="halTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halOldTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halTreeTypology" n="COMM">Conference papers</classCode>
            </textClass>
            <abstract xml:lang="en">
              <p>The Shapley value is a game-theoretic notion for wealth distribution that is nowadays extensively used to explain complex data-intensive computation, for instance, in network analysis or machine learning. Recent theoretical works show that query evaluation over relational databases fits well in this explanation paradigm. Yet, these works fall short of providing practical solutions to the computational challenge inherent to the Shapley computation. We present in this paper two practically effective solutions for computing Shapley values in query answering. We start by establishing a tight theoretical connection to the extensively studied problem of query evaluation over probabilistic databases, which allows us to obtain a polynomial-time algorithm for the class of queries for which probability computation is tractable. We then propose a first practical solution for computing Shapley values that adopts tools from probabilistic query evaluation. In particular, we capture the dependence of query answers on input database facts using Boolean expressions (data provenance), and then transform it, via Knowledge Compilation, into a particular circuit form for which we devise an algorithm for computing the Shapley values. Our second practical solution is a faster yet inexact approach that transforms the provenance to a Conjunctive Normal Form and uses a heuristic to compute the Shapley values. Our experiments on TPC-H and IMDB demonstrate the practical effectiveness of our solutions.</p>
            </abstract>
          </profileDesc>
        </biblFull>
      </listBibl>
    </body>
    <back>
      <listOrg type="structures">
        <org type="laboratory" xml:id="struct-115136" status="VALID">
          <orgName>School of Computer Science</orgName>
          <orgName type="acronym">TAU-CS</orgName>
          <desc>
            <address>
              <addrLine>Schreiber Building, Tel Aviv University, P.O.B. 39040, Ramat Aviv, Tel Aviv 69978</addrLine>
              <country key="IL" />
            </address>
            <ref type="url">http://www.cs.tau.ac.il/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-63133" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-84142" status="VALID">
          <idno type="IdRef">03264387X</idno>
          <idno type="ISNI">0000000121102151</idno>
          <idno type="ROR">https://ror.org/03qryx823</idno>
          <orgName>Technion - Israel Institute of Technology [Haifa]</orgName>
          <desc>
            <address>
              <addrLine>Technion City, Haifa 3200003</addrLine>
              <country key="IL" />
            </address>
            <ref type="url">https://www.technion.ac.il/en/</ref>
          </desc>
        </org>
        <org type="researchteam" xml:id="struct-432648" status="VALID">
          <idno type="RNSR">201321077H</idno>
          <orgName>Linking Dynamic Data</orgName>
          <orgName type="acronym">LINKS</orgName>
          <date type="start">2015-01-01</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/equipes/links</ref>
          </desc>
          <listRelation>
            <relation active="#struct-104752" type="direct" />
            <relation active="#struct-300009" type="indirect" />
            <relation active="#struct-410272" type="direct" />
            <relation name="UMR9189" active="#struct-120930" type="indirect" />
            <relation name="UMR9189" active="#struct-374570" type="indirect" />
            <relation name="UMR9189" active="#struct-441569" type="indirect" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-63133" status="VALID">
          <idno type="ROR">https://ror.org/04mhzgx49</idno>
          <orgName>Tel Aviv University</orgName>
          <orgName type="acronym">TAU</orgName>
          <desc>
            <address>
              <addrLine>Tel Aviv 699780</addrLine>
              <country key="IL" />
            </address>
            <ref type="url">https://english.tau.ac.il/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-104752" status="VALID">
          <idno type="RNSR">200818245B</idno>
          <idno type="ROR">https://ror.org/04eej9726</idno>
          <orgName>Inria Lille - Nord Europe</orgName>
          <desc>
            <address>
              <addrLine>Parc Scientifique de la Haute Borne 40, avenue Halley BÃ¢t.A, Park Plaza 59650 Villeneuve d'Ascq</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/lille/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300009" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-300009" status="VALID">
          <idno type="ROR">https://ror.org/02kvxyf05</idno>
          <orgName>Institut National de Recherche en Informatique et en Automatique</orgName>
          <orgName type="acronym">Inria</orgName>
          <desc>
            <address>
              <addrLine>Domaine de VoluceauRocquencourt - BP 10578153 Le Chesnay Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/en/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-410272" status="VALID">
          <idno type="IdRef">18388695X</idno>
          <idno type="RNSR">201521249L</idno>
          <idno type="ROR">https://ror.org/05vrs3189</idno>
          <orgName>Centre de Recherche en Informatique, Signal et Automatique de Lille - UMR 9189</orgName>
          <orgName type="acronym">CRIStAL</orgName>
          <date type="start">2015-01-01</date>
          <desc>
            <address>
              <addrLine>UniversitÃ© de Lille - Campus scientifique - BÃ¢timent ESPRIT - Avenue Henri PoincarÃ© - 59655 Villeneuve dâ€™Ascq</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cristal.univ-lille.fr/</ref>
          </desc>
          <listRelation>
            <relation name="UMR9189" active="#struct-120930" type="direct" />
            <relation name="UMR9189" active="#struct-374570" type="direct" />
            <relation name="UMR9189" active="#struct-441569" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-120930" status="VALID">
          <idno type="IdRef">256304629</idno>
          <idno type="ISNI">0000000122034461</idno>
          <idno type="ROR">https://ror.org/01x441g73</idno>
          <orgName>Centrale Lille</orgName>
          <desc>
            <address>
              <addrLine>Ã‰cole Centrale de Lille - CitÃ© Scientifique - CS 20048 59651 Villeneuve d'Ascq Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://centralelille.fr/</ref>
          </desc>
        </org>
        <org type="regroupinstitution" xml:id="struct-374570" status="VALID">
          <idno type="IdRef">223446556</idno>
          <idno type="ISNI">0000 0001 2242 6780</idno>
          <idno type="ROR">https://ror.org/02kzqn938</idno>
          <idno type="Wikidata">Q3551621</idno>
          <orgName>UniversitÃ© de Lille</orgName>
          <desc>
            <address>
              <addrLine>EPE UniversitÃ© de Lille. -- 42 rue Paul Duez, 59000 Lille</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.univ-lille.fr/</ref>
          </desc>
        </org>
        <org type="regroupinstitution" xml:id="struct-441569" status="VALID">
          <idno type="IdRef">02636817X</idno>
          <idno type="ISNI">0000000122597504</idno>
          <idno type="ROR">https://ror.org/02feahw73</idno>
          <orgName>Centre National de la Recherche Scientifique</orgName>
          <orgName type="acronym">CNRS</orgName>
          <date type="start">1939-10-19</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cnrs.fr/</ref>
          </desc>
        </org>
      </listOrg>
    </back>
  <teiCorpus>
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computing the Shapley Value of Facts in Query Answering</title>
				<funder ref="#_WQYsqJu">
					<orgName type="full">Israel Science Foundation</orgName>
					<orgName type="abbreviated">ISF</orgName>
				</funder>
				<funder ref="#_ZHx227U">
					<orgName type="full">European Union</orgName>
				</funder>
				<funder ref="#_4RGR6kx">
					<orgName type="full">German Research Foundation (DFG)</orgName>
				</funder>
				<funder>
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
				<date type="published" when="2022-01-02">2 Jan 2022</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
							<email>danielde@post.tau.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Nave</forename><surname>Frost</surname></persName>
							<email>navefrost@mail.tau.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
							<email>bennyk@cs.technion.ac.il</email>
						</author>
						<author>
							<persName><forename type="first">MikaÃ«l</forename><surname>Monet</surname></persName>
							<email>mikael.monet@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Tel Aviv University Blavatnik School of Computer Science</orgName>
								<address>
									<settlement>Tel Aviv</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Tel Aviv University Blavatnik School of Computer Science</orgName>
								<address>
									<settlement>Tel Aviv</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Faculty of Computer Science</orgName>
								<orgName type="institution">Technion -Israel Institute of Technology</orgName>
								<address>
									<settlement>Haifa</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution">Centrale Lille</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">CRIStAL</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Computing the Shapley Value of Facts in Query Answering</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2022-01-02">2 Jan 2022</date>
						</imprint>
					</monogr>
					<idno type="MD5">CB09C462A2C6E0B0454B4D683F9E39C0</idno>
					<idno type="arXiv">arXiv:2112.08874v2[cs.DB]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>The Shapley value is a game-theoretic notion for wealth distribution that is nowadays extensively used to explain complex data-intensive computation, for instance, in network analysis or machine learning. Recent theoretical works show that query evaluation over relational databases fits well in this explanation paradigm. Yet, these works fall short of providing practical solutions to the computational challenge inherent to the Shapley computation. We present in this paper two practically effective solutions for computing Shapley values in query answering. We start by establishing a tight theoretical connection to the extensively studied problem of query evaluation over probabilistic databases, which allows us to obtain a polynomial-time algorithm for the class of queries for which probability computation is tractable. We then propose a first practical solution for computing Shapley values that adopts tools from probabilistic query evaluation. In particular, we capture the dependence of query answers on input database facts using Boolean expressions (data provenance), and then transform it, via Knowledge Compilation, into a particular circuit form for which we devise an algorithm for computing the Shapley values. Our second practical solution is a faster yet inexact approach that transforms the provenance to a Conjunctive Normal Form and uses a heuristic to compute the Shapley values. Our experiments on TPC-H and IMDB demonstrate the practical effectiveness of our solutions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>Explaining query answers has been the objective of extensive research in recent years <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30]</ref>. A prominent approach is to devise an explanation based on the facts that were used for deriving the answers; these facts are often termed provenance or lineage of the query answer. For illustration, consider a query asking whether there exists a route from the USA to France with at most one connection over a database of airports and flights. The answer is Boolean, and upon receiving a positive answer one may seek explanations of why it is so. The basis for such explanations would include all details of qualifying routes that are used in the derivation of the answer. Unfortunately, the number of relevant routes might be huge (specifically, quadratic in the database size). Moreover, it is conceivable that different facts differ considerably in their importance to the answer at hand; for instance, some flights may be crucial to enabling the USA-France connection, while others may be easily replaced by alternatives.</p><p>To address these issues, there have been several proposals for principled ways of quantifying the contribution of input facts to query answers <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30]</ref>. We focus here on the recent approach of Livshits et al. <ref type="bibr" target="#b19">[20]</ref> that applies to this setting the notion of Shapley values <ref type="bibr" target="#b31">[32]</ref>-a game-theoretic function for distributing the wealth of a team in a cooperative game. This function has strong theoretical justifications <ref type="bibr" target="#b27">[28]</ref>, and indeed, it has been applied across various fields such as economics, law, environmental science, and network analysis. It has also been used for explanations in data-centric paradigms such as knowledge representation <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b38">39]</ref> and machine learning <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b21">22]</ref>. In the context of relational databases, given a query ğ‘( x), a database ğ·, an input fact ğ‘“ âˆˆ ğ· and a tuple t of same arity as x, the Shapley value of ğ‘“ in ğ· for query ğ‘( x) and tuple t intuitively represents the contribution of ğ‘“ to the presence (or absence) of t in the query result.</p><p>Livshits et al. <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref> initiated the study of the computational complexity of calculating Shapley values in query answering. They showed mainly lower bounds on the complexity of the problem, with the exception of the sub-class of self-join free SPJ queries called hierarchical, where they gave a polynomial-time algorithm. The results are more positive if imprecision is allowed, as they showed that the problem admits a tractable approximation scheme (FPRAS, to be precise) via Monte Carlo sampling. The state of affairs is that the class of known tractable cases (namely the hierarchical conjunctive queries) is highly restricted, and the approximation algorithms with theoretical guarantees are impractical in the sense that they require a large number of executions of the query over database subsets (the samples). Hence, the theoretical analysis of Livshits et al. <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref> does not provide sufficient evidence of practical feasibility for adopting the Shapley value as a measure of responsibility in query answering. Moreover, the results of Livshits et al. <ref type="bibr" target="#b19">[20]</ref> imply that, for self-join free SPJ queries the class of tractable queries for computing Shapley values coincides with the class of tractable queries in probabilistic tuple-independent databases <ref type="bibr" target="#b6">[7]</ref>. Yet, no direct connection has been made between these two problems and, theoretically speaking, it has been left unknown whether algorithms for probabilistic databases can be used for Shapley computation.</p><p>Recently, Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> and Arenas et al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> investigated the computational complexity of the SHAP-score <ref type="bibr" target="#b21">[22]</ref>, a notion used in machine learning for explaining the predictions of a model. While both are based on the general notion of Shapley value, the SHAP-score for machine learning and Shapley values for databases are different. In the latter case, the players are the tuples of the database and the game function that is used is simply the value of the query on a subset of the database, while in the former case, the players are the features of the model and the game function is a conditional expectation of the model's output (see Section 6.2 for a more formal definition of the SHAP-score). Remarkably, Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> have shown that computing the SHAP-score is equivalent (in terms of polynomial-time reductions) to the problem of computing the expected value of the model. One of our contributions is to show that the techniques developed by <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b35">36]</ref> can be adapted to the context of Shapley values for databases. For instance, by adapting to our context the proof of Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> that computing the SHAP-score reduces to computing the expected value of the model, we resolve the aforementioned open question affirmatively: we prove that Shapley computation can be efficiently (polynomial-time) reduced to probabilistic query answering. Importantly, this applies not only to the restricted class of SPJ queries without self-joins, but to every database query. Hence, extending theory to practice, one can compute the Shapley values using a query engine for probabilistic databases.</p><p>In turn, a common approach that was shown to be practically effective for probabilistic databases is based on Knowledge Compilation <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref>. In a nutshell, the idea is to first compute the Boolean provenance of a given output tuple in the sense of Imielinski and Lipski <ref type="bibr" target="#b16">[17]</ref>, and then to "compile" the provenance into a particular circuit form that is more favorable for probability computation. Specifically, the target class of this compilation is that of deterministic and decomposable circuits (d-D). In our case, rather than going through probabilistic databases, we devise a more efficient approach that computes the Shapley values directly from the d-D circuit. This is similar to how Arenas at al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> directly prove that the SHAP-score can be computed efficiently over such circuits, without using the more general results of <ref type="bibr" target="#b35">[36]</ref>. By adapting the proof of <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, we show how, given a d-D circuit representing the provenance of an output tuple, we can efficiently compute the Shapley value of every input fact. While the aforementioned properties of the circuit are not guaranteed in general (beyond the class of hierarchical queries), we empirically show the applicability and usefulness of the approach even for non-hierarchical queries.</p><p>Our experimental results (see below) indicate that our exact computation algorithm is fast in most cases, but is too costly in others. For the latter cases, we propose a heuristic approach to retrieve the relative order of the facts by their Shapley values, without actually computing these values. Indeed, determining the most influential facts is in many cases already highly useful, even if their precise contribution remains unknown. The solution that we propose to this end is termed CNF Proxy; it is based on a transformation of the provenance to Conjunctive Normal Form (CNF) and using it to compute proxy values intuitively based on (1) the number of clauses in which a variable occur and (2) its alternatives in each clause. These are two aspects that are correlated with Shapley values. The proxy values may be very different from the real Shapley values, and yet, when we order facts according to their proxy values we may intuitively get an ordering that is similar to the order via Shapley. Our experiments validate that this intuition indeed holds for examined benchmarks.</p><p>We have experimented with multiple queries from the two standard benchmarks TPC-H and IMDB. Our main findings are as follows. In most cases (98.67% of the IMDB output tuples and 83.83% for TPC-H), our exact computation algorithm terminates in 2.5 seconds or less, given the provenance expression. In the vast majority of remaining cases the execution is very costly, typically running out of memory already in the Knowledge Compilation step. By contrast, our inexact solution CNF Proxy is extremely fast even for these hard cases -it typically terminates in a few milliseconds with the worst observed case (an outlier) being 4 seconds. In fact, it is faster by several orders of magnitude than sampling-based approximation techniques (the Monte Carlo sampling proposed in <ref type="bibr" target="#b19">[20]</ref> as well as a popular sampling-based solution for Shapley values in Machine Learning (Kernel SHAP <ref type="bibr" target="#b21">[22]</ref>). To measure quality, we use CNF Proxy to rank the input tuples, and compared the obtained ranked lists to ranking by actual Shapley values (in cases where exact computation has succeeded), using the standard measures of nDCG and Precision@k. Our solution outperforms the competitors in terms of quality as well.</p><p>We then propose a simple hybrid approach: execute the exact algorithm until it either terminates or a timeout elapses. If we have reached the timeout, resort to executing CNF Proxy and rank the facts based on the obtained values. We show experiments with different timeout values, justifying our choice of 2.5 seconds.</p><p>Hence, our contributions are both of a theoretical and practical nature and can be summarized as follows.</p><p>â€¢ By adapting the proof technique of <ref type="bibr" target="#b35">[36]</ref>, we establish a fundamental result about the complexity of computing Shapley values over relational queries: Shapley values can be computed in polynomial time-in data complexity-whenever the query can be evaluated in polynomial time over tupleindependent probabilistic databases (Proposition 3.1). This holds for every query. â€¢ By adapting the proof technique of <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, we devise a novel algorithm for computing Shapley values for query evaluation via compilation to a deterministic and decomposable circuit (Proposition 4.4). We show that this algorithm is practical and has the theoretical guarantee of running in polynomial time in the size of the circuit. â€¢ We present a novel heuristic, CNF Proxy, that is fast yet inexact, and is practically effective if we are interested in ranking input facts by their contribution rather than computing exact Shapley values (Section 5). â€¢ We describe a thorough experimental study of our algorithms over realistic data and show their efficiency (Section 6).</p></div>
<div><head>Related work.</head><p>Existing models for explaining database query results may roughly be divided in two categories: (1) models that are geared for tracking/presenting provenance of output tuples, e.g., the set of all input facts participating in their computation <ref type="bibr" target="#b5">[6]</ref>, possibly alongside a description of the ways they were used, in different granularity levels (e.g., <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b13">14]</ref>); (2) models that quantify contributions of input facts <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30]</ref>, which is the approach that we follow here. Works in the latter context often have connections with the influential line of work on probabilistic databases <ref type="bibr" target="#b32">[33]</ref>, and we show that this is the case for Shapley computation as well.</p><p>As already mentioned, an important point of comparison is the work of Van den Broeck et al. <ref type="bibr" target="#b35">[36]</ref> and that of Arenas et al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> on the SHAP-score. While we show that the proof techniques developed in this area can be adapted to the context of relational databases, we point out that the two sets of results obtained (for SHAP-score and for Shapley values for databases) seem incomparable, as we do not see a way of proving results for Shapley value for query answering using the results on the SHAP-score, or vice-versa. In fact, this adaptation only works up to a certain point. For instance, the efficiency axiom of the Shapley value immediately implies that computing the expected value of a model can be reduced in polynomial time to computing the SHAP-score of its features; in contrast, this axiom does not seem to yield any clear such implication in our context (see our Open Problem 1 and the discussion around it).</p><p>Paper organization. We formalize the notion of Shapley values for query answering in Section 2. In Section 3 we present the theoretical connection to probabilistic databases and its implications. Our exact computation algorithm is presented in Section 4 and our heuristic in Section 5. Experimental results are presented in Section 6 and we conclude in Section 7.</p></div>
<div><head n="2">THE SHAPLEY VALUE OF FACTS</head><p>We define here the main notion and illustrate it with an example.</p><p>Relational databases and queries. Let Î£ = {ğ‘… 1 , . . . , ğ‘… ğ‘› } be a signature, consisting of relation names ğ‘… ğ‘– each with its associated arity ar(ğ‘… ğ‘– ) âˆˆ N, and Const be a set of constants. A fact over (Î£, Const) is simply a term of the form ğ‘…(ğ‘ 1 , . . . , ğ‘ ar(ğ‘…) ), for ğ‘… âˆˆ Î£ and ğ‘ ğ‘– âˆˆ Const. A (Î£, Const)-database ğ·, or simply a database ğ·, is a finite set of facts over (Î£, Const). We assume familiarity with the most common classes of query languages and refer the reader to <ref type="bibr" target="#b0">[1]</ref> for the basic definitions. In particular, we recall the equivalence between relational algebra and relational calculus <ref type="bibr" target="#b0">[1]</ref>, and the fact that Select-Project-Join-Union (SPJU) queries are equivalent to unions of conjunctive queries (UCQs). Depending of the context and for consistency with relevant past publications, we will use terminology of either relational calculus or relational algebra. What we call a Boolean query is a query ğ‘ that takes as input a database ğ· and outputs ğ‘(ğ·) âˆˆ {0, 1}. If ğ‘( x) is a query with free variables x and t is a tuple of constants of same length as x, we denote by ğ‘[ x/ t] the Boolean query defined by: ğ‘[ x/ t] (ğ·) = 1 if and only if t is in the output of ğ‘( x) on ğ·.</p><p>Shapley values of facts. Following <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref>, we use the notion of Shapley values <ref type="bibr" target="#b31">[32]</ref> to attribute a contribution to facts of an input database. In this context, the database ğ· is traditionally partitioned into two sets of facts: a set ğ· x of so-called exogenous facts, and a set ğ· n of endogenous facts. The idea is that exogenous facts are considered as given, while endogenous facts are those to which we would like to attribute contributions. Let ğ‘ be a Boolean query and ğ‘“ âˆˆ ğ· n be an endogenous fact. The Shapley value of ğ‘“ in ğ· for query ğ‘, denoted Shapley(ğ‘, ğ· n , ğ· x , ğ‘“ ), is defined as</p><formula xml:id="formula_0">Shapley(ğ‘, ğ· n , ğ· x , ğ‘“ ) def =<label>(1)</label></formula><formula xml:id="formula_1">âˆ‘ï¸ ğ¸ âŠ†ğ· n \{ğ‘“ } |ğ¸|!(|ğ· n | -|ğ¸| -1)! |ğ· n |! ğ‘(ğ· x âˆª ğ¸ âˆª {ğ‘“ }) -ğ‘(ğ· x âˆª ğ¸) .</formula><p>Notice that here, |ğ¸|!(|ğ· n | -|ğ¸| -1)! is the number of permutations of ğ· n with all endogenous facts in ğ¸ appearing first, then ğ‘“ , and finally, all the other endogenous facts. Intuitively then, the value Shapley(ğ‘, ğ· n , ğ· x , ğ‘“ ) represents the contribution of ğ‘“ to the query's output: the higher this value is, the more ğ‘“ helps in satisfying ğ‘.</p><p>For non-Boolean queries ğ‘( x), we are interested in the Shapley value of the fact ğ‘“ for every individual tuple t in the output <ref type="bibr" target="#b19">[20]</ref>. The extension to non-Boolean ğ‘( x) is then straightforward: the Shapley value of the fact ğ‘“ for the answer t to ğ‘( x) is the value Shapley(ğ‘[ x/ t], ğ· n , ğ· x , ğ‘“ ). Therefore, the computational challenge reduces to that of the Boolean query ğ‘ [ x/ t]. Hence, in the theoretical analysis we focus on Boolean queries, and we go back to considering non-Boolean queries when we study the implementation aspects (starting in Section 4.2).</p><p>Example 2.1. Consider the database ğ· and the Boolean query ğ‘ from Figures <ref type="figure" target="#fig_1">1a</ref> and<ref type="figure" target="#fig_1">1c</ref>. All facts in table Flights are endogenous, while facts in Airports are exogenous. To alleviate the notation we write, e.g., ğ‘ 1 for Flights(JFK, CDG). The query ğ‘ checks if there are routes from "USA" to "FR" with one or less connecting flights. Let us compute the Shapley value of all endogenous facts. First, we notice that fact ğ‘ 8 is not part of any valid route, so Shapley(ğ‘, ğ· n , ğ· x , ğ‘ 8 ) = 0 by Equation <ref type="bibr" target="#b0">(1)</ref>. Next, let us focus on ğ‘ 1 . Since ğ‘ 1 is a valid route on its own, adding it to any subset of (endogenous) facts ğ¸ such that ğ¸ does not contain a valid route results in ğ‘(ğ· x âˆª ğ¸ âˆª {ğ‘ 1 }) -ğ‘(ğ· x âˆª ğ¸) = 1 (for all other subsets the difference will be 0). The relevant subsets are the empty set, all singletons {ğ‘ ğ‘– } for 2 â‰¤ ğ‘– â‰¤ 8 (7 singletons), all the pairs of tuples from ğ‘ 2 , . . . , ğ‘ 8 excluding the pairs {ğ‘ 2 , ğ‘ 4 }, {ğ‘ 2 , ğ‘ 5 }, {ğ‘ 3 , ğ‘ 4 }, {ğ‘ 3 , ğ‘ 5 }, and {ğ‘ 6 , ğ‘ 7 } (so 7  2 -5 = 16 pairs), the quadruples {ğ‘ 2 , ğ‘  </p><formula xml:id="formula_2">Shapley(ğ‘, ğ· n , ğ· x , ğ‘ 1 ) = 1 â€¢ 0! â€¢ 7! 8! + 7 â€¢ 1! â€¢ 6! 8! + 16 â€¢ 2!5! 8! + 14 â€¢ 3!4! 8! + 4 â€¢ 4!3! 8! = 43</formula></div>
<div><head n="3">REDUCTION TO PROBABILISTIC DATABASES</head><p>In this section we investigate the complexity of computing Shapley values. As explained in the previous section, the non-Boolean setting of the problem may be reduced to that of Boolean queries, so we will study the following problem for a given Boolean query ğ‘.</p></div>
<div><head>PROBLEM: Shapley(ğ‘)</head><p>INPUT: A database ğ· = ğ· x âˆª ğ· n and an endogenous fact ğ‘“ âˆˆ ğ· n . OUTPUT: The value Shapley(ğ‘, ğ· n , ğ· x , ğ‘“ ).</p><p>Note that for the sake of complexity analysis, the query ğ‘ is assumed to be fixed, so that each query gives rise to a different computational problem; we are then considering what is called the data complexity <ref type="bibr" target="#b36">[37]</ref>. This assumption is motivated by the fact that in practice, the queries are much smaller than the databases.</p><p>The complexity of this problem has been studied in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref>, where in particular a dichotomy has been obtained for self-join-free Boolean conjunctive queries (sjfbcqs). There, the authors show that, for every sjfbcq ğ‘, either ğ‘ is hierarchical (we will not need to define this notion here) and Shapley(ğ‘) can be solved in polynomial time, or ğ‘ is not hierarchical and then Shapley(ğ‘) is intractable (specifically, FP Routes from "USA" to "FR" with one or less connecting flights</p><formula xml:id="formula_3">ğ‘ 1 = âˆƒğ‘¥, ğ‘¦ : Airports(ğ‘¥, "USA") âˆ§ Airports(ğ‘¦, "FR") âˆ§ Flights(ğ‘¥, ğ‘¦) ğ‘ 2 = âˆƒğ‘¥, ğ‘¦, ğ‘§ : Airports(ğ‘¥, "USA") âˆ§ Airports(ğ‘§, "FR") âˆ§ Flights(ğ‘¥, ğ‘¦) âˆ§ Flights(ğ‘¦, ğ‘§) ğ‘ = ğ‘ 1 âˆ¨ ğ‘ 2 (c) ğ‘ is a Boolean union of conjunctive queries (UCQ) (ğ‘ 1 âˆ§ ğ‘ 1 âˆ§ ğ‘ 8 ) ğ‘ 1 provenance âˆ¨ (ğ‘ 2 âˆ§ ğ‘ 4 âˆ§ ğ‘ 2 âˆ§ ğ‘ 8 ) âˆ¨ (ğ‘ 2 âˆ§ ğ‘ 5 âˆ§ ğ‘ 2 âˆ§ ğ‘ 7 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 4 âˆ§ ğ‘ 3 âˆ§ ğ‘ 8 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 5 âˆ§ ğ‘ 3 âˆ§ ğ‘ 7 ) âˆ¨ (ğ‘ 6 âˆ§ ğ‘ 7 âˆ§ ğ‘ 5 âˆ§ ğ‘ 7 ) ğ‘ 2 provenance (d)</formula><p>The lineage Lin(ğ‘, ğ·) as a formula in Disjunctive Normal Form (DNF) Figure <ref type="figure" target="#fig_1">1</ref>: The database, query ğ‘ and its lineage used for our running example is obtained-being hierarchical-is exactly the same as in the context of probabilistic query evaluation (PQE); see, e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. In fact, the main result of this section is that this is not a coincidence: we prove that, for every Boolean query ğ‘ (not just for sjfbcqs), if PQE is tractable for ğ‘ then so is the problem Shapley(ğ‘). Since PQE has been intensively studied already, our result allows us to vastly extend the tractable cases identified in <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref>. We now proceed with the definitions and proof of this result, and explain its consequences.</p></div>
<div><head>Probabilistic query evaluation.</head><p>A tuple-independent (TID) database is a pair consisting of a database ğ· and a function ğœ‹ mapping each fact ğ‘“ âˆˆ ğ· to a probability value ğœ‹ (ğ‘“ ) âˆˆ [0, 1]. The TID (ğ·, ğœ‹) defines a probability distribution Pr ğœ‹ on ğ· â€² âŠ† ğ·, where</p><formula xml:id="formula_4">Pr ğœ‹ (ğ· â€² ) def = ğ‘“ âˆˆğ· â€² ğœ‹ (ğ‘“ ) Ã— ğ‘“ âˆˆğ·\ğ· â€² (1 -ğœ‹ (ğ‘“ ))</formula><p>. Given a Boolean query ğ‘, the probability that ğ‘ is satisfied by (ğ·, ğœ‹) is Pr(ğ‘, (ğ·, ğœ‹))</p><formula xml:id="formula_5">def = ğ· â€² âŠ†ğ· s.t. ğ‘ (ğ· â€² )=1 Pr ğœ‹ (ğ· â€² ).</formula><p>The probabilistic query evaluation problem for ğ‘, PQE(ğ‘) for short, is then defined as follows.</p></div>
<div><head>PROBLEM: PQE(ğ‘)</head><p>INPUT: A tuple-independent database (ğ·, ğœ‹). OUTPUT: The value Pr(ğ‘, (ğ·, ğœ‹)).</p><p>For two computational problems ğ´ and ğµ, we write ğ´ â‰¤ p T ğµ to assert the existence of a polynomial-time Turing reduction from ğ´ to ğµ. We are ready to state the main result of this section. This result implies that for any query ğ‘ for which PQE(ğ‘) is tractable then so is Shapley(ğ‘). Dalvi and Suciu <ref type="bibr" target="#b7">[8]</ref> showed a dichotomy for unions of conjunctive queries: for every such query ğ‘, either PQE(ğ‘) is solvable in polynomial time, in which case ğ‘ is called safe<ref type="foot" target="#foot_0">1</ref> , or PQE(ğ‘) is FP #P -hard (and ğ‘ is called unsafe). Therefore, we obtain as a direct corollary of Proposition 3.1 that Shapley(ğ‘) can be solved in polynomial time for all safe queries. Corollary 3.2. If ğ‘ is a safe UCQ then Shapley(ğ‘) can be solved in polynomial time.</p><p>In particular, this corollary generalizes the tractability result obtained in <ref type="bibr" target="#b19">[20]</ref>, to account for CQs with self-joins and even unions of such queries. We now prove Proposition 3. Then, by grouping by size the terms ğ¸ from Equation 1 we obtain</p><formula xml:id="formula_6">Shapley(ğ‘, ğ· n , ğ· x , ğ‘“ ) = |ğ· n |-1 âˆ‘ï¸ ğ‘˜=0 ğ‘˜!(|ğ· n | -ğ‘˜ -1) |ğ· n | (2) #Slices(ğ‘, ğ· x âˆª {ğ‘“ }, ğ· n \ {ğ‘“ }, ğ‘˜) -#Slices(ğ‘, ğ· x , ğ· n \ {ğ‘“ }, ğ‘˜) .</formula><p>All arithmetical terms (such as ğ‘˜! or |ğ· n |!) can be computed in polynomial time. Therefore, to prove that Shapley(ğ‘) â‰¤ p T PQE(ğ‘), it is enough to show that, given an oracle to the problem PQE(ğ‘), we can compute in polynomial time the quantities #Slices(ğ‘, ğ· x , ğ· n , ğ‘˜), for some arbitrary ğ· = ğ· x âˆª ğ· n and ğ‘˜ âˆˆ {0, . . . , |ğ· n |}. This is what we do next.</p><p>The proof is similar to that of <ref type="bibr" target="#b35">[36,</ref><ref type="bibr">Theorem 2]</ref> in the context of SHAP-score for machine learning (but, as explained in the Introduction, the two results seem to be incomparable).</p><p>We wish to compute #Slices(ğ‘, ğ· x , ğ· n , ğ‘˜), for some database ğ· = ğ· x âˆªğ· n and integer ğ‘˜ âˆˆ {0, . . . |ğ· n |}. Let ğ‘› = |ğ· n | be the number of endogenous facts of ğ·. For ğ‘§ âˆˆ Q, we define a TID database (ğ· ğ‘§ , ğœ‹ ğ‘§ ) as follows: ğ· ğ‘§ contains all the facts of ğ·, and for an exogenous fact ğ‘“ of ğ· we define ğœ‹ ğ‘§ (ğ‘“ ) def = 1 while for an endogenous fact ğ‘“ of ğ· we define ğœ‹ ğ‘§ (ğ‘“ ) def = ğ‘§ 1+ğ‘§ . It is then routine to show that the following relation holds:</p><formula xml:id="formula_7">(1 + ğ‘§) ğ‘› Pr(ğ‘, (ğ· ğ‘§ , ğœ‹ ğ‘§ )) = ğ‘› âˆ‘ï¸ ğ‘–=0 ğ‘§ ğ‘– #Slices(ğ‘, ğ· x , ğ· n , ğ‘–).</formula><p>This suffices to conclude the proof. Indeed, we now call an oracle to PQE(ğ‘) on ğ‘› + 1 databases ğ· ğ‘§ 0 , . . . , ğ· ğ‘§ ğ‘› for ğ‘› + 1 arbitrary distinct values ğ‘§ 0 , . . . , ğ‘§ ğ‘› , forming a system of linear equations as given by the relation above. Since the corresponding matrix is a Vandermonde with distinct coefficients, it is invertible, so we can compute in polynomial time the value #Slices(ğ‘, ğ· x , ğ· n , ğ‘˜). â–¡</p><p>A intriguing natural question is whether the converse of Proposition 3.1 is true, that is, whether we also have PQE(ğ‘) â‰¤ p T Shapley(ğ‘). This is true when ğ‘ is a self-join-free conjunctive query: indeed, by the results of <ref type="bibr" target="#b19">[20]</ref>, either ğ‘ is hierarchical and then both PQE(ğ‘) and Shapley(ğ‘) can be solved in polynomial time (hence PQE(ğ‘) â‰¤ p T Shapley(ğ‘)), or ğ‘ is not hierarchical and then Shapley(ğ‘) is FP #Phard (which, together with the fact that PQE(ğ‘) âˆˆ FP #P , implies PQE(ğ‘) â‰¤ p T Shapley(ğ‘)). However, to the best of our knowledge, the existence of such a reduction in the general case is unknown.</p><p>Open problem 1. Do we have PQE(ğ‘) â‰¤ p T Shapley(ğ‘) for every Boolean query ğ‘?</p><p>Interestingly, we note that this direction is trivial in the setting of SHAP-scores. Indeed, this is directly implied by the efficiency axiom of the Shapley value; see, e.g., <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">Lemma 4.2]</ref> or <ref type="bibr" target="#b35">[36,</ref><ref type="bibr">Equation 5</ref>]. In our case, this axiom only gives us the following equality:</p><formula xml:id="formula_8">âˆ‘ï¸ ğ‘“ âˆˆğ· n Shapley(ğ‘, ğ· n , ğ· x , ğ‘“ ) = ğ‘(ğ· n âˆª ğ· x ) -ğ‘(ğ· x ),</formula><p>which does not seem to help in showing PQE(ğ‘) â‰¤ p T Shapley(ğ‘).</p></div>
<div><head n="4">EXACT COMPUTATION THROUGH KNOWLEDGE COMPILATION</head><p>Motivated by the connection to PQE that we have seen in Section 3, we now investigate whether an approach using knowledge compilation can be used for computing Shapley values. Indeed, a common method to compute the probability that a probabilistic database (ğ·, ğœ‹) satisfies a Boolean query ğ‘ is to first compute the lineage of ğ‘ on ğ· in a formalism from knowledge compilation, and then to use the good properties of said formalism to compute Pr(ğ‘, (ğ·, ğœ‹)) in linear time <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b32">33]</ref>. Recently, Arenas and others <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> showed that this approach is also viable for the notion of SHAP-score used in machine learning, by proving that SHAPscores can be computed in polynomial time when the models are given as circuits from knowledge compilation. By reusing some of these techniques, we can show that this method can also be used in our setting for computing Shapley values of database facts. Again, to the best of our knowledge, the two results are incomparable, i.e., we are not aware of a reduction in either direction between the two problems. We start by formally defining the notions of lineage and the relevant circuit classes from knowledge compilation. Boolean functions and query lineages. Let ğ‘‹ be a finite set of variables. An assignment ğœˆ of ğ‘‹ is a subset ğœˆ âŠ† ğ‘‹ of ğ‘‹ . We denote by 2 ğ‘‹ the set of all assignments of ğ‘‹ . A Boolean function ğœ‘ over ğ‘‹ is a function ğœ‘ : 2 ğ‘‹ â†’ {0, 1}. An assignment ğœˆ âŠ† ğ‘‹ is satisfying if ğœ‘ (ğœˆ) = 1. We denote by SAT(ğœ‘) âŠ† 2 ğ‘‹ the set of all satisfying assignments of ğœ‘, and by #SAT(ğœ‘) the size of this set. For ğ‘˜ âˆˆ N, we define SAT ğ‘˜ (ğœ‘)</p><formula xml:id="formula_9">âˆ§ âˆ§ Â¬ Â¬ Â¬ ğ‘ 3 ğ‘ 5 ğ‘ 1 Â¬ Â¬ âˆ§ âˆ§ ğ‘ 7 âˆ§ ğ‘ 6 ğ‘ 4 ğ‘ 2 âˆ¨ âˆ¨ Â¬ Â¬ Â¬</formula><formula xml:id="formula_10">def = SAT(ğœ‘) âˆ© {ğœˆ âŠ† ğ‘‹ | |ğœˆ | = ğ‘˜ }, that</formula><p>is, the set of satisfying assignments of ğœ‘ of Hamming weight ğ‘˜, and let #SAT ğ‘˜ (ğœ‘) be the size of this set.</p><p>Let ğ‘ be a Boolean query and ğ· be a database. The lineage Lin(ğ‘, ğ·) is the (unique) Boolean function whose variables are the facts of ğ·, and that maps each sub-database ğ· â€² âŠ† ğ· to ğ‘(ğ· â€² ). This definition extends straightforwardly to queries with free variables as follows: if ğ‘( x) is a query with free variables x and t is a tuple of constants of the appropriate size, then Lin(ğ‘[ x/ t]), ğ·) is the lineage for the tuple t.</p><p>Example 4.1. Consider again the database ğ· and the Boolean query ğ‘ from Figures <ref type="figure" target="#fig_1">1a</ref> and<ref type="figure" target="#fig_1">1c</ref>. In Figure <ref type="figure" target="#fig_1">1d</ref>, the lineage Lin(ğ‘, ğ·) is represented as a formula in disjunctive normal form (DNF).</p><p>For our purposes, we will use a refinement of this lineage that accounts for the nature of exogenous tuples; specifically, these tuples should be considered as always being part of the database. Let ğ· = ğ· n âˆª ğ· x be a database with endogenous tuples ğ· n and exogenous tuples ğ· x , and let ğ‘ be a Boolean query. Then the endogenous lineage ELin(ğ‘, ğ· x , ğ· n ) is the (unique) Boolean function whose variables are ğ· n and that maps every set ğ¸ of endogenous facts to ğ‘(ğ· x âˆª ğ¸). In other words, ELin(ğ‘, ğ· x , ğ· n ) can be obtained from Lin(ğ‘, ğ·) by fixing all variables in ğ· x to the value 1. Again, we extend this definition to queries with free variables by using the function ELin(ğ‘[ x/ t], ğ· x , ğ· n ).</p><p>Example 4.2. Continuing the previous example, the endogenous lineage ELin(ğ‘, ğ· n , ğ· x ) can be represented as a DNF by</p><formula xml:id="formula_11">ğ‘ 1 âˆ¨ (ğ‘ 2 âˆ§ ğ‘ 4 ) âˆ¨ (ğ‘ 2 âˆ§ ğ‘ 5 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 4 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 5 ) âˆ¨ (ğ‘ 6 âˆ§ ğ‘ 7 ) .</formula><p>In the last two examples, lineages were represented with Boolean formulas in DNF. Since a lineage is a Boolean function, it can be represented with any formalism that allows to represent Boolean functions. We next review some classes of circuits from the field of knowledge compilation that will be relevant for our work.</p></div>
<div><head>Knowledge compilation classes.</head><p>Let ğ¶ be a Boolean circuit, featuring âˆ§, âˆ¨, Â¬, and variable gates, with the usual semantics. 2  The output gate, for instance, is a deterministic âˆ¨-gate: indeed, its left child requires ğ‘ 1 to be 1, whereas its right child requires ğ‘ 1 to be 0. The right child of the output gate is a decomposable âˆ§-gate: indeed, for its left child ğ‘” 1 we have Vars(ğ‘” 1 ) = {ğ‘ 1 }, whereas for its right child ğ‘” 2 we have Vars(ğ‘” 2 ) = {ğ‘ 2 , ğ‘ 3 , ğ‘ 4 , ğ‘ 5 , ğ‘ 6 , ğ‘ 7 }, and these are indeed disjoint. The reader can easily check that all other âˆ¨gates are deterministic, and that all other âˆ§-gates are decomposable.</p></div>
<div><head n="4.1">Algorithm</head><p>The main result of this section is then the following. Proof of Proposition 4.4. Let ğ¶ be a deterministic and decomposable circuit representing ELin(ğ‘, ğ· n , ğ· x ), and let ğ‘“ âˆˆ ğ· n . First, we complete the circuit ğ¶ so that all variables of ğ· n appear in ğ¶. Indeed, it could be the case that Vars(ğ¶) âŠŠ ğ· n : this happens for instance with the deterministic and decomposable circuit in Figure <ref type="figure" target="#fig_2">2</ref>, where the endogenous fact ğ‘ 8 does not appear in the circuit. To do this, we conjunct ğ¶ with the conjunction ğ‘“ â€² âˆˆğ· n \Vars(ğ¶) (ğ‘“ â€² âˆ¨ Â¬ğ‘“ â€² ). Note that this does not change the semantics of the circuit (as this conjunction always evaluates to 1) and that the resulting circuit is still deterministic and decomposable. Now, let ğ¶ 1 (resp., ğ¶ 2 ) be the Boolean circuit obtained from ğ¶ by replacing all variable gates corresponding to the fact ğ‘“ by a constant 1-gate (resp., by a constant 0-gate). Observe then that the variables of ğ¶ 1 and ğ¶ 2 are exactly ğ· n \ {ğ‘“ }, and moreover that ğ¶ 1 and ğ¶ 2 are still deterministic and decomposable. By definition of the endogenous lineage, we can rewrite Equation (2) into the following. 2 We allow unbounded-fanin âˆ§and âˆ¨-gates, and also allow constant 1-gates and constant 0-gates as, respectively, âˆ§-gates with no input and âˆ¨-gates with no inputs.</p></div>
<div><head>Shapley(ğ‘, ğ·</head><formula xml:id="formula_12">n , ğ· x , ğ‘“ ) = |ğ· n |-1 âˆ‘ï¸ ğ‘˜=0 ğ‘˜!(|ğ· n | -ğ‘˜ -1) |ğ· n |<label>(3)</label></formula><p>#SAT ğ‘˜ (ğ¶ 1 ) -#SAT ğ‘˜ (ğ¶ 2 ) .</p><p>Proposition 4.4 will thus directly follow from the next lemma. First of all, we preprocess ğ¶ so that the fanin of every âˆ¨and âˆ§-gate is exactly 0 or 2; this can simply be done by rewriting every âˆ§-gate of fanin ğ‘š &gt; 2 with ğ‘š -1 âˆ§gates of fanin 2 (same for âˆ¨-gates), and adding a constant gate of the appropriate type to every âˆ¨and âˆ§-gate of fan-in 1. We then compute, for every gate ğ‘” of ğ¶, the set of variables Vars(ğ‘”) upon which the value of ğ‘” depends. For a gate ğ‘” of ğ¶, let us denote by ğœ‘ ğ‘” the Boolean function over the variables Vars(ğ‘”) that is represented by this gate. For a gate ğ‘” and an integer â„“ âˆˆ {0, . . . , |Vars(ğ‘”)|}, we define ğ›¼ â„“ ğ‘” def = #SAT â„“ (ğœ‘ ğ‘” ), i.e. the number of assignments of size â„“ to Vars(ğ‘”) that satisfy ğœ‘ ğ‘” . We will show how to compute all the values ğ›¼ â„“ ğ‘” for every gate ğ‘” of ğ¶ and â„“ âˆˆ {0, . . . , |Vars(ğ‘”)|} in polynomial time. This will conclude the proof since, for the output gate ğ‘” output of ğ¶, we have that ğ›¼ ğ‘˜ ğ‘” output = #SAT ğ‘˜ (ğ‘“ ). We will need the following notation: for two disjoint sets of variables ğ‘‹ 1 , ğ‘‹ 2 and two subsets ğ‘† 1 âŠ† 2 ğ‘‹ 1 , ğ‘† 2 âŠ† 2 ğ‘‹ 2 of assignments to ğ‘‹ 1 and ğ‘‹ 2 , we denote by </p><formula xml:id="formula_13">ğ‘† 1 âŠ— ğ‘† 2 âŠ† 2 ğ‘‹ 1 âˆªğ‘‹ 2 the set of assignments of ğ‘‹ 1 âˆª ğ‘‹ 2 defined by ğ‘† 1 âŠ— ğ‘† 2 def = {ğœˆ 1 âˆª ğœˆ 2 | ğœˆ 1 âˆˆ ğ‘† 2 ,</formula><formula xml:id="formula_14">SAT(ğœ‘ ğ‘” ) = (SAT(ğœ‘ ğ‘” 1 ) âŠ— 2 ğ‘† 1 ) âˆª (SAT(ğœ‘ ğ‘” 2 ) âŠ— 2 ğ‘† 2 )</formula><p>with the union being disjoint. By intersecting with the assignments of Vars(ğ‘”) of size â„“, we obtain:</p><formula xml:id="formula_15">SAT â„“ (ğœ‘ ğ‘” ) = (SAT(ğœ‘ ğ‘” 1 ) âŠ— 2 ğ‘† 1 ) âˆ© {ğœˆ âŠ† Vars(ğ‘”) | |ğœˆ | = â„“ } âˆª (SAT(ğœ‘ ğ‘” 2 ) âŠ— 2 ğ‘† 2 ) âˆ© {ğœˆ âŠ† Vars(ğ‘”) | |ğœˆ | = â„“ }</formula><p>with again the middle union being disjoint, therefore: </p><formula xml:id="formula_16">#SAT â„“ (ğœ‘ ğ‘” ) =|(SAT(ğœ‘ ğ‘” 1 ) âŠ— 2 ğ‘† 1 ) âˆ© {ğœˆ âŠ† Vars(ğ‘”) | |ğœˆ | = â„“ }| + |(SAT(ğœ‘ ğ‘” 2 ) âŠ— 2 ğ‘† 2 ) âˆ© {ğœˆ âŠ† Vars(ğ‘”) | |ğœˆ | = â„“ }|</formula><formula xml:id="formula_17">âˆ‘ï¸ ğ‘– = max(0, â„“-|ğ‘† 1 |) ğ›¼ ğ‘– ğ‘” 1 Ã— |ğ‘† 1 | â„“ -ğ‘– .</formula><p>Decomposable âˆ§-gate. If ğ‘” is a decomposable âˆ§-gate with no input then ğœ‘ ğ‘” is the Boolean function on variables Vars(ğ‘”) = âˆ… that is always true, hence ğ›¼ 0 ğ‘” = 1. Otherwise, let ğ‘” 1 and ğ‘” 2 be the two input gates of ğ‘”. Since ğ‘” is decomposable we have Vars(ğ‘”) = Vars(ğ‘” 1 ) âˆª Vars(ğ‘” 2 ) with the union being disjoint. But then we have:</p><formula xml:id="formula_18">SAT(ğœ‘ ğ‘” ) = SAT(ğœ‘ ğ‘” 1 ) âŠ— SAT(ğœ‘ ğ‘” 2 )</formula><p>We now intersect with the set of assignments of Vars(ğ‘”) of size ğ‘™ to obtain</p><formula xml:id="formula_19">ğ›¼ â„“ ğ‘” = #SAT â„“ (ğœ‘ ğ‘” ) = min(â„“, |Vars(ğ‘” 1 ) |) âˆ‘ï¸ ğ‘– = max(0, â„“-|Vars(ğ‘” 2 ) |) ğ›¼ ğ‘– ğ‘” 1 Ã— ğ›¼ â„“-ğ‘– ğ‘” 2</formula><p>This concludes the proof of the lemma, as well as the proof of Proposition 4. </p></div>
<div><head>This function computes values ğ›¼ â„“</head><p>ğ‘” by bottom-up induction on ğ¶ just as in the proof of Lemma 4.5, by using the appropriate equations depending on the type of each gate. Then, Lines 1-5 in the algorithm simply follow the part of the proof that starts at the beginning of this section until Lemma 4.5. For instance, the returned value on Line 5 corresponds to Equation <ref type="bibr" target="#b2">(3)</ref>. A quick inspection of Algorithm 1 reveals that, if one ignores the complexity of performing arithmetic operations (i.e., considering that additions and multiplications take constant time), the running time is ğ‘‚ (|ğ¶ | â€¢ |ğ· n | 2 ). If one wishes to compute the Shapley value of every endogenous fact (as will be done in the experiments), then the overall complexity is ğ‘‚ (|ğ¶ | â€¢ |ğ· n |<ref type="foot" target="#foot_1">3</ref> ). Last, we point out that, in the case of non-Boolean queries, this cost is incurred for each potential output tuple that one wants to analyze.</p></div>
<div><head n="4.2">Implementation Architecture</head><p>In this section, we present our architecture for implementing the knowledge compilation approach over realistic datasets. The relevant parts, for now, are the middle and top part of Figure <ref type="figure" target="#fig_8">3</ref>, which we next explain. Given a database ğ· = ğ· x âˆª ğ· n , a query ğ‘( x), a tuple t of the same arity as x, and an endogenous fact ğ‘“ âˆˆ ğ· n , we want to compute Shapley(ğ‘[ x/ t], ğ· x , ğ· n , ğ‘“ ). We use two existing tools to help us with this task: <software ContextAttributes="used">ProvSQL</software> <ref type="bibr" target="#b30">[31]</ref> and the knowledge compiler <software ContextAttributes="used">c2d</software> <ref type="bibr" target="#b9">[10]</ref>. <software ContextAttributes="used">ProvSQL</software> is a tool integrated into <software ContextAttributes="used">PostgreSQL</software> that can perform provenance (lineage) computation in various semirings. For our purposes, a knowledge compiler is a tool that takes as input a Boolean function in CNF and outputs an equivalent Boolean function into another formalism. The target formalism that we will use is the so-called "d-DNNF". A d-DNNF is simply a deterministic and decomposable Boolean circuit such that negation gates are only applied to variables (NNF stands for negation normal form). <ref type="foot" target="#foot_2">4</ref>In our case, we use <software ContextAttributes="used">ProvSQL</software> as follows: we feed it the database ğ·, query ğ‘( x) and tuple t, and <software ContextAttributes="used">ProvSQL</software> computes Lin(ğ‘ [ x/ t], ğ·) as a Boolean circuit, called ğ¶ in Figure <ref type="figure" target="#fig_8">3</ref>. We note here that for SPJU queries, ğ¶ can be computed in polynomial-time data complexity. We then set to 1 all the exogenous facts to obtain a Boolean circuit ğ¶ â€² for ELin(ğ‘[ x/ t], ğ· x , ğ· n ). Then, ideally, we would like to use the knowledge compiler to transform ğ¶ â€² into an equivalent d-DNNF, in order to be able to apply Algorithm 1. Unfortunately, every knowledge compiler that we are aware of takes as input Boolean formulas in conjunctive normal form (CNF), and not arbitrary Boolean circuits. To circumvent it, we use the Tseytin transformation <ref type="bibr" target="#b34">[35]</ref> to transform the circuit ğ¶ â€² into a CNF ğœ‘ def = Tseytin(ğ¶ â€² ), whose size is linear in that of ğ¶ â€² . This CNF ğœ‘ has the following properties: (1) its variables are the variables of ğ¶ â€² plus a set ğ‘ of additional variables; (2) for every valuation ğœˆ âŠ† Vars(ğ¶ â€² ) that satisfies ğ¶ â€² , there exists exactly one valuation ğœˆ â€² âŠ† ğ‘ such that ğœ‘ (ğœˆ âˆª ğœˆ â€² ) = 1; and (3) for every valuation ğœˆ âŠ† Vars(ğ¶ â€² ) that does not satisfy ğ¶ â€² , there is no valuation ğœˆ â€² âŠ† ğ‘ such that ğœ‘ (ğœˆ âˆª ğœˆ â€² ) = 1. We then feed ğœ‘ to the knowledge compiler, which produces a d-DNNF ğ¶ â€²â€² equivalent to ğœ‘ (the variables of ğ¶ â€²â€² are again Vars(ğ¶ â€² ) âˆª ğ‘ ). We note here that there is no theoretical guarantee that this step is efficient; indeed, the task of transforming a CNF into an equivalent d-D circuit is FP #P -hard in general; see Section 6 for an experimental analysis of its tractability in practice. Next, we need to eliminate the additional variables ğ‘ in order to be able to apply Algorithm 1. To this end, we use the following Lemma. Lemma 4.6. Given as input a d-DNNF ğ¶ â€²â€² that is equivalent to Tseytin(ğ¶ â€² ) for a Boolean circuit ğ¶ â€² , we can compute in time ğ‘‚ (|ğ¶ â€²â€² |) a d-DNNF ğ¶ â€²â€²â€² that is equivalent to ğ¶ â€² (in particular, the variables of ğ¶ â€²â€²â€² are the same as the variables of ğ¶ â€² ; in our case, they consist only of endogenous facts).</p><p>Proof sketch. Let ğ‘ be the additional variables coming from the Tseytin transformation. First, we remove all the gates of ğ¶ â€²â€² that are not satisfiable, and then we remove all the gates that are not connected to the output gate. Now, let ğ¶ â€²â€²â€² be the circuit that is obtained from this intermediate circuit by replacing every literal ğ‘§ or Â¬ğ‘§ for ğ‘§ âˆˆ ğ‘ by a constant 1-gate. We return ğ¶ â€²â€²â€² . The proof that this algorithm is correct uses the properties (1-3) of the Tseytin transformation, and is omitted due to lack of space. â–¡</p><p>Using this lemma, we obtain a d-DNNF ğ¶ â€²â€²â€² for the endogenous lineage ELin(ğ‘[ x/ t], ğ· x , ğ· n ), to which we can finally apply Algorithm 1 to obtain the value Shapley(ğ‘[ x/ t], ğ· x , ğ· n , ğ‘“ ).</p></div>
<div><head n="5">INEXACT COMPUTATION</head><p>As we will show in the experimental section, the exact computation algorithm that we have proposed performs well in most cases but is too costly in others. In the latter cases, we may wish to resort to methods that do not necessarily compute exact Shapley values, if their results still typically suffice to determine the order of facts according to their Shapley contribution. In this section we propose CNF Proxy, a heuristic solution that is very efficient, and we will experimentally show that the ranking of facts based on CNF Proxy tends to match the ranking based on the exact Shapley values.</p><p>At a high level, CNF Proxy is based on the observation that having a high Shapley score is correlated (albeit in a complex manner) with (1) appearing many times in the provenance and (2) having few "alternatives," that is, facts that could compensate for the absence of the given fact. The first factor (number of occurrences) may be directly read from the CNF obtained by applying the Tseytin transformation to the provenance circuit (ğ¶ â€² in Figure <ref type="figure" target="#fig_8">3</ref>). It is also easy to read from the CNF partial information about the second factor (number of alternatives), namely the number of alternatives in each clause (ignoring intricate dependencies between clauses). Next, we present the details of CNF Proxy.</p><p>We will start with an auxiliary definition, denoting the Shapley value of a general function â„ : 2 ğ‘‹ â†’ R and a variable ğ‘¥ âˆˆ ğ‘‹ as</p><formula xml:id="formula_20">Shapley(â„, ğ‘¥) def = âˆ‘ï¸ ğ‘† âŠ†ğ‘‹ \{ğ‘¥ } |ğ‘† |!(|ğ‘‹ | -|ğ‘† | -1)! |ğ‘‹ |! â„(ğ‘† âˆª {ğ‘¥ }) -â„(ğ‘†) .</formula><p>Naturally, if â„ = ELin(ğ‘, ğ· n , ğ· x ), i.e., the endogenous lineage, and ğ‘¥ is a fact in ğ· n , then Shapley(â„, ğ‘¥) = Shapley(ğ‘, ğ· n , ğ· x , ğ‘¥). ğ‘› ğœ“ ğ‘– (ğœˆ). Intuitively, a fact that appears in many clauses of the CNF ğœ‘ will occur in many summands of ğœ‘, and when we compute Shapley values with respect to ğœ‘, the number of alternatives in each clause will be reflected in decreased value of the respective summands.</p><p>Example 5.1. Consider the CNF formula ğœ‘ = (ğ‘¥ 1 âˆ¨ ğ‘¥ 2 ) âˆ§ (ğ‘¥ 1 âˆ¨ ğ‘¥ 3 âˆ¨ ğ‘¥ 4 ). The Shapley values of ğ‘¥ 1 , ğ‘¥ 2 , ğ‘¥ 3 , ğ‘¥ 4 are 7  12 , 3 12 , 1 12 , 1 12 respectively. Note that ğ‘¥ 1 has the highest influence, which intuitively may be attributed to its appearance in two clauses whereas each other variable appears only in a single clause. The variable ğ‘¥ 2 has more influence than ğ‘¥ 3 and ğ‘¥ 4 , intuitively since it has less alternatives. These comparative features are preserved in ğœ‘ = (ğ‘¥ 1 âˆ¨ ğ‘¥ 2 ) + (ğ‘¥ 1 âˆ¨ ğ‘¥ 3 âˆ¨ ğ‘¥ 4 ), and indeed the Shapley values of ğ‘¥ 1 , ğ‘¥ 2 , ğ‘¥ 3 , ğ‘¥ 4 with respect to ğœ‘ are 5  6 , 1 2 , 1 3 , 1 3 respectively. Observe that although the values assigned to the variables are very different from their actual Shapley values, their order remains intact in this case.</p><p>Due to the linearity of Shapley values, their computation with respect to ğœ‘ is much more efficient, as implied by the following lemma (whose proof we omit for space reasons): Lemma 5.  </p><formula xml:id="formula_21">Î¦(ğœ“ ğ‘– , ğ‘¥) = ï£± ï£´ ï£´ ï£´ ï£´ ï£´ ï£² ï£´ ï£´ ï£´ ï£´ ï£´ ï£³ 1 (ğ‘ ğ‘– +ğ‘ ğ‘– ) â€¢( ğ‘ ğ‘– +ğ‘ ğ‘– -1 ğ‘ ğ‘– ) if ğ‘¥ appears in ğœ“ ğ‘– in positive form; -1 (ğ‘ ğ‘– +ğ‘ ğ‘– ) â€¢( ğ‘ ğ‘– +ğ‘ ğ‘– -1 ğ‘ ğ‘–</formula><p>)</p><p>if ğ‘¥ appears in ğœ“ ğ‘– in negative form;</p><formula xml:id="formula_22">0 otherwise.</formula><p>Algorithm 2 then describes the operation of CNF Proxy, computing Shapley values of ğœ‘ according to Lemma 5.2. The input to the algorithm is a CNF formula ğœ‘ and the set of endogenous facts ğ· n . In Line 1, CNF Proxy counts the number ğ‘› of clauses of ğœ‘, and in Line 2 it initializes the contribution of every variable of ğœ‘ to zero. Then, it iterates over the clauses (Line 3). For each clause, it counts the number ğ‘š of literals, and identifies the set of positive and negative literals, ğ‘ğ‘œğ‘  and ğ‘›ğ‘’ğ‘” respectively (Lines 4-7). In Lines 9 and 12 we add (resp., subtract) quantities for each variable in a positive (resp., negative) literal according to Lemma 5.2 (note that ğ‘š corresponds to ğ‘ ğ‘– + ğ‘ ğ‘– as denoted in the lemma). Finally, in Line 15 the algorithm returns the contribution value of each fact ğ‘¥ âˆˆ ğ· n based on Shapley( ğœ‘, ğ‘¥). Observe that CNF Proxy runs in linear time in the size of ğœ‘ (which itself, being the Tseytin transformation of the provenance circuit ğ¶ â€² from Figure <ref type="figure" target="#fig_8">3</ref>, is linear in ğ¶ â€² ).</p><p>Example 5.3. Recall the queries ğ‘ 1 , ğ‘ 2 , ğ‘ and their lineages depicted in Figure <ref type="figure" target="#fig_1">1</ref>. Using endogenous lineages, we have:</p><formula xml:id="formula_23">â€¢ ELin(ğ‘ 1 , ğ· n , ğ· x ) = ğ‘ 1 â€¢ ELin(ğ‘ 2 , ğ· n , ğ· x ) = (ğ‘ 2 âˆ§ ğ‘ 4 ) âˆ¨ (ğ‘ 2 âˆ§ ğ‘ 5 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 4 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 5 ) âˆ¨ (ğ‘ 6 âˆ§ ğ‘ 7 ) â€¢ ELin(ğ‘, ğ· n , ğ· x ) =ğ‘ 1 âˆ¨ (ğ‘ 2 âˆ§ ğ‘ 4 ) âˆ¨ (ğ‘ 2 âˆ§ ğ‘ 5 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 4 ) âˆ¨ (ğ‘ 3 âˆ§ ğ‘ 5 ) âˆ¨ (ğ‘ 6 âˆ§ ğ‘ 7 )</formula><p>The lineage of ğ‘ 1 is a CNF with a single variable, thus the contribution of ğ‘ 1 to ğ‘ 1 as computed by Algorithm 2 is 1, which is indeed equal to Shapley(ğ‘ 1 , ğ· n , ğ· x , ğ‘ 1 ). Applying the Tseytin transformation to the lineage of ğ‘ 2 introduces 6 new variables ({ğ‘§ ğ‘– } 6 ğ‘–=1 ) and results in the following equisatisfiable CNF:</p><formula xml:id="formula_24">(ğ‘§ 1 ) âˆ§ (ğ‘§ 1 âˆ¨ ğ‘§ 2 ) âˆ§ (ğ‘§ 1 âˆ¨ ğ‘§ 3 ) âˆ§ (ğ‘§ 1 âˆ¨ ğ‘§ 4 ) âˆ§ (ğ‘§ 1 âˆ¨ ğ‘§ 5 ) âˆ§ (ğ‘§ 1 âˆ¨ ğ‘§ 6 ) âˆ§ (ğ‘§ 1 âˆ¨ ğ‘§ 2 âˆ¨ ğ‘§ 3 âˆ¨ ğ‘§ 4 âˆ¨ ğ‘§ 5 âˆ¨ ğ‘§ 6 ) âˆ§ (ğ‘§ 2 âˆ¨ ğ‘ 2 ) âˆ§ (ğ‘§ 2 âˆ¨ ğ‘ 4 ) âˆ§ (ğ‘§ 2 âˆ¨ ğ‘ 2 âˆ¨ ğ‘ 4 ) âˆ§ (ğ‘§ 3 âˆ¨ ğ‘ 2 ) âˆ§ (ğ‘§ 3 âˆ¨ ğ‘ 5 ) âˆ§ (ğ‘§ 3 âˆ¨ ğ‘ 2 âˆ¨ ğ‘ 5 ) âˆ§ (ğ‘§ 4 âˆ¨ ğ‘ 3 ) âˆ§ (ğ‘§ 4 âˆ¨ ğ‘ 4 ) âˆ§ (ğ‘§ 4 âˆ¨ ğ‘ 3 âˆ¨ ğ‘ 4 ) âˆ§ (ğ‘§ 5 âˆ¨ ğ‘ 3 ) âˆ§ (ğ‘¥ 5 âˆ¨ ğ‘ 5 ) âˆ§ (ğ‘§ 5 âˆ¨ ğ‘ 3 âˆ¨ ğ‘ 5 ) âˆ§ (ğ‘§ 6 âˆ¨ ğ‘ 6 ) âˆ§ (ğ‘§ 6 âˆ¨ ğ‘ 7 ) âˆ§ (ğ‘§ 6 âˆ¨ ğ‘ 6 âˆ¨ ğ‘ 7 )</formula><p>Algorithm 2 iterates over the above clauses, and computes the contribution of the endogenous facts ğ· n over the proxy function. Note that the facts ğ· n appear in clauses of two forms. The first form is ğ‘§ ğ‘— âˆ¨ ğ‘ ğ‘– ; appearance in this type of clause adds</p><formula xml:id="formula_25">1 22â€¢2â€¢( 1 1 ) = 1 44 to the contribution of ğ‘ ğ‘– . The second form is ğ‘§ ğ‘— âˆ¨ ğ‘ ğ‘– âˆ¨ ğ‘ â„ , which adds -1 22â€¢3â€¢( 2 1 ) = -1</formula><p>132 . Note that each of ğ‘ 2 , ğ‘ 3 , ğ‘ 4 , ğ‘ 5 has two appearances in clauses of the first form, and one appearance in clauses of the second form. Thus, according to Algorithm 2 the contribution of ğ‘ 2 , ğ‘ 3 , ğ‘ 4 , ğ‘ 5 is 5 132 â‰ˆ 0.038. In contrast, ğ‘ 6 and ğ‘ 7 each have a single appearance in a clause of the first form and a single appearance in a clause of the second form, thus their contribution is 1 66 â‰ˆ 0.015. We note that the values calculated by Algorithm 2 are very different from the actual Shapley values, as</p><formula xml:id="formula_26">Shapley(ğ‘ 2 , ğ· n , ğ· x , ğ‘ ğ‘– ) = 11 60 â‰ˆ 0.183 for ğ‘ ğ‘– âˆˆ {ğ‘ 2 , ğ‘ 3 , ğ‘ 4 , ğ‘ 5 } and Shapley(ğ‘ 2 , ğ· n , ğ· x , ğ‘ ğ‘– ) = 2</formula><p>15 â‰ˆ 0.133 for ğ‘ ğ‘– âˆˆ {ğ‘ 6 , ğ‘ 7 }. However, the facts ğ‘ 2 , ğ‘ 3 , ğ‘ 4 , ğ‘ 5 , are correctly determined to be more influential than ğ‘ 6 and ğ‘ 7 .</p><p>Our experimental evaluation indicates that in most cases, the ordering of facts according to the values assigned to them by Algorithm 2 agrees with the order obtained by using the actual Shapley values. There is however no theoretical guarantee that this will always be the case, as shown by the following example.</p><p>Example 5.4. Applying the Tseytin transformation over the lineage of ğ‘ will result in a CNF similar to that obtained for ğ‘ 2 , with a new variable (ğ‘§ 7 ) and the new clauses (ğ‘§ 1 âˆ¨ ğ‘§ 7 ) âˆ§ (ğ‘§ 7 âˆ¨ ğ‘ 1 ) âˆ§ (ğ‘§ 7 âˆ¨ ğ‘ 1 ). In addition, the disjunct âˆ¨ğ‘§ 7 will be added to the clause (ğ‘§ 1 âˆ¨ ğ‘§ 2 âˆ¨ ğ‘§ 3 âˆ¨ ğ‘§ 4 âˆ¨ ğ‘§ 5 âˆ¨ ğ‘§ 6 ). Similarly to the case of ğ‘ 2 , the contributions of ğ‘ 2 , ğ‘ 3 , ğ‘ 4 , and ğ‘ 5 are correctly determined to be larger than those of ğ‘ 6 and ğ‘ 7 . As for ğ‘ 1 , its contribution according to Algorithm 2 is 0 while in fact it is the most influential fact.</p></div>
<div><head n="6">EXPERIMENTS</head><p>Our system is implemented in Python 3.6 and using the <software ContextAttributes="used">PostgreSQL</software> 11.10 database engine, and the experiments were performed on a <software ContextAttributes="used">Linux</software> Debian 14.04 machine with 1TB of RAM and an Intel(R) Xeon(R) Gold 6252 CPU @ 2.10GHz processor. <software ContextAttributes="used">ProvSQL</software> <ref type="bibr" target="#b30">[31]</ref> was used to capture the provenance. For knowledge compilation we have used the <software ContextAttributes="used">c2d</software> compiler <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. The source <software ContextAttributes="used">code</software> of our implementation is available in <ref type="bibr" target="#b12">[13]</ref>.</p><p>Since no standard benchmark for our problem exists, we have created such a benchmark of 40 queries over the TPC-H (1.4GB) and IMDB (1.2GB) databases.The TPC-H queries are based on the ones in <ref type="bibr" target="#b33">[34]</ref>, where we have only removed nested queries (which <software ContextAttributes="used">ProvSQL</software> does not handle) and aggregation operations (for which provenance is not Boolean). The queries for the IMDB database are based on the join queries in <ref type="bibr" target="#b18">[19]</ref>, where for each query we have added a (last) projection operation over one of the join attributes to make provenance more complex and thus more challenging for our algorithms. The resulting queries are quite complex: in particular, only 4 out of the 40 are hierarchical. See <ref type="bibr" target="#b12">[13]</ref> for details of the obtained queries.</p></div>
<div><head n="6.1">Exact computation</head><p>We have evaluated our solution for exact Shapley computation, presented in Section 4.2, on each of the 40 queries. In total, we have obtained 95,803 output tuples along with their provenance expressions (computed with <software ContextAttributes="used">ProvSQL</software>). We have then transformed each provenance expression into a d-DNNF structure using the <software ContextAttributes="used">c2d</software> <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref> knowledge compiler. In this experiment, for both the knowledge compilation (KC) and Shapley evaluation steps we have set a timeout of one hour (in fact, as we show below, a much shorter timeout of 2.5 seconds typically suffices). In case the compilation completed successfully within this timeframe, we have computed the Shapley values using Algorithm 1. Table <ref type="table" target="#tab_5">1</ref> presents the execution times of our solution for 16 representative queries; next we will overview different aspects of the results.</p><p>Success rate. We report here the rate of successful executions. The IMDB queries resulted in 95,636 output tuples; the KC step completed successfully for 95,599 out of them, where all 37 failures were the result of insufficient memory. For each of the IMDB output tuples that were successfully compiled into a d-DNNF, we have executed Algorithm 1; only a single execution failed in this step (due to a timeout of one hour). Overall, the exact computation of Shapley values was successful for 95,598 out of the 95,636 IMDB output tuples (i.e., 99.96% success rate). The TPC-H queries resulted in 167 output tuples; the KC step has completed successfully for 141 out of them, again all 26 failures were the result of insufficient memory. For all TPC-H outputs that compiled successfully Algorithm 1 was successful, yielding an overall 84.43% success rate.</p><p>Execution time. For each of the 40 queries, we have measured the execution time of each step of the computation. First, we have measured (in the column "Execution time") the execution time in <software ContextAttributes="used">PostgreSQL</software>, which includes provenance generation for every output tuple using <software ContextAttributes="used">ProvSQL</software>. Then, for each tuple t in the output of the query, we have measured the KC execution time and the execution time of Algorithm 1 to compute the contribution of all input facts with respect to the output tuple t. For the latter two algorithms, the execution times varied significantly for the different output tuples, and thus we report the execution times for different percentiles (mean, p25, p50, p75 and p99). Observe that the computation is typically efficient; outliers include q11d for which the execution time of Algorithm 1 was over 96 seconds in average.     In contrast, Figure <ref type="figure" target="#fig_15">5b</ref> depicts 4 query outputs for which the exact computation failed to complete over the full TPC-H database. We observe that the algorithm does succeed in these cases if we execute the queries over subsets of the input database, though its execution time may still be high: e.g., if we take a "slice" of the lineitem table consisting of 480,097 facts, then computation of the contribution of all input facts w.r.t. "Q9 <software ContextAttributes="used">ALGERIA</software>" takes 556sec.   </p></div>
<div><head n="6.2">Inexact computation</head><p>As observed above, computing exact Shapley values using our solution for a given output tuple is typically fast, but may be costly or even fail in some cases. In this section we evaluate inexact computation alternatives.</p><p>Algorithms. We compare three algorithms: CNF Proxy (Section 5) and two existing baselines: Monte Carlo, and Kernel SHAP.</p><p>Monte Carlo. This is a well-known sampling algorithm <ref type="bibr" target="#b22">[23]</ref> for approximating Shapley values in general. To employ the Monte Carlo algorithm in our setting, we feed it a provenance expression â„ containing ğ‘› distinct input facts, and a budget of ğ‘Ÿ â€¢ ğ‘› samples, for some ğ‘Ÿ âˆˆ Z + . The Shapley value of each fact ğ‘“ is approximated by sampling ğ‘Ÿ permutations (ğœ‹ 1 , . . . , ğœ‹ ğ‘Ÿ ) of the input facts, and then outputting 1  ğ‘Ÿ â€¢ ğ‘Ÿ ğ‘–=1 â„(ğ‘† ğœ‹ ğ‘– ,&lt;ğ‘“ âˆª {ğ‘“ })â„(ğ‘† ğœ‹ ğ‘– ,&lt;ğ‘“ ) , where ğ‘† ğœ‹ ğ‘– ,&lt;ğ‘“ is the coalition of all facts preceding ğ‘“ in the permutation ğœ‹ ğ‘– .</p><p>Kernel SHAP. Lundberg and Lee <ref type="bibr" target="#b21">[22]</ref> have defined the notion of SHAP values in the context of ML explainability. Given a function â„ : R ğ‘‘ â†’ R (the model whose decisions we want to explain), a probability distribution D on R ğ‘‘ (the inputs), and an input vector Ä“ âˆˆ R ğ‘‘ , SHAP values were defined to measure the contribution of Ä“'s features to the outcome â„( Ä“). To overcome the issue that â„ does not operate over subsets of features, the notion of SHAP-score has been defined as follows</p><formula xml:id="formula_27">SHAP(â„, Ä“, ğ‘¥) def = âˆ‘ï¸ ğ‘† âŠ†ğ‘‹ \{ğ‘¥ } |ğ‘† |!(|ğ‘‹ | -|ğ‘† | -1)! |ğ‘‹ |! (â„ Ä“ (ğ‘† âˆª{ğ‘¥ })-â„ Ä“ (ğ‘†)),</formula><p>where ğ‘‹ is the set of ğ‘‘ features, ğ‘¥ is a specific feature whose contribution we wish to assess, and â„ Ä“ : 2 ğ‘‹ â†’ R is defined by</p><formula xml:id="formula_28">â„ Ä“ (ğ‘†) def = E zâˆ¼D [â„( z) | Ä“ğ‘† = zğ‘† ],</formula><p>where Ä“ğ‘† and zğ‘† denote the vectors Ä“ and z restricted to the features in ğ‘†.</p><p>In <ref type="bibr" target="#b21">[22]</ref> the authors have proposed a method for approximating SHAP values, called Kernel SHAP. Kernel SHAP assumes feature independence and estimates the probability by multiplying the marginal distributions ğ‘–âˆ‰ğ‘† Pr(ğ‘§ ğ‘– ). The marginal probabilities Pr(ğ‘§ ğ‘– ) in turn are estimated from a background data ğ‘‡ . To approximate SHAP values, Kernel SHAP then samples ğ‘š coalitions ğ‘† 1 , . . . , ğ‘† ğ‘š of features, and trains a linear model ğ‘” : 2 ğ‘‹ â†’ R by minimizing the weighted loss ğ‘š ğ‘–=1 ğ‘¤ ğ‘– â€¢ (ğ‘”(ğ‘† ğ‘– ) -Ä¥ Ä“ (ğ‘† ğ‘– )) 2 , where ğ‘¤ ğ‘– is proportional to the size of ğ‘† ğ‘– and Ä¥ Ä“ is the estimation of â„ Ä“ using the feature independence assumption. The coefficient associated with a feature ğ‘¥ in the trained model ğ‘” is the approximated SHAP value of ğ‘¥.</p><p>We adapt Kernel SHAP to our setting and use it to approximate the Shapley values of facts, as follows. The features are the input facts of the database, we set â„ to be the Boolean function representing the (endogenous) provenance; the vector of interest, Ä“, has the value 1 for all facts, and the background data ğ‘‡ contains a single example with value 0 in all its entries. Note that for such Ä“ and ğ‘‡ , Kernel SHAP estimates â„ Ä“ (ğ‘†) as the result of applying â„ to a vector with ones in ğ‘† features and zeros in the remaining entries.</p><p>The input of both Monte Carlo and Kernel SHAP includes a budget of ğ‘š samples; for provenance expressions containing ğ‘› distinct facts we have experimented with ğ‘š âˆˆ {10ğ‘›, 20ğ‘›, 30ğ‘›, 40ğ‘›, 50ğ‘›}.</p><p>Accuracy metrics To evaluate the performance of the above methods we have used various metrics, specified below. All metrics were computed with respect to the ground truth values obtained by the knowledge compilation approach, and thus these experiments are confined to the cases where the exact computation succeeded.</p><p>â€¢ nDCG is the normalized discounted cumulative gain score <ref type="bibr" target="#b37">[38]</ref>, used to compare the ordering based on the inexact solution to the ordering based on the ground truth. â€¢ Precision@k is the number of facts that appears in the top-ğ‘˜ of both the inexact and exact solutions, divided by ğ‘˜. This was evaluated for ğ‘˜ âˆˆ {1, 3, 5, 10}. â€¢ L1 and L2 are the mean absolute error and squared error, respectively, of the results of an inexact computation method    with respect to the ground truth (i.e. how different the results are from the actual Shapley values).</p><p>Execution time. Figure <ref type="figure" target="#fig_17">6a</ref> depicts the execution time of the above methods as a function of the sampling budget. The execution times of Monte Carlo and Kernel SHAP are rather similar, while the CNF Proxy method (which does not rely on sampling) is substantially faster, with a median of 0.72 milliseconds and a mean of 2.06 milliseconds for a single query output. Figures <ref type="figure" target="#fig_19">7a</ref> and<ref type="figure" target="#fig_19">7b</ref> depict the distribution and worst-case running times of the three methods (for Monte Carlo and Kernel SHAP we used a budget of 20 samples per fact) as function of the number of distinct facts in the provenance expressions. CNF Proxy is substantially faster than its competitors: in most cases CNF Proxy completes in few milliseconds and 4 seconds in the worst case, whereas Monte Carlo and Kernel SHAP median execution time for circuits with 101-200 distinct input facts are 59 and 62 seconds respectively and may take up to 1,539 seconds.</p><p>Recall our analysis of the execution time of the exact solution in Section 6.1. The computation of Shapley values (KC plus Algorithm 1) takes 27,600 seconds if performed for all output tuples of query q8d in the IMDB dataset; for comparison, the CNF Proxy method has (inexactly, see quality analysis below) computed the Shapley value of the proxy functions for all query outputs within 95 seconds, which is 0.3% of the exact computation time. Surprisingly, the execution time of the exact computation was comparable to Monte Carlo and Kernel SHAP, and even faster for large sampling budgets; For example, Kernel SHAP with ğ‘š = 10ğ‘› (where ğ‘› is the number of distinct facts in the provenance) has completed computation for all output tuples of the query q8d in 16,447 seconds, which is 59% of the exact computation time. For ğ‘š = 50ğ‘›, Kernel SHAP required 58,161 seconds for completion of this computation, which is 210% of the exact computation time. This means that using such a sampling budget for Kernel SHAP is impractical in this setting, and we will use it to obtain upper bounds on Kernel SHAP's quality. Quality analysis. Figures <ref type="figure" target="#fig_17">6b</ref> and<ref type="figure" target="#fig_17">6c</ref> depict the ranking quality of the above methods as a function of the sampling budget. The rankings were compared for output tuples where the exact computation succeeded, so we have the ground truth. Recall that CNF Proxy does not rely on sampling, and so it remains constant throughout the different budgets. Naturally, as the sampling budget grows, Monte Carlo and Kernel SHAP quality improves. Most notable is Monte Carlo improvement in terms of nDCG (Figure <ref type="figure" target="#fig_17">6b</ref>), where its median (resp., mean) nDCG with budget of 10 samples per fact is 0.9669 (resp., 0.9435), while with budget of 50 samples per fact it is 1.0 (resp., 0.9923). Comparison between the two sampling methods (Monte Carlo and Kernel SHAP) reveals that Kernel SHAP is superior w.r.t all metrics, across the entire budgets range. In terms of nDCG, all methods achieve rather high scores, but CNF Proxy performs best. Indeed, the median (resp., mean) nDCG of CNF Proxy is 1.0 (resp., 0.9989), while Kernel SHAP requires 50 samples per fact to get a median (resp., mean) nDCG of 1.0 (resp., 0.9986); as previously noted such budget leads to slower execution than that of the exact computation. It is worth mentioning that also when looking at nDCG@k for ğ‘˜ âˆˆ {1, 3, 5, 10}, CNF Proxy performs better than Monte Carlo and Kernel SHAP, even when allowing a budget of 50 samples per fact. In terms of identifying the top influential facts (i.e., Precision@k), CNF Proxy also outperforms the other methods. For example, CNF Proxy's median (resp., mean) Precision@10 are 1.0 (resp., 0.9688), while Kernel SHAP reaches 1.0 (resp., 0.9611) with 50 samples per fact. Similarly, CNF Proxy outperforms Monte Carlo and Kernel SHAP in terms of Precision@k for ğ‘˜ âˆˆ {1, 3, 5}.</p><p>Finally, Table <ref type="table" target="#tab_8">2</ref> zooms in on the results when fixing the budgets of Monte Carlo and Kernel SHAP to 50 samples per fact, which is the highest budget tested (already for this budget, computation of Monte Carlo and Kernel SHAP is slower than for the exact algorithm). Note that CNF Proxy is much faster then the other methods, while still being superior in terms of ranking (nDCG and Precision@k). As explained above, ranking of facts is indeed the use case we recommend for CNF Proxy. Unsurprisingly, Kernel SHAP achieves better distance from the exact Shapley values (L1 and L2), at the cost of being slower by several orders of magnitude.</p><p>Dependency on the provenance size. Figure <ref type="figure" target="#fig_19">7</ref> depicts the performance of Monte Carlo, Kernel SHAP, and CNF Proxy as a function of the number of facts in the provenance expression. The results are aggregated over all output tuples of all queries. Figure <ref type="figure" target="#fig_19">7c</ref> presents the quality of facts ranking (nDCG) as a function of the number of distinct provenance facts. CNF Proxy performs the best, and its quality remains steady regardless of the number of facts in the provenance expression. For example, with 1-10 facts the CNF Proxy median (resp., mean) nDCG is 1.0 (resp., 0.9999), and with 201-400 facts it is 0.9977 (resp., 0.9924). Kernel SHAP has a minor deterioration, where it drops from median (resp., mean) nDCG of 1.0 (resp., 0.9998) with 1-10 facts to 0.9906 (resp., 0.9888) with 201-400 facts. Figure <ref type="figure" target="#fig_19">7d</ref> zooms in on the aggregated results over the worst case expressions of all output tuples for all queries, and shows that even the worst case CNF Proxy is superior to the alternatives, and that the error in terms of nDCG is small (0.92 in the worst case evaluated). Figure <ref type="figure" target="#fig_19">7e</ref> depicts the dependency of Precision@10 on the number of provenance facts. Both Monte Carlo and Kernel SHAP suffer from a massive drop of median (resp., mean) Precision@10, down to 0.4 (resp., 0.476) and 0.6 (resp., 0.6253) respectively with 201-400 facts, while CNF Proxy remains at 0.8 (resp., 0.8293) median and mean Precision@10. A similar trend is observed for Precision@5, whereas for Precision@3 and Precision@1 the drop is less significant. Here again, Figure <ref type="figure" target="#fig_19">7f</ref> zooms in on the worst case and again shows the superiority of CNF Proxy.</p></div>
<div><head n="6.3">Hybrid computation</head><p>Recall that in Section 6.1 we have measured the success rate of the exact computation: for IMDB the success rate was 99.96% and for TPC-H the success rate was 84.43%. We saw in Section 6.2 that the inexact method CNF Proxy is very efficient and that the ranking of tuples based on CNF Proxy is typically close to the ranking obtained based on the real Shapley values.</p><p>In this section we consider a hybrid approach that works as follows. First, we start by running the exact computation, that is, the knowledge compilation step and Algorithm 1. If the exact computation completes successfully within less than ğ‘¡ seconds (where ğ‘¡ is configurable) we return its result. Otherwise, we terminate the exact computation and execute the inexact method CNF Proxy, returning only a ranking of input tuples rather than their Shapley values. Figure <ref type="figure" target="#fig_21">8a</ref> depicts the success rate of the exact computation given different timeouts. Note that given a timeout of 2.5 seconds, the exact computation succeed for 98.67% of the IMDB output tuples, and 83.83% for TPCH-H. Increasing the timeout has a rather minor impact on the success rate: having a 15 seconds timeout increases the success rate for IMDB to 99.52%, while the success rate for TPC-H remains unchanged. Recall that having a timeout of one hour results in success rates of 99.96% and 84.43% for IMDB and  TPC-H respectively. Figure <ref type="figure" target="#fig_21">8b</ref> depicts the mean execution time of the hybrid approach as a function of the chosen timeout ğ‘¡. Observe that given a timeout of 2.5 seconds the mean hybrid execution time is 0.31 seconds and 0.67 seconds for IMDB and TPC-H respectively. The mean execution time of the hybrid approach grows very moderately w.r.t. the timeout for IMDB (since most cases do not reach the timeout); it grows faster for TPC-H, where the difficult cases for which timeout is reached have a more significant effect on the overall mean execution time.</p><p>Main conclusions. Our experimental results indicate that for most output tuples (98.67% for IMDB and 83.83% for TPC-H) exact computation of Shapley values terminates within 2.5 seconds. When it does not, we propose an alternative of ranking facts according to CNF Proxy values, which typically only takes several milliseconds (up to 4 seconds for an outlier case). Experimental evidence shows that the ranking obtained via CNF Proxy is both much faster to compute and more accurate (in terms of nDCG and Precision@k, measured in cases where exact computation does succeed, and so we have the ground truth) than the alternative of only using sampling to approximate the actual Shapley values.</p></div>
<div><head n="7">CONCLUSION</head><p>We have proposed in this paper a first practical framework for computing the contributions of database facts in query answering, quantified through Shapley values. The framework includes an exact algorithm that computes the contribution of input facts, and a faster algorithm that is practically effective in ranking contributions of input facts, while producing inexact Shapley values. Our practical implementation is currently designed for SPJU queries (that is, to the class of queries supported by <software>ProvSQL</software>). In addition to these practical contributions, we have also established a theoretical connection between the problem of computing Shapley values and that of probabilistic query evaluation, by showing that, for every query, the former can be reduced in polynomial time to the latter.</p><p>We leave it open to determine whether there is also a reduction in the other direction (Open Problem 1). Other interesting directions would be to study further constructs such as aggregates and negation, or to extend the framework to bag semantics. Concerning bag semantics we observe that, by differentiating each copy of a same tuple in a bag database (for instance, adding an identifier attribute), our framework can be used as-is. Nevertheless, it would be interesting to see how one could adapt the definitions in order to consider fact multiplicities in a more elaborate way.</p></div><figure xml:id="fig_0"><head>Proposition 3 . 1 .</head><label>31</label><figDesc>For every Boolean query ğ‘, we have that Shapley(ğ‘) â‰¤ p T PQE(ğ‘).</figDesc></figure>
<figure xml:id="fig_1"><head>1 .</head><label>1</label><figDesc>Proof of Proposition 3.1. For a Boolean query ğ‘, database ğ· = ğ· x âˆª ğ· n , and integer ğ‘˜ âˆˆ {0, . . . , |ğ· n |}, define #Slices(ğ‘, ğ· x , ğ· n , ğ‘˜) def = |{ğ¸ âŠ† ğ· n | |ğ¸| = ğ‘˜ and ğ‘(ğ· x âˆª ğ¸) = 1}|.</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Deterministic and decomposable circuit for ELin(ğ‘, ğ· x , ğ· n ) from the running example.</figDesc></figure>
<figure xml:id="fig_3"><head>Proposition 4 . 4 .</head><label>44</label><figDesc>Given as input a deterministic and decomposable circuit ğ¶ representing ELin(ğ‘, ğ· n , ğ· x ) for a database ğ· = ğ· x âˆª ğ· n and Boolean query ğ‘, and an endogenous fact ğ‘“ âˆˆ ğ· n , we can compute in polynomial time (in |ğ¶ |) the value Shapley(ğ‘, ğ· n , ğ· x , ğ‘“ ).Next, we prove Proposition 4.4 and present the algorithm, and then explain in Section 4.2 the architecture of the implementation.</figDesc></figure>
<figure xml:id="fig_4"><head>Lemma 4 . 5 .</head><label>45</label><figDesc>Given as input a deterministic and decomposable Boolean circuit ğ¶ and an integer ğ‘˜ âˆˆ {0, . . . , |Vars(ğ¶)|}, we can compute in polynomial time the quantity #SAT ğ‘˜ (ğ¶). Proof. Our proof is similar to that of [3, Section 3.2]. Let ğ‘‹ def = Vars(ğ¶) and ğ‘› def = |ğ‘‹ |.</figDesc></figure>
<figure xml:id="fig_5"><head /><label /><figDesc>We now explain how to compute the first term, that is, |(SAT(ğœ‘ ğ‘” 1 ) âŠ— 2 ğ‘† 1 ) âˆ© {ğœˆ âŠ† Vars(ğ‘”) | |ğœˆ | = â„“ }|; the second term is similar. This is equal3 to min(â„“, |Vars(ğ‘” 1 ) |)</figDesc></figure>
<figure xml:id="fig_6"><head /><label /><figDesc>4. â–¡ Algorithm. Algorithm 1 depicts the solution underlying Proposition 4.4. The subroutine ComputeAll#SAT ğ‘˜ takes as input a d-D circuit ğ¶ and outputs all the values #SAT 0 (ğ¶), . . . , #SAT |Vars(ğ¶) | (ğ¶).</figDesc></figure>
<figure xml:id="fig_7"><head>Algorithm 2 : 4 L 5 ğ‘š â† |L|; 6 ğ‘ğ‘œğ‘  7 ğ‘›ğ‘’ğ‘” 8 for â„“ âˆˆ ğ‘ğ‘œğ‘  âˆ© ğ· n do 9 ğ‘£</head><label>2456789</label><figDesc>CNF ProxyInput : CNF ğœ‘ and a set of endogenous facts ğ· n . Output : The value Shapley( ğœ‘, ğ‘¥) for each ğ‘¥ âˆˆ ğ· n .1 ğ‘› â† |ğœ‘.ğ‘ğ‘™ğ‘ğ‘¢ğ‘ ğ‘’ğ‘  ()|; 2 ğ‘£ â† 0 |ğ· n | ;// As an array3 for ğœ“ âˆˆ ğœ‘.ğ‘ğ‘™ğ‘ğ‘¢ğ‘ ğ‘’ğ‘  () do â† ğœ“ .ğ‘™ğ‘–ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘™ğ‘  (); â† {â„“ âˆˆ L | â„“ is positive}; â† {â„“ âˆˆ L | â„“ is negative}; [â„“.ğ‘£ğ‘ğ‘Ÿ ()] â† ğ‘£ [â„“.ğ‘£ğ‘ğ‘Ÿ (ğ‘›ğ‘’ğ‘” âˆ© ğ· n do 12 ğ‘£ [â„“.ğ‘£ğ‘ğ‘Ÿ ()] â† ğ‘£ [â„“.ğ‘£ğ‘ğ‘Ÿ ()] -Now, note that for a CNF formula ğœ‘ = ğ‘› ğ‘–=1 ğœ“ ğ‘– (where each ğœ“ ğ‘– is a disjunction of literals) and an assignment ğœˆ it holds that ğœ‘ (ğœˆ) = ğ‘› ğ‘–=1 ğœ“ ğ‘– (ğœˆ). Instead of calculating the Shapley values of a CNF formula ğœ‘ (which may be a hard problem), CNF Proxy computes Shapley values with respect to a proxy function, denoted ğœ‘. The proxy function of ğœ‘ is defined as the sum (instead of the product) of the clauses of ğœ‘, i.e., ğœ‘ (ğœˆ)</figDesc></figure>
<figure xml:id="fig_8"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Our implementation architecture.</figDesc></figure>
<figure xml:id="fig_9"><head>Figure 4</head><label>4</label><figDesc>depicts the running time of the KC step and of the computation of Shapley values from the d-DNNF as a function of different features of the provenance, such as the number of facts appearing in the provenance, the number of clauses in its CNF representation, and the number of gates in its d-DNNF representation. Scalability. To evaluate the scalability of Algorithm 1 we have further looked at different scales of the TPC-H database.</figDesc></figure>
<figure xml:id="fig_10"><head /><label /><figDesc>Figure</figDesc></figure>
<figure xml:id="fig_11"><head>5</head><label>5</label><figDesc /></figure>
<figure xml:id="fig_12"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Running times of knowledge compilation and computation of Shapley values from the d-DNNF as function of the number of distinct facts, CNF clauses, and d-DNNF size</figDesc><graphic coords="11,322.76,255.02,115.31,72.85" type="bitmap" /></figure>
<figure xml:id="fig_13"><head>Figure 5a depicts 4</head><label>4</label><figDesc>representative query outputs, for which the running time takes a few milliseconds, e.g., for "Q3 23426" (result 23426 of query ğ‘„3) and the full TPC-H dataset, the computation of Shapley values for all relevant input facts complete in 4.3ms.</figDesc></figure>
<figure xml:id="fig_14"><head /><label /><figDesc>(a) Representative outputs (b) "Difficult" outputs</figDesc></figure>
<figure xml:id="fig_15"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Alg. 1 running time for various TPC-H query outputs as function of table lineitem size</figDesc><graphic coords="11,321.64,570.18,115.32,89.35" type="bitmap" /></figure>
<figure xml:id="fig_17"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Comparing various metrics for inexact methods as a function of the sampling budget; CNF Proxy does not rely on sampling, thus remains constant for all budgets.</figDesc><graphic coords="13,55.08,200.28,117.72,64.49" type="bitmap" /></figure>
<figure xml:id="fig_18"><head /><label /><figDesc>(a) Running time distribution (b) Worst case running time (c) nDCG Distribution (d) Worst case nDCG (e) Precision@10 distribution (f) Worst case Precision@10</figDesc></figure>
<figure xml:id="fig_19"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Comparing inexact methods as a function the number of distinct facts in the provenance (ğ‘›). Sampling methods (Kernel SHAP and Monte Carlo) presented with sampling budget of ğ‘š = 20ğ‘›; different budgets led to similar trends.</figDesc><graphic coords="13,55.08,358.63,117.72,64.99" type="bitmap" /></figure>
<figure xml:id="fig_20"><head /><label /><figDesc>(a) Exact computation success rate as function of the computation timeout (b) Mean execution time of the hybrid approach as a function of the computation timeout</figDesc></figure>
<figure xml:id="fig_21"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Hybrid approach performance</figDesc><graphic coords="14,440.64,83.69,115.32,98.42" type="bitmap" /></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>3 , ğ‘ 6 , ğ‘ 8 }, {ğ‘ 2 , ğ‘ 3 , ğ‘ 7 , ğ‘ 8 }, {ğ‘ 4 , ğ‘ 5 , ğ‘ 6 , ğ‘ 8 }, and {ğ‘ 4 , ğ‘ 5 , ğ‘ 7 , ğ‘ 8 }, and overall 14 triplets (left to the reader). Summing it all up results in</figDesc><table /></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>ğ· n , ğ· x , ğ‘ ğ‘– ) = 23 210 â‰ˆ 0.1095, and that for ğ‘ ğ‘– âˆˆ {ğ‘ 6 , ğ‘ 7 } we have Shapley(ğ‘, ğ· n , ğ· x , ğ‘ ğ‘– ) = 8 105 â‰ˆ 0.0762.</figDesc><table><row><cell /><cell /><cell>â‰ˆ 0.4095.</cell></row><row><cell /><cell /><cell>105</cell></row><row><cell cols="3">Similarly one can compute the Shapley value of the remaining facts,</cell></row><row><cell>and find that for ğ‘ ğ‘–</cell><cell>âˆˆ</cell><cell>{ğ‘ 2 , ğ‘ 3 , ğ‘ 4 , ğ‘ 5 } it holds that</cell></row><row><cell>Shapley(ğ‘,</cell><cell /><cell /></row></table></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>#P -hard). It turns out that the tractability criterion that</figDesc><table><row><cell /><cell /><cell /><cell /><cell /><cell /><cell>ğ‘ 6</cell><cell /><cell /></row><row><cell /><cell /><cell /><cell /><cell /><cell>LAX</cell><cell cols="2">MUC</cell><cell /></row><row><cell cols="2">Flights (endo)</cell><cell /><cell cols="2">Airports (exo)</cell><cell /><cell /><cell /><cell>ğ‘</cell></row><row><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell>7</cell></row><row><cell>Src</cell><cell>Dest</cell><cell /><cell cols="2">Name Country</cell><cell /><cell /><cell /><cell /></row><row><cell>ğ‘ 1 ğ‘ 2 EWR JFK</cell><cell>CDG LHR</cell><cell cols="2">ğ‘ 1 ğ‘ 2 EWR JFK</cell><cell>USA USA</cell><cell>BOS</cell><cell>3 ğ‘</cell><cell>ğ‘ 8</cell><cell>ğ‘ 5</cell><cell>ORY</cell></row><row><cell>ğ‘ 3 BOS</cell><cell>LHR</cell><cell>ğ‘ 3</cell><cell>BOS</cell><cell>USA</cell><cell /><cell cols="2">LHR</cell><cell /></row><row><cell>ğ‘ 4 LHR</cell><cell>CDG</cell><cell>ğ‘ 4</cell><cell>LAX</cell><cell>USA</cell><cell /><cell>ğ‘ 2</cell><cell /><cell /></row><row><cell>ğ‘ 5 LHR</cell><cell>ORY</cell><cell>ğ‘ 5</cell><cell>LHR</cell><cell>EN</cell><cell>EWR</cell><cell /><cell /><cell>ğ‘ 4</cell></row><row><cell>ğ‘ 6 LAX</cell><cell>MUC</cell><cell cols="2">ğ‘ 6 MUC</cell><cell>GR</cell><cell /><cell /><cell /><cell /></row><row><cell>ğ‘ 7 MUC</cell><cell>ORY</cell><cell>ğ‘ 7</cell><cell>ORY</cell><cell>FR</cell><cell /><cell>ğ‘ 1</cell><cell /><cell /></row><row><cell /><cell /><cell /><cell /><cell /><cell>JFK</cell><cell /><cell /><cell /><cell>CDG</cell></row><row><cell>ğ‘ 8 LHR</cell><cell>MUC</cell><cell>ğ‘ 8</cell><cell>CDG</cell><cell>FR</cell><cell /><cell /><cell /><cell /></row><row><cell /><cell /><cell /><cell /><cell /><cell cols="5">(b) Flights in graph view. Dark</cell></row><row><cell cols="4">(a) Database of flights and airports</cell><cell /><cell cols="5">and light gray depict "USA"</cell></row><row><cell /><cell /><cell /><cell /><cell /><cell cols="5">and "FR" airports respectively</cell></row></table></figure>
<figure type="table" xml:id="tab_3"><head /><label /><figDesc>For a gate ğ‘” of ğ¶, we denote by Vars(ğ‘”) the set of variables that have a directed path to ğ‘”. An âˆ§-gate ğ‘” of ğ¶ is decomposable if for every two input gates ğ‘” 1 â‰  ğ‘” 2 of ğ‘” we have Vars(ğ‘” 1 ) âˆ© Vars(ğ‘” 2 ) = âˆ…. We call ğ¶ decomposable if all âˆ§-gates are. An âˆ¨-gate ğ‘” of ğ¶ is deterministic if the Boolean functions captured by each pair of distinct input gates of ğ‘” are pairwise disjoint; i.e., no assignment satisfies both. We call ğ¶ deterministic if all âˆ¨-gates in it are. A deterministic and decomposable (d-D [26]) Boolean circuit is a Boolean circuit that is both deterministic and decomposable. If ğ¶ is a Boolean circuit we write Vars(ğ¶) to denote the set of variables that appear in it. Example 4.3. Recall ELin(ğ‘, ğ· n , ğ· x ) from Example (4.2) represented as a DNF. Figure 2 depicts a d-D circuit for ELin(ğ‘, ğ· n , ğ· x ).</figDesc><table /></figure>
<figure type="table" xml:id="tab_4"><head>=</head><label /><figDesc>ğœˆ 2 âˆˆ ğ‘† 2 }. We next show how to compute the values ğ›¼ â„“ ğ‘” by bottom-up induction on ğ¶. Variable gate. If ğ‘” is a variable gate corresponding to some variable ğ‘¦, then Vars(ğ‘”) = {ğ‘¦}. Then, ğ›¼ 0 ğ‘” is 0 and ğ›¼ 1 ğ‘” is 1. Â¬-gate. If ğ‘” is a Â¬-gate with input gate ğ‘” â€² , then ğ›¼ â„“ ğ‘” = Deterministic âˆ¨-gate. If ğ‘” is a deterministic âˆ¨-gate with no input then ğœ‘ ğ‘” is the Boolean function on variables Vars(ğ‘”) = âˆ… that is always false, hence ğ›¼ 0 ğ‘” = 0. Otherwise ğ‘” has exactly two input gates; let us denote them ğ‘” 1 and ğ‘” 2 . Observe that Vars(ğ‘”) = Vars(ğ‘” 1 ) âˆª Vars(ğ‘” 2 ) by definition. De-Vars(ğ‘” 2 ) \Vars(ğ‘” 1 ) and similarly ğ‘† 2 def = Vars(ğ‘” 1 ) \ Vars(ğ‘” 2 ). Since ğ‘” is deterministic, we have:</figDesc><table><row><cell /><cell>|Vars(ğ‘”) | ğ‘™</cell><cell>-</cell></row><row><cell>ğ›¼ â„“</cell><cell /></row><row><cell>ğ‘” fine ğ‘† 1</cell><cell>def</cell></row></table><note><p>â€² for every â„“ âˆˆ {0, . . . , |Vars(ğ‘”)|}.</p></note></figure>
<figure type="table" xml:id="tab_5"><head>Algorithm 1 :</head><label>1</label><figDesc>Shapley values from deterministic and decomposable Boolean circuits Input : Deterministic and decomposable Boolean circuit ğ¶ with output gate ğ‘” output representing ELin(ğ‘, ğ· x , ğ· n ) and an endogenous fact ğ‘“ âˆˆ ğ· n . Output : The value Shapley(ğ‘, ğ· x , ğ· n , ğ‘“ ). Complete ğ¶ so that Vars(ğ‘” output ) = ğ· n ; 2 Compute ğ¶ 1 = ğ¶ [ğ‘“ â†’ 1] and ğ¶ 2 = ğ¶ [ğ‘“ â†’ 0]; // Partial evaluations of ğ¶ by setting ğ‘“ to 1 and to 0 âˆˆ {0, . . . , |Vars(ğ‘”)|} by bottom-up induction on ğ¶ using the inductive relations from the proof of Lemma 4.5;</figDesc><table><row><cell cols="4">3 Î“ = ComputeAll#SAT ğ‘˜ (ğ¶ 1 );</cell><cell>// As an array</cell></row><row><cell cols="4">4 Î” = ComputeAll#SAT ğ‘˜ (ğ¶ 2 );</cell><cell>// As an array</cell></row><row><cell /><cell /><cell>|ğ· n |-1</cell><cell /></row><row><cell cols="2">5 return</cell><cell>âˆ‘ï¸</cell><cell /></row><row><cell>10</cell><cell cols="2">return [ğ›¼ 0 ğ‘” output , . . . , ğ›¼</cell><cell>|Vars(ğ¶) | ğ‘” output</cell><cell>];</cell></row></table><note><p><p><p>1 ğ‘˜=0 ğ‘˜! (|ğ· n | -ğ‘˜ -1)! |ğ· n |! â€¢ (Î“ [ğ‘˜] -Î”[ğ‘˜]); 6 Def ComputeAll#SAT ğ‘˜ (C):</p>7</p>Preprocess ğ¶ so that each âˆ¨-gate and âˆ§-gate has fan-in exactly 0 or 2; 8 Compute the set Vars(ğ‘”) for every gate ğ‘” in ğ¶; 9 Compute values ğ›¼ â„“ ğ‘” for every gate ğ‘” in ğ¶ and â„“</p></note></figure>
<figure type="table" xml:id="tab_6"><head /><label /><figDesc>2. Let â„ = ğ‘› ğ‘–=1 1 ğ‘› ğœ“ ğ‘– , where each ğœ“ ğ‘– is a Boolean function representing a disjunction of literals. Without loss of generality let us assume that for each ğœ“ ğ‘– there is no variable that appears in more than one literal of ğœ“ ğ‘– . Denote by ğ‘ ğ‘– and ğ‘ ğ‘– the number of positive and negative literals in ğœ“ ğ‘– respectively. Then, for every variable ğ‘¥, it holds Shapley(ğ‘[ x/t], ğ· x , ğ· n , ğ‘“ ) The Shapley value Algorithm 1 d-DNNF ğ¶ â€²â€²â€² for ELin(ğ‘[ x/t], ğ· x , ğ· n )</figDesc><table><row><cell /><cell /><cell /><cell cols="2">Lemma 4.6</cell><cell cols="2">d-DNNF ğ¶ â€²â€² (w/ extra vars)</cell></row><row><cell /><cell /><cell>(w/o extra vars)</cell><cell /><cell /><cell cols="2">equivalent to ğœ‘</cell></row><row><cell /><cell /><cell /><cell /><cell /><cell cols="2">Knowledge</cell></row><row><cell /><cell /><cell /><cell /><cell /><cell /><cell>compiler</cell></row><row><cell>Database ğ· = ğ· x âˆª ğ· n</cell><cell /><cell>Partial eval: set</cell><cell /><cell /><cell>Tseytin</cell></row><row><cell>Query ğ‘( x) Fact ğ‘“ âˆˆ ğ· n Answer t ProvSQL</cell><cell>for Lin(ğ‘[ x/t], ğ·) Boolean circuit ğ¶</cell><cell>exo vars to 1</cell><cell cols="2">ELin(ğ‘[ x/t], ğ· x , ğ· n ) Bool. circuit ğ¶ â€² for</cell><cell>transform</cell><cell>CNF formula ğœ‘ (w/ extra vars) Proxy</cell></row><row><cell /><cell /><cell /><cell /><cell /><cell /><cell>formula</cell></row><row><cell>Input</cell><cell /><cell cols="2">The value Shapley( ğœ‘, ğ‘“ )</cell><cell cols="2">Algorithm 2</cell><cell>ğœ‘ (w/ extra vars)</cell></row><row><cell /><cell /><cell cols="2">(heuristics)</cell><cell /><cell /></row></table></figure>
<figure type="table" xml:id="tab_7"><head>Table 1 :</head><label>1</label><figDesc>Statistics on the exact computation of Shapley values for 16 representative queries</figDesc><table><row><cell /><cell /><cell>#Joined</cell><cell>#Filter</cell><cell>Execution</cell><cell>#Output</cell><cell>Success</cell><cell cols="4">KC execution times [sec]</cell><cell /><cell /><cell cols="3">Alg. 1 execution times [sec]</cell></row><row><cell cols="2">Dataset Query</cell><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /><cell /></row><row><cell /><cell /><cell>tables</cell><cell>conditions</cell><cell>time [sec]</cell><cell>tuples</cell><cell>rate</cell><cell cols="4">Mean p25 p50 p75</cell><cell>p99</cell><cell>Mean</cell><cell>p25</cell><cell>p50</cell><cell>p75</cell><cell>p99</cell></row><row><cell /><cell>3</cell><cell>3</cell><cell>5</cell><cell>20980.71</cell><cell>100</cell><cell>100%</cell><cell>0.06</cell><cell cols="3">0.04 0.07 0.08</cell><cell>0.13</cell><cell>0.00</cell><cell>0.00</cell><cell>0.00</cell><cell>0.00</cell><cell>0.01</cell></row><row><cell /><cell>5</cell><cell>6</cell><cell>9</cell><cell>48.67</cell><cell>5</cell><cell>0%</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>-</cell></row><row><cell>TPC-H</cell><cell>7 10 11</cell><cell>6 4 6</cell><cell>8 6 7</cell><cell>30.57 4.72 0.13</cell><cell>4 10 10</cell><cell>0% 100% 100%</cell><cell>-0.14 0.09</cell><cell cols="3">-0.13 0.13 0.14 --0.08 0.08 0.08</cell><cell>-0.19 0.13</cell><cell>-0.01 0.01</cell><cell>-0.01 0.00</cell><cell>-0.01 0.00</cell><cell>-0.01 0.01</cell><cell>-0.01 0.03</cell></row><row><cell /><cell>16</cell><cell>3</cell><cell>5</cell><cell>1.25</cell><cell>10</cell><cell>100%</cell><cell>0.26</cell><cell cols="3">0.13 0.18 0.33</cell><cell>0.57</cell><cell>0.18</cell><cell>0.01</cell><cell>0.03</cell><cell>0.29</cell><cell>0.88</cell></row><row><cell /><cell>18</cell><cell>4</cell><cell>3</cell><cell>37.31</cell><cell>10</cell><cell>100%</cell><cell>0.13</cell><cell cols="3">0.08 0.08 0.18</cell><cell>0.23</cell><cell>0.01</cell><cell>0.00</cell><cell>0.01</cell><cell>0.01</cell><cell>0.03</cell></row><row><cell /><cell>19</cell><cell>2</cell><cell>21</cell><cell>2.04</cell><cell>1</cell><cell>100%</cell><cell>1.20</cell><cell cols="3">1.20 1.20 1.20</cell><cell>1.20</cell><cell cols="4">156.06 156.06 156.06 156.06</cell><cell>156.06</cell></row><row><cell /><cell>1a</cell><cell>5</cell><cell>10</cell><cell>0.25</cell><cell>35</cell><cell>100%</cell><cell>0.17</cell><cell cols="3">0.08 0.08 0.13</cell><cell>2.10</cell><cell>5.92</cell><cell>0.01</cell><cell>0.01</cell><cell>0.01</cell><cell>206.72</cell></row><row><cell /><cell>6b</cell><cell>5</cell><cell>8</cell><cell>2.61</cell><cell>1</cell><cell>100%</cell><cell>0.44</cell><cell cols="3">0.44 0.44 0.44</cell><cell>0.44</cell><cell>0.08</cell><cell>0.08</cell><cell>0.08</cell><cell>0.08</cell><cell>0.08</cell></row><row><cell /><cell>7c</cell><cell>8</cell><cell>21</cell><cell>77.33</cell><cell>2415</cell><cell>99%</cell><cell>0.82</cell><cell cols="3">0.18 0.28 0.63</cell><cell>9.44</cell><cell>24.28</cell><cell>0.02</cell><cell>0.05</cell><cell>0.39</cell><cell>787.12</cell></row><row><cell>IMDB</cell><cell>8d 11a</cell><cell>7 8</cell><cell>10 18</cell><cell>145.10 3.20</cell><cell>44517 10</cell><cell>99.9% 100%</cell><cell>0.26 0.75</cell><cell cols="3">0.13 0.18 0.29 0.18 0.48 1.14</cell><cell>1.09 2.15</cell><cell>0.36 23.34</cell><cell>0.01 0.01</cell><cell>0.02 0.13</cell><cell>0.05 1.27</cell><cell>2.28 151.99</cell></row><row><cell /><cell>11d</cell><cell>8</cell><cell>16</cell><cell>56.99</cell><cell>210</cell><cell>98.1%</cell><cell>0.99</cell><cell cols="3">0.19 0.32 0.78</cell><cell>5.97</cell><cell>96.19</cell><cell>0.02</cell><cell>0.06</cell><cell>0.48</cell><cell>1650.72</cell></row><row><cell /><cell>13c</cell><cell>9</cell><cell>19</cell><cell>2.44</cell><cell>14</cell><cell>100%</cell><cell>0.22</cell><cell cols="3">0.13 0.18 0.28</cell><cell>0.53</cell><cell>0.02</cell><cell>0.01</cell><cell>0.01</cell><cell>0.01</cell><cell>0.06</cell></row><row><cell /><cell>15d</cell><cell>9</cell><cell>18</cell><cell>24.25</cell><cell>207</cell><cell>97.6%</cell><cell>1.89</cell><cell cols="4">0.24 0.48 1.28 10.01</cell><cell>70.05</cell><cell>0.06</cell><cell>0.30</cell><cell>3.52</cell><cell>1821.13</cell></row><row><cell /><cell>16a</cell><cell>8</cell><cell>15</cell><cell>5.56</cell><cell>173</cell><cell>100%</cell><cell>0.18</cell><cell cols="3">0.13 0.14 0.20</cell><cell>0.53</cell><cell>0.02</cell><cell>0.01</cell><cell>0.01</cell><cell>0.02</cell><cell>0.12</cell></row></table></figure>
<figure type="table" xml:id="tab_8"><head>Table 2 :</head><label>2</label><figDesc>Median (resp., mean) performance. Monte Carlo and Kernel SHAP use 50 â€¢ #facts samples</figDesc><table><row><cell /><cell cols="2">Monte Carlo Kernel SHAP</cell><cell>CNF Proxy</cell></row><row><cell cols="2">Execution time 0.079 (1.875)</cell><cell cols="2">0.127 (1.978) 7e-4 (0.002)</cell></row><row><cell>L1</cell><cell cols="3">0.439 (0.448) 0.110 (0.109) 0.317 (0.315)</cell></row><row><cell>L2</cell><cell>0.03 (0.034)</cell><cell cols="2">0.001 (0.002) 0.010 (0.014)</cell></row><row><cell>nDCG</cell><cell>1.0 (0.992)</cell><cell>1.0 (0.998)</cell><cell>1.0 (0.999)</cell></row><row><cell>Precision@5</cell><cell>1.0 (0.955)</cell><cell>1.0 (0.961)</cell><cell>1.0 (0.989)</cell></row><row><cell>Precision@10</cell><cell>1.0 (0.953)</cell><cell>1.0 (0.961)</cell><cell>1.0 (0.968)</cell></row></table></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>This notion of safety is distinct from the "usual" notion of query safety<ref type="bibr" target="#b0">[1]</ref> that ensures domain independence.</p></note>
			<note place="foot" n="3" xml:id="foot_1"><p>This comes from the fact that, for disjoint ğ‘‹ 1 , ğ‘‹ 2 and assignments ğœˆ 1 of ğ‘‹ 1 and ğœˆ 2 of ğ‘‹ 2 we have |ğœˆ 1 âˆª ğœˆ 2 | = |ğœˆ 1 | + |ğœˆ 2 |, and Vars(ğœ‘ ğ‘” 1 ) and ğ‘† 1 are disjoint.</p></note>
			<note place="foot" n="4" xml:id="foot_2"><p>This additional NNF restriction is not important here, but, as far as we know, no knowledge compiler has the more general "deterministic and decomposable circuits" (without NNF) as a target. It is currently unknown whether d-DNNFs and deterministic and decomposable circuits are exponentially separated or not<ref type="bibr" target="#b10">[11,</ref> Table 7].</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This research has been partially funded by the <rs type="funder">European Research Council (ERC)</rs> under the <rs type="funder">European Union</rs>'s <rs type="programName">Horizon 2020 research and innovation programme</rs> (Grant agreement No. <rs type="grantNumber">804302</rs>). The work of <rs type="person">Benny Kimelfeld</rs> was supported by the <rs type="funder">Israel Science Foundation (ISF)</rs>, Grant <rs type="grantNumber">768/19</rs>, and the <rs type="funder">German Research Foundation (DFG)</rs> Project <rs type="grantNumber">412400621</rs> (<rs type="programName">DIP program</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_ZHx227U">
					<idno type="grant-number">804302</idno>
					<orgName type="program" subtype="full">Horizon 2020 research and innovation programme</orgName>
				</org>
				<org type="funding" xml:id="_WQYsqJu">
					<idno type="grant-number">768/19</idno>
				</org>
				<org type="funding" xml:id="_4RGR6kx">
					<idno type="grant-number">412400621</idno>
					<orgName type="program" subtype="full">DIP program</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<ptr target="http://webdam.inria.fr/Alice/" />
	</analytic>
	<monogr>
		<title level="m">Foundations of Databases</title>
		<title level="s">Addison-Wesley Reading</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>BarcelÃ³</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MikaÃ«l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2104.08015" />
		<title level="m">On the complexity of SHAP-score-based explanations: Tractability via knowledge compilation and non-approximability results</title>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The tractability of SHAP-score-based explanations over deterministic and decomposable Boolean circuits</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>BarcelÃ³</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MikaÃ«l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2007.14045" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI</title>
		<meeting>AAAI</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Curated databases</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang-Chiew</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
		<ptr target="https://homepages.inf.ed.ac.uk/opb/papers/inv.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sanjeev</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tan</forename><surname>Wang-Chiew</surname></persName>
		</author>
		<ptr target="https://repository.upenn.edu/cgi/viewcontent.cgi?article=1209&amp;context=cis_papers" />
	</analytic>
	<monogr>
		<title level="m">ICDT. Springer</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="316" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Tracing the lineage of view data in a warehousing environment</title>
		<author>
			<persName><forename type="first">Yingwei</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janet</forename><forename type="middle">L</forename><surname>Wiener</surname></persName>
		</author>
		<ptr target="http://ilpubs.stanford.edu:8090/252/1/1997-3.pdf" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="227" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient query evaluation on probabilistic databases</title>
		<author>
			<persName><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://homes.cs.washington.edu/~suciu/vldbj-probdb.pdf" />
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="523" to="544" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The dichotomy of probabilistic inference for unions of conjunctive queries</title>
		<author>
			<persName><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://homes.cs.washington.edu/~suciu/jacm-dichotomy.pdf" />
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1" to="87" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On the tractable counting of theory models and its application to truth maintenance and belief revision</title>
		<author>
			<persName><forename type="first">Adnan</forename><surname>Darwiche</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/cs/0003044" />
	</analytic>
	<monogr>
		<title level="j">J. Applied Non-Classical Logics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1" to="2" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">New advances in compiling CNF to decomposable negation normal form</title>
		<author>
			<persName><forename type="first">Adnan</forename><surname>Darwiche</surname></persName>
		</author>
		<ptr target="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.178.2262" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of ECAI. Citeseer</title>
		<meeting>ECAI. Citeseer</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="328" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A knowledge compilation map</title>
		<author>
			<persName><forename type="first">Adnan</forename><surname>Darwiche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Marquis</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1106.1819" />
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="229" to="264" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Explaining natural language query results</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nave</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amir</forename><surname>Gilad</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2007.04454" />
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="485" to="508" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nave</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MikaÃ«l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://github.com/navefr/ShapleyForDbFacts" />
		<title level="m">Shapley for database facts source code</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">Grigoris</forename><surname>Todd J Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><surname>Tannen</surname></persName>
		</author>
		<ptr target="https://repository.upenn.edu/cgi/viewcontent.cgi?article=1022&amp;context=db_research" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The semiring framework for database provenance</title>
		<author>
			<persName><forename type="first">J</forename><surname>Todd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><surname>Tannen</surname></persName>
		</author>
		<idno type="DOI">10.1145/3034786.3056125</idno>
		<ptr target="https://dl.acm.org/doi/10.1145/3034786.3056125" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="93" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the measure of conflicts: Shapley inconsistency values</title>
		<author>
			<persName><forename type="first">Anthony</forename><surname>Hunter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">SÃ©bastien</forename><surname>Konieczny</surname></persName>
		</author>
		<ptr target="http://www.cril.univ-artois.fr/~konieczny/papers/aij10a.pdf" />
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">174</biblScope>
			<biblScope unit="page" from="1007" to="1026" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Incomplete Information in Relational Databases</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Witold</forename><surname>Lipski</surname><genName>Jr</genName></persName>
		</author>
		<idno type="DOI">10.1145/1634.1886</idno>
		<ptr target="https://doi.org/10.1145/1634.1886" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984">1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Knowledge compilation meets database theory: compiling queries to decision diagrams</title>
		<author>
			<persName><forename type="first">Abhay</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00224-012-9392-5</idno>
		<ptr target="https://link.springer.com/article/10.1007/s00224-012-9392-5" />
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="403" to="440" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">How good are query optimizers, really?</title>
		<author>
			<persName><forename type="first">Viktor</forename><surname>Leis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atanas</forename><surname>Mirchev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfons</forename><surname>Kemper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
		<ptr target="https://www.vldb.org/pvldb/vol9/p204-leis.pdf" />
	</analytic>
	<monogr>
		<title level="j">Proceedings of the VLDB Endowment</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="204" to="215" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Shapley value of tuples in query answering</title>
		<author>
			<persName><forename type="first">Ester</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><forename type="middle">E</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><surname>Sebag</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1904.08679" />
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">From local explanations to global understanding with explainable AI for trees</title>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Scott M Lundberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hugh</forename><surname>Erion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><surname>Degrave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bala</forename><surname>Jordan M Prutkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronit</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nisha</forename><surname>Himmelfarb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Su-In</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName><surname>Lee</surname></persName>
		</author>
		<ptr target="https://arxiv.org/pdf/1905.04610.pdf" />
	</analytic>
	<monogr>
		<title level="j">Nature machine intelligence</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="2522" to="5839" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A unified approach to interpreting model predictions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Su-In</forename><surname>Lundberg</surname></persName>
		</author>
		<author>
			<persName><surname>Lee</surname></persName>
		</author>
		<ptr target="http://papers.nips.cc/paper/7062-a-unified-approach-to-interpreting-model-predictions.pdf" />
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="4765" to="4774" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Values for large games, IV: Evaluating the Electoral College by Monte Carlo Techniques</title>
		<author>
			<persName><forename type="first">Irwin</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName><surname>Shapley</surname></persName>
		</author>
		<idno>2651</idno>
		<ptr target="https://www.rand.org/pubs/research_memoranda/RM2651.html" />
		<imprint>
			<date type="published" when="1960">1960. 1960</date>
			<publisher>The Rand Corporation</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Research Memorandum</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The complexity of causality and responsibility for query answers and non-answers</title>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Gatterbauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katherine</forename><forename type="middle">F</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://www.vldb.org/pvldb/vol4/p34-meliou.pdf" />
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="34" to="45" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Causality and explanations in databases</title>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/pvldb/vol7/p1715-meliou.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB)</title>
		<meeting>the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1715" to="1716" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Solving a Special Case of the Intensional vs Extensional Conjecture in Probabilistic Databases</title>
		<author>
			<persName><forename type="first">MikaÃ«l</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1912.11864" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="149" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The impact of negation on the complexity of the Shapley value in conjunctive queries</title>
		<author>
			<persName><forename type="first">Alon</forename><surname>Reshef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ester</forename><surname>Livshits</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1912.12610" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of PODS</title>
		<meeting>PODS</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="285" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName><forename type="first">Alvin</forename><forename type="middle">E</forename><surname>Roth</surname></persName>
		</author>
		<ptr target="http://www.library.fa.ru/files/Roth2.pdf" />
		<title level="m">The Shapley Value: Essays in Honor of Lloyd S. Shapley</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Explaining query answers with explanation-ready databases</title>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurel</forename><forename type="middle">J</forename><surname>Orr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/pvldb/vol9/p348-roy.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB)</title>
		<meeting>the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="348" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Quantifying causal effects on query answering in databases</title>
		<author>
			<persName><forename type="first">Babak</forename><surname>Salimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><forename type="middle">E</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><surname>Van Den Broeck</surname></persName>
		</author>
		<ptr target="http://web.cs.ucla.edu/~guyvdb/papers/SalimiTaPP16.pdf" />
	</analytic>
	<monogr>
		<title level="m">TaPP. USENIX Association</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Provsql: Provenance and probability management in postgresql</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Jachiet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silviu</forename><surname>Maniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Ramusat</surname></persName>
		</author>
		<ptr target="https://hal.inria.fr/hal-01851538/file/p976-senellart.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment (PVLDB)</title>
		<meeting>the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="2034" to="2037" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A value for n-person games</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName><surname>Shapley</surname></persName>
		</author>
		<ptr target="http://www.library.fa.ru/files/Roth2.pdf#page=39" />
	</analytic>
	<monogr>
		<title level="j">Contributions to the Theory of Games</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="307" to="317" />
			<date type="published" when="1953">1953. 1953</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Probabilistic Databases</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>RÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<idno type="DOI">10.2200/S00362ED1V01Y201105DTM016</idno>
		<ptr target="https://www.morganclaypool.com/doi/abs/10.2200/S00362ED1V01Y201105DTM016" />
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Morgan &amp; Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<ptr target="http://www.tpc.org/tpc_documents_current_versions/pdf/tpc-h_v2.17.2.pdf" />
		<title level="m">Transaction Processing Performance Council (TPC)</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>TPC-H benchmark</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On the complexity of derivation in propositional calculus</title>
		<author>
			<persName><surname>Grigori S Tseitin</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-81955-1_28</idno>
		<ptr target="https://link.springer.com/chapter/10.1007/978-3-642-81955-1_28" />
	</analytic>
	<monogr>
		<title level="m">Automation of reasoning</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="466" to="483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On the tractability of shap explanations</title>
		<author>
			<persName><forename type="first">Guy</forename><surname>Van Den Broeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anton</forename><surname>Lykov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maximilian</forename><surname>Schleich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2009.08634" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI</title>
		<meeting>AAAI</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The complexity of relational query languages</title>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<ptr target="http://www.dis.uniroma1.it/~degiacom/didattica/semingsoft/SIS05-06/materiale/1-query-congiuntive/riferimenti/vardi-1982.pdf" />
	</analytic>
	<monogr>
		<title level="m">STOC. ACM</title>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A theoretical analysis of NDCG ranking measures</title>
		<author>
			<persName><forename type="first">Yining</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liwei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuanzhi</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Di</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tie-Yan</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.680.490&amp;rep=rep1&amp;type=pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of COLT</title>
		<meeting>COLT</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Inconsistency Measures for Repair Semantics in OBDA</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srdjan</forename><surname>Vesic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Madalina</forename><surname>Croitoru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bisquert</surname></persName>
		</author>
		<ptr target="https://www.ijcai.org/proceedings/2018/0273.pdf" />
	</analytic>
	<monogr>
		<title level="m">IJCAI. ijcai.org</title>
		<imprint>
			<date type="published" when="1977">2018. 1977-1983</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</teiCorpus></text>
</TEI>