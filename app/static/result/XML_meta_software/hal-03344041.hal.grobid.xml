<?xml version='1.0' encoding='utf-8'?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 http://api.archives-ouvertes.fr/documents/aofr-sword.xsd">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>HAL TEI export of hal-03344041v2</title>
      </titleStmt>
      <publicationStmt>
        <distributor>CCSD</distributor>
        <availability status="restricted">
          <licence target="http://creativecommons.org/licenses/by/4.0/">Distributed under a Creative Commons Attribution 4.0 International License</licence>
        </availability>
        <date when="2024-04-25T22:45:40+02:00" />
      </publicationStmt>
      <sourceDesc>
        <p part="N">HAL API platform</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <listBibl>
        <biblFull>
          <titleStmt>
            <title xml:lang="en">Toward Generic Abstractions for Data of Any Model</title>
            <author role="aut">
              <persName>
                <forename type="first">Nelly</forename>
                <surname>Barret</surname>
              </persName>
              <email type="md5">803e10717e273bcabe5d672b975e1fea</email>
              <email type="domain">inria.fr</email>
              <idno type="idhal" notation="string">nelly-barret</idno>
              <idno type="idhal" notation="numeric">742715</idno>
              <idno type="halauthorid" notation="string">44197-742715</idno>
              <idno type="ORCID">https://orcid.org/0000-0002-3469-4149</idno>
              <idno type="GOOGLE SCHOLAR">https://scholar.google.com/citations?user=t2mRA04AAAAJ&amp;hl=en&amp;authuser=1</idno>
              <affiliation ref="#struct-241115" />
              <affiliation ref="#struct-451441" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Ioana</forename>
                <surname>Manolescu</surname>
              </persName>
              <email type="md5">198b5d07a89578a2f2e563c17579cde7</email>
              <email type="domain">inria.fr</email>
              <idno type="idhal" notation="string">ioana-manolescu</idno>
              <idno type="idhal" notation="numeric">742652</idno>
              <idno type="halauthorid" notation="string">16724-742652</idno>
              <idno type="ORCID">https://orcid.org/0000-0002-0425-2462</idno>
              <idno type="GOOGLE SCHOLAR">https://scholar.google.com/citations?user=q6Ft35wAAAAJ&amp;hl=en</idno>
              <orgName ref="#struct-300009" />
              <affiliation ref="#struct-241115" />
              <affiliation ref="#struct-451441" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Prajna</forename>
                <surname>Upadhyay</surname>
              </persName>
              <email type="md5">f86e66fa3050d3b1e4fd1f9b6ad08a07</email>
              <email type="domain">inria.fr</email>
              <idno type="idhal" notation="numeric">1110205</idno>
              <idno type="halauthorid" notation="string">2283708-1110205</idno>
              <affiliation ref="#struct-451441" />
            </author>
            <editor role="depositor">
              <persName>
                <forename>Nelly</forename>
                <surname>Barret</surname>
              </persName>
              <email type="md5">803e10717e273bcabe5d672b975e1fea</email>
              <email type="domain">inria.fr</email>
            </editor>
            <funder ref="#projanr-51646" />
          </titleStmt>
          <editionStmt>
            <edition n="v1">
              <date type="whenSubmitted">2021-09-14 15:07:41</date>
            </edition>
            <edition n="v2" type="current">
              <date type="whenSubmitted">2021-09-14 18:02:53</date>
              <date type="whenModified">2024-02-01 10:05:26</date>
              <date type="whenReleased">2021-09-14 18:13:04</date>
              <date type="whenProduced">2021-10-25</date>
              <date type="whenEndEmbargoed">2021-09-14</date>
              <ref type="file" target="https://inria.hal.science/hal-03344041v2/document">
                <date notBefore="2021-09-14" />
              </ref>
              <ref type="file" subtype="author" n="1" target="https://inria.hal.science/hal-03344041v2/file/Submission-41-Barret-Manolescu-Upadhyay.pdf">
                <date notBefore="2021-09-14" />
              </ref>
            </edition>
            <respStmt>
              <resp>contributor</resp>
              <name key="974277">
                <persName>
                  <forename>Nelly</forename>
                  <surname>Barret</surname>
                </persName>
                <email type="md5">803e10717e273bcabe5d672b975e1fea</email>
                <email type="domain">inria.fr</email>
              </name>
            </respStmt>
          </editionStmt>
          <publicationStmt>
            <distributor>CCSD</distributor>
            <idno type="halId">hal-03344041</idno>
            <idno type="halUri">https://inria.hal.science/hal-03344041</idno>
            <idno type="halBibtex">barret:hal-03344041</idno>
            <idno type="halRefHtml">&lt;i&gt;BDA 2021 - Informal publication only&lt;/i&gt;, Oct 2021, Paris, France</idno>
            <idno type="halRef">BDA 2021 - Informal publication only, Oct 2021, Paris, France</idno>
          </publicationStmt>
          <seriesStmt>
            <idno type="stamp" n="X">Ecole Polytechnique</idno>
            <idno type="stamp" n="UNIV-RENNES1">UniversitÃ© de Rennes 1</idno>
            <idno type="stamp" n="CNRS">CNRS - Centre national de la recherche scientifique</idno>
            <idno type="stamp" n="INRIA">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="IRISA">Irisa</idno>
            <idno type="stamp" n="LIX">Laboratoire d'informatique de l'Ã©cole polytechnique</idno>
            <idno type="stamp" n="INRIA-SACLAY" corresp="INRIA">INRIA Saclay - Ile de France</idno>
            <idno type="stamp" n="X-LIX" corresp="X">Laboratoire d'informatique de l'X (LIX)</idno>
            <idno type="stamp" n="X-DEP" corresp="X">Polytechnique</idno>
            <idno type="stamp" n="X-DEP-INFO" corresp="X-DEP">DÃ©partement d'informatique</idno>
            <idno type="stamp" n="INRIA_TEST">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="TESTALAIN1">TESTALAIN1</idno>
            <idno type="stamp" n="INRIA2">INRIA 2</idno>
            <idno type="stamp" n="UR1-HAL">Publications labos UR1 dans HAL-Rennes 1</idno>
            <idno type="stamp" n="UR1-MATH-STIC">UR1 - publications Maths-STIC</idno>
            <idno type="stamp" n="UR1-UFR-ISTIC">UFR ISTIC Informatique et Ã©lectronique</idno>
            <idno type="stamp" n="TEST-UR-CSS">TEST UniversitÃ© de Rennes CSS</idno>
            <idno type="stamp" n="UNIV-RENNES">UniversitÃ© de Rennes</idno>
            <idno type="stamp" n="INRIA-300009">Inria 300009</idno>
            <idno type="stamp" n="IP_PARIS">Institut Polytechnique de Paris</idno>
            <idno type="stamp" n="ANR">ANR</idno>
            <idno type="stamp" n="UR1-MATH-NUM">PÃ´le UnivRennes - MathÃ©matiques - NumÃ©rique </idno>
            <idno type="stamp" n="GS-COMPUTER-SCIENCE">Graduate School Computer Science</idno>
          </seriesStmt>
          <notesStmt>
            <note type="audience" n="2">International</note>
            <note type="invited" n="0">No</note>
            <note type="popular" n="0">No</note>
            <note type="peer" n="1">Yes</note>
            <note type="proceedings" n="0">No</note>
          </notesStmt>
          <sourceDesc>
            <biblStruct>
              <analytic>
                <title xml:lang="en">Toward Generic Abstractions for Data of Any Model</title>
                <author role="aut">
                  <persName>
                    <forename type="first">Nelly</forename>
                    <surname>Barret</surname>
                  </persName>
                  <email type="md5">803e10717e273bcabe5d672b975e1fea</email>
                  <email type="domain">inria.fr</email>
                  <idno type="idhal" notation="string">nelly-barret</idno>
                  <idno type="idhal" notation="numeric">742715</idno>
                  <idno type="halauthorid" notation="string">44197-742715</idno>
                  <idno type="ORCID">https://orcid.org/0000-0002-3469-4149</idno>
                  <idno type="GOOGLE SCHOLAR">https://scholar.google.com/citations?user=t2mRA04AAAAJ&amp;hl=en&amp;authuser=1</idno>
                  <affiliation ref="#struct-241115" />
                  <affiliation ref="#struct-451441" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Ioana</forename>
                    <surname>Manolescu</surname>
                  </persName>
                  <email type="md5">198b5d07a89578a2f2e563c17579cde7</email>
                  <email type="domain">inria.fr</email>
                  <idno type="idhal" notation="string">ioana-manolescu</idno>
                  <idno type="idhal" notation="numeric">742652</idno>
                  <idno type="halauthorid" notation="string">16724-742652</idno>
                  <idno type="ORCID">https://orcid.org/0000-0002-0425-2462</idno>
                  <idno type="GOOGLE SCHOLAR">https://scholar.google.com/citations?user=q6Ft35wAAAAJ&amp;hl=en</idno>
                  <orgName ref="#struct-300009" />
                  <affiliation ref="#struct-241115" />
                  <affiliation ref="#struct-451441" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Prajna</forename>
                    <surname>Upadhyay</surname>
                  </persName>
                  <email type="md5">f86e66fa3050d3b1e4fd1f9b6ad08a07</email>
                  <email type="domain">inria.fr</email>
                  <idno type="idhal" notation="numeric">1110205</idno>
                  <idno type="halauthorid" notation="string">2283708-1110205</idno>
                  <affiliation ref="#struct-451441" />
                </author>
              </analytic>
              <monogr>
                <meeting>
                  <title>BDA 2021 - Informal publication only</title>
                  <date type="start">2021-10-25</date>
                  <settlement>Paris</settlement>
                  <country key="FR">France</country>
                </meeting>
                <imprint />
              </monogr>
            </biblStruct>
          </sourceDesc>
          <profileDesc>
            <langUsage>
              <language ident="en">English</language>
            </langUsage>
            <textClass>
              <classCode scheme="halDomain" n="info">Computer Science [cs]</classCode>
              <classCode scheme="halTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halOldTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halTreeTypology" n="COMM">Conference papers</classCode>
            </textClass>
            <abstract xml:lang="en">
              <p>Digital data sharing leads to unprecedented opportunities to develop data-driven systems for supporting economic activities, the social and political life, and science. Many open-access datasets are RDF graphs, but others are CSV files, Neo4J property graphs, JSON or XML documents, etc. Potential users need to understand a dataset in order to decide if it is useful for their goal. While some datasets come with a schema and/or documentation, this is not always the case. Data summarization or schema inference tools have been proposed, specializing in XML, or JSON, or the RDF data models. In this work, we present a dataset abstraction approach, which () applies on relational, CSV, XML, JSON, RDF or Property Graph data; () computes an abstraction meant for humans (as opposed to a schema meant for a parser); () integrates Information Extraction data profiling, to also classify dataset content among a set of categories of interest to the user. Our abstractions are conceptually close to an Entity-Relationship diagram, if one allows nested and possibly heterogeneous structure within entities.</p>
            </abstract>
          </profileDesc>
        </biblFull>
      </listBibl>
    </body>
    <back>
      <listOrg type="structures">
        <org type="regrouplaboratory" xml:id="struct-241115" status="VALID">
          <idno type="IdRef">125922922</idno>
          <orgName>DÃ©partement d'informatique de l'Ã‰cole polytechnique</orgName>
          <orgName type="acronym">X-DEP-INFO</orgName>
          <desc>
            <address>
              <addrLine>Ã‰cole polytechnique, 91128 Palaiseau Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.polytechnique.edu/fr/departement-informatique</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300340" type="direct" />
          </listRelation>
        </org>
        <org type="researchteam" xml:id="struct-451441" status="VALID">
          <idno type="RNSR">201622056J</idno>
          <orgName>Rich Data Analytics at Cloud Scale</orgName>
          <orgName type="acronym">CEDAR</orgName>
          <date type="start">2016-01-01</date>
          <desc>
            <address>
              <addrLine>1 rue HonorÃ© d'Estienne d'OrvesBÃ¢timent Alan TuringCampus de l'Ã‰cole Polytechnique91120 Palaiseau</addrLine>
              <country key="FR" />
            </address>
          </desc>
          <listRelation>
            <relation active="#struct-2071" type="direct" />
            <relation active="#struct-300340" type="indirect" />
            <relation name="UMR7161" active="#struct-441569" type="indirect" />
            <relation active="#struct-118511" type="direct" />
            <relation active="#struct-300009" type="indirect" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-300340" status="VALID">
          <idno type="IdRef">027309320</idno>
          <idno type="ROR">https://ror.org/05hy3tk52</idno>
          <orgName>Ã‰cole polytechnique</orgName>
          <orgName type="acronym">X</orgName>
          <date type="start">1794-03-11</date>
          <desc>
            <address>
              <addrLine>Ã‰cole polytechnique, 91128 Palaiseau Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.polytechnique.edu/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-2071" status="VALID">
          <idno type="IdRef">196509955</idno>
          <idno type="RNSR">200519331V</idno>
          <orgName>Laboratoire d'informatique de l'Ã‰cole polytechnique [Palaiseau]</orgName>
          <orgName type="acronym">LIX</orgName>
          <desc>
            <address>
              <addrLine>Route de Saclay 91128 PALAISEAU CEDEX</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.lix.polytechnique.fr/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300340" type="direct" />
            <relation name="UMR7161" active="#struct-441569" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-441569" status="VALID">
          <idno type="IdRef">02636817X</idno>
          <idno type="ISNI">0000000122597504</idno>
          <idno type="ROR">https://ror.org/02feahw73</idno>
          <orgName>Centre National de la Recherche Scientifique</orgName>
          <orgName type="acronym">CNRS</orgName>
          <date type="start">1939-10-19</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cnrs.fr/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-118511" status="VALID">
          <idno type="RNSR">200818248E</idno>
          <idno type="ROR">https://ror.org/0315e5x55</idno>
          <orgName>Inria Saclay - Ile de France</orgName>
          <desc>
            <address>
              <addrLine>1 rue HonorÃ© d'Estienne d'OrvesBÃ¢timent Alan TuringCampus de l'Ã‰cole Polytechnique91120 Palaiseau</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/centre/saclay</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300009" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-300009" status="VALID">
          <idno type="ROR">https://ror.org/02kvxyf05</idno>
          <orgName>Institut National de Recherche en Informatique et en Automatique</orgName>
          <orgName type="acronym">Inria</orgName>
          <desc>
            <address>
              <addrLine>Domaine de VoluceauRocquencourt - BP 10578153 Le Chesnay Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/en/</ref>
          </desc>
        </org>
      </listOrg>
      <listOrg type="projects">
        <org type="anrProject" xml:id="projanr-51646" status="VALID">
          <idno type="anr">ANR-20-CHIA-0015</idno>
          <orgName>SourcesSay</orgName>
          <desc>Analyse et Interconnexion Intelligente des Contenus HÃ©terogÃ¨nes dans des ArÃ¨nes NumÃ©riques</desc>
          <date type="start">2020</date>
        </org>
      </listOrg>
    </back>
  <teiCorpus>
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Toward Generic Abstractions for Data of Any Model</title>
				<funder ref="#_JwgXRbH #_eC4c5fX">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nelly</forename><surname>Barret</surname></persName>
							<email>nelly.barret@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<email>ioana.manolescu@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Prajna</forename><surname>Upadhyay</surname></persName>
							<email>prajna-devi.upadhyay@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Toward Generic Abstractions for Data of Any Model</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">3AD859BD738BF7C72C5EF374EDC47FF5</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Digital data sharing leads to unprecedented opportunities to develop data-driven systems for supporting economic activities, the social and political life, and science. Many open-access datasets are RDF graphs, but others are CSV files, Neo4J property graphs, JSON or XML documents, etc.</p><p>Potential users need to understand a dataset in order to decide if it is useful for their goal. While some datasets come with a schema and/or documentation, this is not always the case. Data summarization or schema inference tools have been proposed, specializing in XML, or JSON, or the RDF data models. In this work, we present a dataset abstraction approach, which (ğ‘–) applies on relational, CSV, XML, JSON, RDF or Property Graph data; (ğ‘–ğ‘–) computes an abstraction meant for humans (as opposed to a schema meant for a parser); (ğ‘–ğ‘–ğ‘–) integrates Information Extraction data profiling, to also classify dataset content among a set of categories of interest to the user. Our abstractions are conceptually close to an Entity-Relationship diagram, if one allows nested and possibly heterogeneous structure within entities.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>Open-access data is multiplying over the Internet. This leads on one hand, to the development of new businesses, economic opportunities and applications, and on the other hand, to circulating knowledge on a variety of topics, from health to education, environment, the arts, or leisure activities.</p><p>Many of the openly available datasets follow the RDF standard, the W3C's recommendation for sharing data. The Linked Open Data Cloud portal lists thousands of such datasets containing, e.g., national or worldwide statistics, music, scientific bibliographies, and many other interesting, open RDF graphs are not listed there. However, Open Data sets are not (or not only) RDF, as demonstrated by the following examples of very popular open datasets. (ğ‘–) CSV files (each of which can be seen as a table) are shared on machine learning portals such as Kaggle or the French public portal data.gouv.fr; The French national transparency database HATVP (Haute AutoritÃ© pour la Transparence de la Vie Publique) also publishes CSV files; (ğ‘–ğ‘–) relational databases, comprising several interrelated tables, are used e.g. to disseminate the DBLP bibliographic data; (ğ‘–ğ‘–ğ‘–) XML is the format used in hundreds of million of bibliographic notices, e.g., on PubMed; DBLP and HATVP data has also been shared as XML; (ğ‘–ğ‘£) JSON has become more recently the format of choice, used e.g. to describe the complete activity of the French parliament on the websites NosDeputes.fr and NosSenateurs.fr; (ğ‘£) property graphs, such as pioneered by Neo4J, are oriented graphs whose nodes and edges may have labels and properties; this is the format used by the International Consortium of Investigative Journalists to share their investigative data.</p><p>Decades of data management research have shown that no new data model completely replaces the previous ones. Some models thought obsolete re-surface under new incarnations (think of nested relations vs. document stores, or object databases vs. property graphs). The model in which a dataset is produced or exported is decided by the producers, depending on what they understand/are familiar with, the system at their disposal for storing the data, and the needs of foreseeable data users. The Open Data exchange scenarios, where data users often lack any institutional connection to the producers, also forces users to cope with the data as it is, since the producers have no incentive (and, often, lack the resources) to restructure the data in a different format. Thus, we believe the data model variety in Open Data is here to stay.</p><p>Users who must decide whether to use a dataset in an application need to have a basic understanding of its content and the suitability to their need. Towards this goal, schemas may be available to describe the data structure, and/or documentation (text) may describe its content in natural language. As help to the users, schemas and documentations have some limitations: (ğ‘) schemas are often unavailable, especially for semistructured data formats such as JSON, RDF or XML and documentation is also often unavailable or too terse to inform the users; (ğ‘) even when they are published, or built by automated tools, e.g., <ref type="bibr">[3-5, 7-9, 15]</ref>, schemas are not helpful (or too complex) for casual users, who ignore what an "XML element", "JSON array" or "RDF property node" is; (ğ‘) schemas as well as documentation describe the data according to the data producer's terminology, not according to the consumer's. For instance, in the XML dataset at the left in Figure <ref type="figure" target="#fig_0">1</ref>, a public library labels its data entries item, with the implicit knowledge that these are documents (books, magazines, etc.), whereas from the users' perspective, this dataset describes books; (ğ‘‘) by design, schemas do not quantitatively reflect the data, whereas such information could be very useful as a first insight on the data. Towards a data model-independent dataset abstraction To facilitate the understanding of a dataset by a user, we compute a compact description of the data, focusing on its most frequent content, free of data model-specific syntactic details, and formulated in terms that interest the user. To that end, we develop a single, integrated method, applicable to any of the data models mentioned above. For example, given any of the four bibliographic datasets in Figure <ref type="figure" target="#fig_0">1</ref> and a user interested in "books", our approach would correctly identify the dataset as pertinent for the user's question. As we will explain, users can specify their categories of interest through a few hints; with the help of popular knowledge bases, our system makes suggestions to enlarge the set of hints and improve the chances of users to have an accurate description of their dataset. We proceed in several steps, which also organize the remainder of the paper.</p><p>(1.) We view each dataset as holding records, that is: objects with some internal structure, simple or complex, representing a concept or an object. For instance, the XML data in Figure <ref type="figure" target="#fig_0">1</ref> contains two item records. Further, we identify collections grouping similar records (some records may belong to no collection). For instance, the bibliography XML element in Figure <ref type="figure" target="#fig_0">1</ref> can be seen as a collection which holds the two records. We identify a set of requirements for our record and collection detection method, and formalize the problem of deriving them automatically from a dataset (Section 2).</p><p>(2.) We propose an algorithm for automatically identifying records and collections in a dataset of any of the supported data models (Section 3). For instance, given the XML dataset in Figure <ref type="figure" target="#fig_0">1</ref> (or the relational or the RDF dataset from the same figure), our algorithm understands it as a collection of records, each record corresponding to a book, and having: a title, a collection of authors, and possibly a collection of reviews.</p><p>(3.) We separate collections of Entities from collections of Relationships, in order to report to the user a structured, meaningful dataset abstraction (Section 4).</p><p>(4.) To help users understand the data in their terms, we attempt to assign each collection to a category from a predefined category set, derived from a general-purpose ontology and/or based on the concepts of interest to users, e.g., books in the above example. We provide a method for our tool to enrich its knowledge of userspecified categories by selectively gathering information from large online knowledge bases. For instance, our algorithm classifies the bibliography in Figure <ref type="figure" target="#fig_0">1</ref> as a Creative Work (a Schema.org standard type including books, paintings, songs, etc.) Deployment scenarios On one hand, data producers can use our tool to automatically derive data abstractions, to be shared next to the data; on the other hand, users can generate the abstractions after downloading a candidate dataset, in order to assess its interest.</p></div>
<div><head n="2">PROBLEM STATEMENT</head><p>We start by analyzing a set of requirements of our problem, then formally state it.</p></div>
<div><head n="2.1">Requirements</head><p>R1: data model-independent abstractions Our method needs to go beyond the syntactic details to extract semantically meaningful records, and understand if they are organized in collections. R2: structurally rich abstractions The above problem can be seen as reverse-engineering a dataset to identify its conceptual model, which generalizes the classic Entity-Relationship model behind relational databases <ref type="bibr" target="#b12">[13]</ref> by allowing records to have multivalued attributes, and to contain other records and/or collections. For instance, the second item record in Figure <ref type="figure" target="#fig_0">1</ref> contains a collection of review records. A collection uniformly represents a list, set or bag of records: data order and possible duplicates are not reflected in our abstractions. R3: see beyond the data structures In some cases, data syntax features are insufficient to distinguish records from collections. On one hand, in some data models, such as XML or RDF, the syntax does not distinguish them, e.g., in XMark <ref type="bibr" target="#b13">[14]</ref> benchmark documents, an âŸ¨open_auctionsâŸ© element is clearly a collection, while a âŸ¨userâŸ© element describes a record. On the other hand, even when the data model distinguishes nodes that should naturally be records (e.g., JSON maps), from others that should be collections (e.g., JSON arrays), we should not make this decision purely based on syntax. Indeed, as also noted in <ref type="bibr" target="#b14">[15]</ref>, a short array could in fact designate an object (e.g., three coordinates describe a geographical point), while a map may be used to encode a list, e.g., with attributes named "1", "2", "3" etc., as in Le Monde's Decodex dataset. It is important that such variations in data design do not confuse our abstraction. R4: implicit or explicit collections In our motivating example, each of the four datasets holds a collection of books. In XML, the collection is explicit (materialized by the âŸ¨bibliographyâŸ© node), and the table node labeled Book plays the same role in the relational dataset. In contrast, in the RDF dataset, there is no common parent of the books; we say that the collection here is implicit. Note that whether collections are explicit or implicit does not depend on the original data model: in the relational dataset, the book collection is explicit but the review collection is not; similarly, the RDF dataset could have included a common parent to all the book nodes, which would have made that collection explicit. Availability and role of schemas and types What schema information can we expect to have, and how should we treat it?</p><p>Relational databases always have a schema, describing elementary data types, the attributes of each table, and possible integrity constraints. In a CSV file, the number of attributes can be identified easily; their names may or may not be present, and data types are not explicitly declared; data profiling <ref type="bibr" target="#b0">[1]</ref> is needed to infer their domains. XML documents may or may not have a schema, expressed as a Document Type Description (DTD) or XML Schema Description (XSD); these specify the allowed children for each type of element. JSON documents usually come without a schema, but recent methods <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b14">15]</ref> derive schemas from the documents. RDF graphs are often schemaless, but they may be endowed with: (ğ‘–) an ontology, expressed in RDF Schema or OWL, describing relationships between the types and properties present in the graph, e.g., Any Student is a Person, or Anyone taking a Course is a Student; (ğ‘–ğ‘–) a SHACL (Shapes Constraint Language) schema specification, against which a graph may be validated or not. Schemas for property graphs are being investigated actively <ref type="bibr" target="#b9">[10]</ref>, although no standard has emerged yet.</p><p>Data types are basic components of schemas. When present, types encapsulate valuable insights into the data organization and semantics. Thus, we formulate the following requirement: R5: explicit types When available, types should guide our identification of records and collections, even though our approach should not depend on them.</p></div>
<div><head n="2.2">Abstraction approach</head><p>To satisfy requirement R1, we leverage the ConnectionLens system <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6]</ref> which models the information from any relational database, CSV, XML, JSON, RDF document, or property graph, as a graph ğº = (ğ‘ , ğ¸) where ğ¸ âŠ† ğ‘ Ã— ğ‘ is a set of directed edges, and ğœ† ğ‘ , ğœ† ğ¸ are two functions labeling each node (respectively, edge) with a label (a string), that could in particular be ğœ– (the empty label). Figure <ref type="figure" target="#fig_1">2</ref> illustrates this; for now, just focus on the nodes and edges (their colors and the shaded areas will be explained later).</p><p>Relational data A relational table or a CSV dataset can be seen as a set of tuples, each with the same attributes. This can be turned into a graph by modeling the dataset as a table node, having one child tuple node for each tuple (or line in the CSV file); this child has one child attribute node for each attribute. Figure <ref type="figure" target="#fig_1">2</ref> illustrates this for the sample relational dataset in Figure <ref type="figure" target="#fig_0">1</ref>. Following R5, we leverage foreign key constraints expressed in a relational database schema as follows. Whenever relation ğ‘† includes a foreign key to relation ğ‘…, an edge is created leading from each tuple in ğ‘†, to the respective ğ‘… tuple node.</p><p>XML and JSON data are naturally converted into trees. RDF data Each triple (ğ‘ , ğ‘, ğ‘œ) from an RDF graph is converted into an edge between the (single) node labeled ğ‘  to the (single) node labeled ğ‘œ; the edge is labeled ğ‘. We denote by ğœ the special RDF type property used to explicitly connect an URI to its type (which is also a node in the graph).</p><p>Property graphs (PG) In this rich, directed graph data model: (ğ‘–) each node may have a set of attributes with a name and a value; (ğ‘–ğ‘–) each edge can similarly have attributes; (ğ‘–ğ‘–ğ‘–) zero or more labels may be attached to each node and/or edge, playing roughly the role of a type. In our graphs, each node/edge has at most one label. Therefore, we transform a property graph as follows. Each PG node becomes a node ğ‘› âˆˆ ğ‘ , labeled ğœ–. Each label ğ‘™ of a PG node ğ‘› becomes an edge ğ‘› ğœ -â†’ ğ‘› ğ‘™ âˆˆ ğ¸, where ğ‘› ğ‘™ is a leaf node labeled ğ‘™ and ğœ is the RDF type property mentioned above. Each attribute of ğ‘›, named ğ‘ and whose value is ğ‘, becomes an edge ğ‘› ğ‘ -â†’ ğ‘› ğ‘ âˆˆ ğ¸ where ğ‘› ğ‘ is a leaf node labeled ğ‘. Each PG edge ğ‘’ is turned into a node ğ‘› ğ‘’ , labeled ğœ–, plus two edges, connecting it to its source and target nodes in the original PG; ğ‘› ğ‘’ also has outgoing edges modeling the attributes of ğ‘’, similarly to PG nodes.</p></div>
<div><head>Extracted entities</head><p>The graph built by ConnectionLens out of any dataset is enriched through entity extraction, applied on each value (string, leaf) node present in the dataset <ref type="bibr" target="#b1">[2]</ref>. In our example, Alice, Bob, Carole and David are recognized as Person entities. The set ğ‘‡ ğ¸ of entity types also includes: Location, Organization, Date, URIs, emails, hashtags, etc. Entities will be used to categorize collections (Section 5).</p><p>Problem statement Given the graph ğº = (ğ‘ , ğ¸) obtained as above, our goal is to:</p><p>(1) Identify records and collections, that is: find (ğ‘–) a set R âŠ† ğ‘ of nodes which we call records; (ğ‘–ğ‘–) a set of sets C = {ğ¶ 1 , ğ¶ Together with edges connecting them to each other and to a record ğ‘Ÿ , sub-records form the record content sought in (3b) below.</p><p>As shown above, for now, only collections of entities are classified (not those of relationships). The reason not to classify relationships is that entities ("things") seem even easier to understand for non-IT users, and it is easier for them to provide hints (see later) about entities, than about relationships.</p></div>
<div><head n="3">IDENTIFYING RECORDS AND COLLECTIONS</head><p>We start by a convenient transformation on the graph ğº. Some of its edges have labels (e.g., RDF triples, edges in JSON maps) while others carry the empty label ğœ–. For uniformity, we transform ğº into an unlabeled graph ğº â€² , replacing each labeled edge ğ‘› 1 an intermediary node labeled ğ‘™, and connected to ğ‘› 1 , ğ‘› 2 as follows:</p><formula xml:id="formula_0">ğ‘™ - â†’ ğ‘› 2 with</formula><formula xml:id="formula_1">ğ‘› 1 ğœ– -â†’ ğ‘› ğ‘™ ğœ– -â†’ ğ‘› 2 .</formula><p>From now on, we will work on ğº â€² , whose nodes and edges will be simply denoted as (ğ‘ â€² , ğ¸ â€² ). Then:</p><p>(1) First, we compute a quotient summary of ğº â€² , that is: we identify a partition P = {ğ‘ ğ‘– } ğ‘– of its nodes ğ‘ â€² , such that ğ‘– ğ‘ ğ‘– = ğ‘ â€² and the ğ‘ ğ‘– are pairwise disjont. We say the nodes from a given set ğ‘ ğ‘– are equivalent, and call ğ‘ ğ‘– an equivalence class. Then, the quotient summary of ğº â€² is a graph whose nodes are the equivalence classes, and such that whenever ğº â€² contains an edge ğ‘› 1 â†’ ğ‘› 2 , its summary contains the edge ğ¸ğ¶ (ğ‘› 1 ) â†’ ğ¸ğ¶ (ğ‘› 2 ), where ğ¸ğ¶ (ğ‘› ğ‘– ) denotes the equivalence class of ğ‘› ğ‘– for ğ‘– âˆˆ {1, 2}. Many quotient summarization techniques have been proposed <ref type="bibr" target="#b4">[5]</ref>; we discuss some of them below. Note that while the quotient summary guides the abstraction, it may still differ from it quite substantially: a set ğ‘ ğ‘– may contain records from multiple collections; it may contain an explicit collection node; finally, it may contain nodes which turn out to be in SR.</p><p>(2) Next, we compute the signature of each equivalence class, i.e.</p><p>an object reflecting the entities extracted out of the nodes of that equivalence class. This signature holds such statistics for every entity type in ğ‘‡ ğ¸ (Section 2.2). For instance, given the XML document presented in Figure <ref type="figure" target="#fig_1">2</ref>, the signature of the equivalence class representing the nodes âŸ¨authorâŸ© is: {"total_length":14, "PERSON": {"occurrences":3, "extracted_length":14}} because the three authors have been recognised as Person entities.</p><p>(3) We consider that each ğ‘ ğ‘– is a union of one or more collections, plus possibly (more rarely) a few records. To separate these, we proceed as follows: (a) We cluster the nodes in each ğ‘ ğ‘– according to their structure.</p><p>(i) We transform ğ‘ ğ‘– into a set of transactions D, by turning each node into a transaction, whose item set is the set of labels of the node's non-leaf children. Thus, the first book from the XML bibliography in Figure <ref type="figure" target="#fig_1">2</ref>    <ref type="figure" target="#fig_1">2</ref>. For instance, in the XML bibliography, the second âŸ¨bookâŸ© record includes the âŸ¨titleâŸ©, the two âŸ¨authorâŸ©, and the two âŸ¨reviewâŸ©. Similarly, for the RDF example, the second âŸ¨bookâŸ© record consists of its âŸ¨titleâŸ©, plus few âŸ¨authorsâŸ© and âŸ¨reviewsâŸ©. For the relational database, the âŸ¨bookâŸ© record consists of the âŸ¨titleâŸ© and the âŸ¨idâŸ© of the book. Note that the content of a record is extensive using transitivity (e.g. the âŸ¨authorâŸ© collection is part of the âŸ¨bookâŸ©).</p><p>In ( <ref type="formula" target="#formula_2">1</ref>), knowledge about possible node types should be injected in P, thus satisfying R5. R2 is met by including in a record many nodes reachable from it, in step (3b). Finally, step (3a) satisfies R3 by operating on the graph content (not on the original syntax), and R4 by detecting both implicit and explicit collections.</p><p>We now discuss possible choices for the quotient summary technique. The most general method, applicable to arbitrary graphs, consists of building a quotient graph summary <ref type="bibr" target="#b4">[5]</ref>, such as those described in <ref type="bibr" target="#b7">[8]</ref> which can be built in linear time in the input size. In particular, a type-first quotient summary <ref type="bibr" target="#b7">[8]</ref> uses type information when available to group nodes by their set of most general types (an RDF node may have several types, and a PG node may have several labels), while partitioning untyped nodes according to their incoming and outgoing nodes. Alternatively, in the particular case of tree data models, such as XML or JSON, P may be a Dataguide <ref type="bibr" target="#b8">[9]</ref>, which can also be constructed in linear time in the size of the input.</p></div>
<div><head n="4">DISTINGUISHING ENTITIES FROM RELATIONSHIPS</head><p>We now analyse the collections to separate C into C ğ¸ , the set of entity collections, from C ğ‘… , the set of relationships collection. For instance, the âŸ¨authorsâŸ© node in the XML data describes entities while the âŸ¨wroteâŸ© nodes in the property graph describe relationships. We say a collection ğ‘ is in C ğ‘… iff there exist two collections ğ‘ and ğ‘ such that: âˆ€ğ‘Ÿ ğ‘ âˆˆ ğ‘, âˆƒ!ğ‘Ÿ ğ‘ âˆˆ ğ‘, âˆƒ!ğ‘Ÿ ğ‘ âˆˆ ğ‘ such that ğ‘Ÿ ğ‘ , ğ‘Ÿ ğ‘ are connected by an edge in ğ¸ â€² and similarly ğ‘Ÿ ğ‘ , ğ‘Ÿ ğ‘ are connected by an ğ¸ â€² edge. If this is not the case, we consider that ğ‘ is a collection of entities. For instance, in the property graph in Figure <ref type="figure" target="#fig_1">2</ref>, each record in the implicit collection âŸ¨wroteâŸ© links one âŸ¨authorâŸ© and one âŸ¨bookâŸ©, therefore the collection âŸ¨wroteâŸ© contains relationships; the âŸ¨authorâŸ© and âŸ¨bookâŸ© collections are collections of entities. This check can be sped up by exploiting connection statistics that can be gathered while computing the quotient summary of ğº â€² .</p></div>
<div><head n="5">CLASSIFYING COLLECTIONS</head><p>Our next step is to classify each collection in C ğ¸ into a given set K of categories of interest to the user, or Other if no category is pertinent. In our example, we consider the categories Person, Organization, Location, Event and Creative Work. As input to the classification process, we are also given a set of hints H . A hint â„ âˆˆ H is a tuple (ğ´, ğ‘™, ğµ) where ğ´ âŠ† K, ğ‘™ is a label and ğµ is a signature pattern, which is matched (satisfied) by an individual signature, or not. Such a hint states that a node which has a child labeled ğ‘™ and its signature matches ğµ, should be classified as one of the types in ğ´. For instance, the hint ({ğ‘‚ğ‘Ÿğ‘”ğ‘ğ‘›ğ‘–ğ‘§ğ‘ğ‘¡ğ‘–ğ‘œğ‘›}, â„ğ‘ğ‘ ğ¶ğ¸ğ‘‚, {ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘œğ‘›}) states that a record having a property hasCEO, whose signature matches Person, should be assigned to the category Organization.</p></div>
<div><head n="5.1">Classification algorithm</head><p>Algorithm 1 details our classification.</p><p>(1) For each record ğ‘Ÿ âˆˆ ğ‘, we initialize K ğ‘Ÿ , a multiset of candidate categories for ğ‘Ÿ , and a vector of scores of ğ‘Ÿ for each hint. K ğ‘Ÿ is a multiset to accomodate the possibility that a given category may be suggested by several hints. (2) If the record ğ‘Ÿ has a label semantically close to one of the categories in K, this category is stored as a candidate category in K ğ‘Ÿ , and the similarity score recorded in scores. (3) For each child ğ‘›ğ‘ of the record ğ‘Ÿ , we create a pair ğœ‹ containing the label of ğ‘›ğ‘ and the signature of ğ‘›ğ‘. (4) Next, we compute the similarity of ğœ‹ with each hint â„ in H according to Equation <ref type="formula" target="#formula_2">1</ref>. This equation gives the similarity between a node and a hint, based on the label and the signature of both elements:</p><p>ğ‘ ğ‘–ğ‘š(ğœ‹, â„) = ğ‘ ğ‘–ğ‘”_ğ‘ ğ‘–ğ‘š(ğœ‹ .ğ‘†, â„.ğµ)</p><formula xml:id="formula_2">+ ğ‘˜ ğ‘– âˆˆğ¾ 1 ,ğ‘˜ ğ‘— âˆˆğ¾ 2 ğ‘ğ‘œğ‘ ğ‘–ğ‘›ğ‘’_ğ‘ ğ‘–ğ‘š(ğ‘‰ (ğ‘˜ ğ‘– ), ğ‘‰ (ğ‘˜ ğ‘— ))<label>(1)</label></formula><p>where ğ¾ 1 is the set of keywords present in ğœ‹ .ğ‘™ğ‘ğ‘ğ‘’ğ‘™, ğ¾ 2 is the set of keywords present in â„.ğ‘™, and ğ‘ ğ‘–ğ‘”_ğ‘ ğ‘–ğ‘š(ğœ‹ .ğ‘†, â„.ğµ) is the similarity between the individual signature ğœ‹ .ğ‘† and the signature pattern â„.ğµ, ğ‘‰ (ğ‘˜ ğ‘– ) is a vector representation (embedding) of keyword ğ‘˜ ğ‘– in a multidimensional space. Such embeddings enable detecting that a node labeled writer is close to a hint labeled author, even if they are different words.</p><p>We currently use the Word2Vec model <ref type="bibr" target="#b10">[11]</ref> for this task. (5) For each ğœ‹, we choose the hint â„ leading to the highest similarity score for ğœ‹. Each category indicated by the domain of â„ is added to K ğ‘Ÿ . (6) We classify the record ğ‘Ÿ in the category that is the most frequent in K ğ‘Ÿ , if one category is more frequent than 50%; otherwise, we classify it as Other. (7) Finally, we classify the collection ğ‘ in the most popular category among its records.</p></div>
<div><head n="5.2">Constructing hints</head><p>The classification of the collections depends on the quality of hints provided as input. Users looking for a concept, e.g., creative work, may have in mind a few properties that creative works have, such as title or author, and may provide them as hints. Our approach works better if there are many hints, in order to obtain a decisive category vote. To overcome burdening human experts, we use Classify ğ‘Ÿ in the most frequent ğ‘˜ âˆˆ K ğ‘Ÿ , or Other 14 Classify ğ‘ with the most frequent category of its records knowledge bases like Wikidata <ref type="bibr" target="#b15">[16]</ref> and Yago <ref type="bibr" target="#b11">[12]</ref> to enhance an existing set of hints, as follows.</p><p>A knowledge base ğ¾ğµ consists of triples of the form âŸ¨a,r,bâŸ©, where r is the relationship between the entities a and b. For example, the triple âŸ¨Albert Wessels, spouse, Elisabeth EybersâŸ© states that Albert Wessels' spouse is Elisabeth Eybers. It also makes statements about the entity type, such as âŸ¨Albert Wessels, type, PersonâŸ©, from which we can obtain the category an entity belongs to.</p><p>Let ğ‘˜ âˆˆ K be the category we want to enhance hints for and ğ¾ğµ be the knowledge base. The set of properties ğ‘ƒ ğ‘˜ that are likely to be associated with ğ‘˜ can be acquired using the following equation:</p><formula xml:id="formula_3">ğ‘ƒ ğ‘˜ = {ğ‘Ÿ | âŸ¨a,r,bâŸ© âˆˆ ğ¾ğµ âˆ§ âŸ¨a,type,kâŸ© âˆˆ ğ¾ğµ}<label>(2)</label></formula><p>For example, the triple âŸ¨Albert Wessels, type, PersonâŸ© exists in YAGO, and Albert Wessels participates in triples such as âŸ¨Albert Wessels, nationality, South AfricaâŸ© and âŸ¨Albert Wessels, spouse, Elisabeth EybersâŸ© among many others. So, nationality and spouse would be added to the set ğ‘ƒ ğ‘ƒğ‘’ğ‘Ÿğ‘ ğ‘œğ‘› .</p><p>The acquired set of properties may contain some inaccurate information, e.g., for the category Organization, some properties such as date of birth were retrieved. This happens because knowledge bases such as Wikidata are collaboratively created, which can lead to errors, as evident from the triples âŸ¨Steven Shankman, type, OrganizationâŸ© and âŸ¨Steven Shankman, date of birth, 1947âŸ©. We avoid such errors by scoring each property in the set ğ‘ƒ ğ‘˜ , i.e. errors such as the one reported above will lead to a low score. Formally:</p><p>Category score. This score is set proportional to the number of instances of the category the property was participating with. ğ‘_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (ğ‘, ğ‘˜) for each ğ‘ âˆˆ ğ‘ƒ ğ‘˜ is computed as follows:</p><p>ğ‘_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (ğ‘, ğ‘˜) = |{ğ‘ | âŸ¨a,p,bâŸ© âˆˆ ğ¾ğµ âˆ§ âŸ¨a,type,kâŸ© âˆˆ ğ¾ğµ}| (3) While this prunes away errors, we might still get some properties which are common for all the categories in K, thus are not very useful in distinguishing between these categories. For example, the property Google Knowledge Graph ID appears for all the different categories. We introduce another score to penalize such properties: Inverse category score. This score quantifies how unique a property is for distinguishing between categories. Let ğ‘ƒ ğ‘ğ‘™ğ‘™ = {ğ‘ƒ ğ‘˜ 1 , ğ‘ƒ ğ‘˜ 2 , . . . , ğ‘ƒ ğ‘˜ |K | } be the set of sets of properties retrieved for each category ğ‘˜ ğ‘– âˆˆ K according to Equation <ref type="formula" target="#formula_3">2</ref>. The inverse category score of a property ğ‘ is computed as follows:</p><formula xml:id="formula_4">ğ‘–ğ‘£ğ‘_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (ğ‘) = ğ‘™ğ‘œğ‘” 1 + |K | 1 + |{ğ‘ƒ | ğ‘ âˆˆ ğ‘ƒ, ğ‘ƒ âˆˆ ğ‘ƒ ğ‘ğ‘™ğ‘™ }|<label>(4)</label></formula><p>A property ğ‘ that appears in all sets ğ‘ƒ ğ‘˜ ğ‘– , âˆ€ğ‘– âˆˆ 1, 2, ..., |K | will get ğ‘–ğ‘£ğ‘_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (ğ‘) = 0 since ğ‘™ğ‘œğ‘”(1) = 0. A property ğ‘ which appears in only one of the sets ğ‘ƒ ğ‘˜ 1 , ğ‘ƒ ğ‘˜ 2 , ..., ğ‘ƒ ğ‘˜ |K | will get the highest score. Total score. The total score of a property is given by a product of category score and inverse category score, as shown by Equation <ref type="formula">5</ref>.</p><p>ğ‘¡ğ‘œğ‘¡_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (ğ‘) = ğ‘_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (ğ‘) * ğ‘–ğ‘£ğ‘_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ (ğ‘) + 1</p><p>(5)</p><p>We score the properties in decreasing order of ğ‘¡ğ‘œğ‘¡_ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ and retain the top-ğ‘§ ğ‘ƒ ğ‘˜ ğ‘§ properties for each category ğ‘˜. For each ğ‘˜ âˆˆ K and ğ‘ âˆˆ ğ‘ƒ ğ‘˜ ğ‘§ , we create a hint ({ğ´}, ğ‘, ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’ (ğ‘)), where ğ´ = {ğ‘˜ : ğ‘ âˆˆ ğ‘ƒ ğ‘˜ ğ‘§ } and ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’ (ğ‘) is the range of the property ğ‘ if available from ğ¾ğµ, and âˆ… if not present. We are currently working to make the signature patterns ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’ (ğ‘) more specific, by exploiting the knowledge the ğ¾ğµ may have about the domain of the property ğ‘.</p></div>
<div><head n="6">CONCLUSION AND PERSPECTIVES</head><p>The approach described above aims at producing expressive abstraction of datasets organized in a variety of data models. This goes through their transformation in graphs, identifying records and collections, analyzing and classifying collections. The implementation and fine-tuning of our system is ongoing.</p></div><figure xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Motivating example: four bibliographic datasets, which we view as Collections of CreativeWork records.bibliography XML element in Figure1can be seen as a collection which holds the two records. We identify a set of requirements for our record and collection detection method, and formalize the problem of deriving them automatically from a dataset (Section 2).(2.) We propose an algorithm for automatically identifying records and collections in a dataset of any of the supported data models (Section 3). For instance, given the XML dataset in Figure1(or the relational or the RDF dataset from the same figure), our algorithm understands it as a collection of records, each record corresponding to a book, and having: a title, a collection of authors, and possibly a collection of reviews.(3.) We separate collections of Entities from collections of Relationships, in order to report to the user a structured, meaningful dataset abstraction (Section 4).(4.) To help users understand the data in their terms, we attempt to assign each collection to a category from a predefined category set, derived from a general-purpose ontology and/or based on the concepts of interest to users, e.g., books in the above example. We provide a method for our tool to enrich its knowledge of userspecified categories by selectively gathering information from large online knowledge bases. For instance, our algorithm classifies the bibliography in Figure1as a Creative Work (a Schema.org standard type including books, paintings, songs, etc.) Deployment scenarios On one hand, data producers can use our tool to automatically derive data abstractions, to be shared next to the data; on the other hand, users can generate the abstractions after downloading a candidate dataset, in order to assess its interest.</figDesc><graphic coords="3,79.02,75.18,453.96,251.76" type="bitmap" /></figure>
<figure xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Graph representations of the four bibliographic datasets shown in Figure 1.</figDesc><graphic coords="5,77.90,83.68,453.96,295.37" type="bitmap" /></figure>
<figure xml:id="fig_2"><head /><label /><figDesc>has the items title, id, reviews and authors while the second has title, id and authors. (ii) Given an item set ğ‘‹ âˆˆ D, we denote by ğ‘† (ğ‘‹ ) the support of ğ‘‹ , defined by ğ‘† (ğ‘‹ ) = |{ğ‘Œ âˆˆ D | ğ‘‹ âŠ† ğ‘Œ }|. We also define the transferred support of an item set ğ‘‹ , denoted ğ‘‡ (ğ‘‹ ), based on the set of itemsets Y obtained as follows. Y is initialized with all the proper subsets of ğ‘‹ (not ğ‘‹ and not the empty set) that appear in D. Then, we traverse Y in the decreasing order of the itemset size, and remove all subsets of ğ‘Œ from Y. For a given ğ‘‹ and Y, the transferred support ğ‘‡ (ğ‘‹ ) is defined as: ğ‘‡ (ğ‘‹ ) = ğ‘† (ğ‘‹ ) + ğ‘Œ |ğ‘Œ âˆˆY ğ‘‡ (ğ‘Œ ). Our clustering algorithm starts by computing ğ‘† (ğ‘‹ ) and ğ‘‡ (ğ‘‹ ) for each ğ‘‹ in D. Then, it proceeds in a greedy manner, choosing the ğ‘‹ âˆˆ D with the highest value of ğ‘‡ (ğ‘‹ ), and creating a collection ğ‘ containing ğ‘‹ and all the D transactions whose items are all included in those of ğ‘‹ . We then remove ğ‘ and the previously selected transactions from D and repeat the procedure. Each ğ‘ of more than ğ‘¡ elements (where ğ‘¡ is a threshold,</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>ğ‘› ğ¶ ğ‘– is a parent (in ğº) of all the nodes from ğ¶ ğ‘– ; (ğ‘–ğ‘–ğ‘–) for each ğ‘Ÿ âˆˆ R, a set of nodes and edges of ğº which we view as part of the record ğ‘Ÿ .(2) Separate the collections in C into C ğ¸ and C ğ‘… , respectively collections of entities and collections of relationships. (3) Classify the collections of entities: given a set of categories, and a set of hints (see Section 5), assign to each collection the category it is closest to (or none if does not fit the given categories).The nodes ğ‘ \ R \ {ğ‘› ğ¶ ğ‘– | ğ¶ ğ‘– âˆˆ C} which are neither records nor collection nodes are called sub-records and their set is denoted SR.</figDesc><table /><note><p>2 , . . .}, where each ğ¶ ğ‘– is a set of elements from R, the ğ¶ ğ‘– 's are pairwise disjoint, and for each ğ¶ ğ‘– , there may exist a node ğ‘› ğ¶ ğ‘– such that (ğ‘› ğ¶ ğ‘– , ğ‘Ÿ ğ‘— ğ‘– ) âˆˆ ğ¸ for every ğ‘Ÿ ğ‘— ğ‘– âˆˆ ğ¶ ğ‘– , in other words:</p></note></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>e.g., ğ‘¡ = 2) is considered a collection; if the ğ‘ elements have a common parent, that becomes the collection node, otherwise, the collection is implicit. For each ğ‘, every child ğ‘Ÿ âˆˆ ğ‘ is considered a record, part of ğ‘. The elements of ğ‘ that are not considered collections nor records are considered sub-records. For instance, in Figure2, the XML sample describes 4 collections (blue nodes): a âŸ¨bibliographyâŸ© containing âŸ¨itemâŸ© records (orange nodes), two sets of âŸ¨authorsâŸ© containing âŸ¨authorâŸ© records and a set of âŸ¨reviewsâŸ© containing âŸ¨reviewâŸ© records. The sub-records are the green nodes. (b) For each record ğ‘Ÿ âˆˆ R, we build its content, i.e. a directed acyclic graph (DAG) ğ‘‘ ğ‘Ÿ by following edges outgoing from ğ‘Ÿ , until we reach leaf nodes, or another record node ğ‘Ÿ â€² , or a collection node. The content of each record is represented by a light yellow box in Figure</figDesc><table /></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>Algorithm 1: Classifying a collection ğ‘ Input: a collection ğ‘, hints H , categories K 1 foreach ğ‘Ÿ âˆˆ C do</figDesc><table><row><cell>2</cell><cell>K ğ‘Ÿ â† âˆ…</cell></row><row><cell>3</cell><cell>scores â† âˆ…</cell></row><row><cell>4</cell><cell>foreach ğ‘˜ âˆˆ K do</cell></row><row><cell>5</cell><cell>if the similarity between ğ‘˜ and the label of ğ‘Ÿ is higher</cell></row><row><cell /><cell>than a threshold then</cell></row><row><cell>6</cell><cell>K ğ‘Ÿ â† K ğ‘Ÿ âˆª {ğ‘˜ }</cell></row><row><cell>7</cell><cell>foreach ğ‘›ğ‘ âˆˆ ğ‘Ÿ .children do</cell></row><row><cell>8</cell><cell>ğœ‹ â† (ğ‘›ğ‘.ğ‘™ğ‘ğ‘ğ‘’ğ‘™, ğ‘›ğ‘.ğ‘ ğ‘–ğ‘”ğ‘›ğ‘ğ‘¡ğ‘¢ğ‘Ÿğ‘’)</cell></row><row><cell>9</cell><cell>foreach â„ âˆˆ H do</cell></row><row><cell>10</cell><cell>scores â† scores (â„, ğ‘ ğ‘–ğ‘š(ğœ‹, â„))</cell></row><row><cell>11</cell><cell>bestHint â† argmax(scores)</cell></row></table><note><p><p>12</p>K ğ‘Ÿ â† K ğ‘Ÿ âˆª bestHint.domain 13</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments. This work is funded by <rs type="grantNumber">DIM RFSI PHD 2020-01</rs> and <rs type="projectName">AI Chair SourcesSay</rs> project (<rs type="grantNumber">ANR-20-CHIA-0015-01</rs>) grants.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_JwgXRbH">
					<idno type="grant-number">DIM RFSI PHD 2020-01</idno>
					<orgName type="project" subtype="full">AI Chair SourcesSay</orgName>
				</org>
				<org type="funding" xml:id="_eC4c5fX">
					<idno type="grant-number">ANR-20-CHIA-0015-01</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Data Profiling</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Abedjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Golab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Synthesis Lectures on Data Management</title>
		<imprint>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Graph integration of structured, semistructured and unstructured data for data journalism</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Conceicao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Merabti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>You</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021-07">July 2021</date>
		</imprint>
		<respStmt>
			<orgName>Information Systems</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Human-in-the-loop schema inference for massive JSON datasets</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Baazizi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Berti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Colazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ghelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sartiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parametric schema inference for massive JSON datasets</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Baazizi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Colazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ghelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sartiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Summarizing Semantic Graphs: A Survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cebiric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>GoasdouÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Troullinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zneika</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2019-06">June 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">ConnectionLens: Finding connections across heterogeneous data sources (demonstration)</title>
		<author>
			<persName><forename type="first">C</forename><surname>Chanial</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dziri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leblay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Schemas for safe and efficient XML processing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Colazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ghelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sartiani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">RDF graph summarization for first-sight structure discovery</title>
		<author>
			<persName><forename type="first">F</forename><surname>GoasdouÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2020-04">Apr. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dataguides: Enabling query formulation and optimization in semistructured databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Schema inference for property graphs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lbath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Harmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT. OpenProceedings.org</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Distributed representations of words and phrases and their compositionality</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Yago 4: A reason-able knowledge base</title>
		<author>
			<persName><forename type="first">T</forename><surname>Pellissier Tanon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Suchanek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Database Management Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakhrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>McGraw-Hill</publisher>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Xmark: A benchmark for XML data management</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Waas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Busse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Reducing ambiguity in JSON schema discovery</title>
		<author>
			<persName><forename type="first">W</forename><surname>Spoth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">A</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hammerschmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">H</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Wikidata: A free collaborative knowledgebase</title>
		<author>
			<persName><forename type="first">D</forename><surname>VrandeÄiÄ‡</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>KrÃ¶tzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">10</biblScope>
			<date type="published" when="2014-09">Sept. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</teiCorpus></text>
</TEI>