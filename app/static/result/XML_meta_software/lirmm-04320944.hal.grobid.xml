<?xml version='1.0' encoding='utf-8'?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 http://api.archives-ouvertes.fr/documents/aofr-sword.xsd">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>HAL TEI export of lirmm-04320944</title>
      </titleStmt>
      <publicationStmt>
        <distributor>CCSD</distributor>
        <availability status="restricted">
          <licence target="http://creativecommons.org/licenses/by/4.0/">Distributed under a Creative Commons Attribution 4.0 International License</licence>
        </availability>
        <date when="2024-04-29T11:48:42+02:00" />
      </publicationStmt>
      <sourceDesc>
        <p part="N">HAL API platform</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <listBibl>
        <biblFull>
          <titleStmt>
            <title xml:lang="en">Bounded Treewidth and the Infinite Core Chase: Complications and Workarounds toward Decidable Querying</title>
            <author role="aut">
              <persName>
                <forename type="first">Jean-FranÃ§ois</forename>
                <surname>Baget</surname>
              </persName>
              <email type="md5">8b0bed7369cfe1a6bac9593964cbea24</email>
              <email type="domain">inria.fr</email>
              <idno type="idhal" notation="string">jfbaget</idno>
              <idno type="idhal" notation="numeric">2418</idno>
              <idno type="halauthorid" notation="string">23949-2418</idno>
              <idno type="ORCID">https://orcid.org/0000-0001-7221-5770</idno>
              <idno type="IDREF">https://www.idref.fr/174121555</idno>
              <affiliation ref="#struct-1102911" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Marie-Laure</forename>
                <surname>Mugnier</surname>
              </persName>
              <email type="md5">3ef441151c4a1431a5e05b4da19d881c</email>
              <email type="domain">lirmm.fr</email>
              <idno type="idhal" notation="string">marie-laure-mugnier</idno>
              <idno type="idhal" notation="numeric">6245</idno>
              <idno type="halauthorid" notation="string">18411-6245</idno>
              <idno type="ORCID">https://orcid.org/0000-0002-0574-3693</idno>
              <idno type="IDREF">https://www.idref.fr/129977896</idno>
              <affiliation ref="#struct-1102911" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Sebastian</forename>
                <surname>Rudolph</surname>
              </persName>
              <email type="md5">ac5938c3dc736d968f5495c4280ba2ad</email>
              <email type="domain">tu-dresden.de</email>
              <idno type="idhal" notation="numeric">950283</idno>
              <idno type="halauthorid" notation="string">536461-950283</idno>
              <affiliation ref="#struct-231054" />
            </author>
            <editor role="depositor">
              <persName>
                <forename>Jean-FranÃ§ois</forename>
                <surname>Baget</surname>
              </persName>
              <email type="md5">8b0bed7369cfe1a6bac9593964cbea24</email>
              <email type="domain">inria.fr</email>
            </editor>
            <funder ref="#projanr-48388" />
          </titleStmt>
          <editionStmt>
            <edition n="v1" type="current">
              <date type="whenSubmitted">2023-12-04 13:25:50</date>
              <date type="whenModified">2024-03-07 14:26:04</date>
              <date type="whenReleased">2023-12-04 16:36:10</date>
              <date type="whenProduced">2023-07-18</date>
              <date type="whenEndEmbargoed">2023-12-04</date>
              <ref type="file" target="https://hal-lirmm.ccsd.cnrs.fr/lirmm-04320944/document">
                <date notBefore="2023-12-04" />
              </ref>
              <ref type="file" subtype="author" n="1" target="https://hal-lirmm.ccsd.cnrs.fr/lirmm-04320944/file/main-pods.pdf">
                <date notBefore="2023-12-04" />
              </ref>
            </edition>
            <respStmt>
              <resp>contributor</resp>
              <name key="114307">
                <persName>
                  <forename>Jean-FranÃ§ois</forename>
                  <surname>Baget</surname>
                </persName>
                <email type="md5">8b0bed7369cfe1a6bac9593964cbea24</email>
                <email type="domain">inria.fr</email>
              </name>
            </respStmt>
          </editionStmt>
          <publicationStmt>
            <distributor>CCSD</distributor>
            <idno type="halId">lirmm-04320944</idno>
            <idno type="halUri">https://hal-lirmm.ccsd.cnrs.fr/lirmm-04320944</idno>
            <idno type="halBibtex">baget:lirmm-04320944</idno>
            <idno type="halRefHtml">&lt;i&gt;SIGMOD/PODS 2023 - International Conference on Management of Data&lt;/i&gt;, Jul 2023, Seattle, WA, United States. pp.291-302, &lt;a target="_blank" href="https://dx.doi.org/10.1145/3584372.3588659"&gt;&amp;#x27E8;10.1145/3584372.3588659&amp;#x27E9;&lt;/a&gt;</idno>
            <idno type="halRef">SIGMOD/PODS 2023 - International Conference on Management of Data, Jul 2023, Seattle, WA, United States. pp.291-302, &amp;#x27E8;10.1145/3584372.3588659&amp;#x27E9;</idno>
          </publicationStmt>
          <seriesStmt>
            <idno type="stamp" n="CNRS">CNRS - Centre national de la recherche scientifique</idno>
            <idno type="stamp" n="INRIA">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="INRIA-SOPHIA">INRIA Sophia Antipolis - MÃ©diterranÃ©e</idno>
            <idno type="stamp" n="IATE">IngÃ©nierie des agropolymÃ¨res et technologies Ã©mergentes</idno>
            <idno type="stamp" n="INRIASO">INRIA-SOPHIA</idno>
            <idno type="stamp" n="INRIA_TEST">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="TESTALAIN1">TESTALAIN1</idno>
            <idno type="stamp" n="LIRMM">Laboratoire d'Informatique de Robotique et de MicroÃ©lectronique de Montpellier</idno>
            <idno type="stamp" n="INRIA2">INRIA 2</idno>
            <idno type="stamp" n="UNIV-MONTPELLIER">UniversitÃ© de Montpellier</idno>
            <idno type="stamp" n="INSTITUT-AGRO-MONTPELLIER">Institut Agro Montpellier</idno>
            <idno type="stamp" n="INRAE">Institut National de Recherche en Agriculture, Alimentation et Environnement</idno>
            <idno type="stamp" n="INRAEOCCITANIEMONTPELLIER" corresp="INRAE">INRAE Occitanie Montpellier</idno>
            <idno type="stamp" n="ANR">ANR</idno>
            <idno type="stamp" n="UM-2015-2021" corresp="UNIV-MONTPELLIER">UniversitÃ© de Montpellier (2015-2021)</idno>
            <idno type="stamp" n="UM-EPE" corresp="UNIV-MONTPELLIER">UniversitÃ© de Montpellier - EPE</idno>
            <idno type="stamp" n="BOREAL" corresp="LIRMM">ReprÃ©sentation de Connaissances et Langages Ã  Base de RÃ¨gles pour Raisonner sur les DonnÃ©es</idno>
            <idno type="stamp" n="RESEAU-EAU">RÃ©seau "SystÃ¨mes Agricoles et Eau"</idno>
            <idno type="stamp" n="INSTITUT-AGRO">Institut Agro</idno>
            <idno type="stamp" n="INRIA-ALLEMAGNE">INRIA-ALLEMAGNE</idno>
            <idno type="stamp" n="IA">Intelligence Artificielle</idno>
          </seriesStmt>
          <notesStmt>
            <note type="audience" n="2">International</note>
            <note type="invited" n="0">No</note>
            <note type="popular" n="0">No</note>
            <note type="peer" n="1">Yes</note>
            <note type="proceedings" n="1">Yes</note>
          </notesStmt>
          <sourceDesc>
            <biblStruct>
              <analytic>
                <title xml:lang="en">Bounded Treewidth and the Infinite Core Chase: Complications and Workarounds toward Decidable Querying</title>
                <author role="aut">
                  <persName>
                    <forename type="first">Jean-FranÃ§ois</forename>
                    <surname>Baget</surname>
                  </persName>
                  <email type="md5">8b0bed7369cfe1a6bac9593964cbea24</email>
                  <email type="domain">inria.fr</email>
                  <idno type="idhal" notation="string">jfbaget</idno>
                  <idno type="idhal" notation="numeric">2418</idno>
                  <idno type="halauthorid" notation="string">23949-2418</idno>
                  <idno type="ORCID">https://orcid.org/0000-0001-7221-5770</idno>
                  <idno type="IDREF">https://www.idref.fr/174121555</idno>
                  <affiliation ref="#struct-1102911" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Marie-Laure</forename>
                    <surname>Mugnier</surname>
                  </persName>
                  <email type="md5">3ef441151c4a1431a5e05b4da19d881c</email>
                  <email type="domain">lirmm.fr</email>
                  <idno type="idhal" notation="string">marie-laure-mugnier</idno>
                  <idno type="idhal" notation="numeric">6245</idno>
                  <idno type="halauthorid" notation="string">18411-6245</idno>
                  <idno type="ORCID">https://orcid.org/0000-0002-0574-3693</idno>
                  <idno type="IDREF">https://www.idref.fr/129977896</idno>
                  <affiliation ref="#struct-1102911" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Sebastian</forename>
                    <surname>Rudolph</surname>
                  </persName>
                  <email type="md5">ac5938c3dc736d968f5495c4280ba2ad</email>
                  <email type="domain">tu-dresden.de</email>
                  <idno type="idhal" notation="numeric">950283</idno>
                  <idno type="halauthorid" notation="string">536461-950283</idno>
                  <affiliation ref="#struct-231054" />
                </author>
              </analytic>
              <monogr>
                <title level="m">Proceedings of the 42nd ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
                <meeting>
                  <title>SIGMOD/PODS 2023 - International Conference on Management of Data</title>
                  <date type="start">2023-07-18</date>
                  <date type="end">2023-07-23</date>
                  <settlement>Seattle, WA</settlement>
                  <country key="US">United States</country>
                </meeting>
                <imprint>
                  <publisher>ACM</publisher>
                  <biblScope unit="pp">291-302</biblScope>
                  <date type="datePub">2023-06-18</date>
                </imprint>
              </monogr>
              <idno type="doi">10.1145/3584372.3588659</idno>
              <ref type="publisher">https://2023.sigmod.org/</ref>
            </biblStruct>
          </sourceDesc>
          <profileDesc>
            <langUsage>
              <language ident="en">English</language>
            </langUsage>
            <textClass>
              <keywords scheme="author">
                <term xml:lang="en">Chase</term>
                <term xml:lang="en">Core</term>
                <term xml:lang="en">Universal Models</term>
                <term xml:lang="en">Treewidth</term>
                <term xml:lang="en">Existential rules</term>
                <term xml:lang="en">Tuple-generating dependencies</term>
              </keywords>
              <classCode scheme="halDomain" n="info.info-ai">Computer Science [cs]/Artificial Intelligence [cs.AI]</classCode>
              <classCode scheme="halTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halOldTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halTreeTypology" n="COMM">Conference papers</classCode>
            </textClass>
            <abstract xml:lang="en">
              <p>The core chase, a popular algorithm for answering conjunctive queries (CQs) over existential rules, is guaranteed to terminate and compute a finite universal model whenever one exists, leading to the equivalence of the universal-model-based and the chase-based definitions of finite expansion sets (fes) â€“ a class of rulesets featuring decidable CQ entailment. In case of non-termination, however, it is non-trivial to define a â€œresultâ€ of the core chase, due to its non-monotonicity. This causes complications when dealing with advanced decidability criteria based on the existence of (universal) models of finite treewidth. For these, sufficient chase-based conditions have only been established for weaker, monotonic chase variants.This paper investigates the â€“ prima facie plausible â€“ hypothesis that the existence of a treewidth-bounded universal model and the existence of a treewidth-bounded core-chase sequence coincide â€“ which would conveniently entail decidable CQ entailment whenever the latter holds. Perhaps surprisingly, carefully crafted examples show that both directions of this hypothesized correspondence fail. On a positive note, we are still able to define an aggregation scheme for the infinite core chase that preserves treewidth bounds and produces a finitely universal model, i.e., one that satisfies exactly the entailed CQs. This allows us to prove that the existence of a treewidth-bounded core-chase sequence does warrant decidability of CQ entailment (yet, on other grounds than expected). Hence, for the first time, we are able to define a chase-based notion of boundedtreewidth sets of rules that subsumes fes.</p>
            </abstract>
          </profileDesc>
        </biblFull>
      </listBibl>
    </body>
    <back>
      <listOrg type="structures">
        <org type="researchteam" xml:id="struct-1102911" status="VALID">
          <idno type="RNSR">202224285F</idno>
          <orgName>ReprÃ©sentation de Connaissances et Langages Ã  Base de RÃ¨gles pour Raisonner sur les DonnÃ©es</orgName>
          <orgName type="acronym">BOREAL</orgName>
          <date type="start">2022-06-01</date>
          <desc>
            <address>
              <addrLine>LIRMM, 161 rue Ada, 34000 Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.lirmm.fr/equipes/BOREAL</ref>
          </desc>
          <listRelation>
            <relation active="#struct-34586" type="direct" />
            <relation active="#struct-300009" type="indirect" />
            <relation active="#struct-1100620" type="direct" />
            <relation name="UMR5506" active="#struct-441569" type="indirect" />
            <relation name="UMR5506" active="#struct-1100589" type="indirect" />
            <relation active="#struct-1100827" type="direct" />
            <relation name="UMR1208" active="#struct-577435" type="indirect" />
            <relation active="#struct-1096330" type="indirect" />
            <relation active="#struct-1042499" type="indirect" />
            <relation active="#struct-1100589" type="indirect" />
          </listRelation>
        </org>
        <org type="laboratory" xml:id="struct-231054" status="VALID">
          <orgName>Faculty of Computer Science [TU Dresden]</orgName>
          <desc>
            <address>
              <addrLine>NÃ¶thnitzer StraÃŸe, 46, 01062, Dresden</addrLine>
              <country key="DE" />
            </address>
            <ref type="url">https://tu-dresden.de/ing/informatik</ref>
          </desc>
          <listRelation>
            <relation active="#struct-96520" type="direct" />
          </listRelation>
        </org>
        <org type="laboratory" xml:id="struct-34586" status="VALID">
          <idno type="RNSR">198318250R</idno>
          <idno type="ROR">https://ror.org/01nzkaw91</idno>
          <orgName>Inria Sophia Antipolis - MÃ©diterranÃ©e</orgName>
          <orgName type="acronym">CRISAM</orgName>
          <desc>
            <address>
              <addrLine>2004 route des Lucioles BP 93 06902 Sophia Antipolis</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/centre/sophia/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300009" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-300009" status="VALID">
          <idno type="ROR">https://ror.org/02kvxyf05</idno>
          <orgName>Institut National de Recherche en Informatique et en Automatique</orgName>
          <orgName type="acronym">Inria</orgName>
          <desc>
            <address>
              <addrLine>Domaine de VoluceauRocquencourt - BP 10578153 Le Chesnay Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/en/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-1100620" status="VALID">
          <idno type="IdRef">139590827</idno>
          <idno type="ISNI">0000000405990488</idno>
          <idno type="RNSR">199111950H</idno>
          <idno type="ROR">https://ror.org/013yean28</idno>
          <orgName>Laboratoire d'Informatique de Robotique et de MicroÃ©lectronique de Montpellier</orgName>
          <orgName type="acronym">LIRMM</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>161 rue Ada - 34095 Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.lirmm.fr</ref>
          </desc>
          <listRelation>
            <relation name="UMR5506" active="#struct-441569" type="direct" />
            <relation name="UMR5506" active="#struct-1100589" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-441569" status="VALID">
          <idno type="IdRef">02636817X</idno>
          <idno type="ISNI">0000000122597504</idno>
          <idno type="ROR">https://ror.org/02feahw73</idno>
          <orgName>Centre National de la Recherche Scientifique</orgName>
          <orgName type="acronym">CNRS</orgName>
          <date type="start">1939-10-19</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cnrs.fr/</ref>
          </desc>
        </org>
        <org type="regroupinstitution" xml:id="struct-1100589" status="VALID">
          <idno type="ROR">https://ror.org/051escj72</idno>
          <orgName>UniversitÃ© de Montpellier</orgName>
          <orgName type="acronym">UM</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>163 rue Auguste Broussonnet - 34090 Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.umontpellier.fr/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-1100827" status="VALID">
          <idno type="ISNI">0000000403736662</idno>
          <idno type="RNSR">200317667V</idno>
          <idno type="ROR">https://ror.org/0000n5x09</idno>
          <orgName>IngÃ©nierie des Agro-polymÃ¨res et Technologies Ã‰mergentes</orgName>
          <orgName type="acronym">UMR IATE</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>Campus de la Gaillarde 2, place Pierre Viala 34 060 Montpellier CÃ©dex 02 - FRANCE</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://umr-iate.cirad.fr/</ref>
          </desc>
          <listRelation>
            <relation name="UMR1208" active="#struct-577435" type="direct" />
            <relation active="#struct-1096330" type="direct" />
            <relation active="#struct-1042499" type="indirect" />
            <relation active="#struct-1100589" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-577435" status="VALID">
          <idno type="ROR">https://ror.org/003vg9w96</idno>
          <orgName>Institut National de Recherche pour lâ€™Agriculture, lâ€™Alimentation et lâ€™Environnement</orgName>
          <orgName type="acronym">INRAE</orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
          </desc>
        </org>
        <org type="institution" xml:id="struct-1096330" status="VALID">
          <idno type="IdRef">261038990</idno>
          <idno type="ROR">https://ror.org/03rnk6m14</idno>
          <orgName>Institut Agro Montpellier</orgName>
          <date type="start">2022-01-01</date>
          <desc>
            <address>
              <addrLine>2, place Viala - Montpellier</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.institut-agro-montpellier.fr/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-1042499" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-1042499" status="VALID">
          <idno type="IdRef">260373249</idno>
          <orgName>Institut national d'enseignement supÃ©rieur pour l'agriculture, l'alimentation et l'environnement</orgName>
          <orgName type="acronym">Institut Agro</orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.institut-agro.fr</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-96520" status="VALID">
          <idno type="ROR">https://ror.org/042aqky30</idno>
          <orgName>Technische UniversitÃ¤t Dresden = Dresden University of Technology</orgName>
          <orgName type="acronym">TU Dresden</orgName>
          <desc>
            <address>
              <addrLine>TU Dresden 01062 Dresden</addrLine>
              <country key="DE" />
            </address>
            <ref type="url">http://tu-dresden.de/</ref>
          </desc>
        </org>
      </listOrg>
      <listOrg type="projects">
        <org type="anrProject" xml:id="projanr-48388" status="VALID">
          <idno type="anr">ANR-18-CE23-0003</idno>
          <idno type="program">APPEL Ã€ PROJETS GÃ‰NÃ‰RIQUE 2018</idno>
          <orgName>CQFD</orgName>
          <desc>RequÃªtes Ontologiques Complexes sur des FÃ©dÃ©rations de DonnÃ©es HÃ©tÃ©rogÃ¨nese</desc>
          <date type="start">2018</date>
        </org>
      </listOrg>
    </back>
  <teiCorpus>
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bounded Treewidth and the Infinite Core Chase Complications and Workarounds toward Decidable Querying</title>
				<funder ref="#_75C6S47">
					<orgName type="full">European Research Council</orgName>
				</funder>
				<funder ref="#_395rhe3">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
							<email>jfbaget@inria.frmugnier@lirmm.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
							<email>sebastian.rudolph@tu-dresden.de</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Computational Logic Group</orgName>
								<orgName type="institution">TU Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Bounded Treewidth and the Infinite Core Chase Complications and Workarounds toward Decidable Querying</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">C98BFEA407E06BADD465374513DC78A5</idno>
					<idno type="DOI">10.1145/3584372.3588659</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>existential rules</term>
					<term>tuple-generating dependencies</term>
					<term>chase</term>
					<term>treewidth</term>
					<term>universal models</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>The core chase, a popular algorithm for answering conjunctive queries (CQs) over existential rules, is guaranteed to terminate and compute a finite universal model whenever one exists, leading to the equivalence of the universal-model-based and the chase-based definitions of finite expansion sets (fes) -a class of rulesets featuring decidable CQ entailment. In case of non-termination, however, it is non-trivial to define a "result" of the core chase, due to its non-monotonicity. This causes complications when dealing with advanced decidability criteria based on the existence of (universal) models of finite treewidth. For these, sufficient chase-based conditions have only been established for weaker, monotonic chase variants.</p><p>This paper investigates the -prima facie plausible -hypothesis that the existence of a treewidth-bounded universal model and the existence of a treewidth-bounded core-chase sequence coincidewhich would conveniently entail decidable CQ entailment whenever the latter holds. Perhaps surprisingly, carefully crafted examples show that both directions of this hypothesized correspondence fail. On a positive note, we are still able to define an aggregation scheme for the infinite core chase that preserves treewidth bounds and produces a finitely universal model, i.e., one that satisfies exactly the entailed CQs. This allows us to prove that the existence of a treewidth-bounded core-chase sequence does warrant decidability of CQ entailment (yet, on other grounds than expected). Hence, for the first time, we are able to define a chase-based notion of bounded treewidth sets of rules that subsumes fes.</p></div>
<div><head>CCS CONCEPTS</head><p>â€¢ Theory of computation â†’ Automated reasoning; â€¢ Computing methodologies â†’ Knowledge representation and reasoning.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>The chase is a fundamental tool for the popular formalism of existential rules, also known as tuple-generating dependencies. Given a knowledge base (KB) composed of a finite set ğ¹ of facts (the database) and a set Î£ of (existential) rules, the chase repeatedly applies rules, giving rise to a sequence ğ¹ =ğ¹ 0 , ğ¹ 1 , ğ¹ 2 , . . . If, in the course of this, a fixpoint is reached after a finite number of steps, one speaks of chase termination. Then, the final fact set obtained, seen as a structure, constitutes a finite model of the given KB, which is also universal, meaning that it can be homomorphically mapped to any model of the KB. This pleasant property allows one to consider this single model (instead of all models) to answer all queries preserved under homomorphisms, ranging from conjunctive queries (CQs) to datalog and other second-order queries.</p><p>In fact, there are different chase variants with differing behavior regarding redundancy treatment and termination. The simplest, most lavish, known as the oblivious chase, performs all possible rule applications, without checking for any redundancies <ref type="bibr" target="#b5">[6]</ref>. The most frugal, known as the core chase, prunes all redundancies at each step, retaining a minimal set of atoms, which is called a core <ref type="bibr" target="#b8">[9]</ref>. Between these two extremes, the semi-oblivious (aka skolem) and restricted (aka standard) chase avoid the creation of some redundancies, but not all <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b16">17]</ref>. The core chase is the only chase variant that terminates exactly when the KB has a finite universal model, and produces the unique (up to isomorphism) smallest such model. Thus, the core chase is the best choice for a decision procedure that aims at chase termination. This motivates the definition of the fes (finite expansion sets) class containing all rule sets Î£ for which the core chase for K = (ğ¹, Î£) terminates for all ğ¹ <ref type="bibr" target="#b2">[3]</ref>. For such Î£, the entailment K |= ğ‘„ for any CQ ğ‘„ can be decided by computing the core chase and evaluating ğ‘„ against the resulting structure.</p><p>Yet, finite universal models may not exist. In such cases, no chase reaches a fixpoint, and there is no last chase sequence element to pick as a result. As a remedy, one may define the "result" of the chase as the infinite union over all the fact sets of the infinite sequence, obtaining an infinite structure. This will still yield a universal model for monotonic chase variants, where ğ¹ ğ‘– âŠ† ğ¹ ğ‘–+1 holds for all ğ‘–, such te rm in at in g cc = fin ite un iv er sa l m od el tw -b ou nd ed rc tw -f in ite un iv er sa l m od el inflating elevator tw -b ou nd ed cc tw-finite finitely universal model steepening staircase Figure <ref type="figure">1</ref>: Venn diagram displaying the (non-)inclusion of decidable classes of existential rule sets discussed in the paper. We abbreviate treewidth by tw, and restricted and core chase by rc and cc, respectively. The rulesets entitled "steepening staircase" and "inflating elevator" demonstrate that existence of treewidth-finite universal models and treewidth-bounded core-chase sequences are independent properties. The tw-bounded cc class actually comes in two flavors, referred to as uniform and recurring boundedness. The latter is more general, but the distinction is irrelevant for this overview.</p><p>as the oblivious, semi-oblivious and restricted chases. However, this does not work well for non-monotonic chase variants such as the core chase, where one cannot even be certain to obtain a model.</p><p>One could argue that these issues are of theoretical interest only, given that the non-terminating chase cannot actually be computed and cannot serve as a decision procedure. However, fortunately, decidability of CQ entailment can be established by other means, even when the chase does not terminate. In particular, it is ensured whenever an infinite universal model exists that is still reasonably "structurally well-behaved" by virtue of having a bounded treewidth <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref>. This insight gave rise to many existential rule fragments of high practical relevance, mostly based on varying notions of guardedness, which impose syntactic restrictions ensuring treewidthboundedness for all chase sequences <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b15">16</ref>]. Yet, these classes all have in common that the existence of a treewidth-bounded universal model can be established only via chase variants that are necessarily monotonic: the union over all ğ¹ ğ‘– in a monotonic chase sequence is known to inherit the treewidth bound. Regrettably, for the core chase, which produces "smaller" intermediate structures and hence ensures treewidth-boundedness of the produced facts more often, no adequate model-producing "aggregation" strategy is known, let alone a treewidth-preserving one.</p><p>To overcome this issue, we provide a decidability guarantee, but also bring some unpleasant truths to light. We propose a treewidthpreserving aggregation scheme for the core chase that produces a model, but not a universal one. Luckily, we can still guarantee that the resulting model is finitely universal (that is, any of its finite substructures is universal) and thus sufficient for our purpose of decidable CQ entailment. Also, we show that the failure to construct a treewidth-bounded universal model out of a treewidth-bounded chase sequence is not a flaw of our approach, but unavoidable, by exhibiting the steepening staircase example: a uniformly treewidthbounded core-chase sequence for a KB whose every universal model has infinite treewidth. Conversely, the inflating elevator example presents a KB with a universal model of finite treewidth, yet each of its core-chase sequences consists of structures of ever-growing treewidth, refuting the plausible hypothesis that any universal model of bounded treewidth can be obtained from a treewidthbounded core-chase sequence. Figure <ref type="figure">1</ref> summarizes our findings.</p></div>
<div><head n="2">PRELIMINARIES</head><p>We use countably infinite disjoint sets Î” ğ‘‰ of variables (denoted by uppercase letters) and Î” ğ¶ of constants (denoted by lowercase letters). A schema S is a finite set of relation symbols (or predicates); each p âˆˆ S is given an arity ar (p) â‰¥ 0. The set of terms is</p><formula xml:id="formula_0">Î” ğ‘‡ = Î” ğ¶ âˆª Î” ğ‘‰ . A list ğ‘¡ 1 , . . . , ğ‘¡ ğ‘˜ of terms is also denoted by Ã¬ ğ‘¡ with | Ã¬ ğ‘¡ | = ğ‘˜.</formula><p>Atomsets and Homomorphisms. An atom over a schema S is an expression of the form p( Ã¬ ğ‘¡), p âˆˆ S and Ã¬ ğ‘¡ âˆˆ (Î” ğ‘‡ ) ğ‘˜ with ğ‘˜ = ar (p). An atomset over S is a countable set of atoms over S. For an atom or atomset ğ´, we let terms(ğ´) and vars(ğ´) denote the set of terms and variables in ğ´, respectively.</p><p>A substitution of a set of variables Y âŠ† Î” ğ‘‰ is a mapping ğœ from Y to Î” ğ‘‡ . For an atom at = p(ğ‘¡ 1 , . . . , ğ‘¡ ğ‘˜ ) and a substitution ğœ of Y, let ğœ (at) = p(ğœ + (ğ‘¡ 1 ), . . . , ğœ + (ğ‘¡ ğ‘˜ )) where ğœ + (ğ‘¡ ğ‘– ) = ğœ (ğ‘¡ ğ‘– ) whenever ğ‘¡ ğ‘– âˆˆ Y and ğœ + (ğ‘¡ ğ‘– ) = ğ‘¡ ğ‘– otherwise. If ğ´ is an atomset, then ğœ (ğ´) = {ğœ (at) | at âˆˆ ğ´}. For two substitutions ğœ and ğœ â€² of variable sets Y and Y â€² , respectively, we let ğœ â€² â€¢ ğœ denote the substitution of Y â€² âˆª Y defined by ğ‘Œ â†¦ â†’ ğœ â€²+ (ğœ + (ğ‘Œ )). Two substitutions are compatible if they map the same variables to the same terms.</p><p>A homomorphism from an atomset ğ´ to an atomset ğµ is a substitution ğœ‹ with ğœ‹ (ğ´) âŠ† ğµ. Given such a homomorphism ğœ‹, we also say that ğœ‹ maps ğ´ to ğµ, or that ğ´ maps to ğµ (via ğœ‹). An isomorphism from ğ´ to ğµ is a bijective homomorphism ğœ‹ such that ğœ‹ -<ref type="foot" target="#foot_0">1</ref> is a homomorphism from ğµ to ğ´ (then ğ´ and ğµ are called isomorphic). An endomorphism (automorphism) of ğ´ is a homomorphism (isomorphism) from ğ´ to itself. A retraction of ğ´ is an endomorphism ğœ‹ where the restriction of ğœ‹ to terms(ğœ‹ (ğ´)) (the retract) is the identity. Note that the classes of homomorphisms, endomorphisms, isomorphisms, and retractions are all closed under composition. A finite atomset ğ´ is called a core if every retraction of ğ´ is the identity. Any finite atomset ğ´ admits a retract that is a core; this retract is unique up to isomorphism and called the core of ğ´.</p><p>We identify an atomset with the (possibly infinite) formula obtained from the existential closure of the conjunction of its atoms. Finite or infinite atomsets also naturally correspond to first-order interpretations; 1 if we want to emphasize this aspect, we also refer to them as instances. A (Boolean) conjunctive query (CQ) is a finite atomset. Note that we conflate labeled nulls usually used in instances with variables usually used in queries, as they correspond to the same logical notion. We rely on the standard notions of model and semantic entailment, denoted by |=. An instance ğ¼ is a model of a (possibly infinite) atomset ğ´ iff ğ´ maps to ğ¼ ; for ğ´ and ğµ two (possibly infinite) atomsets, ğ´ |= ğµ iff ğµ maps to ğ´.</p></div>
<div><head>Existential</head><p>Rules. An (existential) rule ğ‘… is of the form ğµ â†’ ğ» , where the body ğµ = body(ğ‘…) and the head ğ» = head (ğ‘…) are nonempty finite atomsets. The variables in ğµ are called universal, those both in ğµ and ğ» are called frontier, and those only in ğ» are called existential. We identify a rule with the first-order sentence</p><formula xml:id="formula_1">âˆ€ Ã¬ ğ‘‹ Ã¬ ğ‘Œ. ğµ [ Ã¬ ğ‘‹, Ã¬ ğ‘Œ ] â†’ âˆƒ Ã¬ ğ‘. ğ» [ Ã¬ ğ‘‹, Ã¬ ğ‘ ]</formula><p>where Ã¬ ğ‘‹, Ã¬ ğ‘Œ, Ã¬ ğ‘ are the frontier, nonfrontier universal, and existential variables of ğ‘…, respectively. In examples, we use the logical notation but omit universal quantifiers.</p><p>Given an instance ğ¼ and a rule ğµ â†’ ğ» , a trigger for ğ¼ is a pair tr = (ğµ â†’ ğ», ğœ‹) such that ğœ‹ maps ğµ to ğ¼ ; tr is satisfied in ğ¼ if ğœ‹ can be extended to a homomorphism from ğµ âˆª ğ» to ğ¼ . Note that an instance ğ¼ is a model of a rule ğ‘… iff it satisfies every trigger for ğ¼ of the form (ğ‘…, ğœ‹). Given a rule ğ‘… = ğµ â†’ ğ» , an instance ğ¼ and a trigger tr = (ğ‘…, ğœ‹) for ğ¼ , the application of tr on ğ¼ produces the instance ğ›¼ (ğ¼, tr) = ğ¼ âˆª ğœ‹ safe (ğ» ), where ğœ‹ safe maps every frontier-variable ğ‘‹ of ğ‘… to ğœ‹ (ğ‘‹ ) and any existential variable in vars(ğ» ) to a fresh variable (usually called a labeled null). <ref type="foot" target="#foot_1">2</ref>Universal Models. A knowledge base (KB) is a pair K = (ğ¹, Î£), where ğ¹ is a finite instance and Î£ is a finite set of rules. An instance ğ¼ is a model of K if it is a model of ğ¹ and of each rule in Î£. An instance ğ¼ is universal for K if it (homomorphically) maps to every model of K; note that this does not necessarily mean that ğ¼ is a model of K. An instance ğ¼ is a universal model of K if it is a model of K and is universal for K. We consider the following CQ entailment problem: given a KB K and a Boolean CQ ğ‘„, does K |= ğ‘„ hold? For any universal model ğ¼ of K, K |= ğ‘„ holds iff ğ‘„ (homomorphically) maps to ğ¼ , hence, a universal model of K is sufficient to decide CQ entailment.</p></div>
<div><head n="3">DERIVATIONS AND THEIR RESULTS</head><p>In this paper, we focus on the restricted and the core chase variants. We now introduce a convenient notion of derivation to define these two variants. Actually, it would allow to define other variants that fall between these two variants in terms of redundancy removal, like e.g., the frugal chase <ref type="bibr" target="#b14">[15]</ref>. Our type of derivation is not only a sequence of rule applications, but also incorporates a retraction that removes (some) redundancies after each rule application. In the following, â„‘ denotes either the set N of natural integers (for infinite derivations) or the interval {0, . . . , ğ‘˜ } âŠ† N (for finite ones). Definition 1 (Derivation). A derivation from a KB K = (ğ¹, Î£) is a (possibly infinite) sequence D = ((tr ğ‘– , ğœ ğ‘– , ğ¹ ğ‘– )) ğ‘– âˆˆâ„‘ , where the tr ğ‘– are triggers (except tr 0 = âˆ…), the ğœ ğ‘– are retractions called simplifications, and the ğ¹ ğ‘– are finite instances such that: ğ¹ 0 = ğœ 0 (ğ¹ ); and, for all ğ‘– âˆˆ â„‘\{0}, ğ¹ ğ‘– = ğœ ğ‘– (ğ›¼ (ğ¹ ğ‘– -1 , tr ğ‘– )), where tr ğ‘– = (ğ‘… ğ‘– , ğœ‹ ğ‘– ) with ğ‘… ğ‘– âˆˆ Î£ is a trigger for ğ¹ ğ‘– -1 not satisfied in ğ¹ ğ‘– -1 .</p><p>For the sake of brevity, we often denote a derivation simply by D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ , leaving the tr ğ‘– and ğœ ğ‘– implicit. A derivation is called monotonic if ğ¹ ğ‘– -1 âŠ† ğ¹ ğ‘– holds for all ğ‘– âˆˆ â„‘\{0}. In a monotonic derivation, the restriction of ğœ ğ‘– to the terms of ğ¹ ğ‘– -1 is the identity.</p><p>When a derivation D = (ğ¹ ğ‘– ) 0â‰¤ğ‘– â‰¤ğ‘˜ is finite, its result can be defined by just taking its last instance: D + = ğ¹ ğ‘˜ . However, for infinite derivations of the form D = (ğ¹ ğ‘– ) ğ‘– âˆˆN , the "result" of D is usually defined as the (infinite) union of all instances along D. We denote this union by D * = ğ‘– âˆˆâ„‘ ğ¹ ğ‘– and call it the natural aggregation of D (to distinguish it from the robust aggregation defined in Section 8). Note that if D is a finite monotonic derivation, then D * = D + .</p><p>As stated in the next proposition, D * is universal for K. Yet, to ensure that a model of K is obtained, we need to require fairness, which intuitively means that every trigger for some ğ¹ ğ‘– has to be satisfied in some ğ¹ ğ‘— with ğ‘— â‰¥ ğ‘–. To formalize this notion, a difficulty with our derivation notion (which arises for any non-monotonic type of chase) is that a trigger (ğ‘…, ğœ‹) for some ğ¹ ğ‘– may not remain a trigger for some ğ¹ ğ‘— with ğ‘— &gt; ğ‘–: this is because ğœ‹ (body(R)) may be "transformed away" by successive simplifications. To address this issue, we need to "trace" how a set of atoms is transformed along a derivation. Definition 2. Let D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ be a derivation, and ğ‘‹ be a variable occurring in some ğ¹ ğ‘– . For any ğ‘— âˆˆ â„‘ with ğ‘— â‰¥ ğ‘–, we define Ïƒğ‘–</p><formula xml:id="formula_2">ğ‘– (ğ‘‹ ) = ğ‘‹ and Ïƒ ğ‘— ğ‘– (ğ‘‹ ) = ğœ ğ‘— â€¢ â€¢ â€¢ â€¢ â€¢ ğœ ğ‘–+1 (ğ‘‹ ) when ğ‘— &gt; ğ‘–.</formula><p>It is immediate that Ïƒ ğ‘— ğ‘– (which is either the identity when ğ‘– = ğ‘— or ğœ ğ‘— â€¢ â€¢ â€¢ â€¢ â€¢ ğœ ğ‘–+1 otherwise) is a homomorphism from ğ¹ ğ‘– to ğ¹ ğ‘— . Note also that for a monotonic derivation, Ïƒ ğ‘— ğ‘– is the identity for any ğ‘—. In the following, if tr = (ğ‘…, ğœ‹) is a trigger for ğ´ and ğœ is a substitution, we note ğœ (tr) = (ğ‘…, ğœ â€¢ ğœ‹) the trigger for ğœ (ğ´).</p></div>
<div><head>Definition 3 (Fair derivation).</head><p>A derivation D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ is fair if, for any ğ‘– âˆˆ â„‘ and trigger tr for ğ¹ ğ‘– , there is some ğ‘— âˆˆ â„‘ with ğ‘— â‰¥ ğ‘–, such that Ïƒ ğ‘— ğ‘– (tr) is a satisfied trigger for ğ¹ ğ‘— .</p><p>In classical chase procedures, only active triggers (a notion specific to each chase variant) are applied. In the restricted chase, a trigger for ğ¹ ğ‘– is active if it is not already satisfied in ğ¹ ğ‘– . The core chase furthermore computes a retraction to a core after each (or a finite number of) rule application. For both variants, the classical definition of a chase sequence coincides with our notion of a fair derivation. A restricted chase sequence can be seen as a fair derivation ((tr ğ‘– , ğœ ğ‘– , ğ¹ ğ‘– )) ğ‘– âˆˆâ„‘ in which ğœ ğ‘– is the identity. Since this derivation is monotonic, it allows for a simpler expression of fairness: any trigger for an ğ¹ ğ‘– has to be satisfied in some ğ¹ ğ‘— , with ğ‘– â‰¤ ğ‘—. A core chase sequence can be seen as a (non-monotonic) fair derivation in which each ğœ ğ‘– produces a core.</p><p>Finally, we adapt to our general framework some well-known properties of these chase variants <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14]</ref>. Albeit D * is not always a model, modelhood is guaranteed for monotonic derivations, as already known for the restricted chase. Proposition 1. Let D be a derivation from K. Then: (1) D * is universal for K;</p><p>(2) if D is monotonic and fair, D * is a model of K;</p><p>(3) if D is fair, for all CQ ğ‘„, K |= ğ‘„ iff D * |= ğ‘„.</p></div>
<div><head n="4">ADDING TREEWIDTH TO THE PICTURE</head><p>We now recall the popular notion of the treewidth of an atomset as well as some well-known facts about it, which will be useful later. Definition 4. Given an atomset ğ´, a tree decomposition of ğ´ is a (possibly infinite) tree ğ‘‡ = (ğ‘‰, ğ¸), with vertices ğ‘‰ âŠ† 2 terms (ğ´) and edges ğ¸ âˆˆ ğ‘‰ Ã— ğ‘‰ , where:</p><p>â€¢ for each at âˆˆ ğ´ exists some ğ‘£ âˆˆ ğ‘‰ with terms(at) âŠ† ğ‘£;</p><p>â€¢ for each ğ‘¡ âˆˆ terms(ğ´), letting ğ‘‰ ğ‘¡ = {ğ‘£ âˆˆ ğ‘‰ | ğ‘¡ âˆˆ ğ‘£ }, the subgraph of ğ‘‡ induced by ğ‘‰ ğ‘¡ is connected. The width of ğ‘‡ = (ğ‘‰ , ğ¸) is the size of its largest vertex, minus 1. The treewidth of an atomset ğ´, denoted by ğ‘¡ğ‘¤ (ğ´), is the minimal width among all its tree decompositions.</p><p>Fact 1. ğ´ âŠ† ğµ implies tw(ğ´) â‰¤ tw(ğµ).</p><p>Definition 5. Given a natural number ğ‘›, we say that an atomset ğ´ contains an ğ‘› Ã— ğ‘›-grid, if terms(ğ´) contains ğ‘› 2 distinct terms, denoted ğ‘¡ ğ‘– ğ‘— for ğ‘–, ğ‘— âˆˆ {1, . . . , ğ‘›}, such that for all ğ‘˜ âˆˆ {1, . . . , ğ‘› -1} and â„“ âˆˆ {1, . . . , ğ‘›}:</p><p>â€¢ there is some at âˆˆ ğ´ with {ğ‘¡ ğ‘˜ â„“ , ğ‘¡ ğ‘˜+1 â„“ } âŠ† terms(at), and</p><formula xml:id="formula_3">â€¢ there is some at â€² âˆˆ ğ´ with {ğ‘¡ â„“ ğ‘˜ , ğ‘¡ â„“ ğ‘˜+1 } âŠ† terms(at â€² ). Fact 2. If ğ´ contains an ğ‘› Ã— ğ‘›-grid then tw(ğ´) â‰¥ ğ‘›.</formula><p>Treewidth is an important notion in the context of existential rules, as the existence of universal models with finite treewidth implies decidability of CQ entailment <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>. In fact, many concrete and practically relevant classes of existential rule sets enjoy this property. One generic way to guarantee the existence of such models is by imposing conditions on the corresponding derivations. This approach underlies all definitions of so-called bounded treewidth sets of rules from the literature, but there is a certain disagreement and diversity as to certain details and the type of chase employed (cf. Footnote 4). Here, we will provide the most general such definition that is known to guarantee finite-treewidth universal models along the lines of previously established proofs. Definition 6. A ruleset Î£ is called a bounded treewidth set (bts) if for any finite instance ğ¹ , there exist some ğ‘ âˆˆ N and a restricted chase sequence (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ such that tw(ğ¹ ğ‘– ) â‰¤ ğ‘ for all ğ‘– âˆˆ â„‘. Proposition 2. CQ entailment for bts is decidable.</p></div>
<div><head n="5">CORE CHASE &amp; STRUCTURAL MEASURES</head><p>In what follows, we will use the term structural measure to generically denote any function ğœ‡ that maps instances to elements of N âˆª {âˆ}. An easy example would be the size of an instance defined by size :</p><formula xml:id="formula_4">ğ¼ â†¦ â†’ |ğ¼ |. An instance ğ¼ is then called ğœ‡-finite, if ğœ‡ (ğ¼ ) â‰  âˆ.</formula><p>Moreover, we say that a sequence (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ of atomsets is uniformly ğœ‡bounded, if there exists some ğ‘˜ âˆˆ N such that ğœ‡ (ğ¹ ğ‘– ) â‰¤ ğ‘˜ for all ğ‘– âˆˆ â„‘. (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ will be called recurringly ğœ‡-bounded if there exists some ğ‘˜ âˆˆ N such that for any ğ‘— âˆˆ â„‘ there exists some ğ‘– â‰¥ ğ‘— from â„‘ for which ğœ‡ (ğ¹ ğ‘– ) â‰¤ ğ‘˜ holds. It is easy to see that uniform ğœ‡-boundedness implies recurring ğœ‡-boundedness, but not vice versa.</p><p>Since -on an intuitive level -universal models can be seen as "limits" of appropriate chase sequences, it is a natural question to ask to what extent this limit process preserves structural measures. More specifically, one may ask oneself, given a particular type of chase and structural measure ğœ‡, if the existence of a (uniformly or recurringly) ğœ‡-bounded chase sequence for a KB is a necessary and/or sufficient condition for the existence of a ğœ‡-finite universal model. As mentioned before, for the structural measure of size, this question can be answered positively: A knowledge base K has a (size-)finite universal model iff it has a size-bounded core chase sequence <ref type="bibr" target="#b8">[9]</ref>.</p><p>Turning to the structural measure of treewidth, however, we found that, surprisingly, both directions fail, witnessed by counterexamples for either direction: The "steepening staircase" KB (Section 6) allows for a (even uniformly) treewidth-bounded chase sequence while lacking a treewidth-finite universal model, whereas the "inflating elevator" KB (Section 7) has a universal model of finite treewidth while not exhibiting a (even just recurringly) treewidthbounded core-chase sequence.</p><p>Irrespective of the fact that our presentation focuses on treewidth as the arguably most prominent structural measure, it should be noted that our counterexamples are based on grid structures and therefore also immediately work for other measures, such as cliquewidth <ref type="bibr" target="#b10">[11]</ref> or (generalized) hypertreewidth <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div><head n="6">THE STEEPENING STAIRCASE</head><p>For the KB below, the core chase sequence is uniformly treewidthbounded by 2, but none of its universal models has finite treewidth.</p></div>
<div><head>Definition 7 (The Steepening Staircase KB). We let</head><formula xml:id="formula_5">K h = (ğ¹ h , Î£ h ) where Î£ h = {ğ‘… h 1 , ğ‘… h 2 , ğ‘… h 3 , ğ‘… h 4 }</formula><p>, as given in Figure <ref type="figure">2</ref>. We now describe the instance ğ¼ h , which is a universal model of K h that we can obtain via both the restricted and the core chase. Definition 8. We define ğ¼ h as the infinite instance using the terms terms</p><formula xml:id="formula_6">(ğ¼ h ) = {ğ‘‹ ğ‘– ğ‘— | (ğ‘–, ğ‘—) âˆˆ N 2 , ğ‘– + 1 â‰¥ ğ‘— } and consisting of the atoms f(ğ‘‹ ğ‘– 0 ) c(ğ‘‹ ğ‘– ğ‘— ) for ğ‘– â‰¥ ğ‘— â‰¥ 1 h(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘–+1 ğ‘— ) h(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘– ğ‘— ) for ğ‘– â‰¤ ğ‘— . v(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘– ğ‘—+1 )</formula><p>The instance ğ¼ h is depicted in Figure <ref type="figure">2</ref>; the names ğ‘‹ ğ‘– ğ‘— of the variables of ğ¼ h are in correspondence to their cartesian coordinates (ğ‘–, ğ‘—) in the picture. We now consider some particular subsets of terms(ğ¼ h ). For any ğ‘˜ âˆˆ N, let ğ‘ƒ ğ‘˜ = {ğ‘‹ ğ‘– ğ‘— } ğ‘– â‰¤ğ‘˜ , ğ¶ ğ‘˜ = {ğ‘‹ ğ‘˜ ğ‘— } ğ‘— â‰¤ğ‘˜ , and , and so on. The infinite union of all atomsets along this derivation is</p><formula xml:id="formula_7">ğ‘† ğ‘˜ = ğ¶ ğ‘˜ âˆª ğ¶ ğ‘˜+1 âˆª {ğ‘‹ ğ‘˜ ğ‘˜+1 }. Let ğ‘ƒ h ğ‘˜ (resp. ğ¶ h ğ‘˜ , ğ‘† h ğ‘˜ )</formula><formula xml:id="formula_8">D * r = ğ¼ h . Proposition 3. ğ¼ h is a result of the restricted chase on K h . h(ğ‘‹ , ğ‘‹ ) â†’ âˆƒğ‘‹ â€² ğ‘Œğ‘Œ â€² .h(ğ‘‹ , ğ‘Œ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ h(ğ‘‹ â€² , ğ‘Œ â€² ) âˆ§ v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ c(ğ‘Œ â€² ) (ğ‘… h 1 ) h(ğ‘‹ , ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ h(ğ‘‹ â€² , ğ‘‹ â€² ) âˆ§ h(ğ‘‹ â€² , ğ‘Œ â€² ) â†’ âˆƒğ‘Œ .c(ğ‘Œ â€² ) âˆ§ h(ğ‘‹ , ğ‘Œ ) âˆ§ v(ğ‘Œ , ğ‘Œ â€² ) (ğ‘… h 2 ) f(ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘Œ ) â†’ f(ğ‘Œ ) âˆ§ h(ğ‘Œ , ğ‘Œ ) (ğ‘… h 3 ) h(ğ‘‹ , ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ c(ğ‘‹ â€² ) â†’ h(ğ‘‹ â€² , ğ‘‹ â€² ) (ğ‘… h 4 ) {f(ğ‘‹ 0 0 ), h(ğ‘‹ 0 0 , ğ‘‹ 0 0 ) } (ğ¹ h ) ğ¹ h ğ‘… h 1 ğ‘… h 2 ğ‘… h 3 ğ‘… h 4 [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] ğ¼ h Ä¨ h [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—]</formula><p>Figure <ref type="figure">2</ref>: Left: rules of Î£ h , fact set ğ¹ h , and a graphical representation thereof. Orange (grey) elements represent the rule body, black elements the rule head. Visualization of atoms: denotes h ("horizontal") and denotes v ("vertical"); we write [Ã—] for c ("ceiling") and</p><p>[Ã—] for f ("floor"). Right: Atomset ğ¼ h from Definition 8 -an infinite universal model of K h . Atomset Ä¨ h at the very right is infinite model of K h , which is not universal but satisfies exactly the same CQs.</p><p>Sketch of proof. The derivation D r given above is a restricted chase sequence. Clearly, no ğ›¼ (ğ¹, ğ‘…, ğœ‹) in D r retracts to ğ¹, so it remains to check that D r is fair. Indeed, if (ğ‘…, ğœ‹) is a trigger for some ğ¹ ğ‘– , then it is a trigger wrt some ğ‘… h ğ‘˜ that is necessarily satisfied</p><formula xml:id="formula_9">(at most in ğ‘ƒ h ğ‘˜+2 ). Thus (ğ‘…, ğœ‹) is satisfied in some ğ¹ ğ‘— âŠ‡ ğ‘ƒ h ğ‘˜+2 . â–¡</formula><p>As a result of the restricted chase, ğ¼ h is a universal model of K h . Now, we point out that for any ğ‘˜, ğ¶ h ğ‘˜+1 is a retract of ğ‘† h ğ‘˜ that is a core. Then we can use D r to build a derivation D c that relies upon those retractions. D c starts out like D r , but as soon as ğ‘† h 0 is obtained, we retract it to its core ğ¶ h 1 . Then, following D r 's course, D c proceeds to build ğ‘† h 1 that retracts to its core ğ¶ h 2 . . . As for D r , we note that D c is fair. Moreover, each retraction to a core is done a finite number of rule applications after the previous one: D c is thus a core chase sequence. Finally, we point out that every atomset in D c is a subset of some ğ‘† h ğ‘˜ , and has thus treewidth at most 2. Proposition 4. There is a core chase sequence for K h that is uniformly treewidth-bounded by 2.</p><p>However, all the core computations done in D c with the goal of producing a "leaner" result turn out to be futile when it comes to the aggregation: D * c = D * r = ğ¼ h contains an ğ‘› Ã—ğ‘› grid for any ğ‘›, and has thus unbounded treewidth. The next proposition even shows that K h admits no universal model of finite treewidth. For instance, the atomset Ä¨ h pictured in Figure <ref type="figure">2</ref> is a model of K h but it is not universal: it does not map to ğ¼ h , since it features an infinite v-path, while all v-paths contained in ğ¼ h are of finite length. Proposition 5. No universal model of K h has finite treewidth. Sketch of proof. Any universal model ğ‘ˆ of K h is homomorphically equivalent to ğ¼ h . This allows to show that, for any ğ‘› â‰¥ 1, ğ‘ˆ contains an ğ‘› Ã— ğ‘›-grid, hence tw(ğ‘ˆ ) â‰¥ ğ‘›. â–¡</p></div>
<div><head n="7">THE INFLATING ELEVATOR</head><p>We now present a knowledge base K v which does have a universal model with a treewidth of 1, while any (fair) core chase sequence for K v contains atomsets whose associated treewidths grow monotonically beyond any given bound.</p><p>Definition 9 (The Inflating Elevator KB). We let</p><formula xml:id="formula_10">K v = (ğ¹ v , Î£ v ) where Î£ v = {ğ‘… v 1 , ğ‘… v 2 , ğ‘… v 3 , ğ‘… v 4 , ğ‘… v 5 , ğ‘… v 6 , ğ‘… v 7</formula><p>} and ğ¹ v are as given in the upper part of Figure <ref type="figure">3</ref>.</p><p>We describe an atomset (shown on the left in Figure <ref type="figure" target="#fig_0">4</ref>) representing a universal model that can be obtained via the natural aggregation over the restricted chase or a core chase. We use the same naming convention for nulls as before.</p></div>
<div><head>Definition 10. Let terms(ğ¼</head><formula xml:id="formula_11">h ) = {ğ‘‹ ğ‘– ğ‘— | (ğ‘–, ğ‘—) âˆˆ N, ğ‘– -1 â‰¤ ğ‘— â‰¤ 2ğ‘–}.</formula><p>Then ğ¼ v consists of the following atoms for all ğ‘–, ğ‘— where all mentioned nulls are in terms(ğ¼ v ):</p><formula xml:id="formula_12">d(ğ‘‹ ğ‘– ğ‘— ) f(ğ‘‹ ğ‘– ğ‘— ) c(ğ‘‹ ğ‘– 2ğ‘– ) h(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘–+1 ğ‘— ) h(ğ‘‹ ğ‘– 2ğ‘– , ğ‘‹ ğ‘–+1 2ğ‘–+1 ) h(ğ‘‹ ğ‘– 2ğ‘– , ğ‘‹ ğ‘–+1 2ğ‘–+2 ) v(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘– ğ‘—+1 ) v(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘– ğ‘— ) for ğ‘– â‰¤ ğ‘— Proposition 6. ğ¼ v is a result of the restricted chase on K v .</formula><p>Sketch of proof. The claim can be shown inductively by assuming that rules without existential variables are prioritized and new nulls are created according to the following scheme:</p><p>â€¢ for every ğ‘– â‰¥ 1, ğ‘‹ ğ‘– 2ğ‘– -1 and ğ‘‹ ğ‘– 2ğ‘– are introduced as instances of ğ‘Œ â€² and ğ‘Œ â€²â€² through an application of Rule</p><formula xml:id="formula_13">ğ‘… v 1 with ğ‘‹ â†¦ â†’ ğ‘‹ ğ‘– -1 2ğ‘– -2 and ğ‘Œ â†¦ â†’ ğ‘‹ ğ‘– 2ğ‘– -2 . â€¢ for every ğ‘– â‰¥ 1, ğ‘‹ ğ‘–+1 ğ‘– is introduced as instance of ğ‘Œ â€² through an application of Rule ğ‘… v 2 with ğ‘‹ â†¦ â†’ ğ‘‹ ğ‘– ğ‘– -1 and ğ‘‹ â€² â†¦ â†’ ğ‘‹ ğ‘– ğ‘– . â€¢ every remaining ğ‘‹ ğ‘– ğ‘— âˆˆ terms(ğ¼ v ) with ğ‘– â‰¥ 1 is introduced as instance of ğ‘Œ â€² through an application of Rule ğ‘… v 3 with ğ‘‹ â†¦ â†’ ğ‘‹ ğ‘– -1 ğ‘— -1 , ğ‘‹ â€² â†¦ â†’ ğ‘‹ ğ‘– -1</formula><p>ğ‘— , and ğ‘Œ â†¦ â†’ ğ‘‹ ğ‘– ğ‘— -1 . Fairness follows from the fact that ğ¼ v satisfies all its triggers, as can be checked easily. â–¡</p><p>As a result of the restricted chase, ğ¼ v is a universal model of K v . As it turns out, it even contains another universal model of finite</p><formula xml:id="formula_14">{c(ğ‘‹ 0 0 ), d(ğ‘‹ 0 0 ), h(ğ‘‹ 0 0 , ğ‘‹ 1 0 ), f(ğ‘‹ 1 0 ) } (ğ¹ v ) c(ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘Œ ) â†’ âˆƒğ‘Œ â€² ğ‘Œ â€²â€² .v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ v(ğ‘Œ â€² , ğ‘Œ â€²â€² ) âˆ§ c(ğ‘Œ â€²â€² ) (ğ‘… v 1 ) v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ h(ğ‘‹ , ğ‘Œ ) â†’ âˆƒğ‘Œ â€² .v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ h(ğ‘‹ â€² , ğ‘Œ â€² ) (ğ‘… v 3 ) d(ğ‘‹ ) âˆ§ f(ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ â€² ) â†’ âˆƒğ‘Œ â€² .h(ğ‘‹ â€² , ğ‘Œ â€² ) âˆ§ f(ğ‘Œ â€² ) (ğ‘… v 2 ) c(ğ‘‹ ) â†’ d(ğ‘‹ ) (ğ‘… v 4 ) v(ğ‘‹ , ğ‘‹ â€² ) âˆ§ d(ğ‘‹ â€² ) â†’ d(ğ‘‹ ) (ğ‘… v 5 ) h(ğ‘‹ , ğ‘Œ ) âˆ§ d(ğ‘Œ ) âˆ§ f(ğ‘Œ ) â†’ f(ğ‘‹ ) âˆ§ v(ğ‘‹ , ğ‘‹ ) (ğ‘… v 6 ) c(ğ‘‹ ) âˆ§ h(ğ‘‹ , ğ‘Œ ) âˆ§ v(ğ‘Œ , ğ‘Œ â€² ) âˆ§ f(ğ‘Œ â€² ) â†’ h(ğ‘‹ , ğ‘Œ â€² ) (ğ‘… v 7 ) ğ¹ v ğ‘… v 1 ğ‘… v 2 ğ‘… v 3 ğ‘… v 4 ğ‘… v 5 ğ‘… v 6 ğ‘… v 7 A [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] [Ã—] A [Ã—] [Ã—] [Ã—] [Ã—] A [Ã—] [Ã—] [Ã—] A [Ã—] A [Ã—] [Ã—] A [Ã—] [Ã—] A [Ã—] [Ã—] [Ã—]</formula><p>Figure <ref type="figure">3</ref>: ğ¹ v and rules of Î£ v (top) and their graphical depictions (bottom). Orange (grey) elements represent the rule body and black elements the rule head. Atoms are encoded as follows: denotes h ("horizontal") and denotes v ("vertical"); we write</p><p>[Ã—] for c ("ceiling"),</p><p>[Ã—] for f ("floor"), and</p><p>[Ã—] for d ("done"). treewidth. This second universal model ğ¼ v * , also shown in Figure <ref type="figure" target="#fig_0">4</ref>, is given in the next definition. Definition 11. We define the atomset ğ¼ v * as the set of those atoms from ğ¼ v only containing variables of the form ğ‘‹ ğ‘– 2ğ‘– .</p><formula xml:id="formula_15">ğ¼ v ğ¼ v * ğ¼ v 1 ğ¼ v 2 ğ¼ v 3 ğ¼ v 4 ğ¼ v 5</formula><formula xml:id="formula_16">Proposition 7. ğ¼ v * is a universal model of K v .</formula><p>Proof. ğ¼ v * is a model of K v : it receives a homomorphism from ğ¹ v and satisfies all rules from Î£ v . It is universal, since the identity is a homomorphism from ğ¼ v * to ğ¼ v which is itself a universal model. â–¡</p><p>This implies that no finite universal model of K v can exist (as any such model would receive a homomorphism from ğ¼ v * and thus contain a h-cycle, thus not be homomorphically equivalent to ğ¼ v * ). We next describe a sequence ğ¼ v 0 , ğ¼ v 1 , . . . of subsets of ğ¼ v that exhibit increasing treewidths and will later be shown to occur as substructures in any core chase sequence of K v . Figure <ref type="figure" target="#fig_0">4</ref> depicts the first elements of that sequence. Definition 12. We define the sequence (ğ¼ v ğ‘› ) ğ‘›âˆˆN of atomsets by letting ğ¼ v 0 = ğ¹ v and, for any ğ‘› &gt; 0, obtaining ğ¼ v ğ‘› as the substructure of (3) For every core chase sequence (ğ¹ ğ‘– ) ğ‘– âˆˆN for K v , there is an unbounded monotonic function ğ‘“ : N â†’ N such that, for every ğ‘› âˆˆ N, ğ¼ v ğ‘“ (ğ‘›) is isomorphic to a subset of ğ¹ ğ‘› . (4) For every core chase sequence (ğ¹ ğ‘– ) ğ‘– âˆˆN for K v and any ğ‘š âˆˆ N exists a ğ‘˜ âˆˆ N such that tw(ğ¹ ğ‘– ) â‰¥ ğ‘š for all ğ‘– â‰¥ ğ‘˜.</p><formula xml:id="formula_17">ğ¼ v induced by terms(ğ¼ v ğ‘› ) = {ğ‘‹ ğ‘– 2ğ‘– | ğ‘– â‰¤ ğ‘› 2 } âˆª {ğ‘‹ ğ‘– ğ‘— | ğ‘– â‰¤ ğ‘›+1</formula><p>From these technical insights, we obtain the strong guarantee regarding the growth of the treewidth: Corollary 1. No core chase sequence for K v is recurringly or uniformly treewidth-bounded.</p><p>Recall that the steepening staircase example demonstrates that a bounded-treewidth chase sequence does not warrant the existence of a universal model of finite treewidth. This blocks the traditional approach for showing decidability of CQ entailment. However, we are still able to establish this desired result by other means, as demonstrated in the course of the next two sections.</p><p>More specifically, we show that CQ entailment is decidable for the class of KBs having a recurringly treewidth-bounded core chase sequence (forthcoming Theorem 2). To do so, we go through the following steps. Firstly, we resort to a weaker notion than universality, namely finite universality (Definition 13). We show that finitely universal models can play the same role as universal models when it comes to CQ entailment (Proposition 9). Secondly, we define a novel way to compute the result of a derivation, namely the robust aggregation of a derivation, and show that the robust aggregation of any fair derivation is a finitely universal model (Proposition 11). Finally, in Section 9, we show that the robust aggregation of a derivation having recurringly bounded treewidth has finite treewidth (Proposition 12), and conclude by adapting Courcelle's theorem to show that CQ entailment is decidable for KBs admitting a finitely universal model of finite treewidth (Theorem 1). In the following, we detail the employed notions and arguments laid out above. Definition 13 (Finite universality). An atomset ğ¼ is finitely universal for K if each finite subset of ğ¼ is universal for K. Defining Robust Aggregations. For non-monotonic derivations D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ , it may happen that an atom at is in some ğ¹ ğ‘– , but "disappears" at some later step ğ‘—. Yet, at will still belong to the natural aggregation D * . Intuitively, the natural aggregation generates atomsets that are "too big" (this is why they may not be models). We thus introduce a new type of aggregation, called robust aggregation, that, instead of merely combining all atomsets ğ¹ ğ‘– along the derivation, combines their collapsed versions obtained via preemptive applications of future simplifications ğœ ğ‘— along the derivation. Defining this result is not immediate, however, since a variable could be indefinitely re-mapped through simplifications along a derivation. Observe that, in the staircase example, the core chase maps ğ‘‹ 0 0 to ğ‘‹ 1 0 , then ğ‘‹ 1 0 to ğ‘‹ 2 0 , etc., and there is no way we can define the ultimate image of ğ‘‹ 0 0 unless we can force the simplification to stabilize at some point. This is the goal of the robust renaming, for which we assume a bijection rank of the variables X with N, and use the total ordering &lt; X on X defined by ğ‘‹ &lt; X ğ‘Œ iff rank(ğ‘‹ ) &lt; rank(ğ‘Œ ). Definition 14 (Robust renaming). Let ğ´ be an atomset and let ğœ be a retraction of ğ´. The robust renaming associated with ğœ is the substitution ğœŒ ğœ of vars(ğœ (ğ´)) that maps any variable ğ‘‹ of ğœ (ğ´) to the &lt; X -smallest variable of ğœ -1 (ğ‘‹ ). We let It is immediate that ğœŒ ğœ is an isomorphism from ğœ (ğ´) to ğœ ğœ (ğ´), and, for any variable ğ‘‹ in ğ´, ğœ ğœ (ğ‘‹ ) is a constant or ğœŒ ğœ (ğ‘‹ ) â‰¤ X ğ‘‹ . Let us now inductively apply those robust renamings along a derivation. Definition 15 (Robust seqence). Let D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ be a derivation. The robust sequence associated with D is the sequence of atomsets (ğº ğ‘– ) ğ‘– âˆˆâ„‘ defined inductively by (see Figure <ref type="figure" target="#fig_2">5</ref> for induction step):</p><formula xml:id="formula_18">ğœ ğœ = ğœŒ ğœ â€¢ ğœ. ğ´ ğ‘– -1 ğ¹ ğ‘– -1 ğ´ ğ‘– ğ¹ ğ‘– ğº ğ‘– -1 ğº ğ‘– ğ´ â€² ğ‘– ğ¹ â€² ğ‘– ğœŒ ğ‘– -1 ğœŒ ğ‘– ğœ ğ‘– -1 ğœ ğ‘– ğœŒ ğ‘– -1 ğœŒ ğ‘– -1 ğœ â€² ğ‘– ğœŒ ğœ â€² ğ‘– ğœ ğ‘– ğœ ğ‘– homomorphism isomorphism rule application</formula><p>â€¢ With ğ´ 0 = ğ¹ , ğ¹ 0 = ğœ 0 (ğ´ 0 ), and ğœŒ 0 = ğœŒ ğœ 0 , we define ğº 0 = ğœŒ 0 (ğ¹ 0 );</p><formula xml:id="formula_19">â€¢ âˆ€ğ‘– âˆˆ â„‘ with ğ‘– &gt; 0, if ğ¹ ğ‘– -1 = ğœ ğ‘– -1 (ğ´ ğ‘– -1 ), ğ´ ğ‘– = ğ›¼ (ğ¹ ğ‘– -1 , tr), ğ¹ ğ‘– =</formula><p>ğœ ğ‘– (ğ´ ğ‘– ) and ğº ğ‘– -1 = ğœŒ ğ‘– -1 (ğ¹ ğ‘– -1 ) (ğ¹ ğ‘– -1 and ğº ğ‘– -1 being isomorphic), we build ğº ğ‘– and an isomorphism ğœŒ ğ‘– from ğ¹ ğ‘– to ğº ğ‘– as follows:</p><formula xml:id="formula_20">-let ğ´ â€² ğ‘– = ğœŒ ğ‘– -1 (ğ´ ğ‘– ) (see that ğ´ â€² ğ‘– = ğ›¼ (ğº ğ‘– -1 , ğœŒ ğ‘– -1 (tr)))</formula><p>, with the same fresh variables as in ğ›¼ (ğ¹ ğ‘– -1 , tr)) and</p><formula xml:id="formula_21">ğ¹ â€² ğ‘– = ğœŒ ğ‘– -1 (ğ¹ ğ‘– ); -then ğœ â€² ğ‘– = ğœŒ ğ‘– -1 â€¢ ğœ ğ‘– â€¢ ğœŒ -1 ğ‘– -1 is a retraction such that ğœ â€² ğ‘– (ğ´ â€² ğ‘– ) = ğ¹ â€² ğ‘– ; -we define ğº ğ‘– = ğœŒ ğœ â€² ğ‘– (ğ¹ â€² ğ‘– ), with ğœŒ ğœ â€² ğ‘– the robust renaming associated with ğœ â€² ğ‘– and ğœŒ ğ‘– = ğœŒ ğœ â€² ğ‘– â€¢ ğœŒ ğ‘– -1 an isomorphism from ğ¹ ğ‘– to ğº ğ‘– ; -furthermore, we denote by ğœ ğ‘– = ğœ ğœ â€² ğ‘– = ğœŒ ğœ â€² ğ‘– â€¢ğœ â€² ğ‘– the homomorphism from ğ´ â€²</formula><p>ğ‘– to ğº ğ‘– . See that ğœ ğ‘– also maps ğº ğ‘– -1 âŠ† ğ´ â€² ğ‘– to ğº ğ‘– . Note that (ğº ğ‘– ) is not a derivation, since the ğœ ğ‘– from ğ´ â€² ğ‘– to ğº ğ‘– are not endomorphisms. However, every ğº ğ‘– is isomorphic to ğ¹ ğ‘– , and we show that variables are finitely renamed along this sequence. Proposition 10. Let (ğº ğ‘– ) ğ‘– âˆˆâ„‘ be an associated robust sequence. For ğ‘–, ğ‘— âˆˆ â„‘ with ğ‘– &lt; ğ‘—, let Ï„ ğ‘— ğ‘– = ğœ ğ‘— â€¢ â€¢ â€¢ â€¢ â€¢ ğœ ğ‘–+1 denote the composition of all ğœ â„“ between ğº ğ‘– and ğº ğ‘— . Then, for any ğ‘‹ âˆˆ vars(ğº ğ‘– ), there is ğ‘— âˆˆ â„‘ with ğ‘— &gt; ğ‘– such that Ï„ ğ‘— ğ‘– (ğ‘‹ ) = ğ‘Œ âˆˆ terms(ğº ğ‘— ) and for all ğ‘˜ âˆˆ â„‘ with ğ‘˜ &gt; ğ‘—, Ï„ğ‘˜ ğ‘— (ğ‘Œ ) = ğ‘Œ (i.e., ğ‘Œ is stable from ğº ğ‘— on). We let Ï„ (ğ‘‹ ) = ğ‘Œ . Proof. Let ğ‘‹ âˆˆ vars(ğº ğ‘– ), then ğœ ğ‘–+1 (ğ‘‹ ) = ğœ ğœ â€² ğ‘–+1 (ğ‘‹ ) â‰¤ X ğ‘‹. Consider some arbitrary ğ‘— âˆˆ â„‘ with ğ‘— &gt; ğ‘–. Among the homomorphisms ğœ â„“ that Ï„ ğ‘— ğ‘– is composed of, there can be at most rank X (ğ‘‹ ) many of them that are effectively decreasing (causing Ï„â„“-1</p><formula xml:id="formula_22">ğ‘– (ğ‘‹ ) &lt; X Ï„â„“ ğ‘– (ğ‘‹ )). â–¡</formula><p>We now use the Ï„ (ğº ğ‘– ) to define the robust aggregation. Note that, contrary to (ğ¹ ğ‘– ) or (ğº ğ‘– ), the sequence ( Ï„ (ğº ğ‘– )) is monotonic. Definition 16 (Robust aggregation). Given a derivation D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ and its associated robust sequence (ğº ğ‘– ) ğ‘– âˆˆâ„‘ , the robust aggregation of D is the (possibly infinite) atomset D âŠ› = ğ‘– âˆˆâ„‘ Ï„ (ğº ğ‘– ).</p><p>Semantic Properties of Robust Aggregations. The steepening staircase shows that the robust aggregation of a derivation is not always universal. Indeed, consider the KB K h (from Definition 7) and let &lt; X be an order on the variables with ğ‘— &lt; ğ‘˜ â‡’ ğ‘‹ ğ‘– ğ‘— &lt; X ğ‘‹ ğ‘– ğ‘˜ . The core chase on K h begins building the first step ğ‘† h 0 of ğ¼ h , and all simplifications are the identity until done. Now, the first proper retraction maps ğ‘‹ 0 0 to ğ‘‹ 1 0 and ğ‘‹ 0 1 to ğ‘‹ 1 1 , so the robust renaming generates ğº ğ‘– 1 , which is isomorphic to the column ğ¶ h 1 , but its variables are named (from bottom to top) ğ‘‹ 0 0 and ğ‘‹ 0 1 . Likewise, from successive proper retraction steps, we obtain ğº ğ‘– ğ‘— isomorphic to ğ¶ h ğ‘— but with variables named ğ‘‹ 0 0 , ğ‘‹ 0 1 , ğ‘‹ 1 2 , . . . , ğ‘‹ ğ‘— ğ‘—+1 . Note that Ï„ (ğº ğ‘– ğ‘— ) = ğº ğ‘– ğ‘— holds: every variable is stable since subsequent re-mappings would have to be within the same row, yet all variables therein are &lt; X -greater. Then, the robust aggregation D âŠ› is isomorphic to the infinite column Ä¨ h , with variables named ğ‘‹ 0 0 , ğ‘‹ 0 1 , ğ‘‹ 1 2 , . . . , ğ‘‹ ğ‘— ğ‘—+1 , . . . , which is not universal, but is a finitely universal model, as stated below. Proposition 11. Let D be a derivation from K. Then (1) D âŠ› is finitely universal for K; and (2) if D is fair, D âŠ› is a model of K.</p><p>To prove this proposition, we rely on the next lemma, which states that any finite part of D âŠ› is "stably present" from a certain element on in the robust sequence associated with D.</p><p>Lemma 1. Let D be a derivation and let (ğº ğ‘– ) ğ‘– âˆˆâ„‘ be the robust sequence associated with D. For any finite subset ğ´ of D âŠ› , there is some ğ‘˜ âˆˆ â„‘ such that ğ´ âŠ† ğº ğ‘Ÿ for every ğ‘Ÿ âˆˆ â„‘ with ğ‘Ÿ â‰¥ ğ‘˜. Sketch of proof. See that (i) the Ï„ (ğº ğ‘– ) form a monotonic sequence and then, thanks to Proposition 10, that (ii) for every Ï„ (ğº ğ‘– ), there exists ğ‘˜ âˆˆ â„‘ such that Ï„ (ğº ğ‘– ) âŠ† ğº ğ‘Ÿ for every ğ‘Ÿ â‰¥ ğ‘˜. Thanks to (i), there is some ğ‘– with ğ´ âŠ† Ï„ (ğº ğ‘– ) and we conclude with (ii). â–¡</p><p>Proof of Proposition 11.</p><p>(1) Let ğ‘€ be an arbitrary model of K, and let ğ¼ be be any finite subset of D âŠ› . By Lemma 1, there is some ğ‘˜ such that ğ¼ âŠ† ğº ğ‘˜ . Now ğº ğ‘˜ is isomorphic to ğ¹ ğ‘˜ , which is universal (from Proposition 1), so ğº ğ‘˜ (hence also ğ¼ ) maps to ğ‘€.</p><p>(2) Let D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ be a fair derivation from (ğ¹, Î£) and (ğº ğ‘– ) ğ‘– âˆˆâ„‘ be its associated robust sequence. Since ğœ 0 maps ğ¹ to ğº 0 , Ï„ â€¢ğœ 0 maps ğ¹ to D âŠ› , thus D âŠ› is a model of ğ¹ . Consider now any trigger tr for D âŠ› . By Lemma 1, there exists some ğ‘— âˆˆ â„‘ such that tr is a trigger for ğº ğ‘Ÿ for any ğ‘Ÿ âˆˆ â„‘ with ğ‘Ÿ â‰¥ ğ‘—. Since ğœŒ ğ‘Ÿ is an isomorphism from ğ¹ ğ‘Ÿ to ğº ğ‘Ÿ , we obtain that ğœŒ -1 ğ‘Ÿ (tr) is a trigger for ğ¹ ğ‘Ÿ . Since D is fair, there exists some ğ‘  âˆˆ â„‘ with ğ‘  â‰¥ ğ‘Ÿ such that the trigger Ïƒğ‘  </p><formula xml:id="formula_23">â€¢ğœŒ -1 ğ‘Ÿ = Ï„ğ‘  ğ‘Ÿ . Then ğœŒ ğ‘  â€¢ Ïƒğ‘  ğ‘Ÿ â€¢ğœŒ -1 ğ‘Ÿ (tr) = Ï„ğ‘  ğ‘Ÿ (tr)</formula><p>= tr is a trigger for ğº ğ‘  satisfied in ğº ğ‘  , and thus satisfied in D âŠ› . â–¡</p><p>Hence, both natural and robust aggregations indicate whether a CQ is entailed by a KB. Yet, natural aggregation provides an instance that is universal but not always a model, while the more complex robust aggregation provides a model which might be only finitely universal. We show next how the latter case can still be utilized towards proving Theorem 2.</p></div>
<div><head n="9">DECIDABILITY THROUGH TREEWIDTH</head><p>The steepening staircase example shows that the natural aggregation of the core chase may have infinite treewidth even if the chase sequence is uniformly treewidth-bounded. The next proposition provides two results: Firstly, the natural aggregation is indeed treewidth-preserving for monotonic derivations, generalizing a result by Baget et al. <ref type="bibr" target="#b2">[3]</ref> for the restricted chase. Secondly (and more importantly), robust aggregation is superior to natural aggregation in that treewidth preservation can be shown to hold even for non-monotonic chases. Both results rely upon the compactness of treewidth <ref type="bibr" target="#b17">[18]</ref>: if ğ¹ is an atomset where tw(ğ¹ â€² ) â‰¤ ğ‘˜ holds for every finite subset ğ¹ â€² âŠ† ğ¹ , then tw(ğ¹ ) â‰¤ ğ‘˜. Proposition 12. For any derivation D that is recurringly treewidth-bounded by some integer ğ‘˜, the following hold:</p><p>(1) D's natural aggregation D * has treewidth â‰¤ğ‘˜, if D is monotonic.</p><p>(2) D's robust aggregation D âŠ› has treewidth â‰¤ğ‘˜.</p><p>Proof. Let ğ¼ be a finite subset of D * (for proof of (1)) or D âŠ› (for proof of (2)). There is some ğ‘ âˆˆ â„‘ such that, âˆ€ğ‘Ÿ â‰¥ ğ‘ âˆˆ â„‘, we can exhibit some ğ¼ ğ‘Ÿ isomorphic to ğ¹ ğ‘Ÿ with ğ¼ âŠ† ğ¼ ğ‘Ÿ . To prove (1), D being monotonic, we can define ğ¼ ğ‘Ÿ = ğ¹ ğ‘Ÿ . To prove (2), we rely upon Lemma 1 and define ğ¼ ğ‘Ÿ = ğº ğ‘Ÿ . Since D is recurrently treewidth-bounded, there is some ğ‘  â‰¥ ğ‘ âˆˆ â„‘ such that tw(ğ¹ ğ‘  ) â‰¤ ğ‘˜. Thus tw(ğ¼ ) â‰¤ tw(ğ¼ ğ‘  ) = tw(ğ¹ ğ‘  ) â‰¤ ğ‘˜, and we conclude, thanks to compactness of treewidth, that D * or D âŠ› has treewidth â‰¤ ğ‘˜. â–¡</p><p>The last missing insight is that the existence of treewidth-bounded finitely universal models suffices to establish decidability of CQ entailment. <ref type="foot" target="#foot_2">3</ref> We obtain this result via a mild generalization of respective statements for universal models <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b10">11]</ref>. Theorem 1. Let â„­ be a class of knowledge bases for which every K = (ğ¹, Î£) âˆˆ â„­ has a model ğ¼ that is finitely universal for K and that satisfies ğ‘¡ğ‘¤ (ğ¼ ) âˆˆ N. Then CQ entailment for â„­ is decidable. Sketch of proof. K |= ğ‘„ can be detected in finite time due to the completeness of first-order logic. K Ì¸ |= ğ‘„ can be detected by incrementing ğ‘˜ stepwise and checking if K âˆ§ (Â¬ğ‘„) has a model of treewidth ğ‘˜, which is decidable. â–¡</p><p>We finally obtain our main result, which follows from Propositions 11 and 12, and Theorem 1: Theorem 2. CQ entailment is decidable for the class of KBs having a recurringly treewidth-bounded core chase sequence.</p><p>We end this section by using this decidability result to define a new class of rulesets and discussing its relationship with existing abstract decidable classes. As usual in the existential rule setting, the considered property can be abstracted from the underlying database, obtaining a new fragment of existential rules that -thanks to Theorem 2 -warrants decidable CQ entailment and properly subsumes and reconciles other classes with that property. <ref type="foot" target="#foot_3">4</ref>Definition 17. A ruleset Î£ is called core-bts, if for every finite atomset ğ¹ , there exists a core chase sequence for the KB (ğ¹, Î£), whose treewidth is recurringly bounded by some ğ‘˜ âˆˆ N. Proposition 13. CQ entailment is decidable for any ruleset that is core-bts. Moreover, core-bts subsumes both finite expansion sets (fes) and bounded treewidth sets (bts), which are mutually incomparable.</p></div>
<div><head n="10">CONCLUSION AND FUTURE WORK</head><p>In this paper, we have investigated ways of exploiting properties of the core chase in non-terminating settings, with the main goal of ensuring decidability of CQ entailment based on treewidth guarantees for the atomsets occurring in chase sequence.</p><p>On the negative side, we found that, contrary to plausible expectations, the existence of a treewidth-bounded core-chase sequence does not coincide with the existence of a treewidth-bounded universal model, nor is there a subsumption in one of the two directions: On one hand, we exhibited a KB K h admitting a core-chase sequence the treewidth of which is uniformly bounded by 2, while all its universal models are of unbounded treewidth. On the other hand, we described a KB K v admitting an infinite universal model of treewidth 1, while all corresponding core chase sequences consist of structures of ever increasing treewidth.</p><p>On the positive side, we showed how a given core chase sequence can be robustly aggregated into a (potentially infinite) atomset that is a model of the underlying knowledge base, while satisfying exactly those CQs entailed by it. We also showed that for any such core chase sequence that is recurringly treewidth-bounded, the aggregated atomset will be of finite treewidth. Together, these findings establish decidability of CQ entailment for all knowledge bases with a recurringly treewidth-bounded core chase. Abstracting from concrete databases, this yields a novel, very general abstract class of recurringly treewidth-bounded rulesets, ensuring decidability of CQ entailment and subsuming the two previously known incomparable classes fes and bts.</p><p>Future work on the topic will clarify under what circumstances the robust aggregation produces cores (according to some of the many existing non-equivalent definitions of cores in the infinite <ref type="bibr" target="#b3">[4]</ref>). Also, we will investigate the relationship of our approach to the stable chase introduced by Carral et al. <ref type="bibr" target="#b7">[8]</ref>, which also produces (not necessarily universal) models satisfying exactly the entailed CQs. Note that the stable chase is quite elaborate and not subsumed by our current generic definition of derivation: the computation occasionally "jumps back" to earlier sequence elements and starts rebuilding the sequence from there.</p></div>
<div><head>A PROOFS OF SECTION 3</head><p>The following appendices are devoted to the complete proofs that are missing or only sketched in the paper. Fact 3. If tr is a trigger for ğ¹ , ğœ‡ maps ğ¹ to ğ¼ and ğ¼ satisfies ğœ‡ (tr), then there is ğœ‡ â€² (compatible with ğœ‡) that maps ğ›¼ (ğ¹, tr) to ğ¼ . Lemma 2. For every fair derivation D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ , there exists a fair monotonic derivation D ğ‘šğ‘œğ‘› = (ğº ğ‘– ) ğ‘– âˆˆâ„‘ such that for every ğ‘– âˆˆ â„‘, there is a retraction from ğº ğ‘– to ğ¹ ğ‘– .</p><p>Proof. From D = (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ , let us first build inductively a derivation D ğ‘šğ‘œğ‘› = (ğº ğ‘– ) ğ‘– âˆˆâ„‘ such that ğº 0 = ğ´ 0 = ğ¹ , ğ¹ 0 = ğœ 0 (ğ¹ 0 ) and âˆ€ğ‘– &gt; 0 âˆˆ â„‘, ğ¹ ğ‘– = ğœ ğ‘– (ğ´ ğ‘– ) with ğ´ ğ‘– = ğ›¼ (ğ¹ ğ‘– -1 , tr ğ‘– ), we can define ğº ğ‘– = ğ›¼ (ğº ğ‘– -1 , tr ğ‘– ). See that ğœ 0 is a retraction from ğº 0 to ğ¹ 0 , and so the trigger tr 1 is also a trigger in ğº 0 , allowing us to build ğº 1 . Now we claim that ğœ 0 is a retraction from ğº 1 to ğ´ 1 , and thus ğœ 1 â€¢ ğœ 0 is a retraction from ğº 1 to ğ¹ 1 . An induction based upon these remarks shows that for ğ‘– âˆˆ â„‘, Ïƒğ‘– = ğœ ğ‘–  (ğ‘–,ğ‘— ) . We make the following observations (which hold for all endomorphisms on ğ¼ h ):</p><p>(1) â„ ğ‘¦ (ğ‘–, 0) = 0 since f holds precisely for all nulls ğ‘‹ ğ‘– 0 .</p><p>(2) â„ ğ‘¦ (ğ‘–, ğ‘—) = ğ‘—, inductively with (1) as base case and the observation that â„ must preserve the length of incoming v-paths rooted in some f. (3) â„ ğ‘¥ (ğ‘–, ğ‘—) = â„ ğ‘¥ (ğ‘–, ğ‘— +1), since this is the only way for â„ to preserve the v-atoms. (4) â„ ğ‘¥ (ğ‘–, ğ‘—) = â„ ğ‘¥ (ğ‘–, ğ‘˜), via iteration of (3).</p><p>(5) â„ ğ‘¥ (ğ‘–, ğ‘—) â‰¥ ğ‘–, due to (2) and the fact that ğ‘‹ ğ‘– ğ‘— does not exist for ğ‘— &gt; ğ‘– + 1. (6) â„ ğ‘¥ (ğ‘– + 1, ğ‘—) = â„ ğ‘¥ (ğ‘–, ğ‘—) or â„ ğ‘¥ (ğ‘– + 1, ğ‘—) = â„ ğ‘¥ (ğ‘–, ğ‘—) + 1, since this is the only way for â„ to preserve the h-atoms. (7) â„ ğ‘¦ (ğ‘– + 1, ğ‘—) = â„ ğ‘¦ (ğ‘–, ğ‘—) since this is the only way for â„ to preserve the h-atoms. (8) There are ğ‘˜, â„“ âˆˆ N such that â„ ğ‘¥ (ğ‘–, ğ‘—) = ğ‘– + â„“ for all ğ‘– &gt; ğ‘˜. This is a consequence of ( <ref type="formula">5</ref>) and ( <ref type="formula">6</ref>). ( <ref type="formula">9</ref>) There is a ğ‘˜ âˆˆ N such that the restriction of â„ to the ğ‘‹ ğ‘– ğ‘— with ğ‘– &gt; ğ‘˜ is injective. Follows from <ref type="bibr" target="#b7">(8)</ref>, for the same ğ‘˜, and (2). If we now let ğ¼ h -be ğ¼ h restricted to terms ğ‘‹ ğ‘– ğ‘— with ğ‘– &gt; ğ‘˜, we obtain that â„ is an isomorphism from</p><formula xml:id="formula_24">ğ¼ h -to â„(ğ¼ h -), i.e., ğ¼ h - â„(ğ¼ h -). Since â„ = â„ 2 â€¢ â„ 1 , this means that â„ 1 must be an isomorphism from ğ¼ h -to â„ 1 (ğ¼ h -) and â„ 2 must be an isomorphism from â„ 1 (ğ¼ h -) to â„ 2 (â„ 1 (ğ¼ h -)) = â„(ğ¼ h -). Therefore, ğ‘¡ğ‘¤ (ğ¼ h -) = ğ‘¡ğ‘¤ (â„ 1 (ğ¼ h -)) = ğ‘¡ğ‘¤ (â„ 2 (â„ 1 (ğ¼ h -)</formula><p>)) (*). Now, for any given ğ‘› âˆˆ N with ğ‘› &gt; ğ‘˜, take T ğ‘›Ã—ğ‘› = {ğ‘‹ ğ‘– ğ‘— | ğ‘› + 1 â‰¤ ğ‘– â‰¤ 2ğ‘› and 0 â‰¤ ğ‘– â‰¤ ğ‘› -1} âŠ† terms(ğ¼ h ). Consequently, T ğ‘›Ã—ğ‘› witnesses that ğ¼ h -contains a ğ‘› Ã— ğ‘› grid. Yet, as ğ‘› can be chosen arbitrarily large, ğ¼ h -contains grids of arbitrary size and thus cannot have finite treewidth, i.e., ğ‘¡ğ‘¤ (ğ¼ h -) âˆ‰ N (**). From these insights, we can conclude</p><formula xml:id="formula_25">ğ¼ h -âŠ† ğ¼ h =â‡’ â„ 1 (ğ¼ h -) âŠ† â„ 1 (ğ¼ h ) âŠ† ğ‘ˆ Fact 1 =â‡’ ğ‘¡ğ‘¤ (â„ 1 (ğ¼ h -)) â‰¤ ğ‘¡ğ‘¤ (ğ‘ˆ ) (*) =â‡’ ğ‘¡ğ‘¤ (ğ¼ h -) â‰¤ ğ‘¡ğ‘¤ (ğ‘ˆ ) (**)</formula><p>=â‡’ ğ‘¡ğ‘¤ (ğ‘ˆ ) âˆ‰ N.</p></div>
<div><head>â–¡</head><p>C PROOFS OF SECTION 7</p><p>Proposition 8. The following hold:</p><p>(1) Every ğ¼ v ğ‘› is a core. (2) ğ¼ v ğ‘› has a treewidth of at least âŒˆğ‘›/3âŒ‰ + 1.</p><p>(3) For every core chase sequence (ğ¹ ğ‘– ) ğ‘– âˆˆN for K v , there is an unbounded monotonic function ğ‘“ : N â†’ N such that, for every ğ‘› âˆˆ N, ğ¼ v ğ‘“ (ğ‘›) is isomorphic to a subset of ğ¹ ğ‘› . (4) For every core chase sequence (ğ¹ ğ‘– ) ğ‘– âˆˆN for K v and any ğ‘š âˆˆ N exists a ğ‘˜ âˆˆ N such that tw(ğ¹ ğ‘– ) â‰¥ ğ‘š for all ğ‘– â‰¥ ğ‘˜.</p><p>Proof. We show these claims consecutively. (1) It is straightforward to check that ğ¼ v 0 is a core. To show that ğ¼ v ğ‘› is a core for every ğ‘› &gt; 0, pick an arbitrary retraction ğœ of ğ¼ v ğ‘› . Toward showing that ğœ is the identity, first note that it must be column-preserving (i.e., satisfy ğœ (ğ‘‹ ğ‘– â„“ ) = ğ‘‹ ğ‘– â„“ â€² ), since for any two ğ‘‹ ğ‘– ğ‘˜ , ğ‘‹ ğ‘— â„“ âˆˆ Î” v ğ‘› hold: â€¢ they are connected by a v-path exactly if ğ‘– = ğ‘—, â€¢ if there is an h connection from the former to the latter, then ğ‘– + 1 = ğ‘—,</p><p>â€¢ if ğ‘– + 1 = ğ‘—, then there are ğ‘˜ â€² and â„“ â€² satisfying h(ğ‘‹ ğ‘– ğ‘˜ â€² , ğ‘‹ ğ‘— â„“ â€² ) âˆˆ ğ¼ v ğ‘› . Yet then, for every ğ‘‹ ğ‘– ğ‘˜ âˆˆ Î” v ğ‘› , the corresponding column (the substructure of ğ¼ v ğ‘› induced by all ğ‘‹ ğ‘— â„“ with ğ‘— = ğ‘–) has an retraction obtained by restricting ğœ accordingly. Yet, each of these column-wise retractions must map the unique elements carrying f and c to themselves, which also forces all other elements (on the intermediate directed v-path) to be identically mapped. Consequently, every row-wise retraction must be the identity function. Yet then, ğœ as a whole must be the identity as well.</p><p>(2) This claim is a consequence of Fact 2, since, for every ğ‘›, the elements ğ‘‹ ğ‘– ğ‘˜ with âŒŠ2ğ‘›/3âŒ‹ + 1 â‰¤ ğ‘– â‰¤ ğ‘› + 1 and ğ‘› â‰¤ ğ‘˜ â‰¤ âŒˆ4ğ‘›/3âŒ‰ witness that ğ¼ v ğ‘› contains a (âŒŠğ‘›/3âŒ‹ + 1) Ã— (âŒŠğ‘›/3âŒ‹ + 1)-grid. (3) Without loss of generality, we assume the considered core chase employs the same naming scheme as ğ¼ v . Therefore, any intermediate atomset of the considered chase can be described by a subset of ğ¼ v . We first observe that ğ¼ v 0 = ğ¹ v , thus the claim is satisfied for ğ‘› = 0 once we set ğ‘“ (0) = 0. We proceed iteratively for larger ğ‘›. For any subsequent ğ‘›, we can assume that ğ¹ ğ‘›-1 contains some ğ¼ v ğ‘š . Therefore, the only interesting case is if, upon producing ğ¹ ğ‘› , nulls of ğ¹ ğ‘›-1 are removed through the non-trivial retraction ğœ ğ‘› . Among the nulls removed, let ğ‘‹ ğ‘– ğ‘— be the one with maximal ğ‘— and (among all these) the one with minimal ğ‘–. By construction (observing ğ¼ v ), removal of nulls will always simultaneously affect all nulls in a row, leaving behind only those of the form ğ‘‹ ğ‘˜ 2ğ‘˜ . Therefore, we obtain ğ‘– = âŒŠ ğ‘—/2âŒ‹ + 1. Also, by maximality of ğ‘— and the fact that there are no rowdecreasing v-atoms, we know that ğœ ğ‘› (ğ‘‹ ğ‘– ğ‘— ) = ğ‘‹ ğ‘– ğ‘—+1 (note that retractions must be column-preserving, as argued before). Then, for ğœ ğ‘› to be a retraction, we require h(ğ‘‹ ğ‘– -1 2âŒŠ ğ‘—/2âŒ‹ , ğ‘‹ ğ‘– ğ‘—+1 ) âˆˆ ğ¼ v ğ‘›-1 . Yet, as row-increasing h-edges can only be the consequence of a (potentially iterated) prior application of ğ‘… v 7 , the atom f(ğ‘‹ ğ‘– ğ‘—+1 ) must occur in some atomset preceding ğ¼ v</p><p>ğ‘› . Yet, this can only be the consequence of the iterated application of ğ‘… v 7 propagating f from "right to left", starting from f(ğ‘‹ ğ‘—+2 ğ‘—+1 ), d(ğ‘‹ ğ‘—+2 ğ‘—+1 ). The latter atom must, in turn have been created through iterated application of ğ‘… v 5 , propagating d "top-down" starting from d(ğ‘‹ ğ‘—+2 2ğ‘—+4 ) which must have been created through application of ğ‘… v 4 to c(ğ‘‹ ğ‘—+2 <ref type="table">2ğ‘—+4</ref> ). Yet, the only way to produce the latter is through ğ‘… v 1 following iterated application of ğ‘… v 2 preceded by an application of ğ‘… v 3 to d(ğ‘‹ ğ‘—+1 ğ‘— ), f(ğ‘‹ ğ‘—+1 ğ‘— ), and v(ğ‘‹ ğ‘—+1 ğ‘— , ğ‘‹ ğ‘—+1 ğ‘—+1 ). This argument can then be repeated for columns further left, leading to the insight that removal of ğ‘‹ ğ‘– ğ‘— requires that all facts from ğ¼ v ğ‘—+1 must have previously existed in the derivation. Among those, the facts involving nulls ğ‘‹ ğ‘˜ â„“ with â„“ &gt; ğ‘—, cannot have been removed by our maximality assumption. The remaining facts of ğ¼ v ğ‘—+1 are indefinitely exempt from removal because the participating nulls are column-wise unique wrt carrying c. We can therefore conclude that upon removal of ğ‘‹ ğ‘– ğ‘— toward the creation of ğ¹ ğ‘› , the latter must contain ğ¼ v ğ‘—+1 . Finally, we observe that, as an indirect consequence of fairness, every ğ‘‹ ğ‘– ğ‘— with ğ‘— â‰  2ğ‘– will be removed in some derivation step, leading to the consequence that ever growing elements ğ¼ v ğ‘—+1 will come into operation. (4) This claim is a direct consequence of Item 2 and Item 3, given monotonicity of treewidth (Fact 1). </p><formula xml:id="formula_26">â–¡ ğ¹ ğ¹ 0 ğ´ 1 ğ¹ 1 ğº 0 ğº 1 ğ´ â€² 1 ğ¹ â€² 1 ğ´ 2 ğ¹ 2 ğº 2 ğ´ â€² 2 ğ¹ â€² 2 ğ´ 2 ğ¹ 2 ğº 3 ğ´ â€² 3 ğ¹ â€² 3 ğœŒ 0 ğœŒ 1 ğœ 0 ğœ 1 ğœŒ 0 ğœŒ 0 ğœ â€² 1 ğœŒ ğœ â€² 1 ğœ 1 ğœ 1 ğœŒ 2 ğœ 2 ğœŒ 1 ğœŒ 1 ğœ â€² 2 ğœŒ ğœ â€² 2 ğœ 2 ğœ 2 ğœŒ 3 ğœ 3 ğœŒ 2 ğœŒ 2 ğœ â€² 3 ğœŒ ğœ â€² 3 ğœ 3 ğœ 3</formula></div>
<div><head>D PROOFS OF SECTION 8</head><p>Lemma 1. Let (ğº ğ‘– ) ğ‘– âˆˆâ„‘ be the robust sequence associated with a derivation D. If ğ´ is a finite subset of D âŠ› , then there exists some ğ‘˜ âˆˆ â„‘ such that, for every ğ‘Ÿ â‰¥ ğ‘˜ âŠ† â„‘, ğ´ âŠ† ğº ğ‘Ÿ .</p><p>Proof. We first prove (i) for every ğ‘– &gt; 0 âˆˆ â„‘, Ï„ (ğº ğ‘– -1 ) âŠ† Ï„ (ğº ğ‘– ). Indeed, since ğœ ğ‘– is a homomorphism from ğº ğ‘– -1 to ğº ğ‘– , then ğœ ğ‘– (ğº ğ‘– -1 ) âŠ† ğº ğ‘– and thus for any ğ‘— &gt; ğ‘– âˆˆ â„‘, Ï„ ğ‘— ğ‘– (ğœ ğ‘– (ğº ğ‘— -1 )) âŠ† Ï„ ğ‘— ğ‘– (ğº ğ‘– ), meaning Ï„ (ğº ğ‘– -1 ) âŠ† Ï„ (ğº ğ‘– ).</p><p>Then we prove (ii) for every Ï„ (ğº ğ‘— ), there exists some ğ‘˜ â‰¥ ğ‘— such that for every ğ‘Ÿ â‰¥ ğ‘˜, Ï„ (ğº ğ‘— ) âŠ† ğº ğ‘Ÿ . For every variable ğ‘‹ in ğº ğ‘— , there is some ğ‘˜ ğ‘‹ âˆˆ â„‘ such that Ï„ (ğ‘‹ ) = ğœ ğ‘˜ ğ‘‹ ğ‘— (ğ‘‹ ) is stable in all atomsets after ğº ğ‘˜ ğ‘‹ (Proposition 10). If we take ğ‘˜ = max ğ‘‹ âˆˆvars (ğº ğ‘— ) ğ‘˜ ğ‘‹ , then for every ğ‘Ÿ â‰¥ ğ‘˜, ğœ ğ‘Ÿ ğ‘— = ğœ ğ‘Ÿ ğ‘˜ â€¢ ğœ ğ‘˜ ğ‘— = Ï„ is a homomorphism from ğº ğ‘— to ğº ğ‘Ÿ , and thus Ï„ (ğº ğ‘— ) âŠ† ğº ğ‘Ÿ .</p><p>Finally, since ğ´ is finite and the successive Ï„ (ğº ğ‘– ) form a monotonic sequence (see (i)), there exists ğ‘— âˆˆ â„‘ such that ğ´ âŠ† Ï„ (ğº ğ‘— ). Then (ii) there exists ğ‘˜ â‰¥ ğ‘— such that for every ğ‘Ÿ â‰¥ ğ‘˜, Ï„ (ğº ğ‘— ) âŠ† ğº ğ‘Ÿ and thus ğ´ âŠ† ğº ğ‘Ÿ . â–¡</p></div>
<div><head>E PROOFS OF SECTION 9</head><p>Theorem 1. CQ entailment is decidable for the class of KBs having a recurringly treewidth-bounded core chase sequence.</p><p>Proof. Let â„­ be the class of KBs having a recurringly treewidthbounded core chase sequence. The proof closely follows arguments from previous work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>. An algorithm deciding K |= ğ‘„ for a given K âˆˆ â„­ and conjunctive query ğ‘„ can be devised from two semi-decision procedures (which, when executed in parallel give rise to a decision algorithm): one guaranteed to detect K |= ğ‘„ after finite time and another detecting K Ì¸ |= ğ‘„. For the former, we can evoke the fact that thanks to the completeness of first-order logic <ref type="bibr" target="#b11">[12]</ref>, the consequences of a first-order theory are recursively enumerable. So, the first part of the algorithm can just enumerate the consequences of K and terminate answering "yes" as soon as ğ‘„ is found among the consequences. It remains to be shown that there is a semi-decision procedure detecting K Ì¸ |= ğ‘„. By assumption, K has a finitely universal model ğ¼ with ğ‘¡ğ‘¤ (ğ¼ ) âˆˆ N. From ğ¼ being finitely universal for K and K Ì¸ |= ğ‘„, we can conclude ğ¼ Ì¸ |= ğ‘„. But then we obtain ğ¼ |= ğ¹ âˆ§ ( Î£) âˆ§ (Â¬ğ‘„) (assuming that ğ¹ and ğ‘„ are represented as first-order sentences and Î£ as a set of first-order sentences). This means, whenever K Ì¸ |= ğ‘„, then there exists some ğ‘˜ (namely ğ‘¡ğ‘¤ (ğ¼ )) such that the first-order sentence ğ¹ âˆ§( Î£)âˆ§(Â¬ğ‘„) is satisfiable over the class of structures of treewidth ğ‘˜. Fortunately, as previously observed <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>, satisfiability of monadic second-order logic -and thus also of first-order logic -over classes of structures with a treewidth bounded by a given ğ‘˜ is decidable. This allows to design a semi-decision procedure that increases ğ‘˜ stepwise and in each step applies the decision procedure that checks if ğ¹ âˆ§ ( Î£) âˆ§ (Â¬ğ‘„) has a model of treewidth ğ‘˜. If so, the procedure terminates with the output "no", since we have shown that ğ‘„ cannot be a consequence of K. If not, we increment ğ‘˜ and repeat. Clearly, thanks to the above assumption, this semi-decision procedure will output "no" and terminate exactly if K Ì¸ |= ğ‘„. â–¡ Proposition 13. CQ entailment is decidable for any ruleset that is core-bts. Moreover, core-bts subsumes both finite expansion sets (fes) and bounded treewidth sets (bts), which are mutually incomparable.</p><p>Proof. Decidability follows from Theorem 2. We sucessively prove the following items:</p><p>â€¢ fes and bts are incomparable, â€¢ fes is subsumed by core-bts.</p><p>â€¢ bts is subsumed by core-bts.</p><p>For the first bullet point, note that the singleton ruleset {r(ğ‘‹, ğ‘Œ ) â†’ âˆƒğ‘ .r(ğ‘Œ, ğ‘ )} is bts but not fes, whereas the singleton ruleset {r(ğ‘‹, ğ‘Œ )âˆ§ r(ğ‘Œ, ğ‘ ) â†’ âˆƒğ‘‰ .r(ğ‘‹, ğ‘‹ ) âˆ§ r(ğ‘‹, ğ‘ ) âˆ§ r(ğ‘, ğ‘‰ )} is fes but not bts.</p><p>For the second bullet point, recall that finite extension sets guarantee core-chase termination. Yet, for any finite sequence of finite structures one can find a uniform finite bound on the treewidth, it suffices to pick max ğ‘– âˆˆâ„‘ |T (ğ¹ ğ‘– )|.</p><p>For the third bullet point, we observe that any treewidth-bounded restricted chase sequence (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ can be transformed into a corechase sequence (ğ¹ â€² ğ‘– ) ğ‘– âˆˆâ„‘ as follows: Let ğœ â€² 0 be an endomorphism turning ğ¹ 0 into a core and let ğ¹ â€² 0 = ğœ â€² 0 (ğ¹ 0 ) = ğœ â€² 0 (ğ¹ ). From this starting point, we can always use ğ¹ ğ‘– , ğ¹ â€² ğ‘– , and ğœ â€² ğ‘– where ğœ â€² ğ‘– (ğ¹ ğ‘– ) = ğ¹ â€² ğ‘– is a core, to define ğœ â€² ğ‘–+1 and ğ¹ â€² ğ‘–+1 such that ğœ â€² ğ‘–+1 (ğ¹ ğ‘–+1 ) = ğ¹ â€² ğ‘–+1 is a core as follows: assuming ğ¹ ğ‘–+1 = ğ›¼ (ğ¹ ğ‘– , (ğ‘…, ğœ‹)), we let ğœ ğ‘–+1 be an endomorphism of ğ›¼ (ğœ â€² ğ‘– (ğ¹ ğ‘– ), (ğ‘…, ğœ â€² ğ‘– â€¢ ğœ‹)) producing a core, which we choose as ğ¹ â€² ğ‘–+1 . Clearly then ğ¹ â€² ğ‘–+1 is also a core of ğ¹ ğ‘–+1 = ğ›¼ (ğ¹ ğ‘– , (ğ‘…, ğœ‹)) witnessed by the endomorphism ğœ â€² ğ‘–+1 = ğœ ğ‘–+1 â€¢ ğœ â€² ğ‘– . Note that (ğ¹ â€² ğ‘– ) ğ‘– âˆˆâ„‘ is indeed a core chase sequence, except for some elements being repeated, which can be removed. Now given that there exists a bound ğ‘ greater than the treewidth of each element of (ğ¹ ğ‘– ) ğ‘– âˆˆâ„‘ , the same must hold for (ğ¹ â€² ğ‘– ) ğ‘– âˆˆâ„‘ , given that ğ¹ â€² ğ‘– âŠ† ğ¹ ğ‘– for all ğ‘– âˆˆ â„‘. Thus (ğ¹ â€² ğ‘– ) ğ‘– âˆˆâ„‘ (and any pruned subsequence of it) is uniformly (and hence also recurrently) treewidth-bounded. â–¡</p></div><figure xml:id="fig_0"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Two infinite universal models of K v (ğ¼ v from Definition 10 and ğ¼ v * from Definition 11), and finite atomsets ğ¼ v 1 -ğ¼ v 5 of the sequence (ğ¼ v ğ‘› ) ğ‘›âˆˆN from Definition 12 (recall that ğ¼ v 0 = ğ¹ v ).</figDesc></figure>
<figure xml:id="fig_1"><head>Proposition 9 .</head><label>9</label><figDesc>Let ğ‘€ be a finitely universal model of a KB K, and let ğ‘„ be a CQ. Then K |= ğ‘„ iff ğ‘€ |= ğ‘„. Proof. (â‡) Let ğœ be a homomorphism from ğ‘„ to ğ‘€. As ğ‘€ is finitely universal, the finite subset ğœ (ğ‘„) of ğ‘€ maps to any model ğ¼ of K by some ğœ â€² , thus ğœ â€² â€¢ ğœ maps ğ‘„ to ğ¼ . (â‡’) Since K |= ğ‘„ and ğ‘€ is a model of K, ğ‘€ |= ğ‘„. â–¡</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Building the robust sequence associated with D.</figDesc></figure>
<figure xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Depiction of the inductive definition of the robust sequence (Definition 15). Also useful to follow proof of Proposition 11.</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>denote the subset of ğ¼ h induced by ğ‘ƒ ğ‘˜ (resp. ğ¶ ğ‘˜ , ğ‘† ğ‘˜ ). Intuitively, ğ‘ƒ h ğ‘˜ is the finite part until column ğ‘˜, ğ¶ h ğ‘˜ is the ğ‘˜ th column of ğ¼ h (minus its top element) and ğ‘† h ğ‘˜ is a step -a rectangle containing the two columns ğ¶ h ğ‘˜ and ğ¶ h ğ‘˜+1 . We first point out that there is a sequence of rule applications from any ğ¶ h ğ‘˜ producing ğ‘† h ğ‘˜ . Indeed, we can apply ğ‘… h 1 on the top of ğ¶ h ğ‘˜ to "complete" ğ¶ h ğ‘˜ and obtain the two highest variables of ğ¶ h</figDesc><table><row><cell /><cell>ğ‘˜+1 .</cell></row><row><cell cols="2">Then we apply ğ‘… h 2 ğ‘˜ times (from top to bottom) to obtain the other</cell></row><row><cell>variables of ğ¶ h ğ‘˜+1 . Once ğ‘‹ ğ‘˜+1 0</cell><cell>has been generated, we can apply ğ‘… h 3</cell></row><row><cell cols="2">to generate the h-loop on ğ‘‹ ğ‘˜+1 0 , then ğ‘˜ successive applications of</cell></row><row><cell cols="2">ğ‘… h 4 propagate the loops on ğ¶ h ğ‘˜+1 , from bottom to top. There is thus</cell></row><row><cell cols="2">a monotonic infinite derivation D r = (ğ¹ ğ‘– ) ğ‘– âˆˆN from K h , the natural</cell></row><row><cell cols="2">aggregation of which yields ğ¼ h . We successively apply ğ‘… h 1 , ğ‘… h 3 , and</cell></row><row><cell>ğ‘… h 4 on ğ¹</cell><cell /></row></table><note><p>h to obtain ğ‘† h 0 = ğ‘ƒ h 1 . Since ğ¶ h 1 âŠ† ğ‘† h 0 , we apply the rules on ğ¶ h 1 as seen previously to obtain ğ‘… h 1 and thus ğ‘† h 2</p></note></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>and ğ‘— â‰¥ ğ‘›} removing all atoms v(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘– ğ‘— ) and f(ğ‘‹ ğ‘– ğ‘— ) with ğ‘— &gt; ğ‘› as well as all atoms h(ğ‘‹ ğ‘– ğ‘— , ğ‘‹ ğ‘–+1 ğ‘˜ ) with ğ‘˜ &gt; ğ‘— and ğ‘˜ &gt; ğ‘›.</figDesc><table><row><cell>Proposition 8. The following hold:</cell></row><row><cell>(1) Every ğ¼ v ğ‘› is a core.</cell></row><row><cell>(2) ğ¼ v ğ‘› has a treewidth of at least âŒˆğ‘›/3âŒ‰ + 1.</cell></row></table></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>ğ‘Ÿ (tr) for ğ¹ ğ‘  is satisfied in ğ¹ ğ‘  . Now since ğœŒ ğ‘  is an isomorphism from ğ¹ ğ‘  to ğº ğ‘  , it follows that ğœŒ ğ‘  â€¢ Ïƒğ‘  ğ‘Ÿ â€¢ğœŒ -1 ğ‘Ÿ (tr) is a satisfied trigger for ğº ğ‘  . We first see that ğœ ğ‘Ÿ +1 â€¢ ğœŒ -1 ğ‘Ÿ = ğœŒ -1 ğ‘Ÿ +1 â€¢ ğœ ğ‘Ÿ +1 . By applying this property iteratively, we show that ğœŒ ğ‘  â€¢ Ïƒğ‘  ğ‘Ÿ</figDesc><table /><note><p>ğ‘Ÿ â€¢ ğœŒ -1</p></note></figure>
<figure type="table" xml:id="tab_3"><head /><label /><figDesc>â€¢ â€¢ â€¢ â€¢ â€¢ ğœ 0 is a retraction from ğº ğ‘– to ğ¹ ğ‘– that allows us to build ğº ğ‘–+1 . The derivation D ğ‘šğ‘œğ‘› we obtain is</figDesc><table><row><cell cols="2">Rule let â„(ğ‘‹ ğ‘– ğ‘— ) = ğ‘‹ â„ ğ‘¥ (ğ‘–,ğ‘— ) â„ ğ‘¦</cell><cell>Homomorphism</cell><cell>Atoms produced</cell></row><row><cell>ğ‘… â„ 1</cell><cell /><cell>ğ‘‹ â†¦ â†’ ğ‘‹ ğ‘˜ ğ‘˜</cell><cell>v(ğ‘‹ ğ‘˜ ğ‘˜ , ğ‘‹ ğ‘˜ ğ‘˜+1 ), h(ğ‘‹ ğ‘˜ ğ‘˜+1 , ğ‘‹ ğ‘˜+1 ğ‘˜+1 ), c(ğ‘‹ ğ‘˜+1 ğ‘˜+1 ), h(ğ‘‹ ğ‘˜ ğ‘˜ , ğ‘‹ ğ‘˜+1 ,</cell><cell>ğ‘˜), v(ğ‘‹ ğ‘˜+1 ğ‘˜ , ğ‘‹ ğ‘˜+1 ğ‘˜+1 )</cell></row><row><cell>ğ‘… â„ 2</cell><cell cols="2">ğ‘‹ â†¦ â†’ ğ‘‹ ğ‘˜ ğ‘˜ -1 , ğ‘‹ â€² â†¦ â†’ ğ‘‹ ğ‘˜ ğ‘˜ , ğ‘Œ â€² â†¦ â†’ ğ‘‹ ğ‘˜+1 ğ‘˜</cell><cell>h(ğ‘‹ ğ‘˜ ğ‘˜ -1 , ğ‘‹ ğ‘˜+1 ğ‘˜ -1 ), v(ğ‘‹ ğ‘˜+1 ğ‘˜ -1 , ğ‘‹ ğ‘˜+1 ğ‘˜ ), c(ğ‘‹ ğ‘˜+1 ğ‘˜ )</cell></row><row><cell>. . .</cell><cell /><cell /><cell /></row></table></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>Note that we operate under the unique name assumption.</p></note>
			<note place="foot" n="2" xml:id="foot_1"><p>The notion of fresh variable refers to the underlying assumption that the referred variable is not already present in ğ¹ , but also, that it has not occurred at any potential previous computation step (which is particularly relevant when rule applications are iterated and/or intertwined with other operations).</p></note>
			<note place="foot" n="3" xml:id="foot_2"><p>However, no upper complexity bounds are entailed. This holds even for the more restricted class of KBs with finite, "properly" universal models<ref type="bibr" target="#b4">[5]</ref>.</p></note>
			<note place="foot" n="4" xml:id="foot_3"><p>Notably, this corrects inaccurate statements in prior work by Baget et al.<ref type="bibr" target="#b2">[3]</ref>, where bts was claimed to subsume fes. The reason for this misconception was a definition of bts using cores, whereas the proof of decidability of CQ entailment for this class was flawed, as it erroneously assumed that the natural aggregation over a (treewidthbounded) core chase sequence produces a (treewidth-bounded) universal model. The current paper also corrects this earlier work, showing that the decidability claim made therein can be salvaged by other means.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>The authors thank the anonymous reviewers for their helpful comments. <rs type="person">Jean-FranÃ§ois Baget</rs> and <rs type="person">Marie-Laure Mugnier</rs> were partially supported by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>). <rs type="person">Sebastian Rudolph</rs> has received funding from the <rs type="funder">European Research Council</rs> (<rs type="grantName">Consolidator Grant</rs> Agreement no. <rs type="grantNumber">771779</rs>, DeciGUT).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_395rhe3">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
				<org type="funding" xml:id="_75C6S47">
					<idno type="grant-number">771779</idno>
					<orgName type="grant-name">Consolidator Grant</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div><p>Proof. Let ğ‘€ be an arbitrary model of K. We first prove the existence of homomorphisms ğ¹ ğ‘– â†’ ğ‘€ by induction over ğ‘–. The existence of some homomorphism ğ¹ 0 â†’ ğ‘€ is immediate by assumption. Then, if there is a homomorphism ğœ‡ ğ‘— from some ğ¹ ğ‘— of D to ğ‘€, then there is a homomorphism ğœ‡ ğ‘—+1 of ğ¹ ğ‘—+1 to ğ‘€ such that ğœ‡ ğ‘—+1 is compatible with ğœ‡ ğ‘— . We have ğ¹ ğ‘—+1 = ğœ ğ‘—+1 (ğ›¼ (ğ¹ ğ‘— , tr ğ‘–+1 )). See that ğœ‡ ğ‘— (tr ğ‘–+1 ) is a trigger for ğ‘€, satisfied in ğ‘€ since it is a model of K. Then (Fact 3) there is a homomorphism ğœ‡ from ğ›¼ (ğ¹ ğ‘— , tr ğ‘—+1 ) to ğ‘€ compatible with ğœ‡ ğ‘— and its restriction ğœ‡ ğ‘—+1 to the variables of ğœ ğ‘—+1 (ğ›¼ (ğ¹ ğ‘— , tr ğ‘—+1 )) is a homomorphism from ğ¹ ğ‘—+1 to ğ‘€ compatible with ğœ‡ ğ‘— .</p><p>(2) Hence, ğ‘€ is a model of every ğ¹ ğ‘– in D: each instance ğ¹ ğ‘– is universal and, if D is finite, then the final result D + = ğ¹ ğ‘˜ is universal. â–¡ (1) Now we claim that since a variable present both in ğ¹ ğ‘– and ğ¹ ğ‘— must appear in all atomsets between ğ¹ ğ‘– and ğ¹ ğ‘— (a consequence of the usage of fresh variables), the pairwise compatibility of the ğœ‡ ğ‘– between succsessive atomsets implies global compatibility of all ğœ‡ ğ‘– . We conclude by pointing out that ğ‘– âˆˆâ„‘ ğœ‡ ğ‘– is a homomorphism from D * to ğ‘€, and thus that D * is universal. â–¡ (4) The final result D + = ğ¹ ğ‘˜ of a finite derivation is a model of ğ¹ ( Ïƒ ğ‘— 0 â€¢ ğœ 0 is a homomorphism from ğ¹ to any ğ¹ ğ‘— in the derivation) and, by Definition 3, for any trigger tr for ğ¹ ğ‘˜ , there is some ğ‘— â‰¥ ğ‘˜ (thus ğ‘— = ğ‘˜) such that Ïƒğ‘˜ ğ‘˜ (tr) = tr is a satisfied trigger for ğ¹ ğ‘˜ . â–¡ (3) In the case of an infinite fair derivation, we first point out that D * contains ğ¹ 0 = ğœ 0 (ğ¹ ), so it is a model of ğ¹ . Then consider any trigger tr for D * : it is also a trigger for some ğ¹ ğ‘– in D. By Definition 3, there exists some ğ‘— âˆˆ â„‘ with ğ‘— â‰¥ ğ‘– such that Ïƒ ğ‘— ğ‘– (tr) is a satisfied trigger for ğ¹ ğ‘— . Since D is monotonic, ğœ ğ‘— ğ‘– is the identity and thus Ïƒ ğ‘— ğ‘– (tr) = tr is satisfied in D * . â–¡ (5, â‡) Let ğœ‹ be a homomorphism from ğ‘„ to D * . Since D * is universal (by (1)), it maps to any model ğ‘€ of K. Let ğœ ğ‘€ be a homomorphism from D * to ğ‘€, then ğœ ğ‘€ â€¢ ğœ‹ maps ğ‘„ to ğ‘€. â–¡ (5, â‡’) Let us now consider the fair monotonic derivation D ğ‘šğ‘œğ‘› from Lemma 2. We now that D * ğ‘šğ‘œğ‘› is a model of K, and then if K |= ğ‘„, then there is a homomorphism ğœ‹ from ğ‘„ to D * ğ‘šğ‘œğ‘› . Since ğœ‹ (ğ‘„) is finite, there is some atomset ğº ğ‘– in D ğ‘šğ‘œğ‘› such that ğœ‹ (ğ‘„) âŠ† ğº ğ‘– . We know there is a retract Ïƒğ‘– from ğº ğ‘– to ğ¹ ğ‘– , so Ïƒğ‘– â€¢ ğœ‹ is a homomorphism from ğ‘„ to ğ¹ ğ‘– and so from ğ‘„ to D * . â–¡</p></div>
<div><head>B PROOFS OF SECTION 6</head><p>We first prove the following claim (see the explanations before Proposition 5.). Claim. There is a sequence of rule applications from any column ğ¶ h ğ‘˜ producing step ğ‘† h ğ‘˜ .</p><p>Proof. Let us consider ğ¶ â„ ğ‘˜ with variables named (ğ‘‹ ğ‘˜ 0 , ğ‘‹ ğ‘˜ 1 , . . . , ğ‘‹ ğ‘˜ ğ‘˜ ), from bottom to top. Let us apply rules as shown in Table <ref type="table">1</ref>. The obtained result is indeed ğ‘† â„ ğ‘˜ . â–¡ Proposition 5. No universal model of K h has finite treewidth.</p><p>Proof. We call v-path (resp. h-path) in an atomset a non-empty sequence of nulls such that, for any two consecutive nulls ğ‘‹ ğ‘– and ğ‘‹ ğ‘–+1 , the atomset contains the atom v(ğ‘‹ ğ‘– , ğ‘‹ ğ‘–+1 ) (resp. h(ğ‘‹ ğ‘– , ğ‘‹ ğ‘–+1 )). By analogy to graphs, the length of a path is ğ‘› -1 if it is a sequence of ğ‘› nulls.</p><p>Let ğ‘ˆ be an arbitrary universal model of K h . We first point out that ğ¼ h and ğ‘ˆ being both universal models, they homomorphically map to each other. We let â„ 1 denote the homomorphism from ğ¼ h to ğ‘ˆ and let â„ 2 denote the homomorphism from ğ‘ˆ to ğ¼ h . Then â„ = â„ 2 â€¢ â„ 1 is an endomorphism on ğ¼ h , the properties of which we will now inspect further. We make use of the following notation: for â„(ğ‘‹ ğ‘– ğ‘— ) = ğ‘‹ ğ‘˜ â„“ , we denote ğ‘˜ by â„ ğ‘¥ (ğ‘–, ğ‘—) and â„“ by â„ ğ‘¦ (ğ‘–, ğ‘—), that is, we</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Walking the Decidability Line for Rules with Existential Variables</title>
		<author>
			<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<ptr target="http://aaai.org/ocs/index.php/KR/KR2010/paper/view/1216" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR'10)</title>
		<editor>
			<persName><forename type="first">Fangzhen</forename><surname>Lin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ulrike</forename><surname>Sattler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Miroslaw</forename><surname>Truszczynski</surname></persName>
		</editor>
		<meeting>the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR'10)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Walking the Complexity Lines for Generalized Guarded Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MichaÃ«l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-126</idno>
		<ptr target="https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-126" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI'11)</title>
		<editor>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI'11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
	<note>IJCAI/AAAI</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Salvat</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2011.03.002</idno>
		<ptr target="https://doi.org/10.1016/j.artint.2011.03.002" />
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Core-like properties of infinite graphs and structures</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><surname>Bauslaugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="101" to="111" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Capturing Homomorphism-Closed Decidable Queries with Existential Rules</title>
		<author>
			<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>KrÃ¶tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MichaÃ«l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.24963/kr.2021/14</idno>
		<ptr target="https://doi.org/10.24963/kr.2021/14" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<editor>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gerhard</forename><surname>Lakemeyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Esra</forename><surname>Erdem</surname></persName>
		</editor>
		<meeting>the 18th International Conference on Principles of Knowledge Representation and Reasoning<address><addrLine>KR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Taming the Infinite Chase: Query Answering under Expressive Relational Constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR'08)</title>
		<meeting>the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR'08)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Taming the Infinite Chase: Query Answering under Expressive Relational Constraints</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<idno type="DOI">10.1613/jair.3873</idno>
		<ptr target="https://doi.org/10.1613/jair.3873" />
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="115" to="174" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Preserving Constraints with the Stable Chase</title>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>KrÃ¶tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maximilian</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><surname>Ozaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2018.12</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2018.12" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Database Theory (ICDT'18) (LIPIcs</title>
		<editor>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yael</forename><surname>Amsterdamer</surname></persName>
		</editor>
		<meeting>the 21st International Conference on Database Theory (ICDT'18) (LIPIcs</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The chase revisited</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
		<idno type="DOI">10.1145/1376916.1376938</idno>
		<ptr target="https://doi.org/10.1145/1376916.1376938" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS'08)</title>
		<editor>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</editor>
		<meeting>the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS'08)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data Exchange: Semantics and Query Answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Finite-Cliquewidth Sets of Existential Rules: Toward a General Criterion for Decidable yet Highly Expressive Querying</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Feller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><forename type="middle">S</forename><surname>Lyon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Piotr</forename><surname>Ostropolski-Nalewaja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2209.02464" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Database Theory (ICDT 2023) (LIPIcs)</title>
		<meeting>the 26th International Conference on Database Theory (ICDT 2023) (LIPIcs)</meeting>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum fÃ¼r Informatik</orgName>
		</respStmt>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Kurt</forename><surname>GÃ¶del</surname></persName>
		</author>
		<title level="m">Ãœber die VollstÃ¤ndigkeit des LogikkalkÃ¼ls</title>
		<imprint>
			<date type="published" when="1929">1929</date>
		</imprint>
		<respStmt>
			<orgName>UniversitÃ¤t Wien</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Robbers, Marshals, and Guards: Game Theoretic and Logical Characterizations of Hypertree Width</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Scarcello</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0022-0000(03)00030-8</idno>
		<ptr target="https://doi.org/10.1016/S0022-0000(03)00030-8" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="775" to="808" />
			<date type="published" when="2003-06">2003. jun 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Anatomy of the Chase</title>
		<author>
			<persName><forename type="first">GÃ¶sta</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Onet</surname></persName>
		</author>
		<idno type="DOI">10.3233/FI-2018-1627</idno>
		<ptr target="https://doi.org/10.3233/FI-2018-1627" />
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Optimizing the Chase: Scalable Data Integration under Constraints</title>
		<author>
			<persName><forename type="first">George</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">JosÃ©</forename><surname>Luis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ambite</forename></persName>
		</author>
		<idno type="DOI">10.14778/2733085.2733093</idno>
		<ptr target="https://doi.org/10.14778/2733085.2733093" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="1869" to="1880" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Extending Decidable Existential Rules by Joining Acyclicity and Guardedness</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>KrÃ¶tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-166</idno>
		<ptr target="https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-166" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI'11)</title>
		<editor>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI'11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="963" to="968" />
		</imprint>
	</monogr>
	<note>IJCAI/AAAI</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Generalized schema-mappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">B</forename><surname>Marnette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS'09)</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</editor>
		<meeting>the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS'09)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">Robin</forename><surname>Thomas</surname></persName>
		</author>
		<ptr target="https://people.math.gatech.edu/~thomas/PAP/twcpt.pdf" />
		<title level="m">The Tree-Width Compactness Theorem for Hypergraphs</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</teiCorpus></text>
</TEI>