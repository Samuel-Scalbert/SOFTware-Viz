<?xml version='1.0' encoding='utf-8'?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 http://api.archives-ouvertes.fr/documents/aofr-sword.xsd">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>HAL TEI export of hal-03104155</title>
      </titleStmt>
      <publicationStmt>
        <distributor>CCSD</distributor>
        <availability status="restricted">
          <licence target="http://creativecommons.org/licenses/by/4.0/">Distributed under a Creative Commons Attribution 4.0 International License</licence>
        </availability>
        <date when="2024-04-19T21:25:12+02:00" />
      </publicationStmt>
      <sourceDesc>
        <p part="N">HAL API platform</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <listBibl>
        <biblFull>
          <titleStmt>
            <title xml:lang="en">Weight Annotation in Information Extraction</title>
            <author role="aut">
              <persName>
                <forename type="first">Johannes</forename>
                <surname>Doleschal</surname>
              </persName>
              <idno type="halauthorid">2127153-0</idno>
              <affiliation ref="#struct-558206" />
              <affiliation ref="#struct-469275" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Benny</forename>
                <surname>Kimelfeld</surname>
              </persName>
              <idno type="halauthorid">425194-0</idno>
              <affiliation ref="#struct-84142" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Wim</forename>
                <surname>Martens</surname>
              </persName>
              <idno type="halauthorid">157350-0</idno>
              <affiliation ref="#struct-558206" />
            </author>
            <author role="aut">
              <persName>
                <forename type="first">Liat</forename>
                <surname>Peterfreund</surname>
              </persName>
              <email type="md5">bd31a675907ebc2207c3d26ce6696269</email>
              <email type="domain">gmail.com</email>
              <idno type="idhal" notation="numeric">1087990</idno>
              <idno type="halauthorid" notation="string">2127139-1087990</idno>
              <affiliation ref="#struct-25027" />
              <affiliation ref="#struct-478610" />
            </author>
            <editor role="depositor">
              <persName>
                <forename>Liat</forename>
                <surname>Peterfreund</surname>
              </persName>
              <email type="md5">bd31a675907ebc2207c3d26ce6696269</email>
              <email type="domain">gmail.com</email>
            </editor>
            <funder>This work was supported by the German-Israeli Foundation for Scientific Research and Development (GIF), grant I-1502-407.6/2019. The work of Johannes Doleschal and Wim Martens was also supported by the Deutsche Forschungsgemeinschaft (DFG), grant MA 4938/4-1. The work of Benny Kimelfeld and Liat Peterfreund was also supported by the Israel Science Foundation (ISF), grants 1295/15 and 768/19, and the DFG project 412400621 (DIP program).</funder>
          </titleStmt>
          <editionStmt>
            <edition n="v1" type="current">
              <date type="whenSubmitted">2021-01-08 16:31:22</date>
              <date type="whenModified">2024-04-19 16:18:56</date>
              <date type="whenReleased">2021-01-11 09:18:28</date>
              <date type="whenProduced">2020-03-30</date>
              <date type="whenEndEmbargoed">2021-01-08</date>
              <ref type="file" target="https://inria.hal.science/hal-03104155/document">
                <date notBefore="2021-01-08" />
              </ref>
              <ref type="file" subtype="author" n="1" target="https://inria.hal.science/hal-03104155/file/LIPIcs-ICDT-2020-8-2.pdf">
                <date notBefore="2021-01-08" />
              </ref>
            </edition>
            <respStmt>
              <resp>contributor</resp>
              <name key="975150">
                <persName>
                  <forename>Liat</forename>
                  <surname>Peterfreund</surname>
                </persName>
                <email type="md5">bd31a675907ebc2207c3d26ce6696269</email>
                <email type="domain">gmail.com</email>
              </name>
            </respStmt>
          </editionStmt>
          <publicationStmt>
            <distributor>CCSD</distributor>
            <idno type="halId">hal-03104155</idno>
            <idno type="halUri">https://inria.hal.science/hal-03104155</idno>
            <idno type="halBibtex">doleschal:hal-03104155</idno>
            <idno type="halRefHtml">&lt;i&gt;ICDT 2020 - 23rd International Conference on Database Theory&lt;/i&gt;, Mar 2020, Copenhague / Virtual, Denmark. &lt;a target="_blank" href="https://dx.doi.org/10.4230/LIPIcs.ICDT.2020.8"&gt;&amp;#x27E8;10.4230/LIPIcs.ICDT.2020.8&amp;#x27E9;&lt;/a&gt;</idno>
            <idno type="halRef">ICDT 2020 - 23rd International Conference on Database Theory, Mar 2020, Copenhague / Virtual, Denmark. &amp;#x27E8;10.4230/LIPIcs.ICDT.2020.8&amp;#x27E9;</idno>
          </publicationStmt>
          <seriesStmt>
            <idno type="stamp" n="ENS-PARIS">Ecole Normale Supérieure de Paris</idno>
            <idno type="stamp" n="CNRS">CNRS - Centre national de la recherche scientifique</idno>
            <idno type="stamp" n="INRIA">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="INRIA-ROCQ">INRIA Paris - Rocquencourt</idno>
            <idno type="stamp" n="TESTALAIN1">TESTALAIN1</idno>
            <idno type="stamp" n="INRIA2">INRIA 2</idno>
            <idno type="stamp" n="PSL">Université Paris sciences et lettres</idno>
            <idno type="stamp" n="INRIA-PSL">INRIA-PSL</idno>
            <idno type="stamp" n="TEST-HALCNRS">Collection test HAL CNRS</idno>
            <idno type="stamp" n="ENS-PSL" corresp="PSL">École normale supérieure - PSL</idno>
            <idno type="stamp" n="INRIA-ISRAEL">COPUBLICATION INRIA ISRAEL</idno>
            <idno type="stamp" n="INRIA-ALLEMAGNE">INRIA-ALLEMAGNE</idno>
            <idno type="stamp" n="DIENS" corresp="ENS-PARIS">Département d'informatique de l'ENS-PSL</idno>
          </seriesStmt>
          <notesStmt>
            <note type="audience" n="2">International</note>
            <note type="invited" n="0">No</note>
            <note type="popular" n="0">No</note>
            <note type="peer" n="1">Yes</note>
            <note type="proceedings" n="1">Yes</note>
          </notesStmt>
          <sourceDesc>
            <biblStruct>
              <analytic>
                <title xml:lang="en">Weight Annotation in Information Extraction</title>
                <author role="aut">
                  <persName>
                    <forename type="first">Johannes</forename>
                    <surname>Doleschal</surname>
                  </persName>
                  <idno type="halauthorid">2127153-0</idno>
                  <affiliation ref="#struct-558206" />
                  <affiliation ref="#struct-469275" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Benny</forename>
                    <surname>Kimelfeld</surname>
                  </persName>
                  <idno type="halauthorid">425194-0</idno>
                  <affiliation ref="#struct-84142" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Wim</forename>
                    <surname>Martens</surname>
                  </persName>
                  <idno type="halauthorid">157350-0</idno>
                  <affiliation ref="#struct-558206" />
                </author>
                <author role="aut">
                  <persName>
                    <forename type="first">Liat</forename>
                    <surname>Peterfreund</surname>
                  </persName>
                  <email type="md5">bd31a675907ebc2207c3d26ce6696269</email>
                  <email type="domain">gmail.com</email>
                  <idno type="idhal" notation="numeric">1087990</idno>
                  <idno type="halauthorid" notation="string">2127139-1087990</idno>
                  <affiliation ref="#struct-25027" />
                  <affiliation ref="#struct-478610" />
                </author>
              </analytic>
              <monogr>
                <meeting>
                  <title>ICDT 2020 - 23rd International Conference on Database Theory</title>
                  <date type="start">2020-03-30</date>
                  <date type="end">2020-04-02</date>
                  <settlement>Copenhague / Virtual</settlement>
                  <country key="DK">Denmark</country>
                </meeting>
                <imprint />
              </monogr>
              <idno type="doi">10.4230/LIPIcs.ICDT.2020.8</idno>
              <ref type="publisher">https://diku-dk.github.io/edbticdt2020/</ref>
            </biblStruct>
          </sourceDesc>
          <profileDesc>
            <langUsage>
              <language ident="en">English</language>
            </langUsage>
            <textClass>
              <keywords scheme="author">
                <term xml:lang="en">Information extraction</term>
                <term xml:lang="en">regular document spanners</term>
                <term xml:lang="en">K-relations</term>
                <term xml:lang="en">Provenance semirings</term>
                <term xml:lang="en">Weighted automata</term>
              </keywords>
              <classCode scheme="halDomain" n="info.info-db">Computer Science [cs]/Databases [cs.DB]</classCode>
              <classCode scheme="halTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halOldTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halTreeTypology" n="COMM">Conference papers</classCode>
            </textClass>
            <abstract xml:lang="en">
              <p>The framework of document spanners abstracts the task of information extraction from text as a function that maps every document (a string) into a relation over the document's spans (intervals identified by their start and end indices). For instance, the regular spanners are the closure under the Relational Algebra (RA) of the regular expressions with capture variables, and the expressive power of the regular spanners is precisely captured by the class of vset-automata-a restricted class of transducers that mark the endpoints of selected spans. In this work, we embark on the investigation of document spanners that can annotate extractions with auxiliary information such as confidence, support, and confidentiality measures. To this end, we adopt the abstraction of provenance semirings by Green et al., where tuples of a relation are annotated with the elements of a commutative semiring, and where the annotation propagates through the (positive) RA operators via the semiring operators. Hence, the proposed spanner extension, referred to as an annotator, maps every string into an annotated relation over the spans. As a specific instantiation, we explore weighted vset-automata that, similarly to weighted automata and transducers, attach semiring elements to transitions. We investigate key aspects of expressiveness, such as the closure under the positive RA, and key aspects of computational complexity, such as the enumeration of annotated answers and their ranked enumeration in the case of numeric semirings. For a number of these problems, fundamental properties of the underlying semiring, such as positivity, are crucial for establishing tractability.</p>
            </abstract>
            <particDesc>
              <org type="consortium">Réponse efficace aux requêtes sous mises à jour EQUUS - ANR-19-CE48-0019 AAPG2019 - 2019</org>
            </particDesc>
          </profileDesc>
        </biblFull>
      </listBibl>
    </body>
    <back>
      <listOrg type="structures">
        <org type="institution" xml:id="struct-558206" status="VALID">
          <idno type="ROR">https://ror.org/0234wmv40</idno>
          <orgName>University of Bayreuth</orgName>
          <desc>
            <address>
              <addrLine>95440 Bayreuth</addrLine>
              <country key="DE" />
            </address>
          </desc>
        </org>
        <org type="institution" xml:id="struct-469275" status="VALID">
          <idno type="ROR">https://ror.org/04nbhqj75</idno>
          <orgName>Hasselt University</orgName>
          <orgName type="acronym">UHasselt</orgName>
          <desc>
            <address>
              <addrLine>Campus Hasselt | Martelarenlaan 42 | BE3500 HasseltCampus Diepenbeek | Agoralaan gebouw D | BE3590 Diepenbeek</addrLine>
              <country key="BE" />
            </address>
            <ref type="url">http://www.uhasselt.be/</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-84142" status="VALID">
          <idno type="IdRef">03264387X</idno>
          <idno type="ISNI">0000000121102151</idno>
          <idno type="ROR">https://ror.org/03qryx823</idno>
          <orgName>Technion - Israel Institute of Technology [Haifa]</orgName>
          <desc>
            <address>
              <addrLine>Technion City, Haifa 3200003</addrLine>
              <country key="IL" />
            </address>
            <ref type="url">https://www.technion.ac.il/en/</ref>
          </desc>
        </org>
        <org type="regrouplaboratory" xml:id="struct-25027" status="VALID">
          <idno type="IdRef">148034055</idno>
          <idno type="RNSR">199812876J</idno>
          <orgName>Département d'informatique - ENS Paris</orgName>
          <orgName type="acronym">DI-ENS</orgName>
          <date type="start">1999-01-01</date>
          <desc>
            <address>
              <addrLine>École normale supérieure 45 rue d'Ulm F-75230 Paris Cedex 05</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.di.ens.fr/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-59704" type="direct" />
            <relation active="#struct-564132" type="indirect" />
            <relation active="#struct-300009" type="direct" />
            <relation name="UMR8548" active="#struct-441569" type="direct" />
          </listRelation>
        </org>
        <org type="researchteam" xml:id="struct-478610" status="VALID">
          <idno type="RNSR">201622223R</idno>
          <orgName>Value from Data</orgName>
          <orgName type="acronym">VALDA </orgName>
          <date type="start">2016-12-01</date>
          <desc>
            <address>
              <addrLine>ENS Paris</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.inria.fr/equipes/valda</ref>
          </desc>
          <listRelation>
            <relation active="#struct-25027" type="direct" />
            <relation active="#struct-59704" type="indirect" />
            <relation active="#struct-564132" type="indirect" />
            <relation active="#struct-300009" type="indirect" />
            <relation name="UMR8548" active="#struct-441569" type="indirect" />
            <relation active="#struct-454310" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-59704" status="VALID">
          <idno type="IdRef">031738419</idno>
          <idno type="ISNI">0000000123532622</idno>
          <idno type="ROR">https://ror.org/05a0dhs15</idno>
          <orgName>École normale supérieure - Paris</orgName>
          <orgName type="acronym">ENS-PSL</orgName>
          <date type="start">1985-07-24</date>
          <desc>
            <address>
              <addrLine>45, Rue d'Ulm - 75230 Paris cedex 05</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.ens.psl.eu/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-564132" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-564132" status="VALID">
          <idno type="IdRef">241597595</idno>
          <idno type="ISNI">0000 0004 1784 3645</idno>
          <orgName>Université Paris Sciences et Lettres</orgName>
          <orgName type="acronym">PSL</orgName>
          <desc>
            <address>
              <addrLine>60 rue Mazarine 75006 Paris</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://www.psl.eu/</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-300009" status="VALID">
          <idno type="ROR">https://ror.org/02kvxyf05</idno>
          <orgName>Institut National de Recherche en Informatique et en Automatique</orgName>
          <orgName type="acronym">Inria</orgName>
          <desc>
            <address>
              <addrLine>Domaine de VoluceauRocquencourt - BP 10578153 Le Chesnay Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/en/</ref>
          </desc>
        </org>
        <org type="regroupinstitution" xml:id="struct-441569" status="VALID">
          <idno type="IdRef">02636817X</idno>
          <idno type="ISNI">0000000122597504</idno>
          <idno type="ROR">https://ror.org/02feahw73</idno>
          <orgName>Centre National de la Recherche Scientifique</orgName>
          <orgName type="acronym">CNRS</orgName>
          <date type="start">1939-10-19</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cnrs.fr/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-454310" status="VALID">
          <idno type="IdRef">241614864</idno>
          <idno type="RNSR">196718247G</idno>
          <orgName>Inria de Paris</orgName>
          <date type="start">2016-03-10</date>
          <desc>
            <address>
              <addrLine>2 rue Simone Iff -CS 42112 -75589 Paris Cedex 12</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/centre/paris</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300009" type="direct" />
          </listRelation>
        </org>
      </listOrg>
    </back>
  <teiCorpus>
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Weight Annotation in Information Extraction</title>
				<funder ref="#_jvkqSXv">
					<orgName type="full">Deutsche Forschungsgemeinschaft (DFG)</orgName>
				</funder>
				<funder ref="#_4RTuE6Z">
					<orgName type="full">DFG</orgName>
				</funder>
				<funder ref="#_4WE9u3t">
					<orgName type="full">German-Israeli Foundation for Scientific Research and Development</orgName>
					<orgName type="abbreviated">GIF</orgName>
				</funder>
				<funder ref="#_Uen6gdf">
					<orgName type="full">Israel Science Foundation</orgName>
					<orgName type="abbreviated">ISF</orgName>
				</funder>
				<funder ref="#_XNxrfy7">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Johannes</forename><surname>Doleschal</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Liat</forename><surname>Peterfreund</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Bayreuth</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Hasselt University</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Technion -Israel Institute of Technology</orgName>
								<address>
									<settlement>Haifa</settlement>
									<country key="IL">Israel</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Bayreuth</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">IRIF -Université de Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">University of Edinburgh</orgName>
								<address>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="department" key="dep1">Leibniz International Proceedings</orgName>
								<orgName type="department" key="dep2">Informatics Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
								<orgName type="department" key="dep3">Dagstuhl Publishing</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Weight Annotation in Information Extraction</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">41AF2E9CAC31F7D87C8F61A7051D8277</idno>
					<idno type="DOI">10.4230/LIPIcs.ICDT.2020.8</idno>
					<note type="submission">anonymous reviewers for ICDT 2020</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>2012 ACM Subject Classification Information systems → Information extraction</term>
					<term>Theory of computation → Transducers</term>
					<term>Theory of computation → Problems, reductions and completeness</term>
					<term>Theory of computation → Data provenance Information extraction, regular document spanners, weighted automata, provenance semirings, K-relations Digital Object Identifier 10.4230/LIPIcs.ICDT.2020.8</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>The framework of document spanners abstracts the task of information extraction from text as a function that maps every document (a string) into a relation over the document's spans (intervals identified by their start and end indices). For instance, the regular spanners are the closure under the Relational Algebra (RA) of the regular expressions with capture variables, and the expressive power of the regular spanners is precisely captured by the class of vset-automata -a restricted class of transducers that mark the endpoints of selected spans.</p><p>In this work, we embark on the investigation of document spanners that can annotate extractions with auxiliary information such as confidence, support, and confidentiality measures. To this end, we adopt the abstraction of provenance semirings by Green et al., where tuples of a relation are annotated with the elements of a commutative semiring, and where the annotation propagates through the (positive) RA operators via the semiring operators. Hence, the proposed spanner extension, referred to as an annotator, maps every string into an annotated relation over the spans. As a specific instantiation, we explore weighted vset-automata that, similarly to weighted automata and transducers, attach semiring elements to transitions. We investigate key aspects of expressiveness, such as the closure under the positive RA, and key aspects of computational complexity, such as the enumeration of annotated answers and their ranked enumeration in the case of numeric semirings. For a number of these problems, fundamental properties of the underlying semiring, such as positivity, are crucial for establishing tractability.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">Introduction</head><p>A plethora of paradigms have been developed over the past decades towards the challenge of extracting structured information from text -a task generally referred to as Information Extraction (IE). Common textual sources include natural language from a variety of sources such as scientific publications, customer input and social media, as well as machine-generated activity logs. Instantiations of IE are central components in text analytics and include tasks such as segmentation, named-entity recognition, relation extraction, and coreference resolution <ref type="bibr" target="#b37">[38]</ref>. Rules and rule systems have consistently been key components in such paradigms, yet their roles have varied and evolved over time. Systems such as Xlog <ref type="bibr" target="#b41">[42]</ref> and <software ContextAttributes="used">SystemT</software> <ref type="bibr" target="#b3">[4]</ref> use IE rules for materializing relations inside relational query languages. Machinelearning classifiers and probabilistic graphical models (e.g., Conditional Random Fields) use rules for feature generation <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b43">44]</ref>. Rules serve as weak constraints (later translated into probabilistic graphical models) in Markov Logic Networks <ref type="bibr" target="#b31">[32]</ref> and in the DeepDive system <ref type="bibr" target="#b42">[43]</ref>. Rules are also used for generating noisy training data ("labeling functions") in the Snorkel system <ref type="bibr" target="#b33">[34]</ref>.</p><p>The framework of document spanners (spanners for short) provides a theoretical basis for investigating the principles of relational rule systems for IE <ref type="bibr" target="#b12">[13]</ref>. Specifically, a spanner extracts from a document a relation over text intervals, called spans, using either atomic extractors or a relational query on top of the atomic extractors. More formally, by a document we refer to a string d over a finite alphabet, a span of d represents a substring of d by its start and end positions, and a spanner is a function that maps every document d into a relation over the spans of d. The most studied spanner language is that of the regular spanners: atomic extraction is via regex formulas, which are regular expressions with capture variables, and relational manipulation is via the relational algebra: projection, natural join, union, and difference. Equivalently, the regular spanners are the ones expressible as variable-set automata (vset-automata for short), which are nondeterministic finite-state automata that can open and close variables (playing the role of the attributes of the extracted relation). Interestingly, there has been an independent recent effort to express artificial neural networks for natural language processing by means of finite-state automata <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b46">47]</ref>.</p><p>To date, the research on spanners has focused on their expressive power <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b30">31]</ref>, their computational complexity <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b17">18]</ref>, incompleteness <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b29">30]</ref>, and other system aspects such as cleaning <ref type="bibr" target="#b13">[14]</ref> and distributed query planning <ref type="bibr" target="#b7">[8]</ref>. That research has exclusively adopted a Boolean approach: a tuple is either extracted or not. Nevertheless, when applied to noisy or fuzzy domains such as natural language, modern approaches in artificial intelligence adopt a quantitative approach where each extracted tuple is associated with a level of confidence that the tuple coincides with the intent. When used within an end-to-end IE system, such confidence can be used as a principled way of tuning the balance between precision and recall. For instance, in probabilistic IE models (e.g., CRF), each extraction has an associated probability. In systems of weak constraints (e.g., MLN), every rule has a numerical weight, and the confidence in an extraction is an aggregation of the weights of the invoked rules that lead to the extraction. IE via artificial neural networks typically involves thresholding over a produced score or confidence value <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b28">29]</ref>. Numerical scores in extraction are also used for quantifying the similarity between associated substrings, as done with sequence alignment and edit distance in the analysis of biological sequences such as DNA and RNA <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46]</ref>.</p><p>In this work, we embark on the investigation of spanners that quantify the extracted tuples. We do so by adopting the concept of annotated relations from the framework of provenance semirings by Green et al. <ref type="bibr" target="#b19">[20]</ref>. In essence, every tuple of the database is annotated with an element of a commutative semiring, and the positive relational algebra manipulates both the tuples and their annotations by translating relational operators into semiring operators (e.g., product for natural join and sum for union). An annotated relation is referred to as a K-relation, where K is the domain of the semiring. The conceptual extension of the spanner model is straightforward: instead of a function (i.e., spanner) that maps every document d into a relation over the spans of d, we consider a function that maps every d into a K-relation over the spans of d. We refer to such a function as a K-annotator. Interestingly, as in the relational case, we can vary the meaning of the annotation by varying the semiring:</p><p>Confidence via the probability (a.k.a. inside) semiring and the Viterbi (best derivation) semiring <ref type="bibr" target="#b18">[19]</ref>; Support (i.e., number of derivations) via the counting semiring <ref type="bibr" target="#b18">[19]</ref>; Access control via the semiring of the confidentiality policies <ref type="bibr" target="#b15">[16]</ref> (e.g., does the extracted tuple require reading top-secret sections? which level suffices for the tuple?);</p><p>The traditional spanners via the Boolean semiring.</p><p>As a specific instantiation of K-annotators, we study the class of K-weighted vset-automata. Such automata generalize vset-automata in the same manner as weighted automata and weighted transducers (cf., e.g., the Handbook of Weighted Automata <ref type="bibr" target="#b9">[10]</ref>): transitions are weighted by semiring elements, the cost of a run is the product of the weights along the run, and the weight (annotation) of a tuple is the sum of costs of all the runs that produce the tuple. Again, there has been recent research that studies the connection between models of artificial neural networks in natural language processing and weighted automata <ref type="bibr" target="#b38">[39]</ref>. Our investigation answers several fundamental questions about K-weighted vset-automata: 1. Is this class closed under the positive relational algebra (according to the semantics of provenance semirings <ref type="bibr" target="#b19">[20]</ref>)? 2. What is the computational complexity of computing the annotation of a tuple? 3. Can we enumerate the annotated tuples as efficiently as we can do so for ordinary vset-automata (i.e., regular document spanners)? 4. In cases of numerical semirings (i.e., when K is a set of numbers), what is the complexity of enumerating the answers in ranked order by decreasing weight? Our answers are mostly positive, put the last question aside, and show that K-weighted vset-automata possess appropriate expressivity and tractability properties. As for the last question, we show that ranked enumeration is intractable and inapproximable for some of the aforementioned semirings (e.g., the probability and counting semirings), but tractable for positively ordered and bipotent semirings, such as the Viterbi semiring. Due to space constraints, we sometimes omit proofs or only provide a proof sketch.</p></div>
<div><head n="2">Preliminaries</head><p>Our annotators will read documents and produce annotated relations <ref type="bibr" target="#b19">[20]</ref>, which are relations in which each tuple is annotated with an element from a semiring. In this section we revisit the basic definitions and properties of annotated relations.</p></div>
<div><head>Semirings</head><p>A semiring (K, ⊕, ⊗, 0, 1) is an algebraic structure consisting of a set K, containing two distinguished elements: the zero element 0 and the unit element 1, and equipped with two binary operations, namely addition ⊕ and multiplication ⊗ such that: (K, ⊕) is a commutative monoid with identity element 0; 0 is absorbing for ⊗, i.e., 0 ⊗ a = a ⊗ 0 = 0. A semiring is called commutative if (K, ⊗) is commutative. We follow Green et al. <ref type="bibr" target="#b19">[20]</ref> and assume that a semiring is commutative if not stated otherwise. Furthermore, following Eilenberg <ref type="bibr" target="#b10">[11]</ref>, a semiring is positive if the following conditions hold:</p><formula xml:id="formula_0">I</formula><formula xml:id="formula_1">0 = 1, If a ⊕ b = 0, then a = 0 = b. If a ⊗ b = 0, then a = 0 or b = 0.</formula><p>An element a ∈ K is a zero divisor if a = 0 and there is an element b ∈ K with b = 0 and a ⊗ b = 0. Furthermore, an element a ∈ K has an additive inverse, if there is an element b ∈ K such that a ⊕ b = 0. In the following, we will also identify a semiring by its domain K if the rest is clear from the context. When we do this for numeric semirings such as R and N, we always assume the usual addition and multiplication.</p><p>Example 2.1. The following are examples for commutative semirings. It is easy to verify that all but the numeric semirings and the Łukasiewcz semiring are positive. 1. The numeric semirings (R, +, •, 0, 1) and (Z, +, •, 0, 1); 2. The counting semiring (N, +, •, 0, 1); 3. The Boolean semiring (B, ∨, ∧, false, true) where B = {true, false}; 4. The probability semiring (R + , +, •, 0, 1). <ref type="foot" target="#foot_0">1</ref> Rabin <ref type="bibr" target="#b32">[33]</ref> and Segala <ref type="bibr" target="#b39">[40]</ref> define probabilistic automata over this semiring, where all edge weights must be between 0 and 1 and the sum of all edge weights starting some state, labeled by the same label must be 1; 5. The Viterbi semiring ([0, 1], max, •, 0, 1) which is used in probabilistic parsing <ref type="bibr" target="#b8">[9]</ref>; 6. The access control semiring A = ({P &lt; C &lt; S &lt; T &lt; 0}, min, max, 0, P ), where P is "public", C is "confidential", S is "secret", T is "top secret", and 0 is "so secret that nobody can access it" <ref type="bibr" target="#b15">[16]</ref>; 7. The tropical semiring (N ∪ {∞}, min, +, ∞, 0) where min stands for the binary minimum function. This semiring is used in optimization problems of networks <ref type="bibr" target="#b8">[9]</ref>. 8. The Łukasiewcz semiring, whose domain is [0, 1], with addition given by x⊕y = max(x, y), with multiplication x ⊗ y = max(0, x + y -1), zero element 0, and unit 1. This semiring is used in multivalued logics <ref type="bibr" target="#b8">[9]</ref>.</p><p>Complexity-wise, we assume that single semiring elements can be stored in a single register and that addition and multiplication can be carried out in constant time -in similar spirit as the standard assumption for Random Access Machines. We use this assumption to simplify the analysis of algorithms.</p></div>
<div><head n="2.1">Annotated Relations</head><p>We assume infinite and disjoint sets D and Vars, containing data values (or simply values) and variables, respectively. Let V ⊆ Vars be a finite set of variables. A V -tuple is a function t : V → D that assigns values to variables in V . The arity of t is the cardinality |V | of V . For a subset X ⊆ Vars, we denote the restriction of t to the variables in X by t X. We denote the set of all the V -tuples by V -Tup. We sometimes leave V implicit when the precise set is not important. Let K be a set containing a distinguished element 0. A (K, D)-relation R over</p><formula xml:id="formula_2">V is a function R : V -Tup → K such that its support defined by supp(R) def = {t | R(t) = 0} is finite. The arity of a (K, D)-relation over V is |V |.</formula><p>When D is clear from the context or irrelevant, we also use K-relations to refer to (K, D)-relations.</p><p>Example 2.2. The bottom left table in Figure <ref type="figure" target="#fig_1">1</ref> shows an example (K, D)-relation, where K is the Viterbi semiring. The variables are x pers and x loc , so the V -tuples are described in the first two columns. The third column contains the element in K associated to each tuple.</p></div>
<div><head>Relational Algebra for Annotated Relations</head><p>Green et al. <ref type="bibr" target="#b19">[20]</ref> defined a set of operators on (K, D)-relations that naturally correspond to relational algebra operators and map K-relations to K-relations. Let (K, ⊕, ⊗, 0, 1) be a commutative semiring. The algebraic operators 2 union, projection, and natural join are defined in the usual way, for all finite sets V 1 , V 2 ⊆ Vars and for all K-relations R 1 over V 1 and R 2 over V 2 , as follows.</p><p>Union:</p><formula xml:id="formula_3">If V 1 = V 2 then the union R def = R 1 ∪ R 2 is a function R : V 1 -Tup → K defined by R(t) def = R 1 (t) ⊕ R 2 (t).</formula><p>(Otherwise, the union is not defined.)</p><formula xml:id="formula_4">Projection: For X ⊆ V 1 , the projection R def = π X R 1 is a function R : X-Tup → K defined by R(t) def = t=t X and R1(t ) =0 R 1 (t ). Natural Join: The natural join R def = R 1 R 2 is a function R : (V 1 ∪ V 2 )-Tup → K defined by R(t) def = R 1 (t 1 ) ⊗ R 2 (t 2 )</formula><p>where t 1 and t 2 are the restrictions t V 1 and t V 2 , respectively. Selection: If P is a selection predicate that maps each tuple in V 1 -Tup to either 0 or 1 then</p><formula xml:id="formula_5">R def = σ P (R 1 ) is a function R : V 1 -Tup → K defined by R(t) def = R 1 (t) ⊗ P(t).</formula><p>Proposition 2.3. <ref type="bibr" target="#b19">[20]</ref> The above operators preserve the finiteness of the supports and therefore they map K-relations into K-relations.</p><p>Hence, we obtain an algebra on K-relations.</p></div>
<div><head n="3">K-Annotators</head><p>We start by setting the basic terminology. We fix a finite alphabet Σ that is disjoint from  A span identifies a substring of a document d by specifying its bounding indices, that is, a span of d is an expression of the form [i, j where 1</p><formula xml:id="formula_6">Vars. A document is a finite sequence d = σ 1 • • • σ n where σ i ∈ Σ for each i = 1, . . . ,</formula><formula xml:id="formula_7">≤ i ≤ j ≤ n + 1. By d [i,j we denote the substring σ i • • • σ j-1 .</formula><p>In case i = j it holds that d [i,j is the empty string, which we denote by ε. We denote by Spans(d) the set of all possible spans of a document d and by Spans the set of all possible spans of all possible documents. Since we will be working with relations over spans, we assume that D is such that Spans ⊆ D. A (K, d)-relation over V ⊆ Vars is defined analogously to a (K, D)-relation over V but only uses V -tuples with values from Spans(d).</p><p>Definition 3.1. Let (K, ⊕, ⊗, 0, 1) be a semiring. A K-annotator (or annotator for short), is a function S that is associated with a finite set V ⊆ Vars of variables and maps documents d into (K, d)-relations over V . We denote V by Vars(S). We sometimes also refer to an annotator as an annotator over (K, ⊕, ⊗, 0, 1) when we want to emphasize the semiring.</p><p>Notice that B-annotators, i.e., annotators over (B, ∨, ∧, false, true) are simply the document spanners as defined by Fagin et al. <ref type="bibr" target="#b12">[13]</ref>.</p><p>Example 3.2. We provide an example document d in Figure <ref type="figure" target="#fig_1">1 (top)</ref>. The table at the bottom right depicts a possible (K, d)-relation obtained by a spanner that extracts (person, hometown) pairs from d. Notice that for each span [i, j occurring in this table, the string d [i,j can be found in the table to the left.</p><p>In this naïve example, which is just to illustrate the definitions, we used the Viterbi semiring and annotated each tuple with (0.9) k , where k is the number of words between the spans associated to x pers and x loc . The annotations can therefore be interpreted as confidence scores.</p></div>
<div><head>Relational Algebra for K-Annotators</head><p>We now lift the relational algebra operators on K-relations to the level of K-annotators. For all documents d and for all annotators S 1 and S 2 associated with V 1 and V 2 , respectively, we define the following:</p><formula xml:id="formula_8">Union: If V 1 = V 2 then the union S def = S 1 ∪ S 2 is defined by S(d) def = S 1 (d) ∪ S 2 (d). 3 Projection: For X ⊆ V 1 , the projection S def = π X S 1 is defined by S(d) def = π X S 1 (d).</formula><p>Natural Join: The natural join</p><formula xml:id="formula_9">S def = S 1 S 2 is defined by S(d) def = S 1 (d) S 2 (d).</formula><p>String selection: Let R be a k-ary string relation. The string-selection operator σ R is parametrized by k variables x 1 , . . . , x k in V 1 and may be written as σ R x1,...,x k . Then the annotator</p><formula xml:id="formula_10">S def = σ R x1,...,x k S 1 is defined as S(d) def = σ P (S 1 (d))</formula><p>where P is a selection predicate with P(t) = 1 if (d t(x1) , . . . , d t(x k ) ) ∈ R; and P(t) = 0 otherwise. Due to Proposition 2.3 it follows that the above operators form an algebra on K-annotators.</p></div>
<div><head>4</head><p>Weighted Variable-Set Automata</p><p>In this section, we define the concept of a weighted vset-automaton as a formalism to represent K-annotators. This formalism is the natural generalization of vset-automata <ref type="bibr" target="#b12">[13]</ref> and weighted automata <ref type="bibr" target="#b9">[10]</ref>. Later in this section, we also present a formalism that is based on parametric factors, and a specification can be translated into a weighted vset-automaton (Section 4.1). Let V ∈ Vars be a finite set of variables. Furthermore, let Γ V = {v , v | v ∈ V } be the set of variable operations. 4 Let (K, ⊕, ⊗, 0, 1) be a semiring. A weighted variable-set automaton over semiring K (alternatively, a weighted vset automaton or a K-weighted vsetautomaton) is a tuple</p><formula xml:id="formula_11">A def = (V, Q, I, F, δ) where V ⊆ Vars is a finite set of variables; Q is a finite set of states; I : Q → K is the initial weight function; F : Q → K is the final weight function; and δ : Q × (Σ ∪ {ε} ∪ Γ V ) × Q → K is a (K-weighted) transition function.</formula><p>We define the transitions of A as the set of triples (p, o, q) with δ(p, o, q) = 0. Likewise, the initial (resp., accepting) states are those states q with I(q) = 0 (resp., F (q) = 0). A run</p><formula xml:id="formula_12">ρ of A over a document d def = d 1 • • • d n is a sequence (q 0 , i 0 ) o1 → • • • (q m-1 , i m-1 ) om-1 → (q m , i m )</formula><p>where i 0 = 1, i m = n + 1, and i j ∈ {1, . . . , n} for each j ∈ {1, . . . , m -1}; each o j is in Σ ∪ {ε} ∪ Γ V ; i j+1 = i j whenever o j ∈ {ε} ∪ Γ V and i j+1 = i j + 1, otherwise; δ(q j , o j , q j+1 ) = 0 for all j ≥ 0.</p><p>The weight of a run is obtained by ⊗-multiplying the weights of its constituent transitions. Formally, the weight w ρ of ρ is an element in K given by the expression</p><formula xml:id="formula_13">I(q 0 ) ⊗ δ(q 0 , o 1 , q 1 ) ⊗ • • • ⊗ δ(q m-1 , o m-1 , q m ) ⊗ F (q m ) .</formula><p>We call ρ nonzero if w ρ = 0. Notice that ρ is nonzero only if q 0 and q m are initial and final, respectively. A run is called valid if for every variable v ∈ V the following hold: there is exactly one index i for which o i = v and exactly one index j ≥ i for which o j = v.</p><p>For a nonzero and valid run ρ, we define t ρ as the V -tuple that maps each variable v ∈ V to the span [i j , i j where o ij = v and o i j = v. We denote the set of all valid and nonzero runs of A on d by P (A, d). We naturally extend the notion of functionality to apply also to general (not necessarily Boolean) weighted vset-automata. A weighted functional vset-automaton is a weighted vset-automaton whose runs are all valid. 5  Notice that there may be infinitely many nonzero and valid runs of a weighted vsetautomaton on a given document, due to ε-cycles, which are sets of states {q 1 , . . . , q k } such that (q i , ε, q i+1 ) is a transition for every i ∈ {1, . . . , k -1}. Similar to much of the standard 4 The operation v represents opening variable v and v represents closing v. 5 Notice that, while our notion of functionality indeed generalizes the notion on B-weighted vset-automata <ref type="bibr" target="#b12">[13]</ref>, one needs positivity of K to ensure that a functional automaton has an output tuple for every valid run.</p><p>I C D T 2 0 2 0 8:8</p><p>Weight Annotation in Information Extraction q 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 10 1 Σ ; 1 ; 1 Σ ; 1</p><p>x pers ; 1</p><p>Pers; 1 x pers ; 1 ; 1 Σ ; 1 ; 0.9 Σ ; 1</p><p>x loc ; 1</p><p>Loc; 1</p><formula xml:id="formula_14">x loc ; 1 ; 1 Σ; 1 1 1 Figure 2</formula><p>An example weighted vset-automaton over the Viterbi semiring with initial state q0 and two final states q9, q10. Σ = Σ \ { }, Pers and Loc are sub-automata matching person and location names respectively. All edges, including the edges of the sub-automata, have the weight 1 besides the transition from q6 to q5 with weight 0.9.</p><p>literature on weighted automata (see, e.g., <ref type="bibr" target="#b11">[12]</ref>) we will assume that weighted vset-automata do not have ε-cycles, unless mentioned otherwise. The reason for this restriction is that automata with such cycles need K to be closed under infinite sums for their semantics to be well-defined. <ref type="foot" target="#foot_2">6</ref>As such, if A does not have ε-cycles, then the result of applying A on a document d,</p><formula xml:id="formula_15">denoted A K (d), is the (K, d)-relation R for which R(t) def = ρ∈P (A,d) and t=tρ w ρ .</formula><p>Note that we only use runs ρ that are valid and nonzero here. Observe that if t is a V -tuple with V = V then R(t) = 0. In addition, A K is well defined since every V -tuple in the support of A K (d) is a V -tuple over Spans(d). The size |A| of a weighted vset-automaton A is its number of states plus its number of transitions.</p><p>We say that a K-annotator S is regular if there exists a weighted vset-automaton A such that S = A K . Similar to our terminology on annotators, we use the term B-weighted vset-automata to refer to the "classical" vset-automata of Fagin et al. <ref type="bibr" target="#b12">[13]</ref>, which are indeed weighted vset-automata over the Boolean semiring.</p><p>Example 4.1. Figure <ref type="figure">2</ref> shows an example weighted vset-automaton over the Viterbi semiring, which is intended to extract (person, hometown)-tuples from a document. Here, "Pers" and "Loc" should be interpreted as sub-automata that test if a string could be a person name or a location. (Such automata can be compiled from publicly available regular expressions <ref type="foot" target="#foot_3">7</ref> and from deterministic rules and dictionaries as illustrated in <software ContextAttributes="used">SystemT</software> <ref type="bibr" target="#b3">[4]</ref>.)</p><p>The relation extracted by this automaton from the document in Figure <ref type="figure" target="#fig_1">1</ref> is exactly the annotated span relation of the same figure. The weight of a tuple t depends on the number of spaces occurring between the span captured by x pers and the span captured by x loc . More specifically the automaton assigns the weight (0.9) k to each tuple, where k is the number of words between the two variables.</p></div>
<div><head n="4.1">Annotators via Parametric Factors</head><p>We now describe another way of introducing weights (or softness) in document spanners. This section can also be seen as an additional motivation for K-annotators. Indeed, we will show that, if softness is introduced in document spanners <ref type="bibr" target="#b12">[13]</ref> (i.e., B-annotators) in the standard manner that we recall here, the resulting annotators can be captured in our framework.</p><p>Softness can be introduced in document spanners via the concept of parametric factors, which is a very common concept that is used in a wide range of contexts. Examples are the soft keys of Jha et al. <ref type="bibr" target="#b20">[21]</ref>, the PrDB model of Sen et al. <ref type="bibr" target="#b40">[41]</ref>, the probabilistic unclean databases of De Sa et al. <ref type="bibr" target="#b35">[36]</ref> which can be viewed as a special case of the Markov Logic Network (MLN) <ref type="bibr" target="#b34">[35]</ref>. Intuitively, a parametric factor is a succinct expression of numerical factors of a probability via weighted rules: whenever the rule fires, a corresponding factor (determined by the weight) is added to the product that constitutes the probability. What we want to show in this section is that, if one has rules that involve B-annotators, and one adds uncertainty or softness to these rules in this standard way -using parametric factorsthen the obtained formalism naturally leads to K-annotators.</p><p>Next, we give the precise definition of a soft spanner and show that, when the factors are regular, a soft spanner can be translated into a weighted vset-automaton.</p><p>Formally, a soft spanner is a triple Q = (P, S, w), where: P is a document spanner, i.e., a B-annotator, S is a finite set of document spanners referred to as the factor spanners, and w : S → R assigns a (positive or negative) numerical value to each factor spanner. Given a document d, the soft spanner Q assigns to each t ∈ P (d) a probability as follows:</p><formula xml:id="formula_16">Q(d, t) def = exp   S∈S u∈{t} S(d) w(S)   = S∈S e w(S)•|{t} S(d)| , Q(d, t) def = Q(d, t)/Z(d),</formula><p>where Z(d) is a normalization factor (or the partition function) defined in the usual way:</p><formula xml:id="formula_17">Z(d) = t∈P (d) Q(d, t)</formula><p>Note that {t} S(d) is the join of the relation S(d) with the relation that consists of the single tuple t. Hence, |{t} S(d)| is the number of tuples t ∈ S(d) that are compatible (joinable) with t, that is, t(x) = t (x) whenever x is in the domain of both t and t .</p><p>Example 4.2. The same relation as discussed in Example 4.1 can also be extracted using a soft spanner Q = (P, {S}, w). To this end, P is a boolean spanner extracting (person, hometown)-tuples; S is the spanner, extracting (x pers , y, x loc )-triples of words, where y matches a word between x pers and x loc ; and the weight function w is the function assigning w(S) = log(0.9). Note that S simply extracts words and does not test whether the words matched by x pers or x loc correspond to a person or location.</p><p>We therefore see that K-annotators can also be defined by applying the standard technique of parametric factors to document spanners. In fact, as we will see next, soft spanners can be compiled into weighted vset-automata, which serves as an additional motivation for weighted vset-automata. To prove the result, we use closure properties of weighted vset-automata that we will obtain further in the paper (so the proof can be seen as a motivation for the closureand computational properties of weighted vset-automata as well).</p><p>For the following result, we say that a K-weighted vset-automaton A is unambiguous if, for every document d and every tuple t ∈ A K (d), there exists exactly one valid and nonzero run ρ of A on d such that t = t ρ .</p></div>
<div><head>I C D T 2 0 2 0 8:10</head><p>Weight Annotation in Information Extraction Theorem 4.3. Let Q = (P, S, w) be a soft spanner such that P and every S ∈ S is regular. There exists an R-weighted vset-automaton A such that A R (d)(t) = log( Q(d, t)) for all documents d and tuples t; Moreover, if the spanners of Q are represented as unambiguous functional vset-automata, then A can be constructed in polynomial time in the size of Q.</p><p>Proof sketch. Let P u be an unambiguous version of P , interpreted as an R-weighted vsetautomaton where true is associated with 1 and false with 0 and let V P be the variables of P . Let S u be an unambiguous version of S. From S u we compute a weighted vset-automaton S w u by interpreting it as an R-weighted vset-automaton and assigning to each accepting state q of S u the weight F (q) = w(S). Then the automaton we need for computing log( Q(d, t)) is</p><formula xml:id="formula_18">A = S∈S π V P (P u S w u ) .</formula><p>We show correctness, i.e., log( Q(d, t)) = A R (d)(t). Due to P u and S w u being unambiguous, it follows directly that P u S w u has exactly one accepting run with weight w(S) for every tuple t ∈ P u S w u R (d). Per definition of union and projection, it follows that <ref type="figure">Q(d,</ref><ref type="figure">t</ref>)). As we will obtain in Theorem 5.5, automaton A can be represented as an R-weighted vset-automaton and can be constructed in PTIME, which concludes the proof.</p><formula xml:id="formula_19">A R (d)(t) = S∈S u∈{t} S(d) w(S) = log(</formula></div>
<div><head n="5">Fundamental Properties</head><p>We now study fundamental properties of annotators. Specifically, we will show that regular annotators are closed under union, projection, and join. Furthermore, annotators over positive semirings are closed under exactly the same string relations as document spanners. We begin the section by showing that every regular K-annotator can be transformed into an equivalent functional regular K-annotator without ε-transitions. We say that two vset-automata A and A are equivalent if A K = A K .</p></div>
<div><head>Proposition 5.1. For every weighted vset-automaton A there is an equivalent weighted vset-automaton A that has no ε-transitions. This automaton A can be constructed from A in PTIME. Furthermore, A is functional if and only if A is functional.</head><p>Notice that non-functional vset-automata can be inconvenient to work with, since some of their nonzero runs are not valid and therefore do not contribute to the weight of a tuple. It is therefore desirable to be able to automatically convert weighted vset-automata into functional weighted vset-automata.</p></div>
<div><head>Proposition 5.2. Let A be a weighted vset-automaton. Then there is a functional weighted vset-automaton A fun that is equivalent to A. If A has n states and uses k variables, then A fun can be constructed in time polynomial in n and exponential in k.</head><p>The exponential blow-up in Proposition 5.2 cannot be avoided, since Freydenberger [17, Proposition 3.9] showed that there is a vset-automaton A (over B) with one state and k variables, such that every equivalent functional vset-automaton has at least 3 k states. Functionality of vset-automata can be checked efficiently, as we have the following result.</p></div>
<div><head>Proposition 5.3. Given a weighted vset-automaton A with m transitions and k variables, it can be decided whether A is functional in time O(km).</head><p>Observation 5.4 ((Similar to Freydenberger et al. <ref type="bibr" target="#b17">[18]</ref>)). Let A def = (V, Q, I, F, δ) be a K-weighted functional vset-automaton. Then there exists a function C : Q × V → {w, o, c} that maps every state to its variable configuration, i.e., C(q, x) ∈ {w, o, c} depending on whether x is waiting, open, or closed in state q. More formally, the function</p><formula xml:id="formula_20">C(q, v) =       </formula><p>w there is a nonzero run where v does not occur before reaching q, o there is a nonzero run where v but not v occur before reaching q, c there is a nonzero run where v and v occur before reaching q.</p><p>is well-defined. Indeed, if C would not be well-defined, then two conflicting runs would contradict the functionality of A.</p></div>
<div><head n="5.1">Closure Under Join, Union, and Projection</head><p>Here we obtain the following result.</p><p>Theorem 5.5. Regular annotators are closed under union, projection, and natural join.</p><p>Whereas union and projection are fairly standard, the case of join needs some care in the case that the two automata A 1 and A 2 process variable operations in different orders. (I.e., if A 1 processes x y a y x and A 2 processes y x a x y, then these two different sequences produce the same result. The automata construction has to deal with this.) One can also show that, if the annotators are given as functional weighted vset-automata, then the construction for a single union, projection, and join can be done in polynomial time. Furthermore, the constructions preserve functionality.</p></div>
<div><head n="5.2">Closure under String Selection</head><p>A k-ary string relation is recognizable if it is a finite union of Cartesian products of regular string languages <ref type="bibr" target="#b36">[37]</ref>. Let REG K be the set of regular K-annotators. We say that a k-ary string relation R is selectable by regular K-annotators if the following equivalence holds:</p><formula xml:id="formula_21">REG K = {σ R x1,.</formula><p>..,x k (S) | S ∈ REG K and x i ∈ Vars(S) for all 1 ≤ i ≤ k} , that is, the class of K-annotators is closed under selection using R. If K = B, we say that R is selectable by document spanners. Fagin et al. <ref type="bibr" target="#b12">[13]</ref> proved that a string relation is recognizable if and only if it is selectable by document spanners. Here, we generalize this result in the context of weights and annotation. Indeed, it turns out that the equivalence is maintained for all positive semirings. Theorem 5.6. Let (K, ⊕, ⊗, 0, 1) be a positive semiring and R be a string relation. The following are equivalent:</p><formula xml:id="formula_22">(1) R is recognizable. (2) R is selectable by document spanners. (3) R is selectable by K-annotators.</formula><p>Proof sketch. The equivalence between (1) and ( <ref type="formula">2</ref>) is known <ref type="bibr" target="#b12">[13,</ref><ref type="bibr">Theorem 4.16]</ref>. The proof (2) ⇒ (3) is heavily based on the closure properties from Theorem 5.5 and does not use positivity of the semiring. For (3) ⇒ (2) we use semiring morphisms to turn K-weighted vset-automata into B-weighted vset-automata and need positivity of the semiring.</p><p>Since the implication from (2) to (3) does not assume positivity of the semiring, it raises the question if the equivalence can be generalized even further. One can show that this is indeed the case, such as for the Łukasiewicz semiring, which is not positive. </p></div>
<div><head n="6">Evaluation Problems</head><p>We consider two types of evaluation problems in this section: answer testing and best weight evaluation. The former is given an annotator, document d, and tuple t; and computes the annotation of t in d according to the annotator. The latter does not receive the tuple as input, but recieves a weight threshold and is asked whether there exists a tuple that is returned with a weight that is at least the threshold.</p></div>
<div><head n="6.1">Answer Testing</head><p>It follows from Freydenberger [17, Lemma 3.1] that answer testing is NP-complete for B-weighted vset-automata in general. Indeed, he showed that, given a B-weighted vsetautomaton A, it is NP-complete to check if A returns any output on the empty document ε, so it is even NP-complete to check if the tuple of empty spans is returned or not. However, the proof makes extensive use of non-functionality of the automaton. Indeed, we can prove that answer testing is tractable for functional weighted vset-automata.</p><p>Theorem 6.1. Given a functional weighted vset-automaton A, a document d, and a tuple t, the weight A K (d)(t) assigned to t by A on d can be computed in PTIME.</p><p>Proof sketch. Let A, d, and t be as stated. Per definition, the weight assigned to t by A is</p><formula xml:id="formula_23">A K (d)(t) def = ρ∈P (A,d) and t=tρ w ρ .</formula><p>Therefore, in order to compute the weight A K (d)(t), we need to consider the weights of all runs ρ for which t = t ρ . Furthermore, multiple runs can select the same tuple t but assign variables in a different order. <ref type="foot" target="#foot_4">8</ref>We first define an automaton A t , such that A t K (d)(t ) = 1 if t = t and A t K (d)(t ) = 0 otherwise. Such an automaton A t can be defined using a chain of |d| + 2|V | + 1 states, which checks that the input document is d and which has exactly one nonzero run ρ, with w ρ = 1 and t ρ = t. By Theorem 5.5 there is a weighted vset-automaton A such that</p><formula xml:id="formula_24">A K = A A t K . It follows directly from the definition of A that A K (d)(t) = A K (d)(t)</formula><p>. Furthermore, all accepting runs ρ ∈ P (A , d) have length |d| + 2|V |. Therefore, the weight A K (d)(t) can be obtained by taking the sum of the weights of all accepting runs of A . If we assume w.l.o.g. that the states of A are {1, . . . , n} for some n ∈ N, then this sum can be computed as</p><formula xml:id="formula_25">A K (d)(t) = v I × (M δ ) |d|+2|V | × (v F ) T ,</formula><p>where v I is the vector (I(1), . . . , I(n)), M δ is the n × n matrix with M δ (i, j) = a∈Σ δ(i, a, j), and (v F ) T is the transpose of vector v F = (F (1), . . . , F (n)). Since n is polynomial in the input, this product can be computed in polynomial time.</p></div>
<div><head n="6.2">Best Weight Evaluation</head><p>In many semirings, the domain is naturally ordered by some relation. For instance, the domain of the probability semiring is R + , which is ordered by the ≤-relation. This motivates evaluation problems where we are interested in some kind of optimization of the weight, which we will look into in this section. Definition 6.2 ((Dorste and Kuich <ref type="bibr" target="#b8">[9]</ref>)). A commutative monoid (K, ⊕, 0) is ordered if it is equipped with a partial order preserved by the ⊕ operation. An ordered monoid is positively ordered if 0 a for all a ∈ K. A semiring (K, ⊕, ⊗, 0, 1) is (positively) ordered if the additive monoid is (positively) ordered and multiplication with elements 0 a preserves the order.</p><p>We consider the following two problems.</p></div>
<div><head>Threshold</head></div>
<div><head>Given:</head><p>Regular annotator A over an ordered semiring, document d ∈ Docs, and a weight w ∈ K. Question: Is there a tuple t with w A K (d)(t)?</p></div>
<div><head>MaxTuple</head><p>Given: Regular annotator A over an ordered semiring and a document d ∈ Docs.</p><p>Task: Compute a tuple with maximal weight, if it exists.</p><p>Notice that, if MaxTuple is efficiently solvable, then so is Threshold. We therefore prove upper bounds for MaxTuple and lower bounds for Threshold. The Threshold problem is sometimes also called the emptiness problem in the weighted automata literature. It turns out that, for positively ordered semirings that are bipotent (that is, a ⊕ b ∈ {a, b}), both problems are tractable. Theorem 6.3. Let (K, ⊕, ⊗, 0, 1) be a positively ordered, bipotent semiring. Furthermore, let A be a functional K-weighted vset-automaton and let d ∈ Docs be a document. Then MaxTuple for A and d can be solved in PTIME.</p><p>Proof sketch. Since a ⊕ b ∈ {a, b} for every a, b ∈ K, the weight of a tuple t ∈ A K (d) is always equal to the weight of one of the accepting runs ρ with t = t ρ . Thus in order to find the tuple with maximal weight, we need to find the run of A on d with maximal weight. This boils down to finding a maximal weight path in a DAG, which is obtained by taking a "product" between A and d.</p><p>If the semiring is not bipotent, however, the Threshold and MaxTuple problems become intractable quickly. Theorem 6.4. Let (K, ⊕, ⊗, 0, 1) be a semiring such that m i=1 1 is strictly monotonously increasing for increasing values of m. Futhermore let A be a functional K-weighted vsetautomaton, let d ∈ Docs be a document, and k ∈ K be a weight threshold. Then Threshold for such inputs is NP-complete.</p><p>Proof sketch. It is obvious that Threshold is in NP, as one can guess a tuple t and and test in PTIME whether w A K (d)(t) using Theorem 6.1. For the NP-hardness, we will reduce from MAX-3SAT. To this end, let ψ = C 1 ∧ • • • ∧ C m be a boolean formula in 3CNF over variables x 1 , . . . , x n such that each clause</p><formula xml:id="formula_26">C i = ( i,1 ∨ i,2 ∨ i,3 ) is a disjunction of exactly three literals i,j ∈ {x c , ¬x c | 1 ≤ c ≤ n}, 1 ≤ i ≤ k, 1 ≤ j ≤ 3.</formula><p>I C D T 2 0 2 0 8:14 Weight Annotation in Information Extraction</p><formula xml:id="formula_27">q 1,1 1,1 q 1,2 1,1 q 1,3 1,1 q 1,4 1,1 q 1,5 1,1 x 1 x 1 a x 1 x 1 q 1,2 1,2 q 1,3 1,2 q 1,4 1,2 q 1,5 1,2 x 2 x 2 a x 2 x 2 q 1,2 1,3 q 1,3 1,3 q 1,4 1,3 q 1,5 1,3 x 3 x 3 a a x 3 x 3 ∨ ¬x 3 q 1,2 1,4 q 1,3 1,4 q 1,4</formula><p>1,4</p><p>q 1,5  W.l.o.g., we can assume that no clause has two literals corresponding to the same variable.</p><p>Observe that for each clause C i there are 2 3 = 8 assignments of the variables corresponding to the literals of C i of which exactly 7 satisfy the clause C i . Formally, let f Ci be the function that maps a variable assignment τ to a number between 1 and 8, depending on the assignments of the literals of the clause C i . W.l.o.g., we can assume that f Ci (τ ) = 8 iff C i is not satisfied by τ . We will define a functional weighted automaton automaton A ψ over the unary alphabet Σ = {a} such that A ψ K (a n )(t) = m i=1 1 if and only if the assignment corresponding to t satisfies exactly m clauses in ψ and A ψ K (d) = ∅ if d = a n . To this end, each variable x i of ψ is associated with a corresponding capture variable x i of A ψ . We associate a tuple t τ with every assignment τ such that</p><formula xml:id="formula_28">t τ (x i ) = [i, i if τ (x i ) = 0, and [i, i + 1 if τ (x i ) = 1.</formula><p>The automaton A ψ def = (V, Q, I, F, δ) consists of m disjoint branches, where each branch corresponds to a clause of ψ; we call these clause branches. Each clause branch is divided into 7 sub-branches, such that a path in the sub-branch j corresponds to a variable assignment τ if f Ci (τ ) = j. Thus, each clause branch has exactly one run ρ with weight 1 for each tuple t τ associated to a satisfying assignment τ of C i .</p><p>More formally, the set of states</p><formula xml:id="formula_29">Q = {q a,b i,j | 1 ≤ i ≤ m, 1 ≤ j ≤ n, 1 ≤ a ≤ 7, 1 ≤ b ≤ 5} contains 5n</formula><p>states for every of the 7 sub-branches of each clause branch. Intuitively, A ψ has a gadget, consisting of 5 states, for each variable and each of the 7 satisfying assignments of each clause. Figure <ref type="figure">4</ref> depicts the three types of gadgets we use here. Note that the weights of the drawn edges are all 1. We use the left gadget if x does not occur in the relevant clause and the middle (resp., right) gadget if the literal ¬x (resp., x) occurs. Furthermore, within the same sub-branch of A ψ , the last state of each gadget is the same state as the start state of the next variable, i.e., q a,5 i,j = q a,1 i,j+1 for all 1 ≤ i ≤ k, 1 ≤ j &lt; n, 1 ≤ a ≤ 7. We illustrate the crucial part of the construction on an example. Let ψ = (x 1 ∨ ¬x 2 ∨ x 4 ) ∧ (x 2 ∨ x 3 ∨ x 4 ). The corresponding weighted vset-automaton A ψ therefore has 14 = 2 × 7 disjoint branches. Figure <ref type="figure">3</ref> depicts the sub-branch for clause C 1 that corresponds to all assignments with x 1 = x 2 = 1 and x 4 = 0.</p><p>We note that Theorem 6.3 and Theorem 6.4 give us tight bounds for all semirings we defined in Example 2.1.</p><p>Since MAX-3SAT is hard to approximate, we can turn Theorem 6.4 into an even stronger inapproximability result for semirings where approximation makes sense. To this end, we focus on semirings that contain (N, +, •, 0, 1) (as a sub-semiring) in the following result. Theorem 6.5. Let K be a semiring that contains (N, +, •, 0, 1) and let A be a weighted vset-automaton over K. Unless PTIME = NP, there is no algorithm that approximates the tuple with the best weight within a sub-exponential factor in PTIME.</p></div>
<div><head n="7">Enumeration Problems</head><p>In this section we consider computing the output of annotators from the perspective of enumeration problems, where we try to enumerate all tuples with nonzero weight, possibly from large to small. Such problems are highly relevant for (variants of) vset-automata, as witnessed by the recent literature on the topic <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b14">15]</ref>. We assume familiarity with terminology in enumeration algorithms such as preprocessing time and delay. If the order of the answers does not matter and the semiring is positive, we can guarantee a constant delay enumeration algorithm with linear preprocessing time. We now consider cases in which answers are required to arrive in a certain ordering.</p><p>Ranked Annotator Enumeration (RA-Enum)</p><p>Given: Regular functional annotator A over an ordered semiring (K, ⊕, ⊗, 0, 1) and a document d.</p></div>
<div><head>Task:</head><p>Enumerate all tuples t ∈ A K (d) in descending order on K.</p><p>Theorem 7.2. Let (K, ⊕, ⊗, 0, 1) be an positively ordered, bipotent semiring, let A be a functional K-weighted vset-automaton, and let d ∈ Docs be a document. Then RA-Enum can be solved with polynomial delay and preprocessing.</p><p>Proof sketch. Our algorithm is a slight adaptation of Yen's algorithm <ref type="bibr" target="#b47">[48]</ref>. To this end, we will use the DAG we defined in the proof of Theorem 6.3, but invest a bit more preprocessing. In particular, we change the DAG so that it has a one-to-one correspondence between output tuples and some of its paths. Using this correspondence, we can then revert to Yen's algorithm for enumerating simple paths in graphs.</p></div>
<div><head n="8">Concluding Remarks</head><p>We embarked on a study that incorporates annotations or weights in information extraction and propose K-annotators as a candidate formalism to study this problem. The K-annotators can be instantiated with weighted vset-automata, thereby obtaining regular K-annotators, which are powerful enough to capture the extension of the traditional spanner framework with parametric factors. Furthermore, the regular K-annotators have favorable closure properties, such as closure under union, projection, natural join, and string selection using regular I C D T 2 0 2 0</p></div>
<div><head>8:16</head><p>Weight Annotation in Information Extraction relations. The first complexity results on evaluation problems are encouraging: answer testing is tractable and, depending on the semiring, problems such as the threshold problem, the max tuple problem, and enumeration of answers are tractable too. We note that the addition of weights to vset-automata also introduces new challenges. For instance, some typical questions that we study in database theory are not yet fully understood for weighted automata, which are the basis of weighted vset-automata. Examples are equivalence and emptiness. Concerning equivalence, one can show that equivalence is undecidable for weighted vset-automata over the tropical semiring, using techniques from Krob <ref type="bibr" target="#b22">[23]</ref> or Almagor et al. <ref type="bibr" target="#b0">[1]</ref>. In however, it is not completely clear for which semirings equivalence is decidable or not.</p><p>The emptiness problem that is usually studied in the weighted automata literature does not ask if there exists a document d such that the automaton returns at least one tuple with nonzero weight on d, but is additionally given a threshold (as in our Threshold problem) and asks if the automaton returns a tuple with at least the threshold weight (which requires an order on the semiring). It is not yet clear how much this threshold influences the complexity of the problem.</p><p>An additional challenge is that determinization of weighted automata is a complex matter and not always possible. It is well-known to be possible for the Boolean semiring but, for the tropical semiring, i.e., (R ∪ {-∞}, max, +, -∞, 0), deterministic weighted automata are strictly less expressive than unambiguous weighted automata, which are strictly less expressive than general weighted automata, cf. Klimann et al. <ref type="bibr" target="#b21">[22]</ref>.</p><p>A possible direction for further exploration could be the study of annotators which use regular cost functions (cf. Colcombet <ref type="bibr" target="#b5">[6]</ref>) instead of weighted automata. Since regular cost functions are restructed to the domain of the natural numbers, this would probably be most interesting in the case where the semiring domain is (a subset of) the natural numbers. Indeed, in this case, it is known that regular cost functions are strictly more expressive than weighted automata over the tropical semiring (cf. Colcombet et al. <ref type="bibr" target="#b6">[7]</ref>) and therefore could provide a useful tool to annotate document spanners. On the other hand, it is not yet clear to us how to associate regular cost functions in a natural way to annotated relations, which require semirings.</p></div><figure xml:id="fig_0"><head /><label /><figDesc>⊗) is a monoid with identity element 1; multiplication distributes over addition, i.e., (a ⊕ b) ⊗ c = (a ⊗ c) ⊕ (b ⊗ c) and c ⊗ (a ⊕ b) = (c ⊗ a) ⊕ (c ⊗ b);</figDesc></figure>
<figure xml:id="fig_1"><head>Figure 1 A</head><label>1</label><figDesc>Figure 1 A document (top), a (K, D)-relation (bottom left), and an extracted annotated span relation (bottom right).</figDesc></figure>
<figure xml:id="fig_3"><head>Figure 3 Figure 4</head><label>34</label><figDesc>Figure 3 The sub-branch of A ψ corresponding to C1 and x1 = x2 = 1, x4 = 0.</figDesc></figure>
<figure xml:id="fig_4"><head>Theorem 7 . 1 .</head><label>71</label><figDesc>Given a weighted functional vset-automaton A over a positive semiring K, and a document d, the K-Relation A K (d) can be enumerated with preprocessing linear in |d| and polynomial in |A| and delay constant in |d| and polynomial in |A|. Note that the proof of the theorem essentially requires to go through the entire proof of the main result of Amarilli et al. [2, Theorem 1.1].</figDesc></figure>
<figure type="table" xml:id="tab_0"><head>2 0 8:6 Weight Annotation in Information Extraction</head><label /><figDesc>2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67</figDesc><table><row><cell>xpers</cell><cell>x loc</cell><cell>annotation</cell><cell>xpers</cell><cell>x loc</cell><cell>annotation</cell></row><row><cell>Carter</cell><cell>Plains, Georgia</cell><cell>0.9</cell><cell>[1, 7</cell><cell>[13, 28</cell><cell>0.9</cell></row><row><cell cols="2">Washington Westmoreland, Virginia</cell><cell>0.9</cell><cell>[30, 40</cell><cell>[46, 68</cell><cell>0.9</cell></row><row><cell>Carter</cell><cell>Georgia, Washington</cell><cell>0.81</cell><cell>[1, 7</cell><cell>[21, 40</cell><cell>0.81</cell></row><row><cell>Carter</cell><cell>Westmoreland, Virginia</cell><cell>0.59049</cell><cell>[1, 7</cell><cell>[46, 68</cell><cell>0.59049</cell></row></table><note><p><p><p><p><p><p><p>n. By Docs we denote the set of all documents. A (k-ary) string relation is a subset of Docs k for some k ∈ N.</p>2 </p>As in much of the work on semirings in provenance, e.g. Green et al.</p><ref type="bibr" target="#b19">[20]</ref></p>, we do not yet consider the difference operator (which would require additive inverses).</p>I C D T 2 0</p>C a r t e r f r o m P l a i n s , G e o r g i a , W a s h i n g t o n f r o m W e s t m o r e l a n d , V i r g i n i a 1</p></note></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>One may expect the domain to be [0, 1], but this is difficult to obtain while maintaining the semiring properties. For instance, defining a ⊕ b as min{a + b, 1} would violate distributivity.</p></note>
			<note place="foot" n="3" xml:id="foot_1"><p>Here, ∪ stands for the union of two K-relations as was defined previously. The same is valid also for the other operators.</p></note>
			<note place="foot" n="6" xml:id="foot_2"><p>The semirings need to fulfill additional properties as well such as distributivity, commutativity and associativity must also hold for infinite sums. Such semirings are called complete<ref type="bibr" target="#b27">[28]</ref>.</p></note>
			<note place="foot" n="7" xml:id="foot_3"><p>For example, http://regexlib.com/.</p></note>
			<note place="foot" n="8" xml:id="foot_4"><p>This may happen when variable operations occur consecutively, i.e., without reading a symbol in between.</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>Funding This work was supported by the <rs type="funder">German-Israeli Foundation for Scientific Research and Development (GIF)</rs>, grant <rs type="grantNumber">I-1502-407.6/2019</rs>. The work of <rs type="person">Johannes Doleschal</rs> and <rs type="person">Wim Martens</rs> was also supported by the <rs type="funder">Deutsche Forschungsgemeinschaft (DFG)</rs>, grant <rs type="grantNumber">MA 4938/4-1</rs>. The work of <rs type="person">Benny Kimelfeld</rs> and <rs type="person">Liat Peterfreund</rs> was also supported by the <rs type="funder">Israel Science Foundation (ISF)</rs>, grants <rs type="grantNumber">1295/15</rs> and <rs type="grantNumber">768/19</rs>, and the <rs type="funder">DFG</rs> project <rs type="grantNumber">412400621</rs> (<rs type="programName">DIP program</rs>). <rs type="person">Liat Peterfreund</rs>: A part of the work was donewhile the author was affiliated with the <rs type="institution">Technion</rs>. for many useful discussions and his help regarding</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_4WE9u3t">
					<idno type="grant-number">I-1502-407.6/2019</idno>
				</org>
				<org type="funding" xml:id="_jvkqSXv">
					<idno type="grant-number">MA 4938/4-1</idno>
				</org>
				<org type="funding" xml:id="_Uen6gdf">
					<idno type="grant-number">1295/15</idno>
				</org>
				<org type="funding" xml:id="_4RTuE6Z">
					<idno type="grant-number">768/19</idno>
				</org>
				<org type="funding" xml:id="_XNxrfy7">
					<idno type="grant-number">412400621</idno>
					<orgName type="program" subtype="full">DIP program</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">What's Decidable about Weighted Automata? In Automated Technology for Verification and Analysis</title>
		<author>
			<persName><forename type="first">Shaull</forename><surname>Almagor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Udi</forename><surname>Boker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orna</forename><surname>Kupferman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="482" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Constant-Delay Enumeration for Nondeterministic Document Spanners</title>
		<author>
			<persName><forename type="first">Antoine</forename><surname>Amarilli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mengel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Niewerth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient Logspace Classes for Enumeration, Counting, and Uniform Generation</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Luis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajesh</forename><surname>Croquevielle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Jayaram</surname></persName>
		</author>
		<author>
			<persName><surname>Riveros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="59" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">SystemT: An Algebraic Approach to Declarative Information Extraction</title>
		<author>
			<persName><forename type="first">Laura</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajasekar</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yunyao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sriram</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frederick</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shivakumar</forename><surname>Vaithyanathan</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/P10-1014" />
	</analytic>
	<monogr>
		<title level="m">ACL</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="128" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Named Entity Recognition with Bidirectional LSTM-CNNs</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Jason</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><surname>Nichols</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TACL</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="357" to="370" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Logic and regular cost functions</title>
		<author>
			<persName><forename type="first">T</forename><surname>Colcombet</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS.2017.8005061</idno>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Cost Functions Definable by Min/Max Automata</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Colcombet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Kuperberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amaldev</forename><surname>Manuel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Szymon</forename><surname>Torunczyk</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.STACS.2016.29</idno>
	</analytic>
	<monogr>
		<title level="m">STACS)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="1" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Split-Correctness in Information Extraction</title>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Doleschal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoav</forename><surname>Nahshon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Neven</surname></persName>
		</author>
		<idno type="DOI">10.1145/3294052.3319684</idno>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="149" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Semirings and Formal Power Series</title>
		<author>
			<persName><forename type="first">Manfred</forename><surname>Droste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Kuich</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-01492-5_1</idno>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="3" to="28" />
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Handbook of Weighted Automata</title>
		<author>
			<persName><forename type="first">Manfred</forename><surname>Droste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Kuich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heiko</forename><surname>Vogler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer Publishing Company, Incorporated</publisher>
		</imprint>
	</monogr>
	<note>1st edition</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Automata, Languages, and Machines</title>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Eilenberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Academic Press, Inc</publisher>
			<pubPlace>Orlando, FL, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Finite Automata</title>
		<author>
			<persName><forename type="first">Zoltán</forename><surname>Ésik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Werner</forename><surname>Kuich</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-01492-5_3</idno>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="69" to="104" />
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Document Spanners: A Formal Approach to Information Extraction</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frederick</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
		<idno type="DOI">10.1145/2699442</idno>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Declarative Cleaning of Inconsistencies in Information Extraction</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frederick</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
		<idno type="DOI">10.1145/2877202</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Constant Delay Algorithms for Regular Document Spanners</title>
		<author>
			<persName><forename type="first">Fernando</forename><surname>Florenzano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Riveros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martín</forename><surname>Ugarte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="165" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Annotated XML: queries and provenance</title>
		<author>
			<persName><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="271" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Logic for Document Spanners</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dominik</surname></persName>
		</author>
		<author>
			<persName><surname>Freydenberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1679" to="1754" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Joining Extractions of Regular Expressions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dominik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Freydenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Liat</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><surname>Peterfreund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="137" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Semiring Parsing</title>
		<author>
			<persName><forename type="first">Joshua</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="573" to="605" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<idno type="DOI">10.1145/1265530.1265535</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</title>
		<meeting>the Twenty-Sixth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">June 11-13, 2007. 2007</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Query evaluation with soft-key constraints</title>
		<author>
			<persName><forename type="first">Abhay</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jha</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Vibhor</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Deciding unambiguity and sequentiality from a finitely ambiguous max-plus automaton</title>
		<author>
			<persName><forename type="first">Ines</forename><surname>Klimann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvain</forename><surname>Lombardy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename><surname>Mairesse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christophe</forename><surname>Prieur</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2004.02.049</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">327</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="349" to="373" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Equality Problem for Rational Series with Multiplicities in the tropical Semiring is Undecidable</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Krob</surname></persName>
		</author>
		<idno type="DOI">10.1142/S0218196794000063</idno>
	</analytic>
	<monogr>
		<title level="j">IJAC</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="405" to="426" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">SVM based learning system for information extraction</title>
		<author>
			<persName><forename type="first">Yaoyong</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kalina</forename><surname>Bontcheva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hamish</forename><surname>Cunningham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Deterministic and Statistical Methods in Machine Learning</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3635</biblScope>
			<biblScope unit="page" from="319" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Document Spanners for Extracting Incomplete Information: Expressiveness and Complexity</title>
		<author>
			<persName><forename type="first">Francisco</forename><surname>Maturana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Riveros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="125" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Regular Inference on Artificial Neural Networks</title>
		<author>
			<persName><forename type="first">Franz</forename><surname>Mayr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Yovine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Cd-Make</forename></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">11015</biblScope>
			<biblScope unit="page" from="350" to="369" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Representing Formal Languages: A Comparison Between Finite Automata and Recurrent Neural Networks</title>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">J</forename><surname>Michalenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ameesh</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhinav</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">G</forename><surname>Baraniuk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swarat</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankit</forename><forename type="middle">B</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR (Poster)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Weighted Automata Algorithms</title>
		<author>
			<persName><forename type="first">Mehryar</forename><surname>Mohri</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-01492-5_6</idno>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="213" to="254" />
			<pubPlace>Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Cross-Sentence N-ary Relation Extraction with Graph LSTMs</title>
		<author>
			<persName><forename type="first">Nanyun</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hoifung</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Quirk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristina</forename><surname>Toutanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wen-Tau</forename><surname>Yih</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TACL</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="101" to="115" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Complexity Bounds for Relational Algebra over Document Spanners</title>
		<author>
			<persName><forename type="first">Liat</forename><surname>Peterfreund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dominik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Freydenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><surname>Kröll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="320" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Recursive Programs for Document Spanners</title>
		<author>
			<persName><forename type="first">Liat</forename><surname>Peterfreund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Balder Ten Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><surname>Kimelfeld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Joint Inference in Information Extraction</title>
		<author>
			<persName><forename type="first">Hoifung</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><forename type="middle">M</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="913" to="918" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Probabilistic automata</title>
		<author>
			<persName><forename type="first">O</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><surname>Rabin</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0019-9958(63)90290-0</idno>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="230" to="245" />
			<date type="published" when="1963">1963</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Snorkel: Rapid Training Data Creation with Weak Supervision</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Ratner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">H</forename><surname>Bach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><forename type="middle">R</forename><surname>Ehrenberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Fries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sen</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="269" to="282" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Markov Logic Networks</title>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Domingos</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10994-006-5833-1</idno>
	</analytic>
	<monogr>
		<title level="j">Mach. Learn</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="107" to="136" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A Formal Framework for Probabilistic Unclean Databases</title>
		<author>
			<persName><forename type="first">Christopher</forename><surname>De Sa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ihab</forename><forename type="middle">F</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Theodoros</forename><surname>Rekatsinas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Elements of Automata Theory</title>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Sakarovitch</surname></persName>
		</author>
		<idno type="DOI">10.1017/CBO9781139195218</idno>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Information Extraction</title>
		<author>
			<persName><forename type="first">Sunita</forename><surname>Sarawagi</surname></persName>
		</author>
		<idno type="DOI">10.1561/1900000003</idno>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Databases</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="261" to="377" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Bridging CNNs, RNNs, and Weighted Finite-State Machines</title>
		<author>
			<persName><forename type="first">Roy</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="295" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Probability and Nondeterminism in Operational Models of Concurrency</title>
		<author>
			<persName><forename type="first">Roberto</forename><surname>Segala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="64" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">PrDB: managing and exploiting rich correlations in probabilistic databases</title>
		<author>
			<persName><forename type="first">Prithviraj</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amol</forename><surname>Deshpande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lise</forename><surname>Getoor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1065" to="1090" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Declarative Information Extraction Using Datalog with Embedded Extraction Predicates</title>
		<author>
			<persName><forename type="first">Warren</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anhai</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/2007/papers/research/p1033-shen.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1033" to="1044" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Incremental Knowledge Base Construction Using DeepDive</title>
		<author>
			<persName><forename type="first">Jaeho</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sen</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feiran</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><forename type="middle">De</forename><surname>Sa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ce</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/pvldb/vol8/p1310-shin.pdf" />
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1310" to="1321" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">An Introduction to Conditional Random Fields</title>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">A</forename><surname>Sutton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Machine Learning</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="267" to="373" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A genome-wide survey of human pseudogenes</title>
		<author>
			<persName><forename type="first">David</forename><surname>Torrents</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikita</forename><surname>Suyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evgeny</forename><surname>Zdobnov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peer</forename><surname>Bork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2559" to="2567" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">On the Complexity of Multiple Sequence Alignment</title>
		<author>
			<persName><forename type="first">Lusheng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tao</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Biology</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="337" to="348" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Extracting Automata from Recurrent Neural Networks Using Queries and Counterexamples</title>
		<author>
			<persName><forename type="first">Gail</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="5244" to="5253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Finding the k Shortest Loopless Paths in a Network</title>
		<author>
			<persName><forename type="first">Jin</forename><forename type="middle">Y</forename><surname>Yen</surname></persName>
		</author>
		<ptr target="http://www.jstor.org/stable/2629312" />
	</analytic>
	<monogr>
		<title level="j">Management Science</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="712" to="716" />
			<date type="published" when="1971">1971</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</teiCorpus></text>
</TEI>