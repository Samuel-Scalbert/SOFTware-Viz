<?xml version='1.0' encoding='utf-8'?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 http://api.archives-ouvertes.fr/documents/aofr-sword.xsd">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>HAL TEI export of hal-03426547</title>
      </titleStmt>
      <publicationStmt>
        <distributor>CCSD</distributor>
        <availability status="restricted">
          <licence target="http://creativecommons.org/licenses/by/4.0/">Distributed under a Creative Commons Attribution 4.0 International License</licence>
        </availability>
        <date when="2024-04-29T11:48:18+02:00" />
      </publicationStmt>
      <sourceDesc>
        <p part="N">HAL API platform</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <listBibl>
        <biblFull>
          <titleStmt>
            <title xml:lang="en">Fixed-point semantics for barebone relational concept analysis</title>
            <author role="aut">
              <persName>
                <forename type="first">Jérôme</forename>
                <surname>Euzenat</surname>
              </persName>
              <idno type="halauthorid">9194-0</idno>
              <affiliation ref="#struct-1043307" />
            </author>
            <editor role="depositor">
              <persName>
                <forename>Jérôme</forename>
                <surname>Euzenat</surname>
              </persName>
              <email type="md5">60cd233e6714c5a2eea038ee0eda516a</email>
              <email type="domain">inria.fr</email>
            </editor>
            <funder ref="#projanr-42626" />
            <funder ref="#projanr-50501" />
          </titleStmt>
          <editionStmt>
            <edition n="v1" type="current">
              <date type="whenSubmitted">2021-11-12 13:04:19</date>
              <date type="whenWritten">2021</date>
              <date type="whenModified">2024-04-04 21:34:51</date>
              <date type="whenReleased">2021-11-15 14:24:12</date>
              <date type="whenProduced">2021-07-01</date>
              <date type="whenEndEmbargoed">2021-11-12</date>
              <ref type="file" target="https://hal.science/hal-03426547/document">
                <date notBefore="2021-11-12" />
              </ref>
              <ref type="file" subtype="author" n="1" target="https://hal.science/hal-03426547/file/euzenat2021a.pdf">
                <date notBefore="2021-11-12" />
              </ref>
              <ref type="externalLink" target="https://hal.archives-ouvertes.fr/hal-03426547/file/euzenat2021a.pdf" />
            </edition>
            <respStmt>
              <resp>contributor</resp>
              <name key="102400">
                <persName>
                  <forename>Jérôme</forename>
                  <surname>Euzenat</surname>
                </persName>
                <email type="md5">60cd233e6714c5a2eea038ee0eda516a</email>
                <email type="domain">inria.fr</email>
              </name>
            </respStmt>
          </editionStmt>
          <publicationStmt>
            <distributor>CCSD</distributor>
            <idno type="halId">hal-03426547</idno>
            <idno type="halUri">https://hal.science/hal-03426547</idno>
            <idno type="halBibtex">euzenat:hal-03426547</idno>
            <idno type="halRefHtml">&lt;i&gt;ICFCA - 16th international conference on formal concept analysis&lt;/i&gt;, Jul 2021, Strasbourg, France. pp.20-37, &lt;a target="_blank" href="https://dx.doi.org/10.1007/978-3-030-77867-5_2"&gt;&amp;#x27E8;10.1007/978-3-030-77867-5_2&amp;#x27E9;&lt;/a&gt;</idno>
            <idno type="halRef">ICFCA - 16th international conference on formal concept analysis, Jul 2021, Strasbourg, France. pp.20-37, &amp;#x27E8;10.1007/978-3-030-77867-5_2&amp;#x27E9;</idno>
          </publicationStmt>
          <seriesStmt>
            <idno type="stamp" n="UGA">HAL Grenoble Alpes</idno>
            <idno type="stamp" n="CNRS">CNRS - Centre national de la recherche scientifique</idno>
            <idno type="stamp" n="INRIA">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="INPG">Institut polytechnique de Grenoble</idno>
            <idno type="stamp" n="INRIA-RHA">INRIA Grenoble - Rhône-Alpes</idno>
            <idno type="stamp" n="LIG">Laboratoire d'Informatique de Grenoble</idno>
            <idno type="stamp" n="INRIA_TEST">INRIA - Institut National de Recherche en Informatique et en Automatique</idno>
            <idno type="stamp" n="TESTALAIN1">TESTALAIN1</idno>
            <idno type="stamp" n="INRIA2">INRIA 2</idno>
            <idno type="stamp" n="LIG-TDCGE-MOEX" corresp="LIG_TDCGE">MOEX - Évolution de la connaissance</idno>
            <idno type="stamp" n="INRIA-RENGRE">INRIA-RENGRE</idno>
            <idno type="stamp" n="MIAI">Multidisciplinary Institute in Artificial intelligence - Grenoble Alpes</idno>
            <idno type="stamp" n="TEST-HALCNRS">Collection test HAL CNRS</idno>
            <idno type="stamp" n="PNRIA">Programme National de Recherche en IA</idno>
            <idno type="stamp" n="UGA-EPE">Université Grenoble Alpes [2020-*]</idno>
            <idno type="stamp" n="ANR">ANR</idno>
            <idno type="stamp" n="LIG_SIDCH" corresp="LIG">Systèmes intelligents pour les données, les connaissances et les humains</idno>
          </seriesStmt>
          <notesStmt>
            <note type="audience" n="2">International</note>
            <note type="invited" n="0">No</note>
            <note type="popular" n="0">No</note>
            <note type="peer" n="1">Yes</note>
            <note type="proceedings" n="1">Yes</note>
          </notesStmt>
          <sourceDesc>
            <biblStruct>
              <analytic>
                <title xml:lang="en">Fixed-point semantics for barebone relational concept analysis</title>
                <author role="aut">
                  <persName>
                    <forename type="first">Jérôme</forename>
                    <surname>Euzenat</surname>
                  </persName>
                  <idno type="halauthorid">9194-0</idno>
                  <affiliation ref="#struct-1043307" />
                </author>
              </analytic>
              <monogr>
                <title level="m">Proc. 16th international conference on formal concept analysis (ICFCA)</title>
                <meeting>
                  <title>ICFCA - 16th international conference on formal concept analysis</title>
                  <date type="start">2021-07-01</date>
                  <date type="end">2021-07-01</date>
                  <settlement>Strasbourg</settlement>
                  <country key="FR">France</country>
                </meeting>
                <editor>Agnès Braud</editor>
                <editor>Aleksey Buzmakov</editor>
                <editor>Tom Hanika</editor>
                <editor>Florence Le Ber</editor>
                <imprint>
                  <publisher>Springer Verlag</publisher>
                  <biblScope unit="pp">20-37</biblScope>
                  <date type="datePub">2021</date>
                </imprint>
              </monogr>
              <idno type="doi">10.1007/978-3-030-77867-5_2</idno>
            </biblStruct>
          </sourceDesc>
          <profileDesc>
            <langUsage>
              <language ident="en">English</language>
            </langUsage>
            <textClass>
              <keywords scheme="author">
                <term xml:lang="en">Formal Concept Analysis</term>
              </keywords>
              <classCode scheme="halDomain" n="info.info-ai">Computer Science [cs]/Artificial Intelligence [cs.AI]</classCode>
              <classCode scheme="halTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halOldTypology" n="COMM">Conference papers</classCode>
              <classCode scheme="halTreeTypology" n="COMM">Conference papers</classCode>
            </textClass>
            <abstract xml:lang="en">
              <p>Relational concept analysis (RCA) extends formal concept analysis (FCA) by taking into account binary relations between formal contexts. It has been designed for inducing description logic TBoxes from ABoxes, but can be used more generally. It is especially useful when there exist circular dependencies between objects. In this case, it extracts a unique stable concept lattice family grounded on the initial formal contexts. However, other stable families may exist whose structure depends on the same relational context. These may be useful in applications that need to extract a richer structure than the minimal grounded one. This issue is first illustrated in a reduced version of RCA, which only retains the relational structure. We then redefine the semantics of RCA on this reduced version in terms of concept lattice families closed by a fixed-point operation induced by this relational structure. We show that these families admit a least and greatest fixed point and that the well-grounded RCA semantics is characterised by the least fixed point. We then study the structure of other fixed points and characterise the interesting lattices as the self-supported fixed points.</p>
            </abstract>
          </profileDesc>
        </biblFull>
      </listBibl>
    </body>
    <back>
      <listOrg type="structures">
        <org type="researchteam" xml:id="struct-1043307" status="VALID">
          <idno type="RNSR">201722226P</idno>
          <orgName>Evolution de la connaissance</orgName>
          <orgName type="acronym">MOEX </orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <addrLine>Centre de Recherche Inria 655, avenue de l'Europe 38334 Saint Ismier Cedex </addrLine>
              <country key="FR" />
            </address>
            <ref type="url">https://moex.inria.fr/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-2497" type="direct" />
            <relation active="#struct-300009" type="indirect" />
            <relation active="#struct-1043301" type="direct" />
            <relation name="UMR5217" active="#struct-441569" type="indirect" />
            <relation active="#struct-1042703" type="indirect" />
            <relation active="#struct-1043329" type="indirect" />
          </listRelation>
        </org>
        <org type="laboratory" xml:id="struct-2497" status="VALID">
          <idno type="RNSR">199218244V</idno>
          <idno type="ROR">https://ror.org/00n8d6z93</idno>
          <orgName>Inria Grenoble - Rhône-Alpes</orgName>
          <desc>
            <address>
              <addrLine>Inovallée655 avenue de l'Europe38330 Montbonnot</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/centre/grenoble</ref>
          </desc>
          <listRelation>
            <relation active="#struct-300009" type="direct" />
          </listRelation>
        </org>
        <org type="institution" xml:id="struct-300009" status="VALID">
          <idno type="ROR">https://ror.org/02kvxyf05</idno>
          <orgName>Institut National de Recherche en Informatique et en Automatique</orgName>
          <orgName type="acronym">Inria</orgName>
          <desc>
            <address>
              <addrLine>Domaine de VoluceauRocquencourt - BP 10578153 Le Chesnay Cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.inria.fr/en/</ref>
          </desc>
        </org>
        <org type="laboratory" xml:id="struct-1043301" status="VALID">
          <idno type="IdRef">148425550</idno>
          <idno type="ISNI">0000 0001 2286 4035</idno>
          <idno type="RNSR">200711886U</idno>
          <idno type="ROR">https://ror.org/01c8rcg82</idno>
          <orgName>Laboratoire d'Informatique de Grenoble</orgName>
          <orgName type="acronym">LIG</orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <addrLine>UMR 5217 - Laboratoire LIG - Bâtiment IMAG - 700 avenue Centrale - Domaine Universitaire de Saint-Martin-d’Hères Adresse postale : CS 40700 - 38058 Grenoble cedex 9Tél. : 04 57 42 14 00</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.liglab.fr/</ref>
          </desc>
          <listRelation>
            <relation name="UMR5217" active="#struct-441569" type="direct" />
            <relation active="#struct-1042703" type="direct" />
            <relation active="#struct-1043329" type="direct" />
          </listRelation>
        </org>
        <org type="regroupinstitution" xml:id="struct-441569" status="VALID">
          <idno type="IdRef">02636817X</idno>
          <idno type="ISNI">0000000122597504</idno>
          <idno type="ROR">https://ror.org/02feahw73</idno>
          <orgName>Centre National de la Recherche Scientifique</orgName>
          <orgName type="acronym">CNRS</orgName>
          <date type="start">1939-10-19</date>
          <desc>
            <address>
              <country key="FR" />
            </address>
            <ref type="url">https://www.cnrs.fr/</ref>
          </desc>
        </org>
        <org type="regroupinstitution" xml:id="struct-1042703" status="VALID">
          <idno type="IdRef">240648315</idno>
          <idno type="ROR">https://ror.org/02rx3b187</idno>
          <orgName>Université Grenoble Alpes</orgName>
          <orgName type="acronym">UGA</orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <addrLine>Adresse CS 40700 - 38058 Grenoble cedex</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.univ-grenoble-alpes.fr</ref>
          </desc>
        </org>
        <org type="institution" xml:id="struct-1043329" status="VALID">
          <idno type="IdRef">026388804</idno>
          <idno type="ROR">https://ror.org/05sbt2524</idno>
          <orgName>Institut polytechnique de Grenoble - Grenoble Institute of Technology</orgName>
          <orgName type="acronym">Grenoble INP </orgName>
          <date type="start">2020-01-01</date>
          <desc>
            <address>
              <addrLine>46 avenue Félix Viallet 38031 Grenoble Cedex 1</addrLine>
              <country key="FR" />
            </address>
            <ref type="url">http://www.grenoble-inp.fr/</ref>
          </desc>
          <listRelation>
            <relation active="#struct-1042703" type="direct" />
          </listRelation>
        </org>
      </listOrg>
      <listOrg type="projects">
        <org type="anrProject" xml:id="projanr-42626" status="VALID">
          <idno type="anr">ANR-17-CE23-0007</idno>
          <idno type="program">Société de l'information et de la communication</idno>
          <orgName>ELKER</orgName>
          <desc>Étendre les clés de liage: extraction et raisonnement</desc>
          <date type="start">2017</date>
        </org>
        <org type="anrProject" xml:id="projanr-50501" status="VALID">
          <idno type="anr">ANR-19-P3IA-0003</idno>
          <orgName>MIAI</orgName>
          <desc>MIAI @ Grenoble Alpes</desc>
          <date type="start">2019</date>
        </org>
      </listOrg>
    </back>
  <teiCorpus>
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fixed-point semantics for barebone relational concept analysis</title>
				<funder ref="#_XW2jY5V">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Jérôme</forename><surname>Euzenat</surname></persName>
							<email>jerome.euzenat@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Grenoble INP</orgName>
								<orgName type="institution" key="instit5">LIG</orgName>
								<address>
									<postCode>F-38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fixed-point semantics for barebone relational concept analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">8FEB58726A9F2CA84187A677C1B4C847</idno>
					<idno type="DOI">10.1007/978-3-030-77867-5_2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Relational concept analysis (RCA) extends formal concept analysis (FCA) by taking into account binary relations between formal contexts. It has been designed for inducing description logic TBoxes from ABoxes, but can be used more generally. It is especially useful when there exist circular dependencies between objects. In this case, it extracts a unique stable concept lattice family grounded on the initial formal contexts. However, other stable families may exist whose structure depends on the same relational context. These may be useful in applications that need to extract a richer structure than the minimal grounded one. This issue is first illustrated in a reduced version of RCA, which only retains the relational structure. We then redefine the semantics of RCA on this reduced version in terms of concept lattice families closed by a fixed-point operation induced by this relational structure. We show that these families admit a least and greatest fixed point and that the well-grounded RCA semantics is characterised by the least fixed point. We then study the structure of other fixed points and characterise the interesting lattices as the self-supported fixed points.</p></div>
<div><head n="1">Motivation</head><p>Formal concept analysis (FCA [7]) is a useful tool for inducing a classification structure from data. Relational concept analysis (RCA <ref type="bibr" target="#b12">[13]</ref>) is one of its extensions allowing to take advantage of relationships between objects to extract dependent concept lattices. One of its strong point is its ability to deal with circular dependencies between objects.</p><p>Although the result returned by RCA is solid and useful, it may not be the only possible result. The relational structure, when containing circuits, has the capability to induce richer lattice structures. Indeed, in the absence of information or of reason to separate objects, RCA classifies them within the same concept. On the contrary, in the absence of information or of reason to aggregate objects, it is possible to keep them in different concepts. A good compromise may sometimes reside in between these two extremes. As a data mining procedure, RCA can be useful in returning all possible structures and not necessarily the safest ones. This is not really a problem in the target RCA application: extracting the core classes of a description logic ontology. However, this may be a problem for other applications.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><p>This work was initially motivated by one such application of RCA: We developed a link key candidate extraction algorithm on top of relational concept analysis <ref type="bibr" target="#b1">[2]</ref>. Link keys are rules for identifying the same individuals from different data sources. In this context, the concepts of extracted lattices are link key candidates which will be selected on the basis of two independent measures <ref type="bibr" target="#b0">[1]</ref>. As a data mining task, RCA is more useful if it generates all the possible link key candidates.</p><p>Hereafter, we illustrate the considered problem on RCA 0 , a minimal version of RCA. Although RCA 0 is simply a convenient way to illustrate the problem it requires solutions that will apply to RCA as a whole.</p><p>Understanding the nature of the problem and its relation with RCA lead to consider its semantics. The current semantics of RCA <ref type="bibr" target="#b13">[14]</ref> focusses on the grounding of the process. We redefine this semantics on properties directly characterising the solutions.</p><p>We first consider the core function involved in the classical RCA algorithm and identify acceptable results as the fixed points of this function. We show, in the case of RCA 0 , that the classical RCA semantics corresponds to extracting its least fixed point.</p><p>We also provide a direct way to generate the greatest fixed point. However, although RCA extracts the minimal fixed point in its simplest form, this is not the case of the greatest fixed point: it would make reference to non-existent concepts. Hence we discuss the notion of self-supported concept lattice, so that the acceptable RCA results would be self-supported fixed points.</p><p>FCA is a domain of fixed points, hence it is easy to get lost among the various fixed points involved: (a) In description logics, on which RCA relies, the semantics of concepts is given by fixed points when circularities occur <ref type="bibr" target="#b10">[11]</ref>; (b) FCA's goal is to compute fixed points: concepts are the result of a closure operator which is also a fixed point <ref type="bibr" target="#b3">[4]</ref>; (c) finally, when confronted to cycles, the RCA concept lattice is the fixed point of the function that grows a lattice family from the previous one. The present work is concerned with the latter kind of fixed points.</p><p>In the remainder, we present the context as well as related work ( §2). We illustrate the considered problem on a minimal example ( §3). We then provide a fixed-point semantics for RCA based on a context-expansion function ( §4) which allows to characterise the classical RCA semantics. However, this semantics being not fully satisfactory, we introduce the complementary notion of self-supported concept lattices ( §5). We finally discuss concrete processing issues ( §6).</p></div>
<div><head n="2">Preliminaries and related work</head><p>We mix preliminaries with related works for reasons of space, but also because the paper directly builds on this related work.</p></div>
<div><head n="2.1">Formal concept analysis</head><p>Formal Concept Analysis (FCA) <ref type="bibr" target="#b6">[7]</ref> starts with a binary context G, M, I where G denotes a set of objects, M a set of attributes, and I ⊆ G × M a binary relation between G and M, called the incidence relation. The statement gIm is interpreted as "object g has attribute m". Two operators • ↑ and • ↓ define a Galois connection between the powersets 2 G , ⊆ and 2 M , ⊆ , with A ⊆ G and B ⊆ M:</p><formula xml:id="formula_0">A ↑ = {m ∈ M | gIm for all g ∈ A} B ↓ = {g ∈ G | gIm for all m ∈ B} The operators • ↑ and • ↓ are decreasing, i.e. if A 1 ⊆ A 2 then A ↑ 2 ⊆ A ↑ 1 and if B 1 ⊆ B 2 then B ↓ 2 ⊆ B ↓ 1 .</formula><p>Intuitively, the less objects there are, the more attributes they share, and dually, the less attributes there are, the more objects have these attributes. It can be checked that A ⊆ A ↑↓ and that B ⊆ B ↓↑ , that A ↑ = A ↑↓↑ and that B ↓ = B ↓↑↓ .</p><p>For A ⊆ G, B ⊆ M, a pair A, B , such that A ↑ = B and B ↓ = A, is called a formal concept, where A is the extent and B the intent of A, B . Moreover, for a formal concept A, B , A and B are closed sets for the closure operators • ↑↓ and • ↓↑ , respectively, i.e.</p><formula xml:id="formula_1">A ↑↓ = A and B ↓↑ = B.</formula><p>Concepts are partially ordered by</p><formula xml:id="formula_2">A 1 , B 1 ≤ A 2 , B 2 ⇔ A 1 ⊆ A 2 or equivalently B 2 ⊆ B 1 .</formula><p>With respect to this partial order, the set of all formal concepts forms a complete lattice called the concept lattice of G, M, I .</p><p>Formal concept analysis can be considered as a function that associates to a formal context G, M, I its concept lattice C, ≤ = FCA( G, M, I ) (or B(G, M, I) <ref type="bibr" target="#b6">[7]</ref>). By abuse of language, when a variable L denotes a concept lattice C, ≤ , L will also be used to denote C.</p></div>
<div><head n="2.2">Extending FCA</head><p>Formal concept analysis is defined on relatively simple structures hence many extensions have been designed. They allow FCA to (a) deal with more complex input structure, and/or (b) generate more expressive and interpretable knowledge structures.</p><p>Scaling Scaling is one type of extension of type (a). A scaling operation ς : X → 2 D generates boolean attributes named after a language D from a structure Σ ∈ X . In FCA, D = M and I is provided by its matrix. In scaled contexts, this language can be interpreted so that the incidence relation I is immediately derived from the attribute m following:</p><formula xml:id="formula_3">gIm iff Σ |= m(g)</formula><p>Hence, adding attributes to a context under such a structure may be performed as:</p><formula xml:id="formula_4">K Σ M ( G, M, I ) = G, M ∪ M , I ∪ { g, m ∈ G × M | Σ |= m(g)}</formula><p>Applying a scaling operation ς to a formal context K following a structure Σ can be thus decomposed into (i) determining the set of attributes ς (Σ ) to add, and (ii) extending the context with such attributes:</p><formula xml:id="formula_5">σ ς (K, Σ ) = K Σ ς (Σ ) (K)</formula><p>Many conceptual scaling operations have been discussed in <ref type="bibr" target="#b6">[7]</ref> for dealing with non boolean variables in formal contexts. In general, Σ is void, D is expressed as predicates, e.g. • = v for nominal scaling or • ≤ n for ordinal scaling, and |= is the evaluation of the predicate for the value.</p><p>Logical scaling <ref type="bibr" target="#b11">[12]</ref> has been introduced for more versatile languages such as description logics and SQL. It introduces query results within formal contexts. In this case, Σ is a logical theory or database tables, D the set of formulas of the logic or instantiated queries and |= is entailment or query evaluation.</p><p>Relational scaling operations considered in <ref type="bibr" target="#b12">[13]</ref> are based on a struture Σ = R,C made of a family of relations R = {r y } y∈Y , i.e. relations r y ⊆ G x × G z between two sets of objects, and a family C = {C x } x∈X of sets of concepts whose extent is a subset of G x . Its language D ς ,R,C is the set of attribute descriptions involving ς , R and C. For example, qualified existential scaling (∃) adds attributes ∃r.c for r ∈ R, r</p><formula xml:id="formula_6">⊆ G x × G z , c ∈ C z and |= checks that R, L |= gI∃r.c iff ∃g ; g, g ∈ r ∧ g ∈ extent(c)</formula><p>Various relational scaling operations are used in RCA such as existential, strict and wide universal, min and max cardinality, which all follow the classical role restriction semantics of description logics <ref type="bibr" target="#b2">[3]</ref>.</p><p>Other extensions Pattern structures <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b8">9]</ref> provide a more structured attribute language without scaling. However, its use is not directly related to the problem of context dependencies considered here as the attributes do not refer to concepts.</p><p>On the contrary, other approaches <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b4">5]</ref> aim at extracting conceptual structures from n-ary relations without resorting to scaling. Their concepts have intents that can be thought of as conjunctive queries and extents as tuples of objects, i.e. answers to these queries. Hence, instead of being classes, i.e. monadic predicates, concepts correspond to general polyadic predicates. For that purpose, they rely on more expressive input, e.g. in Graph-FCA <ref type="bibr" target="#b4">[5]</ref> the incidence relation is a hypergraph between objects, and produce a more expressive representation. A comparison of RCA and Graph-FCA is provided in <ref type="bibr" target="#b7">[8]</ref>. Graph-FCA adopts a different approach than RCA but should, in principle, suffer from the same problem as the one illustrated here. However, intents would need to refer to concepts so created, i.e. named subqueries. This remains to be studied.</p></div>
<div><head n="2.3">Relational concept analysis</head><p>Relational Concept Analysis (RCA) <ref type="bibr" target="#b12">[13]</ref> extends FCA to the processing of relational datasets and allows inter-object relations to be materialised and incorporated into formal concept intents. RCA is a way to induce a description logic TBox from a simple ABox <ref type="bibr" target="#b2">[3]</ref>, using specific scaling operations. It may also be though of as a general way to deal with circular references using different scaling operations.</p><p>RCA applies to a relational context K 0 , R , composed of a set of formal contexts</p><formula xml:id="formula_7">K 0 = { G x , M 0 x , I 0 x } x∈X and a set of binary relations R = {r y } y∈Y . A relation r y ⊆ G x × G z connects two object sets, a domain G x (dom(r y ) = G x , x ∈ X) and a range G z (ran(r y ) = G z , z ∈ X).</formula><p>RCA applies relational scaling operations from a set Ω to each K i x ∈ K i and all relations r y ⊆ G x × G z from the set of concepts in corresponding L z = FCA(K i z ).</p><p>For performing its operations, RCA thus relies on FCA and σ ς . More precisely it uses FCA * and σ * Ω defined as:</p><formula xml:id="formula_8">FCA * ({ G x , M x , I x } x∈X ) = {FCA( G x , M x , I x )} x∈X σ * Ω ({ G x , M x , I x } x∈X , R, {L x } x∈X ) =    ς ∈Ω r y ∈R | r⊆G x ×G z σ ς ( G x , M x , I x , r y , L z )    x∈X such that ⊕ ς ∈Ω</formula><p>r y ∈R | r⊆G x ×G z scales, with all operations in Ω , the given context with all the relations starting from x (to any z).</p><p>RCA starts from the initial formal context family K 0 and thus iterates the application of the two operations:</p><formula xml:id="formula_9">K i+1 = σ * Ω (K i , R, FCA * (K i )) until reaching closure, i.e. reaching n such that K n+1 = K n . Then, RCA Ω (K 0 , R) = FCA * (K n ).</formula><p>By abuse of notation, we note G, M, I ⊆ G, M , I whenever M ⊆ M and I = I ∩ (G × M). In this case, because I is the incidence relation between the same G and M ⊆ M , the relation only depends on M and M . This is generalised to formal context families</p><formula xml:id="formula_10">{ G x , M x , I x } x∈X ⊆ { G x , M x , I x } x∈X whenever ∀x ∈ X, M x ⊆ M x .</formula><p>The RCA process always reaches a closed formal context family for reason of finiteness <ref type="bibr" target="#b12">[13]</ref> and the sequence</p><formula xml:id="formula_11">(K i ) n i=0 is non-contracting, i.e. ∀i ≥ 0, K i ⊆ K i+1 [14]</formula><p>. The well-grounded semantics of RCA <ref type="bibr" target="#b13">[14]</ref> further establishes that RCA indeed finds the K n satisfying these constraints through correctness (the concepts of FCA * (K n ) are grounded in K 0 through R) and completess (all such concepts are in K n ).</p></div>
<div><head n="2.4">RCA 0</head><p>To keep the paper short and simple, we restrict it to RCA 0 , a special case of RCA. It is restricted in two ways:</p><p>-It contains only one formal context (|X| = 1), -which has no attributes (M 0 x = ∅).</p><p>Additionally, we will consider below only qualified existential scaling (Ω = {∃}).</p><p>Because RCA 0 is a restriction of RCA, we will use the same notation as defined above, thought it operates on simpler structures.</p><p>Although RCA 0 seems very simple, FCA can be encoded into RCA 0 . Introducing RCA 0 is sufficient to hint at the problem that we want to illustrate<ref type="foot" target="#foot_0">1</ref> .  Scaling with ∃ and p provides the attribute ∃p.ABCD which generates the new context of Figure <ref type="figure" target="#fig_2">2</ref> (left), leading to the lattice of Figure <ref type="figure" target="#fig_2">2</ref> (right) which is the one returned by RCA.  They correspond to different knowledge bases: In addition to extracting the TBox, these extend the ABox. However, in RCA and FCA, objects are also assigned to the created concepts. In this case, this assignment has consequences on the scaled attributes taken into account and hence the resulting lattice.</p></div>
<div><head n="3">RCA may accept different concept lattice families: illustration</head><formula xml:id="formula_12">∃p.ABCD a × c × b × d × ∃p.ABCD a, b, c, d ABCD L 1 :</formula><formula xml:id="formula_13">T 1 = {ABCD ∃p.ABCD} A 1 = {ABCD(a)</formula><p>As in classical RCA, each concept of these lattices is closed with respect to the specific formal context scaled by ∃ and p from the concepts of the lattice. Moreover, the lattices are self-supported in the sense that their attributes refer only to their concepts.</p><p>The problem applies to RCA as a whole as RCA 0 is included in RCA. Hence the question: Why does RCA returns only one lattice, and which one? Answering it requires to reconsider the RCA semantics.</p></div>
<div><head n="4">Semantics and properties: a context approach</head><p>The alternative lattices presented in Section 3 are legitimate because, independently of the attributes, they rely exclusively on the structure of the relations between formal contexts. This structure is already used in the well-grounded RCA semantics, but they have not been fully exploited.</p><p>The answer will require to further define 'legitimate', in terms of fixed points of a specific function, and characterise the semantics of RCA as indeed grounded, in terms of these fixed points.</p></div>
<div><head n="4.1">The lattice K of RCA 0 contexts</head><p>We first define the space of formal context families considered by RCA. They are determined by three elements given once and for all:</p><formula xml:id="formula_14">K 0 = { G, M 0 , I 0 } x∈X , R = {r y } y∈Y ,</formula><p>and Ω . This is even more specific for RCA 0 with K 0 = G, ∅, ∅ and Ω = {ς ∃ }, but for most of this section we will ignore it.</p><p>The contexts considered by RCA are formal context families obtained by the scaled initial context using the scaling operations. Given a finite set of objects G, the set of concepts that can be created from such contexts is finite and moreover each concept can be identified by its extent. Hence, we will consider that this induces a set of concept names N(G) = 2 G valid for any such concept lattice; the extent of a so named concept will be the set of objects in its name. Given a finite set of relations R and scaling operations Ω , this determines the finite set</p><formula xml:id="formula_15">D Ω ,R,N(G) = ς ∈Ω r∈R D ς ,r,N(G) of possible scaled attributes in RCA 0 .</formula><p>Hence, the formal contexts considered by RCA are those obtained by adding subsets of D Ω ,R,N(G) :</p><formula xml:id="formula_16">K G,M 0 ,I 0 ,R,Ω = {K R,N(G) M ( G, M 0 , I 0 ) | M ⊆ D Ω ,R,N(G) } with K R,N(G) M (.) the operation defined in §2.2. Given K, K ∈ K G,M 0 ,I 0 ,R,Ω such that K = G, M 0 ∪ M, I 0 ∪ I and K = G, M 0 ∪ M , I 0 ∪ I , K ∨ K and K ∧ K are defined as: K ∨ K = G, M 0 ∪ (M ∪ M ), I 0 ∪ (I ∪ I ) (join) K ∧ K = G, M 0 ∪ (M ∩ M ), I 0 ∪ (I ∩ I ) (meet)</formula><p>It is clear that K K 0 ,R,Ω is closed by meet and join.</p><formula xml:id="formula_17">Property 1. K K 0 ,R,Ω , ∨, ∧ is a complete lattice</formula><p>Proof. ∨ and ∧ satisfy commutativity, associativity and the absorption laws directly from the union and intersection on sets, so this is a lattice. It is complete because finite.</p><formula xml:id="formula_18">Property 2. ∀K, K ∈ K K 0 ,R,Ω , K ⊆ K iff K = K ∧ K</formula><p>Proof. This property also comes directly from its set theoretic counterpart application to M and M :</p><formula xml:id="formula_19">K ⊆ K ⇔ M ⊆ M ⇔ M = M ∩ M ⇔ K = K ∧ K 4.</formula></div>
<div><head n="2">The context expansion function F</head><p>We reformulate RCA as based on a main single function, F K 0 ,R,Ω , the context expansion function attached to a relational context K 0 , R and a set Ω of scaling operations.</p></div>
<div><head>Definition 1 (Context expansion function)</head><p>. Given a relational context K 0 , R and a set of relational scaling operations Ω , the function F K 0 ,R,Ω :</p><formula xml:id="formula_20">K K 0 ,R,Ω → K K 0 ,R,Ω is defined by: F K 0 ,R,Ω (K) = σ * Ω (K, R, FCA * (K)))</formula><p>The function expression is independent from K 0 , K 0 is used to restrict the domain of the function so that its elements cover K 0 . From now on, we will abbreviate K K 0 ,R,Ω as K and F K 0 ,R,Ω as F. This is legitimate because, for a given relational context, K 0 , R and Ω do not change. F is an extensive and monotone internal operation for K :</p><formula xml:id="formula_21">Property 3. ∀K ∈ K , F(K) ∈ K Proof. Scaling only adds attributes from D Ω ,R,N(G) .</formula><p>Property 4 (F is extensive and monotone). The function F attached to a relational context and a set of scaling operator satisfies:</p><formula xml:id="formula_22">K ⊆ F(K) (extensivity) K ⊆ K ⇒ F(K) ⊆ F(K )<label>(monotony)</label></formula><p>Proof. extensivity holds because F eventually adds to each formal context in K new attributes scaled from FCA(K). The set of attributes can thus not be smaller. monotony holds because K ⊆ K means that M ⊆ M . This entails that the set of concepts of FCA(K) is included in that of FCA(K ), hence the set of attributes A scaled from K is included in the set A scaled from K . Since, they are added to M and M , then</p><formula xml:id="formula_23">M ∪ A ⊆ M ∪ A , hence F(K) ⊆ F(K ).</formula><p>Extensivity corresponds to the non-contracting property of the well-grounded semantics <ref type="bibr" target="#b13">[14]</ref> and monotony is also called order-preservation.</p></div>
<div><head n="4.3">Fixed points of F</head><p>Given F, it is possible to define its sets of fixed points, i.e. the sets of formal contexts closed for F, as: Definition 2 (fixed point). A formal context K ∈ K is a fixed point for a context expansion function F, if F(K) = K. We call fp(F) the set of fixed points for F.</p><p>Since K is a complete lattice and F is order-preserving (or monotone) on K , then the Knaster-Tarski theorem applies:</p><p>Theorem 1 (Knaster-Tarski theorem <ref type="bibr" target="#b14">[15]</ref>). Let K be a complete lattice and let F : K → K be an order-preserving function. Then the set of fixed points of F in L is also a complete lattice.</p><p>In particular, this warrants that there exists least and greatest fixed points of F in K (called lfp(F) and gfp(F)).</p><p>In FCA, and subsequently in RCA without circular dependencies, the images by FCA * of all fixed points of F are isomorphic. They will have the same concept lattice as seen from their intent. Even with RCA and circular dependencies (between the objects or between the contexts), this is often the case. These are these concept lattices that the RCA algorithm computes. But the example of Section 3 shows that, even in RCA 0 , there may be several fixed points for F with non isomorphic lattices. Hence the question: which fixed point is returned by RCA's well-grounded semantics <ref type="bibr" target="#b13">[14]</ref>?</p><p>4.4 The well-grounded semantics of RCA is the least fixed-point semantics RCA may be redefined as</p><formula xml:id="formula_24">RCA Ω (K 0 , R) = FCA * (F ∞ (K 0 ))</formula><p>RCA iterates F from K 0 until closure, and ultimately applies FCA * . Since K 0 belongs to K , then it computes a fixed point of F. This is the least fixed point.</p><p>Proposition 1 (The RCA algorithm computes the least fixed point). Given F the context expansion function associated to K 0 , R and Ω ,</p><formula xml:id="formula_25">RCA Ω (K 0 , R) = FCA * (lfp(F K 0 ,R,Ω )) Proof. RCA Ω (K 0 , R) = FCA * (F n (K 0 )) for some n at which F(F n (K 0 )) = F n (K 0 ) [13]. Let K ∞ = F n (K 0 ), K ∞ ∈ fp(F) (Definition 2). ∀K ∈ fp(F), K ∈ K , thus K 0 ⊆ K because all the contexts in K contain M 0 . By monotony (Property 4), K ∞ = F n (K 0 ) ⊆ F n (K) = K,</formula><p>because K is a fixed point. Thus, K ∞ is a fixed point more specific than all fixed points: it is the least fixed point.</p></div>
<div><head n="4.5">Computing the greatest fixed point</head><p>A natural question is how to obtain the greatest fixed point. In fact, under this approach this is (theoretically) surprisingly easy.</p><formula xml:id="formula_26">Proposition 2. gfp(F G,M 0 ,I 0 ,R,Ω ) = K R,N(G) D Ω ,R,N(G) ( G, M 0 , I 0 )</formula><p>Proof. This context is the greatest element of K as it contains all attributes of D Ω ,R,N(G) . It is also a fixed point because F is extensive and internal.</p><p>The lattice corresponding to the greatest fixed point will be L = FCA * (gfp(F K 0 ,R,Ω )). This result is easy but very uncomfortable. The obtained lattice may contain many useless attributes. Indeed, ∃r.c is well defined by the incidence relation, but it is of no use to RCA if c does not belong to L.</p><p>In the example of Section 3, the attribute ∃p.A belongs to D Ω ,R,N(G) though A does not belong to the maximal lattice L 3 , because it is not closed. The fact that both a and b satisfy this attribute makes that it will find its place in the intent of AB. If one considers the lattice in isolation, this is perfectly valid because the scaled context is well-defined: ∃p.A is just an attribute among others satisfied by a and b. However, if the lattice is transformed in a description logic TBox, this is not correct to refer to an undefined class. This is not the result that we expected: we need the results to be self-supported.</p><p>This problem is even more embarrassing if one wants to enumerate all fixed points, which are as many solutions to the RCA problem: many of these will feature such nonsupported attributes.</p></div>
<div><head n="5">Self-supported fixed points</head><p>We first quickly approach this problem from the concept lattice standpoint, it is better understood with both contexts and lattices together<ref type="foot" target="#foot_1">2</ref> . We then define self-supported concept lattices and consider their interaction with fixed points.</p></div>
<div><head>5.1</head><p>The lattice L of RCA 0 lattices and the lattice expansion function E From K K 0 ,R,Ω , one can define L K 0 ,R,Ω as the finite set of images of K K 0 ,R,Ω by FCA. These are concept lattices obtained by applying FCA on K 0 extended with a subset of</p><formula xml:id="formula_27">D Ω ,R,N(G) : L G,M 0 ,I 0 ,R,Ω = {FCA( G, M 0 ∪ M, I 0 ∪ I ) | M ⊆ D Ω ,R,N(G) }</formula><p>We define a specific type of homomorphisms between two concept lattices when concepts are simply mapped into concepts with the same extent and possibly increased intent. We note L L if there exists a homomorphism from L to L . In principle, L L if L L and L L, but here, is =. The order between concept lattices is straigthforwardly extended to families of concept lattices such that:</p><formula xml:id="formula_28">K L= FCA(K) K L = FCA(K ) F E FCA * κ σ * FCA * K L</formula><formula xml:id="formula_29">{L x } x∈X {L x } x∈X iff ∀x ∈ X, L x L x .</formula><p>There exists an implicit function κ :</p><formula xml:id="formula_30">L K 0 ,R,Ω → K K 0 ,R,Ω such that ∀L ∈ L K 0 ,R,Ω , L = FCA(κ(L))</formula><p>. Since is the same as = which identifies lattices containing concept having exactly the same intent and extent. κ(L) can be induced by collecting the attributes present in L intents to build the unique M, from which the corresponding I is obtained <ref type="bibr" target="#b6">[7]</ref>.</p><p>We define E K 0 ,R,Ω , the lattice expansion function attached to a relational context K 0 , R and a set Ω of scaling operators. Definition 4 (Lattice expansion function). Given a relational context K 0 , R and a set of relational scaling operations Ω the function E K 0 ,R,Ω :</p><formula xml:id="formula_31">L K 0 ,R,Ω → L K 0 ,R,Ω is defined by: E K 0 ,R,Ω (L) = FCA * (σ * Ω (κ(L), R, L))</formula><p>Here again, K 0 is only used to constrain the domain of the function, not its expression. From now on, we will abbreviate L K 0 ,R,Ω as L and E K 0 ,R,Ω as E.</p><p>Instead of considering that</p><formula xml:id="formula_32">RCA(K 0 ) = FCA * (F ∞ (K 0 )), it is possible to consider that RCA(K 0 ) = E ∞ (FCA * (K 0 )).</formula><p>Hence, RCA may be redefined as</p><formula xml:id="formula_33">RCA Ω (K 0 , R) = E ∞ (FCA * (K 0 ))</formula><p>RCA iterates E from FCA * (K 0 ) until closure. The definition of E amounts to first scaling and then applying FCA, though F does the opposite (see Figure <ref type="figure">4</ref>).</p><p>In consequence, E is the function corresponding to F in the sense that E = FCA • F • κ and FCA * • E = F • FCA * (see Figure <ref type="figure">4</ref>). Actually, the results obtained for K and F, hold exactly for L and E:</p><p>-L , is a complete lattice; -E is an internal, monotone and extensive operation of L ; -RCA Ω (K 0 , R) = lfp(E K 0 ,R,Ω ).</p><p>E inherits exactly all properties of F: the desirable ones and the problematic ones. So, apparently no progress has been made.</p></div>
<div><head n="5.2">Self-supported lattices</head><p>The problem is that both F and E are extensive functions. Hence, it is possible, starting from anywhere in K or L , to consider attributes that do not refer to concepts and these attributes will be preserved. As a consequence, there are fixed points with these unwanted attributes and they are also found in the greatest fixed point.</p><p>One may consider identifying such attributes from the greatest fixed point and forbidding them. However, these meaningless attributes are contextual: one supported attribute in the greatest fixed point, may be non supported in a smaller lattice. This is a base difficulty for enumerating these fixed points.</p><p>Instead, we consider only self-supported lattices, i.e. lattices whose intents only refer to their own concepts. Definition 5 (Self-supported lattices). Let L a set of concept lattices, its set of selfsupported lattices is</p><formula xml:id="formula_34">S(L ) = {L ∈ L K 0 ,R,Ω | ∀c ∈ L, intent(c) ⊆ D Ω ,R,L }</formula><p>The set of interesting lattices that may be returned by RCA 0 can be circumbscribed as fp(E) ∩ S(L ) as these are stable and self-supported. Moreover, by construction of K and L , they cover K 0 .</p><p>E has the advantage of preserving self-supportivity.</p><p>Proposition 3 (E is internal to S(L )). ∀L ∈ S(L ), E(L) ∈ S(L ).</p><p>Proof. If L ∈ S(L ), all attributes in intents of L are supported by concepts in L. E = FCA * • σ * Ω . σ * Ω first adds to κ(L) attributes which are supported by L. L E(L), so these concepts are still in E(L). Hence, the attributes in κ(L) and those scaled by σ * Ω are still supported by E(L).</p><p>But the definition of S does not provide a direct way to transform a non selfsupported lattice into a self-supported one: the suppression of non self-supported attributes from intents could result in non-concepts (with non closed-extent). One possible way to solve this problem consists of extracting only the attributes currently in the lattice and to apply FCA * to the resulting context.</p><p>For that purpose, we introduce a filtering function π : L → K which suppresses from the induced context (κ(L)) those attributes non supported by the lattice:</p><formula xml:id="formula_35">π(L) = G, M \ D Ω ,R,N(G)\L , I \ { g, m | m ∈ D Ω ,R,N(G)\L } such that κ(L) = G, M, I . K L= FCA(K) K L = FCA(K ) P Q FCA * κ π FCA * K L</formula><p>Fig. <ref type="figure">5</ref>. Relations between P and Q through the alternation of FCA * and π.</p><p>One can define Q : L → L , such that</p><formula xml:id="formula_36">Q(L) = FCA * (π(L))</formula><p>or P : K → K , such that P(K) = π(FCA * (K)), see Figure <ref type="figure">5</ref>.</p><p>Contrary to E, Q is anti-extensive and monotone:</p><p>Proposition 4 (Q is anti-extensive and monotone). The function Q satisfies:</p><formula xml:id="formula_37">Q(L) L (anti-extensivity) L L ⇒ Q(L) Q(L )<label>(monotony)</label></formula><p>Proof. anti-extensivity π(L) ⊆ κ(L) because π simply suppresses attributes from κ(L). It would be possible to redefine S(L ) as fp(Q). Like with E, it is possible to apply the Knaster-Tarski theorem to show that fp(Q), is a complete lattice. But like E, Q is not a closure operator as it is not idempotent. However, with the same arguments as <ref type="bibr" target="#b12">[13]</ref>, it can be argued that the repeated application of Q converges to a self-supported concept lattice.</p><formula xml:id="formula_38">Proposition 5. ∀L ∈ L , ∃n; Q n (L) = Q n+1 (L) and Q n (L) ∈ S(L ).</formula><p>Proof. First, L is a finite concept lattice. Moreover, Q(L) L, hence it not possible to build an infinite chain of non converging application of Q since at each iteration, either π suppresses no attribute (and then closure has been reached), or it suppresses at least one attribute and then a strictly smaller context is reached. Ultimately, the least fixed point lfp(Q) = FCA * (K 0 ) is reached. It is a fixed point because κ(FCA * (K 0 )) = K 0 contains no scaled attribute and thus is self-supported. When closure is reached, this is because π does not find any non-supported attribute in the lattice intents. This means that all of them are supported by the lattice.</p><formula xml:id="formula_39">K 0 lfp(F) fp(F) S(K ) gfp(F) K F ∞ P ∞ FCA * (K 0 ) lfp(E) fp(E) S(L ) gfp(E) L E ∞ Q ∞ FCA * σ * Ω FCA * σ * Ω /π FCA * σ * Ω /π FCA *</formula><p>π Fig. <ref type="figure">6</ref>. The L (resp. K ) lattice and effects of E and Q (resp. F and P) for characterising fp(E) and S(L ) (resp. fp(F) and S(K )).</p><p>By convention, we note Q ∞ the closure function associated with Q.</p><p>We end up with two operations, E and Q, the former extensive and the latter antiextensive, that may be transformed into closure operators. These functions are instrumental to provide the infimum and supremum of our desired lattices (see also Figure <ref type="figure">6</ref>): Proposition 6. lfp(E) and Q ∞ (gfp(E)) are respectively the infimum and suppremum of fp(E) ∩ S(L ) for .</p><p>Proof. lfp(E) is the lower bound for fp(E) ∩ S(L ) because it is the lower bound for fp(E). It is the infimum of fp(E) ∩ S(L ) for because FCA * (K 0 ) ∈ S(L ) and by Proposition 3 this property is preserved by E and since lfp(E) = E ∞ (FCA * (K 0 )), it belongs to S(L ).</p><p>Q ∞ (gfp(E)) is the upper bound for fp(E) ∩ S(L ) because gfp(E) contains all possible closed concepts that can be built from D Ω ,R,N(G) . Hence, those attributes not belonging to π(gfp(E)) cannot belong to any self-supported lattice. By Proposition 5,</p><formula xml:id="formula_40">Q ∞ (gfp(E)) ∈ S(L ). If Q ∞ (gfp(E)) ∈ fp(E), this entails Q ∞ (gfp(E)) ≺ E(Q ∞ (gfp(E)))</formula><p>and moreover that ∃n; E n (Q ∞ (gfp(E))) ∈ fp(E) (because E is extensive and the space is finite). But, by Proposition 3, E preserves self-supportiveness. Thus,</p><formula xml:id="formula_41">E n (Q ∞ (gfp(E))) ∈ fp(E) ∩ S(L ) and Q ∞ (gfp(E)) ≺ E n (Q ∞ (gfp(E)))</formula><p>, which is contradictory with the fact that Q ∞ (gfp(E)) is an upper-bound for all fixed points. Thus, Q ∞ (gfp(E)) is the supremum of fp(E) ∩ S(L ) for .</p></div>
<div><head n="6">Discussion</head><p>Our initial goal was to define which concept lattices could be considered as the result of RCA on a relational context. RCA provides a practical algorithm (based on F or E and FCA * ) to find out the smallest of these: lfp(E). We have characterised the greatest one: gfp(Q) or Q ∞ (gfp(E)).</p><p>We end up with two functions, complementary in their structure, one expanding the context, the other contracting it. In the perspective of enumerating all self-supported fixed points, it is tempting to either start from lfp(E) and use E or start from gfp(Q) and use Q. Unfortunately, these starting points being fixed points for these very functions, this leads nowhere. It is necessary to escape the fixed points. For instance, starting from lfp(E), one could add non-supported attributes until they become supported. Performing this attribute by attribute is not very smart. Figure <ref type="figure" target="#fig_3">3</ref> shows possible fixed points: L 2 and L 3 . They require to add 2 or 6 attributes to L 1 . A smarter strategy would consist of analysing the sets of attributes that support each others, through the induction of concepts, and adding these one by one to lfp(E) or suppressing them from gfp(Q).</p><p>There is a known bound to this set since none of the attributes not in the intents of gfp(Q) can be added, and none of those in lfp(E) can be suppressed. Finally, these sets may entertain dependencies (adding one set of attributes would immediately support another). This may be dealt with by computing such dependencies or by applying the required closure operator (E ∞ or Q ∞ ) after each addition.</p><p>Such a procedure seems to be achievable with RCA 0 , it will be more difficult to set up with RCA due to dependencies across lattices.</p></div>
<div><head n="7">Conclusions</head><p>Motivated by the requirement to extract more concepts with relational concept analysis, we gave a new, fixed-point based, semantics for RCA 0 . The main contribution of this work is the formulation of the RCA semantics in terms of fixed points of the function (F or E) at the core of RCA 0 . Then it is shown that the well-grounded semantics of RCA corresponds to the least fixed-point semantics.</p><p>We also identified as self-supported fixed points those other fixed points of interest. The least fixed point being the smaller of these. This led to develop another function (P or Q) which, together with FCA * , allows extracting the greatest of them as an alternative to RCA. This result does not mean that RCA is wrong. In FCA, conceptual scaling has been considered as a human-driven analysis tool: a knowledgeable person could provide attribute in this language for describing better the data to be analysed. In RCA, scaling is used as an extraction tool, with the drawback to potentially generate many attributes. By only extracting the least fixed point, RCA avoids generating too many of them.</p><p>In the context of extracting a TBox for a particular ABox, extracting the least fixed point is adequate since it may be relatively complex and it is a good starting point. But for other applications, such as link key candidate extraction, it is very important to have all possible fixed points because external measures are used for selecting the best one (which has no reason to be either the least or the greatest one).</p><p>The definitions and results of Sections 4 and 5 have been restricted to RCA 0 for the sake of clarity. Although this remains to be proved, they should hold for RCA as a whole. Indeed, all definitions can be applied to families of contexts and lattices, the order between them being the product order induced by the piece-wise conjunction. All operations remain monotone and extensive (or anti-extensive) as soon as the selected scaling operations are. This is enough to preserve the results.</p></div><figure xml:id="fig_0"><head /><label /><figDesc>As an RCA 0 example, consider the following ABox: A = { (a), (b), (c), (d), p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)} This can be encoded as an empty formal context and the relation of Figure 1 (left). The empty context will generate the single lattice of Figure 1 (right) (names are assigned to concepts according to their extent).</figDesc></figure>
<figure xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Relation (left) and initial concept lattice (right).</figDesc></figure>
<figure xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Scaled context (left) and final concept lattice L 1 (right).</figDesc></figure>
<figure xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Alternative concept lattices (L 2 and L 3 ).</figDesc></figure>
<figure xml:id="fig_4"><head /><label /><figDesc>, ABCD(b), ABCD(c), ABCD(d), p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)} and T 2 = {AB ∃p.AB,CD ∃p.CD, ABCD ∃p.ABCD} A 2 = {AB(a), AB(b),CD(c),CD(d), p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)} and T 3 = {AB ABC ABD ∃p.AB,C ABC CD ∃p.D, D ABD CD ∃p.C, ABC ABCD ∃p.ABD, ABD ABCD ∃p.ABC,CD ABCD ∃p.CD, ABCD ∃p.ABCD} A 3 = {AB(a), AB(b),C(c), D(d), p(a, b), p(b, a), p(c, d), p(d, c), p(a, a), p(b, b)}</figDesc></figure>
<figure xml:id="fig_5"><head>Fig. 4 .Definition 3 (</head><label>43</label><figDesc>Fig. 4. Relations between F and E through the alternation of FCA * and σ * Ω .</figDesc></figure>
<figure xml:id="fig_6"><head /><label /><figDesc>Hence, FCA * (π(L)) FCA * (κ(L)) because the latter contain all concepts of the former (identified by extent) eventually featuring the removed attributes. Moreover,FCA * (κ(L)) = L by definition, thus Q(L) = FCA * (π(L)) FCA * (κ(L)) = L. monotony If L L , then κ(L) ⊆ κ(L ),otherwise FCA * would not generate a smaller lattice. In addition, L L entails N(G) \ L ⊇ N(G) \ L which entails D Ω ,R,N(G)\L ⊇ D Ω ,R,N(G)\L , which finally together leads to M \ D Ω ,R,N(G)\L ⊆ M \ D Ω ,R,N(G)\L . Then, π(L) ⊆ π(L ) because a smaller context supported by a smaller lattice cannot result in a larger context. Hence, Q(L) = FCA * (π(L)) FCA * (π(L )) = Q(L ).</figDesc></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>An anonymous reviewer complements the remarks of §2.2 noting that RCA 0 is also very related to Graph-FCA as they both have only one context and using existential scaling.</p></note>
			<note place="foot" n="2" xml:id="foot_1"><p>Instead of developing both K and L independently and maintaining an equivalence between them, it would have been possible to use a more FCA-like structure associating the corresponding contexts and lattices.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>This work has been partially funded by the <rs type="funder">ANR Elker</rs> project (<rs type="grantNumber">ANR-17-CE23-0007-01</rs>). The author thanks <rs type="person">Philippe Besnard</rs> for pointing to the Knaster-Tarski theorem.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_XW2jY5V">
					<idno type="grant-number">ANR-17-CE23-0007-01</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Data interlinking through robust linkkey extraction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st european conference on artificial intelligence (ECAI)</title>
		<meeting>21st european conference on artificial intelligence (ECAI)<address><addrLine>Praha (CZ)</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="15" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Link key candidate extraction with relational concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vizzini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="2" to="20" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m">The description logic handbook: theory, implementations and applications</title>
		<editor>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Patel-Schneider</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Introduction to formal concept analysis</title>
		<author>
			<persName><forename type="first">R</forename><surname>Belohlávek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<pubPlace>Olomouc (CZ)</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univerzita Palackého</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. rep.</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Graph-FCA: an extension of formal concept analysis to knowledge graphs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cellier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="81" to="102" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Pattern structures and their projections</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th International conference on conceptual structures (ICCS)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>9th International conference on conceptual structures (ICCS)</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2120</biblScope>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Formal concept analysis: mathematical foundations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wille</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Heidelberg</publisher>
			<pubPlace>DE)</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Practical comparison of FCA extensions to model indeterminate value of ternary data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Keip</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ferré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gutierrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Silvie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th International Conference on Concept Lattices and Their Applications (CLA)</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<meeting>15th International Conference on Concept Lattices and Their Applications (CLA)<address><addrLine>Tallinn (EE)</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">2668</biblScope>
			<biblScope unit="page" from="197" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Pattern structures for analyzing complex data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Workshop on Rough Sets, Fuzzy Sets, Data Mining, and Granular-Soft Computing (RSFDGrC)</title>
		<title level="s">Lecture notes in computer science</title>
		<meeting>International Workshop on Rough Sets, Fuzzy Sets, Data Mining, and Granular-Soft Computing (RSFDGrC)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5908</biblScope>
			<biblScope unit="page" from="33" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Concept lattices of a relational structure</title>
		<author>
			<persName><forename type="first">J</forename><surname>Kötters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21th International Conference on Conceptual Structures (ICCS)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>21th International Conference on Conceptual Structures (ICCS)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7735</biblScope>
			<biblScope unit="page" from="301" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Reasoning and revision in hybrid representation systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Nebel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">422</biblScope>
			<date type="published" when="1990">1990</date>
			<publisher>Springer Verlag</publisher>
			<pubPlace>Berlin (DE)</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Logical scaling in formal concept analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Prediger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th International Conference on Conceptual Structures (ICCS)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>5th International Conference on Conceptual Structures (ICCS)<address><addrLine>Seattle (WA US)</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1257</biblScope>
			<biblScope unit="page" from="332" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Relational concept analysis: mining concept lattices from multi-relational data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rouane Hacene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valtchev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="81" to="108" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Soundness and completeness of relational concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rouane Hacene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Huchard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valtchev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11h International Conference on Formal Concept Analysis (ICFCA)</title>
		<title level="s">Lecture Notes in Computer science</title>
		<meeting>11h International Conference on Formal Concept Analysis (ICFCA)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7880</biblScope>
			<biblScope unit="page" from="228" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A lattice-theoretical fixpoint theorem and its applications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Tarski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pacific journal of mathematics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="285" to="309" />
			<date type="published" when="1955">1955</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</teiCorpus></text>
</TEI>