<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">RDF graph anonymization robust to data linkage</title>
				<funder ref="#_qsRNk9t">
					<orgName type="full">Auvergne-Rhône-Alpes region</orgName>
				</funder>
				<funder ref="#_JccSpCv">
					<orgName type="full">French Programme Investissement d&apos;Avenir</orgName>
					<orgName type="abbreviated">PIA</orgName>
				</funder>
				<funder ref="#_B5ptaAV">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_ERdM2JG">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Rémy</forename><surname>Delanaux</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Lyon 1</orgName>
								<orgName type="institution" key="instit2">LIRIS CNRS</orgName>
								<address>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marie-Christine</forename><surname>Rousset</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Université Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">INRIA</orgName>
								<orgName type="institution" key="instit4">Grenoble INP</orgName>
								<address>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Institut Universitaire de France</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Romuald</forename><surname>Thion</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Lyon 1</orgName>
								<orgName type="institution" key="instit2">LIRIS CNRS</orgName>
								<address>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Remy</forename><surname>Delanaux</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Lyon 1</orgName>
								<orgName type="institution" key="instit2">LIRIS CNRS</orgName>
								<address>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">RDF graph anonymization robust to data linkage</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F97C66CC7616522204EB2D3685C7FC61</idno>
					<idno type="DOI">10.1007/978-3-030-34223-4_31</idno>
					<note type="submission">Submitted on 19 Jan 2020</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Linked Open Data</term>
					<term>Data privacy</term>
					<term>RDF anonymization</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Since its inception, the Linked Open Data (LOD) paradigm has allowed to publish data on the Web and interconnect uniquely identified objects by realizing widely open information exchange and data sharing. The LOD cloud is rapidly growing and contains 1,231 RDF graphs connected by 16,132 links (as of June 2018). Since 2007, the number of RDF graphs published in the LOD has seen an increase of about two orders of magnitude. Nevertheless, the participation of many organizations and institutions to the LOD movement is hindered by individual privacy concerns. Personal data are ubiquitous in many of these data sources and recent regulations about personal data, such as the EU GDPR General Data Protection Regulation (GDPR) make these organizations reluctant to publish their data in the LOD.</p><p>While there has been some effort <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b21">22]</ref> to bring data anonymization techniques from the relational database world to the LOD, such as variations of k-anonymity <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b15">16]</ref>, most of the state of the art is mainly based on differential privacy techniques for relational data <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b16">17]</ref>. However, differential privacy is not a perfect match for Linked Data, focusing more on statistical integrity rather than accurate, qualitative query results which represents the main usage of Linked Data through SPARQL endpoints <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b18">19]</ref>. Differential privacy is indeed useful whenever the aggregate results of data analysis (such as statistics about groups of individuals) can be seamlessly published. Whereas this is highly desirable in many applications, it becomes not sufficient in privacy-preserving data publishing (PPDP) <ref type="bibr" target="#b8">[9]</ref> scenarios where the privacy of individuals need to be protected while at the same time ensuring that the published data can be utilized in practice. Whereas the underpinnings of PPDP under its most prominent form, such as anonymization, have been widely studied for relational data (see <ref type="bibr" target="#b8">[9]</ref> for a comprehensive survey), the theoretical foundations for PPDP in the context of Linked Data have only been recently laid out in <ref type="bibr" target="#b11">[12]</ref> by focusing on the theoretical study of its computational complexity</p><p>In this paper, we build upon the foundations of <ref type="bibr" target="#b11">[12]</ref> by focusing on the linkage safety requirement and present practical algorithms to compute the anonymization operations needed to achieve such a requirement when a graph G is linked to external graphs in the LOD. By relying on the computational complexity of the linkage safety problem, which is AC 0 in data complexity under the open-world assumption, we address the problem of actually computing a safety-compliant sequence of anonymization operations setting up their guarantees against linkage attacks. In doing this, we also devote special care to :sameAs links (i.e. links expressed in RDF syntax) that can be either explicit in the original graph G linking to entities in external graphs or derived by inference mechanisms on G itself. In particular, this approach exhibits two distinguishing features. First, it is query-based since the privacy policies as well as the anonymization operations are specified by means of conjunctive queries and updates in SPARQL, respectively. Second, our approach is data-independent since, given a privacy policy (specified as a set of privacy queries), our algorithms produce anonymization operations (under the form of delete and update queries) with the guarantee that their application to any RDF graph will satisfy the safety requirement. Our contributions can be summarized as follows: we first ground the linkage safety problem to the sequence of anonymization operations necessary to enforce it by providing a novel data-independent definition of safety; such a definition considers a set of privacy queries as input and does not look at the actual graph instances (Section 4); as such, it departs from the basic definition of linkage safety of <ref type="bibr" target="#b11">[12]</ref>. We then provide sufficient conditions under which an anonymization instance is safe given a set of privacy queries and design an anonymization algorithm that solves the above query-based safety requirement and study its runtime complexity (Section 5). Next, we introduce :sameAs links and show that slight modification of our algorithm is robust to them (Section 6) and finally, we provide a quick discussion about the evaluation of our algorithms and the remaining utility of the anonymized graphs (Section 7) that confirms the good behavior of our framework in practice. Related work is discussed in Section 2, and we provide the necessary background in Section 3. We conclude in Section 8. All proofs and implementations are available online in a companion appendix. <ref type="foot" target="#foot_0">4</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>A query-based approach to privacy-preserving RDF data publishing has been presented in <ref type="bibr" target="#b5">[6]</ref>, in which the focus was to check the compatibility between a privacy policy and an utility policy (both specified as queries) and to build anonymizations preserving the answers to a set of utility queries (when compatibility is ensured). However, the above approach suffers from the lack of resilience against privacy breaches caused by linking external datasets, which is clearly a recurrent situation in the LOD.</p><p>In line with existing works <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b10">11]</ref> on safety models defined in terms of secret or privacy queries for relational data. A query-based safety model for RDF data has been introduced in <ref type="bibr" target="#b11">[12]</ref> where linking RDF graphs is reduced to their union, several results are provided on the computational complexity of the decision problems. In our paper, we slightly extend the considered safety model and we address the data-independent construction problem underpinning safety, i.e. how to produce a sequence of update operations that are safe for any RDF graph, given a privacy policy expressed as queries.</p><p>Graph specific, but non RDF, declinations of privacy criteria and related attacks have been proposed such as l-opacity <ref type="bibr" target="#b20">[21]</ref> or k-isomorphism <ref type="bibr" target="#b4">[5]</ref>, the typical use cases being social networks graphs. In this paper, we follow a complementary direction where the privacy criteria is declared by the data protection officer and not fixed, with a concrete and efficient procedure that uses standard and efficient SQPARL engines to enforce them. Compared to existing approaches based on k-anonymity in RDF graphs <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b21">22]</ref>, we focus on generalizations that replace constants by blank nodes. We have also shown that in some cases, triple suppressions are required in addition to generalizations for guaranteeing safe anonymizations.</p><p>Privacy-preserving record linkage has been recently considered in <ref type="bibr" target="#b23">[24]</ref> as the problem of identifying and linking records that correspond to the same real-world entity without revealing any sensitive information about these entities. For preserving privacy while allowing the linkage, masking functions are proposed to transform original data in such a way that there exists a specific functional relationship between the original data and the masked data. The problem of privacy-preserving record linkage is a difficult problem that is significantly different from the privacy-preserving data publishing problem considered in this paper, in which sameAs links are input of the anonymization process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Formal background</head><p>We recall the usual concepts for RDF graphs and SPARQL queries as formalized in <ref type="bibr" target="#b12">[13]</ref>. Let I, L and B be countably infinite pairwise disjoint sets representing respectively IRIs, literals and blank nodes. IRIs (Internationalized Resource Identifiers) are standard identifiers used for denoting any Web resource described in RDF within the LOD. We denote by T = I ∪ L ∪ B the set of terms, in which we distinguish constants (IRIs and literals) from blank nodes, which are used to model unknown IRIs or literals like in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b2">3]</ref> and correspond to labeled nulls <ref type="bibr" target="#b0">[1]</ref>.</p><p>We also assume an infinite set V of variables disjoint from the above sets. Throughout this paper, we adhere to the SPARQL conventions: variables in V are prefixed with a question mark (?), IRIs in I are prefixed with a colon (:), blank nodes in B are prefixed with an underscore and a colon ( :). Definition 1 (RDF graph and graph pattern). An RDF graph is a finite set of RDF triples (s, p, o), where (s, p, o)</p><formula xml:id="formula_0">∈ (I ∪ B) × I × (I ∪ L ∪ B). A triple pattern is a triple (s, p, o) ∈ (I ∪ B ∪ V) × (I ∪ V) × (I ∪ L ∪ B ∪ V).</formula><p>A graph pattern is a finite set of triple patterns.</p><p>We can now define the three types of queries that we consider. Definition 2 corresponds to conjunctive queries and will be the basis for formalizing the sensitive information that must not be disclosed. Definition 6 corresponds to counting queries which will model a form of utility that it may be useful to preserve for analytical tasks. Finally, Definition 7 describes update queries, modeling the anonymization operations handled in our framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (Conjunctive query).</head><p>A conjunctive query Q is defined by an expression SELECT x WHERE GP (x, ȳ) where GP (x, ȳ), also denoted body(Q), is a graph pattern without blank nodes and x ∪ ȳ is the set of its variables, among which x are the result variables, and the subset of variables in predicate position is disjoint from the subset of variables in subject or object position. A conjunctive query Q is alternatively written as a pair Q = x, GP . A boolean query is a query of the form Q = ∅, GP .</p><p>Conjunctive queries with variables in predicate position are allowed, if such variables do not appear in a subject or object position. This ensures that within a conjunctive query, all occurrences of a given variable are in the same connected component (see Definition 3).</p><p>Example 1. The conjunctive query SELECT ?p WHERE {?s ?p ?o. ?s a :VIP.} conforms to Definition 2. Intuitively, this query selects all properties of subjects who are "VIP".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Connected components of a query). Given a conjunctive query</head><formula xml:id="formula_1">Q = x, GP , let G Q = N Q , E Q</formula><p>be the undirected graph defined as follows: its nodes N Q are the distinct variables and constants appearing in subject or object position in GP , and its edges E Q are the pairs of nodes (n i , n j ) such that there exists a triple</p><formula xml:id="formula_2">(n i , p, n j ) or (n j , p, n i ) in GP . Each subgraph SG Q of G Q corresponds to the subgraph of body(Q) made of the set of triples (s, p, o) such that either (s, o) or (o, s) is an edge of SG Q . By slight abuse of notation, we will call the connected components of the query Q the (disjoint) subsets of GP = body(Q) corresponding to the connected components of G Q . A connected component GP C of the query Q is called boolean when it contains no result variable.</formula><p>Example 2. Let Q be the following query in the SPARQL syntax where a is a shorthand for rdf:type, Q has two connected components GP 1 and GP 2 :</p><p>SELECT ?x ?y WHERE { ?x :seenBy ?z.</p><p>?z :specialistOf ?y. ?v a :VIP. ?v :isHospitalized true. } GP1 = { ?x :seenBy ?z.</p><p>?z :specialistOf ?y. } GP2 = { ?v a :VIP. ?v :isHospitalized true. } Definition 4 (Critical terms). A variable (resp. constant) in subject or object position having several occurrences within the body of a query is called a join variable (resp. join constant). We name join variables, join constants and result variables of a query as its critical terms.</p><p>Example 3. The query SELECT ?p WHERE { ?s ?p ?o. ?s a :VIP.} has two critical terms: ?s, which has two occurrences, and ?p which is a result variable. Critical terms are computed in Algorithm 1 (Lines 5 to 10).</p><p>The evaluation of a query Q = x, GP over an RDF graph G consists in finding mappings µ assigning the variables in GP to terms such that the set of triples, denoted µ(GP ), obtained by replacing with µ(z) each variable z appearing in GP , is included in G. The corresponding answer is defined as the tuple of terms µ(x) assigned by µ to the result variables.</p><p>Definition 5 (Evaluation of a conjunctive query). Let Q = x, GP be a conjunctive query and let G be an RDF graph. The answer set of Q over G is defined by : W ) is a graph pattern whose set of variables is x (resp. z) such that x ⊆ z; and I is a graph pattern where blank nodes are allowed, whose set of variables is ȳ such that ȳ ⊆ z. isNotBlank( b) is a parameter where b is a set of variables such that b ⊆ z. The evaluation of Q u over an RDF graph G is defined by:</p><formula xml:id="formula_3">Ans(Q, G) = {µ(x) | µ(GP ) ⊆ G}.</formula><formula xml:id="formula_4">Result(Q u , G) = G \ {µ(D(x))|µ(W (z)) ⊆ G ∧ ∀x ∈ b, µ(x) / ∈ B} ∪ {µ (I(ȳ))|µ(W (z)) ⊆ G ∧ ∀x ∈ b, µ(x) / ∈ B}</formula><p>where µ is an extension of µ renaming blank nodes from I(ȳ) to fresh blank nodes, i.e. a mapping such that µ (x) = µ(x) when x ∈ z and µ (x) = b new ∈ B otherwise. The application of an update query Q u on a graph G is written</p><formula xml:id="formula_5">Q u (G) = Result(Q u , G). This notation is extended to a sequence of operations O = Q 1 u , . . . Q n u by O(G) = Q n u (. . . (Q 1 u (G)) . . .).</formula><p>We generalize the definition of a safe anonymization introduced in <ref type="bibr" target="#b11">[12]</ref> as follows: an RDF graph is safely anonymized if it does not disclose any new answer to a set of privacy queries when it is joined with any external RDF graph. Additionally, compared to <ref type="bibr" target="#b11">[12]</ref>, we define a notion of data-independent safety for a sequence of anonymization operations independently of any RDF graph. Given an RDF graph G, a sequence O of update queries called anonymization operations and a set P of conjunctive privacy queries, the safety of the anonymization instance (G, O, P) is formally defined as follows.</p><p>Definition 8 (Safe anonymization instance). An anonymization instance (G, O, P) is safe iff for every RDF graph G , for every P ∈ P and for every tuple of constants c, if c ∈ Ans(P, O(G) ∪ G ) then c ∈ Ans(P, G ).</p><p>Notice that the safety property is stronger than the privacy property defined in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b5">6]</ref> which requires that for every privacy query P , Ans(P, O(G)) does not contain any tuple made only of constants. In contrast with <ref type="bibr" target="#b11">[12]</ref>, the safety problem that we consider is data-independent and is a construction problem. Given a set of privacy queries, the goal is to build anonymization operations guaranteed to produce a safe anonymization when applied to any RDF graph, as follows.</p><p>Definition 9 (Safe sequence of anonymization operations). Let O be a sequence of anonymization operations, let P be a set of privacy queries, O is safe for P iff (G, O, P) is safe for every RDF graph G.</p><p>Problem 1. The data-independent Safety problem.</p><p>Input : P a set of privacy queries Output: A sequence O of update operations such that O is safe for P.</p><p>Our approach to solve Problem 1 is to favour whenever possible update operations that replace IRIs and literals by blank nodes over update operations that delete triples. We exploit the standard semantics of blank nodes that interprets them as existential variables in the scope of local graphs. As a consequence, two blank nodes appearing in two distinct RDF graphs cannot be equated. The privacy-preserving approach described in <ref type="bibr" target="#b5">[6]</ref> is also data-independent but is based on deleting operations that may lead to unsafe anonymizations, as shown in Example 4.</p><p>Example 4. Let consider the following privacy query P stating that IRIs of people seen by a specialist of a disease should not be disclosed.</p><p>SELECT ?x WHERE { ?x :seenBy ?y.</p><p>?y :specialistOf ?z. }</p><p>Let the RDF graph to anonymize be G that is made of the following triples:</p><p>:bob :seenBy :mary. :mary :specialistOf :cancer. :mary :worksAt :hospital1. :ann :seenBy :mary. :jim :worksAt :hospital1.</p><p>Let O 1 be the update query deleting all the :seenBy triples, written as DELETE { ?x :seenBy ?y. } WHERE { ?x :seenBy ?y. } in SPARQL. The resulting anonymized RDF graph O 1 (G) is as follows:</p><p>:mary :specialistOf :cancer.</p><p>:mary :worksAt :hospital1. :jim :worksAt :hospital1.</p><p>O 1 preserves privacy (the evaluation of P against O 1 (G) returns no answer). However, O 1 is not safe since the union of O 1 (G) with an external RDF graph G containing the triple (:bob, :seenBy, :mary) will provide :bob as an answer. This example shows that the problem for safety comes from a possible join between an internal and an external constant (:mary here). This can be avoided by replacing critical constants by blank nodes. <ref type="bibr">Example</ref>  It is worth noticing that the result of the counting query Count(P ) is preserved i.e. it returns the same value as when evaluated on the original RDF graph G. Many other utility queries are preserved, such as for instance the one asking for who works at which hospital.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Safe anonymization of an RDF graph</head><p>In this section, we provide an algorithm that computes a solution to the Safety problem. We first prove a sufficient condition (Theorem 1) guaranteeing that an anonymization instance is safe, then we define an algorithm based on this condition. We extend the definition of a mapping, which is now allowed to map constants to blank nodes: an anonymization mapping µ is a function V ∪I∪L → T. For a triple τ = (s, p, o) we write µ(τ ) for (µ(s), µ(p), µ(o)). Theorem 1 is progressively built on two conditions that must be satisfied by all the connected components of the privacy queries. Theorem 1. An anonymization instance (G, O, P) is safe if the following conditions hold for every connected component GP c of all privacy queries P ∈ P:</p><p>(i) for every critical term x of GP c , for every triple τ ∈ GP c where x appears, for each anonymization mapping µ s.t. µ(τ ) ∈ O(G), µ(x) ∈ B holds; (ii) if GP c does not contain any result variable, then there exists a triple pattern of GP c without any image in O(G) by an anonymization mapping.</p><p>The intuition of condition (i) is that if all the images of critical terms are blank nodes, it is impossible to graft external pieces of information to the anonymized graph as they cannot have common blank nodes. Condition (ii) deals with boolean connected components with no result variable. We are now able to design an anonymization algorithm that solves the Safety problem. Algorithm 1 computes a sequence<ref type="foot" target="#foot_1">5</ref> of operations O for a privacy policy P such that O is safe for P. Operations are computed for each connected component of each privacy query from P, the crux being to turn conditions (i) and (ii) into update queries.   The starting point of Algorithm 1 is to compute joins variable, constants and then critical terms (Lines 5 to 10). The update queries that replace the images of critical terms by blank nodes are built from Line 14 to Line 17. The subtle point is that as many update queries as the connected subsets of the component GP c need to be constructed. Considering these subsets in decreasing order of cardinality (Line 11) and using the isNotBlank(x ) construct guarantees that all the images of a critical term in a given RDF graph will be replaced only once. Non-connected subsets of GP c are skipped because their own connected components are handled afterwards. Finally, if the connected component under scrutiny is boolean, one of its triple is deleted (Line 20).</p><formula xml:id="formula_6">forall (s, p, o) ∈ GPc do 7 if s ∈ V ∨ s ∈ I then I[s] = I[s] + 1; 8 if o ∈ V ∨ o ∈ I ∨ o ∈ L then I[o] = I[o] + 1; 9 Let xc := {v | v ∈ xi ∧ ∃τ ∈ GPc s.t. v ∈ τ }; 10 Let Tcrit := {t | I[t] &gt; 1} ∪ xc; 11 Let SGPc = {X | X ⊆ GPc ∧ X = ∅ ∧ X is connected}</formula><p>When applied to the privacy query considered in Example 4, operation O 2 reported in Example 5 is the first one generated at Line 17. When applied to Example 2, Algorithm 1 will sequentially generate anonymization operations starting from those replacing the images of all the variables by blank nodes (since all its variables are critical), followed by those deleting all the triples corresponding to one of the triple patterns (?v a :VIP or ?v :isHospitalized true) in the boolean connected component. Note that anonymizations may create an RDF graph where some properties have been replaced by blank nodes. In this case, the output is a generalized RDF graph. Theorem 2 states the soundness and computational complexity of Algorithm 1. Since Algorithm 1 is data-independent, its exponential worst-case complexity (due to the powerset SGP c computed on Line 11) is not necessarily an important limitation in practice, as it will be demonstrated in Section 7.</p><p>Theorem 2. Let O = find-safe-ops(P) be the sequence of anonymization operations returned by Algorithm 1 applied to the set P of privacy queries: O is safe for P. The worst-case computational complexity of Algorithm 1 is exponential in in the size of P.</p><p>Algorithm 2 (reported in the companion appendix) is a polynomial approximation of Algorithm 1 obtained as follows: instead of considering all possible subsets of triple patterns of SG c (Line 12), we simply construct update queries that replace, in each triple pattern τ ∈ GP c , every critical term with a fresh blank node. As a result, there does not exist anymore any equality between images of join variables, literals or IRIs (while in Algorithm 1 all occurrences of each critical term were replaced by the same blank node). For instance, Algorithm 2 generates a sequence of three update queries, one for each triple, more general than O 2 from Example 5 of Section 4. Theorem 3 states that Algorithm 2 is sound but leads to anonymizations that are more general than those produced by Algorithm 1.</p><p>Theorem 3. The worst-case computational complexity of Algorithm 2 is polynomial in the size of P. Let O and O be the result of applying respectively Algorithm 1 and Algorithm 2 (with the same non deterministic choices) to a set P of privacy queries: for any RDF graph G, (G, O, P) is safe and</p><formula xml:id="formula_7">G |= O(G) and O(G) |= O (G).</formula><p>Theorem 4 establishes that the anonymization operations computed by Algorithm 1 preserve some information on Count(P ) for privacy queries P with no boolean connected component. It is not necessarily the case for Algorithm 2. 6 Safe anonymization robust to :sameAs links One of the fundamental assets of the LOD is the possibility to assert that two resources are the same by stating owl:sameAs triples (shortened to :sameAs later), also known as entity linking. We do not consider :sameAs between properties and we interpret :sameAs triples (called :sameAs links) as equality between constants (including blank nodes) that are in subject or object position. With this interpretation, :sameAs links can also be inferred by a logical reasoning on additional knowledge known on some properties (e.g. that a property is functional). In this section, we study the impact of both explicit and inferred :sameAs links on safety.</p><p>We extend Definition 5 to the semantics of query answering in presence of a set sameAs of :sameAs links. Let closure(sameAs) be the transitive, reflexive and symmetric closure of sameAs. This set can be computed in polynomial time. Definition 10 (Answer of a query modulo sameAs). Let Q be a conjunctive query, G an RDF graph and sameAs a set of :sameAs links. A tuple ā is an answer to Q over G modulo sameAs iff there exists (b 0 , :sameAs, b 0 ), . . ., O is safe modulo sameAs for P if (G, O, P) is safe modulo sameAs for every RDF graph G and for every set sameAs of :sameAs links.</p><formula xml:id="formula_8">(b k , :sameAs, b k ) in closure(sameAs) s.t. ā ∈ Ans(Q, G[b 0 ← b 0 , . . . , b k ← b k ]). We note Ans sameAs (Q, G) the answer set of Q over G modulo sameAs.</formula><p>We first study how to build anonymization operations that are robust to explicit :sameAs links. Then, we focus on handling the case of inferred :sameAs links through knowledge.</p><p>Theorem 5 establishes that Algorithm 1 (and thus Algorithm 2) computes safe anonymizations even in presence of a set sameAs of explicit :sameAs links.</p><p>Theorem 5. Let O be the result of applying Algorithm 1 to a set P of privacy queries: for any set sameAs of explicit :sameAs links, O is safe modulo sameAs for P.</p><p>We address two cases in which knowledge on properties may infer equalities. The first case occurs in the ontology axiomatization of the OWL language 6 when some of the properties are functional or inverse functional, as in Definition 12, where we model equalities by :sameAs links. Definition 12. A property p is functional iff for every ?x, ?y 1 , ?y 2 :</p><p>(?x, p, ?y 1 ) ∧ (?x, p, ?y 2 ) ⇒ (?y 1 , :sameAs, ?y 2 ). A property p is inverse functional iff for every ?x, ?y 1 , ?y 2 : (?y 1 , p, ?x) ∧ (?y 2 , p, ?x) ⇒ (?y 1 , :sameAs, ?y 2 ).</p><p>For example, declaring that property :bossOf as inverse functional expresses the constraint that every person has only one boss. As shown in Example 6, exploiting this knowledge may lead to re-identifying blank nodes that have been produced by the previous anonymization algorithms. From O(G) ∪ G and the inverse functionality of :bossOf, it can be inferred first (:jim, :sameAs, :b1) and second (:bob, :sameAs, :b). Consequently, :b is re-identified as :bob, which is returned as answer of P over O(G) ∪ G modulo sameAs, and the anonymization operation O is not safe.</p><p>One solution is to add a privacy query for each functional property p and for each inverse functional property q, respectively SELECT ?x WHERE {?x p ?y.} and SELECT ?x WHERE {?y q ?x.}. By doing so, the update queries returned by our algorithms will replace each constant in subject position of a functional property by a fresh blank node, and each constant in an object position of an inverse functional property by a fresh blank node. In the previous example, the constant :ann in ( :b1, :bossOf, :ann) would be replaced by a fresh blank node.</p><p>The second case that we consider may lead to infer equalities (modeled as :sameAs links) when a property is completely known, i.e., when its closure is available in an external RDF graph. For instance, suppose that the closure of the property :seenBy is stored in an extension of the external RDF graph G containing the following triples:</p><p>:bob :seenBy :mary. :alice :seenBy :ann. :john :seenBy :ann.</p><p>:tim :seenBy :ann.</p><p>Knowing that G is the complete extension of the seenBy predicate allows to infer ( :b, :sameAs, :bob) and thus to re-identify the blank node :b.</p><p>One solution is to add a privacy query SELECT ?x ?y WHERE { ?x p ?y } for each property p for which we suspect that a closure could occur in the LOD. Then, the update queries returned by our algorithms will replace each constant in the subject or object position of such a property by a fresh blank node. For instance, in the Example 6, the constant :mary in ( :b, :seenBy, :mary) would be replaced by a fresh blank node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experimental evaluation</head><p>We have evaluated the runtime performance of the anonymization process produced by Algorithm 1 and the resulting loss of precision on three real RDF graphs for which we have designed a reference privacy query as a union of privacy conjunctive queries. Table <ref type="table" target="#tab_1">1</ref> provides the indicators characterizing each RDF graph used in the experiments: #T riples (respectively #IRIs and #Blanks) denotes the number of triples (respectively unique IRIs and unique blank nodes) in the graph, and #P rivQuery denotes the size of the reference privacy query (i.e., the sum of the triple patterns in each conjunctive privacy query). The reference privacy queries are reported in the companion appendix. The source code of our prototype is openly available on GitHub </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Runtime performances</head><p>The average runtime of Algorithm 1 has been measured over 10 executions for each graph, using the reference privacy queries as input. Table <ref type="table" target="#tab_2">2</ref> reports the results: T-Algo1 denotes the time in seconds for computing the sequence of anonymization operations by Algorithm 1 (which depends only of the reference privacy query) whereas T-Anonym denotes the time in seconds required for applying them on the different RDF graphs to compute their anonymized version, and #UpdateQueries is the number of update queries returned by Algorithm 1. The anonymization time is reasonable in all cases. The cost for anonymizing the Swedish Heritage graph is due to a few update queries with graph patterns having many occurrences in the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Evaluation of the precision loss</head><p>We have evaluated the precision loss and how it depends on the privacy query specificity defined relatively to the reference privacy query. We distinguish the absolute precision loss which is the the number of blank nodes introduced by the anonymization process, from the relative precision loss which the ratio of it with the total number of IRIs in the input graph.</p><p>From each reference privacy query P , we create more specific privacy queries by applying a set of random mutations that replace a variable by a constant in one of the privacy conjunctive queries. The specificity of a privacy query P obtained by this mutation process is defined by specif</p><formula xml:id="formula_9">(P ) = | Ans(P , G)| / | Ans(P, G)|.</formula><p>By construction, specif(P ) is a normalized value between 0 and 1, as any mutated privacy query P is more specific than the reference privacy query P .</p><p>Results displayed on Figures <ref type="figure" target="#fig_8">1a to 1c</ref> show that the precision loss grows linearly with the policy specificity: the less precise the privacy policy is in its selection of data, the more blank nodes will be inserted in the graph. We can also observe that precision is very dependent on the input: if the privacy policy only cover a specific part of the whole data (e.g. only the subscriptions in the data of whole transportation network) then its impact is quite small: for the TCL graph (Figure <ref type="figure" target="#fig_8">1a</ref>), this precision value only drops marginally (99.9% to 99.4%). The trend is similar for other graphs: precision drops when the privacy policy gets more general. It drops to 85% in the case of the Swedish Heritage graph, and 96% for the Drugbank graph. This confirms that in general, using plausible privacy policy semantics, the number of IRIs lost in the anonymization process is not huge.</p><p>However, Figure <ref type="figure" target="#fig_8">1c</ref> for the Swedish Heritage graph have a quite large spread on the x = 0 line. Indeed, the privacy policy forbids the disclosure of very general pieces of information such as the description of objects in the graph. Thus, this leads to many replacements by blank nodes in such a situation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have tackled the safety problem for Linked Open Data by providing a dataindependent version and grounding it in a set of privacy queries (expressed in SPARQL). Our algorithms let seamlessly construct sequences of anonymization operations in order to prevent privacy leakages due to external RDF graphs along with explicit or inferred knowledge (under the form of sameAs links). We have proved the soundness of our anonymization algorithms and shown their runtime complexity. We have conducted experiments showing the quality of our anonymization and the performance of its operations.</p><p>Our approach can be seamlessly combined with existing privacy-preserving approaches. Once the RDF graph is transformed according to the operations generated by our algorithms, one could apply any other method to the obtained RDF graph. In particular, it could be verified whether the resulting anonymized RDF graph verifies some desired k-anonymity property. The adaptation of kanonymity approaches for a more fine-tuned generalization of literals, see for instance <ref type="bibr" target="#b21">[22]</ref>, is planned as future work. Our approach can be also combined with ontology-based query rewriting for first-order rewritable ontological languages such as RDFS <ref type="bibr" target="#b2">[3]</ref>, DL-Lite <ref type="bibr" target="#b3">[4]</ref> or EL fragments <ref type="bibr" target="#b13">[14]</ref>, by providing as input to Algorithm 1 the rewritings of the privacy queries.</p><p>We envision several other directions of future work. The first is to study the potential risk for re-identification of delegating the generation of fresh blank nodes to a standard SPARQL engine. Next, since the conditions provided in Theorem 1 for guaranteeing that a anonymization instance is safe are sufficient but not necessary, it would be beneficial to explore both sufficient and necessary conditions. We also plan to extend our safety model to handle additional knowledge, like for instance that some properties are equivalent. Finally, we plan to study whether considering the data-dependent version of the safety problem could lead to more specific anonymization operations while guaranteeing safety.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 6 (</head><label>6</label><figDesc>Counting query). Let Q be a conjunctive query. The query Count(Q) is a counting query, whose answer over a graph G is defined by: Ans(Count(Q), G) = | Ans(Q, G)| We now define an additional ingredient: update queries. Intuitively, an update query DELETE D(x) INSERT I(ȳ) WHERE W (z) isNotBlank( b) executed on a graph G searches for the instances of the graph pattern W (z) in G, then deletes the instances of D(x) and finally inserts the I(ȳ) part. The isNotBlank operator will be used in Algorithm 1 to avoid replacing the images of critical terms that are already blank nodes. Definition 7 (Update query). An update query (or update operation) Q u is defined by DELETE D(x) INSERT I(ȳ) WHERE W (z) isNotBlank( b) where D (resp.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 1 : 2 Let O = ; 3 for</head><label>123</label><figDesc>Find update operations to ensure safety Input : a set P of privacy conjunctive queries Pi = xi, GPi Output : a sequence O of operations which is safe for P 1 function find-safe-ops(P): Pi ∈ P do 4 forall connected components GPc ⊆ GPi do 5 Let I := [ ];</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>6</head><label>6</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>ordered by decreasing size; 12 forall X ∈ SGPc do 13 Let 14 forall x ∈ x do 15 Let b ∈ B be a fresh blank node; 16 X 17 O 20 O</head><label>12131415161720</label><figDesc>X := X and x = {t | t ∈ Tcrit ∧ ∃τ ∈ X s.t. t ∈ τ }; := X [x ← b]; := O + DELETE X INSERT X WHERE X isNotBlank(x ) 18 if xc = ∅ then 19 Let τ ∈ GPc // non-deterministic choice := O + DELETE τ WHERE GPc 21 return O;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 4 .</head><label>4</label><figDesc>Let O = find-safe-ops({P }) be the output of Algorithm 1 applied to a privacy query P with no boolean connected component. For every RDF graph G, O(G) satisfies the the condition Ans(Count(P ), O(G)) ≥ Ans(Count(P ), G).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>We write G[b 0 ← b 0 , . . . , b k ← b k ] for denoting the graph obtained from G by replacing each occurrence of b i by b i for every i ∈ [1..k].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Hence, we extend Definition 8 to handle a set sameAs of :sameAs links. Definition 11 (Safety modulo sameAs). An anonymization instance (G, O, P) is safe modulo sameAs iff for every RDF graph G , for every P ∈ P and for any tuple of constants c, if c ∈ Ans sameAs (P, O(G) ∪ G ) then c ∈ Ans sameAs (P, G ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Example 6 .</head><label>6</label><figDesc>Let P be the following privacy query written in SPARQL syntax: SELECT ?x WHERE { ?x :seenBy ?y. ?x :bossOf ?z. } Let G, O(G) and G be the following RDF graphs where O is an update operation returned by Algorithm 1: G = {:bob :seenBy :mary. :bob :bossOf _:b1. _:b1 :bossOf :ann.} O(G) = {_:b :seenBy :mary. _:b :bossOf _:b1. _:b1 :bossOf :ann.} G' = {:bob :bossOf :jim. :jim :bossOf :ann.}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Loss of precision depending on privacy query specificity for each graph.</figDesc><graphic coords="14,137.84,351.27,110.66,110.45" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>5 illustrates the strategy considered in Algorithm 1 to enforce safety (see Section 5). Consider the following update query O 2 :</figDesc><table><row><cell>Example 5. DELETE {?x</cell><cell>:seenBy ?y.</cell><cell>?y</cell><cell>:specialistOf ?z.}</cell></row><row><cell cols="4">INSERT {_:b1 :seenBy _:b2. _:b2 :specialistOf ?z.}</cell></row><row><cell>WHERE {?x</cell><cell>:seenBy ?y.</cell><cell>?y</cell><cell>:specialistOf ?z.</cell></row></table><note><p><p>}</p>The result RDF graph O 2 (G) is made of the following triples and is safe: _:b1 :seenBy _:b2. _:b2 :specialistOf :cancer. :mary :worksAt :hospital1. _:b3 :seenBy _:b4. _:b4 :specialistOf :cancer. :jim :worksAt :hospital1.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>7 . RDF graphs and privacy queries used in our experiments.</figDesc><table><row><cell>RDF graph</cell><cell cols="3">#Triples #IRIs #Blanks #PrivQuery</cell></row><row><cell>TCL</cell><cell cols="2">6,443,256 1,020,580 705,030</cell><cell>19</cell></row><row><cell></cell><cell cols="2">Synthetic transportation data</cell><cell></cell></row><row><cell>Drugbank 8</cell><cell>517,023 109,494</cell><cell>0</cell><cell>6</cell></row><row><cell cols="3">Real-world data about approved drugs</cell><cell></cell></row><row><cell cols="2">(Swedish) Heritage 9 4,970,464 1,687,452</cell><cell>0</cell><cell>6</cell></row><row><cell cols="3">Real world Europeana Swedish heritage data</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Running time (in seconds) of anonymization process.</figDesc><table><row><cell cols="4">RDF graph T-Algo1 #UpdateQueries T-Anonym</cell></row><row><cell>TCL</cell><cell>0.207</cell><cell>16</cell><cell>3.5</cell></row><row><cell>Drugbank</cell><cell>0.012</cell><cell>6</cell><cell>1.7</cell></row><row><cell cols="2">Swedish Heritage 0.013</cell><cell>14</cell><cell>53.6</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>See https://perso.liris.cnrs.fr/remy.delanaux/papers/WISE2019appx.pdf</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>The + operator denotes the concatenation of sequences.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>See OWL 2 RDF-Based Semantics, notably section 5.13. https://www.w3.org/TR/ 2012/REC-owl2-rdf-based-semantics-20121211/#Semantic Conditions</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_3"><p>https://github.com/RdNetwork/safe-lod-anonymizer</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>http://wifo5-03.informatik.uni-mannheim.de/drugbank/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_5"><p>General Europeana portal: https://pro.europeana.eu/page/linked-open-data</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>This work has been supported by the <rs type="funder">Auvergne-Rhône-Alpes region</rs> through the <rs type="programName">ARC6 research program</rs> funding <rs type="projectName">Remy Delanaux</rs>'s PhD; by the <rs type="projectName">LabEx PERSYVAL-Lab</rs> (<rs type="grantNumber">ANR-11-LABX-0025-01</rs>); by the <rs type="projectName">SIDES 3.0</rs> project (<rs type="grantNumber">ANR-16-DUNE-0002</rs>) funded by the <rs type="funder">French Programme Investissement d'Avenir (PIA)</rs>; and by the <rs type="programName">Palse Impulsion 2016/31 program</rs> (<rs type="grantNumber">ANR-11-IDEX-0007-02</rs>) at <rs type="funder">UDL</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_qsRNk9t">
					<orgName type="project" subtype="full">Remy Delanaux</orgName>
					<orgName type="program" subtype="full">ARC6 research program</orgName>
				</org>
				<org type="funded-project" xml:id="_ERdM2JG">
					<idno type="grant-number">ANR-11-LABX-0025-01</idno>
					<orgName type="project" subtype="full">LabEx PERSYVAL-Lab</orgName>
				</org>
				<org type="funded-project" xml:id="_JccSpCv">
					<idno type="grant-number">ANR-16-DUNE-0002</idno>
					<orgName type="project" subtype="full">SIDES 3.0</orgName>
					<orgName type="program" subtype="full">Palse Impulsion 2016/31 program</orgName>
				</org>
				<org type="funding" xml:id="_B5ptaAV">
					<idno type="grant-number">ANR-11-IDEX-0007-02</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<title level="m">Foundations of Databases</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An analytical study of large SPARQL query logs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Timm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="149" to="161" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reformulation-based query answering for RDF graphs with RDF ontologies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Mugnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC, to appear</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Tractable reasoning and efficient query answering in description logics: The DL-Lite family</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reasoning</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">K-isomorphism: privacy preserving network publication against structural attacks</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="459" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Query-based linked data anonymization</title>
		<author>
			<persName><forename type="first">R</forename><surname>Delanaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rousset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Thion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC (1)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">11136</biblScope>
			<biblScope unit="page" from="530" to="546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Privacy in database publishing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="230" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Differential privacy</title>
		<author>
			<persName><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP (2)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4052</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Privacy-preserving data publishing: A survey of recent developments</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C M</forename><surname>Fung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">53</biblScope>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient query answering against dynamic RDF databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roatis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="299" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Privacy-preserving query answering in logic-based information systems</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECAI</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="40" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Logical foundations of privacy-preserving publishing of linked data</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="943" to="949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Foundations of semantic web databases</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gutiérrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Hurtado</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">O</forename><surname>Mendelzon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="95" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient query rewriting in the description logic EL and beyond</title>
		<author>
			<persName><forename type="first">P</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Seylan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3034" to="3040" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">k-RDF-neighbourhood anonymity: Combining structural and attribute-based anonymisation for linked data</title>
		<author>
			<persName><forename type="first">B</forename><surname>Heitmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hermsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Decker</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">PrivOn@ISWC</title>
		<imprint>
			<date type="published" when="1951">1951. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">t-closeness: Privacy beyond k-anonymity and l-diversity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkatasubramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="106" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Differential privacy in the wild: A tutorial on current practices &amp; open challenges</title>
		<author>
			<persName><forename type="first">A</forename><surname>Machanavajjhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="1611" to="1614" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">L-diversity: Privacy beyond k -anonymity</title>
		<author>
			<persName><forename type="first">A</forename><surname>Machanavajjhala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Venkitasubramaniam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TKDD</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Getting the most out of wikidata: Semantic technology usage in wikipedia&apos;s knowledge graph</title>
		<author>
			<persName><forename type="first">S</forename><surname>Malyshev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>González</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gonsior</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bielefeldt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="376" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A formal analysis of information disclosure in data exchange</title>
		<author>
			<persName><forename type="first">G</forename><surname>Miklau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="507" to="534" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">L-opacity: Linkage-aware graph anonymization</title>
		<author>
			<persName><forename type="first">S</forename><surname>Nobari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Karras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bressan</surname></persName>
		</author>
		<ptr target=".org" />
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<publisher>OpenProceedings</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="583" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Towards the anonymisation of RDF data</title>
		<author>
			<persName><forename type="first">F</forename><surname>Radulovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>García-Castro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gómez-Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SEKE</title>
		<imprint>
			<publisher>KSI Research Inc</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="646" to="651" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">k-anonymity: A model for protecting privacy</title>
		<author>
			<persName><forename type="first">L</forename><surname>Sweeney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="557" to="570" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Privacy-preserving record linkage for big data: Current approaches and research challenges</title>
		<author>
			<persName><forename type="first">D</forename><surname>Vatsalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Sehili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Christen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Big Data Technologies</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="851" to="895" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
