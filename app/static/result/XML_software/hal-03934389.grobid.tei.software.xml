<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Regular Languages of First-Order Logic with One Alternation</title>
				<funder ref="#_QxStmUW">
					<orgName type="full">DFG</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2022-03-11">11 Mar 2022</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Corentin</forename><surname>Barloy</surname></persName>
							<email>corentin.barloy@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Charles</forename><surname>Paperman</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">INRIA</orgName>
								<orgName type="institution" key="instit4">Centrale Lille</orgName>
								<address>
									<postCode>9189</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">CRIStAL France</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
							</affiliation>
						</author>
						<title level="a" type="main">The Regular Languages of First-Order Logic with One Alternation</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2022-03-11">11 Mar 2022</date>
						</imprint>
					</monogr>
					<idno type="MD5">7A13627111ECB2F97684930D15CB6CAA</idno>
					<idno type="DOI">10.1145/3531130.3533371</idno>
					<idno type="arXiv">arXiv:2203.06075v1[cs.LO]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>automata theory</term>
					<term>first-order logic</term>
					<term>descriptive complexity</term>
					<term>circuit complexity</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The regular languages with a neutral letter expressible in first-order logic with one alternation are characterized. Specifically, it is shown that if an arbitrary Σ 2 formula defines a regular language with a neutral letter, then there is an equivalent Σ 2 formula that only uses the order predicate. This shows that the so-called Central Conjecture of Straubing holds for Σ 2 over languages with a neutral letter, the first progress on the Conjecture in more than 20 years. To show the characterization, lower bounds against polynomial-size depth-3 Boolean circuits with constant top fan-in are developed. The heart of the combinatorial argument resides in studying how positions within a language are determined from one another, a technique of independent interest.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Circuits and regular languages. Since the works of Barrington and Thérien <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">5]</ref> in the early 1990s, regular languages have emerged as the backbone of small-depth circuit complexity. Despite being the most elementary class of languages, regular languages seem to embody the intrinsic power of circuit classes. Under a suitable notion of reduction, a lot of relevant circuit classes even admit complete regular languages (this is at the heart of Barrington's Theorem <ref type="bibr" target="#b1">[2]</ref>). In addition, it seems that each natural restriction of smalldepth circuits defines its own class of regular languages.</p><p>More precisely, consider the following families:</p><p>• AC 0 𝑖 is the class of Boolean circuits families of depth 𝑖 and polynomial size, • ACC 0 𝑖 is the same as AC 0 𝑖 but with additional modulo gates,</p><p>• TC 0 𝑖 is the same as AC 0 𝑖 but with additional threshold gates (more than half of the inputs are 1). The hierarchy in depth of AC 0 is known to be strict <ref type="bibr" target="#b25">[26]</ref>, but this is open for the other classes (for TC 0 this is known up to depth 3 <ref type="bibr" target="#b12">[13]</ref>). It is however conjectured that each of these hierarchies is strict and that strictness can always be witnessed by regular languages; in other words, as mentioned, each of these classes is conjectured to have its own subset of regular languages.</p><p>Over the past 30 years, abundant literature has provided a sophisticated toolset to show separation (and sometimes decidability) of classes of regular languages. This toolset relies on algebraic objects that characterize the complexity of regular languages; this object satisfies some properties iff the language belongs to some class. It is thus tempting to, first, characterize the regular languages that belong to a circuit class, and, second, separate the classes that arise. This paper is focused on that first step, for a specific class of circuits (loosely speaking, AC 0  3 ). Logic. Wishing to provide a guiding light, Straubing <ref type="bibr" target="#b29">[30]</ref> presented in a succinct but beautiful way the links between circuit complexity and automata theory, and formulated a conjecture on. . . logics. Indeed, circuits themselves are illformed for statements of the form "a circuit family AC 0 𝑖 recognizes a regular language iff it has this specific shape. " Logic came to the rescue by giving a descriptional tool for circuits. This started with the work of Barrington et al. <ref type="bibr" target="#b2">[3]</ref> and Straubing <ref type="bibr" target="#b28">[29]</ref> who showed that AC 0 (= 𝑖 AC 0 𝑖 ) is equivalent to first-order logic. This means that for any AC 0 circuit family, there is a first-order formula, with quantifiers over positions, that recognizes the same language. For instance, over the alphabet 𝐴 = {𝑎, 𝑏, 𝑐} the language 𝐴 * 𝑎𝑏 * 𝑎𝐴 * , which is in AC 0  2 , can be written as:</p><formula xml:id="formula_0">(∃𝑥, 𝑦) [𝑥 &lt; 𝑦 ∧ 𝑎(𝑥) ∧ 𝑎(𝑦) ∧ (find the 2 𝑎s) (∀𝑧) [𝑥 &lt; 𝑧 &lt; 𝑦 → 𝑏 (𝑧)]]</formula><p>(everything in between is a 𝑏)</p><p>In this formula, we used the numerical predicate &lt;; numerical predicates speak about the numerical value of positions but not their contents. The class of (languages recognized by) formulas FO <ref type="bibr">[arb]</ref> is that of first-order formulas where we allow any numerical predicate (even undecidable ones!).</p><p>The aforementioned characterization reads: AC 0 = FO <ref type="bibr">[arb]</ref>. Extensions of this tight relationship between circuits and logics exist for ACC 0 , TC 0 , and other classes (see <ref type="bibr" target="#b29">[30]</ref>).</p><p>Equipped with this, the characterization of the regular languages of AC 0 is given by this striking statement <ref type="bibr" target="#b28">[29]</ref>:</p><formula xml:id="formula_1">FO[arb] ∩ Reg = FO[reg],</formula><p>where reg is the set of numerical predicates &lt;, +1, and divisibility by constants. Straubing notes "this phenomenon appears to be quite general" and postulates that for well-behaved logics L, it holds that</p><formula xml:id="formula_2">L [arb] ∩ Reg = L [reg].</formula><p>This is known as the Straubing Property for L (simply Central Conjecture in <ref type="bibr" target="#b29">[30]</ref>) and it is explicitly stated for the logics Σ 𝑖 . Straubing <ref type="bibr">[30, p. 169]</ref> explains: "This has the look of a very natural principle. It says, in effect, that the only numerical predicates we need in a sentence that defines a regular language are themselves recognized by finite automata. "</p><p>The Program for Separation in circuit complexity then becomes:</p><p>1. Identify a logic that corresponds to the circuit class, 2. Prove the Straubing Property for the class, 3. Show separation over regular languages.</p><p>In this work, we apply this approach to the lower reaches of the AC 0 𝑖 hierarchy.</p><p>Step 1 in the Program is covered by a result of <ref type="bibr" target="#b19">[20]</ref>; we will be focusing on the subset Σ 𝑖 of FO of formulas with 𝑖 quantifier alternations, starting with an existential one. For instance, the above formula is in Σ 2 [&lt;, +1]. The Straubing Properties for these logics are very much open: it is known to hold for Σ 1 <ref type="bibr" target="#b29">[30]</ref> and its Boolean closure <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b30">31]</ref>, but no progress has been made on Straubing Properties since the end of the 1990s.</p><p>We will be mostly focusing on languages with a neutral letter, this means that the languages will admit a letter 𝑐 that can be added or removed from words without impacting their membership in the language. This is usually not a restriction to the Program for Separation, since it is conjectured that circuit classes are separated by regular languages with neutral letters. See, in particular, the fascinating survey by Koucký <ref type="bibr" target="#b16">[17]</ref>. Write Neut for the set of languages that have a neutral letter. The Neutral Straubing Property is that for a logic L, it holds that:</p><formula xml:id="formula_3">L [arb] ∩ Reg ∩ Neut = L [&lt;] ∩ Neut.</formula><p>Contributions. We show that Σ 2 has the Neutral Straubing Property and that Δ 2 = (Σ 2 ∩ Π 2 ) has the Straubing Property, where Π 2 is defined as Σ 2 but with ∃ and ∀ swapped. Consequently, we exhibit some natural regular languages that separate AC 0 2 and AC 0 3 . Related work. In <ref type="bibr" target="#b11">[12]</ref>, the authors study the model of socalled programs over DA. This defines another subclass of AC 0 , but it is not known to have any equivalent characterization in terms of circuits. It is in particular not known to be equivalent to Σ 2 [arb] ∩ Π 2 [arb] or to the two-variable fragment of <ref type="bibr">FO[arb]</ref>, classes that we will explore in Section 6. They give a precise description of the regular languages computable with programs over DA, but their proof uses the algebraic structure of DA, which is not available in our setting.</p><p>The class Σ 2 [&lt;] corresponds to the second level of the Straubing-Thérien hierarchy, an extensively studied hierarchy that is closely tied to the famous dot-depth hierarchy. A major open problem is to decide whether a given regular language belongs to a given level of this hierarchy. See the survey of Pin <ref type="bibr" target="#b20">[21]</ref> for a modern account on this topic and the recent major progress of Place and Zeitoun <ref type="bibr" target="#b24">[25]</ref>.</p><p>Organization of the paper. We introduce circuits, logic, and a bit of algebra in Section 2. In Section 3, we introduce socalled limits, a classical tool in devising lower bounds against depth-3 circuits. In Section 4, we present a simple lower bound against a language in Σ 2 ; this serves as both a warmup for the main proof and to identify the difficulties ahead. In Section 5, we prove our main result, that is, the Neutral Straubing Property for Σ 2 . In Section 6, we derive some consequences of our main result, in particular the Straubing Property for Δ 2 . We conclude in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We assume familiarity with regular languages, logic, and circuits, although we strive to keep this presentation selfcontained. We write Reg for the class of regular languages.</p><p>Word, languages, neutral letters. Following Lothaire <ref type="bibr" target="#b18">[19]</ref>, a word 𝑣 = 𝑎 1 𝑎 2 . . . 𝑎 𝑛 , with each 𝑎 𝑖 in an alphabet 𝐴, is a subword of a word 𝑣 if 𝑣 can be written as</p><formula xml:id="formula_4">𝑣 = 𝑣 0 𝑎 1 𝑣 1 𝑎 2 • • • 𝑎 𝑛 𝑣 𝑛 ,</formula><p>with each 𝑣 𝑖 in 𝐴 * . We say that a language 𝐿 separates 𝑋 from 𝑌 if 𝑋 ⊆ 𝐿 and 𝐿 ∩ 𝑌 = ∅. A language 𝐿 has a neutral letter if there is a letter 𝑐 such that 𝑢 • 𝑐 • 𝑣 ∈ 𝐿 ⇔ 𝑢 • 𝑣 ∈ 𝐿 for all words 𝑢, 𝑣. We write Neut for the class of languages with a neutral letter.</p><p>Monoids, ordered monoids, morphisms. A monoid is a set equipped with a binary associative operation, denoted multiplicatively, with a identity element. An idempotent of 𝑀 is an element 𝑒 ∈ 𝑀 that satisfies 𝑒 2 = 𝑒. For an alphabet 𝐴, the set 𝐴 * is the free monoid generated by 𝐴, its identity element being the empty word. An ordered monoid is a monoid equipped with a partial order ≤ compatible with the product, i.e., 𝑥 ≤ 𝑦 implies 𝑥𝑧 ≤ 𝑦𝑧 and 𝑧𝑥 ≤ 𝑧𝑦 for any 𝑥, 𝑦, 𝑧 ∈ 𝑀. Any monoid can be seen as an ordered monoid, using equality as order. An upper set of an ordered monoid 𝑀 is a set 𝑆 such that for any 𝑥, 𝑦 ∈ 𝑀, if 𝑥 ∈ 𝑆 and 𝑥 ≤ 𝑦 then 𝑦 ∈ 𝑆. A morphism is a map ℎ : 𝑀 → 𝑁 satisfying ℎ(𝑎𝑏) = ℎ(𝑎)ℎ(𝑏) and ℎ(1) = 1, with 𝑎, 𝑏 ∈ 𝑀 and 1 denoting the identity element of 𝑀 and 𝑁 .</p><p>Monoids as recognizers. An ordered monoid 𝑀 recognizes a language 𝐿 ⊆ 𝐴 * if there is a morphism ℎ : 𝐴 * → 𝑀 and an upper set 𝑃 of 𝑀 such that 𝐿 = ℎ -<ref type="foot" target="#foot_0">1</ref> (𝑃). The ordered syntactic monoid of 𝐿 is the smallest ordered monoid that recognizes 𝐿; it is finite iff 𝐿 is regular, in which case it is unique. 1   Logic. We work with first-order logics recognizing languages. For instance, the formula over the alphabet {𝑎, 𝑏}</p><formula xml:id="formula_5">(∀𝑥) (∃𝑦) [mod 2 (𝑥) ∨ (𝑦 = 𝑥 + 1) ∧ (𝑎(𝑥) ↔ 𝑏 (𝑦))]</formula><p>asserts that, in a given word 𝑤, for every position 𝑥 there is another position 𝑦 such that either 𝑥 is divisible by 2 (mod 2 ) or 𝑦 is just after 𝑥 and 𝑤 has different letters at 𝑥 and 𝑦. The predicates mod 2 and +1 are examples of numerical predicates, i.e., they only speak about the numerical positions, not the contents of the input word. The predicates 𝑎(•) and 𝑏 (•) are the letter predicates.</p><p>In this paper, first-order logics are specified by restricting two aspects:</p><p>• The number of quantifier alternations. We write Σ 2 for the subset of first-order formulas that can be written as (∃𝑥 1 , 𝑥 2 , . . .) (∀𝑦 1 , 𝑦 2 , . . .) [𝜙] with 𝜙 a quantifier-free formula, that is, Σ 2 is the set of formulas starting with an existential quantifier and alternating once. In Section 6.1, we will briefly mention Π 2 (defined as Σ 2 but with ∃ and ∀ swapped) and Δ 2 , the set of formulas that are equivalent to both a Σ 2 and a Π 2 formula (this describes, a priori, fewer languages than Σ 2 or Π 2 ). • The numerical predicates allowed. Except for a quick detour in Section 6.1, we will only be using two sets: &lt;, that is, the sole order relation (e.g., Σ 2 [&lt;]) and arb the set of all predicates (e.g., Σ 2 [arb]). In the latter set, there would be predicates asserting that two positions are coprime or that a position encodes an halting Turing machine, there is no restriction whatsoever.</p><p>The language of a formula is the set of words that satisfy it. We commonly identify a class of formulas with the class of languages they recognize.</p><p>Languages of a syntactic ordered monoid. Let 𝑀 be an ordered monoid. For any element 𝑥 ∈ 𝑀, the up-word problem for 𝑀 and 𝑥 is the following language over 𝑀 seen as an alphabet:</p><formula xml:id="formula_6">{𝑤 ∈ 𝑀 * | 𝑤 evaluates in 𝑀 to an element ≥ 𝑥 }.</formula><p>In some precise sense, a regular language has the same complexity as the hardest of the up-word problems for its ordered syntactic monoid; in the case on Σ 2 [arb], we can state: Lemma 2.1 (From <ref type="bibr" target="#b22">[23,</ref><ref type="bibr">Lemma 5.6]</ref>). A regular language with a neutral letter is in Σ 2 [arb] iff all the up-word problems for its ordered syntactic monoid are in Σ 2 <ref type="bibr">[arb]</ref>.</p><p>Circuits. We will study languages computed by families of constant-depth, polynomial-size circuits consisting of unbounded fan-in ∧and ∨-gates. A circuit with 𝑛 inputs 𝑥 1 , 𝑥 2 , . . . , 𝑥 𝑛 in some alphabet 𝐴 can query whether any input contains any given letter in 𝐴. The depth of the circuit is the maximal number of gates appearing on a path from an input to the output. A circuit family is an infinite set (𝐶 𝑛 ) 𝑛 ≥0 where the circuit 𝐶 𝑛 has 𝑛 inputs and one output gate; a word 𝑤 is deemed accepted if the circuit 𝐶 |𝑤 | outputs 1 when 𝑤 is placed as input. We identify classes of circuits with the class of languages they recognize.</p><p>For a circuit 𝐶 we visualize the inputs on top and the one output gate at the bottom. <ref type="foot" target="#foot_1">2</ref> The top fan-in of 𝐶 is the maximum fan-in of the gates that receive an input letter directly. We say that 𝐶 is a ∃∀∃ circuit if it is layered with a bottom OR gate with AND gates as inputs, each of these having OR gates as inputs.</p><p>We let Σ 2 be the class of families of ∃∀∃ circuits of polynomial-size and constant top fan-in. In the literature, this circuit family is also called ΣΠΣ(𝑘) in <ref type="bibr" target="#b9">[10]</ref> and Σ poly,𝑘 2 in <ref type="bibr" target="#b8">[9]</ref>, where 𝑘 is the top fan-in. It is a subclass of AC 0 3 , the class of polynomial-size, depth-3 circuits, a class we will discuss in Section 6.2. The name "Σ 2 circuit family" is all the more justified that: Lemma 2.2 (From <ref type="bibr" target="#b19">[20,</ref><ref type="bibr">Proposition 11]</ref>). A language is recognized by a Σ 2 [arb] formula iff it is recognized by a Σ 2 circuit family.</p><p>We will often exploit this equivalence without pointing at this lemma.</p><p>A decidable characterization of Σ 2 [&lt;]. Let 𝑥, 𝑦 ∈ 𝑀; we say that 𝑦 is a subword of 𝑥 if there are two words 𝑤 𝑥 , 𝑤 𝑦 ∈ 𝑀 * that evaluate, using 𝑀's product, to 𝑥 and 𝑦, respectively, and 𝑤 𝑦 is a subword of 𝑤 𝑥 . The following is a characterization of the languages in Σ 2 [&lt;] that is due to Pin and Weil <ref type="bibr" target="#b21">[22]</ref>, and we use a version proposed by Bojańczyk:</p><formula xml:id="formula_7">Theorem 2.3 (From [6]). A regular language is in Σ 2 [&lt;] iff its ordered syntactic monoid 𝑀 is such that for any 𝑥, 𝑦 ∈ 𝑀 such that 𝑥 is an idempotent 3 and 𝑦 a subword of 𝑥, it holds that 𝑥 ≤ 𝑥𝑦𝑥 .</formula><p>Equivalently, this could be worded over languages directly: a regular language 𝐿 is in Σ 2 [&lt;] iff for any three words 𝑤 1 , 𝑤 2 , 𝑤 3 that map to the same idempotent in 𝑀 and 𝑣 a subword of 𝑤 2 , if a word 𝑤 0 • 𝑤 1 𝑤 2 𝑤 3 • 𝑤 4 is in 𝐿, for some words 𝑤 0 , 𝑤 4 , then so is 𝑤 0 • 𝑤 1 𝑣𝑤 3 • 𝑤 4 . We will allude to this wording in some proofs in the Consequences section (Section 6.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Limits and lower bounds against Σ 2 [arb]</head><p>We present a tool that has been used several times to show lower bounds against depth-3 circuits, in particular in <ref type="bibr" target="#b13">[14]</ref>. The following definition is attributed to Sipser therein: Definition 3.1 (From <ref type="bibr" target="#b26">[27]</ref>). Let 𝐹 be a set of words, all of same length 𝑛, and 𝑘 &gt; 0. A 𝑘-limit for 𝐹 is a word 𝑢 of length 𝑛 such that for any set of 𝑘 positions, a word in 𝐹 matches 𝑢 on all these positions. In symbols, 𝑢 satisfies:</p><formula xml:id="formula_8">(∀𝑃 ⊆ [𝑛].|𝑃 | = 𝑘) (∃𝑣 ∈ 𝐹 ) (∀𝑝 ∈ 𝑃) 𝑢 𝑝 = 𝑣 𝑝 .</formula><p>Naturally, we will be interested in 𝑘-limits that fall outside of 𝐹 , otherwise finding 𝑘-limits is trivial. In fact, we will consider sets 𝐹 that are included in a subset of a target language, and find 𝑘-limits outside of the target language itself. We include a short proof of the following statement for completeness and because it makes the statement itself more readily understandable. Lemma 3.2 (From [14, Lemma 2.2]). Let 𝐿 be a set of words all of same length 𝑛 and 𝐶 be a ∃∀∃ circuit that accepts at least all the words of 𝐿. Let 𝑘 be the top fan-in of 𝐶 and 𝑠 its size.</p><p>Assume there is a subset 𝐿 ′ ⊆ 𝐿 such that for any 𝐹 ⊆ 𝐿 ′ of size at least |𝐿 ′ |/𝑠 there is a 𝑘-limit for 𝐹 that does not belong to 𝐿. Then 𝐶 accepts a word outside of 𝐿. The hypothesis can be represented graphically as:</p><formula xml:id="formula_9">∃𝐿 ′ ∀𝐹 |𝐹 | ≥ |𝐿 ′ |/𝑠 ∃𝑢 𝑘-lim. for 𝐹 𝐿 Proof.</formula><p>At the bottom of 𝐶, we have an OR gate of fan-in at most 𝑠 that receives the result of some AND gates. By counting, one of these AND gates should accept a subset 𝐹 of 𝐿 ′ of size at least |𝐿 ′ |/𝑠; we will now focus on that gate. Let 𝑢 ∉ 𝐿 be the 𝑘-limit for 𝐹 that exists by hypothesis. Consider an OR gate that feeds into the AND gate under consideration. This OR gate checks the contents of a subset 𝑃 ⊆ [𝑛] of 𝑘 positions of the input. By hypothesis, there is a word 𝑣 in 𝐹 that matches 𝑢 on all the positions in 𝑃, hence the OR gate cannot distinguish between 𝑢 and 𝑣 and must output 1 (true) as 𝑣 must be accepted. This holds for all the OR gates feeding into the AND gate under consideration, hence the AND gate must accept 𝑢, and so does 𝐶. □ Corollary 3.3. Let 𝐿 be a language and write 𝐿 𝑛 for the subset of words of length 𝑛 in 𝐿. Assume that for any 𝑘, 𝑑 ∈ N, there is an 𝑛 ∈ N and a subset 𝐿 ′ ⊆ 𝐿 𝑛 such that every subset 𝐹 ⊆ 𝐿 ′ of size at least |𝐿 ′ |/𝑛 𝑑 admits a 𝑘-limit outside of 𝐿.</p><formula xml:id="formula_10">Then 𝐿 is not in Σ 2 [arb].</formula><p>Proof. For a contradiction, assume there is a Σ 2 circuit family for 𝐿, with top fan-in 𝑘 and size 𝑛 𝑑 . Let 𝑛 be the value provided by the hypothesis, then the circuit 𝐶 for 𝐿 𝑛 satisfies the hypotheses of Lemma 3.2, hence 𝐶 accepts a word outside of 𝐿, a contradiction.</p><formula xml:id="formula_11">□ 4 Warm-up: 𝐾 = (𝑎𝑐 * 𝑏 + 𝑐) * ∉ Σ 2 [arb]</formula><p>In this section, we follow the approach of Håstad, Jukna, and Pudlák <ref type="bibr" target="#b13">[14]</ref> to show the claim of the section title. We present it in a specific way that will help us stress the commonality and the differences of this approach with our main proof.</p><p>To show the claim of the section title, we consider a slightly different language. For any 𝑛 that is a perfect square, we let Good 𝑛 be the set of words of length 𝑛 over {𝑎, 𝑏} of the following shape:</p><formula xml:id="formula_12">𝑛 𝑏 • • • 𝑏𝑎𝑏 • • • 𝑏 √ 𝑛 𝑏 • • • 𝑏𝑎𝑏 • • • 𝑏 √ 𝑛 . . .</formula><p>In words, a word is in Good 𝑛 if it can be decomposed into √ 𝑛 blocks of length √ 𝑛, such that each of them has exactly one 𝑎. We let Good = 𝑛 Good 𝑛 .</p><formula xml:id="formula_13">Lemma 4.1. If 𝐾 is in Σ 2 [arb], then so is Good.</formula><p>Proof. This is easier to see on circuits, so assume there is a Σ 2 circuit family for 𝐾. For 𝑛 a perfect square, we design a circuit for Good 𝑛 . On any input, we convert the 𝑏's to 𝑐's and insert a 𝑏 every √ 𝑛 positions; we call this the expansion of the input word. For instance, with 𝑛 = 9, the input 𝑎𝑏𝑏 𝑏𝑎𝑏 𝑏𝑏𝑎 is expanded to 𝑎𝑐𝑐𝑏 𝑐𝑎𝑐𝑏 𝑐𝑐𝑎𝑏. Clearly, if the input word is in Good 𝑛 , then its expansion is in 𝐾. Conversely, if a block of the input had two 𝑎's, the expansion will not add a 𝑏 in between, so the expansion is not in 𝐾; similarly, if a block of the input contains only 𝑏's, it will be expanded to only 𝑐's sandwiched between two 𝑏's, and the expansion will not be in 𝐾 (in the case where the block containing only 𝑏's is the first one, the expansion starts with 𝑐 • • • 𝑐𝑏, again putting the expansion outside of 𝐾).</p><p>Thus a circuit for Good 𝑛 can be constructed by computing the expansion (this only requires wires and no gates), then feeding that expansion to a circuit for 𝐾. If the circuit family for 𝐾 were in Σ 2 , so would the circuit family for Good. □  Proof. We rely on the Flower Lemma, a combinatorial lemma that is a relaxation of the traditional Sunflower Lemma. We first need to introduce some vocabulary.</p><p>We consider families F containing sets of size 𝑠 for some 𝑠. The core of the family is the set 𝑌 = 𝑆 ∈ F 𝑆. The coreless version of F is the family F 𝑌 = {𝑆 \ 𝑌 | 𝑆 ∈ F }. A set 𝑆 intersects a family F if all the sets of F have a nonempty intersection with 𝑆. Finally, a flower with 𝑝 petals is a family F of size 𝑝 with core 𝑌 such that any set which intersects F 𝑌 is of size at least 𝑝. Lemma 4.3 (Flower Lemma <ref type="bibr" target="#b15">[16,</ref><ref type="bibr">Lemma 6.4]</ref>). Let F be a family containing sets of cardinality 𝑠 and 𝑝 ≥ 1 be an integer. If |F | &gt; (𝑝 -1) 𝑠 , then there is a subfamily F ′ ⊆ F that is a flower with 𝑝 petals. To apply this lemma, consider the mapping 𝜏 from words in Good 𝑛 to 2 [𝑛] that lists all the positions where a word has an 𝑎. For instance, with 𝑛 = 9, 𝜏 (𝑏𝑏𝑎 𝑎𝑏𝑏 𝑏𝑎𝑏) = {3, 4, 8}. For any word 𝑤 in Good 𝑛 , 𝜏 (𝑤) is of size</p><formula xml:id="formula_14">√ 𝑛. We let F = {𝜏 (𝑤) | 𝑤 ∈ 𝐹 }.</formula><p>We now apply the lemma with 𝑠 = √ 𝑛 and 𝑝 = 𝑘 + 1. Since |F | = |𝐹 |, we can apply the lemma on F and obtain a subfamily F ′ that is a flower with 𝑘 + 1 petals. Let 𝑌 be its core. Consider the word 𝑢 of length 𝑛 over {𝑎, 𝑏} which has 𝑎's exactly at the positions in 𝑌 . Then:</p><p>• 𝑢 is outside of Good 𝑛 . Indeed, |𝑌 | &lt; √ 𝑛, since it is the intersection of distinct sets of size √ 𝑛. Hence one of the blocks of 𝑢 will contain only 𝑏's, putting it outside of Good 𝑛 .</p><p>• 𝑢 is a 𝑘-limit. Let 𝑃 be a set of 𝑘 positions, we will find a word that is mapped to F ′ that matches 𝑢 on 𝑃. If a position in 𝑃 points to an 𝑎 in 𝑢, then every word in F ′ has an 𝑎 at that position (by construction, since this position would belong to the core 𝑌 ). So we assume that 𝑃 contains only positions on which 𝑢 is 𝑏.</p><formula xml:id="formula_15">Since |𝑃 | is 𝑘, it cannot intersect F ′ , hence there is a set 𝑆 ∈ F ′ such that 𝑆 ∩ 𝑃 = ∅.</formula><p>The set 𝑆 is thus 𝜏 (𝑤) for a word 𝑤 ∈ 𝐹 that has a 𝑏 on all positions in 𝑃. This word 𝑤 thus matches 𝑢 on 𝑃, concluding the proof of the main statement. The "in particular" part is implied by the fact that, for 𝑛 large enough:</p><formula xml:id="formula_16">|Good 𝑛 | 𝑛 𝑑 = √ 𝑛 √ 𝑛 𝑛 𝑑 ≥ 𝑘 √ 𝑛 . □ Theorem 4.4. The language 𝐾 = (𝑎𝑐 * 𝑏+𝑐) * is not in Σ 2 [arb].</formula><p>Proof. Corollary 3.3 applied on Good, using Lemma 4. The proof of the statement of the section title is along two main steps:</p><p>Section 5.1. We will start with a language with a neutral letter 𝐿 ∉ Σ 2 [&lt;]. Since it is not in Σ 2 [&lt;], there are 𝑥, 𝑦 ∈ 𝑀 that falsify the equations of Theorem 2.3. We use these witnesses to build a up-word problem 𝑇 of the ordered syntactic monoid of 𝐿 and show that it lies outside of Σ 2 [arb], implying that 𝐿 ∉ Σ 2 [arb] by Lemma 2.1.</p><p>To show 𝑇 out of Σ 2 [arb], we identify (Section 5.1.1) a subset of well-behaved words of 𝑇 , and make some simple syntactical changes (in Section 5.1.2) on them so that they look like words in Good, in a similar fashion as the "expansions" of Lemma 4.1. The argument used in Lemma 4.1 then needs to be refined, as we do not have that any word outside of Good comes from a word outside of 𝑇 . We will define a set Bad of words that look like words in Good except for one block that contains only 𝑏's; Lemma 4.1 is then worded as: if 𝐾 is in Σ 2 [arb], then there is a Σ 2 [arb] language that separates Good from Bad (Lemma 5.1). Section 5.2. We show that no language of Σ 2 [arb] can separate Good from Bad. We thus need to provide a statement in the spirit of Lemma 4.2. We first write good and bad words in a succinct ("packed") way, as words in [ √ 𝑛]</p><p>√ 𝑛 , the 𝑖-th letter being some value 𝑣 if the original word had the 𝑎 of its 𝑖-th block in position 𝑣 (Section 5.2.1). We then translate the notion of 𝑘-limit to packed words (Lemma 5.3). Finally, we provide a measure of how diverse a set of (packed) good words is (Definition 5.4), and show that such a set is either not diverse and small (Lemma 5.5), or diverse and admits a 𝑘-limit (Lemma 5.6). Our term for "not diverse" will be tangled, referring to the fact that there is a strong correlation between the contents of positions within words.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">If a language not in</head><formula xml:id="formula_17">Σ 2 [&lt;] is in Σ 2 [arb], we can separate Good from Bad with a language in Σ 2 [arb]</formula><p>5.1.1 Target up-word problem and some of its words.</p><p>For the rest of this section, let 𝐿 ⊆ 𝐴 * be a regular language with a neutral letter that lies outside of Σ 2 [&lt;] and let 𝑀 be its ordered syntactic monoid. Since 𝐿 is not in Σ 2 [&lt;], there are elements 𝑥, 𝑦 ∈ 𝑀 such that 𝑥 ≰ 𝑥𝑦𝑥 with 𝑥 an idempotent and 𝑦 a subword of 𝑥. Let 𝑇 be the up-word problem of 𝑀 for 𝑥. Clearly, any word of 𝑀 * that evaluates to 𝑥𝑦𝑥 does not belong to 𝑇 . Naturally, 𝑦 is thus also a subword of 𝑥; this provides us with words that evaluate to 𝑥 and 𝑦 of the shape: 𝑥 1 𝑦 1 . . . 𝑥 𝑡 𝑦 𝑡 evaluates to 𝑥, 𝑦 1 . . . 𝑦 𝑡 evaluates to 𝑦, with each 𝑥 𝑖 and 𝑦 𝑖 in 𝑀. (Note that we can use the identity element of 𝑀 as needed to ensure we have as many 𝑥 𝑖 's as 𝑦 𝑖 's.)</p><p>Let 𝑛 ∈ N be a large enough perfect square ("large enough" only depends on 𝑡, the length of the word for 𝑦). We define √ 𝑛 + 1 words of length</p><formula xml:id="formula_18">√ 𝑛 + 𝑡 over 𝑀: • For 𝑖 ∈ [ √ 𝑛], 𝑥 (𝑖) = 1 𝑖-1 𝑥 1 1 √ 𝑛-𝑖 • 𝑦 1 • • • 1 𝑖-1 𝑥 𝑡 1 √ 𝑛-𝑖 • 𝑦 𝑡 .</formula><p>Here 1 ∈ 𝑀 is the neutral element of 𝑀. Note that these words evaluate to 𝑥. • Additionally, we consider the word 1</p><formula xml:id="formula_19">√ 𝑛 𝑦 1 . . . 1 √ 𝑛 𝑦 𝑡 ,</formula><p>which evaluates to 𝑦, and we simply write 𝑦 for it. Note that 𝑦 can be obtained by removing all the letters 𝑥 𝑗 from any word 𝑥 (𝑖) . Call 𝑇 -good a concatenation of √ 𝑛 words of the form 𝑥 (𝑖) sandwiched between two words 𝑥 (1) (the 1 is arbitrary), and 𝑇 -bad a word obtained by changing, in a 𝑇 -good word, exactly one of the words 𝑥 (𝑖) to 𝑦 (but for the 𝑥 (1) at the beginning and end). By construction, any 𝑇 -good word evaluates to 𝑥 in 𝑀, so belongs to 𝑇 , while any 𝑇 -bad word evaluates to 𝑥𝑦𝑥, hence does not belong to 𝑇 . Note that if we had switched two blocks of a 𝑇 -good word to 𝑦, we would not be able to say whether it belonged to 𝑇 or not.</p><p>5.1.2 𝑇 -good, 𝑇 -bad to Good and Bad. The 𝑇 -good and 𝑇 -bad words contain a lot of redundant information, for instance 𝑥 (𝑖) is of length √ 𝑛 + 𝑡, while all the information it really contains is 𝑖 ∈ [ √ 𝑛]. Recall the set Good 𝑛 of Section 4 which contains all words of length 𝑛 over {𝑎, 𝑏} that can be divided into √ 𝑛 blocks of length √ 𝑛, each containing a single 𝑎. Again, we let Good be all such words, of any perfect square length. Define similarly Bad 𝑛 as the set of words that are like Good 𝑛 except for one block which has only 𝑏's, and let Bad = 𝑛 Bad 𝑛 .</p><p>In the next lemma, we show that we can modify, using only wires in a circuit, words over {𝑎, 𝑏} so that if they are in Good they become 𝑇 -good, and if they are in Bad they become 𝑇 -bad. This modification is simple enough that we can take a Σ 2 [arb] circuit family for𝑇 , apply the modification at the top of each circuit, and still have a circuit family in Σ 2 [arb]; the resulting circuit family separates Good from Bad:</p><formula xml:id="formula_20">Lemma 5.1. If 𝑇 ∈ Σ 2 [arb],</formula><p>then there is a Σ 2 [arb] language that separates Good from Bad.</p><p>Proof. As in Lemma 4.1, this is easier seen on circuits: we design a circuit for inputs of length 𝑛 over {𝑎, 𝑏} that separates Good from Bad.</p><p>Consider the first block of √ 𝑛 letters of the input. We replicate it 𝑡 times, with the 𝑖-th replication changing 𝑏's to 1 and 𝑎's to 𝑥 𝑖 . We then concatenate these and add 𝑦 𝑖 between the 𝑖-th and (𝑖 + 1)-th replication. For instance, 𝑏 7 𝑎𝑏 √ 𝑛-8</p><p>would turn into:</p><formula xml:id="formula_21">1 7 𝑥 1 1 √ 𝑛-8 • 𝑦 1 • • • 1 7 𝑥 𝑡 1 √ 𝑛-8</formula><p>• 𝑦 𝑡 = 𝑥 (8) .</p><p>In particular, if the block were all 𝑏's, we would obtain the word 𝑦, which has no letter 𝑥 𝑗 . We can do this to each block of √ 𝑛 letters, concatenate the resulting words, then add the word 𝑥 (1) at the beginning and the end. Note that these operations can be done with only wires, with no gates involved.</p><p>If the input word is in Good, then the word produced is 𝑇 -good, hence in 𝑇 . If it was in Bad, then the resulting word would be 𝑇 -bad, hence would lie outside of 𝑇 . This shows that the desired circuit can be constructed using the above wiring followed by the circuit for 𝑇 for inputs of length</p><formula xml:id="formula_22">(𝑡 √ 𝑛 + 𝑡) (2 + √ 𝑛).</formula><p>Since 𝑡 is a constant and depends solely on 𝐿, the resulting circuit is of polynomial size and of the correct shape. □ 5.2 No language in Σ 2 [arb] separates Good from Bad Note that this section is independent from the previous one.</p><p>We will now rely on Corollary 3.3 to show that any Σ 2 [arb] language 𝐿 that accepts all of Good must accept a word in Bad. To apply Corollary 3.3, from this point onward we let 𝑘, 𝑑 ∈ N, and set 𝑛 to be a large enough value that depends only on 𝑘 and 𝑑. The role of 𝐿 ′ in the statement of Corollary 3.3 will be played by Good 𝑛 and we will build 𝑘-limits belonging to Bad 𝑛 , which we call bad 𝑘-limits. The reader may check that the statements of the forthcoming Lemma 5.5 and Lemma 5.6 conclude the proof. √ 𝑛 . We call these words packed and will use Greek letters 𝜆, 𝜇, 𝜈 for them; we also call the letter at some position in packed words its contents at this position, only to stress that we are working with packed words. We define the natural functions to pack and unpack words:</p><formula xml:id="formula_23">• unpack : [ √ 𝑛, ⊥] → {𝑎, 𝑏} √ 𝑛 maps 𝑖 to 𝑏 𝑖-1 𝑎𝑏 √ 𝑛-𝑖 and ⊥ to 𝑏 √ 𝑛 . This extends naturally to words over [ √ 𝑛, ⊥]. • pack : {𝑎, 𝑏} * → [ √ 𝑛, ⊥] *</formula><p>is the inverse of unpack. We will use that function on sets of words too, with the natural meaning. We can now rephrase the notion of 𝑘-limit using packed words: Lemma 5.3. Let 𝐹 ⊆ Good 𝑛 and define Φ = pack(𝐹 ). If 𝜇 is a packed word that has the following properties, then unpack(𝜇) is a bad 𝑘-limit for 𝐹 :</p><p>1. There is a word 𝜈 ∈ Φ that differs on a single position 𝑖 with 𝜇, at which 𝜇 has contents ⊥:</p><formula xml:id="formula_24">𝜇 𝑖 = ⊥ ∧ (∀𝑗 ≠ 𝑖) [𝜈 𝑗 = 𝜇 𝑗 ].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>For every set 𝐶 ⊆ [ √ 𝑛] of contents that contains 𝜈 𝑖 and every set 𝑃 ⊆ [ √ 𝑛] \ {𝑖} of positions such that |𝐶 | + |𝑃 | = 𝑘, there is a word 𝜆 ∈ Φ whose contents at position 𝑖 is not in 𝐶 and that matches 𝜈 on 𝑃:</p><formula xml:id="formula_25">𝜆 𝑖 ∉ 𝐶 ∧ (∀𝑝 ∈ 𝑃) [𝜆 𝑝 = 𝜈 𝑝 ].</formula><p>Proof. Write 𝑢 for unpack(𝜇). That 𝑢 ∈ Bad is immediate from Property 1: 𝑢 is but a word 𝑣 of Good in which one block was set to all 𝑏's.</p><p>We now show that 𝑢 is a 𝑘-limit. Let 𝑇 be a set of 𝑘 positions, we split 𝑇 into two sets:</p><p>• 𝑇 ′ is the set of positions that do not belong to the 𝑖-th block of 𝑢, that is, they do not satisfy ⌈𝑝/ √ 𝑛⌉ = 𝑖. We let 𝑃 be each of the elements of 𝑇 ′ divided by √ 𝑛, that is, for any 𝑝 ∈ 𝑇 ′ we add ⌈𝑝/ √ 𝑛⌉ to 𝑃. • 𝑇 ′′ is the set of positions that do fall in the 𝑖-th block.</p><p>Note that 𝑢 only has 𝑏's at the positions of 𝑇 ′′ . We let 𝐶 be that set, modulo √ 𝑛, that is, for any 𝑝 ∈ 𝑇 ′′ , we add 𝑝 mod √ 𝑛 to 𝐶 or √ 𝑛 if this value is 0. First, if 𝜇 𝑖 ∉ 𝐶, then 𝑇 indicates positions of 𝑢 that have the same letter as in unpack(𝜈) ∈ 𝐹 , so a word of 𝐹 matches 𝑢 over 𝑇 , as required. We thus assume next that 𝜇 𝑖 ∈ 𝐶.</p><p>Let 𝜆 ∈ Φ be the word given by Property 2 for 𝐶 and 𝑃, we claim that 𝑤 = unpack(𝜆) matches 𝑢 on the positions of 𝑇 , concluding the proof.</p><p>First note that the 𝑖-th block of 𝑤 has its 𝑎 in a position that is not in 𝑇 ′′ , hence 𝑤 matches 𝑢 on 𝑇 ′′ . Consider next any position 𝑝 ∈ 𝑇 ′ and write 𝑗 for the block in which 𝑝 falls (i.e., 𝑗 = ⌈𝑝/ √ 𝑛⌉). Since 𝜇 𝑗 = 𝜆 𝑗 by hypothesis, the 𝑗-th block of 𝑢 and 𝑤 are the same, hence 𝑢 𝑝 = 𝑤 𝑝 . □ 5.2.2 Tangled sets of good words are small, nontangled ones have a bad 𝑘-limit. Consider a 𝐹 ⊆ Good 𝑛 . To find a bad 𝑘-limit for 𝐹 , we need a lot of diversity in 𝐹 ; see in particular Prop. 2 of Lemma 5.3. Hence having some given contents at a given position in a word of Φ should not force too many other positions to have a specific value. We make this notion formal:</p><p>Definition 5.4. Let 𝐹 ⊆ Good 𝑛 and Φ = pack(𝐹 ). The entailment relation of Φ is relating sets of pairs (𝑖, 𝑐) of position/contents in words of Φ. Let us say that a word and a pair position/contents (𝑖, 𝑐) agree if the contents at position 𝑖 of the word is 𝑐, and that a word and a set of such pairs agree if they agree on all the pairs. We say that a set of pairs is an 𝑖-set if all its pairs have 𝑖 as position.</p><p>A set 𝑆 of pairs position/contents entails an 𝑖-set 𝐷 if all words in Φ that agree with 𝑆 also agree with at least one pair of 𝐷; additionally, the position 𝑖 should not appear in 𝑆:</p><formula xml:id="formula_26">( 𝑐) [(𝑖, 𝑐) ∈ 𝑆]∧ (∀𝜇 ∈ Φ) [(∀( 𝑗, 𝑑) ∈ 𝑆) [𝜇 𝑗 = 𝑑] → (∃(𝑖, 𝑐) ∈ 𝐷) [𝜇 𝑖 = 𝑐]].</formula><p>The set 𝐹 is said to be 𝑘-tangled if for any word 𝜇 ∈ Φ and any position 𝑖 ∈ [ √ 𝑛], there is an 𝑖-set of pairs of size ≤ 𝑘 that contains (𝑖, 𝜇 𝑖 ) and that is entailed by a set of size 𝑘 that agrees with 𝜇. In other words, every position of 𝜇 is entailed by a subset of its positions. We drop the 𝑘 in 𝑘-tangled if it is clear from context.</p><formula xml:id="formula_27">Lemma 5.5. Let 𝐹 ⊆ Good 𝑛 . If 𝐹 is 𝑘-tangled, then |𝐹 | &lt; √ 𝑛 2𝑘 √ 𝑛/(2𝑘+1) . In particular, |𝐹 | &lt; |Good 𝑛 |/𝑛 𝑑 .</formula><p>Proof. Assume 𝐹 is 𝑘-tangled and let Φ = pack(𝐹 ). We show that every word in Φ can be fully described in Φ by fully specifying a portion 𝑘/(𝑘 + 1) of its positions and encoding the contents of each of the other 1/(𝑘 + 1) positions with elements from [𝑘]. That is, if two words in Φ have the same such description, they are the same, hence Φ cannot be larger than the number of such descriptions. We first show this property, then derive the numerical implication on |𝐹 |.</p><p>Let 𝜇 ∈ Φ, we construct iteratively a set 𝐾 of positions that we will fully specify and a set 𝐾 + of positions that are restricted when setting the positions in 𝐾.</p><p>First consider the pair (1, 𝜇 1 ). Since 𝐹 is tangled, there is an 1-set containing (1, 𝜇 1 ), entailed by a set 𝑆 that agrees with 𝜇. We add to 𝐾 the positions of 𝑆 and to 𝐾 + the positions of 𝑆 and position 1.</p><p>We now iterate this process: Take a pair (𝑖, 𝜇 𝑖 ) such that 𝑖 ∉ 𝐾 + . There is an 𝑖-set containing (𝑖, 𝜇 𝑖 ) that is entailed by a set 𝑆 that agrees with 𝜇. Let 𝑆 ′ be the set of positions of 𝑆 that are not in 𝐾 + . We add 𝑆 ′ to 𝐾, and 𝑆 ′ ∪ {𝑖} to 𝐾 + . Note that the size increase for 𝐾 + is one more than that for 𝐾. We continue iterating until all positions appear in 𝐾 + .</p><p>We now bound the size of 𝐾 at the end of the computation. For each iteration, in the worst case, we need to add 𝑘 positions to 𝐾 to obtain 𝑘 + 1 new positions in 𝐾 + (this is the worst case in the sense that this is the worst ratio of the number of positions we need to pick in 𝐾 to the number of positions that are put in 𝐾 + ). In that case, after 𝑠 steps, we have |𝐾 | = 𝑠𝑘 and |𝐾 + | = 𝑠𝑘 + 𝑠. Thus when |𝐾 + | = √ 𝑛, that is, when no more iterations are possible, we have:</p><formula xml:id="formula_28">𝑠𝑘 + 𝑠 = √ 𝑛 ⇒ 𝑠 = √ 𝑛 𝑘 + 1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>This shows that |𝐾 | ≤ 𝑘</head><p>√ 𝑛/(𝑘 + 1). We now turn to describing the word 𝜇 using 𝐾. We first provide all the contents of 𝜇 at positions in 𝐾; call 𝑍 the set of pairs position/contents of 𝜇 that correspond to positions in 𝐾. We mark the positions of 𝐾 as specified, and carry on to specify the other positions in a deterministic fashion.</p><p>We first fix an arbitrary order on sets of pairs of position/contents. We iterate through all the subsets of 𝑍 of size 𝑘, in order. For each such subset 𝑆, we consider, in order again, the subsets 𝐷 that are entailed by 𝑆. Assume 𝐷 is an 𝑖-set; if position 𝑖 is already specified, we do nothing, otherwise, we describe which element of 𝐷 is (𝑖, 𝜇 𝑖 ) using an integer in [𝑘], and mark 𝑖 as specified. We proceed until all the subsets of 𝑍 have been seen, at which point, by construction of 𝐾, all the positions will have been specified. As claimed, given 𝑍 and the description of which elements in sets 𝐷 correspond to the correct contents, we can reconstruct 𝜇.</p><p>Summing up, to fully describe 𝜇, we had to specify the positions of 𝐾 (one of </p><formula xml:id="formula_29">|𝐹 | ≤ √ 𝑛 𝑘 √ 𝑛/(𝑘 + 1) • √ 𝑛 𝑘 √ 𝑛/(𝑘+1) • 𝑘 √ 𝑛/(𝑘+1) ≤ 2 √ 𝑛 • 2 ( √ 𝑛/(𝑘+1)) (𝑘 log √ 𝑛) • 2 ( √ 𝑛/(𝑘+1)) log(𝑘) = 2 ( √ 𝑛/(𝑘+1)) ( (𝑘+1)+𝑘 log √ 𝑛+log 𝑘) ≤ 2 ( √ 𝑛/(𝑘+1)) ( (𝑘+ 1 𝑘 ) log √ 𝑛) (n large enough) ≤ √ 𝑛 (𝑘+ 1 𝑘 ) √ 𝑛/(𝑘+1) ≤ √ 𝑛 2𝑘 √ 𝑛/(2𝑘+1)</formula><p>.</p><p>The "in particular" part is a consequence of the fact that, for 𝑛 large enough:</p><formula xml:id="formula_30">|Good 𝑛 | 𝑛 𝑑 = √ 𝑛 √ 𝑛 𝑛 𝑑 ≥ √ 𝑛 2𝑘 √ 𝑛/(2𝑘+1)</formula><p>. □ Lemma 5.6. Let 𝐹 ⊆ Good 𝑛 . If 𝐹 is not 𝑘-tangled, then 𝐹 has a bad 𝑘-limit.</p><p>Proof. Write Φ = pack(𝐹 ). That 𝐹 is not tangled means that there is a word 𝜈 ∈ Φ and a position 𝑖 such that for any set of pairs position/contents 𝑆 and any 𝑖-set 𝐷 that contains (𝑖, 𝜈 𝑖 ), 𝑆 does not entail 𝐷. We define 𝜇 to be the word 𝜈 but with 𝜇 𝑖 set to ⊥. We show that unpack(𝜇) is a bad 𝑘-limit using Lemma 5.3. Property 1 therein is true by construction, so we need only show Property 2.</p><formula xml:id="formula_31">Let 𝐶 ⊆ [ √ 𝑛] with 𝜇 𝑖 ∈ 𝐶 and 𝑃 ⊆ [ √ 𝑛] \ {𝑖} with |𝐶 | + |𝑃 | = 𝑘.</formula><p>We add some more arbitrary positions in 𝑃 so that |𝑃 | = 𝑘, avoiding 𝑖. Define:</p><formula xml:id="formula_32">𝑆 = {(𝑝, 𝜇 𝑝 ) | 𝑝 ∈ 𝑃 }, 𝐷 = {(𝑖, 𝑐) | 𝑐 ∈ 𝐶}.</formula><p>By hypothesis, since (𝑖, 𝜇 𝑖 ) ∈ 𝐷, 𝑆 does not entail 𝐷. This means that there is a word 𝜆 ∈ Φ such that 𝑆 and 𝜆 agree, but 𝜆 𝑖 ∉ 𝐶. This is the word needed for Property 2 of Lemma 5.3, concluding the proof. □ Corollary 5.7. No Σ 2 [arb] language can separate Good from Bad.</p><p>Proof. We apply Corollary 3.3 on any language 𝐿 that separates Good from Bad. We let 𝑘, 𝑑 ∈ N, and 𝑛 large enough;</p><p>𝐿 ′ in the statement of Corollary 3.3 is set to Good 𝑛 . We are then given a set 𝐹 of size at least |Good 𝑛 |/𝑛 𝑑 and Lemma 5.5 shows that 𝐹 is not tangled. Lemma 5.6 then implies that 𝐹 has a bad 𝑘-limit. Corollary 3.3 concludes that 𝐺 is not in</p><formula xml:id="formula_33">Σ 2 [arb],</formula><p>showing the statement. □ Theorem 5.8 (Neutral Straubing Property for Σ 2 ).</p><formula xml:id="formula_34">Σ 2 [arb] ∩ Reg ∩ Neut ⊆ Σ 2 [&lt;].</formula><p>Proof. Let 𝐿 ∉ Σ 2 [&lt;] with a neutral letter and 𝑇 be the language defined in Section 5.1. </p><formula xml:id="formula_35">dition that L [reg] ∩ Neut ⊆ L [&lt;]</formula><p>. This latter property is called the Crane Beach Property of L [reg], and also stems from the natural idea that if a language has a neutral letter, then numerical predicates do not provide any useful information. Albeit natural, this property is false for FO[arb] <ref type="bibr" target="#b3">[4]</ref>, but Theorem 5.8 shows that Σ 2 [reg] does have the Crane Beach Property.</p><p>Relying on Theorem 4.4 and some results from <ref type="bibr" target="#b7">[8]</ref>, we can show:</p><formula xml:id="formula_36">Theorem 6.1 (Straubing Property of Δ 2 ). Δ 2 [arb] ∩ Reg = Δ 2 [reg].</formula><p>Proof. The proof structure is as follows: We first show that Δ 2 [arb] ∩ Reg has some closure properties, so that it is a so-called lm-variety. We then show that Δ 2 [reg] recognizes precisely all the regular languages definable with a first-order formula with two variables that uses reg as numerical predicates; that class of languages is denoted FO 2 [reg]. We then rely on the following lemma, where 𝐾 = (𝑎𝑐 * 𝑏 + 𝑐) * : Lemma 6.2 (From [8, <ref type="bibr">Lemma 8]</ref>). If an lm-variety of regular languages V satisfies:</p><formula xml:id="formula_37">FO 2 [reg] ⊆ V ⊆ FO[arb] and 𝐾 ∉ V then V = FO 2 [reg]. Since Δ 2 [arb] ∩ Reg satisfies the hypotheses, it is equal to FO 2 [reg] = Δ 2 [reg], concluding the proof.</formula><p>𝚫 2 [arb] ∩ Reg is an lm-variety. We ought to first define lm-variety. If for a morphism ℎ : 𝐴 * → 𝐵 * there is a 𝑘 such that ℎ(𝐴) ⊆ 𝐵 𝑘 , we call ℎ an lm-morphism, where lm stands for length-multiplying. Given a language 𝐿 and a letter 𝑎, the left quotient of 𝐿 by 𝑎 is the set 𝑎 -1 𝐿 = {𝑣 | 𝑎𝑣 ∈ 𝐿}. The right quotient 𝐿𝑎 -1 is defined symmetrically. An lm-variety of languages is a set of languages closed under the Boolean operations, quotient, and inverse lm-morphisms.</p><p>Since Reg is an lm-variety of languages, it is sufficient to show that Δ 2 [arb] is too; this is not hard: Let 𝐿 ∈ Σ 2 [arb] over the alphabet 𝐵 and ℎ be an lmmorphism such that ℎ(𝐴) ⊆ 𝐵 𝑘 for some 𝑘. Consider the circuit for the words of 𝐿 of length 𝑘𝑛 for some 𝑛. Given a word in 𝐴 𝑛 , we can use wires to map each input letter 𝑎 ∈ 𝐴 to ℎ(𝑎), and we can feed the resulting word to the circuit for 𝐿. A word 𝑤 ∈ 𝐴 𝑛 is thus accepted iff ℎ(𝑤) ∈ 𝐿, hence the circuit family thus defined recognizes ℎ -1 (𝐿).</p><p>𝚫 2 [reg] and FO 2 [reg] recognize the same languages. We show the inclusion from left to right, the converse being similar. We rely on the fact that FO 2 [&lt;, +1] = Δ 2 [&lt;, +1], a result due to Thérien and Wilke <ref type="bibr" target="#b32">[33,</ref><ref type="bibr">Theorem 7]</ref>. The rest of our proof is fairly simple: we put the information given by the mod 𝑝 predicates within the alphabet, show that this information is easily checked with one universal quantifier if we have reg predicates, and that if the modular predicates are put within the alphabet, the only required predicates to express our Δ 2 [reg] formula are &lt; and +1. We then rely on the equivalence of FO 2 and Δ 2 over these predicates to conclude.</p><p>Formally, let 𝜙 ∈ Δ 2 [reg] be a formula over the alphabet 𝐴. Let 𝑃 be the set of moduli used in 𝜙, that is, the predicate mod 𝑝 appears in 𝜙 iff 𝑝 ∈ 𝑃. The 𝑃-annotation of a word 𝑤 ∈ 𝐴 * is the word in (𝐴 ∪ 2 𝑃 ) * that indicates, for each position 𝑖, the set of moduli in 𝑃 that divide 𝑖. In other words, the 𝑃-annotation of 𝑤 = 𝑤 1 𝑤 2 • • • 𝑤 𝑛 , with each 𝑤 𝑖 ∈ 𝐴, is the word of length 𝑛 whose 𝑖-th letter is:</p><formula xml:id="formula_38">𝑤 𝑖 {𝑝 ∈ 𝑃 | 𝑝 divides 𝑖} ∈ (𝐴 ∪ 2 𝑃 ).</formula><p>Let W be the set of words in (𝐴∪2 𝑃 ) * that are 𝑃-annotations.</p><p>Then:</p><formula xml:id="formula_39">• W ∈ FO 2 [reg] ∩ Δ 2 [reg]</formula><p>. Indeed, a formula for W need only assert that for all positions 𝑖, the 2 𝑃 part of the letter at position 𝑖 is exactly the set {𝑝 ∈ 𝑃 | 𝑝 divides 𝑖}. This can be written as a single universal quantifier followed by a quantifier-free formula. • There is a 𝜙 ′ ∈ Δ 2 [&lt;, +1] such that the words of W that satisfy 𝜙 ′ are precisely the 𝑃-annotations of words that satisfy 𝜙. The formula 𝜙 ′ is simply the formula 𝜙 in which each predicate mod 𝑝 (𝑥) is replaced with the property "𝑝 belongs to the 2 𝑃 part of the letter at position 𝑥," which can be written as a simple disjunction.</p><p>If the input word is a 𝑃-annotation, mod 𝑝 (𝑥) is indeed equivalent to that property. Since FO 2 [&lt;, +1] = Δ 2 [&lt;, +1], there is a formula 𝜓 of FO 2 [&lt;, +1] that accepts the same language as 𝜙 ′ . With 𝜓 W the FO 2 [reg] formula for W, we conclude that 𝜓 ∧ 𝜓 W is a FO 2 [reg] formula that is equivalent to 𝜙. □</p><p>The proof of the previous statement hinged on the characterization given by Lemma 6.2. To show the (nonneutral) Straubing Property of Σ 2 [arb], a similar statement will need to be proved. To make the similarity more salient, we reword Lemma 6.2 as the equivalent statement: Lemma 6.3. If an lm-variety of regular languages V satisfies:</p><formula xml:id="formula_40">Δ 2 [reg] ⊆ V ⊆ FO[arb] and V ∩ Neut ⊆ Δ 2 [&lt;]. then V = Δ 2 [reg].</formula><p>Proof. The second part of the proof of Theorem 6.1 shows that FO 2 [reg] = Δ 2 [reg], while the same was already known if &lt; is the only available numerical predicate, so we can freely swap FO 2 for Δ 2 in the statement of Lemma 6.2. We need to show that the hypothesis </p><formula xml:id="formula_41">V ∩ Neut ⊆ Δ 2 [&lt;] is equivalent to 𝐾 ∉ V. For the left-to-right implication, it is known [18] that 𝐾 ∉ FO 2 [&lt;] = Δ 2 [&lt;].</formula><formula xml:id="formula_42">Σ 2 [reg] ⊆ V ⊆ FO[arb] and V ∩ Neut ⊆ Σ 2 [&lt;] then V = FO 2 [reg].</formula><p>If the conjecture held, then using V = Σ 2 [arb] ∩ Reg would show the Straubing Property for Σ 2 [arb].</p><p>6.2 On the fine structure of AC 0 For this section, we use notations similar to <ref type="bibr" target="#b19">[20]</ref> on circuit complexity (these correspond to the classes BC 0 𝑖 therein):</p><formula xml:id="formula_43">• AC 0</formula><p>𝑖 is the class of polynomial-size, depth-𝑘 Boolean circuit families, where all the circuits in a family have the same kind of output gate (AND or OR); • AC 0 𝑖 is defined similarly, the only difference being that the input gates of the circuits are allowed to compute any function of at most a constant number of positions of the input string. This class is equivalent to Σ 𝑖 [arb] ∪ Π 𝑖 [arb] (the 𝑖 here is the number of quantifiers blocks, so that there are 𝑖 -1 alternations between ∃ and ∀). The implied hierarchies interleave in a strict way:</p><formula xml:id="formula_44">AC 0 1 ⊊ AC 0 1 ⊊ AC 0 2 ⊊ • • •</formula><p>The strictness of the hierarchy was independently obtained by <ref type="bibr" target="#b19">[20]</ref> and <ref type="bibr" target="#b8">[9]</ref>, both relying on previous bounds by Håstad <ref type="bibr" target="#b14">[15]</ref>, but with very different approaches. However, the question of finding explicit languages that separate this hierarchy is still open, to the best of our knowledge. We make some modest progress towards this: Theorem 6.5. The language 𝐾 ′ = 𝐾 •𝑏𝑐 * 𝑏 •𝐴 * is in AC 0 3 \ AC 0 2 . Proof. Upper bound. It is easily seen that a word is in the language 𝐾 iff:</p><p>• Between every two 𝑎's there is a 𝑏, and vice versa;</p><p>• The first (resp. last) nonneutral letter of the word is 𝑎 (resp. 𝑏). Each of these statements can be written as an AND of ORs; for the first one, it is easier seen on the complement: we have an OR gate that selects two positions 𝑝 1 , 𝑝 2 and checks that there is an 𝑎 at both positions and only 𝑐's in between. Thus 𝐾 can be written as an AND of these, and so 𝐾 has a circuit of depth exactly 2.</p><p>To build a circuit for 𝐾 ′ , we start with an OR gate that selects two positions 𝑝 1 , 𝑝 2 , and checks with an AND gate that they both contain a 𝑏 and that only 𝑐's appear in between. We add as input to that AND gate the inputs of the AND gate for 𝐾 where the positions considered are restricted to be smaller than 𝑝 1 . This thus correctly checks that the prefix up to 𝑝 1 is in 𝐾, and that it is followed by a word starting with 𝑏𝑐 * 𝑏.</p><formula xml:id="formula_45">Lower bound. If 𝐾 ′ ∈ AC 0 2 , then 𝐾 ′ is either in Σ 2 [arb] or Π 2 [arb]. Assume 𝐾 ′ ∈ Σ 2 [arb], then 𝐾 ′ ∈ Σ 2 [&lt;]</formula><p>by Theorem 5.8. We show that 𝐾 ′ ∉ Σ 2 [&lt;] using the equations provided by Theorem 2.3 with the wording appearing after the Theorem. First, the word (𝑎𝑏) 2 is mapped to an idempotent: if (𝑎𝑏) 2 appears in a word, we can repeat it any number of times without changing membership to 𝐾 ′ . Also, the word 𝑏𝑎 appears as a subword of (𝑎𝑏) 2 . However (𝑎𝑏) 6 • 𝑏𝑏 ∈ 𝐾, but (𝑎𝑏) 2 (𝑏𝑎) (𝑎𝑏) 2 • 𝑏𝑏 ∉ 𝐾 ′ , showing that 𝐾 ′ ∉ Σ 2 [&lt;].</p><p>If we assume that 𝐾 ′ ∈ Π 2 [arb], we have to show that the complement of 𝐾 ′ is not in Σ 2 [&lt;]. This time, we pick (𝑎𝑏) 3 as the idempotent, and 𝑏𝑏𝑎 as the subword. Then (𝑎𝑏) 9 ∉ 𝐾 ′ but (𝑎𝑏) 3 (𝑏𝑏𝑎) (𝑎𝑏) 3 ∈ 𝐾 ′ , hence the complement of 𝐾 ′ is not in Σ 2 <ref type="bibr">[&lt;]</ref>. □</p><p>The language 𝐾 itself appears very often in the literature pertaining to the fine separation of small circuit classes <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b17">18]</ref>. This is no surprise: The language is the first of the family of bounded-depth Dyck languages. These are the wellparenthesized expressions that nest no more than a fixed value:</p><p>𝐷 (1)  1 = 𝐾 = (𝑎𝑐 * 𝑏 + 𝑐) * , 𝐷 (𝑖) 1 = (𝑎𝐷 (𝑖-1)</p><formula xml:id="formula_46">1 𝑏 + 𝑐) * .</formula><p>(Here, 𝑎 can be interpreted as "opening parenthesis" and 𝑏 as "closing. ") Saliently, these languages separate the class Σ 𝑖 [&lt;] from Σ 𝑖+1 [&lt;], with 𝐷 (𝑖)</p><p>1 belonging to the latter but not the former <ref type="bibr" target="#b6">[7]</ref>. It is open whether these languages also separate the Σ 𝑖 [arb] hierarchy, and thus the AC 0 𝑖 one. We can show that: Theorem 6.6. 𝐷 (2)  1 ∈ AC 0 3 \ AC 0 2 . Proof. Upper bound. It can be shown [7, Lemma 4 + ] that: 𝐷 (2)  1 = 𝐾𝑏𝐴 * ∪ 𝐴 * 𝑏𝑐 * 𝑏𝐾𝑏𝐴 * ∪ 𝐴 * 𝑎𝐾 ∪ 𝐴 * 𝑎𝐾𝑎𝑐 * 𝑎𝐴 * . We can use an OR gate to select the positions of the letters 𝑎, 𝑏 mentioned in that expression, and then either use an AND gate to verify that only 𝑐's appear between them, or use the AND of ORs circuit for 𝐾 from the previous proof to check that a word of 𝐾 appears between two positions.</p><p>Lower bound. We again use the wording appearing after Theorem 2.3. As in the previous proof, we need to show that neither 𝐷 (2)  1 nor its complement are in Σ 2 [&lt;]. For the language itself, we pick (𝑎𝑏) 3 as the word mapping to an idempotent and 𝑏𝑏𝑎 as the subword. We indeed have that (𝑎𝑏) 9 ∈ 𝐷 (2)  1 , but (𝑎𝑏) 3 (𝑏𝑏𝑎) (𝑎𝑏) 3 ∉ 𝐷 (2)  1 . For the complement, we pick (𝑎𝑏) 2 as the word mapping to an idempotent and 𝑎𝑎𝑏 as the subword; they satisfy (𝑎𝑏) 6 • 𝑏 ∉ 𝐷 (2)  1 but (𝑎𝑏) 2 (𝑎𝑎𝑏) (𝑎𝑏) 2 • 𝑏 ∈ 𝐷 (2)  1 . □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have shown the Neutral Straubing Property for Σ 2 :</p><formula xml:id="formula_47">Σ 2 [arb] ∩ Reg ∩ Neut = Σ 2 [&lt;] ∩ Neut.</formula><p>To do so, we developed a new lower bound technique against circuits of depth 3 that relies on the entailment relation of a language. This relation indicates how dependent the positions within a language are on one another. We believe that this relation may be exploited to show Straubing Properties at higher levels of the Σ 𝑖 hierarchy. Dropping the neutral-letter restriction from our main result is an interesting task. Although it would not imply a much stronger statement in terms of circuits, it is still a stain on the clean statement that is the Straubing Property. We note that Conjecture 6.4 is implied by the so-called locality property of the algebraic counterpart of Σ 2 [&lt;]; showing locality is a notoriously hard problem in algebraic language theory (see, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b33">34]</ref>).</p><p>Showing Straubing Properties remains a challenging and wide open problem. If we are to follow our approach for Σ 𝑖 , 𝑖 ≥ 3, it requires in particular a decidable characterization of the form of Theorem 2.3. This is usually provided by an equational characterization of the class, and although the general shape of the equations for each Σ 𝑖 [&lt;] is known [25, Theorem 6.2], they do not readily imply decidability; in fact, the decidability of Σ 𝑖 [&lt;] for 𝑖 ≥ 5 is open <ref type="bibr" target="#b23">[24]</ref>.</p><p>An outstanding example of the connection between the Straubing Property of a circuit class and its computational power is given in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b17">18]</ref>: FO 2 [arb] has the Straubing Property if and only if addition cannot be computed with a linear number of gates. This latter question, pertaining to the precise complexity of addition, was asked, in particular, by Furst, Saxe, and Sipser <ref type="bibr" target="#b10">[11,</ref><ref type="bibr">Section 5]</ref>. Note that even though Δ 2 [reg] = FO 2 [reg], this is not known to hold for the set of arbitrary numerical predicates.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>We use Corollary 3.3 to show that Good ∉ Σ 2 [arb]. Let then 𝑘, 𝑑 ∈ N. The value of 𝐿 ′ in Corollary 3.3 will simply be Good 𝑛 , and we show:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 4 . 2 .</head><label>42</label><figDesc>If 𝑛 is large enough, any subset 𝐹 ⊆ Good 𝑛 with |𝐹 | &gt; 𝑘 √ 𝑛 has a 𝑘-limit outside of Good 𝑛 . This holds in particular if |𝐹 | ≥ |Good 𝑛 |/𝑛 𝑑 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>5. 2 . 1</head><label>21</label><figDesc>Packed words. Words in Good 𝑛 and Bad 𝑛 can be described by the position of the letter 𝑎 in each block of size √ 𝑛. We make this explicit, by seeing [ √ 𝑛, ⊥] = [ √ 𝑛] ∪{⊥} as an alphabet, and working with words in [ √ 𝑛, ⊥]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Example 5 . 2 .</head><label>52</label><figDesc>With 𝑛 = 9, pack(𝑎𝑏𝑏 𝑏𝑏𝑏 𝑏𝑎𝑏) = 1⊥2, and unpack(31⊥) = 𝑏𝑏𝑎 𝑎𝑏𝑏 𝑏𝑏𝑏.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>𝑘+1) possible choices), and for each position not specified by 𝐾, we needed to provide an integer in [𝑘] (one of 𝑘 √ 𝑛/(𝑘+1) possible choices). This shows that:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>1. Corollary 5.7 and Lemma 5.1 imply that 𝑇 cannot be in Σ 2 [arb], and in turn, Lemma 2.1 shows that 𝐿 cannot be in Σ 2 [arb]. Life without neutral letters The regular numerical predicates, denoted reg, are the numerical predicates +1, &lt;, and for any 𝑝 &gt; 0, mod 𝑝 which is true of a position if it is divisible by 𝑝. The term "regular" stems from the fact that these are the properties on numerical positions that automata can express. Recall that the Straubing Property for a logic L expresses that L [arb] ∩Reg = L [reg]. The Straubing Property does not immediately imply the Neutral Straubing Property; for this, one would need in ad-</figDesc><table><row><cell>□</cell></row><row><cell>6 Consequences</cell></row><row><cell>6.1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>•</head><label></label><figDesc>Boolean operations: Both Σ 2 [arb] and Π 2 [arb] formulas are closed under Boolean OR and AND, hence the classes of languages they recognize are closed under union and intersection, and so is Δ 2 [arb]. Also, since the negation of a Σ 2 [arb] formula is a Π 2 [arb] formula, and vice versa, Δ 2 [arb] is closed under complement. • Quotient: We show that Σ 2 [arb] is closed under quotient; the proof is the same for Π 2 [arb], and this implies that Δ 2 [arb] is also closed under quotient. Let 𝐿 ∈ Σ 2 [arb] and 𝑎 be a letter. Consider the circuit for the words of length 𝑛 in 𝐿. We can hardwire the first letter to 𝑎; the resulting circuit has 𝑛 -1 inputs, and recognizes a word 𝑤 iff 𝑎𝑤 ∈ 𝐿. The family thus obtained recognizes 𝑎 -1 𝐿. The argument for right quotient is similar. • Lm-morphisms: Again, we show this holds for Σ 2 [arb], the proof for Π 2 [arb] being similar, and these two facts imply closure under lm-morphisms of Δ 2 [arb].</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>For the right-to-left implication, we use the hypothesis that V ⊆ FO[arb]: [8,Theorem 9]  shows that V ⊆ FO[arb] and 𝐾 ∉ V implies that V ⊆ FO2 [reg] and [8,Theorem 15]  asserts that FO 2 [reg] ∩ Neut ⊆ FO 2 [&lt;]. Hence V ∩ Neut ⊆ FO2 [&lt;] and replacing FO 2 with Δ 2 concludes the proof. □</figDesc><table><row><cell>A positive lm-variety is defined just as lm-variety, but</cell></row><row><cell>without requiring closure under complement. The statement</cell></row><row><cell>we need for Σ 2 thus reads:</cell></row><row><cell>Conjecture 6.4. If a positive lm-variety of regular languages</cell></row><row><cell>V satisfies:</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The ordered syntactic monoid is usually defined as the quotient of 𝐴 * by the so-called syntactic order induced by 𝐿; the definition proposed here is equivalent<ref type="bibr" target="#b22">[23,</ref> Corollary 4.4]  and allows to introduce one fewer concept.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The literature has been flip-flopping between putting the inputs at the bottom or at the top, with a semblance of stability for "top" achieved in the late 90s. This explains that some references mention "bottom fan-in. "</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This is usually written by letting 𝑥 be any element, and considering 𝑥 𝜔 , which is the unique idempotent that is a power of 𝑥; we simplify the presentation slightly by simply requiring 𝑥 to be an idempotent.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>We wish to thank <rs type="person">Nikhil Balaji</rs> and <rs type="person">Sébastien Tavenas</rs>. The last author acknowledges financial support by the <rs type="funder">DFG</rs> grant <rs type="grantNumber">ZE 1235/2-1</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_QxStmUW">
					<idno type="grant-number">ZE 1235/2-1</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Syntactical Proof of Locality of da</title>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Almeida</surname></persName>
		</author>
		<idno type="DOI">10.1142/S021819679600009X</idno>
		<ptr target="https://doi.org/10.1142/S021819679600009X" />
	</analytic>
	<monogr>
		<title level="j">Int. J. Algebra Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="165" to="178" />
			<date type="published" when="1996">1996. 1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Bounded-Width Polynomial-Size Branching Programs Recognize Exactly Those Languages in NC 1</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A Mix</forename><surname>Barrington</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(89)90037-8</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(89)90037-8" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="150" to="164" />
			<date type="published" when="1989">1989. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Regular Languages in NC 1</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A Mix</forename><surname>Barrington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><forename type="middle">J</forename><surname>Compton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Howard</forename><surname>Straubing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Thérien</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(92)90014-A</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(92)90014-A" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="478" to="499" />
			<date type="published" when="1992">1992. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">First-order expressibility of languages with neutral letters or: The Crane Beach conjecture</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A Mix</forename><surname>Barrington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neil</forename><surname>Immerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clemens</forename><surname>Lautemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicole</forename><surname>Schweikardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Thérien</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.jcss.2004.07.004</idno>
		<ptr target="https://doi.org/10.1016/j.jcss.2004.07.004" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="101" to="127" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Finite monoids and the fine structure of NC 1</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">A Mix</forename><surname>Barrington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Thérien</surname></persName>
		</author>
		<idno type="DOI">10.1145/48014.63138</idno>
		<ptr target="https://doi.org/10.1145/48014.63138" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="941" to="952" />
			<date type="published" when="1988">1988. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Factorization Forests</title>
		<author>
			<persName><forename type="first">Mikolaj</forename><surname>Bojanczyk</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-02737-6_1</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-02737-6_1" />
	</analytic>
	<monogr>
		<title level="m">Developments in Language Theory, 13th International Conference, DLT 2009</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Volker</forename><surname>Diekert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dirk</forename><surname>Nowotka</surname></persName>
		</editor>
		<meeting><address><addrLine>Stuttgart, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009-06-30">2009. June 30 -July 3, 2009</date>
			<biblScope unit="volume">5583</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Dot-Depth Hierarchy of Star-Free Languages is Infinite</title>
		<author>
			<persName><forename type="first">A</forename><surname>Janusz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Brzozowski</surname></persName>
		</author>
		<author>
			<persName><surname>Knast</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(78)90049-1</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(78)90049-1" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="55" />
			<date type="published" when="1978">1978. 1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The Regular Languages of Wire Linear AC 0</title>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Cadilhac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><surname>Paperman</surname></persName>
		</author>
		<ptr target="https://hal.archives-ouvertes.fr/hal-03466451Submittedto" />
		<imprint>
			<date type="published" when="2021-12">2021. Dec. 2021</date>
		</imprint>
	</monogr>
	<note>Acta Informatica, special issue for the 70th birthday of Klaus-Jörn Lange</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Circuit Bottom Fan-In and Computational Power</title>
		<author>
			<persName><forename type="first">Liming</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianer</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johan</forename><surname>Håstad</surname></persName>
		</author>
		<idno type="DOI">10.1137/S0097539795282432</idno>
		<ptr target="https://doi.org/10.1137/S0097539795282432" />
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="341" to="355" />
			<date type="published" when="1998">1998. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">PAC Learning Depth-3 AC 0 Circuits of Bounded Top Fanin</title>
		<author>
			<persName><forename type="first">Ning</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanli</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dawu</forename><surname>Gu</surname></persName>
		</author>
		<ptr target="http://proceedings.mlr.press/v76/ding17a.html" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Algorithmic Learning Theory</title>
		<title level="s">Proceedings of Machine Learning Research</title>
		<editor>
			<persName><forename type="first">Steve</forename><surname>Hanneke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lev</forename><surname>Reyzin</surname></persName>
		</editor>
		<meeting><address><addrLine>ALT; Kyoto, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2017-10">2017. 2017. October 2017</date>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="667" to="680" />
		</imprint>
		<respStmt>
			<orgName>Kyoto University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Parity, Circuits, and the Polynomial-Time Hierarchy</title>
		<author>
			<persName><forename type="first">L</forename><surname>Merrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">B</forename><surname>Furst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><surname>Sipser</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF01744431</idno>
		<ptr target="https://doi.org/10.1007/BF01744431" />
	</analytic>
	<monogr>
		<title level="j">Math. Syst. Theory</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="13" to="27" />
			<date type="published" when="1984">1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Power of Programs over Monoids in DA</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Grosshans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Mckenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.MFCS.2017.2</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.MFCS.2017.2" />
	</analytic>
	<monogr>
		<title level="m">42nd International Symposium on Mathematical Foundations of Computer Science, MFCS 2017</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Kim</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Hans</forename><forename type="middle">L</forename><surname>Larsen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jean-François</forename><surname>Bodlaender</surname></persName>
		</editor>
		<editor>
			<persName><surname>Raskin</surname></persName>
		</editor>
		<meeting><address><addrLine>Aalborg, Denmark (LIPIcs</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-08-21">2017. August 21-25, 2017 -</date>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="1" to="2" />
		</imprint>
	</monogr>
	<note>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Threshold Circuits of Bounded Depth</title>
		<author>
			<persName><forename type="first">András</forename><surname>Hajnal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Maass</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavel</forename><surname>Pudlák</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mario</forename><surname>Szegedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">György</forename><surname>Turán</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(93)90001-D</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(93)90001-D" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="129" to="154" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Top-Down Lower Bounds for Depth-Three Circuits</title>
		<author>
			<persName><forename type="first">Johan</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stasys</forename><surname>Jukna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavel</forename><surname>Pudlák</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF01268140</idno>
		<ptr target="https://doi.org/10.1007/BF01268140" />
	</analytic>
	<monogr>
		<title level="j">Comput. Complex</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="99" to="112" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Almost Optimal Lower Bounds for Small Depth Circuits</title>
		<author>
			<persName><forename type="first">John</forename><surname>Håstad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Comput. Res</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="143" to="170" />
			<date type="published" when="1989">1989. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Extremal Combinatorics -With Applications in Computer Science</title>
		<author>
			<persName><forename type="first">Stasys</forename><surname>Jukna</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-17364-6</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-17364-6" />
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Circuit Complexity of Regular Languages</title>
		<author>
			<persName><forename type="first">Michal</forename><surname>Koucký</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00224-009-9180-z</idno>
		<ptr target="https://doi.org/10.1007/s00224-009-9180-z" />
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="865" to="879" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Bounded-depth circuits: separating wires from gates</title>
		<author>
			<persName><forename type="first">Michal</forename><surname>Koucký</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pavel</forename><surname>Pudlák</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Thérien</surname></persName>
		</author>
		<idno type="DOI">10.1145/1060590.1060629</idno>
		<ptr target="https://doi.org/10.1145/1060590.1060629" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">Harold</forename><forename type="middle">N</forename><surname>Gabow</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</editor>
		<meeting>the 37th Annual ACM Symposium on Theory of Computing<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005-05-22">2005. May 22-24, 2005</date>
			<biblScope unit="page" from="257" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Lothaire</surname></persName>
		</author>
		<title level="m">Combinatorics on words</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
	<note>second ed.</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Programs over semigroups of dot-depth one</title>
		<author>
			<persName><forename type="first">Alexis</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Péladeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Thérien</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0304-3975(99)00278-9</idno>
		<ptr target="https://doi.org/10.1016/S0304-3975(99)00278-9" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">245</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="135" to="148" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Dot-Depth Hierarchy, 45 Years Later</title>
		<author>
			<persName><forename type="first">Jean-Éric</forename><surname>Pin</surname></persName>
		</author>
		<idno type="DOI">10.1142/9789813148208_0008</idno>
		<ptr target="https://doi.org/10.1142/9789813148208_0008" />
	</analytic>
	<monogr>
		<title level="m">The Role of Theory in Computer Science -Essays Dedicated to Janusz</title>
		<editor>
			<persName><forename type="first">Stavros</forename><surname>Brzozowski</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Nelma</forename><surname>Konstantinidis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Rogério</forename><surname>Moreira</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">O</forename><surname>Reis</surname></persName>
		</editor>
		<editor>
			<persName><surname>Shallit</surname></persName>
		</editor>
		<imprint>
			<publisher>World Scientific</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="177" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Polynomial Closure and Unambiguous Product</title>
		<author>
			<persName><forename type="first">Jean-Éric</forename><surname>Pin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pascal</forename><surname>Weil</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF02679467</idno>
		<ptr target="https://doi.org/10.1007/BF02679467" />
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="383" to="422" />
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A variety theorem without complementation</title>
		<author>
			<persName><forename type="first">Jean-Éric</forename><surname>Pin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Russian Mathematics (Izvestija vuzov. Matematika)</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="80" to="90" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Separating regular languages with two quantifier alternations</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Place</surname></persName>
		</author>
		<idno type="DOI">10.23638/LMCS-14(4:16)2018</idno>
		<ptr target="https://doi.org/10.23638/LMCS-14(4:16)2018" />
	</analytic>
	<monogr>
		<title level="j">Log. Methods Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Going Higher in First-Order Quantifier Alternation Hierarchies on Words</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Place</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Zeitoun</surname></persName>
		</author>
		<idno type="DOI">10.1145/3303991</idno>
		<ptr target="https://doi.org/10.1145/3303991" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Borel Sets and Circuit Complexity</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Sipser</surname></persName>
		</author>
		<idno type="DOI">10.1145/800061.808733</idno>
		<ptr target="https://doi.org/10.1145/800061.808733" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Annual ACM Symposium on Theory of Computing</title>
		<editor>
			<persName><forename type="first">David</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><forename type="middle">L</forename><surname>Fredman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Harel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Nancy</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Christos</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ronald</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Walter</forename><forename type="middle">L</forename><surname>Ruzzo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Joel</forename><forename type="middle">I</forename><surname>Seiferas</surname></persName>
		</editor>
		<meeting>the 15th Annual ACM Symposium on Theory of Computing<address><addrLine>Boston, Massachusetts, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983-04-27">1983. 25-27 April, 1983</date>
			<biblScope unit="page" from="61" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Topological View of Some Problems in Complexity Theory</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Sipser</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0030341</idno>
		<ptr target="https://doi.org/10.1007/BFb0030341" />
	</analytic>
	<monogr>
		<title level="m">Mathematical Foundations of Computer Science</title>
		<title level="s">Proceedings (Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Michal</forename><surname>Chytil</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Václav</forename><surname>Koubek</surname></persName>
		</editor>
		<meeting><address><addrLine>Praha, Czechoslovakia</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1984-09-03">1984. 1984. September 3-7, 1984</date>
			<biblScope unit="volume">176</biblScope>
			<biblScope unit="page" from="567" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Finite semigroup varieties of the form 𝑉 ★ 𝐷</title>
		<author>
			<persName><forename type="first">Howard</forename><surname>Straubing</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-4049(85)90062-3</idno>
		<ptr target="https://doi.org/10.1016/0022-4049(85)90062-3" />
	</analytic>
	<monogr>
		<title level="j">Journal of Pure and Applied Algebra</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="53" to="94" />
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Constant-Depth periodic Circuits</title>
		<author>
			<persName><forename type="first">Howard</forename><surname>Straubing</surname></persName>
		</author>
		<idno type="DOI">10.1142/S0218196791000043</idno>
		<ptr target="https://doi.org/10.1142/S0218196791000043" />
	</analytic>
	<monogr>
		<title level="j">Int. J. Algebra Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="88" />
			<date type="published" when="1991">1991. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Finite Automata, Formal Logic, and Circuit Complexity</title>
		<author>
			<persName><forename type="first">Howard</forename><surname>Straubing</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4612-0289-9</idno>
		<ptr target="https://doi.org/10.1007/978-1-4612-0289-9" />
		<imprint>
			<date type="published" when="1994">1994</date>
			<pubPlace>Birkhäuser, Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Languages Defined with Modular Counting</title>
		<author>
			<persName><forename type="first">Howard</forename><surname>Straubing</surname></persName>
		</author>
		<idno type="DOI">10.1006/inco.2000.2923</idno>
		<ptr target="https://doi.org/10.1006/inco.2000.2923" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">166</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="112" to="132" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A new proof of the locality of R</title>
		<author>
			<persName><forename type="first">Howard</forename><surname>Straubing</surname></persName>
		</author>
		<idno type="DOI">10.1142/S0218196715400111</idno>
		<ptr target="https://doi.org/10.1142/S0218196715400111" />
	</analytic>
	<monogr>
		<title level="j">Int. J. Algebra Comput</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="293" to="300" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Over Words, Two Variables Are as Powerful as One Quantifier Alternation</title>
		<author>
			<persName><forename type="first">Denis</forename><surname>Thérien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Wilke</surname></persName>
		</author>
		<idno type="DOI">10.1145/276698.276749</idno>
		<ptr target="https://doi.org/10.1145/276698.276749" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth Annual ACM Symposium on the Theory of Computing</title>
		<editor>
			<persName><forename type="first">Jeffrey</forename><surname>Scott</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vitter</forename></persName>
		</editor>
		<meeting>the Thirtieth Annual ACM Symposium on the Theory of Computing<address><addrLine>Dallas, Texas, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998-05-23">1998. May 23-26, 1998</date>
			<biblScope unit="page" from="234" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Categories as algebra: An essential ingredient in the theory of monoids</title>
		<author>
			<persName><forename type="first">Bret</forename><surname>Tilson</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-4049(87)90108-3</idno>
		<ptr target="https://doi.org/10.1016/0022-4049(87)90108-3" />
	</analytic>
	<monogr>
		<title level="j">Journal of Pure and Applied Algebra</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="83" to="198" />
			<date type="published" when="1987">1987. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
