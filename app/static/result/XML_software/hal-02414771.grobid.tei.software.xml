<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Power of Programs over Monoids in J</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Nathan</forename><surname>Grosshans</surname></persName>
							<email>nathan.grosshans@polytechnique.edu</email>
							<affiliation key="aff0">
								<orgName type="department">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Power of Programs over Monoids in J</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">EE4E08D7D1065674C84B626C7F73087F</idno>
					<idno type="DOI">10.1007/978-3-030-40608-0_22</idno>
					<note type="submission">Submitted on 17 Dec 2019</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In computational complexity theory, many hard still open questions concern relationships between complexity classes that are expected to be quite small in comparison to the mainstream complexity class P of tractable languages. One of the smallest such classes is NC 1 , the class of languages decided by Boolean circuits of polynomial length, logarithmic depth and bounded fan-in, a relevant and meaningful class, that has many characterisations but whose internal structure still mostly is a mystery. Indeed, among its most important subclasses, we count AC 0 , CC 0 and ACC 0 : all of them are conjectured to be different from each other and strictly within NC 1 , but despite many efforts for several decades, this could only be proved for the first of those classes.</p><p>In the late eighties, Barrington and Thérien <ref type="bibr" target="#b3">[3]</ref>, building on Barrington's celebrated theorem <ref type="bibr" target="#b2">[2]</ref>, gave an interesting viewpoint on those conjectures, relying on algebraic automata theory. They defined the notion of a program over a monoid M : a sequence of instructions (i, f ), associating through function f some element of M to the letter at position i in the input of fixed length. In that way, the program outputs an element of M for every input word, by multiplying out the elements given by the instructions for that word; acceptance or rejection then depends on that outputted element. A language of words of arbitrary length is consequently recognised in a non-uniform fashion, by a sequence of programs over some fixed monoid, one for each possible input length; when that sequence is of polynomial length, it is said that the monoid p-recognises that language. Barrington and Thérien's discovery is that NC 1 and almost all of its significant subclasses can each be exactly characterised by p-recognition over monoids taken from some suitably chosen variety of finite monoids (a class of finite monoids closed under basic operations on monoids). For instance, NC 1 , AC 0 , CC 0 and ACC 0 correspond exactly to p-recognition by, respectively, finite monoids, finite aperiodic monoids, finite solvable groups and finite solvable monoids. Understanding the internal structure of NC 1 thus becomes a matter of understanding what finite monoids from some particular variety are able to p-recognise.</p><p>It soon became clear that regular languages play a central role in understanding p-recognition: McKenzie, Péladeau and Thérien indeed observed <ref type="bibr" target="#b12">[12]</ref> that finite monoids from a variety V and a variety W p-recognise the same languages if and only if they p-recognise the same regular languages. Otherwise stated, most conjectures about the internal structure of NC 1 can be reformulated as a statement about where one or several regular languages lie within that structure. This is why a line of previous works got interested into various notions of tameness, capturing the fact that for a given variety of finite monoids, p-recognition does not offer much more power than classical morphism-recognition when it comes to regular languages (see <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b21">21,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b8">8]</ref>).</p><p>This paper is a contribution to an ongoing study of what regular languages can be p-recognised by monoids taken from "small" varieties, started with the author's Ph.D. thesis <ref type="bibr" target="#b7">[7]</ref>. In a previous paper by the author with McKenzie and Segoufin <ref type="bibr" target="#b8">[8]</ref>, a novel notion of tameness was introduced and shown for the "small" variety of finite aperiodic monoids DA. This allowed them to characterise the class of regular languages p-recognised by monoids from DA as those recognised by so called quasi-DA morphisms and represented a first small step towards a new proof that the variety A of finite aperiodic monoids is tame. This is a statement equivalent to Furst's, Saxe's, Sipser's <ref type="bibr" target="#b6">[6]</ref> and Ajtai's <ref type="bibr" target="#b0">[1]</ref> well-known lower bound result about AC 0 . In <ref type="bibr" target="#b8">[8]</ref>, the authors also observed that, while DA "behaves well" with respect to p-recognition of regular languages, the variety J, a subclass of DA, does, in contrast, "behave badly" in the sense that monoids from J do p-recognise regular languages that are not recognised by quasi-J morphisms. Now, J is a well-studied and fundamental variety in algebraic automata theory (see, e.g., <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b16">16]</ref>), corresponding through classical morphism-recognition to the class of regular languages in which membership depends on the presence or absence of a finite set of words as subwords. This paper is a contribution to the understanding of the power of programs over monoids in J, a knowledge that certainly does not bring us closer to a new proof of the tameness of A (as we are dealing with a strict subvariety of DA), but that is motivated by the importance of J in algebraic automata theory and the unexpected power of programs over monoids in J. The results we present in this article are twofold: first, we exhibit a fine hierarchy within the class of languages p-recognised by monoids from J, depending on the length of those programs and on a parametrisation of J; second, we show that a whole class of regular languages, that form a subclass of dot-depth one languages <ref type="bibr" target="#b16">[16]</ref>, are p-recognised by monoids from J while, in general, they are not recognised by any quasi-J morphism. This class roughly corresponds to dot-depth one languages where detection of a given factor does work only when it does not appear too often as a subword. We actually even conjecture that this class of languages with additional positional modular counting (that is, letters can be differentiated according to their position modulo some fixed number) corresponds exactly to all those p-recognised by monoids in J, a statement that is interesting in itself for algebraic automata theory.</p><p>Organisation of the paper. Following the present introduction, Section 2 is dedicated to the necessary preliminaries. In Section 3, we present the results about the fine hierarchy and in Section 4 we expose the results concerning the regular languages p-recognised by monoids from J. Section 5 gives a short conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note.</head><p>This article is based on unpublished parts of the author's Ph.D. thesis <ref type="bibr" target="#b7">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Various mathematical materials</head><p>We assume the reader is familiar with the basics of formal language theory, semigroup theory and recognition by morphisms, that we might designate by classical recognition; for those, we only specify some things and refer the reader to the two classical references of the domain by Eilenberg <ref type="bibr" target="#b4">[4,</ref><ref type="bibr" target="#b5">5]</ref> and Pin <ref type="bibr" target="#b15">[15]</ref>.</p><p>General notations and conventions. Let i, j ∈ N. We shall denote by <ref type="bibr">[[i, j]</ref>] the set of all n ∈ N verifying i ≤ n ≤ j. We shall also denote by [i] the set [ <ref type="bibr">[1, i]</ref>]. Given some set E, we shall denote by P(E) the powerset of E. All our alphabets and words will always be finite; the empty word will be denoted by ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Varieties and languages.</head><p>A variety of monoids is a class of finite monoids closed under submonoids, Cartesian product and morphic images. A variety of semigroups is defined similarly. When dealing with varieties, we consider only finite monoids and semigroups, each having an idempotent power, a smallest ω ∈ N &gt;0 such that x ω = x 2ω for any element x. To give an example, the variety of finite aperiodic monoids, denoted by A, contains all finite monoids M such that, given ω its idempotent power, x ω = x ω+1 for all x ∈ M .</p><p>To each variety V of monoids or semigroups we associate the class L(V) of languages such that, respectively, their syntactic monoid or semigroup belongs to V. For instance, L(A) is well-known to be the class of star-free languages. Quasi V languages. If S is a semigroup we denote by S 1 the monoid S if S is already a monoid and S ∪ {1} otherwise.</p><p>The following definitions are taken from <ref type="bibr" target="#b17">[17]</ref>. Let ϕ be a surjective morphism from Σ * to a finite monoid M . For all k consider the subset ϕ(Σ k ) of M (where Σ k is the set of words over Σ of length k). As M is finite there is a k such that ϕ(Σ 2k ) = ϕ(Σ k ). This implies that ϕ(Σ k ) is a semigroup. The semigroup given by the smallest such k is called the stable semigroup of ϕ. If S is the stable semigroup of ϕ, S 1 is called the stable monoid of ϕ. If V is a variety of monoids or semigroups, then we shall denote by QV the class of such surjective morphisms whose stable monoid or semigroup, respectively, is in V and by L(QV) the class of languages whose syntactic morphism is in QV.</p><p>Programs over monoids. Programs over monoids form a non-uniform model of computation, first defined by Barrington and Thérien <ref type="bibr" target="#b3">[3]</ref>, extending Barrington's permutation branching program model <ref type="bibr" target="#b2">[2]</ref>. Let M be a finite monoid and Σ an alphabet. A program P over M on Σ n is a finite sequence of instructions of the form (i, f ) where i ∈ [n] and f ∈ M Σ ; said otherwise, it is a word over ([n] × M Σ ). The length of P , denoted by |P |, is the number of its instructions. The program P defines a function from Σ n to M as follows. On input w ∈ Σ n , each instruction (i, f ) outputs the monoid element f (w i ). A sequence of instructions then yields a sequence of elements of M and their product is the output P (w) of the program. A language L ⊆ Σ n is consequently recognised by P whenever there exists F ⊆ M such that L = P -1 (F ).</p><p>A language L over Σ is recognised by a sequence of programs (P n ) n∈N over some finite monoid M if for each n, the program P n is on Σ n and recognises</p><formula xml:id="formula_0">L =n = L ∩ Σ n . We say (P n ) n∈N is of length s(n) for s : N → N whenever |P n | = s(n) for all n ∈ N and that it is of length at most s(n) whenever there exists α ∈ R &gt;0 verifying |P n | ≤ α • s(n) for all n ∈ N.</formula><p>For s : N → N and V a variety of monoids, we denote by P(V, s(n)) the class of languages recognised by sequences of programs over monoids in V of length at most s(n). The class P(V) = k∈N P V, n k is then the class of languages p-recognised by a monoid in V, i.e. recognised by sequences of programs over monoids in V of polynomial length.</p><p>The following is an important property of P(V).</p><p>Proposition 2.1 ([12, Corollary 3.5]). Let V be a variety of monoids, then P(V) is closed under Boolean operations.</p><p>Given two alphabets Σ and Γ, a Γ-program on Σ n for n ∈ N is defined just like a program over some finite monoid M on Σ n , except that instructions output letters from Γ and thus that the program outputs words over Γ. Let now L ⊆ Σ * and K ⊆ Γ * . We say that L program-reduces to K if and only if there exists a sequence (Ψ n ) n∈N of Γ-programs (the program-reduction) such that Ψ n is on Σ n and L =n = Ψ -1 n (K =|Ψn| ) for each n ∈ N. The following proposition shows closure of P(V) also under program-reductions. Proposition 2.2 ([7, Proposition 3.3.12 and Corollary 3.4.3]). Let Σ and Γ be two alphabets. Let V be a variety of monoids. Given K ⊆ Γ * in P(V, s(n)) for s : N → N and L ⊆ Σ * from which there exists a program-reduction to K of length t(n), for t : N → N, we have that L ∈ P(V, s(t(n))). In particular, when K is recognised (classically) by a monoid in V, we have that L ∈ P(V, t(n)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Tameness and the variety J</head><p>We won't introduce any of the proposed notions of tameness but will only state that the main consequence for a variety of monoids V to be tame in the sense of <ref type="bibr" target="#b8">[8]</ref> is that P(V) ∩ Reg ⊆ L(QV). This consequence has far-reaching implications from a computational-complexity-theoretic standpoint when P(V) happens to be equal to a circuit complexity class. For instance, tameness for A implies that P(A) ∩ Reg ⊆ L(QA), which is equivalent to the fact that AC 0 does not contain the language MOD m of words over {0, 1} containing a number of 1s not divisible by m for any m ∈ N, m ≥ 2 (a central result in complexity theory <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b0">1]</ref>).</p><p>Let us now define the variety of monoids J. A finite monoid M of idempotent power ω belongs to J if and only if (xy) ω = (xy) ω x = y(xy) ω for all x, y ∈ M . It is a strict subvariety of the variety DA, containing all finite monoids M of idempotent power ω such that (xy) ω = (xy) ω x(xy) ω for all x, y ∈ M , itself a strict subvariety of A. The variety J is a "small" one, well within A.</p><p>We now give some specific definitions and results about J that we will use, based essentially on <ref type="bibr" target="#b9">[9]</ref>, but also on [15, Chapter 4, Section 1].</p><p>For some alphabet Σ and each k ∈ N, let us define the equivalence relation ∼ k on Σ * by u ∼ k v if and only if u and v have the same set of k-subwords (subwords of length at most k), for all u, v ∈ Σ * . The relation ∼ k is a congruence of finite index on Σ * . For an alphabet Σ and a word u ∈ Σ * , we shall write u ¡ Σ * for the language of all words over Σ having u as a subword. In the following, we consider that ¡ has precedence over ∪ and ∩ (but of course not over concatenation).</p><p>We define the class of piecewise testable languages PT as the class of regular languages such that for every alphabet Σ, we associate to Σ * the set PT (Σ * ) of all languages over Σ that are Boolean combinations of languages of the form u ¡ Σ * where u ∈ Σ * . In fact, PT (Σ * ) is the set of languages over Σ equal to a union of ∼ k -classes for some k ∈ N (see <ref type="bibr" target="#b18">[18]</ref>). Simon showed <ref type="bibr" target="#b18">[18]</ref> that a language is piecewise testable if and only if its syntactic monoid is in J, i.e. PT = L(J).</p><p>We can define a hierarchy of piecewise testable languages in a natural way. For k ∈ N, let the class of k-piecewise testable languages PT k be the class of regular languages such that for every alphabet Σ, we associate to Σ * the set PT k (Σ * ) of all languages over Σ that are Boolean combinations of languages of the form u ¡ Σ * where u ∈ Σ * with |u| ≤ k. We then have that PT k (Σ * ) is the set of languages over Σ equal to a union of ∼ k -classes. Let us define J k the inclusion-wise smallest variety of monoids containing the quotients of Σ * by ∼ k for any alphabet Σ: we have that a language is k-piecewise testable if and only if its syntactic monoid belongs to J k , i.e. PT k = L(J k ). (See [9, Section 3].)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Fine Hierarchy</head><p>The first part of our investigation of the computational power of programs over monoids in J concerns the influence of the length of programs on their computational capabilities.</p><p>We say two programs over a same monoid on the same set of input words are equivalent if and only if they recognise the same languages. Tesson and Thérien proved in <ref type="bibr" target="#b23">[23]</ref> that for any monoid M in DA, there exists some k ∈ N such that for any alphabet Σ there is a constant c ∈ N &gt;0 verifying that any program over M on Σ n for n ∈ N is equivalent to a program over M on Σ n of length at most c • n k . Since J ⊂ DA, any monoid in J does also have this property. However, this does not imply that there exists some k ∈ N working for all monoids in J, i.e. that P(J) collapses to P J, n k .</p><p>In this section, we show on the one hand that, as for DA, while P(J, s(n)) collapses to P(J) for any super-polynomial function s : N → N, there does not exist any k ∈ N such that P(J) collapses to P J, n k ; and on the other hand that P(J k ) does optimally collapse to P J k , n k/2 for each k ∈ N.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Strict hierarchy</head><p>Given k, n ∈ N, we say that σ is a k-selector over n if σ is a function of P([n]) [n] k that associates a subset of [n] to each vector in [n] k . For any sequence ∆ = (σ n ) n∈N such that σ n is a k-selector over n for each n ∈ N -a sequence we will call a sequence of k-selectors -, we set L ∆ = n∈N K n,σn , where for each n ∈ N, the language K n,σn is the set of words over {0, 1} of length (k + 1) • n that can be decomposed into k + 1 consecutive blocks u (1) , u (2) , . . . , u (k) , v of n letters where the first k blocks each contain 1 exactly once and uniquely define a vector ρ in [n] k , where for all i ∈ [k], ρ i is given by the position of the only 1 in u (i) (i.e. u (i) ρi = 1) and v is such that there exists j ∈ σ n (ρ) verifying that v j is 1. Observe that for any k-selector σ 0 over 0, we have K 0,σ0 = ∅.</p><p>We now proceed similarly to what has been done in Subsection 5.1 in <ref type="bibr" target="#b8">[8]</ref> to show, on one hand, that for all k ∈ N, there is a monoid M k in J 2k+1 such that for any sequence of k-selectors ∆, the language L ∆ is recognised by a sequence of programs over M k of length at most n k+1 ; and, on the other hand, that for all k ∈ N there is a sequence of k-selectors ∆ such that for any finite monoid M and any sequence of programs (P n ) n∈N over M of length at most n k , the language L ∆ is not recognised by (P n ) n∈N .</p><p>We obtain the following proposition; the proof can be found in Appendix A.</p><p>Proposition 3.1. For all k ∈ N, we have P J, n k ⊂ P J, n k+1 . More precisely, for all k ∈ N and d ∈ N, d ≤ k 2 -1, we have P J k , n d ⊂ P J k , n d+1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Collapse</head><p>Looking at Proposition 3.1, it looks at first glance rather strange that, for each k ∈ N, we can only prove strictness of the hierarchy inside P(J k ) up to exponent k 2 . We now show, in a way similar to Subsection 5.2 in <ref type="bibr" target="#b8">[8]</ref>, that in fact P(J k ) does collapse to P J k , n k/2 for all k ∈ N, showing Proposition 3.1 to be optimal in some sense. Due to space constraints, we leave the proof to Appendix A. Proposition 3.2. Let k ∈ N. Let M ∈ J k and Σ be an alphabet. Then there exists a constant c ∈ N &gt;0 such that any program over M on</p><formula xml:id="formula_1">Σ n for n ∈ N is equivalent to a program over M on Σ n of length at most c • n k/2 .</formula><p>In particular, P(J k ) = P J k , n k/2 for all k ∈ N.</p><p>4 Regular Languages in P(J)</p><p>The second part of our investigation of the computational power of programs over monoids in J is dedicated to understanding exactly what regular languages can be p-recognised by monoids in J.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Non-tameness of J</head><p>It is shown in <ref type="bibr" target="#b8">[8]</ref> that P(J) ∩ Reg L(QJ), thus giving an example of a wellknown subvariety of A for which p-recognition allows to do unexpected things when recognising a regular language. How far does this unexpected power go?</p><p>The first thing to notice is that, though none of them is in L(QJ), all languages of the form Σ * u and uΣ * for Σ an alphabet and u ∈ Σ + are in P(J). Indeed, each of them can be recognised by a sequence of constant-length programs over the syntactic monoid of u ¡ Σ * : for every input length, just output the image, through the syntactic morphism of u ¡Σ * , of the word made of the |u| first or last letters. So, informally stated, programs over monoids in J can check for some constant-length beginning or ending of their input words.</p><p>But they can do much more. Indeed, the language (a + b) * ac + does not belong to L(QJ) (compute the stable monoid), yet it is in P(J). The crucial insight is that it can be program-reduced in linear length to the piecewise testable language of all words over {a, b, c} having ca as a subword but not the subwords cca, caa and cb by using the following trick (that we shall call "feedback-sweeping") for input length n ∈ N: read the input letters in the order 2, 1, 3, 2, 4, 3, 5, 4, . . . , n, n-1, output the letters read. This has already been observed in [8, <ref type="bibr">Proposition 5]</ref>; here we give a formal proof of the following lemma, to be found in Appendix B.</p><formula xml:id="formula_2">Lemma 4.1. (a + b) * ac + ∈ P(J, n).</formula><p>Using variants of the "feedback-sweeping" reading technique, we can prove that the phenomenon just described is not an isolated case. Hence, we are tempted to say that there are "much more" regular languages in P(J) than just those in L(QJ), even though it is not clear to us whether L(QJ) ⊆ P(J) or not. But can we show any upper bound on P(J) ∩ Reg? It turns out that we can, relying on two known results.</p><p>First, since J ⊆ DA, we have P(J) ⊆ P(DA), so Theorem 6 in <ref type="bibr" target="#b8">[8]</ref>, that states P(DA) ∩ Reg = L(QDA), implies that P(J) ∩ Reg ⊆ L(QDA).</p><p>Second, let us define an important superclass of the class of piecewise testable languages. Let Σ be an alphabet and u 1 , . . . ,</p><formula xml:id="formula_3">u k ∈ Σ + (k ∈ N &gt;0 ); we define [u 1 , . . . , u k ] = Σ * u 1 Σ * • • • Σ * u k Σ * .</formula><p>The class of dot-depth one languages is the class of Boolean combinations of languages of the form Σ * u, uΣ * and [u 1 , . . . , u k ] for Σ an alphabet, k ∈ N &gt;0 and u, u 1 , . . . , u k ∈ Σ + . The inclusion-wise smallest variety of semigroups containing all syntactic semigroups of dot-depth one languages is denoted by J * D and verifies that L(J * D) is exactly the class of dot-depth one languages. (See <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b16">16]</ref>.) It has been shown in <ref type="bibr" target="#b11">[11,</ref><ref type="bibr">Corollary 8]</ref> that P(J * D) ∩ Reg = L(Q(J * D)) (if we extend the program-over-monoid formalism in the obvious way to finite semigroups). Now, we have J ⊆ J * D, so that P(J) ⊆ P(J * D) and hence P(J) ∩ Reg ⊆ L(Q(J * D)).</p><p>To summarise, we have the following.</p><formula xml:id="formula_4">Proposition 4.3. P(J) ∩ Reg ⊆ L(QDA) ∩ L(Q(J * D)).</formula><p>In fact, we conjecture that the inverse inclusion does also hold.</p><formula xml:id="formula_5">Conjecture 1. P(J) ∩ Reg = L(QDA) ∩ L(Q(J * D)).</formula><p>Why do we think this should be true? Though, for a given alphabet Σ, we cannot decide whether some word u ∈ Σ + of length at least 2 appears as a factor of any given word w in Σ * with programs over monoids in J (because Σ * uΣ * / ∈ L(QDA)), Lemma 4.2 and the possibilities offered by the "feedback-sweeping" technique give the impression that we can do it when we are guaranteed that u appears at most a fixed number of times in w, which seems somehow to be what dot-depth one languages become when restricted to belong to L(QDA). This intuition motivates the definition of threshold dot-depth one languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Threshold dot-depth one languages</head><p>The idea behind the definition of threshold dot-depth one languages is that we take the basic building blocks of dot-depth one languages, of the form [u 1 , . . . , u k ] for an alphabet Σ, for k ∈ N &gt;0 and u 1 , . . . , u k ∈ Σ + , and restrict them so that, given l ∈ N &gt;0 , membership of a word does really depend on the presence of a given word u i as a factor if and only if it appears less than l times as a subword. Definition 4.4. Let Σ be an alphabet. For all u ∈ Σ + and l ∈ N &gt;0 , we define [u] l to be the language of words over Σ containing u l as a subword or u as a factor, i.e.</p><formula xml:id="formula_6">[u] l = Σ * uΣ * ∪ u l ¡Σ * . Then, for all u 1 , . . . , u k ∈ Σ + (k ∈ N, k ≥ 2) and l ∈ N &gt;0 , we define [u 1 , . . . , u k ] l = [u 1 ] l • • • [u k ] l . Obviously, for each Σ an alphabet, k ∈ N &gt;0 and u 1 , . . . , u k ∈ Σ + , the language [u 1 , . . . , u k ] 1 equals u 1 • • • u k ¡ Σ * .</formula><p>Over {a, b, c}, the language [ab, c] 3 contains all words containing a letter c verifying that in the prefix up to that letter, ababab appears as a subword or ab appears as a factor. Finally, the language (a+b) * ac + over {a, b, c} of Lemma 4.</p><formula xml:id="formula_7">1 is equal to [c, a] 2 ∩[c, b] 2 ∩[ac] 2 .</formula><p>We then define a threshold dot-depth one language as any Boolean combination of languages of the form Σ * u, uΣ * and [u 1 , . . . , u k ] l for Σ an alphabet, for k, l ∈ N &gt;0 and u, u 1 , . . . , u k ∈ Σ + .</p><p>Confirming the intuition briefly given above, the technique of "feedbacksweeping" can indeed be pushed further to prove that the whole class of threshold dot-depth one languages is contained in P(J), and we dedicate the remainder of this section to prove it. Concerning Conjecture 1, our intuition leads us to believe that, in fact, the class of threshold dot-depth one languages with additional positional modular counting is exactly L(QDA) ∩ L(Q(J * D)). We simply refer the interested reader to Section 5.4 of the author's Ph.D. thesis <ref type="bibr" target="#b7">[7]</ref>, that contains a partial result supporting this belief, too technical and long to be presented here.</p><p>Let us now move on to the proof of the following theorem.</p><p>Theorem 4.5. Every threshold dot-depth one language belongs to P(J).</p><p>As P(J) is closed under Boolean operations (Proposition 2.1), our goal is to prove, given an alphabet Σ, given l ∈ N &gt;0 and u 1 , . . . , u k ∈ Σ + (k ∈ N &gt;0 ), that [u 1 , . . . , u k ] l is in P(J); the case of Σ * u and uΣ * for u ∈ Σ + is easily handled (see the discussion at the beginning of Subsection 4.1). To do this, we need to put</p><formula xml:id="formula_8">[u 1 , . . . , u k ] l in some normal form. It is readily seen that [u 1 , . . . , u k ] l = q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k )</formula><p>where the L (l) (ui,qi) 's are defined thereafter. Definition 4.6. Let Σ be an alphabet.</p><formula xml:id="formula_9">For all u ∈ Σ + , l ∈ N &gt;0 and α ∈ [l], set L (l) (u,α) = Σ * uΣ * if α &lt; l u l ¡ Σ * otherwise .</formula><p>Building directly a sequence of programs over a monoid in J that decides</p><formula xml:id="formula_10">L (l) (u1,q1) • • • L (l) (u k ,q k )</formula><p>for some alphabet Σ and q 1 , . . . , q k ∈ {1, l} seems however tricky. We need to split things further by controlling precisely how many times each u i for i ∈ [k] appears in the right place when it does less than l times. To do this, we consider, for each α ∈ [l] k , the language R α l (u 1 , . . . , u k ) defined below.</p><p>Definition 4.7. Let Σ be an alphabet.</p><p>For all u 1 , . . . ,</p><formula xml:id="formula_11">u k ∈ Σ + (k ∈ N &gt;0 ), l ∈ N &gt;0 , α ∈ [l] k , we set R α l (u 1 , . . . , u k ) =(u 1 α1 • • • u k α k ) ¡ Σ * ∩ i∈[k],αi&lt;l (u 1 α1 • • • u i αi+1 • • • u k α k ) ¡ Σ * .</formula><p>Now, for a given α ∈ [l] k , we are interested in the words of R α l (u 1 , . . . , u k ) such that for each i ∈ [k] verifying α i &lt; l, the word u i indeed appears as a factor in the right place. We thus introduce a last language S α l (u 1 , . . . , u k ) defined as follows.</p><p>Definition 4.8. Let Σ be an alphabet.</p><p>For all u 1 , . . . ,</p><formula xml:id="formula_12">u k ∈ Σ + (k ∈ N &gt;0 ), l ∈ N &gt;0 , α ∈ [l] k , we set S α l (u 1 , . . . , u k ) = i∈[k],αi&lt;l (u 1 α1 • • • u i-1 αi-1 )¡Σ * u i (u i+1 αi+1 • • • u k α k )¡Σ * .</formula><p>We now have the normal form we were looking for to prove Theorem 4.5: [u 1 , . . . , u k ] l is equal to the union, over all α ∈ [l] k , of the intersection of R α l (u 1 , . . . , u k ) and S α l (u 1 , . . . , u k ). Though rather intuitive, the correctness of this decomposition is not so straightforward to prove and, actually, we can only prove it when for each i ∈ [k], the letters in u i are all distinct. (The tedious proof is to be found in Appendix B.) Lemma 4.9. Let Σ be an alphabet, l ∈ N &gt;0 and u 1 , . . . ,</p><formula xml:id="formula_13">u k ∈ Σ + (k ∈ N &gt;0 ) such that for each i ∈ [k], the letters in u i are all distinct. Then, q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) = α∈[l] k R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) .</formula><p>Our goal now is to prove, given an alphabet Σ, given l ∈ N &gt;0 and u 1 , . . . , u k ∈ Σ + (k ∈ N &gt;0 ) such that for each i ∈ [k], the letters in u i are all distinct, that for any α ∈ [l] k , the language R α l (u 1 , . . . , u k )∩S α l (u 1 , . . . , u k ) is in P(J); closure of P(J) under union (Proposition 2.1) consequently entails that [u 1 , . . . , u k ] l ∈ P(J). The way R α l (u 1 , . . . , u k ) and S α l (u 1 , . . . , u k ) are defined allows us to reason as follows. For each i ∈ [k] verifying α i &lt; l, let L i be the language of words w over Σ containing x i,1 u i αi x i,2 as a subword but not x i,1 u i αi+1 x i,2</p><p>and such that w = y 1 u i y 2 with y 1 ∈ x i,1 ¡ Σ * and y 2 ∈ x i,2 ¡ Σ * , where</p><formula xml:id="formula_14">x i,1 = u 1 α1 • • • u i-1 αi-1 and x i,2 = u i+1 αi+1 • • • u k α k . If we manage to prove that for each i ∈ [k] verifying α i &lt; l we have L i ∈ P(J), we can conclude that R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) = (u 1 α1 • • • u k α k ) ¡ Σ * ∩ i∈[k],αi&lt;l L i does</formula><p>belong to P(J) by closure of P(J) under intersection, Proposition 2.1. The lemma that follows, the main lemma in the proof of Theorem 4.5, exactly shows this. The proof crucially uses the "feedback sweeping" technique, but note that we actually don't know how to prove it when we do not enforce that for each i ∈ [k], the letters in u i are all distinct.</p><p>Lemma 4.10. Let Σ be an alphabet and u ∈ Σ + such that its letters are all distinct. For all α ∈ N &gt;0 and x 1 , x 2 ∈ Σ * , we have</p><formula xml:id="formula_15">(x 1 u α x 2 ) ¡ Σ * ∩ (x 1 u α+1 x 2 ) ¡ Σ * ∩ (x 1 ¡ Σ * )u(x 2 ¡ Σ * ) ∈ P(J) .</formula><p>Sketch. Let Σ be an alphabet and u ∈ Σ + such that its letters are all distinct. Let α ∈ N &gt;0 and x 1 , x 2 ∈ Σ * . We let</p><formula xml:id="formula_16">L = (x 1 u α x 2 ) ¡ Σ * ∩ (x 1 u α+1 x 2 ) ¡ Σ * ∩ (x 1 ¡ Σ * )u(x 2 ¡ Σ * ) .</formula><p>If |u| = 1, the lemma follows trivially because L is piecewise testable and hence belongs to L(J), so we assume |u| &gt; 1.</p><p>For each letter a ∈ Σ, we shall use 2 |u| -1 distinct decorated letters of the form a (i) for some i ∈ [[0, 2 |u| -2]], using the convention that a (0) = a; of course, for two distinct letters a, b ∈ Σ, we have that a (i) and b (j) are distinct for all i, j ∈ [[0, 2 |u| -2]]. We denote by A the alphabet of these decorated letters. The main idea of the proof is, for a given input length n ∈ N, to build an A-program Ψ n over Σ n such that, given an input word w ∈ Σ n , it first ouputs the |u| -1 first letters of w and then, for each i going from |u| to n, outputs w i , followed by w</p><formula xml:id="formula_17">(1) i-1 • • • w (|u|-1)</formula><p>i-|u|+1 (a "sweep" of |u|-1 letters backwards down to position i-|u|+ 1, decorating the letters incrementally) and finally by w</p><formula xml:id="formula_18">(|u|) i-|u|+2 • • • w (2|u|-2) i</formula><p>(a "sweep" forwards up to position i, continuing the incremental decoration of the letters). The idea behind this way of rearranging and decorating letters is that, given an input word w ∈ Σ n , as long as we make sure that w and thus Ψ n (w) do contain x 1 u α x 2 as a subword but not x 1 u α+1 x 2 , then Ψ n (w) can be decomposed as Ψ n (w) = y 1 zy 2 where y 1 ∈ x 1 ¡Σ * , y 2 ∈ x 2 ¡Σ * , and</p><formula xml:id="formula_19">|y 1 | , |y 2 | are minimal, with z containing u β u (1) |u|-1 • • • u (|u|-1) 1 u (|u|) 2 • • • u (2|u|-2) |u| u α-β as a subword for some β ∈ [α] if and only if w ∈ (x 1 ¡ Σ * )u(x 2 ¡ Σ * )</formula><p>. This means we can check whether w ∈ L by testing whether w belongs to some fixed piecewise testable language over A.</p><p>The full proof can be found in Appendix B.</p><p>As explained before stating the previous lemma, we can now use it to prove the result we were aiming for. The detailed proof can be found in Appendix B. Proposition 4.11. Let Σ be an alphabet, l ∈ N &gt;0 and u 1 , . . . ,</p><formula xml:id="formula_20">u k ∈ Σ + (k ∈ N &gt;0 ) such that for each i ∈ [k], the letters in u i are all distinct. For all α ∈ [l] k , we have R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , .</formula><p>. . , u k ) ∈ P(J). We thus derive the awaited corollary. Corollary 4.12. Let Σ be an alphabet, l ∈ N &gt;0 and u 1 , . . . , u k ∈ Σ + (k ∈ N &gt;0 ) such that for each i ∈ [k], the letters in u i are all distinct. Then, [u 1 , . . . , u k ] l ∈ P(J).</p><p>However, what we really want to obtain is that [u 1 , . . . , u k ] l ∈ P(J) without putting any restriction on the u i 's. But, in fact, to remove the constraint that the letters must be all distinct in each of the u i 's, we simply have to decorate each of the input letters with its position minus 1 modulo a big enough d ∈ N &gt;0 . This finally leads to the following proposition; as usual, the proof is in Appendix B. Proposition 4.13. Let Σ be an alphabet, l ∈ N &gt;0 and u 1 , . . . ,</p><formula xml:id="formula_21">u k ∈ Σ + (k ∈ N &gt;0 ). Then [u 1 , . . . , u k ] l ∈ P(J).</formula><p>This finishes to prove Theorem 4.5 by closure of P(J) under Boolean combinations (Proposition 2.1) and by the discussion at the beginning of Subsection 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>Although P(J) is very small compared to AC 0 , we have shown that programs over monoids in J are an interesting subject of study in that they allow to do quite unexpected things. The "feedback-sweeping" technique allows one to detect presence of a factor thanks to such programs as long as this factor does not appear too often as a subword: this is the basic principle behind threshold dot-depth one languages, that our article shows to belong wholly to P(J).</p><p>Whether threshold dot-depth one languages with additional positional modular counting do correspond exactly to the languages in L(QDA)∩L(Q(J * D)) seems to be a challenging question, that we leave open. In his Ph.D. thesis <ref type="bibr" target="#b7">[7]</ref>, the author proved that all strongly unambiguous monomials (the basic building blocks in L(DA)) that are imposed to belong to L(J * D) at the same time are in fact threshold dot-depth one languages. However, the proof looks much too complex and technical to be extended to, say, all languages in L(DA) ∩ L(J * D). New techniques are probably needed, and we might conclude by saying that proving (or disproving) this conjecture could be a nice research goal in algebraic automata theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Missing Proofs from Section 3</head><p>A.1 Proof of Proposition 3.1</p><p>Upper bound. We start with the upper bound. Given k ∈ N, we define the alphabet Y k = {e, #} ∪ {⊥ l , l | l ∈ [k]}; we are going to prove that for all k ∈ N there exists a language Z k ∈ PT 2k+1 (Y * k ) such that for all ∆ = (σ n ) n∈N sequences of k-selectors, there exists a program-reduction from L ∆ to Z k of length at most 2 • (k + 1) -k • n k+1 . To this end, we use the following proposition and the fact that the language of words of length n ∈ N of L ∆ is exactly K n ,σ n when there exists n ∈ N verifying n = (k + 1) • n and ∅ otherwise.</p><formula xml:id="formula_22">Proposition A.1. For all k ∈ N there is a language Z k ∈ PT 2k+1 (Y * k ) such that ε /</formula><p>∈ Z k and for all n ∈ N and all k-selectors σ n over n, we have</p><formula xml:id="formula_23">K n,σn = Ψ -1 (k+1)•n,σn (Z =|Ψ (k+1)•n,σn | k ) where Ψ (k+1)•n,σn is a Y k -program on {0, 1} (k+1)•n of length at most 2 • (k + 1) • n k+1 .</formula><p>Proof. We first define by induction on k a family of languages</p><formula xml:id="formula_24">Z k over the alphabet Y k . For k = 0, set Z 0 = Y * 0 #Y * 0 .</formula><p>For k ∈ N &gt;0 , the language Z k is the set of words containing each of k and ⊥ k exactly once, the first before the latter, and verifying that the factor between the occurrence of k and the occurrence of</p><formula xml:id="formula_25">⊥ k belongs to Z k-1 , i.e. Z k = Y * k-1 k Z k-1 ⊥ k Y * k-1 . A simple induction on k shows that Z k for k ∈ N is defined by the expression Y * k-1 k Y * k-2 k-1 • • • Y * 1 2 Y * 0 1 Y * 0 #Y * 0 ⊥ 1 Y * 0 ⊥ 2 Y * 1 • • • ⊥ k-1 Y * k-2 ⊥ k Y * k-1 ,</formula><p>hence it belongs to PT 2k+1 (Y * k ) and in particular does not contain the empty word ε.</p><p>Fix n ∈ N. If n = 0, the proposition follows trivially since for any k-selector σ 0 over 0, we have K 0,σ0 = ∅ and ε / ∈ Z k ; otherwise, we define by induction on k a Y k -program P k (d, σ) on {0, 1} (d+k+1)•n for every k-selector σ over n and every d ∈ N.</p><p>For any j ∈ [n] and σ a 0-selector over n, which is just a function in P([n]) {ε} , let h j,σ : {0, 1} → Y 0 be the function defined by h j,σ (0) = e and h j,σ (1) = # if j ∈ σ(ε) e otherwise . For all k ∈ N &gt;0 , we also let f k and g k be the functions in</p><formula xml:id="formula_26">Y k {0,1} defined by f k (0) = g k (0) = e, f k (1) = k and g k (1) = ⊥ k .</formula><p>Moreover, for any k-selector σ over n, the symbol σ|j for j ∈ [n] denotes the (k -1)selector over n such that for all ρ ∈ [n] k-1 , we have i ∈ σ|j(ρ ) if and only if i ∈ σ((j, ρ )).</p><p>For k ∈ N &gt;0 , for d ∈ N and σ a k-selector over n, the Y k -program P k (d, σ) on {0, 1} (d+k+1)•n is the following sequence of instructions:</p><formula xml:id="formula_27">(d • n + 1, f k )P k-1 (d + 1, σ|1)(d • n + 1, g k ) • • •(d • n + n, f k )P k-1 (d + 1, σ|n)(d • n + n, g k ) .</formula><p>In words, for each position</p><formula xml:id="formula_28">i ∈ [[d • n + 1, d • n + n]</formula><p>] with a 1 in the (d + 1)-th block of n letters in the input, the program runs, between the symbols k and ⊥ k , the program P k-1 (d + 1, σ|i) obtained by induction for σ|i the (k -1)-selector over n obtained by restricting σ to all vectors in [n] k whose first coordinate is i.</p><p>For k = 0, for d ∈ N and σ a 0-selector over n, the Y 0 -program P 0 (d, σ) on {0, 1} (d+1)•n is the following sequence of instructions:</p><formula xml:id="formula_29">(d • n + 1, h 1,σ )(d • n + 2, h 2,σ ) • • • (d • n + n, h n,σ ) .</formula><p>In words, for each position</p><formula xml:id="formula_30">i ∈ [[d • n + 1, d • n + n]</formula><p>] with a 1 in the (d + 1)-th block of n letters in the input, the program outputs # if and only if (i -d • n) does belong to the set σ(ε).</p><p>In short, P k (d, σ) is designed so that for any w ∈ {0, 1} (d+k+1)•n , the word P k (d, σ)(w) belongs to Z k if and only if the last (k + 1) • n letters of w form a word of K n,σ .</p><p>A simple computation shows that for any k ∈ N, any d ∈ N and σ a k-selector over n, the number of instructions in</p><formula xml:id="formula_31">P k (d, σ) is at most 2 • (k + 1) • n k+1 .</formula><p>A simple induction on k shows that for any k ∈ N and d ∈ N, when running on a word w ∈ {0, 1} (d+k+1)•n , for any σ a k-selector over n, the program P k (d, σ) returns a word in Z k if and only if when u (1) , u (2) , . . . , u (k) , v are the last k + 1 consecutive blocks of n letters of w, then u (1) , u (2) , . . . , u (k) each contain 1 exactly once and define the vector ρ in [n] k where for all i ∈ [k], the value ρ i is given by the position of the only 1 in u (i) , verifying that there exists j ∈ σ n (ρ) such that v j is 1.</p><p>Therefore, for any k ∈ N and σ n a k-selector over n, if we set</p><formula xml:id="formula_32">Ψ (k+1)•n,σn = P k (0, σ n ), we have K n,σn = Ψ -1 (k+1)•n,σn (Z =|Ψ (k+1)•n,σn | k ) where Ψ (k+1)•n,σn is a Y k -program on {0, 1} (k+1)•n of length at most 2 • (k + 1) • n k+1 .</formula><p>Consequently, for all k ∈ N and any sequence of k-selectors ∆, since the language Z k is in PT 2k+1 (Y * k ) and thus recognised by a monoid from J 2k+1 , we have, by Proposition 2.2, that L ∆ ∈ P J 2k+1 , n k+1 . Lower bound. For the lower bound, we use the following claim, whose proof can be found in [8, <ref type="bibr">Claim 10]</ref>.</p><p>Claim A.2. For all i ∈ N &gt;0 and n ∈ N, the number of languages in {0, 1} n recognised by programs over a monoid of order i on {0, 1} n , with at most l ∈ N instructions, is upper-bounded by i</p><formula xml:id="formula_33">i 2 2 i • (n • i 2 ) l .</formula><p>If for some k ∈ N and i ∈ [α] with α ∈ N &gt;0 , we apply this claim for all n ∈ N and l = α • ((k + 1) • n) k , we get a number µ i (n) of languages in {0, 1} (k+1)•n recognised by programs over a monoid of order i on {0, 1} (k+1)•n with at most l instructions that is in 2 O(n k log 2 (n)) , which is asymptotically strictly smaller than the number of distinct K n,σn when the k-selector σ n over n varies, which is</p><formula xml:id="formula_34">2 n k+1 , i.e. µ i (n) is in o(2 n k+1 ).</formula><p>Hence, for all j ∈ N &gt;0 , there exist an n j ∈ N and τ j a k-selector over n j such that no program over a monoid of order i ∈ [j] on {0, 1} (k+1)•nj and of length at most j • ((k + 1) • n j ) k recognises K nj ,τj . Moreover, we can assume without loss of generality that the sequence (n j ) j∈N&gt;0 is increasing. Let ∆ = (σ n ) n∈N be such that σ nj = τ j for all j ∈ N &gt;0 and σ n : [n] k → P([n]), ρ → ∅ for any n ∈ N verifying that it is not equal to any n j for j ∈ N &gt;0 . We show that no sequence of programs over a finite monoid of length O(n k ) can recognise L ∆ . If this were the case, then let i be the order of the monoid. Let j ∈ N, j ≥ i be such that for any n ∈ N, the n-th program has length at most j • n k . But, by construction, we know that there does not exist any such program on {0, 1} (k+1)•nj recognising K nj ,τj , a contradiction. This implies that for all k ∈ N, we have P J, n k ⊂ P J, n k+1 and additionally that for all d ∈ N, d ≤ k 2 -1, we have P J k , n d ⊂ P J k , n d+1 , since any monoid from J d is also a monoid from J k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Proof of Proposition 3.2</head><p>Actually, the equivalent shorter program we give is even a subprogram of the original one, i.e. a subsequence of the latter. For P some program over a finite monoid M , we may denote by ξ P the function that associates to each possible input word w the word in M |P | obtained by successively evaluating the instructions of P for w.</p><p>Observe that given P a program over some finite monoid M on Σ n for n ∈ N and Σ an alphabet, a subprogram P of P is equivalent to P if and only if for every language K ⊆ M * recognised by the evaluation morphism η M of M , the unique morphism from M * to M extending the identity on M , we have ξ P (w) ∈ K ⇔ ξ P (w) ∈ K for all w ∈ Σ n . Moreover, every language recognised by η M is precisely a language of PT k (M * ) when M ∈ J k for some k N.</p><p>The result is hence a consequence of the following lemma and the fact that every language in PT k (M * ) is a union of ∼ k -classes, each of those classes corresponding to all words over M having the same set of k-subwords, that is finite.</p><p>Lemma A.3. Let Σ be an alphabet and M a finite monoid.</p><p>For all k ∈ N, there exists a constant c ∈ N &gt;0 verifying that for any program P over M on Σ n for n ∈ N and any word t ∈ M k , there exists a subprogram Q of P of length at most c • n k/2 such that for any subprogram Q of P that has Q as a subprogram, we have that t is a subword of ξ P (w) if and only if t is a subword of ξ Q (w) for all w ∈ Σ n .</p><p>Proof. A program P over M on Σ n for n ∈ N is a finite sequence (p i , f i ) of instructions where each p i is a positive natural number which is at most n and each f i is a function from Σ to M . We denote by l the number of instructions of P . For each set I ⊆ [l] we denote by P [I] the subprogram of P consisting of the subsequence of instructions of P obtained after removing all instructions whose index is not in I. When I = [[i, j]] for some i, j ∈ [l], we may write</p><formula xml:id="formula_35">P [i, j] instead of P [I].</formula><p>We prove the lemma by induction on k, fixing the constant to be</p><formula xml:id="formula_36">c k = k! • |Σ| k/2</formula><p>for a given k ∈ N. The intuition behind the proof for a program P on inputs of length n and some t of length at least 3 is as follows. Given l the length of P , we will select a subset I of the indices of instructions numbered from 1 to l to obtain P [I] verifying the conditions of the lemma. Consider all the indices 1 ≤ i 1 &lt; i 2 &lt; • • • &lt; i s ≤ l that each correspond, for some letter a and some position p in the input, to the first instruction of P that would output the element t 1 when reading a at position p or to the last instruction of P that would output the element t k when reading a at position p. We then have that, given some w as input, t is a subword of ξ P (w) if and only if there exist 1 ≤ γ &lt; δ ≤ s verifying that the element at position i γ of ξ P (w) is t 1 , the element at position i δ of ξ P (w)</p><formula xml:id="formula_37">is t k and t 2 • • • t k-1 is a subword of ξ P [iγ +1,i δ -1] (w).</formula><p>The idea is then that if we set I to contain i 1 , i 2 , . . . , i s as well as all indices obtained by induction for P [i j + 1, i j+1 -1] and t α • • • t β for all 1 ≤ j ≤ s -1 and 1 &lt; α ≤ β &lt; k, we would have that for all w, the word t is a subword of ξ P (w) if and only if it is a subword of ξ P [I] (w), that is ξ P (w) where only the elements at indices in I have been kept. The length upper bound of the order of n k/2 would be met because the number of possible values for j is s -1, hence at most linear in n, and the number of possible values for (α, β) is quadratic in k, a constant.</p><p>The intuition behind the proof when t is of length less than 3 is essentially the same, but without induction.</p><p>Inductive step. Let k ∈ N, k ≥ 3 and assume the lemma proven for all k ∈ N, k &lt; k. Let P be a program over M on Σ n for n ∈ N of length l ∈ N and some word t ∈ M k .</p><p>Observe that when n = 0, we necessarily have P = ε, so that the lemma is trivially proven in that case. So we now assume n &gt; 0.</p><p>For each p ∈ [n] and each a ∈ Σ consider within the sequence of instructions of P the first instruction of the form (p, f ) with f (a) = t 1 and the last instruction of that form with f (a) = t k , if they exist. We let I (1,k) be the set of indices of these instructions for all a and p. Notice that the size of</p><formula xml:id="formula_38">I (1,k) is at most 2 • |Σ| • n.</formula><p>Let s = I (1,k) and let us denote</p><formula xml:id="formula_39">I (1,k) = {i 1 , i 2 , . . . , i s } where i 1 &lt; i 2 &lt; • • • &lt; i s . Given α, β ∈ [k], we also set t (α,β) = t α t α+1 • • • t β . For all α, β ∈ [k] such that 1 &lt; α ≤ β &lt; k and j ∈ [s -1]</formula><p>, we let J j,(α,β) be the set of indices of the instructions within P [i j + 1, i j+1 -1] appearing in its subprogram obtained by induction for P [i j + 1, i j+1 -1] and t (α,β) .</p><p>We now let I be the union of I (1,k) and J j,(α,β) = {e + i j | e ∈ J j,(α,β) } for all α, β ∈ [k] such that 1 &lt; α ≤ β &lt; k and j ∈ [s -1] (the translation being required because the first instruction in P [i j + 1, i j+1 -1] is the (i j + 1)-th instruction in P ). We claim that Q = P [I], a subprogram of P , has the desired properties.</p><p>First notice that by induction the size of J j,(α,β) for all α, β ∈</p><formula xml:id="formula_40">[k] such that 1 &lt; α ≤ β &lt; k and j ∈ [s -1] is upper bounded by (β -α + 1)! • |Σ| (β-α+1)/2 • n (β-α+1)/2 ≤ (k -2)! • |Σ| (k-2)/2 • n (k-2)/2 .</formula><p>Hence, the size of I is at most</p><formula xml:id="formula_41">I (1,k) + s-1 j=1 1&lt;α≤β&lt;k J j,(α,β) ≤2 • |Σ| • n + (2 • |Σ| • n -1) • (k -1) • (k -2) 2 • (k -2)! • |Σ| (k-2)/2 • n (k-2)/2 ≤2 • |Σ| • n + (2 • |Σ| • n -1) • k • (k -1) 2 • (k -2)! • |Σ| (k-2)/2 • n (k-2)/2 ≤k! • |Σ| k/2 • n k/2 = c k • n k/2 as {(α, β) ∈ N 2 | 1 &lt; α ≤ β &lt; k} = k-1 j=2 (k -j) = k-2 j=1 j = (k-1)•(k-2) 2 and 2 • |Σ| • n ≤ k! 2 • |Σ| (k-2)/2</formula><p>• n (k-2)/2 since k ≥ 3, so that P [I] has at most the required length.</p><p>Let Q be a subprogram of P that has Q as a subprogram: it means that there exists some set</p><formula xml:id="formula_42">I ⊆ [l] containing I such that Q = P [I ].</formula><p>Take w ∈ Σ n . Assume now that t is a subword of ξ P (w). It means that there exist r 1 , r 2 , . . . ,</p><formula xml:id="formula_43">r k ∈ [l], r 1 &lt; r 2 &lt; • • • &lt; r k , such that for all j ∈ [k], we have f rj (w pr j ) = t j . By definition of I (1,k) , there exist γ, δ ∈ [s], γ &lt; δ, such that i γ ≤ r 1 &lt; r k ≤ i δ and f iγ (w pi γ ) = t 1 and f i δ (w pi δ ) = t k . For each j ∈ [[γ, δ -1]], let m j ∈ [[2, k]] be the smallest integer in [[2, k -1]</formula><p>] such that i j ≤ r mj &lt; i j+1 and k if it does not exist, and</p><formula xml:id="formula_44">M j ∈ [[1, k -1]] be the biggest integer in [[2, k -1]] such that i j ≤ r Mj &lt; i j+1 and 1 if it does not exist. Observe that, since for each j ∈ [[γ, δ -1]], we have t (mj ,Mj ) = t (k,1) = ε if there does not exist any o ∈ [[2, k -1]] verifying i j ≤ r o &lt; i j+1 , it holds that t (2,k-1) = δ-1 j=γ t (mj ,Mj ) . For all j ∈ [[γ, δ -1]],</formula><p>we have that for any set J ⊆ [i j+1 -i j -1] containing 1&lt;α≤β&lt;k J j,(α,β) , the word t (mj ,Mj ) is a subword of f ij (w pi j )ξ P [ij +1,ij+1-1][J] (w) when m j &lt; k and r mj = i j , and of ξ</p><formula xml:id="formula_45">P [ij +1,ij+1-1][J] (w) otherwise. Indeed, let j ∈ [[γ, δ -1]].</formula><p>• If m j &lt; k and r mj = i j , then f ij (w pi j ) = f rm j (w pr m j ) = t mj and</p><formula xml:id="formula_46">i j = r mj &lt; r mj +1 &lt; • • • &lt; r Mj &lt; i j+1 , so t (mj +1,Mj ) is a subword of ξ P [ij +1,ij+1-1] (w).</formula><p>This implies, directly when m j = M j or by induction otherwise, that for any set J ⊆ [i j+1 -i j -1] containing 1&lt;α≤β&lt;k J j,(α,β) , the word</p><formula xml:id="formula_47">t (mj +1,Mj ) is a subword of ξ P [ij +1,ij+1-1][J] (w). This implies in turn that t (mj ,Mj ) is a subword of f ij (w pi j )ξ P [ij +1,ij+1-1][J] (w).</formula><p>• Otherwise, when</p><formula xml:id="formula_48">m j = k, there does not exist any o ∈ [[2, k -1]] verifying i j ≤ r o &lt; i j+1 , so t (mj ,Mj ) = ε is trivially a subword of ξ P [ij +1,ij+1-1][J] (w)</formula><p>for any set J ⊆ [i j+1 -i j -1] containing 1&lt;α≤β&lt;k J j,(α,β) . And when m j &lt; k but r mj = i j , it means that r mj &gt; i j , hence i j &lt; r mj &lt; r mj +1 &lt; • • • &lt; r Mj &lt; i j+1 , so t (mj ,Mj ) is a subword of ξ P [ij +1,ij+1-1] (w). This implies, by induction, that t (mj ,Mj ) is a subword of ξ P [ij +1,ij+1-1][J] (w) for any set J ⊆ [i j+1 -i j -1] containing 1&lt;α≤β&lt;k J j,(α,β) .</p><p>Therefore, using the convention that i 0 = 0 and i s+1 = l + 1, if we define, for each j ∈ [[0, s]], the set I j = {e -i j | e ∈ I , i j &lt; e &lt; i j+1 } as the subset of I of elements strictly between i j and i j+1 translated by -i j , we have that t (2,k-1) is a subword of</p><formula xml:id="formula_49">ξ P [iγ +1,iγ+1-1][I γ ] (w)f iγ+1 (w pi γ+1 )ξ P [iγ+1+1,iγ+2-1][I γ+1 ] (w) • • • f i δ-1 (w pi δ-1 )ξ P [i δ-1 +1,i δ -1][I δ-1 ] (w) (since we have r mγ ≥ r 2 &gt; r 1 ≥ i γ ), so that, as f iγ (w pi γ ) = t 1 and f i δ (w pi δ ) = t k , we have that t = t 1 t (2,k-1) t k is a subword of ξ P [1,i1-1][I 0 ] (w)f i1 (w pi 1 )ξ P [i1+1,i2-1][I 1 ] (w) • • • f is (w pi s )ξ P [is+1,l][I s ] (w) =ξ P [I ] (w) .</formula><p>Assume finally that t is a subword of ξ P [I ] (w). Then it is obviously a subword of ξ P (w), as ξ P [I ] (w) is a subword of ξ P (w).</p><p>Therefore, t is a subword of ξ P (w) if and only if t is a subword of ξ Q (w) = ξ P [I ] (w), as desired.</p><p>Base case. There are three subcases to consider.</p><p>Subcase k = 2. Let P be a program over M on Σ n for n ∈ N of length l ∈ N and some word t ∈ M 2 .</p><p>We use the same idea as in the inductive step.</p><p>Observe that when n = 0, we necessarily have P = ε, so that the lemma is trivially proven in that case. So we now assume n &gt; 0.</p><p>For each p ∈ [n] and each a ∈ Σ consider within the sequence of instructions of P the first instruction of the form (p, f ) with f (a) = t 1 and the last instruction of that form with f (a) = t 2 , if they exist. We let I be the set of indices of these instructions for all a and p. Notice that the size of</p><formula xml:id="formula_50">I is at most 2 • |Σ| • n = 2! • |Σ| 2/2 • n 2/2 = c 2 • n 2/2</formula><p>. We claim that Q = P [I], a subprogram of P , has the desired properties. We just showed it has at most the required length.</p><p>Let Q be a subprogram of P that has Q as a subprogram: it means that there exists some set</p><formula xml:id="formula_51">I ⊆ [l] containing I such that Q = P [I ].</formula><p>Take w ∈ Σ n . Assume now that t is a subword of ξ P (w). It means there exist</p><formula xml:id="formula_52">i 1 , i 2 ∈ [l], i 1 &lt; i 2 such that f i1 (w pi 1 ) = t 1 and f i2 (w pi 2 ) = t 2 . By definition of I, there exist i 1 , i 2 ∈ I, such that i 1 ≤ i 1 &lt; i 2 ≤ i 2 and f i1 (w p i 1 ) = t 1 and f i2 (w p i 2 ) = t 2 . Hence, as f i1 (w p i 1 )f i2 (w p i 2 ) is a subword of ξ P [I ] (w) (because I ⊆ I ), we get that t = t 1 t 2 is a subword of ξ P [I ] (w).</formula><p>Assume finally that t is a subword of ξ P [I ] (w). Then it is obviously a subword of ξ P (w), as ξ P [I ] (w) is a subword of ξ P (w).</p><p>Therefore, t is a subword of ξ P (w) if and only if t is a subword of ξ Q (w) = ξ P [I ] (w), as desired.</p><p>Subcase k = 1. Let P be a program over M on Σ n for n ∈ N of length l ∈ N and some word t ∈ M 1 .</p><p>We again use the same idea as before.</p><p>Observe that when n = 0, we necessarily have P = ε, so that the lemma is trivially proven in that case. So we now assume n &gt; 0.</p><p>For each p ∈ [n] and each a ∈ Σ consider within the sequence of instructions of P the first instruction of the form (p, f ) with f (a) = t 1 , if it exists. We let I be the set of indices of these instructions for all a and p. Notice that the size of</p><formula xml:id="formula_53">I is at most |Σ| • n = 1! • |Σ| 1/2 • n 1/2 = c 1 • n 1/2</formula><p>. We claim that Q = P [I], a subprogram of P , has the desired properties. We just showed it has at most the required length.</p><p>Let Q be a subprogram of P that has Q as a subprogram: it means that there exists some set</p><formula xml:id="formula_54">I ⊆ [l] containing I such that Q = P [I ].</formula><p>Take w ∈ Σ n . Assume now that t is a subword of ξ P (w). It means there exists i ∈ [l] such that f i (w pi ) = t 1 . By definition of I, there exists i ∈ I such that i ≤ i and</p><formula xml:id="formula_55">f i (w p i ) = t 1 . Hence, as f i (w p i ) is a subword of ξ P [I ] (w) (because I ⊆ I), we get that t = t 1 is a subword of ξ P [I ] (w).</formula><p>Assume finally that t is a subword of ξ P [I ] (w). Then it is obviously a subword of ξ P (w), as ξ P [I ] (w) is a subword of ξ P (w).</p><p>Therefore, t is a subword of ξ P (w) if and only if t is a subword of ξ Q (w) = ξ P [I ] (w), as desired.</p><p>Subcase k = 0. Let P be a program over M on Σ n for n ∈ N of length l ∈ N and some word t ∈ M 0 . of caa, cba and cca is a subword of Ψ n (w), in both cases contradicting the fact Ψ n (w) belongs to L. Hence, we indeed have j = i -1, and in particular that i ≥ 2. Now, by construction, for each t ∈ [i -2], we have that w t w i w i-1 = w t ca is a subword of Ψ n (w) ∈ L, so that w t cannot be equal to c. Similarly, for each t ∈ [[i + 1, n]], we have that w i w i-1 w t = caw t is a subword of Ψ n (w) ∈ L, so that w t must be equal to c. This means that w</p><formula xml:id="formula_56">1 • • • w i-2 ∈ (a + b) * and w i+1 • • • w n ∈ c * , so that w ∈ (a + b) * acc * = (a + b) * ac + . Since this is true for all w ∈ Ψ -1 n (L =s(n) ), it follows that ((a + b) * ac + ) =n ⊇ Ψ -1 n (L =s(n) ). Therefore, we have that ((a + b) * ac + ) =n = Ψ -1 n (L =s(n) ) for all n ∈ N, so (Ψ n ) n∈N is a program reduction from (a + b) * ac + to L of length s(n). So since L ∈ L(J), we can conclude that (a + b) * ac + ∈ P(J, s(n)) = P(J, n) by Proposition 2.2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Proof of Lemma 4.9</head><p>Proof of Lemma 4.9. Let Σ be an alphabet and l ∈ N &gt;0 . We prove it by induction on k ∈ N &gt;0 .</p><formula xml:id="formula_57">Base case k = 1. Let u 1 ∈ Σ + such that the letters in u 1 are all distinct. It is clear that q1∈{1,l} L (l) (u1,q1) =(Σ * u 1 Σ * ∪ u 1 l ¡ Σ * ) = l-1 α1=1 u 1 α1 ¡ Σ * ∩ (u 1 α1+1 ¡ Σ * ) ∩ Σ * u 1 Σ * ∪ (u 1 l ¡ Σ * ) = α1∈[l] R α1 l (u 1 ) ∩ S α1 l (u 1 ) .</formula><p>Induction. Let k ∈ N &gt;0 and assume that for all u 1 , . . . , u k ∈ Σ + such that for each i ∈ [k], the letters in u i are all distinct, we have q1,...,q k ∈{1,l}</p><formula xml:id="formula_58">L (l) (u1,q1) • • • L (l) (u k ,q k ) = α∈[l] k R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) . Let now u 1 , . . . , u k+1 ∈ Σ + such that for each i ∈ [k + 1], the letters in u i are all distinct. Right-to-left inclusion. Let w ∈ α∈[l] k+1 R α l (u 1 , . . . , u k+1 ) ∩ S α l (u 1 , . . . , u k+1 ) .</formula><p>Let α ∈ [l] k+1 witnessing this fact. As w ∈ R α l (u 1 , . . . , u k+1 ), we can decompose it as w = xy where x ∈ (u</p><formula xml:id="formula_59">1 α1 • • • u k α k ) ¡ Σ * and y ∈ u k+1 α k+1 ¡ Σ * with</formula><p>|y| being minimal. What we are going to do is, on the one hand, to prove that x ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) where α = (α 1 , . . . , α k ), so that we can apply the inductive hypothesis on x and get that there exist q 1 , . . . , q k ∈ {1, l}</p><formula xml:id="formula_60">such that x ∈ L (l) (u1,q1) • • • L (l) (u k ,q k )</formula><p>; and, on the other hand, we are going to prove that there exists q k+1 ∈ {1, l} verifying y ∈ L (l) (u k+1 ,q k+1 ) . We now spell out the details.</p><p>For</p><formula xml:id="formula_61">each i ∈ [k], α i &lt; l, we have x / ∈ (u 1 α1 • • • u i αi+1 • • • u k α k )¡Σ * , otherwise we would have w = xy ∈ (u 1 α1 • • • u i αi+1 • • • u k+1 α k+1 ) ¡ Σ * . Also, for all i ∈ [k], α i &lt; l, we have that x ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * , otherwise it would mean that y = y 1 y 2 with |y 1 | &gt; 0, that xy 1 ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * and y 2 ∈ u k+1 α k+1 ¡ Σ * , contra- dicting the minimality of |y|. So x ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k )</formula><p>, which means by inductive hypothesis that there exist q 1 , . . . , q k ∈ {1, l} such that</p><formula xml:id="formula_62">x ∈ L (l) (u1,q1) • • • L (l) (u k ,q k ) . Remember now that the letters in u k+1 are all distinct. If α k+1 &lt; l, since w ∈ (u 1 α1 . . . u k α k ) ¡ Σ * u k+1 Σ * , we must have y ∈ Σ * u k+1 Σ * .</formula><p>Indeed, by minimality of |y|, the word y starts with the first letter of u k+1 , which has pairwise distinct letters, so that u k+1 cannot appear as a factor of xy partly in x and partly in y; so if it were the case that y does not contain u k+1 as a factor, we would have</p><formula xml:id="formula_63">x ∈ (u 1 α1 . . . u k α k ) ¡ Σ * u k+1 Σ * , so that xy = w ∈ (u 1 α1 . . . u k α k u k+1 α k+1 +1</formula><p>) ¡ Σ * , a contradiction with the hypothesis on w.</p><formula xml:id="formula_64">Hence, y ∈ L (l) (u k+1 ,α k+1 ) . If α k+1 = l, then y ∈ u k+1 α k+1 ¡ Σ * = L (l) (u k+1 ,α k+1 ) .</formula><p>So, if we set q k+1 = 1 if α k+1 &lt; l l otherwise , then we get that y ∈ L</p><p>(u k+1 ,q k+1 ) .</p><p>We can conclude that</p><formula xml:id="formula_66">w = xy ∈ L (l) (u1,q1) • • • L (l) (u k ,q k ) L (l) (u k+1 ,q k+1 ) . Left-to-right inclusion. Let w ∈ q1,...,q k+1 ∈{1,l} L (l) (u1,q1) • • • L (l) (u k+1 ,q k+1 )</formula><p>. The rough idea of our proof here is to take (u 1 , . . . , u k+1 ) by distinguishing between the case in which α k+1 = l and the case in which α k+1 &lt; l. The first one is easy to handle, the second one is much trickier.</p><formula xml:id="formula_67">α k+1 ∈ [l] the biggest integer in [l] such that w ∈ q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) ) (u k+1 α k+1 ¡ Σ * )</formula><p>We now spell out the details.</p><p>• Suppose we have w ∈ q1,...,q k ∈{1,l}</p><formula xml:id="formula_68">L (l) (u1,q1) • • • L (l) (u k ,q k ) L (l) (u k+1 ,l) = q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) (u k+1 l ¡ Σ * ) .</formula><p>Then w can be decomposed as w = xy where x ∈ q1,...,q k ∈{1,l} L</p><formula xml:id="formula_69">(l) (u1,q1) • • • L (l) (u k ,q k )</formula><p>and y ∈ u k+1 l ¡Σ * with |y| being minimal. So by inductive hypothesis, there exists α ∈ [l] k such that x ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ). Observe that this means we have w ∈ (u</p><formula xml:id="formula_70">1 α1 • • • u k α k u k+1 l ) ¡ Σ * and for each i ∈ [k], α i &lt; l, that w / ∈ (u 1 α1 • • • u i αi+1 • • • u k α k u k+1 l ) ¡ Σ * , other- wise it would mean that x ∈ (u 1 α1 • • • u i αi+1 • • • u k α k ) ¡Σ * by minimality of |y|.</formula><p>Similarly, for all i ∈ [k], α i &lt; l, it is obvious that we have (u 1 , . . . , u k+1 ).</p><formula xml:id="formula_71">w = xy ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k u k+1 l ) ¡ Σ * as x ∈ (u 1 α1 • • • u i-1 αi-1 )¡Σ * u i (u i+1 αi+1 • • • u k α k )</formula><p>• Or we have w / ∈ q1,...,q k ∈{1,l} 1) .</p><formula xml:id="formula_72">L (l) (u1,q1) • • • L (l) (u k ,q k ) L (l) (u k+1 ,l) = q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) (u k+1 l ¡ Σ * ) but w ∈ q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) L (l) (u k+1 ,</formula><p>Let</p><formula xml:id="formula_73">α k+1 ∈ [l -1] be the biggest integer in [l -1] such that w ∈ q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) (u k+1 α k+1 ¡ Σ * )</formula><p>which does exist by hypothesis. We can decompose w as w = xy where x ∈ q1,...,q k ∈{1,l} L (u 1 , . . . , u k+1 ) .</p><formula xml:id="formula_74">(l) (u1,q1) • • • L (l) (u k ,q k ) and y ∈ u k+1 α k+1 ¡ Σ * with |y|</formula><p>Among the obvious things to observe is that we have w ∈ (u</p><formula xml:id="formula_75">1 α1 • • • u k α k u k+1 α k+1 ) ¡ Σ * and for each i ∈ [k], α i &lt; l, that w / ∈ (u 1 α1 • • • u i αi+1 • • • u k α k u k+1 α k+1 ) ¡ Σ * , otherwise it would mean that x ∈ (u 1 α1 • • • u i αi+1 • • • u k α k ) ¡ Σ * by min- imality of |y|.</formula><p>Similarly, for all i ∈ [k], α i &lt; l, it is obvious that we have</p><formula xml:id="formula_76">w = xy ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k u k+1 α k+1 ) ¡ Σ * because x ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * and y ∈ u k+1 α k+1 ¡ Σ * .</formula><p>Now let us show that we have y ∈ Σ * u k+1 Σ * . Assume it weren't the case: the letters in u k+1 are pairwise distinct and moreover y starts with the first letter of u k+1 by minimality of |y|, so u k+1 cannot appear as a factor of xy partly in x and partly in y and, additionally, w ∈ q1,...,q k ∈{1,l}</p><formula xml:id="formula_77">L (l) (u1,q1) • • • L (l) (u k ,q k ) L (l) (u k+1 ,1) = q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) Σ * u k+1 Σ * , so we would have x ∈ ( q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l)</formula><p>(u k ,q k ) )Σ * u k+1 Σ * . But this either contradicts the maximality of α k+1 or the fact that w / ∈ q1,...,q k ∈{1,l}</p><formula xml:id="formula_78">L (l) (u1,q1) • • • L (l) (u k ,q k ) (u k+1 l ¡ Σ * ) .</formula><p>Thus, we have w = xy ∈ (u</p><formula xml:id="formula_79">1 α1 • • • u k α k ) ¡ Σ * u k+1 Σ * as x ∈ (u 1 α1 • • • u k α k ) ¡ Σ * .</formula><p>Let us finish with the trickiest part, namely showing that w / ∈ (u</p><formula xml:id="formula_80">1 α1 • • • u k α k u k+1 α k+1 +1 ) ¡Σ * . Assume that w ∈ (u 1 α1 • • • u k α k u k+1 α k+1 +1 ) ¡Σ * .</formula><p>We then have that x ∈ (u</p><formula xml:id="formula_81">1 α1 • • • u k α k u k+1 ) ¡ Σ * , otherwise it would mean that y = y 1 y 2 with |y 1 | &gt; 0, with xy 1 ∈ (u 1 α1 • • • u k α k u k+1 ) ¡</formula><p>Σ * and y 2 ∈ u k+1 α k+1 ¡ Σ * , contradicting the minimality of |y|. We can decompose x as x = x 1 x 2 where</p><formula xml:id="formula_82">x 1 ∈ (u 1 α1 • • • u k α k ) ¡ Σ * and x 2 ∈ u k+1 ¡ Σ * with |x 2 | being minimal. We claim that, actually, x 1 ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ), so that by inductive hypothesis, x 1 ∈ q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) . But since x 2 y ∈ u k+1 α k+1 +1 ¡ Σ * , this means that w = x 1 x 2 y ∈ q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) (u k+1 α k+1 +1 ¡ Σ * ) ,</formula><p>contradicting the maximality of α k+1 or the fact that w / ∈ q1,...,q k ∈{1,l}</p><formula xml:id="formula_83">L (l) (u1,q1) • • • L (l) (u k ,q k ) (u k+1 l ¡ Σ * ) .</formula><p>So we can conclude that w / ∈ (u</p><formula xml:id="formula_84">1 α1 • • • u k α k u k+1 α k+1 +1 ) ¡ Σ * .</formula><p>The claim that x 1 ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) remains to be shown. We directly see that</p><formula xml:id="formula_85">x 1 / ∈ (u 1 α1 • • • u i αi+1 • • • u k α k )¡Σ * for all i ∈ [k], α i &lt; l, otherwise it would mean that x ∈ (u 1 α1 • • • u i αi+1 • • • u k α k ) ¡ Σ * . Let now i ∈ [k], α i &lt; l, and assume that x 1 / ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * . We can decompose x 1 as x 1 = x 1,1 x 1,2 where x 1,1 ∈ (u 1 α1 • • • u i αi ) ¡ Σ * and x 1,2 ∈ (u i+1 αi+1 • • • u k α k ) ¡ Σ * with |x 1,1 |</formula><p>being minimal. By hypothesis, we have</p><formula xml:id="formula_86">x 1,1 / ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡</formula><p>Σ * u i Σ * , otherwise we would have</p><formula xml:id="formula_87">x 1 = x 1,1 x 1,2 ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * .</formula><p>As previously, the letters in u i are pairwise distinct, and x 1,1 ends with the last letter of u i by minimality of |x 1,1 |, so u i cannot appear as a factor of x partly in x 1,1 and partly in x 1,2 x 2 . Thus, we have that</p><formula xml:id="formula_88">x 1,2 x 2 ∈ Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * because we know that x ∈ (u 1 α1 • • • u i-1 αi-1 )¡Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * . But this means that x = x 1,1 x 1,2 x 2 ∈ (u 1 α1 • • • u i αi+1 • • • u k α k ) ¡</formula><p>Σ * , a contradiction. Hence, we can deduce that for all i ∈</p><formula xml:id="formula_89">[k], α i &lt; l, we have x 1 ∈ (u 1 α1 • • • u i-1 αi-1 ) ¡Σ * u i (u i+1 αi+1 • • • u k α k ) ¡Σ * . This finishes to show that x 1 ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) .</formula><p>Putting all together, we indeed also have that</p><formula xml:id="formula_90">w ∈ R (α1,...,α k+1 ) l (u 1 , . . . , u k+1 ) ∩ S (α1,...,α k+1 ) l (u 1 , . . . , u k+1 )</formula><p>in the present case.</p><p>In conclusion, in both cases,</p><formula xml:id="formula_91">w ∈ α∈[l] k+1 R α l (u 1 , . . . , u k+1 ) ∩ S α l (u 1 , . . . , u k+1 ) .</formula><p>So we can finally conclude that q1,...,q k+1 ∈{1,l}</p><formula xml:id="formula_92">L (l) (u1,q1) • • • L (l) (u k+1 ,q k+1 ) = α∈[l] k+1 R α l (u 1 , . . . , u k+1 ) ∩ S α l (u 1 , . . . , u k+1 ) .</formula><p>This concludes the proof of the lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3 Proof of Lemma 4.10</head><p>Before proving Lemma 4.10, we need a useful decomposition lemma, that is straightforward to prove.</p><p>Lemma B.1. Let Σ be an alphabet and u ∈ Σ + . Then, for all α ∈ N &gt;0 , each</p><formula xml:id="formula_93">w ∈ u α ¡ Σ * ∩ (u α+1 ¡ Σ * ) verifies w = α i=1 |u| j=1 (v i,j u j ) y</formula><p>where v i,j ∈ (Σ \ {u j }) * for all i ∈ [α] and j ∈ [|u|], and y ∈</p><formula xml:id="formula_94">|u| i=1 i-1 j=1 (Σ \ {u j }) * u j (Σ \ {u i }) * .</formula><p>Proof. Let Σ be an alphabet and u ∈ Σ + . Take α ∈ N &gt;0 and w ∈ u α ¡ Σ * ∩ (u α+1 ¡ Σ * ) . As w ∈ u α ¡ Σ * , the word w can be decomposed as w = xy where x ∈ u α ¡ Σ * and |x| is minimal. Then, it is clearly necessarily the case that</p><formula xml:id="formula_95">x = α i=1 |u| j=1 (v i,j u j ) with v i,j ∈ (Σ \ {u j }) * for all i ∈ [α] and j ∈ [|u|]. Moreover, as xy / ∈ u α+1 ¡ Σ * , we necessarily have that y / ∈ u ¡ Σ * , so that there exists some i ∈ [|u|] verifying that u 1 • • • u i-1 is a subword of y but not u 1 • • • u i . Thus, we have that y ∈ i-1 j=1 (Σ \ {u j }) * u j (Σ \ {u i }) * . This concludes the proof.</formula><p>We can now prove Lemma 4.10.</p><p>Proof of Lemma 4.10. Let Σ be an alphabet and u ∈ Σ + such that its letters are all distinct. Let α ∈ N &gt;0 and x 1 , x 2 ∈ Σ * . We let</p><formula xml:id="formula_96">L = (x 1 u α x 2 ) ¡ Σ * ∩ (x 1 u α+1 x 2 ) ¡ Σ * ∩ (x 1 ¡ Σ * )u(x 2 ¡ Σ * ) .</formula><p>If |u| = 1, the lemma follows trivially because L is piecewise testable and hence belongs to L(J), so we assume |u| &gt; 1.</p><p>For each letter a ∈ Σ, we shall use 2 |u| -1 distinct decorated letters of the form a (i) for some i ∈ [[0, 2 |u| -2]], using the convention that a (0) = a; of course, for two distinct letters a, b ∈ Σ, we have that a (i) and b (j) are distinct for all i, j ∈ [[0, 2 |u| -2]]. We denote by A the alphabet of these decorated letters.</p><p>For each</p><formula xml:id="formula_97">i ∈ [[0, 2 |u| -2]], let f (i) : Σ → A a → a (i)</formula><p>.</p><p>For all i ∈ N, i ≥ |u|, we define</p><formula xml:id="formula_98">Φ i = (i, f (0) ) |u|-1 j=1 (i -j, f (j) ) |u| j=2 (i -|u| + j, f (|u|+j-2) ) .</formula><p>For all n ∈ N, n &lt; |u|, we define Ψ n = ε. For all n ∈ N, n ≥ |u|, we define</p><formula xml:id="formula_99">Ψ n = |u|-1 i=1 (i, f (0) ) n i=|u| Φ i .</formula><p>Finally, let K be the language of words over A having</p><formula xml:id="formula_100">ζ β = x 1 u β-1 u |u|-1 j=1 u (j) |u|-j |u| j=2 u (|u|+j-2) j u α-β x 2</formula><p>for some β ∈ [α] as a subword but not x 1 u α+1 x 2 .</p><p>Claim B.2. The sequence (Ψ n ) n∈N of A-programs is a program-reduction from L to K.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let</head><formula xml:id="formula_101">s : N → N n → 0 if n &lt; |u| |u| -1 + (n -|u| + 1) • (2 |u| -1) otherwise . It is direct to see that s(n) = |Ψ n | ≤ (2 |u| -1) • n for all n ∈ N.</formula><p>Therefore, using this claim, (Ψ n ) n∈N is a program-reduction from L to K of length s(n), so since K is piecewise testable and hence is recognised (classically) by some monoid from J, Proposition 2.2 tells us that L ∈ P(J, s(n)) = P(J, n).</p><formula xml:id="formula_102">Proof of claim. Let n ∈ N. If n &lt; |u|, then it is obvious that for all w ∈ Σ n , we have w / ∈ (x 1 ¡ Σ * )u(x 2 ¡ Σ * ) so w / ∈ L =n and also Ψ n (w) = ε / ∈ K =s(n) , hence L =n = ∅ = Ψ -1 n (K =s(n) ). Otherwise, n ≥ |u|. We are going to show that L =n = Ψ -1 n (K =s(n) ).</formula><p>Left-to-right inclusion. Let w ∈ L =n . We want to show that Ψ n (w) ∈ K =s(n) . We are first going to show that there exists some β ∈ [α] such that ζ β is a subword of Ψ n (w). The fact that w ∈ L =n means in particular that w ∈ j=1 (Σ \ {u j }) * u j (Σ \ {u i }) * . We know the letters in u are all distinct, so this means that there is no β ∈ [α -1] such that u is a factor of z partly in |u| j=1 (v β,j u j ) and partly in |u| j=1 (v β+1,j u j ), and that u cannot appear as a factor of z partly in |u| j=1 (v α,j u j ) and partly in y either. Hence, since z ∈ Σ * uΣ * , by the way we decomposed z, there necessarily exists β ∈</p><formula xml:id="formula_103">[α] such that |u| j=1 (v β,j u j ) ∈ Σ * uΣ * . Let γ, δ ∈ [n] such that w γ • • • w δ = |u| j=1 (v β,j u j ), w 1 • • • w γ-1 = y 1 β-1 i=1 |u| j=1 (v i,j u j ) and w δ+1 • • • w n = α i=β+1 |u| j=1 (v i,j u j ) yy 2 .</formula><p>By the way β is defined, we have w δ-|u|+1 • • • w δ = u, because δ is the first and only position in w with the letter</p><formula xml:id="formula_104">u |u| within the interval [[γ, δ]] verifying that w γ • • • w δ-1 contains u 1 • • • u |u|-1</formula><p>as a subword, and we observe additionally that δ ≥ γ + |u| -1 ≥ |u|. This means that</p><formula xml:id="formula_105">Φ δ (w) =f (0) (w δ )f (1) (w δ-1 ) • • • f (|u|-1) (w δ-|u|+1 )f (|u|) (w δ-|u|+2 ) • • • f (2|u|-2) (w δ ) =u |u| |u|-1 j=1 u (j) |u|-j |u| j=2 u (|u|+j-2) j . Moreover, γ-1 i=1 f (0) (w i ) = w 1 • • • w γ-1 = y 1 β-1 i=1 |u| j=1 (v i,j u j ) , δ-1 i=δ-|u|+1 f (0) (w i ) = w δ-|u|+1 • • • w δ-1 = u 1 • • • u |u|-1 and n i=δ+1 f (0) (w i ) = w δ+1 • • • w n = α i=β+1 |u| j=1 (v i,j u j ) yy 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>So as</head><formula xml:id="formula_106">γ-1 i=1 (i, f (0) ) δ-1 i=δ-|u|+1 (i, f (0) )Φ δ n i=δ+1 (i, f (0)</formula><p>) is a subword of Ψ n , we have that</p><formula xml:id="formula_107">ζ β = x 1 u β-1 u |u|-1 j=1 u (j) |u|-j |u| j=2 u (|u|+j-2) j u α-β x 2</formula><p>is a subword of Ψ n (w).</p><p>We secondly show that x 1 u α+1 x 2 cannot be a subword of Ψ n (w). But this is direct by construction of Ψ n , otherwise we would have that x 1 u α+1 x 2 is a subword of w, contradicting the fact that w ∈ L =n . Hence, Ψ n (w) ∈ K =s(n) , and since this is true for all w ∈ L =n , we have L =n ⊆ Ψ -1 n (K =s(n) ).</p><p>Right-to-left inclusion. We are going to prove the "contrapositive inclusion". Let w ∈ Σ n \ L =n . We want to show that Ψ n (w) / ∈ K =s(n) . Let us start with the easy cases. If we have w / ∈ (x 1 u α x 2 ) ¡ Σ * , then it means that x 1 u α x 2 is not a subword of w and hence, by construction of Ψ n , not a subword of Ψ n (w) either, so that there does not exist any β ∈ [α] such that ζ β is a subword of Ψ n (w). Similarly, if we have w ∈ (x 1 u α+1 x 2 ) ¡ Σ * , then it means that x 1 u α+1 x 2 is a subword of w and hence, by construction of Ψ n , a subword of Ψ n (w).</p><p>We now assume that w ∈ (x 1 u α x 2 ) ¡ Σ * ∩ (x 1 u α+1 x 2 ) ¡ Σ * while w / ∈ (x 1 ¡ Σ * )u(x 2 ¡ Σ * ). We want to show that in this case, there does not exist any β ∈ [α] such that ζ β is a subword of Ψ n (w). Suppose for a contradiction that such a β exists; our goal is to show, through a careful observation of what this implies on the letters in w by examining how Ψ n decorates the letters, that this contradictingly entails x 1 u α+1 x 2 is a subword of w.</p><p>Since ζ β is a subword of Ψ n (w), it is not too difficult to see there exist </p><formula xml:id="formula_108">)(q 1 , f (0) ) • • • (q |u| , f (0) ) (q |u|+1 , f (1) ) • • • (q 2|u|-1 , f (|u|-1) )(q 2|u| , f (|u|) ) • • • (q 3|u|-2 , f (2|u|-2) ) (r 1 , f (0) ) • • • (r (α-β)•|u|+|x2| , f (0) )</formula><p>is a subword of Ψ n . By construction of Ψ n , we have</p><formula xml:id="formula_109">p 1 &lt; • • • &lt; p |x1|+(β-1)•|u| &lt; q 1 &lt; • • • &lt; q |u| &lt; r 1 &lt; • • • &lt; r (α-β)•|u|+|x2|</formula><p>, so this implies that w can be decomposed as w = y 1 zy 2 where y 1 ∈ x 1 ¡ Σ * , where z ∈ u α ¡ Σ * and y 2 ∈ x 2 ¡ Σ * , the positions p 1 , . . . , p |x1| corresponding to letters in y 1 , the positions p |x1|+1 , . . . , p |x1|+(β-1)•|u| , q 1 , . . . , q |u| , r 1 , . . . , r (α-β)•|u| corresponding to letters in z and the positions r (α-β)•|u|+1 , . . . , r (α-β)•|u|+|x2| corresponding to letters in y 2 .</p><p>We are now going to show that, in fact, q |u| &lt; q 2|u|-1 &lt; q 2|u| &lt; • • • &lt; q 3|u|-2 &lt; r 1 , which implies z ∈ u α+1 ¡ Σ * and thus the contradiction we are aiming for. Since w / ∈ (x 1 ¡ Σ * )u(x 2 ¡ Σ * ), we have z / ∈ Σ * uΣ * , hence as w q |u| = u |u| and |u| &gt; 1, there must exist j ∈ [|u| -1] such that w q |u| -j = u |u|-j and w q |u| -ι = u |u|-ι for all ι ∈ [[0, j -1]]. By construction of Ψ n , we know that q |u|+j ≥ q |u| -j (because the instructions with f (j) after an instruction with f (0) querying position p ∈ [n] all query a position at least equal to p -j), but since u |u|-j = w q |u| -j and u |u|-j = u |u|-ι = w q |u| -ι for all ι ∈ [[0, j -1]] as the letters in u are all distinct, we get that q |u|+j &gt; q |u| . By (backward) induction, we can show that for all ι ∈ [[j + 1, |u| -1]], we have q |u|+ι &gt; q |u| . Indeed, given ι ∈ [[j + 1, |u| -1]], we have q |u|+ι-1 &gt; q |u| , either by inductive hypothesis or directly in the base case ι = j + 1 by what we have just seen. So by construction of Ψ n , we know that q |u|+ι ≥ q |u| (because the instructions with f (ι) after an instruction with f (ι-1) querying position p ∈ [n] all query a position at least equal to p -1), but since u |u|-ι = u |u| = w q |u| as the letters in u are all distinct, it follows that q |u|+ι &gt; q |u| . Therefore, we have that q 2|u|-1 &gt; q |u| . Moreover, by construction of Ψ n , we also have q 2|u|-1 &lt; q 2|u| &lt; • • • &lt; q 3|u|-2 &lt; r 1 (because for each ι ∈ [[0, |u| -2]], the instructions with f (|u|+ι) after an instruction with f (|u|+ι-1) querying position p ∈ [n] all query a position at least equal to p + 1 and similarly for the instructions with f (0) after an instruction with f (2|u|-2) ). So, to conclude, we have</p><formula xml:id="formula_110">p 1 &lt; • • • &lt; p |x1|+(β-1)•|u| &lt; q 1 &lt; • • • &lt; q |u| &lt; q 2|u|-1 &lt; q 2|u| &lt; • • • &lt; q 3|u|-2 &lt; r 1 &lt; • • • &lt; r (α-β)•|u|+|x2| and w p1 • • • w p |x 1 |+(β-1)•|u| w q1 • • • w q |u| w q 2|u|-1 w q 2|u| • • • w q 3|u|-2 w r1 • • • w r (α-β)•|u|+|x 2 | =x 1 u β-1 uu 1 u 2 • • • u |u| u α-β x 2 = x 1 u α+1 x 2 .</formula><p>This implies that w ∈ (x 1 u α+1 x 2 ) ¡Σ * , a contradiction. So there does not exist</p><formula xml:id="formula_111">β ∈ [α] such that ζ β is a subword of Ψ(w).</formula><p>Therefore, in every case Ψ n (w) / ∈ K =s(n) , and since this is true for all w ∈ Σ n \ L =n , we have Σ n \ L =n ⊆ Ψ -1 n (A s(n) \ K =s(n) ), which is equivalent to</p><formula xml:id="formula_112">L =n ⊇ Ψ -1 n (K =s(n) ).</formula><p>This concludes the proof of the claim.</p><p>And the one of the lemma.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.4 Proof of Proposition 4.11</head><p>Proof of Proposition 4.11. Let Σ be an alphabet, l ∈ N &gt;0 and u 1 , . . . , u k ∈ Σ + (k ∈ N &gt;0 ) such that for each i ∈ [k], the letters in u i are all distinct. Let α ∈ [l] k . For each i ∈ [k] verifying α i &lt; l, we define</p><formula xml:id="formula_113">L i =(u 1 α1 • • • u k α k ) ¡ Σ * ∩ (u 1 α1 • • • u i αi+1 • • • u k α k ) ¡ Σ * ∩ (u 1 α1 • • • u i-1 αi-1 ) ¡ Σ * u i (u i+1 αi+1 • • • u k α k ) ¡ Σ * .</formula><p>It is immediate to show that R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) = (u</p><formula xml:id="formula_114">1 α1 • • • u k α k ) ¡ Σ * ∩ i∈[k],αi&lt;l L i .</formula><p>By Lemma 4.10, L i ∈ P(J) for each i ∈ [k] verifying α i &lt; l. Moreover, since (u 1 α1 • • • u k α k ) ¡ Σ * obviously is a piecewise testable language, it belongs to P(J). Thus, we can conclude that R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) belongs to P(J) by closure of P(J) ∩ Reg under intersection, Proposition 2.1.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Lemma 4 . 2 .</head><label>42</label><figDesc>The languages (a + b) * ac + , (a + b) * ac + a(a + b) * , c + a(a + b) * ac + , (a + b) * bac + and (a + b) * ac + (a + b) * ac + do all belong to P(J) \ L(QJ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>and decompose w as w = xy where x ∈ q1,...,q k ∈{1,l} L (l) (u1,q1) • • • L (l) (u k ,q k ) and y ∈ u k+1 α k+1 ¡ Σ * with |y| being minimal. By inductive hypothesis, we know there exists α ∈ [l] k such that x ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ) and we then prove that xy ∈ R (α1,...,α k+1 ) l (u 1 , . . . , u k+1 ) ∩ S (α1,...,α k+1 ) l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>¡Σ * and y ∈ u k+1 l ¡Σ * . Hence, w ∈ R (α1,...,α k+1 ) l (u 1 , . . . , u k+1 ) ∩ S (α1,...,α k+1 ) l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>being minimal. So by inductive hypothesis, there exists α ∈ [l] k such that x ∈ R α l (u 1 , . . . , u k ) ∩ S α l (u 1 , . . . , u k ). We are now going to prove that w = xy ∈ R (α1,...,α k+1 ) l (u 1 , . . . , u k+1 ) ∩ S (α1,...,α k+1 ) l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>(x 1 ¡</head><label>1</label><figDesc>Σ * )u(x 2 ¡ Σ * ) and we can hence decompose w as w = y 1 zy 2 where y 1 ∈ (x 1 ¡ Σ * ) and y 2 ∈ (x 2 ¡ Σ * ) with |y 1 | and |y 2 | being minimal. It follows necessarily that z ∈ u α ¡ Σ * ∩ (u α+1 ¡ Σ * ) ∩ Σ * uΣ * by minimality of |y 1 | and |y 2 |. By Lemma B.1, we have z = α i=1 |u| j=1 (v i,j u j ) y where v i,j ∈ (Σ\{u j }) * for all i ∈ [α] and j ∈ [|u|], and y ∈ |u| i=1 i-1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>p 1 ,w</head><label>1</label><figDesc>. . . , p |x1|+(β-1)•|u| , q 1 , . . . , q 3|u|-2 , r 1 , . . . , r (α-β)•|u|+|x2| ∈ [n] verifying that w p1 • • • w p |x 1 |+(β-1)•|u| = x 1 u β-1 , w q1 • • • w q 3|u|-2 = u r1 • • • w r (α-β)•|u|+|x 2 | = u α-β x 2 and (p 1 , f (0) ) • • • (p |x1|+(β-1)•|u| , f(0)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements The author thanks the anonymous referees for their helpful comments and suggestions.</p></div>
			</div>			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We claim that Q = ε, a subprogram of P , has the desired properties. First notice that the length of Q is 0 ≤ 0! • |Σ| 0/2 • n 0/2 = c 0 • n 0/2 , at most the required length.</p><p>Let Q be a subprogram of P that has Q as a subprogram. As t ∈ M 0 , we necessarily have that t = ε, which is a subword of any word in M * . Therefore, we immediately get that for all w ∈ Σ n , the word t is a subword of ξ P (w) if and only if t is a subword of ξ Q (w), as desired. Let</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Missing</head><p>be the language of all words over Σ having ca as a subword but not the subwords cca, caa and cb, that by construction is piecewise testable, i.e. belongs to L(J).</p><p>We are now going to build a program-reduction from (a + b)</p><p>We therefore have</p><p>Since this means that Ψ n (w) ∈ L =s(n) , we necessarily have n ≥ 2 as it must contain ca as a subword, so that</p><p>Let i, j ∈ [n] verifying that w i = c, that w j = a and w i w j is a subword of Ψ n (w). This means that j ≥ i-1, and we will now show that, actually, j = i-1. Assume that j ≥ i+2; by construction, this would mean that w i w j w j = caa is a subword of Ψ n (w), a contradiction to the fact it belongs to L. Assume otherwise that j = i + 1; by construction, this would either mean that w i w i-1 w i+1 w i is a subword of Ψ n (w), which would imply one of caa, cba and cca is a subword of Ψ n (w), or that w i+1 w i w i+2 w i+1 is a subword of Ψ n (w), which would imply one</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.5 Proof of Proposition 4.13</head><p>Proof of Proposition 4.13. Let Σ be an alphabet, l ∈ N &gt;0 and u 1 , . . . ,</p><p>, then the result is straightforward because the language [u 1 , . . . , u k ] l then belongs to L(J), so now we assume d ≥ 2. We let Σ d = Σ × Z/d Z and for all w ∈ Σ * , for all i ∈ Z/d Z, we define w i = |w| j=1 (w j , (j + i -1) mod d). We also let w = w 0 for all w ∈ Σ * .</p><p>For all v ∈ Σ + , |v| ≤ d, we define µ(v, 1) = v and</p><p>a language over Σ d , that does belong to P(J) by Corollary 4.12 and closure of P(J) ∩ Reg under finite union (Proposition 2.1), because since</p><p>, each v i j for j ∈ Z/d Z has all distinct letters. This implies that for all q 1 , . . . , q k ∈ {1, l}, we have that [µ(u 1 , q 1 ), . . . , µ(u k , q k )] l,d does belong to P(J), so that q1,...,q k ∈{1,l} [µ(u 1 , q 1 ), . . . , µ(u k , q k )] l,d is a language over Σ d belonging to P(J). Now, it is not so difficult to see that</p><p>[µ(u 1 , q 1 ), . . . , µ(u k , q k )] l,d , which allows us to conclude that the sequence (Ψ n ) n∈N of Σ d -programs such that Ψ n (w) = w for all n ∈ N and w ∈ Σ n is a program-reduction from [u 1 , . . . , u k ] l to q1,...,q k ∈{1,l} [µ(u 1 , q 1 ), . . . , µ(u k , q k )] l,d of length n. Hence, [u 1 , . . . , u k ] l does also belong to P(J) by Proposition 2.2.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Ajtai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Σ</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">1 -formulae on finite structures</title>
	</analytic>
	<monogr>
		<title level="j">Annals of pure and applied logic</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="48" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Bounded-width polynomial-size branching programs recognize exactly those languages in NC 1</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A M</forename><surname>Barrington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="150" to="164" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Finite monoids and the fine structure of NC 1</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A M</forename><surname>Barrington</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thérien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="941" to="952" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Automata, Languages, and Machines, volume A</title>
		<author>
			<persName><forename type="first">S</forename><surname>Eilenberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<publisher>Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Automata, Languages, and Machines</title>
		<author>
			<persName><forename type="first">S</forename><surname>Eilenberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>B. Academic Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Parity, circuits, and the polynomialtime hierarchy</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Furst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sipser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Systems Theory</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="13" to="27" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><surname>Grosshans</surname></persName>
		</author>
		<title level="m">The limits of Nečiporuk&apos;s method and the power of programs over monoids taken from small varieties of finite monoids</title>
		<meeting><address><addrLine>France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
		<respStmt>
			<orgName>University of Paris-Saclay</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The power of programs over monoids in DA</title>
		<author>
			<persName><forename type="first">N</forename><surname>Grosshans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mckenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MFCS 2017</title>
		<meeting><address><addrLine>Aalborg, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">August 21-25, 2017 -. 2017</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Hierarchies of piecewise testable languages</title>
		<author>
			<persName><forename type="first">O</forename><surname>Klíma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Polák</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Found. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="517" to="533" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An algebraic point of view on the Crane Beach property</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lautemann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thérien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSL 2006</title>
		<meeting><address><addrLine>Szeged, Hungary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">September 25-29, 2006. 2006</date>
			<biblScope unit="page" from="426" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Programs over semigroups of dot-depth one</title>
		<author>
			<persName><forename type="first">A</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Péladeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thérien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">245</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="135" to="148" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">NC 1 : The automata-theoretic viewpoint</title>
		<author>
			<persName><forename type="first">P</forename><surname>Mckenzie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Péladeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thérien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="330" to="359" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Péladeau</surname></persName>
		</author>
		<title level="m">Classes de circuits booléens et variétés de monoïdes</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
		<respStmt>
			<orgName>Université Pierre-et-Marie-Curie (Paris-VI</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Finite semigroup varieties defined by programs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Péladeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Straubing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thérien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">180</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="325" to="339" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Varieties Of Formal Languages</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986">1986</date>
			<publisher>Plenum Publishing Co</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The dot-depth hierarchy, 45 years later</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Role of Theory in Computer Science -Essays Dedicated to Janusz Brzozowski</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="177" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Some results on C-varieties</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Straubing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ITA</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="239" to="262" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Piecewise testable events</title>
		<author>
			<persName><forename type="first">I</forename><surname>Simon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata Theory and Formal Languages, 2nd GI Conference</title>
		<meeting><address><addrLine>Kaiserslautern</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975">May 20-23, 1975. 1975</date>
			<biblScope unit="page" from="214" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Finite semigroup varieties of the form V * D</title>
		<author>
			<persName><forename type="first">H</forename><surname>Straubing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Pure and Applied Algebra</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="53" to="94" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">When can one finite monoid simulate another? In Algorithmic Problems in Groups and Semigroups</title>
		<author>
			<persName><forename type="first">H</forename><surname>Straubing</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="267" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Languages defined with modular counting quantifiers</title>
		<author>
			<persName><forename type="first">H</forename><surname>Straubing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">166</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="112" to="132" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Computational Complexity Questions Related to Finite Monoids and Semigroups</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tesson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<pubPlace>Montreal</pubPlace>
		</imprint>
		<respStmt>
			<orgName>McGill University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The computing power of programs over finite monoids</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tesson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Thérien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Lang. Comb</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="247" to="258" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
