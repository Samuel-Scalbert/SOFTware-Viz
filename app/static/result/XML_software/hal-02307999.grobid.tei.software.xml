<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" />
				<funder ref="#_pbq8ZWs #_ezVQp5S">
					<orgName type="full">DBOnto</orgName>
				</funder>
				<funder>
					<orgName type="full">EPSRC</orgName>
				</funder>
				<funder ref="#_nPGuBhf">
					<orgName type="full">PDQ</orgName>
				</funder>
				<funder ref="#_mTXDaBC">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
						</author>
						<author>
							<persName><surname>Cristal</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">The University of Oxford</orgName>
								<address>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">CRIStAL</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">University of Lille &amp; Inria</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">GEORG GOTTLOB</orgName>
								<orgName type="institution">The University of Oxford</orgName>
								<address>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria &amp; LTCI</orgName>
								<orgName type="institution" key="instit4">Télécom Paris</orgName>
								<address>
									<settlement>IP Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">The University of Oxford</orgName>
								<address>
									<settlement>Oxford</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">CNRS</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="department">Georg Gottlob</orgName>
								<orgName type="institution">University of Lille &amp; Inria</orgName>
								<address>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution">The University of Oxford</orgName>
								<address>
									<settlement>Oxford</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria &amp; LTCI</orgName>
								<orgName type="institution" key="instit4">Télécom Paris</orgName>
								<orgName type="institution" key="instit5">IP</orgName>
								<address>
									<settlement>Paris, Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">49C700DCC8FB99405CD07F36F7914688</idno>
					<idno type="DOI">10.1145/3344514</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Access patterns</term>
					<term>binding patterns</term>
					<term>deep Web</term>
					<term>monadic datalog</term>
					<term>query containment</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>We reconsider the problem of containment of monadic datalog (<software>MDL</software>) queries in unions of conjunctive queries (UCQs). Prior work has dealt with special cases of the problem, but has left the precise complexity characterization open. In addition, the complexity of one important special case, that of containment under access patterns, was not known before. We start by revisiting the connection between <software ContextAttributes="used">MDL</software>/UCQ containment and containment problems involving regular tree languages. We then present a general approach for getting tighter bounds on the complexity of query containment, based on analysis of the number of mappings of queries into tree-like instances. We give two applications of the machinery. We first give an important special case of the <software ContextAttributes="used">MDL</software>/UCQ containment problem that is in EXPTIME, and use this bound to show an EXPTIME bound on containment under access patterns. Secondly we show that the same technique can be used to get a new tight upper bound for containment of tree automata in UCQs. We finally show that the new <software ContextAttributes="used">MDL</software>/UCQ upper bounds are tight. We establish a 2EXPTIME lower bound on the <software ContextAttributes="used">MDL</software>/UCQ containment problem, resolving an open problem from the early 1990s. This bound holds for the <software ContextAttributes="used">MDL</software>/CQ containment problem as well. We also show that changes to the conditions given in our special cases can not be eliminated, and that in particular slight variations of the problem of containment under access patterns become 2EXPTIME-complete.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head>Monadic Datalog, Tree Validity, and Limited Access Containment 1 INTRODUCTION</head><p>Context. Datalog represents a standard model for querying data with recursion. The basic problems of evaluation, equivalence, and containment of datalog thus have been the object of study for several decades. Shmueli <ref type="bibr" target="#b30">[31]</ref> showed that containment (and equivalence) of datalog is undecidable. Decidable subclasses were subsequently isolated <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14]</ref>, focusing on restricting the form of recursion used. Chaudhuri and Vardi <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref> provide an extensive study of the containment of datalog queries in non-recursive datalog queries, showing in particular that the problem is decidable. They also show that it is 2EXPTIME-complete to decide containment of a datalog query within a union of conjunctive queries (UCQ).</p><p>In this article we focus on monadic datalog (<software ContextAttributes="used">MDL</software>) -the fragment in which all intensional predicates are unary. Cosmodakis, Gaifman, Kanellakis, and Vardi <ref type="bibr" target="#b21">[22]</ref> showed that containment of monadic datalog queries is in 2EXPTIME, and is EXPTIME-hard, leaving open the question of a tight bound. In another article, Chaudhuri and Vardi <ref type="bibr" target="#b17">[18]</ref> prove a co-NEXPTIME upper bound for containment of a unary <software ContextAttributes="used">MDL</software> query (i.e., a query with one output variable) in a union of connected Example 1.1. Consider a schema with relations as follows: there is a binary relation R(x, y), having an access a R that requires a value for both positions; given inputs v, w the access returns true exactly when R(v, w). There is also a unary relation U (x) having an access a U that requires no input: hence a call to a U will return all values of U . The accessible facts from this schema can be seen to be all facts of the form U (c) and all facts R(c, d) where c, d ∈ U .</p><p>The containment problem for limited access patterns is the following: given two queries Q and Q ′ and a schema with limited access patterns, is it true that, for every instance I , Q(AccFacts(I )) ⊆ Q ′ (AccFacts(I ))?</p><p>Example 1.2. In the example schema above, consider queries Q = ∃x∃y R(x, y) and Q ′ = ∃x∃y R(x, y) ∧ U (x). These are certainly not equivalent, but are equivalent over the accessible data for this schema: indeed, the only way to access facts from relation R is to first access U , implying that all facts of the form R(a, b) that are accessible are such that both U (a) and U (b) are accessible.</p><p>It was noticed early on <ref type="bibr" target="#b26">[27]</ref> that the problem of containment of unions of conjunctive queries under access patterns is a special case of monadic datalog containment in a UCQ. First, the problem can be seen to be equivalent to: ∀I Q(AccFacts(I )) ⊆ Q ′ (I ) One direction of the equivalence is immediate from monotonicity of UCQs, since Q ′ (AccFacts(I )) ⊆ Q ′ (I ). For the other direction, given a counterexample to containment under access patterns, we can modify it by replacing I with AccFacts(I ), giving a counterexample to the above.</p><p>Assuming each relation mentioned in the query has at least one access method (this is without loss of generality, since containment is trivial otherwise), the query Q ′ (AccFacts(I )) can be defined by restricting Q ′ to the values that occur in AccFacts(I ), and the latter can in turn be defined by an <software>MDL</software> program, using the rules:</p><formula xml:id="formula_0">AccValues(x j ) ← R(x) ∧ AccValues(x m 1 ) ∧ • • • ∧ AccValues(x m k )</formula><p>whenever there is an access with input positions m 1 . . . m k .</p><p>Thus containment under access limitations is a special case of <software ContextAttributes="used">MDL</software>/UCQ containment. But again the only upper bound observed for containment under access patterns was the 2EXPTIME bound of <ref type="bibr">Chaudhuri and Vardi.</ref> Another problem closely related to the <software ContextAttributes="used">MDL</software>/UCQ containment problem is boundedness of <software ContextAttributes="used">MDL</software>, i.e., determining whether the evaluation of a <software ContextAttributes="used">MDL</software> program reaches a fixpoint after a fixed, dataindependent, number of iterations. Though boundedness of Datalog programs is undecidable in general, it was shown in <ref type="bibr" target="#b21">[22]</ref> that it is decidable for <software ContextAttributes="used">MDL</software>, though the precise complexity was not assessed. As shown in <ref type="bibr" target="#b6">[7]</ref> (Claim 40 of the extended version), containment of <software ContextAttributes="used">MDL</software> in a UCQ reduces to <software ContextAttributes="used">MDL</software> boundedness.</p><p>Contributions. In this work, we will ascertain both the exact complexity of <software>MDL</software>/UCQ containment, and the exact complexity of limited-access containment. We will also settle some questions on the complexity of query validity problems on trees: this is the problem of determining, given a tree schema (e.g. given as an automaton or DTD) and a query, whether the schema implies the query. We will show that monadic datalog containment and tree validity problems are tightly connected.</p><p>We start by introducing a new upper bound technique, revisiting the 2EXPTIME upper bound for containment of Chaudhuri and Vardi. We will refine the main two tools used there: reduction to tree-shaped models, and counting the number of different types of nodes in the models. We present a property of a class of instances, the Unique Mapping Condition, that suffices to show that the number of types reduces from doubly-exponential to exponential. We then show that whenever this condition holds, containment in UCQs goes down to EXPTIME.</p><p>We give two settings where the Unique Mapping Condition holds. The first is that of "almost globally extensionally limited" <software>MDL</software> (<software ContextAttributes="used">AGEMDL</software>) queries over general relational instances: we limit the number of occurrences of an extensional predicate in the program. We show that containment under limited access in the case of a single-access per relation reduces to <software ContextAttributes="used">GEMDL</software> containment in a UCQ. Thus our EXPTIME bounds apply to this case. We show that this reduction can be bootstrapped to give the same bounds for the general limited-access containment problem.</p><p>A second application is when the models are trees. We show that the UMC for this case gives us new upper bounds on the validity problem of tree automata in UCQs.</p><p>We then turn to lower bounds. We first show that all of our upper bounds on tree validity are tight. The key ingredient is an adaptation of a 2EXPTIME-hardness argument due to Bjorklund, Martens and Schwentick <ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref>. We then give reductions from tree validity problems to <software ContextAttributes="used">MDL</software> and limited access containment problems to show that the upper bounds we provide for these problems are tight as well. In particular, we show that containment of <software ContextAttributes="used">MDL</software> in CQs (and hence, UCQs) is 2EXPTIME-complete. This resolves the main open question from <ref type="bibr" target="#b17">[18]</ref> and also implies that <software ContextAttributes="used">MDL</software> boundedness is 2EXPTIME-hard, as noted in <ref type="bibr" target="#b6">[7]</ref>. Since containment of <software ContextAttributes="used">MDL</software> in a CQ is a special case of monadic datalog containment, it also shows that monadic datalog containment is 2EXPTIME-complete, closing the gap in the bounds of <ref type="bibr" target="#b21">[22]</ref>. We finally use the technique to show that when we move to a slightly broader collection of <software ContextAttributes="used">MDL</software> programs, compared to those arising from limited access containment, we get a 2EXPTIME-complete query containment problem.</p><p>Organization. Section 2 contains the basic definitions. Section 3 reviews prior work and summarizes the main results in detail. Section 4 defines the main new subclasses for which tighter upper bounds can be provided, and then gives our new upper bound proofs. Section 5 deals with lower bounds, showing that all previously given upper bounds are tight. Section 6 discusses related work, while Section 7 gives conclusions, open issues, and future directions.</p><p>Limitations. For simplicity, we do not consider two important variants of the <software ContextAttributes="used">MDL</software>/UCQ containment problem and of limited-access containment. First, we assume that all queries do not contain any constants, i.e., that all relation atoms are made up of variables. Though the general <software ContextAttributes="used">MDL</software>/UCQ problem is known to also be in 2EXPTIME in the presence of constants <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, constants typically do affect the complexity of containment problems, as they make it easier to code hardness proofs. Second, contrarily to some of the limited-access literature <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13]</ref>, we assume that our queries work over relational databases in which there are no restrictions on the values that occur in a column. The alternative would be to allow a schema to specify a type or abstract domain for each attribute.</p><p>Though we do not consider abstract domains, the corresponding constraints could easily be coded by a disjunction of conjuncts, so we believe our results on limited-access containment of UCQs would not be affected.</p></div>
<div><head n="2">BACKGROUND</head><p>We introduce in this section the main notions studied in this article (some from the literature, others introduced in this work), along with some general preliminary results. We go over the following concepts: monadic datalog and query containment (Section 2.1); expansion trees of monadic datalog queries (Section 2.2); tree validity problems (Section 2.3); querying under limited access constraints (Section 2.4).</p></div>
<div><head n="2.1">Monadic Datalog Containment</head><p>Basics. A relational signature σ consists of a set of relation symbols (or simply relations), each with an associated arity. For a relation R any number i &lt; arity(R) is referred to as a position of R. An instance I for the signature σ interprets each relation symbol in the signature of arity k by a set of k-tuples, where the values are taken in some infinite set of values (independent of the instance). For every tuple (v 1 , . . . , v n ) in the interpretation of a relation symbol R by I , we say that R(v 1 , . . . , v n ) is a fact of I . We denote by dom(I ) the active domain of the instance I , i.e., the set of values appearing in I .</p><p>An atom over a relational signature σ is an expression R(x 1 . . . x n ) where R is a k-ary predicate of σ and the x i 's are variables (from some countable set). We refer to x i as "the variable at position i" of the atom. We emphasize that an atom never refers to a domain constant.</p><p>We consider the following two simple positive query languages over σ : (a) conjunctive queries (CQs); (b) unions of conjunctive queries (UCQs). They are respectively defined as the fragments of first-order logic over σ consisting of, respectively, (a) existentially quantified conjunctions of atoms; (b) disjunctions of CQs. A conjunctive query is connected if its Gaifman graph (whose vertices are the variables of the query and where there is an edge between two variable if they appear in the same atom) is connected. A subquery of a CQ is a subset of its atoms; a subquery of a UCQ is a subquery of one of its conjuncts (in particular, a subquery is always a CQ).</p><p>Datalog. A datalog program <ref type="bibr" target="#b0">[1]</ref> over σ consists of: (i) A set of rules of the form A ← φ, where φ is a conjunction of atoms over σ , and A is an atom over σ . We say A is the head and φ the body of the rule. We require that every variable occurring in the head of a rule r also occurs in its body. (ii) A distinguished predicate Goal of σ which occurs in the head of a rule, referred to as the goal predicate. The relational symbols that do not occur in the head of any rule are the input or extensional predicates, while the others are intensional predicates. Similarly, the extensional (resp., intensional) signature of a program is the set of extensional (resp., intensional) predicates used by the program. Monadic datalog (<software ContextAttributes="used">MDL</software>) denotes the sublanguage where all intensional predicates are monadic (unary), except for the goal predicate which can be either unary or nullary (in the latter case, we say that the program is Boolean).</p><p>For a datalog program P, an intensional predicate R of P, and an instance I interpreting the input predicates, we define the evaluation of R on I , denoted R(I ), as the union of the relations P k (R, I ) defined via the following process, starting with P 0 (R, I ) = ∅:</p><p>• Let I k be the expansion of I with P k (R, I ) for all intensional R.</p><p>• If r is a rule with R(x 1 . . . x l ) in the head, w the variables of r not present in the head, and φ(x, w) the body of r , let P k +1 (r, I ) be defined by: {c ∈ dom(I ) l | I k |= ∃w φ(c, w)} where dom(I ) is the active domain of I . • Let then P k +1 (R, I ) denote the union of P k +1 (r, I ) over all r with R in the head. Finally, the query result of P on I , denoted P(I ), is the evaluation of the goal predicate of P on I . We often assume P is Boolean, in which case the result of the program on I is the Boolean "true" iff Goal() holds in I , and we simply say that I is a model of P or that I satisfies P. We alternatively refer to a datalog query, rather than to a datalog program, to emphasize that we are only interested in the evaluation on the goal predicate.</p><p>Under these semantics, it is easy to check that any UCQ can be transformed in linear-time into an equivalent <software>MDL</software> query, that does not involve any intensional predicate apart from Goal.</p><p>Containment. The main problem we deal with in this work is the classical notion of query containment <ref type="bibr" target="#b0">[1]</ref>.</p><formula xml:id="formula_1">Definition 2.1. Let Q and Q ′ be two queries over a signature σ . We say Q is contained in Q ′ , denoted Q ⊑ Q ′ , if, for any instance I over σ , Q(I ) ⊆ Q ′ (I ).</formula><p>Above we have defined containment in terms of the evaluation of Q over all instances, finite and infinite. But a simple (and well-known) argument shows that this coincides with containment when only finite instances are considered. If there is an instance I and tuple t such that t ∈ Q(I ), t Q ′ (I ), then the fact that t ∈ Q(I ) is guaranteed by a finite collection of facts I 0 in I . Thus I 0 witnesses that Q is not contained in Q ′ over finite instances. Given this equivalence, throughout this work we will assume that instances are finite. For finite instances I , there will be a finite k such that the evaluation of datalog Q will be P k +1 (Goal, I ) for Goal the goal predicate.</p><p>Example 2.2. Consider the following <software>MDL</software> program P that determines whether there is a path in a graph G from a node marked with the unary predicate S to one marked with the unary predicate T :</p><formula xml:id="formula_2">Goal() ← T (x) ∧ Reachable(x) Reachable(y) ← G(x, y) ∧ Reachable(x) Reachable(x) ← R(x)</formula><p>Now consider the UCQs:</p><formula xml:id="formula_3">Q 1 : ∃x∃y R(x) ∧ G(x, y) ∧ T (y) Q 2 : (∃x R(x) ∧ T (x)) ∨ (∃x ′ ∃y ′ G(x ′ , y ′ ))</formula><p>We have that P Q 1 but P ⊑ Q 2 : indeed, if I is the instance made of the facts R(a) and T (a), I is a model of P, but not a model of Q 1 . And in any model of P, either the first rule defining Reachable is used, and then the second disjunct of Q 2 holds, or only the second rule defining Reachable is used, and then the first disjunct of Q 2 holds.</p><p>We focus on containment for Boolean queries in the remainder of the paper. However, our results apply to the unary case as well, thanks to the following: Proposition 2.3. There are polynomial time one-to-one reductions in both directions between the containment of Boolean <software>MDL</software> queries in Boolean UCQs and that of <software ContextAttributes="used">MDL</software> queries in UCQs.</p><p>Proof. Given a containment problem for Boolean <software>MDL</software> query Q 1 in UCQ Q 2 , we can create a unary containment problem by adding an additional unary intensional predicate U to the signature. We create a new unary <software ContextAttributes="used">MDL</software> query that returns the content of U whenever Q 1 is true. We similarly create a new UCQ by adding a conjunct U (x) to all CQs.</p><p>In the other direction, given unary <software>MDL</software> Q 1 and UCQ Q 2 , we again add a unary predicate to the signature. We create a new Boolean <software ContextAttributes="used">MDL</software> query Q ′ 1 that holds if Q 1 intersected with the unary predicate is non-empty, and similarly for Boolean UCQ Q ′ 2 derived from Q 2 . It is easy to see that containment is preserved by this reduction, since if Q 1 is not contained in Q 2 on some instance I one can expand to the larger signature by choosing the unary predicate to be the symmetric difference of Q 1 and Q 2 on I . □</p><p>The direction from non-Boolean to Boolean in the proposition above implies that lower bounds on Boolean containment of <software>MDL</software> into UCQ applies to unary <software ContextAttributes="used">MDL</software> as well. The other direction is used to transfer upper bounds. Our upper bounds will be proven for several restricted classes of Boolean <software ContextAttributes="used">MDL</software>. The analogous definitions for non-Boolean <software ContextAttributes="used">MDL</software> will be obvious, and all of these classes will easily be seen to be preserved by the transformation from above. Hence the argument above implies that these upper bounds also apply to the corresponding non-Boolean problem.</p><p>Note that this simple argument does not apply to the results of Chaudhuri and Vardi <ref type="bibr" target="#b17">[18]</ref> on containment of connected unary <software ContextAttributes="used">MDL</software> queries into a union of unary connected queries, since connectedness is not preserved by the reduction.</p><p>Relying on Proposition 2.3, we will only consider Boolean queries in the rest of this paper. Because of this, note that we can assume that variables are not reused across conjuncts of a UCQ.</p></div>
<div><head n="2.2">Monadic Expansion Trees</head><p>Before discussing the complexity of the containment problem, we introduce the notion of monadic expansion tree of a Boolean <software ContextAttributes="used">MDL</software> query that will be used in various proofs throughout the paper. Monadic expansion trees are inspired by the notion of expansion trees of <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>; a monadic expansion tree is not a special case of an expansion tree, but a refinement of this notion that adds structure to it exploiting the fact that the datalog query is monadic. Monadic expansion trees can also be seen as a special kind of tree decomposition <ref type="bibr" target="#b29">[30]</ref>.</p><p>Definition 2.4. A monadic expansion tree over some signature σ is an instance I over σ , together with a finite, rooted, ordered, unranked tree T(I ). Every node n of T(I ) is associated with a set of facts of I , called the bag of n and denoted bag(n). In addition, all nodes except for the root are associated with an element v from dom(I ), called the output element of the node n. We require that:</p><p>(i) every fact R(a) ∈ I appears in a bag(n) for some n ∈ T(I );</p><p>(ii) for every n ∈ T(I ), every value a appearing in atoms of bag(n) ∈ dom(n) is either the output element of n or the output element of one of n's children in T(I ); (iii) for every non-root n ∈ T(I ) with parent n ′ , the output element of v appears in bag(n ′ ); (iv) the output elements of nodes are all distinct. We denote a node n by a pair (v, bag(n)) consisting of its output value and bag of facts. The rank of a monadic expansion tree I is the maximal number of children of any node in T(I ).</p><p>Example 2.5. Consider the following monadic expansion tree (I, T(I )) over the same signature as in Example 2.2. It is represented as its tree T(I ) (with the root to the left):</p><formula xml:id="formula_4">{T (c)} (c, {G(b, c)}) (b, {G(a, b)}) (a, {S(a)})</formula><p>This tree happens to have no branching (i.e., it has rank 1). The corresponding instance is I = {S(a), G(a, b), G(b, c),T (c)}, verifying requirement (i). It is easy to check that the other requirements are satisfied.</p><p>Note that, for each domain element a, the nodes of a monadic expansion tree containing a form a connected subtree of size at most 2: indeed, requirement (ii) implies that any bag containing a must be the bag n that has a as output element -which is unique by requirement (iv) -or the parent of n (if n is not the root). Together with the other conditions, this means that a monadic expansion tree is a special kind of tree decomposition <ref type="bibr" target="#b29">[30]</ref>.</p><p>A fundamental fact is that there always exists a monadic expansion tree that is a witness for non-containment of a monadic datalog query in a UCQ. A similar result appears in various other places in the literature, such as <ref type="bibr" target="#b22">[23,</ref><ref type="bibr">Theorem 5.2]</ref>, <ref type="bibr" target="#b17">[18,</ref><ref type="bibr">Proposition 3.7]</ref>, or <ref type="bibr" target="#b12">[13,</ref><ref type="bibr">Theorem 1]</ref> in the specific setting of limited access containment. One distinction of the result presented here with respect to those works is that our definition of monadic expansion tree enforces a stricter structure, in particular through the use of output elements associated to nodes, that we will need, further on, to prove upper bounds on the containment problem. Proposition 2.6. Let Q be an <software ContextAttributes="used">MDL</software> query with at most k atoms in the body of each rule, and at most p intensional predicates. Let Q ′ be a UCQ over the extensional signature of Q. If Q is not contained in Q ′ , there exists a monadic expansion tree (I, T(I )), with at most p × k facts per bag, such that</p><formula xml:id="formula_5">I satisfies Q ∧ ¬Q ′ .</formula><p>Proof. This proof is based on the notion of expansion tree of a datalog query, as defined in Section 2.4 of <ref type="bibr" target="#b17">[18]</ref>. An expansion tree of a Boolean <software ContextAttributes="used">MDL</software> query Q, as defined in that work, is a finite tree where each node is labeled by an instantiated rule r of Q. We will assume that this instantiation does not introduce any spurious equalities. Specifically, we fix for each node n of the tree a one-to-one mapping φ n from the variables of the rule to some set of variables. We annotate the node n with the instantiated rule φ(r ). Furthermore, if a node is labeled with an instantiation of a rule r , it has a child for each intensional predicate atom A appearing in r . The label of that child is a rule r ′ with A in the head, with the variables of A mapped to the same variables as in r , and other variables of r mapped to fresh variables. The root of the tree is labeled with a rule that has the goal predicate as its head.</p><p>For any expansion tree t of an <software ContextAttributes="used">MDL</software> query Q, we let Π ext (t) be the set of all extensional atoms appearing in nodes of t. A critical observation made in <ref type="bibr" target="#b17">[18]</ref> is that Q is equivalent to the infinite disjunction of the Π ext (t), with t an expansion tree of Q, each Π ext (t) being seen as a conjunctive query, where we conjoin all atoms and existentially quantify all variables. In particular, if some instance I 0 satisfies Q ∧ ¬Q ′ , then there exists an expansion tree t such that I 0 |= Π ext (t) and, of course, we still have</p><formula xml:id="formula_6">I 0 ̸ |= Q ′ .</formula><p>Example 2.7. Returning to the Datalog program in Example 2.2, where we label the rules: r 1 : Goal() ← T (x) ∧ Reachable(x), r 2 : Reachable(y) ← G(x, y) ∧ Reachable(x), r 3 : Reachable(x) ← R(x). One expansion tree would have r 1 at the root, r 2 instantiated as Reachable(x) ← G(x, z) ∧ Reachable(z) as the only child of the root, and r 3 instantiated as Reachable(z) ← R(z) as a leaf child of the instantiation of r 2 .</p><p>So far, we have not used the fact that Q is monadic. We do so now, by first arguing that we can choose t such that there are no two nodes n and n ′ in t, with n a strict ancestor of n ′ , sharing the same head atom R(x) with the same variable x (or having the same head atom Goal()). If there were such nodes, the subtree rooted at n could be replaced by the subtree rooted at n ′ , resulting in a new expansion tree whose set of atoms is a subset of that of t, and that I 0 thus still models. This remark is similar to Proposition 3.15 of <ref type="bibr" target="#b17">[18]</ref>, which is also about the monadic case.</p><p>Moreover, we show how to turn t into a DAG structure G such that no two nodes n and n ′ have the same head atom R(x) with the same variable x, or the same atom Goal(). For this purpose, an equivalence relation ≡ is associated with the nodes of t such that n ≡ n ′ iff n and n ′ have the same head atom. We fix an arbitrary representative of the equivalence class of every node n, denoted φ(n). We then transform t into a graph G where each edge (n, n ′ ) is turned into an edge (φ(n), φ(n ′ )). Since we assumed no two equivalent nodes could be strict descendants of each other, G is acyclic.</p><p>We can define Π ext (G) similarly to the way we defined Π ext (G), as the conjunctive query formed of all extensional atoms of the rules annotating nodes of the graph. Note that Π ext (t) is contained in Π ext (G) since the set of atoms of G is a subset of that of t. This means our original I 0 is still a model of Π ext (G).</p><p>We now build a monadic expansion tree (I, T(I )) from a "canonical model" of G. Let ν be a one-to-one mapping from the variables of G to constants. We let I ν (Π ext (G)) and define the tree T(I ) as follows. Consider a value c = ν (x) of I for some variable x. We construct a new node n c with c as output element, and let bag(n c ) contain all extensional facts associated by ν to the atoms of the nodes of G having x in their head atom. Similarly, we construct one node r whose bag contains all extensional facts associated to atoms of nodes of G having Goal() as the head atom. For each value d in a fact within the bag of a node n distinct from its output element if any exists, we put an edge from n to n d . We will show that this structure is indeed a monadic expansion tree.</p><p>We first argue that the underlying structure is a DAG rooted at r . By definition, there cannot be an edge from a node n to itself, and there cannot be an edge to r . If there were a path from a node n ν (x ) to itself through a node n ν (y) with x y, it would mean that, in G, and thus in t, there would be a disconnected set of nodes with the same variable x in their head atom; this is in contradiction with the definition of expansion trees.</p><p>Second, we show that T(I ) is not only a DAG, but a tree. We claim that for any variable x, there is only one node of T(I ) whose bag involves a fact with ν (x) apart from the bag whose output element is ν(x). It will be the node corresponding to the parent of the topmost node of G whose head atom refers to x; it is easy to see that, in G a node can only have several parents if parents and child share the same head atom variable. We deduce that T(I ) is a tree.</p><p>We now verify the properties required of monadic expansion trees: (i) Every extensional atom in G is in some node n of G; it will thus be present in T(I ), either in the root bag r if the head atom of n is Goal(), or in n ν (x ) if the head of atom of n is of the form R(x). (ii) If a value d appears in a bag n c of T(I ) then, by construction either d = c, or n d is a child of n c . (iii) A node n d cannot be a child of a node n in T(I ) unless d appears in bag(n); (iv) Nodes of T(I ) are either the root or indexed by their output element, so that output elements of nodes are all distinct. Let us now verify that the maximum number of facts per bag is less than or equal to p × k. The root bag r contains, for each intensional atom Goal() corresponding to some node n of G, a fact for every extensional atom within n. Note that there are at most p intensional atoms and the number of extensional atoms n is at most the number of atoms in the body of the rule, which is at most k. Similarly, a bag n ν (x ) contains, for each intensional atom of the form R(x) corresponding to some node n of G, a fact for every extensional atom within n. Here we note that there are at most p atoms of the form R(x), and the number of extensional atoms in the rule is again at most k. We obtain the desired bound.</p><p>It only remains to show that I |= Q and I ̸ |= Q ′ . The former is immediate: I is the extensional part of ν (G), which is a canonical model of G, when G is seen as a conjunctive query -and G can be expanded into an expansion tree of Q. The latter comes from the fact that we showed I 0 |= Π ext (G), which means that there exists a homomorphism ρ : Π ext (G) → I 0 . If we had I |= Q ′ , witnessed by homomorphism µ, then ρ • ν -1 • µ would be a homomorphism from Q ′ to I 0 , contradicting </p><formula xml:id="formula_7">I 0 ̸ |= Q ′ . □<label>Example</label></formula></div>
<div><head n="2.3">Trees and Tree Validity</head><p>Our results for datalog containment will make use of trees in several ways. First, our upper bounds will make use of techniques from tree automata, so we will need to review the definitions of several flavors of automata. Second we will show a tight connection between datalog containment and "universality" or "validity" problems for queries over trees: given a schema describing a set of trees and a Boolean query over trees, does every tree satisfy the query? There are many variants of the problem, depending on the exact signature of trees used. We will thus define several signatures below.</p><p>Let Λ be a finite non-empty set of labels. We will consider the settings of both binary and unranked trees. Many of our lower bounds will work in the restricted setting of binary trees. For binary trees with labels from Λ, the following signature is natural.</p><p>The relational signature of ordered, labeled, binary trees, denoted S bin Ch1,Ch2 , contains the binary predicates <software>FirstChild</software>, <software ContextAttributes="used">SecondChild</software>, unary Root, Leaf predicates, and Label α predicates for all α ∈ Λ.</p><p>A tree T over S bin Ch1,Ch2 is a relational instance such that: (i) the non-empty Label T α 's for α ∈ Λ form a partition of dom(T ) (one can thus talk about the label of a node n, which is the α ∈ Λ such that n ∈ Label T α ); (ii) <software>FirstChild</software> T and <software ContextAttributes="used">SecondChild</software> T are one-to-one partial mappings with the same domain (the set of internal nodes), whose complement is Leaf T (the set of leaves), and with disjoint ranges; (iii) the inverses of <software ContextAttributes="used">FirstChild</software> T and <software ContextAttributes="used">SecondChild</software> T are one-to-one partial mappings; (iv) ∃x <software ContextAttributes="used">FirstChild</software>(x, x) ∨ <software ContextAttributes="used">SecondChild</software>(x, x) does not hold; (v) Root T contains exactly one element (the root r of T ), and the following formula does not hold for r : ∃x <software ContextAttributes="used">FirstChild</software>(x, r ) ∨ <software ContextAttributes="used">SecondChild</software>(x, r ). We denote as S bin Ch1,Ch2,Child (resp., S bin Ch1,Ch2,Child,Child ? ) the relational signature containing all the relations of S bin Ch1,Ch2 together with a binary Child relation (resp., binary Child and Child ? relations). A tree T over S bin Ch1,Ch2,Child is a relational instance that verifies the same axioms as a tree over S bin Ch1,Ch2 , where Child T is the disjoint union of <software ContextAttributes="used">FirstChild</software> T and <software ContextAttributes="used">SecondChild</software> T . A tree over S bin Ch1,Ch2,Child,Child ? has the additional requirement that ∀x∀y Child ? (x, y) ↔ (Child(x, y) ∨ x = y) holds.</p><p>Note that we omit the label alphabet Λ from notation such as S bin Ch1,Ch2 for readability. Our upper bound results concerning S bin Ch1,Ch2 and S bin Ch1,Ch2,Child will hold for any label set Λ, while in our lower bounds we will usually show hardness for any label set of size at least 2.</p><p>The relational signature of unordered, labeled, unranked trees, denoted S unranked</p></div>
<div><head>Child</head><p>, is made out of the binary predicate Child together with the unary Root, Leaf, and Label α . A tree over S unranked Child is a relational instance such that:</p><p>(i) the non-empty Label T α 's for α ∈ Λ form a partition of dom(T ); (ii) Child T is a tree in the usual sense, whose root is the only element of Root T and whose leaves are exactly the elements of Leaf T . We sometimes consider as special cases trees formed of a single node (i.e., trees such that |dom(T )| = 1); we call them root-only trees.</p><p>Example 2.9. Consider the simple abstract tree with a root labeled α and two children labeled β and γ respectively represented here with the root at the top:</p><formula xml:id="formula_8">α β γ</formula><p>In the four signatures introduced, this tree can be represented as the following collection of facts:</p><p>all four signatures Root(r ), Label α (r ), Label β (f ), Leaf(f ), Label γ (s), Leaf(s)</p></div>
<div><head>S bin</head><p>Ch1,Ch2 <software>FirstChild</software>(r, f ), <software ContextAttributes="used">SecondChild</software>(r, s) S bin Ch1,Ch2,Child <software ContextAttributes="used">FirstChild</software>(r, f ), <software ContextAttributes="used">SecondChild</software>(r, s), Child(r, f ), Child(r, s) S bin Ch1,Ch2,Child,Child ? <software ContextAttributes="used">FirstChild</software>(r, f ), <software ContextAttributes="used">SecondChild</software>(r, s), Child(r, f ), Child(r, s), Child ? (r, r ), Child ? (f , f ), Child ? (s, s), Child ? (r, f ), Child ? (r, s) S unranked Child Child(r, f ), Child(r, s)</p><p>We will consider several methods for defining families of trees, in particular tree automata and document type definitions (DTDs). We define them formally in the binary case. Definition 2.10. A nondeterministic tree automaton on binary trees (or BNTA) over finite alphabet Λ is of the form (Ω, ∆ 0 , ∆, F ), where Ω (the control states) is a finite set, ∆ 0 ⊂ Λ × Ω, ∆ ⊂ Ω 2 × Λ × Ω, and F ⊂ Ω. A run ρ of a BNTA over a Λ-labeled binary tree is an assignment of states to nodes. A run is accepting if for all leaves l labeled with α ∈ Λ, (α, ρ(l)) ∈ ∆ 0 ; the root is assigned a state in F ; and if n has left and right children n 1 and n 2 respectively and label α, then (ρ(n 1 ), ρ(n 2 ), α, ρ(n)) ∈ ∆.</p><p>A deterministic tree automaton on binary trees (BDTA) over Λ is a BNTA in which for every (q 1 , q 2 , a) ∈ Ω 2 × Λ, there is at most one q such that (q 1 , q 2 , a, q) ∈ ∆.</p><p>The set of all binary trees having an accepting run of BNTA A is the language of A, noted L(A). Such a language is then said to be regular.</p><p>A nondeterministic tree automaton over ranked trees (NTA Rk ) is defined similarly, but with ∆ ⊂ i⩽r Ω i × Λ × Ω for some r . Such an automaton expects trees in which the outdegree of each vertex is at most r . The notion of deterministic tree automaton over ranked trees (DTA Rk ), the language of such an automaton, and regularity of a language of ranked trees is defined analogously to above. We will also make use of the corresponding notion of nondeterministic tree automaton over unranked trees, NTA Unr and of a regular language for unranked trees, see <ref type="bibr" target="#b24">[25]</ref>. We will not need to know the definition of a NTA Unr , since most of the results involving NTA Unr will come from prior work. We will use the following simple facts relating NTA Unr to their ranked counterparts:</p><p>• A BNTA, and more generally an NTA Rk , is a special case of a NTA Unr , since we can enforce a restriction on the rank with an automaton. • A witness for the non-emptiness of an NTA Unr A can always be taken to have rank polynomial in the size of A. This can be shown by just "trimming" a witness. A DTD for binary trees over Λ (BDTD) is a pair (d, l 0 ) where d is a function from Λ to 2 (Λ×Λ)∪{ε } giving the constraints over the labels of the children of a node; l 0 , an element of Λ, is the root label. A binary tree t is accepted by a BDTD (d, l 0 ) if (i) for any node n labeled a, if n is a leaf then ε ∈ d(a) and, otherwise, if b and c are the labels of the first and second children of n then (b, c) ∈ d(a); (ii) the root of t is labeled by l 0 . The set of all trees accepted by a BDTD D is the language of D, noted L(D). The standard notion of a DTD <ref type="bibr" target="#b27">[28]</ref> is for unranked trees. For clarity and to keep a uniform notation we refer to these as UDTDs. For these, d is a function from Λ to regular expressions over Λ. The notion of acceptance of an unranked tree by a UDTD is standard, and we will not have need of it here. We will need the well-known and simple fact that BDTDs can be turned into BNTAs accepting the same language in linear time, and similarly for the unranked case. Definition 2.11. A query on one of the signatures is valid over an automaton or DTD appropriate for that signature (e.g., BNTA or BDTD for a signature for binary trees) if for all trees that satisfy the schema, the query returns true. A query is valid with respect to a set of node labels if the query returns true on all trees over that set of node labels.</p></div>
<div><head n="2.4">Limited Access Patterns</head><p>An important area where monadic datalog programs arise is that of querying under access constraints <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b28">29]</ref>, also known as querying under limited access patterns, or, simply limited access querying. We recall basic notions from these works.</p><p>Access methods. Given a relational schema, we consider a set of access methods</p><formula xml:id="formula_9">ACS = { AcM 1 . . . AcM m }</formula><p>with each AcM i consisting of a source relation Rel(AcM i ) and a set InputAtt(AcM i ) of input positions from the set of positions of Rel(AcM i ); intuitively, each access method allows one to put in a tuple of values for InputAtt(AcM i ) and get as a result a set of matching tuples. A position of R that is not an input position of a method AcM is an output position of AcM. As mentioned in the introduction, we assume that all attributes have the same domain; we do not consider separate abstract domains per attribute.</p><p>A combination of an access method and a binding to the input places of the accessed relation will be referred to as an access. We will often write an access by adding "?" to the non-input places, omitting the exact method: e.g., R(3, ?) is an access (via some method) to R with the first place bound to 3. If R does not have any output positions, we say that it is a Boolean access, and we write for instance R(3, 4)? for an access that checks whether (3, 4) ∈ R. If R does not have any input positions, we say that it is a free access. In particular, free accesses can serve to model some initial facts (or some initial data values) that are known before making any access.</p><p>We also assume, following the literature, <ref type="foot" target="#foot_1">1</ref> that each relation has exactly one access methodallowing relations with no access would not make any difference in our setting, as they would make queries using them unanswerable.</p><p>Given a set of access methods and an instance I over signature σ , we define a sequence of values AccValues k (I ) and a sequence of facts AccFacts k (I ) by mutual induction as follows:</p><formula xml:id="formula_10">• AccValues 0 (I ) = ∅; • For k ⩾ 0: AccFacts k (I ) = AcM∈ACS {j 1 ...j m }=InputAtt(AcM) v 1 ,...,v m ∈AccValues k (I ) σ #j 1 =v 1 ∧•••∧#j m =v m (Rel(AcM)) (I ); • For k ⩾ 0, AccValues k+1 (I ) = dom(AccFacts k (I )).</formula><p>We denote AccValues(I ) and AccFacts(I ), respectively, the fixpoint of these two sequences.</p><p>Containment under access constraints. We now give the formal definition of containment under limited access patterns. Definition 2.12. Let Q and Q ′ be two queries over the relational schema.</p><formula xml:id="formula_11">Q is contained in Q ′ under the access methods of ACS if, for every instance, I Q(AccFacts(I )) ⊆ Q ′ (AccFacts(I )).</formula><p>Example 2.13. We consider again the same signature as in Example 2.1: a binary relation G and two unary relations S and T . Assume that the access methods consist on a free access to relation R, an access with input on the first position for relation G, and a Boolean access on relation T .</p><p>Then, under these access methods, the CQ ∃x T (x) is contained in the UCQ :</p><formula xml:id="formula_12">(∃x T (x) ∧ R(x)) ∨ (∃x ′ ∃y ′ T (y ′ ) ∧ G(x ′ , y ′ )).</formula><p>Indeed, the only way to make an access to relation T is for the value bound to be accessible, which is only possible if it has been produced by the free access to relation R or by an access to relation G, with first position bound to an accessible value.</p><p>As mentioned in the introduction, containment under limited accesses is strongly related to containment of monadic datalog queries <ref type="bibr" target="#b25">[26]</ref>, in a manner that we now explain. Assume that Q and Q ′ are Boolean UCQs. Then containment of Q in Q ′ under ACS can be reduced to the containment of a monadic datalog query P in Q ′ . We write Q = k i=1 φ i (x i ) with the φ i (x i ) conjunctions of atoms. The monadic datalog query P makes use of an intensional predicate AccValues and is formed of the following rules:</p><formula xml:id="formula_13">Goal() ← φ i (x i ) ∧ j AccValues(x i,j ) for 1 ⩽ i ⩽ k (1) AccValues(x j ) ← Rel(AcM ℓ )(x) ∧ i ∈InputAtt(AcM k ) AccValues(x i )<label>(2)</label></formula><p>for every 1 ⩽ ℓ ⩽ m, and output position j of AcM ℓ .</p><p>Note that if we were to deal with abstract domains, these rules would change to include a predicate AccValues τ for each abstract domain τ .</p><p>Example 2.14. The monadic datalog program resulting of the rewriting of query ∃x T (x) for the access methods of Example 2.13 is:</p><formula xml:id="formula_14">Goal() ← T (x) ∧ AccValues(x) AccValues(y) ← G(x, y) ∧ AccValues(x) AccValues(x) ← R(x) Note that this is exactly the program of Example 2.2.</formula><p>From the previous discussion and Proposition 2.6, we derive immediately: Corollary 2.15. If a UCQ Q is not contained in a UCQ Q ′ under a set of access constraints, then there exists a monadic expansion tree I that is a model of the <software>MDL</software> query P associated to Q under the access constraints, such that I satisfies Q ∧ ¬Q ′ .</p><p>We now have all the necessary elements to state the main results proved in this work.</p></div>
<div><head n="3">STATEMENT OF THE MAIN RESULTS</head><p>In this paper we study three problems of interest, with strong connections: containment of monadic datalog, validity problems on trees, and containment of UCQs under access constraints.</p><p>Though the connection between monadic datalog and querying under limited accesses is wellknown <ref type="bibr" target="#b25">[26]</ref>, one major contribution of this work is to highlight the connection to tree validity problems.</p><p>In Section 4, we present upper bounds, by providing a technique for giving EXPTIME upper bounds on certain variations of both the tree validity problem and the query containment problems.</p><p>In our lower bound section (Section 5), we prove 2EXPTIME and EXPTIME lower bounds for different variants of the tree validity problem. The technique here is to adapt ideas from <ref type="bibr" target="#b8">[9]</ref>. We then use a reduction from tree validity to <software ContextAttributes="used">MDL</software> containment (given in the proof of Theorem 5.10) that allows us to push the 2EXPTIME lower bound to the <software ContextAttributes="used">MDL</software> containment problem, and another reduction (given in the proof of Theorem 5.11) that allows us to push EXPTIME hardness from tree validity to containment under access constraints.</p><p>Let us now briefly review the currently known bounds, as well as the results proved here, on tree validity and query containment.</p></div>
<div><head n="3.1">Results on Tree Validity Problems</head><p>We begin by overviewing results on tree validity that are either explicitly in prior work, can be derived with little effort from prior work, or are easy to derive directly. The discussion here will be quite abbreviated, but it does not concern the main results of the paper.</p><p>We first note that validity over all trees is tractable for CQs: Proposition 3.1. Determining if a CQ is valid over all trees for a given label set can be done in PTIME over S unranked Child , S bin Ch1,Ch2 , S bin Ch1,Ch2,Child , and S bin Ch1,Ch2,Child,Child ? . Proof. We claim a CQ Q is valid if and only if the following conditions are all satisfied: (i) it does not contain any <software>FirstChild</software>, <software ContextAttributes="used">SecondChild</software>, or Child atom;</p><p>(ii) either it does not contain any Label α atom or |Λ| = 1; (iii) there are no (possibly identical) variables x 1 , x 2 such that (x 1 , x 2 ) is in the reflective transitive symmetric closure of the set of pairs of variables appearing in a Child ? atom, and such that Root(x 1 ) and Leaf(x 2 ) appear in Q. Indeed, if any of these conditions is not satisfied, Q is not valid: (i) any root-only tree is a counterexample; (ii) any tree with no node of that label is a counterexample; (iii) any tree formed of a single chain of nodes of length greater than the number of Child ? atoms plus 1 is a counterexample. Conversely, if T is an arbitrary tree and Q satisfies (i)-(iii), mapping every query variable of Q to the root of the tree if the connected component of that variable does not include any Leaf atom, and to an arbitrary leaf of the tree otherwise, yields a homomorphism. Indeed, we know that Q contains only Root, Leaf, and Child ? atoms, and that in each connected component of Q there cannot be both a Root and Leaf atom. □</p><p>Apart from this very special case, the best upper bound known for the tree validity problems we consider is 2EXPTIME. Indeed, in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr">Theorem 11]</ref>, validity of a query over S unranked Child with respect to an NTA Unr was shown to be in 2EXPTIME for CQs. This 2EXPTIME upper bound actually holds for all considered problems on tree validity. For most of our signatures, such a bound can be obtained as follows. Convert the UCQ Q to an exponential-sized tree automaton (e.g., BNTA for signatures appropriate to binary trees) A Q in exponential time. See, for example, [2, Proposition B.1] for this conversion. Then using standard automata techniques <ref type="bibr" target="#b20">[21]</ref> we can determinize A Q in exponential time, complement it, and intersect it with the automaton representing the schema in polynomial time. Finally, we can test the resulting automaton for emptiness in polynomial time.</p></div>
<div><head>In the case of S bin</head><p>Ch1,Ch2,Child,Child ? , we first convert a UCQ Q over S bin Ch1,Ch2,Child,Child ? to a positive existential query Q ′ over S bin Ch1,Ch2,Child . The query Q ′ can be converted in exponential time to an alternating automaton over trees. The construction is a standard induction: the atoms are converted to automata that work over trees with the free variables annotated on the tree. Conjunction and disjunction are done using the closure properties of alternating automata, which allow positive Boolean combinations in the transition function. Existential quantification can be assumed to be outermost, and requires projecting out the annotations. This can be done by converting the alternating automaton to a nondeterministic automaton in exponential time; for nondeterministic automata the projection step is straightforward. Emptiness of alternating automata can be checked in exponential time <ref type="bibr" target="#b20">[21]</ref>, which gives the 2EXPTIME bound.</p><p>Let us now discuss existing lower bounds. The validity problem with respect to DTDs over S unranked Child has been studied in <ref type="bibr" target="#b8">[9]</ref>. <ref type="bibr" target="#b8">[9,</ref><ref type="bibr">Theorem 12]</ref> shows that the validity problem for S unranked Child is EXPTIME-hard for child-only tree-pattern queries. Given that one can convert these straightforwardly Table <ref type="table">1</ref>. Summary of results on the complexity of tree validity of CQs and UCQs, over various tree signatures and with respect to DTDs, tree automata, or all trees Previously known results <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> and straightforward arguments from Section 3.1 (in particular, Proposition 3.1 for PTIME results)</p><formula xml:id="formula_15">CQ UCQ CQ UCQ Signature</formula><p>(DTD or tree automaton) (DTD or tree automaton) (all trees) (all trees)</p><formula xml:id="formula_16">S unranked Child EXPTIME-hard, in 2EXPTIME EXPTIME-hard, in 2EXPTIME PTIME in 2EXPTIME S bin Ch1,Ch2 in 2EXPTIME in 2EXPTIME PTIME in 2EXPTIME S bin Ch1,Ch2,Child EXPTIME-hard, in 2EXPTIME EXPTIME-hard, in 2EXPTIME PTIME in 2EXPTIME S bin Ch1,Ch2,Child,Child ? EXPTIME-hard, in 2EXPTIME EXPTIME-hard, in 2EXPTIME PTIME in 2EXPTIME</formula><p>Results proved in Sections 4 (upper bounds) and 5 (lower bounds).</p><p>We give references to statements proving the bounds; lower bounds w.r.t. tree automata are transferred to lower bounds w.r. to CQs, we obtain EXPTIME-hardness of the validity problem for CQs (and thus UCQs) with respect to UDTD and NTA Unr . Inspection of prior work easily shows the lower bound carries over to the S bin Ch1,Ch2,Child signature and, consequently, to the S bin Ch1,Ch2,Child,Child ? signature, as we now explain. Theorem 12 of <ref type="bibr" target="#b8">[9]</ref> relies on Theorem 11 in the same paper, whose proof involves a reduction from finding a winning strategy in a game on tiling systems <ref type="bibr" target="#b19">[20,</ref><ref type="bibr">Rectangle Tiling Game]</ref>. Critically, the number of possible moves in this strategy is bounded, by the number of different tiles, which is fixed. Thus the trees involved in the hardness proof are actually ranked. Now, we use a standard encoding of b-ranked trees as binary trees where every node n with at most b children is replaced with a binary subtree of height exactly ⌈log 2 (b)⌉ whose leaves are the children of n. This means that, in the CQ, we replace every Child atom with a chain of ⌈log 2 (b)⌉ child atoms. In the DTD, we enumerate the bounded number of possible words for the labels of children of every node label, and choose fresh node labels for every such possible word and every position in the binary tree encoding the unranked Child relation. It then becomes easy to transform the UDTD on unranked trees into a BDTD on the encoded binary trees.</p><p>This concludes our discussion of the state of the art prior to our work. Table <ref type="table">1</ref> (upper) summarizes the results that can be derived from <ref type="bibr" target="#b8">[9]</ref> and from the other arguments given so far in this section. In the table, we have abbreviated "all trees in a given label set" by "all trees".</p><p>In this work, we establish tight complexity bounds for the validity of CQs and UCQs over all four tree signatures introduced (S unranked Child , S bin Ch1,Ch2 , S bin Ch1,Ch2,Child , and S bin Ch1,Ch2,Child,Child ? ) with respect to DTDs, tree automata, and over all trees. The results are summarized in Table <ref type="table">1</ref> (lower). The ) and EXPTIME-completeness (for the other three signatures).</p></div>
<div><head n="3.2">Results on Containment for MDL and Access Constraints</head><p>Recall that containment of <software ContextAttributes="used">MDL</software> queries in UCQs is in 2EXPTIME by <ref type="bibr" target="#b21">[22]</ref> (indeed, this holds also for containment of two <software ContextAttributes="used">MDL</software> queries <ref type="bibr" target="#b21">[22]</ref> or for Datalog in UCQs <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b18">19]</ref>). In this paper we show that this problem is 2EXPTIME-hard, thus obtaining a tight characterization of its complexity.</p><p>In contrast, we show that containment of UCQs under access constraints is EXPTIME-complete. Both the upper and lower bound here are non-trivial. We will also display a subset of <software>MDL</software>, <software ContextAttributes="used">AGEMDL</software>, that exhibits the same behavior. In an <software ContextAttributes="used">AGEMDL</software> query, the goal predicate never occurs in the body of a rule, and every extensional predicate has only one occurrence in a rule other than a rule for the goal predicate. We will see that this restriction of <software ContextAttributes="used">MDL</software> to obtain EXPTIME-completeness is somewhat robust: if we allow a bounded number of occurrences of every extensional predicate except of just one (we call k-<software ContextAttributes="used">GEMDL</software> the corresponding fragment of <software ContextAttributes="used">MDL</software>, where k is the bound), the complexity of containment jumps back to 2EXPTIME-complete.</p><p>Table <ref type="table" target="#tab_2">2</ref> summarizes these results and provides references to the corresponding theorems.</p></div>
<div><head n="4">UPPER BOUNDS</head><p>In a first step, this section will introduce the main upper bound technique of the paper (Sections 4.1 to 4.3). It consists of machinery for showing that certain containment problems have exponentialsized counterexamples, based on analysis of models that are monadic expansion trees. We will then show (Section 4.4) that the machinery gives new bounds for tree validity problems. We will also show (Section 4.5) that it can be used to obtain new bounds for containment under access constraints, by reduction from a bound on the <software>AGEMDL</software> fragment of <software ContextAttributes="used">MDL</software>, introduced there.</p><p>Our machinery revisits the argument showing the 2EXPTIME upper bound of containment of arbitrary datalog queries in UCQs. This result is proved in <ref type="bibr" target="#b18">[19]</ref>, as Theorem 5.15 of that paper.</p><p>By Proposition 2.6, since we are dealing with monadic datalog queries here, we can restrict ourselves to monadic expansion trees. We introduce in Section 4.1 a notion of "interface queries" used to define a type over the nodes of a monadic expansion tree, called IQ-type (Definition 4.5). We show that IQ-types are enough to characterize monadic expansion trees that are counterexamples to containment, with the use of automata techniques (Theorem 4.10). This allows us to bound the size of a minimal counterexample by the number of IQ-types (see Section 4.2). We show how this yields a generic recipe for getting bounds on the containment problem, by highlighting a property of some classes of instances (the unique mapping condition, see Section 4.3) that guarantees a bound on the number of IQ-types.</p></div>
<div><head n="4.1">IQ-types</head><p>How big does a monadic expansion tree that is a counterexample to containment of Q into Q ′ need to be? Clearly it needs to be big enough to witness satisfaction of Q, but the main issue is how big it needs to be to witness non-satisfaction of Q ′ . Intuitively, one only needs nodes that represent the different kinds of behavior with respect to Q ′ . A crude notion of "same behavior" w.r.t. Q ′ would be to identify a node with the collection of subqueries that simultaneously hold at that node. Such an abstraction would easily lead to a doubly-exponential bound on the size of a counterexample to containment. Our main contribution in this section is a finer notion of similarity that takes advantage of the restricted structure of monadic expansion trees. Intuitively, we do not care about all subqueries that map to a node, but only about the way that the subqueries impact what is happening at other nodes. Given a subinstance corresponding to a subtree of the monadic expansion tree, we can capture that interaction by the restriction of the mapping of query variables of Q ′ to the root of this subtree. We can thus think of fixing a "root interface". Naively, our root interface would require us to specify the mapping to the root bag completely. Instead we allow ourselves to fix only two things: (1) the set of variables that map to the output element of the root;</p><p>(2) for each set of variables at a time, for each connected component of Q ′ disregarding this set of variables, information about whether the corresponding query is satisfied in the subinstance. We formalize this idea of satisfied "interface queries" through the notion of IQ-types.</p><p>4.1.1 Definitions. We recall that the tree structure associated with a monadic expansion tree is denoted by T(I ). Definition 4.1. Let I be a monadic expansion tree and n a node of T(I ). The subinstance of I rooted at n is the set of facts contained in the bags of n and its descendants.</p><p>The queries defining IQ-types have to map the facts belonging to bags of descendants of a node in a particular way, given by the notion of relative homomorphism below. Definition 4.2. Let q ′ be a conjunctive query and X a subset of the variables of q ′ . Let I be a monadic expansion tree and n a node of T(I ). A relative homomorphism h from the pair (X, q ′ ) to the subinstance rooted at n is a function from the variables of q ′ to the active domain of the subinstance rooted at n such that:</p><p>(i) the set of variables mapped to the output element of n by h is equal to X ; (ii) h(q ′ ) is included in the subinstance rooted at n;</p><p>(iii) at least one of the facts of h(q ′ ) is included in the bag of n.</p><p>Note that if X is non-empty, the third condition is trivially satisfied: a fact that includes a variable in X is necessarily in the bag of n.</p><p>For connected queries, the existence of a homomorphism in the usual sense implies the existence of a relative homomorphism: Lemma 4.3. Let q ′ be a connected conjunctive query. A monadic expansion tree I satisfies q ′ if and only if there exist a node n ∈ T(I ), a subset X of the variables of q ′ , and a relative homomorphism from (X, q ′ ) to the subinstance rooted at n. Proof. The "if" part is obvious: a relative homomorphism from (X, q ′ ) to the subinstance rooted at n is in particular a homomorphism from q ′ to I .</p><p>Let h be a homomorphism from q ′ to I . Let n be the least common ancestor of all nodes of T(I ) having in their bag a fact of h(q ′ ). We let X be the (possibly empty) set of variables mapped to the output element of n by h. Observe that one fact of h(q ′ ) is in the bag of n. Indeed, q ′ being connected, the bags containing facts of h(q ′ ) form a connected subtree of T(I ); n is the root of this subtree. Therefore, h is a relative homomorphism from (X, q ′ ) to the subinstance rooted at n. □</p><p>In order to define IQ-types, we need a few further definitions. As explained above, IQ-types define some root interface using a set of queries. The definition of these queries is given below. Definition 4.4. Given a UCQ Q ′ , and a subset X of the variables of Q ′ , a subquery q ′ of Q ′ covers X if for each variable x in X , there exists an atom of q ′ containing x.</p><p>A subquery q ′ of Q ′ is closed relative to X if, whenever q ′ contains one atom with a variable x not in X then q ′ contains all atoms of Q ′ containing x. (Recall that since we only consider Boolean queries, we assume that a variable is not reused across CQs of a UCQ.)</p><p>A subquery q ′ of Q ′ is connected relative to X iff for each atom α 1 and α 2 in q ′ , there exist two variables x 1 in α 1 and x 2 in α 2 , both not in X , such that there is a path of variables not in X from x 1 to x 2 , where the path is in the graph connecting two variables if they co-occur in an atom of q ′ . Note that we allow degenerate paths that consist of a single variable</p><formula xml:id="formula_17">x 1 = x 2 .</formula><p>A maximal connected component of a query relative to X is a closed and connected subquery relative to X that covers X . Note that if the set of variables X is empty, a maximal connected component of Q ′ relative to X is a maximal connected component in the usual sense; we let MCC(Q) be the set of maximal connected components of a query Q.</p><p>We now use relative homomorphisms and maximal connected components to define types of a node in a monadic expansion tree. Definition 4.5. Let Q ′ be a UCQ. A pair (X, q ′ ), where q ′ is a subquery of Q ′ and X a subset of the variables of</p><formula xml:id="formula_18">Q ′ , is a type element of Q ′ iff q ′ is a maximal connected component of Q ′ relative to X .</formula><p>Let I be a monadic expansion tree and n a node of T(I ). A type element (X, q ′ ) is satisfied by a node n iff there exists a relative homomorphism from (X, q ′ ) to the subinstance rooted at n.</p><p>The IQ-type of a node n with respect to Q ′ , denoted by type Q ′ (n), is the set of all type elements satisfied by n. This notion of IQ-type will be used to characterize instances that satisfy a given query.</p><p>Example 4.6. To illustrate the notion of type element, consider the query</p><formula xml:id="formula_19">Q ′ = ∃x∃y∃z C(x) ∧ R(x, y) ∧ R(y, z) ∧ C(z)</formula><p>We consider the following pairs consisting of a set of variables and a set of atoms from Q ′ :</p><formula xml:id="formula_20">T 1 = ({x, z}, {R(x, y), R(y, z)}) T 2 = ({x }, {R(x, y), R(y, z), C(z)})</formula><p>We claim that both T 1 and T 2 are type elements of Q ′ . We argue that the set of atoms of T 1 is closed and connected relative to the set of variables in T 1 , and similarly for T 2 . We give the argument for T 2 , with the one for T 1 being similar. T 2 is connected relative to {x } since all pairs of atoms are connected by a path of variables different from x: the two R atoms are connected through y, the second R atom and the C atom through z, and the first R atom and the C atom through z and y. To verify relative closedness of T 2 we need only notice that T 2 contains every atom containing z and every atom containing y.</p></div>
<div><head n="4.1.2">Composition</head><p>Lemma. We now introduce an important lemma, the composition lemma, critical to the soundness of our technique for finding monadic-expansion-tree counterexamples to containment of bounded size. Definition 4.7. Let I and I ′ be two monadic expansion trees and n and n ′ two nodes of T(I ) and T(I ′ ), respectively. A bijection φ from the values of n to the values of n ′ is an output-isomorphism iff (i) it is an isomorphism, i.e., for each atom R(a ′ 1 . . . a ′ k ) in n ′ there exists exactly one atom R(a 1 . . . a k ) in n such that φ(a i ) = a ′ i for all 1 ⩽ i ⩽ k; (ii) child ordering is preserved: if v is the output element of the jth child of n, then φ(v) is the output element of the jth child of n ′ ; (iii) the output element of n maps to the output element of n ′ . Two nodes n and n ′ are output-isomorphic iff there exists an output-isomorphism from the values of n to the values of n ′ .</p><p>We now state our composition lemma: the IQ-type of a node is determined by its bag of facts (up to output-isomorphism) and the IQ-types of its children. </p><formula xml:id="formula_21">′ c , type Q ′ (n c ) = type Q ′ (n ′ c ). Then type Q ′ (n) = type Q ′ (n ′ ). Proof. We denote n 1 . . . n k the children of n; n ′ 1 . . . n ′ k the children of n ′ .</formula><p>We suppose that for each 1 ⩽ i ⩽ k, the IQ-types of n i and n ′ i with respect to Q ′ are the same and that if v is the output element of n i then φ(v) is the output element of n ′ i . We demonstrate that type Q ′ (n ′ ) ⊆ type Q ′ (n): for any subset of variables X of Q ′ and for any maximal connected component q ′ of Q ′ relative to X , if there exists a relative homomorphism from (X, q ′ ) to the subtree rooted at n then there exists a relative homomorphism from (X, q ′ ) to the subtree rooted at n ′ . The other direction is implied by the symmetry of the roles of n and n ′ .</p><p>Let X be a subset of the variables of Q ′ and q ′ be a maximal connected component of Q ′ relative to X . Let h be a relative homomorphism from (X, q ′ ) to the subtree rooted at n. We need to create a homomorphism h ′ from (X, q ′ ) to the subtree rooted at n ′ .</p><p>For 1 ⩽ i ⩽ k we denote by q ′ i the maximal subquery mapped by h to the subinstance rooted at n i . Let A be the set of integers i with 1 ⩽ i ⩽ k such that q ′ i is non-empty. For i ∈ A, let X i be the subset of variables of q ′ i such that the image of X i by h is the output element of n i . We claim that (X i , q ′ i ) is a type element of Q ′ , by exploiting the structure of monadic expansion trees:</p><p>• q ′ i is closed relative to X i : since every variable x of q ′ i not in X i maps to values in the subinstance rooted at n i , all atoms of q ′ containing x are mapped to the subinstance rooted at n i ; • q ′ i is connected relative to X i , since q ′ is connected relative to X and every path of atoms between variables of q ′ i not in X i must be entirely in the subinstance rooted at n i . Furthermore, q ′ i covers X i by definition of X i . Hence, (X, q ′ i ) is a type element of Q ′ . Let α be an atom mapped by h to the bag of n (such an α necessarily exists by the definition of a relative homomorphism) and α i mapped by h to the subtree rooted at n i . Since q ′ is connected relative to X , there exists a path between α and α i , which translates into a path between h(α) and h(α i ) that necessarily involves the output element of n i due to the monadic expansion tree structure of the instance, and thus a fact within the bag of n i . We have thus shown that the restriction h i of h to the variables of q ′ i is a relative homomorphism from (X i , q ′ i ) to the subtree rooted at n i . In other words,</p><formula xml:id="formula_22">(X i , q ′ i ) ∈ type Q ′ (n i ). Since type Q ′ (n i ) = type Q ′ (n ′ i )</formula><p>, there exists a homomorphism h ′ i from (X i , q ′ i ) to the subtree rooted at n ′ i . We then define h ′ (x) as follows: if h(x) is a value present in a subinstance rooted at some n i for</p><formula xml:id="formula_23">i ∈ A, we set h ′ (x) := h ′ i (x); if h(x) is a value of bag(n), we set h ′ (x) := φ(h(x)</formula><p>). This definition is well formed: the subinstances rooted at n i and n j do not share any common value, and any value shared between the bag of n and the subinstance rooted at n i must be the output element of n i . The requirement that φ preserves child ordering ensures that the output element of any n i in the domain of φ is mapped to the output element of n ′ i . Thus we know that for any variable x ∈ X i ,</p><formula xml:id="formula_24">h ′ i (x) = φ(h(x)).</formula><p>Let α be any atom of q ′ . Since h is a relative homomorphism from (X, q ′ ) to the subtree rooted at n, h(α) is either in bag(n) (and there is at least one such α) or in one of the subinstance rooted at one of the n i for i ∈ A. In the former case, h ′ (α) = φ(h(α)) ∈ bag(n ′ ). In the latter case, h ′ (α) = h ′ i (α), which is in the subinstance rooted at n ′ i . In addition, since φ is an output-isomorphism, the only variables mapped to the output element of n ′ by h ′ are the variables mapped to the output element of n by h, i.e., the set X . In other words, h ′ is a relative homomorphism from (X, q ′ ) to the subtree rooted at n ′ . □ 4.1.3 From IQ-Types to Automata. We now explain how to see IQ-types as states of a tree automaton operating on monadic expansion trees. This will allow us to see the containment problem in terms of tree automata and derive upper bounds from there. More specifically, IQ-types capture the "state" of a node in a monadic expansion tree with respect to a query: they can be used as states in a deterministic ranked tree automaton that accepts monadic expansion trees not satisfying a given query. Then, the number of IQ-types with respect to a given query will have a direct impact on the size of the tree automaton, and from there on the complexity of the containment problem. We emphasize that the ability to use IQ-types to form such an automaton relies on some general properties such as the Composition Lemma, not on the fine details of IQ-types. These details will come into play later -in Section 4.4 and Section 4.5, when we want to argue that in certain situations we have a tighter bound on the number of IQ-types, and hence a tighter bound on the size of the automaton.</p><p>Let σ be a relational signature and d a positive integer. We denote by L(d, σ ) the set of monadic expansion trees over σ with at most d facts in the bag of each node.  A collection of monadic expansion trees is said to be regular if it is d-regular for some d.</p><formula xml:id="formula_25">O |σ | d + O(d • |σ |) O (d • |σ |) = O χ d • |σ |</formula><p>Let I be a regular set of monadic expansion trees. Let Q ′ be a connected conjunctive query (we will consider the case of arbitrary UCQs further on). We reduce the problem of validity of Q ′ over a regular set of monadic expansion trees I to the emptiness of a tree automaton. More precisely, we build a deterministic ranked tree automaton A Q ′ over Γ(d, σ ) such that the intersection of A Q ′ and</p><formula xml:id="formula_26">A I recognizes exactly the set { Code d (I ) | I ∈ I ∧ I ̸ |= Q ′ }.</formula><p>Intuitively, the states of A Q ′ are the types of nodes of instances of I which cover Q ′ . We will use Lemma 4.8 to calculate the transition function.</p><p>The theorem below formalizes this intuition:</p><p>Theorem 4.10. Consider a signature σ , a positive integer d, and let I be a d-regular set of monadic expansion trees recognized by the ranked deterministic tree automaton A I . Let Q ′ be a connected conjunctive query.</p><p>There exists a DTA Rk A Q ′ over the alphabet Γ(d, σ ), such that A Q ′ ∩ A I accepts the set of all Code d (I ) with I ∈ I not satisfying Q ′ . Moreover, the size of σ ) where Y is the set of IQ-types with respect to Q ′ of nodes of some instances of I.</p><formula xml:id="formula_27">A Q ′ is in O |Y| poly(d ,</formula><p>Finally, if one is given a superset Z of Y, then we can compute</p><formula xml:id="formula_28">A Q ′ in time O |Z| poly(d , |σ |, |Q ′ |) .</formula><p>Before we go into the details of the automaton, we classify the types that correspond to good (accepting) and bad (rejecting) states. Definition 4.11. Let Q ′ be a conjunctive query, Q ′′ a subquery of Q ′ , and τ an IQ-type with respect to Q ′ . We say that τ covers Q ′′ if τ contains type elements (X, q 1 ) . . . (X, q n ) for some set of variables X and subqueries q 1 . . . q n that together contain each atom of Q ′′ .</p><p>We note the following simple consequence of Lemma 4.3: Proposition 4.12. A monadic expansion tree I satisfies a subquery Q ′′ of a connected conjunctive query Q ′ iff it contains a node n whose IQ-type with respect to Q ′ covers Q ′′ .</p><p>Proof. Clearly if τ covers Q ′′ , then a monadic expansion tree I having a node with type τ must satisfy Q ′′ . Conversely, if I satisfies Q ′′ , by Lemma 4.3 there is a set X , a node n, and a relative homomorphism h from (Q ′′ , X ) to n. Let q 1 . . . q n be the maximal connected components of Q ′′ relative to X . Then h also serves as a relative homomorphism of each (X, q i ) to n, while each q i is closed and connected relative to X , hence is a valid type element. Thus (X, q 1 ) . . . (X, q n ) witness that τ covers Q ′′ . □</p><p>Thus types that cover Q ′ will be the "bad states" of our automaton.</p><p>Proof of Theorem 4.10. We denote by Y ¬Q ′ ⊆ Y the set of IQ-types τ with respect to Q ′ of nodes of some instances of I such that Q ′ is not covered by τ . We will construct a deterministic automaton A Q ′ whose set of states is Y ¬Q ′ . IQ-types not in Y ¬Q ′ can be seen as leading directly to rejection (i.e., are not co-accessible), and thus need not be made explicit in a trimmed automaton. In the variant where we are given Z ⊇ Y, we will instead use the set  <ref type="figure">d,</ref><ref type="figure">σ</ref> ). The result of δ (l, α) is determined in the following manner. Let n be a node in an instance I of I with output-isomorphism class α and having a list of children whose types match those of l. If there exists an X such that (X, Q ′ ) is satisfied by n, the transition is not defined. The outcome of the transition is the type τ of n, if τ does not cover Q ′ ; otherwise, the transition is undefined. Lemma 4.8 guarantees that this transition function is well-defined: the type of a node only depends on the types of the children of this node and its output-isomorphism class. We set all states of the automaton to be final.</p><formula xml:id="formula_29">Z ¬Q ′ ⊇ Y ¬Q ′ of types τ in Z that do not cover Q ′ . Since I ⊆ L(d, σ ),</formula><p>Let I be an arbitrary instance in I. Let us show by induction on the structure of Code d (I ) that A Q ′ assigns a state τ to a node u of Code d (I ) if and only if Q ′ is not satisfied in the subinstance rooted at the corresponding node n of T(I ) and that, in the case where a state τ is assigned, τ = type Q ′ (n). Assume this is true for all descendant of a node of u coding a node n in T(I ). Assume now u is assigned state τ (and thus, τ does not cover Q ′ ). It follows from the induction hypothesis that the children have as their state assignment in the coded instance their type, and by definition of the transition function, τ = type Q ′ (n). Since the subinstance rooted at n does not contain any node whose IQ-type covers Q ′ , according to Proposition 4.12, it does not satisfy Q ′ . Conversely, the only case where a transition is not defined at a node u is when there exists an X such that (X, Q ′ ) is satisfied by a node n coded by u.</p><p>We prove the equivalence between acceptance by A ′ Q ∩ A I and being the code of an instance of I not satisfying Q ′ . First, let I be a monadic expansion tree having its code Code d (I ) accepted by A Q ′ and A I . Thus I is in I. Suppose by way of contradiction that I satisfies Q ′ . Due to Proposition 4.12, there exists a node n of T(I ) whose type τ covers Q ′ . But then A Q ′ would have to reach a state corresponding to τ , which is impossible, since no such states are in Y ¬Q ′ , which is the set of states of our automaton. Conversely, let I be a monadic expansion tree in I not satisfying Q ′ . The inductive argument above shows that A Q ′ accepts I , and we know that A I also does. σ ) . Indeed, the size of the automaton is dominated by the size of its transition function. This transition function takes a sequence of states of the automaton and a symbol of the alphabet and returns a state of the automaton. The maximal length of the sequence is equal to the rank of the instance, which is bounded by O(d • |σ |). Moreover, the states of the automaton are the possible types of I which is equal to Y. Finally, each symbol of the alphabet is an element of Γ(d, σ ), by definition. We finally obtain a bound of O |B(d, σ )| × |Y| O (d • |σ |) for the size of the automaton.</p></div>
<div><head>Complexity bounds. First, it is easy to check that the size of</head><formula xml:id="formula_30">A Q ′ is in O |B(d, σ )| × |Y| O (d • |σ |) = O χ d • |σ | × |Y| O (d • |σ |) = O |Y| poly(d ,</formula><p>We now turn to the claims about computation time. Let Z be a superset of the IQ-types satisfied in I. The computation of Z ¬Q ′ can be done by enumerating the types in Z and checking coverage of Q ′ by the type. The coverage check is polynomial in the type and Q ′ . Thus the total time is polynomial in the size of Z, the maximal size of a type in Z, and Q ′ . The maximal size of a type in Z is O(2 |Q ′ | ). Thus the set of states Z ¬Q ′ can be computed in the required time.</p><p>We now discuss the transition function. For each symbol α ∈ Γ(d, σ ), for each list of states</p><formula xml:id="formula_31">(v 1 , • • • , v k ),</formula><p>where k is in O(d × |σ |), we have to determine the type τ of a node in an instance I of I with a bag in the equivalence class α and having children with IQ-types τ 1 , • • • τ k . For one fixed representative of this output-isomorphism class, we let v be the output element of the node, B the set of facts, and we let v i be the output element of each child, 1 ⩽ i ⩽ k. We proceed by constructing a small monadic expansion tree to determine the type τ . This mini-instance has a node n with bag B and output element v (for technical reasons we cannot put n as the root of the monadic expansion tree since the root is assumed not to have an output element, but we can construct a dummy root node that serves no other purpose). We now explain how to construct the k children of node n.</p><p>For each 1 ⩽ i ⩽ k, we build a subinstance I i as follows: For each type-element (X i j , q i j ) of τ i , we build a mapping ν i j from q i j as follows: for variable x appearing in q i j , if x is in X i j then x is mapped to v i , otherwise the variable is mapped to a fresh value. We define I ′ i j to be an instance formed by turning ν i j into a homomorphism. I i is the union of I ′ i j for all j. The subinstance I is the union of the I i and B. We now define a tree decomposition of I . We let the root node have an empty bag and child n with output element v and bag B. The children of n are n i for 1 ⩽ i ⩽ k, where n i has output element v i and bag I i . Clearly, α is the code of the output-isomorphism class of n. Determining the type of Q can be done by simply enumerating all type elements of Z and determining which are satisfied by n, which can be done in time</p><formula xml:id="formula_32">O(|Z| • 2 |Q ′ | • |I | |Q ′ | ). The size of I is the size of B, plus an O(d • |σ | • 2 |Q ′ | • |Q ′ |).</formula><p>Finally, the whole process of constructing a small monadic expansion tree has to be performed for every possible transition, i. </p><formula xml:id="formula_33">Q ′ = i Q ′ i is a general UCQ.</formula><p>For each i, Q ′ i is a possibly disconnected CQ which we can write as</p><formula xml:id="formula_34">Q ′ i = q ′ i j ∈MCC(Q ′ i ) q ′ i j .</formula><p>We first construct a deterministic automaton A i j for each query q ′ i j as above. Q ′ i is not satisfied if and only if one of the q ′ i j is not satisfied. Thus, j A i j is a nondeterministic ranked tree automaton that recognizes monadic expansion trees that do not satisfy Q ′ i . Similarly, Q ′ is not satisfied if and only if none of the Q ′ i is satisfied. Therefore if we consider A Q ′ = i j A i j and apply a product construction to the automata for each j A i j , we obtain a nondeterministic ranked tree automaton recognizing monadic expansion trees that do not satisfy Q ′ . Thus, for any d-regular set of instances I, applying a product construction to A Q ′ ∩ A I gives an NTA Rk that accepts the set of all Code d (I ) with I ∈ I not satisfying Q ′ . The construction of the union of the deterministic automata as a nondeterministic one can be done in time polynomial in |Q ′ | and in each of the automata (just do the union of the transitions). The construction of the intersection amounts to considering all possible combination of states and therefore raises the size of the automaton to an exponent of |Q ′ |. Thus we have a generalization of Theorem 4.10: Theorem 4.13. Let σ be a signature, d a positive integer, and I a d-regular set of monadic expansion trees recognized by the deterministic ranked tree automaton A I . Let Q ′ be an arbitrary UCQ.</p><p>Then there exists a nondeterministic ranked tree automaton A Q ′ over the alphabet Γ(d, σ ), such that A Q ′ ∩ A I accepts the set of all Code d (I ) with I ∈ I not satisfying Q ′ . Moreover, the size of</p><formula xml:id="formula_35">A Q ′ is in O |Y| poly(d ,σ , |Q ′ |)</formula><p>where Y is the set of IQ-types with respect to Q ′ of nodes of some instances of I.</p><p>Finally, if one is given a superset Z of Y, then we can compute</p><formula xml:id="formula_36">A Q ′ in time O |Z| poly(d , |σ |, |Q ′ |) .</formula></div>
<div><head n="4.2">IQ-Types and Containment of MDL in UCQs</head><p>How does the machinery of the last subsection help us? Let us first discuss how these arguments can be used to reprove the 2EXPTIME upper bound on the containment of <software ContextAttributes="used">MDL</software> in UCQs <ref type="bibr" target="#b18">[19]</ref>.</p><p>To determine whether an <software>MDL</software> query Q is not contained in a UCQ Q ′ , we can check whether there exists a monadic expansion tree satisfying Q and not satisfying Q ′ by Lemma 2.6. But we can actually restrict the search of a witness to a subset of the monadic expansion tree satisfying Q.</p><p>First, we observe that a monadic datalog program is equivalent to an infinite union of conjunctive queries, denoted by UQ(Q). Second, we can consider special cases of monadic expansion trees I of Q with the following property: there exists a conjunctive query q 1 in UQ(Q) and a surjective homomorphism from q 1 onto I . An instance having the previous property is said to surjectively satisfy Q. Indeed, a monadic expansion tree I of Q that does not satisfy Q ′ has to satisfy some CQ q 1 in UQ(Q), and all facts not necessary for the homomorphism from q 1 to I can be removed from I while keeping the monadic expansion tree structure and the non-satisfaction of Q ′ .</p><p>There exists an integer d polynomial in Q such that the codes of monadic expansion trees surjectively satisfying Q are in L(d, σ ). More precisely, the set of monadic expansion tree models surjectively satisfying Q is regular and there exists a tree automaton A Q of size exponential in d and in the sizes of σ and Q. This is an argument very similar to Proposition 5.9 of <ref type="bibr" target="#b18">[19]</ref>, except for the difference in coding of the instances (the proof trees of <ref type="bibr" target="#b18">[19]</ref> encoding their expansion trees vs our coding of monadic expansion trees), which is not essential for the proof.</p><p>We can then apply Theorem 4.13 to compute A Q ′ and test the emptiness of A Q ∩A Q ′ in polynomial time in the size of the automata. In the general case of <software ContextAttributes="used">MDL</software> containment in UCQs, if we take Z to be all IQ-types, we obtain a doubly exponential bound on the construction of A Q ′ , yielding an overall 2EXPTIME upper bound on the containment of <software ContextAttributes="used">MDL</software> within a UCQ, as in <ref type="bibr" target="#b18">[19]</ref>.</p><p>We now introduce a special property of classes of instances that allow us to take Z to be considerably smaller, yielding a better upper bound.</p></div>
<div><head n="4.3">Unique Mapping Condition</head><p>As we shall see in Section 5, the 2EXPTIME upper bound obtained from our method for the containment of arbitrary <software>MDL</software> query in UCQs is the best we can do, since the bound is tight. We can do better if we can restrict to a class of instances that satisfies the Unique Mapping Condition: Definition 4.14. For any conjunctive query Q ′ , a class of monadic expansion trees I satisfies the Q ′ -Unique Mapping Condition (Q ′ -UMC) if the following holds for any node n in an instance of I:</p><p>(⋆) for any type elements (X 1 , q 1 ) and (X 2 , q 2 ) of Q ′ satisfied at n, if there exists an atom A appearing in both q 1 and q 2 referencing a variable x in both X 1 and X 2 then X 1 = X 2 and q 1 = q 2 . A class of monadic expansion trees has the Universal Unique Mapping Condition (∀-UMC) if it has the Q ′ -UMC for every conjunctive query Q ′ .</p><p>The idea behind the name Unique Mapping Condition is that type elements represent ways in which Q ′ can be partially mapped into an expansion tree. The UMC says that such mappings are determined once we know one atom of Q ′ in the domain. The Q ′ -UMC should shed more light on the connectedness and maximality requirements imposed on IQ-types. It is easy to see that for a disconnected query we will not have a unique mapping even for very restricted structures; and if we do not look at connected queries that are somehow "maximal", we cannot get uniqueness.</p><p>Example 4.15. In the definition of IQ-types (Definition 4.5), we required the subquery to be a relative connected component: relatively closed and relatively connected. This restriction is important for making the UMC non-trivial, and we illustrate this via two examples.</p><p>Consider the CQ Q ′ 1 = ∃x∃y∃z R(x, y) ∧ R(y, z) and a monadic expansion tree I 1 , with T(I 1 ) as follows (with the root to the left):</p><formula xml:id="formula_37">{A(a)} (a, {R(a, b)}) (b, {R(b, c)}) (c, ∅)</formula><p>Consider X = {x } and the following subquery of Q ′ 1 : q 1 = ∃x∃y R(x, y). Both (X, Q ′ 1 ) and (X, q 1 ) have a relative homomorphism to the subinstance rooted at the node of T(I ) with bag {R(a, b)}, and clearly they are different. But this does not contradict the UMC, since while the pair (X, {R(x, y), R(y, z)}) is a type element, the pair (X, {R(x, y)}) is not, since R(x, y) is not closed relatively to X : it has one atom containing y, and thus must have the other such atom in order to be relatively closed. Now consider Q ′ 2 = ∃x∃y∃z B(x) ∧ R(x, y) ∧ S(x, z), and a monadic expansion tree I 2 , with T(I 2 ) as follows:</p><formula xml:id="formula_38">{A(a)} (a, {B(a), R(a, b), S(a, c)}) (b, ∅) (c, ∅)</formula><p>Let n be the node of T(I ) whose output element is a. We set X = {x }, and consider two subqueries of Q ′ 2 : q 21 = ∃x∃y B(x) ∧ R(x, y) and q 22 = ∃x∃z B(x) ∧ S(x, z). Both (X, q 21 ) and (X, q 22 ) have a relative homomorphism to the subinstance rooted at n in I 2 , and clearly they are different. But this does not contradict the UMC, since neither ({x }, {B(x), R(x, y)}) nor ({x }, {B(x), S(x, z)}) is a type element. In this case, the reason is that neither subquery is connected relative to X . The definition of relative connectedness would require the existence of variables x 1 in B(x) and x 2 in R(x, y) that are not in {x }, and that are connected by some path. But clearly such variables cannot exist, since the only variable of B(x) is x.</p><p>Above we have given examples that have the UMC, due to the restrictions we have placed on being a type element. We now show that even with these restrictions, it is possible for the UMC to fail.</p><p>Example 4.16. Consider a monadic expansion tree of the following form (with the root to the left):</p><formula xml:id="formula_39">(a, {R(a, b), R(b, a), C(a)}) (b, {R(b, c), R(c, b), B(b)}) (c, {C(c)})</formula><p>This is a valid monadic expansion tree for the <software>MDL</software> program:</p><formula xml:id="formula_40">P 1 (x) ← R(x, y) ∧ R(y, x) ∧ C(x) ∧ P 2 (y) P 2 (x) ← R(x, y) ∧ R(y, x) ∧ B(x) ∧ P 3 (y) P 3 (x) ← C(x) Consider again the query Q ′ = ∃x∃y∃z C(x) ∧ R(x, y) ∧ R(y, z) ∧ C(z)</formula><p>from Example 4.6 along with the two pairs that were shown in Example 4.6 to be type elements of Q ′ :</p><formula xml:id="formula_41">T 1 = ({x, z}, {R(x, y), R(y, z)}) T 2 = ({x }, {R(x, y), R(y, z), C(z)})</formula><p>We claim that these two type elements witness the fact that the expansion tree above does not satisfy the Q ′ -UMC.</p><p>Indeed, note that both T 1 and T 2 are satisfied at the root of the expansion tree. In the case of T 1 , the relative homomorphism witnessing this maps both z and x to the value a while mapping y to b. For T 2 the relative homomorphism maps x to a, y to b, and z to c (remember that z cannot be mapped to a in the case of T 2 as {x } is by definition the set of variables mapped to a). Now, observe that T 1 and T 2 have an atom in common, and yet differ in their set of variables and their set of atoms. Thus they witness the failure of the Q ′ -UMC.</p><p>The takeaway here is that the presence of symmetries in both Q ′ and the expansion tree can cause the UMC to fail.</p><p>The UMC is a semantic property which is not straightforward to check. However, in Sections 4.4 and 4.5, we will see two cases where the UMC holds: first, by restricting the classes of instances we work with (to trees over specific signatures), and second by restricting the <software>MDL</software> program we consider monadic expansion trees of.</p><p>We will show that the Unique Mapping Condition suffices to get better upper bounds. The interest of the UMC is that it bounds the number of useful types: Proposition 4.17. Let Q ′ be a UCQ. There exists a set Z constructible in time O(2 poly(|Q ′ |) ), such that for every set I of monadic expansion trees satisfying the Q ′ -UMC:</p><formula xml:id="formula_42">Z ⊇ I ∈I n ∈T(I ) type Q ′ (n).</formula><p>In particular, the size of |Z| is in O(2 poly( |Q ′ |) ).</p><p>Proof. Let n be a node of an instance in I satisfying (⋆) and τ = type Q ′ (n). By (⋆), for every occurrence of a variable x within an atom A of Q ′ , there can be at most one type element of the form (X, q) with A in q and x ∈ X . In other words, the number of type elements of the form (X, q) with X non-empty is bounded by the size of Q ′ . Furthermore, the number of type elements of the form (∅, q) is at most the number of maximal connected components of Q ′ , i.e., also bounded by |Q ′ |.</p><p>In other words, choosing an element of Z requires to choose at most 2|Q )) as well, for instance by first enumerating all possible type elements of Q ′ (there are exponentially many pairs (X, q) with X a subset of the variables of Q ′ and q a subquery of Q ′ , and one can check in polynomial type that such a pair is a type element), and then constructing all types over these type elements that satisfy the constraints above. □</p><p>Together with Theorem 4.13, this proposition implies that one can compute in time exponential in d, |σ |, and |Q ′ | a deterministic ranked tree automaton such that the intersection with A I recognizes the codes of the instances in I that do not satisfy Q ′ . Because the intersection of two tree automata is polynomial in their sizes and the emptiness of a tree automaton can be checked in linear time in its size, we conclude: </p></div>
<div><head n="4.4">Upper Bounds for Tree Validity</head><p>We now present our first application of the UMC and IQ-type technology developed over the last few sections. It concerns the problem of tree validity introduced in Section 2.3, over the signatures S unranked Child , S bin Ch1,Ch2 , and S bin Ch1,Ch2,Child . A tree I over one of these relational signatures can be associated with the bag and output element structure of a monadic expansion tree T(I ) in a canonical way, up to sibling ordering, as follows:</p><p>(1) For each vertex v in I , there is a node n v whose output element is v.</p><p>(2) For each node n v ∈ T(I ), bag(n v ) contains all unary facts about v, as well as every fact of the form Child(v, x), <software>FirstChild</software>(v, x), <software ContextAttributes="used">SecondChild</software>(v, x). Ch1,Ch2 , S bin Ch1,Ch2,Child . Let q be a connected conjunctive query over σ , and I a tree over σ . Suppose h 1 and h 2 are two homomorphisms from q to I , and x and y are variables of q. Assume h 1 (x) = h 2 (x) = r for some vertex r of I , and that all variables of q are mapped by h 1 and h 2 to the subtree of I rooted at r . If h 1 (y) = r then h 2 (y) = r .</p><formula xml:id="formula_43">(3) Two nodes n v 1 and n v 2 of T(I ) are in parent-child relation iff Child(v 1 , v 2 ), FirstChild(v 1 , v 2 ), or SecondChild(v 1 , v 2 ) holds in I . (<label>4</label></formula><p>Proof. If y = x, this is trivial. Since q is connected and y</p><p>x, there is a non-empty path of binary atoms A 1 . . . A n and a sequence of variables x = x 0 , . . . x n = y with, for all 1 ⩽ i ⩽ n, x i-1 and x i distinct variables co-occurring in A i . Since the A i 's are binary, they have to be <software>FirstChild</software>, <software ContextAttributes="used">SecondChild</software>, or Child atoms; let us denote R i the corresponding relation name. For 0 ⩽ i ⩽ n, let d i be the depth of h 1 (x i ) in the subtree of I rooted at r . We know that d 0 = 0, and, for all 1 ⩽ i ⩽ n, we can compute d i from d i-1 :</p><formula xml:id="formula_44">• if A i = R i (x i-1 , x i ), d i = d i-1 + 1; • if A i = R i (x i , x i-1 ), d i = d i-1 -1. But the depth d ′ i of h 2 (x i</formula><p>) in the subtree of I rooted at r is computed in exactly the same way: d ′ 0 = 0 and the same recurrence formulas as above hold. This means in particular that d ′ n = d n = 0. Since r is the only node at depth 0 in the subtree of I rooted at r , h 2 (y) = r . □ Note that this lemma does not hold over S bin Ch1,Ch2,Child,Child ? . We are now ready to prove Theorem 4.19:</p><p>Proof of Theorem 4.19. Let Q ′ be an arbitrary conjunctive query, I an instance of σ , and n a node of T(I ), with output element the corresponding tree vertex v n . Let (X 1 , q 1 ) and (X 2 , q 2 ) be two type elements of Q ′ in type Q ′ (n), with respective relative homomorphisms h 1 and h 2 . We assume there exists an atom A in both q 1 and q 2 referencing a variable in both X 1 and X 2 . We need to show that X 1 = X 2 and q 1 = q 2 .</p><p>We first show q 1 = q 2 . Let X be the intersection of X 1 and X 2 . Let q ∩ be the intersection of q 1 and q 2 (i.e., the atoms in common), and q ′ the maximal connected component of q ∩ relative to X that contains A.</p><p>By way of contradiction, assume q 1 q 2 . Without loss of generality, since q 1 and q 2 play the same role, we can assume that there exists an atom A ′ of q 1 that is not in q 2 . Since q 1 is connected relative to X 1 , we know there is a path consisting of variables not in X 1 such that consecutive variables x i , x i+1 co-occur in an atom A i of q 1 , with the path starting at a variable of A and terminating at a variable of A ′ . We now consider j to be the least index such that the atom A j+1 is not in q 2 , and such that all variables x 1 , . . . , x j are not in X 2 . Thus, A j , which contains variable x j+1 is in both q 1 and q 2 , and it is also in q ′ since it is connected to A relative to X 1 ∩ X 2 in q ∩ . Note that since x j+1 X 1 , h 1 (x j+1 ) v n , by the definition of a relative homomorphism.</p><p>Suppose first that h 2 (x j+1 ) = v n , which means x j+1 ∈ X 2 . Let x be any variable in X 1 ∩ X 2 (which is non-empty, since q 1 and q 2 share a non-empty atom). Thus h 1 (x) = h 2 (x) = v n . Note that both h 1 and h 2 restrict to homomorphisms of the connected query q ′ , and these restrictions contain x and x j+1 . Applying Lemma 4.20 above to the query q ′ , we derive that h 1 (x) = h 1 (x j+1 ) = v n which is a contradiction of the fact noted immediately above. Thus we can assume h 2 (x j+1 ) is not v n . Hence x j+1 is not in X 2 , by definition of relative homomorphism. But then, by closedness of the connected component q 2 , A j+1 should be in q 2 , which leads to a contradiction.</p><p>Thus we completed the argument that q 1 is equal to q 2 . A similar argument shows that X 1 must be equal to X 2 , completing the uniqueness argument. As above, let x be a variable of X 1 ∩ X 2 . Let y be a variable of X 1 . Then h 1 (y) = v n = h 1 (x). Moreover, h 2 (x) = v n . Since h 1 witnesses that (X 1 , q 1 ) is a type element satisfied in n, h 1 must map into the subinstance rooted at n. Similarly, h 2 must map into the subinstance rooted at n. By Lemma 4.20 above, applied to q 1 = q 2 we infer h 2 (x) = h 2 (y), and thus h 2 (y) = v n . Thus y is in X 1 . With the same reasoning, we can demonstrate that X 2 ⊆ X 1 . Thus X 1 is equal to X 2 . □ From the theorem above and Corollary 4.18, we get the following new bound, which in particular (for S unranked Let Q be a UCQ over σ , and A = (Ω, ∆ 0 , ∆, F ) a binary tree automaton over σ .</p><p>From A, we build a binary tree automaton A ′ = (Ω, ∆ ′ 0 , ∆ ′ , F ) over the alphabet Γ(d, σ ) as follows: • For every (α, q) ∈ ∆ 0 , let c ∈ B(d, σ ) be the output-isomorphism class of a bag with output element v and facts Leaf(v) and Label α (v). We then add (ĉ, q) to ∆ ′ 0 ; • For every (q 1 , q 2 , α, q) ∈ ∆ 0 , let C ⊆ B(d, σ ) be the output-isomorphism classes of bags with output element v, facts <software>FirstChild</software>(v, v 1 ),</p><formula xml:id="formula_45">FirstChild(v, v 2 ), Child(v, v 1 ) (if σ = S bin Ch1,Ch2,Child ), Child(v, v 2 ) (if σ = S bin</formula><p>Ch1,Ch2,Child ), Label α (v), and a possible additional fact Root(v). There are exactly two elements in C. For either of these elements c ∈ C, we add (q 1 , q 2 , ĉ, q) and (q 2 , q 1 , ĉ, q) to ∆ ′ . By construction, A ′ recognizes the set Code d (I ) for I a tree accepted by A. Additionally, A ′ can be constructed in time linear in A.</p><p>We now apply Corollary 4.18 to σ , d, Q ′ , and the class of trees over σ whose monadic expansion tree representation is recognized by A ′ , which has the Q ′ -UMC by Theorem 4.19. We obtain that checking if Q ′ holds over S bin Ch1,Ch2 and S bin Ch1,Ch2,Child can be done in time</p><formula xml:id="formula_46">O(|A ′ | × 2 poly(|Q ′ |,d , |σ |) ) = O(|A| × 2 poly( |Q ′ |)</formula><p>) since d and σ are fixed. In other words, it is in EXPTIME.</p><p>Finally we deal with the unranked case. We make use of the following easily-verified fact about an automaton A over unranked trees: given a tree t that is accepted by A, there is a subtree t ′ (obtained by removing subtrees in t) which is a ranked tree of rank at most polynomial in A, such that t ′ is also accepted by A. Applying this to a counterexample t to validity, we see that t is still a counterexample to validity, since trimming preserves the negation of Q. Thus we have reduced to the ranked case. □ Corollary 4.21 complements the theorem of Björklund et al. <ref type="bibr" target="#b8">[9]</ref>, which shows that the problem of validity with respect to an NTA is hard for EXPTIME.</p><p>In the case of validity over all trees for S unranked</p></div>
<div><head>Child</head><p>, we can do better: Proposition 4.22. Validity of a UCQ over S unranked</p></div>
<div><head>Child</head><p>with respect to all trees is in PSPACE.</p><p>Proof. Observe that a counterexample to validity for S unranked Child can always be taken to be a single path with no branching, by keeping one arbitrary branch from the root to a leaf: indeed, removing other branches amount to simply removing facts from the relational instance and therefore cannot make a CQ true if it did not hold on the original instance (we cannot, on the other hand, shorten a branch, as this amounts to adding new Leaf facts).</p><p>We can further assume each CQ in the UCQ is connected, since we can guess a connected component of each CQ. A connected CQ specifies an interval of polynomial size in the path. Thus we need a nondeterministic PSPACE algorithm which determines whether there is a path in which a set S of k-sized intervals are omitted. We can do this by tracking the last k elements observed. □</p></div>
<div><head n="4.5">Upper bounds for restricted MDL queries</head><p>We will apply the UMC to get another exponential decrease in the complexity. This time we deal with general structures, but restrict the queries.</p><p>A monadic datalog query is globally extensionally restricted (<software>GEMDL</software>) if every extensional predicate appears in only one rule, and occurs only once in that rule. An <software ContextAttributes="used">MDL</software> query is almost globally extensionally restricted (<software ContextAttributes="used">AGEMDL</software>) if the goal predicate never occurs in the body of a rule, and every extensional predicate has only one occurrence in a rule other than a rule for the goal predicate.</p><p>Informally, <software>AGEMDL</software> queries allow UCQs built over intensional predicates, where extensional predicates are partitioned into classes where each rule uses predicates in a particular class.</p><p><software>GEMDL</software> and <software ContextAttributes="used">AGEMDL</software> are simple syntactic restrictions of <software ContextAttributes="used">MDL</software> whose properties will allow us to apply the UMC. The main application of these restrictions are the ones that come from limited access querying, in the specific case where access methods have at most one output position. Indeed, consider again the rules in Equation (2) in Section 2.4, an encoding as an <software ContextAttributes="used">MDL</software> program of the unary predicate AccValues representing values that can be discovered via the access restrictions. When there is at most one output position for every access method, there is only one rule for every extensional predicate R, of the form:</p><p>AccValues(x j k ) ← R(x) ∧ AccValues(x j 1 ) ∧ • • • ∧ AccValues(x j m ) These rules satisfy the <software>GEMDL</software> restriction.</p><p>Furthermore, evaluation of UCQ Q over accessible data can be done using a single additional predicate (see Equation (1) in Section 2.4), with rules for every conjunct of Q, also enforcing all variables are accessible.</p><p>Combining the <software>GEMDL</software> rules defining AccValues and the rules defining the goal predicate thus results in an <software ContextAttributes="used">AGEMDL</software> query. It follows that the question of containment of unions of conjunctive queries under limited access patterns (recall Definition 2.12), where every access has a single output position, can be expressed as the containment of an <software ContextAttributes="used">AGEMDL</software> query in a UCQ. Formally: Proposition 4.23. There is a polynomial-time reduction from containment of UCQs under limited access patterns, where every access has at most one output position, to containment of <software ContextAttributes="used">AGEMDL</software> in UCQ.</p><p>We will get an EXPTIME bound for <software>AGEMDL</software>. The key feature common to containment of <software ContextAttributes="used">GEMDL</software> queries and the limited access containment problem is that counterexamples have a stronger kind of tree-like instance, compared to simply monadic expansion trees. A diversified tree-like instance is a monadic expansion tree in which: (i) for each node n which is not the root, for each relation R, there exists at most one fact in bag(n) having the relation name R; (ii) there is no value v that appears at the same position in two distinct facts with the same relation name.</p><p>The first condition is a local one, saying roughly that we do not have self-joins within a bag while the second one is global, saying self-joins across bags must not have the joined variable in the same position. A figure showing a diversified tree-like instance is given in Fig. <ref type="figure">1</ref>. The large ellipses represent bags, with different relations represented by different shapes in a bag. The dark circle represents a common value shared across and within bags.</p><p>We now have the following refinement of Proposition 2.6. Let Q be a union of conjunctive queries. Proposition 4.24. If an <software>AGEMDL</software> query Q is not contained in a UCQ Q ′ , then there is a diversified tree-like instance I such that I satisfies Q ∧ ¬Q ′ . Furthermore, the size of the bags of I can be taken to be polynomial in the size of Q.</p><p>Proof. We reuse the construction presented in the proof of Proposition 2.6. We just have to show the additional properties of a diversified tree-like instance.</p><p>Recall from Proposition 2.6 that our tree-like instance was derived from a graph G(Q), whose nodes consisted of pairs, a head atom and a rule. Furthermore:</p><p>( †) G(Q) has no two nodes n and n ′ with the same head atom α(x), where x is a variable. There exists an isomorphism ψ from the facts in the rules of G(Q) to elements of I . For each atom α appearing in a rule within a node m of G(Q) such that y is the variable appearing in the head atom of m, ψ (α) appears in the node of T (I ) having ψ (y) as its output element.</p><p>(1) Let R be a relation name. Due to Property ( †), for each intensional predicate P and for each variable x, there is at most one node of G(Q) having P(x) as head atom. Due to the <software>AGEMDL</software> restriction, a rule associated with a non-root node has at most one atom in the body with relation R. Thus, by construction of T (I ), the bag associated with each node has at most one atom with relation R.</p><p>(2) Let R( ā1 ) and R( ā2 ) be two facts of I in two distinct non-root nodes n and n ′ within T (I ), which share the value v. By definition of a tree-like instance, and by the fact proved above, we must have that n ′ and n of T (I ) are in a parent-child relationship. We assume that R( ā1 ) is in n ′ and R( ā2 ) is in n. Let v and v ′ denote the output elements of n and n ′ respectively, and let m and m ′ be the corresponding nodes of G(Q). We prove by contradiction that v does not appear in the same position of R( ā1 ) and R( ā2 ). We denote by x the variable mapped to v by ψ and by x ′ the variable mapped to v ′ by ψ . Let ρ be the (necessarily unique) rule of Q having an atom with the relation name R. There exist atoms α m in the body of the rule of m and α m ′ in the body of the rule associated to m ′ such that ψ (α m ) = R( ā2 ) and ψ (α ′ m ) = R( ā1 ). Because v is the output element of n, by the second property of ψ listed above, x must appear in the head atom of m, and similarly x ′ must appear in the head atom of m ′ . Both m and m ′ have relation R in the associated rule, and thus by the <software>AGEMDL</software> property, the rule must be the same, namely ρ. Because v appears in R( ā1 ) and R( ā2 ) at the same position and ψ (x) = v, x appears in the same position in the atoms α m and α m ′ . Thus x ′ = x, and therefore m and m ′ have the same head atoms, as well as the same rules, hence they must be the same node of G(Q). This contradicts the assumption that n and n ′ were distinct.</p></div>
<div><head>□</head><p>The technique generalizes to the containment problems arising from general access methods, not only ones with a single output: Proposition 4.25. If a UCQ Q is not contained in a UCQ Q ′ under access restrictions ACS then there is a diversified tree-like instance I such that I satisfies Q ∧ ¬Q ′ .</p><p>Proof. The rules that come from limited access patterns with an arbitrary number of output positions satisfy the following weakening of the <software ContextAttributes="used">AGEMDL</software> condition: for any two rules that share an extensional predicate in the body, the bodies are identical. One can easily see that the argument Fig. <ref type="figure">1</ref>. Diversified tree-like instance in the proof of Proposition 4.24 applies to show that these rules also admit diversified tree-like instances.</p><p>□</p><p>The following links diversified instances to the IQ-type machinery developed previously:</p><p>Theorem 4.26. The class of diversified tree-like instances satisfies the ∀-UMC.</p><p>Proof. We need to show that the class of diversified tree-like instances satisfies the Q ′ -UMC for any conjunctive query Q ′ . Let Q ′ be such a query, I a diversified tree-like instance, and n a node of T(I ).</p><p>We will show the following: ( ‡) Let X be a subset of variables of Q ′ and q a subquery of Q ′ . Take any x X of q and atom α of Q ′ but not of q that contains x, any relative homomorphism h from (X, q) to the subinstance rooted at n. Then there is at most one way of extending h into a homomorphism h * from q * = q ∧ α to the subinstance rooted at n, and of extending X into a superset X * , such that h * is a relative homomorphism from (X * , q * ) to the subinstance rooted at n. We now prove ( ‡). We let X , q, x, α, h to be as in the statement of ( ‡). Let β be an atom of q that contains x; β exists since x is a variable of q. Let n ′ be the node of the subinstance rooted at n whose bag contains h(β). We distinguish two cases:</p><p>(</p><formula xml:id="formula_47">1) h(x) is the output element v of n ′ . Since x X , n ′ n. Since α contains x, it is clear h * (α)</formula><p>can only be mapped to the bag of n ′ or to that of its parent n ′′ . It cannot be mapped to both, as this would imply that there are two distinct facts with same relation name as α that both contain v in the same position (the position of x in α), which is forbidden in diversified tree-like instances. Within the only possible bag, there cannot be more than one possible way to map α, as otherwise there would be two facts on the same relation within the same bag, which is also forbidden in diversified tree-like instances. (2) h(x) is not the output element of n ′ . Then h(x) must be the output element of one of the children n ′′ of n ′ . We then proceed exactly as in the previous case, the roles of n ′ and n ′′ being exchanged. This completes the argument for the uniqueness of h * . We turn to the second statement of ( ‡), concerning uniqueness of X * . Here we observe that if such an h * can be constructed, X * is necessarily the set of variables mapped by h * to the output element of n, by the definition of relative homomorphism. This concludes the proof of ( ‡).</p><p>We now explain how ( ‡) can be used to prove that the property (⋆) in the definition of the unique mapping condition holds.</p><p>Let (X 1 , q 1 ) and (X 2 , q 2 ) be two type elements of Q ′ satisfied by n that share an atom α referencing a variable x in X 1 ∩ X 2 . By definition, there exist a relative homomorphism h 1 from (X 1 , q 1 ) to the subinstance rooted at n and a relative homomorphism h 2 from (X 2 , q 2 ) to the subinstance rooted at n. Since α references a variable mapped by h 1 to the output element of n, h 1 (α) ∈ bag(n); similarly, h 2 (α) ∈ bag(n). Now, since I is a diversified tree-like instance, there can only be one fact in bag(n) having same relation name as α, so h 1 (α) = h 2 (α). In particular, none of the variables of α except those in X 1 ∩ X 2 can be mapped to the output element by h 1 or h 2 . Now, assume by way of contradiction that q 1 q 2 or X 1 X 2 . Then, without loss of generality since q 1 and q 2 play symmetrical roles, we can assume there exists an atom β in q 1 such that either β is not in q 2 or h 2 (β) h 1 (β). Since q 1 is connected relative to X 1 , there is a path x 1 . . . x k of variables not in X 1 from a variable x 1 of α to a variable x k of β in the graph of co-occurrences of variables in atoms of q 1 . Let γ 1 = α, γ 2 . . . γ k+1 = β be the corresponding atoms on this path and let γ i+1 with 1 ⩽ i ⩽ k be the first atom on this path such that either γ i+1 is not in q 2 or h 2 (γ i+1 ) h 1 (γ i+1 ). Let X be the subset of variables of q = γ 1 ∧ • • • ∧ γ i that are mapped to the output element of n both by h 1 and by h 2 , i.e., that are in X 1 ∩ X 2 . Since q 2 is closed relative to X 2 and x i X 2 , it means that γ i+1 , which also contains x 1 , is in q 2 . We thus must have h 2 (γ i+1 ) h 1 (γ i+1 ). We then apply ( ‡) to X , q, x i , γ i+1 : indeed, x i X since x i X 1 . But then, the restriction h of h 1 to the variables of q (which is also the restriction of h 2 to the variables of q) is a relative homomorphism from (X, q) to the subinstance rooted at n. Therefore, ( ‡) tells us that there is at most one way to extend h and X into h * from q * = q ∧ γ i+1 to the subinstance rooted at n and of extending X into a superset X * such that h * is a relative homomorphism from (X * , q * ) to the subinstance rooted at n. But the restriction of h 1 to the variables of q * , and the restriction of h 2 to the variables of q * are two relative homomorphisms (for some sets X ′ 1 ⊆ X 1 , X ′ 2 ⊆ X 2 ) that also extend h in the same sense. They must thus coincide and h 1 (γ i+1 ) = h 2 (γ i+1 ), which is a contradiction. □</p><p>Note that an atom α determines a unique set of variables X , so the key is that, in this restricted setting, we have only one way to select which variables map to the output element of the root.</p><p>The last thing we need to apply our UMC machinery to diversified instances is to note that this class of tree-like instances can be captured with an exponential-sized automaton: Lemma 4.27. The set of diversified tree-like instances satisfying a UCQ Q is d-regular for some d. Further there is a ranked deterministic tree automaton A Q recognizing the codes of the diversified treelike instances satisfying Q which has size exponential in Q and can be constructed in time exponential in Q.</p><p>Proof. First, we argue that the set of monadic expansion trees satisfying a UCQ Q is easily recognizable by an exponential sized automaton. The properties of a monadic expansion tree are easily enforced by the transition function of the automaton. The property of satisfying a UCQ is checked by having a state for each subquery Q 0 of Q supplemented with a homomorphism from a subset of the variables in Q 0 to the current node. Updating the state can be done with an exponential sized transition function, and the automaton accepts if the full query Q is covered. The property of being diversified is very simple to check, and the intersection of these two automata can be formed in polynomial time. □ From this lemma, Theorem 4.26, and Proposition 4.17, the number of IQ-types of the set of diversified instances satisfying Q is bounded by an exponential function. Moreover, from Corollary 4.18 we get complexity bounds for <software>AGEMDL</software> and limited access containment: Corollary 4.28. The containment of an <software ContextAttributes="used">AGEMDL</software> query in a UCQ can be decided in EXPTIME. The containment of two UCQs under limited access constraints can be decided in EXPTIME.</p></div>
<div><head n="5">LOWER BOUNDS</head><p>We will now prove our lower bound results. Again, there is a tight connection between <software>MDL</software> containment and tree validity problems. We will begin by showing lower bounds for the tree validity problem, and then use these to get results for <software ContextAttributes="used">MDL</software> and limited access containment.</p></div>
<div><head n="5.1">Lower bounds for tree validity problems</head><p>We first prove lower bounds for tree validity problems matching the upper bounds of Section 4.4. For generality, we show that the lower bounds hold for BDTDs (recall that they are more restrictive than BNTAs) by first proving them for BNTAs and then applying the following lemma, which shows that one can reduce NTA problems to DTD problems, by making runs explicit. This result was stated by Björklund et al. (Lemma 18 of <ref type="bibr" target="#b9">[10]</ref>) for unranked trees, who mention that it is implicit in Takahashi's work <ref type="bibr" target="#b31">[32]</ref>. As in <ref type="bibr" target="#b9">[10]</ref>, we define the annotated tree language of a BNTA A with states Ω over binary trees labeled with Λ as the set of trees in L(A) that are annotated by their accepting runs. More formally, the annotated tree language of A is the set of trees t over Λ × Ω such that Π Λ (t) ∈ L(A) while Π Ω (t) is an accepting run of A on Π Λ (t).</p><p>Lemma 5.1. Let A be a BNTA over binary trees with a single final state, and such that all trees accepted by A have a common root label. Then there exists a BDTD D A , constructible in polynomial time from A, that recognizes the annotated binary tree language of A.</p><p>Proof. Since our notion of DTDs is slightly different from the classical one (in particular, this makes the construction cubic, not quadratic as in <ref type="bibr" target="#b9">[10]</ref>), and since the statement of the result in <ref type="bibr" target="#b9">[10]</ref> misses the technical condition of imposing a single possible root label, we give the construction explicitly.</p><p>Let A be a BNTA with alphabet Λ, states Ω, final state q f , input states ∆ 0 ⊆ Λ × Ω, and transition relation ∆ ⊆ Ω 2 × Λ × Ω. Let a r be the common root label of all trees accepted by A. We construct the BDTD D A = (d, l 0 ) over the alphabet Λ × Ω as follows (note that this construction is cubic in the size of A):</p><formula xml:id="formula_48">• l 0 = (a r , q f ); • For α ∈ Λ and q ∈ Ω, d(α, q) = {((β 1 , q 1 ), (β 2 , q 2 )) | β 1 , β 2 ∈ Λ, (q 1 , q 2 , α, q) ∈ ∆} ∪ {ε | (α, q) ∈ ∆ 0 }</formula><p>It is clear that a binary tree t is accepted by D A if and only if Π Ω (t) is an accepting run of A on Π Λ (t). □ Thus, as in <ref type="bibr" target="#b9">[10]</ref>, if we show that the validity problem is hard for BNTAs (even when all trees have a common root label), we can deduce it is also hard for BDTDs using this reduction: Corollary 5.2. Let Q be a UCQ on S bin Ch1,Ch2 , S bin Ch1,Ch2,Child , or S bin Ch1,Ch2,Child,Child ? and A a BNTAs such that all trees accepted by A have a common root label. One can construct in polynomial time a UCQ Q ′ on the same signature and a BDTD D</p><formula xml:id="formula_49">′ A such that Q ′ is valid over D ′ A if and only if Q is valid over A. Furthermore, if Q is a CQ, so is Q ′ .</formula><p>Proof. We would like to apply Lemma 5.1 to get the DTD and then rewrite the query appropriately. We have two difficulties: first, we need to deal with the case where A does not have a single final state, since Lemma a 5.1 requires this. Second even in the case where we have a single final state, and hence could apply Lemma 5.1 and take D ′ A D A , we have a difficulty translating from a CQ to another CQ, since we would need disjunction to express the different possible labels of the annotated tree that correspond to one label of the regular tree.</p><p>We take care of the final state problem first. We modify A = (Ω, ∆ 0 , ∆, F ) to A ′ (Ω∪{q f }, ∆ 0 , ∆∪ ∆ ′ , q f ) where q f is a fresh state and ∆ ′ {(q 1 , q 2 , α, q f ) | (q 1 , q 2 , α, q) ∈ ∆, α ∈ Λ, q ∈ F }. A ′ has a single final state, is constructible in time linear in A, and Q is valid over A ′ if and only if Q is valid over A.</p><p>To address the second problem, we make the different annotations structurally adjacent to the labels of the regular tree, rather than being extended labels. This technique is similar to that used in the proof of Theorem 19 of <ref type="bibr" target="#b9">[10]</ref> in the case of unranked trees. We construct the BDTD D A = (d, (a r , q f )) over Λ × (Ω ∪ {q f }) from A ′ using Lemma 5.1, then we construct in polynomial time a modified</p><formula xml:id="formula_50">BDTD D ′ A (d ′ , (a r , q f , 0)) over (Λ × (Ω ∪ {q f }) × {0, 1}) ∪ Λ ∪ {⊥} from D A as follows. For every α ∈ Λ, q ∈ Ω ∪ {q f }:              d ′ (α, q, 0) {(α, (α, q, 1))} d ′ (α, q, 1) {((α 1 , q 1 , 0), (α 2 , q 2 , 0)) | ((α 1 , q 1 ), (α 2 , q 2 )) ∈ d(α, q)} ∪ {ε | ε ∈ d(α, q)} d ′ (α) {(⊥, ⊥)} d ′ (⊥) {ε}.</formula><p>Furthermore, we rewrite Q as Q ′ by doing substitutions of atoms. Let S(x) ∃t∃u <software>FirstChild</software>(x, t)∧ <software ContextAttributes="used">FirstChild</software>(t, u) ∧ Label ⊥ (u). We construct Q ′ as follows.</p><p>• R(x, y), for R ∈ {FirstChild, <software>SecondChild</software>, Child} is replaced with ∃z <software ContextAttributes="used">SecondChild</software>(x, z) ∧ R(z, y) ∧ S(x) ∧ S(y); • Child ? (x, y) is replaced with ∃z Child ? (x, z) ∧ Child ? (z, y) ∧ S(x) ∧ S(y); • Leaf(x) is replaced with ∃z <software ContextAttributes="used">SecondChild</software>(x, z) ∧ Leaf(z) ∧ S(x); • Label α (x) for α ∈ Λ is replaced with ∃z <software ContextAttributes="used">FirstChild</software>(x, z) ∧ Label α (z). The resulting Q ′ is a CQ if Q is a CQ, the only atoms added reference relations existing in the current signature, and the construction is polynomial-time. For a UCQ Q</p><formula xml:id="formula_51">= i Q i , we write Q ′ = i Q ′ i</formula><p>where Q ′ i is the CQ obtained by applying the substitutions above to Q i . We argue that Q ′ is valid over D ′ A if and only if Q is valid over A ′ , i.e., if and only if Q is valid over A.</p><p>Assume Q ′ is valid over D ′ A and let T ∈ L(A ′ ). There is therefore an accepting run of A on T ; let T ′ be the annotated tree over Λ × (Ω ∪ {q f }) corresponding to this run. We know that T ′ is accepted by D A . From T ′ we construct T ′′ by replacing every subtree t with root labeled with (α, q) by a subtree formed of a root labeled with (α, q, 0), a first child labeled with q with no children, and a second child labeled with (α, q, 1) with the non-root part of t underneath, similarly transformed. By construction, T ′′ ∈ L(D ′ A ) and we know therefore that</p><formula xml:id="formula_52">T ′′ |= Q ′ , which means T ′′ |= Q ′ i for some Q ′ i .</formula><p>Let ν be a valuation of the variables of Q ′ i on T ′′ that witnesses this. Observe that ν maps variables x of Q i present in an atom of Q i to nodes n of T ′′ with label of the form (α, q, 0):</p><p>• If the variable appears in Q i in an atom Root(x), n is the root of T ′′ , which has a label (a r , q f , 0).</p><p>• If the variable appears in Q i in an atom Label α (x), then the first child of n in T ′′ has α as label, which is only possible if n has (α, q, 0) for some q as label. • If the variable is of the form R(x, y) or R(x) or R(y, x) for R ∈ {FirstChild, <software>SecondChild</software>, Child, Child ? , Leaf} then S(x) holds, which means that n has a first child whose first child is labeled with ⊥, which is only possible if n has (α, q, 0) for some α, q as label. We consider the valuation ν ′ that maps variables x of Q i to the nodes of T ′ labeled by (α, q) that were transformed when constructing T ′′ to the node ν (x) labeled by (α, q, 0). Let now ν ′′ be the valuation of variables of Q i to nodes of T corresponding to ν ′ on T ′ (remember that T ′ is just an annotated version of T ). Then ν is a witness that T |= Q i , i.e., T |= Q.</p><p>Conversely, assume Q is valid over A ′ and let T ∈ L(D ′ A ). Let T ′ be the tree obtained from T by retaining only the nodes whose label is of the form (α, q, 0), attaching them to the closest retained ancestor, and dropping the 0 in the label. This is a tree in the language of D A , i.e., an annotated tree of A ′ . We can thus project the states out and obtain a tree T ′′ ∈ L(A ′ ), for which we know T ′′ |= Q, meaning T ′′ |= Q i for some i. Let ν be the valuation witnessing this, and let ν ′ the valuation from the variables of Q i to nodes of T of the form (α, q, 0) corresponding to these nodes of T ′′ (via the annotation given by T ′ ). Because T ∈ L(D ′ A ) and D ′ A fully constrains the positions of α and (α, q, 1) nodes, we can extend ν ′ into a valuation of the variables of Q ′ i that did not appear in Q i , to obtain a witness that T |= Q ′ i and thus T |= Q ′ . □</p><p>We can now prove the following result, which closely tracks Theorem 6 of <ref type="bibr" target="#b7">[8]</ref>.</p><p>Theorem 5.3. Given a CQ Q on S bin Ch1,Ch2,Child,Child ? and a BDTD A, it is 2EXPTIME-hard to decide whether Q is valid over A.</p><p>Proof. First, thanks to Corollary 5.2, we prove the result for a BNTA instead of a BDTD. We adapt the proof of Theorem 6 of <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref>, which states that validity with respect to an NTA of a CQ with child and descendant predicates over unranked trees is 2EXPTIME-hard. We adapt it by moving from unranked trees to binary trees (with the changes that it implies in the definition of an NTA), writing the output of the reduction given in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref> using Child ? instead of the descendant predicate.</p><p>We give a self-contained presentation keeping the notation from <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref> as much as possible, with notable departures highlighted in bold font throughout the proof.</p><p>As in <ref type="bibr" target="#b7">[8]</ref>, we reduce from the termination of an alternating EXPSPACE Turing Machine M, a 2EXPTIME-hard problem <ref type="bibr" target="#b15">[16]</ref>. The next few paragraphs are taken in part from <ref type="bibr" target="#b7">[8]</ref>, with some minor adjustments, as we need to introduce the same concepts.</p><p>An alternating Turing machine (ATM) is a tuple M = (Ω, Γ, ∆, q 0 ) where Ω = Ω ∀ ⊎Ω ∃ ⊎{q a }⊎{q r } is a finite set of states partitioned into universal states from Ω ∀ , existential states from Ω ∃ , an accepting state q a , and a rejecting state q r . The (finite) tape alphabet is Γ and includes a special blank character '#'. The initial state of M is q 0 ∈ Ω. The transition relation ∆ is a subset of (Ω × Γ) × (Ω × Γ × {L, R, S}). The letters L, R, and S denote the directions left, right, and stay, according to which the tape head is moved.</p><p>A configuration of an ATM M = (Ω, Γ, ∆, q 0 ) is a triple (τ , k, q) where τ : Z → Γ is the configuration tape, k ∈ Z is the tape head position, and q ∈ Q is the current state. We assume that τ -1 (Γ \ {#}) is finite (only finitely many symbols on the tape are non-blank). A configuration (τ , k, q) is existential if q ∈ Ω ∃ , universal if q ∈ Ω ∀ , accepting if q = q a , rejecting if q = q r . The initial configuration of M on a word w ∈ Γ * is the configuration (τ , 0, q 0 ) where τ (i) is the i-th character of w if 1 ⩽ i ⩽ |w |, and is '#' otherwise. A successor configuration (τ ′ , k ′ , q ′ ) of a configuration (τ , k, q) is a configuration such that τ ′ |Z\{k } = τ |Z\{k } and one of the following three properties holds:</p><p>•</p><formula xml:id="formula_53">k ′ = k -1 and (q, τ (k), q ′ , τ ′ (k), L) ∈ ∆; • k ′ = k and (q, τ (k), q ′ , τ ′ (k), S) ∈ ∆; • k ′ = k + 1 and (q, τ (k), q ′ , τ ′ (k), R) ∈ ∆.</formula><p>An accepting computation tree for an ATM M on a word w ∈ Γ * is a finite unranked tree labeled by non-rejecting configurations of M such that: (1) if node v is labeled by an existential configuration C, then v has one child, labeled by one of the successor configurations of C; (2) if v is labeled by a universal configuration C, then v has one child for each successor configuration of C; (3) the root is labeled by the initial configuration on w; and (4) all leaves are labeled by accepting configurations (and accepting configurations only appear as leaves). An ATM M accepts a word w ∈ Γ * if there exists an accepting computation tree for M on w.</p><p>The overall idea of the proof of <ref type="bibr" target="#b7">[8]</ref>, that we closely adapt, is as follows. Let M be an ATM and w a word of Γ * of length n. First, for technical reasons, we construct, in polynomial time an ATM M w which accepts the empty word if and only if M accepts w; this construction is straightforward.</p><p>Second, from M w , we construct a BNTA A that checks most important properties of (suitably encoded) computation trees of M w , except their consistency w.r.t. the transition relation of M w . The consistency is tested by a query Q that we construct. To be precise, Q is satisfied by a tree T in L(A) if and only if the transition relation of M w is not respected by T . This means that Q is valid w.r.t. A iff there does not exist a consistent, accepting computation tree for M w . Since 2EXPTIME is closed under complementation, we conclude that validity of CQs on S bin Ch1,Ch2,Child,Child ? with respect to BNTAs (and thus to BDTDs) is 2EXPTIME-hard. We emphasize that the encoding of the ATM would be straightforward if our query Q was allowed to be in non-recursive datalog, and fairly simple even if Q was a UCQ. It is the fact that we want to show hardness for containment in the case where Q is a CQ which motivates the subtleties in the encoding of <ref type="bibr" target="#b7">[8]</ref>, and we will inherit these in the constructions below.</p><p>Without loss of generality, we assume that universal configurations of M w always have exactly two successor configurations. If they have less, we can just add transition(s) for every universal state and tape symbol to an accepting state; if they have more, we can introduce intermediary states to encode a conjunction as a tree of binary conjunctions, with no change to tape symbol written or tape head move.</p><p>We do not give the nondeterministic tree automaton explicitly, but trees in its language will have the shape represented by Fig. <ref type="figure" target="#fig_8">2</ref>. <ref type="foot" target="#foot_3">2</ref> The bold nodes are the nodes added to the trees of Fig. <ref type="figure" target="#fig_9">3</ref> and<ref type="figure">4</ref> of <ref type="bibr" target="#b9">[10]</ref>. The labels of dashed edges indicate the number of nodes between a node and its ancestor. This BNTA encodes trees that represent accepting computation trees of M w . Each configuration in an accepting computation is encoded by a subtree rooted by a node labeled Conf (it was called CT in <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref>); the Conf-node for the initial configuration appears as the unique child of a chain of ℓ nodes with dummy labels from the root for some integer ℓ that we will define further (this chain of ℓ nodes is only needed for technical reasons). A Conf-node has two children labeled r and NextConf. The subtree rooted at the r -node represents the configuration tape and the subtree rooted by the NextConf-node has zero, one, or two Conf-children that we will regard as zero, one, or two successor configurations depending upon whether the current state is accepting, existential, or universal. That is, the links between r , Conf, and NextConf nodes represent the "macro structure" of a run, the links between configurations.</p><p>A configuration tape can be viewed a complete binary tree of depth n, with leaves of the tree containing information about 2 n cells. A path in the tree encodes the binary address of a cell, with the pattern of left and right children to the leaf encoding the address, and the label of the leaf encoding the tape content. This complete binary tree, that we will refer to as the abstract tape tree, is itself encoded for querying purposes underneath a configuration node r . We call this encoding the physical tape tree. For 1 ⩽ i ⩽ n, a node in the physical tape tree with label s represents a node at depth i in the abstract tape tree. Each such node representing a node at depth i, with 1 ⩽ i ⩽ n -1, has for first child a node of label p that serves as a navigation widget indicating the sibling type of this node in the tape tree (left or right). It has as second child a node of label TTCh (for tape tree children), which in turn has for children two nodes with label s, encoding the two children of the current encoded node in the abstract tape tree. The navigation widget is a p-labeled node with a single x-child that has itself a single y-child. If the current encoded node in the tape tree was a left child, x = 0 and y = 1; otherwise, x = 1 and y = 0. The root of the physical tree, r , corresponds to the root of the abstract tape tree; since the root of the abstract tape tree is neither a left or right child, r does not need a navigation widget as a child. It therefore has two children, nodes labeled with s encoding the two children of the root in the abstract tape tree. For a node at level n of the abstract tape tree, the corresponding s-labeled node must have a navigation widget child encoding whether it is a left or right child of its parent. But instead of a link to nodes representing its children in the abstract tape tree, it must have a link to a node representing its content. Thus the corresponding node in the physical tape tree has one child that is a p-labeled navigation widget, and second child a c-node that encodes the content of the cell, which we describe immediately below.</p><p>In encoding the information about the content of a tape cell in a configuration, we again follow <ref type="bibr" target="#b9">[10]</ref>. In the abstract tape tree, this information consists of the symbols on basic cells, symbol and transition followed on the current cell, and current symbol, previous state, previous symbol on previous tape cells. This means each cell would be associated with an element of Γ ∪ (Γ × ∆) ∪ (Γ × Ω × Γ): there are polynomially many such annotations, we refer to them in the following as 1, . . . , k fixing an arbitrary order. As in <ref type="bibr" target="#b9">[10]</ref>, we want to impose a number of horizontal constraints (constraints on the annotations of neighboring cells in a given configuration) and of vertical constraints (constraints on the annotation of the same cell in successive configurations). These constraints can be written as two sets of pairs H (M w ) and V (M w ) of integers 1 ⩽ i, j ⩽ k, respectively, indicating respectively whether j can appear to the right of i in a configuration, and whether j can appear in the same cell as i in a successive configuration. We refer to <ref type="bibr" target="#b9">[10]</ref> for the full set of constraints required.</p><p>In our physical tree representation, the content of a cell is not represented by a single label, but by a chain of descendants. For each cell, the c-node has two children, labeled with m (for me) and f (for forbidden), each having as descendants a chain of k nodes that can have labels either 0 or 1. Only one node has label 1 under m, the one whose depth gives the current content of the cell; other nodes under m have label 0. Under f , for a cell at position i in the tape, node at depth j has label 0 if and only if (i, j) ∈ V (M w ), and label 1 otherwise.</p><p>In Fig. <ref type="figure" target="#fig_8">2</ref> we see a bird's eye view of one of our encodings. In the box in the lower part of the picture near the center of the page, we have highlighted the physical encoding of an abstract tape, focusing on the physical encoding of the address structure while omitting the encoding of the cell content. In the box closer to the left border we have zoomed in on the encoding of a tape cell's content.</p><p>As in <ref type="bibr" target="#b9">[10]</ref>, we can construct in polynomial time a BNTA that enforces that all physical trees have the described form, including respect of horizontal constraints, initial configuration at the root and accepting configuration at the leaves, but excluding vertical constraints. Indeed, vertical constraints cannot (at least straightforwardly) be imposed on the tree as they relate nodes of the tree that are very far apart -see <ref type="bibr" target="#b9">[10]</ref> for how to encode horizontal constraints and the general structure. Modifications needed because of our binary setting are minor. The language of this BNTA is exactly the codes of accepting computation trees for M w , except that vertical constraints may be violated. We will now construct a conjunctive query that holds if vertical constraints are violated. In what follows, we denote by R i (x, y) the chain ∃x 1 . . .</p></div>
<div><head>⊥</head><formula xml:id="formula_54">Conf r s p 0 1 c f • k m • k 2n -1 NextConf Conf r s p 0 1 TTCh s • • • s • • • s p 1 0 TTCh • • • NextConf • • • Conf • • • ℓ physical tape tree tape cell's content</formula><formula xml:id="formula_55">x i-1 R(x, x 1 ) ∧ • • • ∧ R(x i-1 , y) for R a binary relation and i ⩾ 1.</formula><p>We first need to construct a conjunctive query SameCell(s 1 , s 2 ) that expresses that two s-nodes encoding a node at depth n in the tape tree (i.e., at the bottom of the tape tree) correspond to the same cell of successive configuration tapes. To do that, we will need the following subformulas:</p><p>• A formula Succ(r 1 , r 2 ) that expresses that r 1 and r 2 are each the root of a tree encoding a tape, with the configuration of r 2 being a successor in the computation tree of that of r 1 . Formally: Succ(r 1 , r 2 ) ∃s 1 s 2 Label r (r 1 ) ∧ Label r (r 2 ) ∧ Child(s 1 , r 1 ) ∧ Child(s 2 , r 2 ) ∧ Child 2 (s 1 , s 2 ).</p><p>• A formula Φ i (x, y) that expresses that x and y are s-nodes encoding a node at the i-th level of two tape trees, such that the configuration of y is a successor in the computation tree of the configuration of x:</p><p>Φ i (x, y) ∃r 1 r 2 Label s (x) ∧ Label s (y) ∧ Succ(r 1 , r 2 ) ∧ Child 2i -1 (r 1 , x) ∧ Child 2i -1 (r 2 , y).</p><p>• A formula Ψ i (x, y) that expresses that Φ i (x, y) holds and that, additionally, x and y are both first children or both second children of their parents (Ψ i (x, y) does not hold if x is a first child and y a second child or vice versa); note that we could not use <software>FirstChild</software> and <software ContextAttributes="used">SecondChild</software> here as it would require disjunction. We can, however, use the navigation widgets: x , t x ) ∧ Child ? (t ′ y , t y ) ∧ Child (2i -1)+4 (z, t x ) ∧ Child (2i -1)+6 (z, t y ) Observe that when x and y are both first children, the t x and t y are grandchildren of the p-node, and therefore at distance (2i -1) + 3 of the r -node, so going up (2i -1) + 4 times brings us to the Conf-node of the current configuration, and going up (2i -1) + 6 times brings us to the Conf-node of the preceding configuration. Similarly, if x and y are both second children, the t x and t y are children of the p-node, so going up (2i -1) + 4 times brings us to the parent of the Conf-node of the current configuration, and going up (2i -1) + 6 times brings us to the parent of the Conf-node of the preceding configuration. This is one of the two places where we need the chain of ℓ nodes at the root: otherwise, since the initial configuration does not have a preceding configuration, we would not be able to go high enough up in the tree to find the z node. Taking ℓ ⩾ 1 suffices.</p><formula xml:id="formula_56">Ψ i (x,</formula><p>• Finally, SameCell(s 1 , s 2 ) is written as:</p><formula xml:id="formula_57">SameCell(s 1 , s 2 ) ∃x 1 • • • x n-1 y 1 • • • y n-1 1⩽i &lt;n-1 Child 2 (x i , x i+1 ) ∧ Child 2 (y i , y i+1 ) ∧ Child 2 (x n-1 , s 1 ) ∧ Child 2 (y n-1 , s 2 ) ∧ Ψ n (s 1 , s 2 ) ∧ 1⩽i &lt;n Ψ i (x i , y i ).</formula><p>We can now use these subformulas in the following sentence, that expresses the final conjunctive query Q. It checks whether the two same cells s 1 and s 2 of successive configurations violate vertical constraints. Remember that the value of a cell is encoded under the m-node, while vertical constraints are encoded under the f -node. A vertical constraint occurs when the (unique) position of a 1-node under the m-descendant of s 2 is equal to the position of a 1-node under the f -descendant of s 1 . </p></div>
<div><head>Q</head><formula xml:id="formula_58">∧ Label f (f 1 ) ∧ Label m (m 2 ) ∧ Label 1 (u 1 ) ∧ Label 1 (u 2 ) ∧ (Child ? ) k (f 1 , u 1 ) ∧ (Child ? ) k (m 2 , u 2 )</formula><p>∧ Child (2n-1+3)+k (z, u 1 ) ∧ Child (2n-1+5)+k (z, u 2 ). This is the other place we need the chain of ℓ nodes at the root: otherwise, again, since the initial configuration does not have a preceding configuration, we would not be able to go high enough up in the tree to find the z node. Taking ℓ ⩾ k -1 suffices.</p><p>The query Q can be constructed in polynomial time, and Q is valid over the BNTA previously constructed if and only if the Turing machine M w has no accepting (EXPSPACE) computation tree. □</p><p>This hardness result of CQ validity over trees satisfying a DTD actually implies hardness of UCQ validity over all trees, thanks to the following argument, that shows that BDTD constraints can be encoded by the negation of a union of conjunctive queries. Segoufin and ten Cate <ref type="bibr" target="#b32">[33]</ref> define the language UNFP which can express the conjunction of an <software ContextAttributes="used">MDL</software> query with a negated UCQ; they show that the satisfiability for this language is 2EXPTIMEcomplete. An EXPTIME bound on satisfiability is shown for a fragment called Simple UNFP; the fragment cannot express UCQs, much less the negation of a UCQ conjoined with an <software ContextAttributes="used">MDL</software> query. <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> shows a 2EXPTIME upper bound for containment of datalog in positive queries with constants.</p><p>Limited access containment. The problem of containment under access restrictions originates from <ref type="bibr" target="#b11">[12]</ref> and is examined further in <ref type="bibr" target="#b12">[13]</ref>. The model allows constants in the users queries, and also allows relations to be typed from a domain, which could have a fixed set of values. It restricts to conjunctive queries, rather than UCQs as in earlier work.</p><p>Both papers claim a co-NEXPTIME bound for the problem, with the proof being sketched in <ref type="bibr" target="#b11">[12]</ref> and given in detail in <ref type="bibr" target="#b12">[13]</ref>. The argument applies a technique similar to the one applied in our work: one shows that if there is a counterexample instance for containment, it can be taken to be tree-like (a "crayfish-chase instance" in the terminology of <ref type="bibr" target="#b12">[13]</ref>). Then it is claimed that if there is a tree-like instance, it can be truncated to have depth polynomially bounded; this is Lemma 5 of <ref type="bibr" target="#b12">[13]</ref>. The shrinking is done by repeatedly finding appropriate comparable nodes and replacing the subtree of the upper node with the subtree of the lower node. It is thus analogous to showing that exponential sized paths must have two nodes with the same automaton state.</p><p>Our results apply to access method containment for UCQs without constants, and provide an EXPTIME bound, and thus are orthogonal to those in <ref type="bibr" target="#b12">[13]</ref>. In addition, our bounds apply to other classes of <software ContextAttributes="used">MDL</software> containment problems where the polynomial depth property does not hold.</p><p>We also believe that there is a flaw in the proof of Lemma 5 of <ref type="bibr" target="#b12">[13]</ref>, already in the case of queries without constants and with a single domain for all attributes. Indeed, consider a schema with one binary relation R, with an access on its second position, and two unary relations S and T , with free accesses on each. On this schema, consider the following queries: Q 1 : ∃x∃y R(x, y) ∧ S(x) Q 2 : ∃x∃y R(x, y) ∧ S(x) ∧ T (y) In Fig. <ref type="figure" target="#fig_9">3</ref> (left), we give an example database instance D that is in the crayfish-chase of Q 1 (one can verify that all properties of the crayfish-chase, in Definition 2 of <ref type="bibr" target="#b12">[13]</ref>, are satisfied). We are in subcase (1b) of the proof of Lemma 5 of <ref type="bibr" target="#b12">[13]</ref>: Q 2 is connected, and there is more than one relation (R and S) that can be on the smallest level (0) of the mapped facts of Q 2 in a crayfish-chase of Q 1 . Accordingly, we consider all paths in D from a node of level 0 to a leaf, and we consider the first and last occurrences of every relation among R and S. Only the two atoms framed in Fig. <ref type="figure" target="#fig_9">3</ref> (left) are of interest here. The proof then proceeds with shrinking the database, by applying the replacement (see Definition 4 of <ref type="bibr" target="#b12">[13]</ref>) of the subtree rooted at the upper node by the subtree rooted rooted at the lower node, resulting in the database instance in Fig. <ref type="figure" target="#fig_9">3</ref> (right). The proof goes on by applying further replacements to other cases of multiple occurrences of relations in the database, irrelevant here as every relation appears only once. Now, observe that Q 2 is satisfied in the resulting database but not in the original database D, whereas Lemma 5 of <ref type="bibr" target="#b12">[13]</ref> claims that the shrunk database after subtree replacements cannot be satisfied by Q 2 if the original database was not satisfied by Q 2 .</p><p>The problem comes from joins at level 0 of crayfish-chase database forests. We do not see how the proof can be easily fixed, say by imposing that subtree replacement is only carried at levels that are deep enough: it seems critical in the proof that subtree replacements of relations in Q 2 are done at the occurrence of a relation that has the lowest-level possible, to ensure that newly created joins with relations above this level do not change the satisfaction of Q 2 . Of course, these comments do not amount to a disproof of the polynomial depth property claimed in the paper. We leave this question for future work.</p><p>Our main upper bound technique originates from our work on limited access querying <ref type="bibr" target="#b5">[6]</ref>. There we showed a co-NEXPTIME bound for a particular kind of <software ContextAttributes="used">MDL</software>/UCQ containment problem, using a special case of the technique. Our upper bounds here are an abstraction of the idea in <ref type="bibr" target="#b5">[6]</ref>, relating it to tree-like instances. Our lower bounds can be seen as exploring the limits of this method. However <ref type="bibr" target="#b5">[6]</ref> also contains some significant errors.</p><p>• A co2NEXPTIME lower bound for containment of positive queries (which extend UCQs by allowing ∃, ∨, ∧ to be freely mixed) under access patterns is claimed. The proof in <ref type="bibr" target="#b5">[6]</ref> is flawed, and in <ref type="bibr" target="#b3">[4]</ref> a 2EXPTIME upper bound on this problem is proven. The latter is at odds (relative to complexity-theoretic hypothesis) with the former. • A coNEXPTIME upper bound is claimed in <ref type="bibr" target="#b5">[6]</ref> for containment of UCQs under general access patterns. The proof given there only works for schemas with a single-access per relation. The multiple access containment problem is open (see the discussion in Section 7).</p><p>Validity and containment problems on trees. Björklund et al. <ref type="bibr" target="#b7">[8]</ref> study containment of tree automata in UCQs with child and descendant. We make use of their lower bound technique in our first result, while also refining one of their upper bounds in the absence of a descendant predicate. Some of the results in this work were announced in the conference paper <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div><head n="7">CONCLUSIONS AND FUTURE WORK</head><p>In this paper we have revisited the containment problem for recursive queries in UCQs. We started by showing that the problem is hard for doubly-exponential time in general. We then analyzed the phenomenon of tree-like models (monadic expansion trees) for recursive queries in more detail, and give a parameter -the number of IQ classes -that controls the size of a minimal counterexample to containment. We have shown that if a logic has models that are "very tree-like", then the number of distinct ways a CQ can map into the model is limited, and thus an exponential bound can be shown on the number of IQ classes. We have applied this analysis to two logics and two collections of instances -<software>GEMDL</software> and tree automata. But we believe that it can be applied to other fragments of <software ContextAttributes="used">MDL</software>.</p><p>Our results on limited access containment come with two main restrictions, and we discuss lifting them here.</p><p>First we assume that there are no constants in the queries. This does not make any difference in the 2EXPTIME upper bounds for general <software>MDL</software> containment in UCQs, but the assumption is critical for our EXPTIME upper bounds. We believe that the addition of constants makes all of our EXPTIME-complete problems into co-NEXPTIME-complete problems.</p><p>The second restriction is that there is a single access method per relation. Although this is a standard assumption in the literature, it is easily seen to be unimportant for decidability of the problem. Indeed, one still get a 2EXPTIME bound for limited access containment, either directly via tree-like witnesses or by reduction to <software>MDL</software> containment. As with constants, the issue is whether the EXPTIME bound carries over to this case. Although we conjecture that the EXPTIME bounds carry over to this case, the problem is open at the time of writing.</p></div><figure xml:id="fig_0"><head>Lemma 4 . 8 (</head><label>48</label><figDesc>Composition Lemma). Let Q ′ be a UCQ, and I , I ′ two monadic expansion trees. Let n ∈ T(I ) and n ′ ∈ T(I ′ ) two nodes of these instances such that there is an output-isomorphism φ from n to n ′ . Assume that for all children n c of n and n ′ c of n ′ with the output element of n c mapped by φ to the output element of n</figDesc></figure>
<figure xml:id="fig_1"><head /><label /><figDesc>We denote by B(d, σ ) the set of output-isomorphism classes of nodes in the instances of L(d, σ ). Since the size of bags is bounded, the size of B(d, σ ) is finite. Let us derive a bound on its size: to choose an element of B(d, σ ), one can choose at most d relation names among O(|σ |) and, for each of the positions in the corresponding atoms, the number of which is in O(d • |σ |), choose a constant among O(d • |σ |) possible ones; then, one needs to choose at most (r + 1) output elements among these O(d • |σ |) values, where r is the rank of the tree. Since r is itself bounded by the number of constants, i.e., O(d • |σ |), we obtain a total bound on the size of B(d, σ ) of:</figDesc></figure>
<figure xml:id="fig_2"><head /><label /><figDesc>for some constant χ , i.e., simply exponential in d and in the size of σ .For each output-isomorphism class c of B(d, σ ), we choose a distinct symbol ĉ and we consider the finite setΓ(d, σ ) = { ĉ | c ∈ B(d, σ ) }. Γ(d, σ) is used as an alphabet for the finite trees that will be used to abstract monadic expansion trees out. For I ∈ L(d, σ ), we denote by Code d (I ) the finite tree labeled by tags in Γ(d, σ ) obtained from T(I ) by labeling each node of T(I ) by the symbol ĉ corresponding to its output-isomorphism class c. Definition 4.9. Let σ be a signature, I a collection of monadic expansion trees over σ , and d a positive integer. We say I is d-regular if I ⊆ L(d, σ ) and there exists a DTA Rk A I over the alphabet Γ(d, σ ) recognizing exactly the set { Code d (I ) | I ∈ I }.</figDesc></figure>
<figure xml:id="fig_3"><head /><label /><figDesc>each node of an instance in I has at most d facts, each of which having at most |σ | places. The transition function δ takes as input a list l of at most d • |σ | types in Y and a label α in Γ(</figDesc></figure>
<figure xml:id="fig_4"><head /><label /><figDesc>e., O(|B(d, σ )| × |Z| O (d • |σ |) ) times. □ General UCQs. Theorem 4.10 restricted attention to connected CQs. Now consider the case where</figDesc></figure>
<figure xml:id="fig_5"><head>Corollary 4 . 18 .</head><label>418</label><figDesc>Let σ be a signature, d a positive integer, and Q ′ a UCQ over σ . Let I be a d-regular set of monadic expansion trees over σ with the Q ′ -UMC and recognized by the tree automaton A I . Then checking if Q ′ holds over all I ∈ I can be done in O(|A I | × 2 poly(|Q ′ |,d , |σ |) ).</figDesc></figure>
<figure xml:id="fig_6"><head>Theorem 4 . 19 .</head><label>419</label><figDesc>) Children of a given node n v ∈ T(I ) are ordered in an arbitrary manner. It is easy to verify that (I, T(I )) is a monadic expansion tree. It has at most 4 facts per node for S bin Ch1,Ch2 (the root bag contains one FirstChild, one SecondChild, one Label, and one Root fact), 6 for S bin Ch1,Ch2,Child (same plus two Child facts), and r + 2 for S unrankedChildwhere r is the rank of the tree.We will show that the collection of such trees is an instance class that satisfies the UMC: Let σ be any of S unranked Child , S bin Ch1,Ch2 , S bin Ch1,Ch2,Child . The collection of monadic expansion trees (I, T(I )), where I is a tree over σ , satisfies the ∀-UMC.Towards proving the theorem, first note the following: Lemma 4.20. Let σ be any of S unranked Child , S bin</figDesc></figure>
<figure xml:id="fig_7"><head>Child)</head><label /><figDesc>answers a question left open from [8]. Corollary 4.21. Validity of a UCQ over S unranked Child , S bin Ch1,Ch2 , or S bin Ch1,Ch2,Child with respect to a tree automaton is in EXPTIME. Proof. Let us first consider the ranked case, i.e., σ = S bin Ch1,Ch2 or σ = S bin Ch1,Ch2,Child . We pose d = 4 in the former case, d = 6 in the latter.</figDesc></figure>
<figure xml:id="fig_8"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. General structure of trees in proof of Theorem 5.3; bold labels and counters highlight changes from the proof of Theorem 6 of<ref type="bibr" target="#b7">[8]</ref> </figDesc></figure>
<figure xml:id="fig_9"><head>Fig. 3 .</head><label>3</label><figDesc>Fig.3. Left: Example database in the crayfish-chase of query Q 1 : ∃x∃y R(x, y) ∧ S(x). Right: Same database after applying the subtree replacement procedure in the proof of Lemma 5 of<ref type="bibr" target="#b12">[13]</ref>.</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>2.8. Consider, again, the monadic expansion tree of Example 2.5. It is actually a witness of non-containment of the program P of Example 2.2 into the UCQ's Q 1 from Example 2.2.</figDesc><table /></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>t. DTDs using Corollary 5.2.</figDesc><table><row><cell /><cell>CQ</cell><cell>UCQ</cell><cell>CQ</cell><cell>UCQ</cell></row><row><cell>Signature</cell><cell>(DTD or tree automaton)</cell><cell>(DTD or tree automaton)</cell><cell>(all trees)</cell><cell>(all trees)</cell></row><row><cell>S unranked Child S bin Ch1,Ch2 S bin Ch1,Ch2,Child S bin Ch1,Ch2,Child,Child ?</cell><cell>EXPTIME-complete (Cor. 4.21) in EXPTIME (Cor. 4.21) EXPTIME-complete (Cor. 4.21) 2EXPTIME-complete (Thm 5.3)</cell><cell>EXPTIME-complete (Cor. 4.21) EXPTIME-complete EXPTIME-complete (Cor. 4.21) 2EXPTIME-complete (Thm 5.3)</cell><cell>PTIME PTIME PTIME PTIME</cell><cell>EXPTIME-complete (Cor. 4.21, Prop. 5.8) EXPTIME-complete EXPTIME-complete (Cor. 4.21, Cor. 5.7) 2EXPTIME-complete (Cor. 5.5)</cell></row></table><note><p>(Cor. 4.21, Thm 5.6) (Cor. 4.21, Cor. 5.7)</p></note></figure>
<figure type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Summary of results on the complexity of query containment. We give references to statements proving the bounds, from Sections 4 (upper bounds) and 5 (lower bounds) or the literature. over all trees refer to the combined complexity of the problem that takes as input both the query and label set, determining if the query is valid for that label set. There is one exception where a tight bound is still open: the case of CQs over S bin Ch1,Ch2 with respect to BDTDs or BNTAs. In all other cases (beyond the trivial PTIME case of CQs over all trees), we establish 2EXPTIME-completeness (for S bin Ch1,Ch2,Child,Child ?</figDesc><table><row><cell>Query containment setting</cell><cell>Containment</cell><cell>Upper bound Lower bound</cell></row><row><cell cols="3">MDL in MDL MDL in UCQ MDL in CQ UCQ in UCQ + access constraints EXPTIME-complete Cor. 4.28 2EXPTIME-complete [22, Thm 7.2] 2EXPTIME-complete [22, Thm 7.2] 2EXPTIME-complete [22, Thm 7.2] AGEMDL in UCQ EXPTIME-complete Cor. 4.28 3-GEMDL in UCQ 2EXPTIME-complete [22, Thm 7.2] Datalog in UCQ 2EXPTIME-complete [19, Thm 5.12] [19, Thm 5.15] Thm 5.9 Thm 5.9 Thm 5.9 Thm 5.11 Cor. 5.12 Thm 5.10</cell></row><row><cell>results on validity</cell><cell /><cell /></row></table></figure>
<figure type="table" xml:id="tab_4"><head /><label /><figDesc>y) ∃p x p y t x t y t ′ x t ′ y z Φ i (x, y) ∧ Label p (p x ) ∧ Label p (p y ) ∧ Label 1 (t x ) ∧ Label 1 (t y ) ∧ Child(x, p x ) ∧ Child(y, p y ) ∧ Child(p x , t ′ x ) ∧ Child(p y , t ′ y ) ∧ Child ? (t ′</figDesc><table /></figure>
<figure type="table" xml:id="tab_5"><head /><label /><figDesc>∃s 1 s 2 t 1 t 2 f 1 m 2 u 1 u 2 z SameCell(s 1 , s 2 ) ∧ Child(s 1 , t 1 ) ∧ Child(s 2 , t 2 ) ∧ Child(t 1 , f 1 ) ∧ Child(t 2 , m 2 )</figDesc><table /></figure>
			<note place="foot" xml:id="foot_0"><p>ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.</p></note>
			<note place="foot" n="1" xml:id="foot_1"><p>To the best of our knowledge, with the exception of<ref type="bibr" target="#b5">[6]</ref>, work on containment under limited access patterns has assumed (at most) a single access per relation. Indeed, access patterns are usually defined to be attached to positions of a relation. See Section 7 for a discussion of the importance of this assumption. ACM Trans. Comput. Logic, Vol.</p></note>
			<note place="foot" xml:id="foot_2"><p>21, No. 1, Article 6. Publication date: October 2019.</p></note>
			<note place="foot" n="2" xml:id="foot_3"><p>Since our definition of BNTA requires a binary tree to be full, we need to add dummy nodes where needed, with labels distinct from real nodes. This technicality has no impact, and we will ignore these nodes.ACM Trans. Comput. Logic, Vol. 21, No. 1, Article 6. Publication date: October 2019.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENT</head><p><rs type="person">Benedikt</rs> was funded by the <rs type="funder">EPSRC</rs> grants <rs type="funder">PDQ</rs> (<rs type="grantNumber">EP/M005852/1</rs>), <rs type="grantNumber">ED 3</rs> (<rs type="grantNumber">EP/N014359/1</rs>), and <rs type="funder">DBOnto</rs> (<rs type="grantNumber">EP/L012138/1</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_nPGuBhf">
					<idno type="grant-number">EP/M005852/1</idno>
				</org>
				<org type="funding" xml:id="_mTXDaBC">
					<idno type="grant-number">ED 3</idno>
				</org>
				<org type="funding" xml:id="_pbq8ZWs">
					<idno type="grant-number">EP/N014359/1</idno>
				</org>
				<org type="funding" xml:id="_ezVQp5S">
					<idno type="grant-number">EP/L012138/1</idno>
				</org>
			</listOrg>
			<div type="annex">
<div> <ref type="bibr">Lemma 5.4</ref><p>. Let τ = (d, l 0 ) be a BDTD. Then one can construct in polynomial time a UCQ q τ over S bin</p><p>Ch1,Ch2 such that for any binary tree t, t is accepted by τ iff t does not satisfy q τ . Proof. We denote by d c the function from Λ to 2 Λ×Λ such that for any α ∈ Λ, d c (α) = 2 Λ×Λ -d(α). We denote by φ α the query equal to ∃x Leaf(x) ∧ Label α (x) if ε ∈ d c (α) and equal to false, e.g., ∃x <software>FirstChild</software>(x, x), otherwise.</p><p>We define q τ as follows:</p><p>α ∈Λ (β ,γ )∈d c (α )</p><p>(∃xyz Label α (x) ∧ <software>FirstChild</software>(x, y) ∧ Label β (y) ∧ <software ContextAttributes="used">SecondChild</software>(x, z) ∧ Label γ (z))</p><p>It is easy to check that t is accepted by the DTD τ iff t does not satisfy q τ . □ Corollary 5.5. Deciding whether a UCQ on S bin Ch1,Ch2,Child,Child ? is valid is 2EXPTIME-hard. Proof. We reduce the problem of Theorem 5.3 to the current problem. Let τ be a DTD and q be a CQ on S bin Ch1,Ch2,Child,Child ? . Thanks to Lemma 5.4, we can construct q τ in polynomial time such that t does not satisfy q ∨ q τ if and only if t ∈ L(τ ) and t ̸ |= q. □ In the restricted case where Child and Child ? relations cannot be used in the query, we prove an EXPTIME lower bound, which matches the upper bound of Corollary 4.21. This result is proved in <ref type="bibr" target="#b8">[9]</ref>, in a slightly different setting, as the Child relation is allowed (because of this restriction, we prove the hardness for UCQs instead of CQs). Theorem 5.6. [Adapted from Theorem 10 of <ref type="bibr" target="#b8">[9]</ref>] Deciding whether a UCQ on S bin Ch1,Ch2 is valid over a DTD, or whether a CQ on S bin Ch1,Ch2,Child or S unranked Child is valid over a DTD, is EXPTIME-hard.</p><p>Proof. Theorem 10 of <ref type="bibr" target="#b8">[9]</ref> shows the EXPTIME-hardness of CQ validity on S bin Ch1,Ch2,Child over an NTA. The CQ used in the proof is of the form:</p><p>The setting of <ref type="bibr" target="#b8">[9]</ref> is that of unranked trees, but the proof of Theorem 10 only uses binary trees. They are not full binary trees, but they can easily be rendered full by adding nodes with dummy labels as second children of nodes with a single child.</p><p>To move from NTAs to DTDs, we use Corollary 5.2 (in the same way, Theorem 12 of <ref type="bibr" target="#b8">[9]</ref> states the EXPTIME-hardness of CQ validity on S bin Ch1,Ch2,Child over a DTD). The only thing that remains to be proven is the EXPTIME-hardness of UCQ validity on S bin Ch1,Ch2 over an NTA. This is easily done by observing that in the proof of Theorem 10 of <ref type="bibr" target="#b8">[9]</ref> all but one of the Child can be replaced by a <software ContextAttributes="used">FirstChild</software> atom (the proof relies on the reduction from a tiling game, and non-branching chains of nodes are used to encodes tiles and constraints, with branching used only to encode choices of one of the player; the query matches nodes within the encoding two successive tiles, thus with at most one branching on the second child).</p><p>We consider the query Q ′ i , for 1 ⩽ i ⩽ n -1, obtained by replacing in Q the i-th atom Child(x i , x i+1 ) by an atom <software>SecondChild</software>(x i , x i+1 ), and all other atoms Child(x i , x i+1 ) by an atom <software ContextAttributes="used">FirstChild</software>(x i , x i+1 ). We then let</p><p>, which is a formula with n(2n -1) atoms (and thus of polynomial size in the size of Q).</p><p>Then Q ′ can be used instead of Q in the proof of Theorem 10 of <ref type="bibr" target="#b8">[9]</ref>, and Q ′ is on S bin Ch1,Ch2 Proof. We consider the problem of tiling a polynomial width grid. A solution to such a problem can be coded as a path, where the label alphabet are the tiles and the path represents the concatentation of the rows of the tiling. Given a tiling problem we can create in polynomial time a UCQ Q such that the tiling problem has a solution if and only if a counterexample to validity of Q codes a solution. The satisfaction of the horizontal constraint will correspond to one CQ of Q, while the satisfaction of the vertical constraint will represent a second CQ. □</p></div>
<div><head n="5.2">Lower bounds for MDL and limited access containment</head><p>We now apply the prior results to get bounds on <software>MDL</software> and limited access containment. We first show a 2EXPTIME lower bound for the problem of checking the containment of a monadic datalog program in a CQ. This matches the general upper bound for the containment of a datalog query within a union of CQs. Theorem 5.9. <software ContextAttributes="used">MDL</software> containment in a CQ is 2EXPTIME-hard.</p><p>Proof. We reduce from the problem of validity of a CQ on S bin Ch1,Ch2,Child,Child ? over a BNTA, which is 2EXPTIME-hard by Theorem 5.3.</p><p>Let A = (Ω, ∆ 0 , ∆, F ) be a BNTA and Q a conjunctive query. We build a monadic datalog program P as follows:</p><p>• For every q ∈ Ω, we have an intensional monadic predicate P q .</p><p>• For every q ∈ F , we have a rule: Goal() ← Root(r ) ∧ P q (r ).</p><p>• For every symbol α ∈ Λ, for every q ∈ ∆ 0 (α), we have a rule:</p><p>• For every symbol α ∈ Λ, for every q 1 , q 2 , q ′ ∈ Ω such that q ′ ∈ ∆(α, q 1 , q 2 ), we have a rule:</p><p>We claim that this is a valid reduction of tree validity to <software>MDL</software> containment. In one direction, given a counterexample to tree validity of Q, we can interpret the relations of the program in the usual way, and this is easily seen to be a counterexample to containment of P in Q.</p><p>In the other direction, if there is a counterexample to containment of P in Q, then by the proof of Proposition 2.6 there is a counterexample that is an expansion tree of the program P, with the notion of expansion tree defined in <ref type="bibr" target="#b18">[19]</ref>: see the proof of Proposition 2.6 for a review of the notion of expansion tree. But one can see that an expansion tree of P must actually be a tree over S bin Ch1,Ch2,Child,Child ? . Further, the second rule guarantees that such a tree must satisfy that BNTA A.</p><p>□</p><p>We now show a more elaborate result, which is that even for a restricted subset of <software>MDL</software> generalizing <software ContextAttributes="used">AGEMDL</software>, the problem of containment in a UCQ is 2EXPTIME-hard.</p><p><software>AGEMDL</software> forbids a relation from occurring more than once outside of the goal predicate, which is a strong restriction. A simple generalization is to consider the class of <software ContextAttributes="used">MDL</software> queries where relations can occur in a bounded number of rules. Let k-<software ContextAttributes="used">GEMDL</software> be the class obtained by replacing "in only one rule", with "in at most k rules" in the definition of <software ContextAttributes="used">GEMDL</software> (while still restricting to one occurrence per rule). Thus, 3-<software ContextAttributes="used">GEMDL</software> is the class of <software ContextAttributes="used">MDL</software> queries such that:</p><p>(i) every extensional predicate appears in at most 3 rules;</p><p>(ii) every extensional predicate appears at most once in a rule. We show that in the case of 3-<software>GEMDL</software>, the complexity jumps back up to 2EXPTIME, relying on our 2EXPTIME-hardness result for UCQ validity over trees of S bin Ch1,Ch2,Child,Child ? . Because of space constraints, the proof is deferred to an electronic appendix.</p><p>Theorem 5.10. 3-<software>GEMDL</software> containment in a UCQ is 2EXPTIME-hard.</p><p>We similarly show, by using a reduction from UCQ validity over trees of S bin Ch1,Ch2 to UCQ containment under limited access patterns, EXPTIME-hardness of this latter problem: Again, because of space constraints, the proof is deferred to an electronic appendix.</p><p>Theorem 5.11. The problem of UCQ containment under limited access patterns is EXPTIME-hard. The hardness holds even if every access has at most one output position.</p><p>Theorem 5.11 implies, in particular, by Proposition 4.23: Corollary 5.12. Containment of an <software>AGEMDL</software> query in a UCQ is EXPTIME-hard.</p><p>We have thus shown matching complexity lower bounds for the upper bounds of <ref type="bibr" target="#b32">[33]</ref> on monadic datalog containment and of Section 4.5 on <software ContextAttributes="used">AGEMDL</software> containment in a UCQ, using reductions from tree validity problems.</p></div>
<div><head n="6">RELATED WORK</head><p>Monadic datalog containment. Special cases of the containment problem of monadic datalog in UCQs have been studied in the past. As mentioned in the introduction, the Chaudhuri and Vardi article <ref type="bibr" target="#b17">[18]</ref> proved a co-NEXPTIME upper bound of containment of unary <software ContextAttributes="used">MDL</software> queries in a union of unary connected conjunctive queries. Their paper extends earlier work by Courcelle <ref type="bibr" target="#b22">[23]</ref>, who noted the connection with graph decompositions, and by Chaudhuri and Vardi <ref type="bibr" target="#b16">[17]</ref> (published in journal form in <ref type="bibr" target="#b18">[19]</ref>) that established complexity bounds for containment of general datalog queries in non-recursive datalog queries. The proof technique in <ref type="bibr" target="#b17">[18]</ref> does not extend to non-connected unary queries, as our 2EXPTIME-completeness results for the general case show.</p><p>A PROOF OF THEOREM 5.10</p><p>Theorem 5.10. 3-GEMDL containment in a UCQ is 2EXPTIME-hard.</p><p>Proof. We reduce from UCQ validity over trees of S bin ? (see Corollary 5.5). For technical reasons, it will be more convenient to reduce from hardness of UCQ validity over trees of S bin Ch1,Ch2,Child,Child ? that have more than one node (i.e., whose root is not a leaf). So we start by showing that we can assume this without loss of generality: Claim A.1. UCQ validity over trees of S bin Ch1,Ch2,Child,Child ? reduces to UCQ validity over trees of S bin Ch1,Ch2,Child,Child ? with more than one node.</p><p>Proof of the claim. Let Q be a UCQ which is an instance of the former problem. For every α ∈ Λ, we evaluate Q over the tree consisting only of a root with label α. This evaluation can be done in time linear in Q: a CQ is true over such a tree iff it does not include any Child or β atoms with β α.</p><p>If one of these evaluations returns false, we take for Q ′ the query ∃x Root(x) ∧ Leaf(x); otherwise we take Q ′ Q. Observe that if Q is valid over all trees, then it is in particular valid over all rootonly trees and Q ′ = Q is valid over all trees with more than one node. Conversely, if Q is not valid over all trees, either there is a root-only tree that does not satisfy Q and then</p><p>is not satisfied by any tree with more than one node, or there is a tree with more than one node that does not satisfy Q and then it does not satisfy</p><p>Now let Q be a UCQ over S bin Ch1,Ch2,Child,Child ? which is an instance for the UCQ validity problem over trees with more than one node.</p><p>The goal is to construct a 3-<software>GEMDL</software> query Q ′ 1 and a UCQ Q ′ 2 over a relational signature such that Q is valid over trees of S bin Ch1,Ch2,Child,Child ? if and only if</p><p>To achieve this, we build a one-to-one correspondence between binary tree witnesses of non-validity of Q and minimal monadic expansion tree witnesses of non-containment of</p><p>The binary tree will be encoded as the expansion tree of Q ′ 1 . The temptation would be to have a unary predicate U (x) and an extensional predicate Child(x, y) with a rule, such as U (x) ← Child(x, y), Child(x, z), U (y), U (z) which will generate a binary expansion tree. However, this is problematic for two reasons:</p><p>(1) The 3-<software>GEMDL</software> restriction prevents us from having two occurrences of the same extensional predicate, such as Child in the rule above. (2) We need to express Q by UCQ Q ′ 2 over the encoded structure, and Q uses the Child ? predicate in addition to Child. Naively inlining Child ? (x, y) as a disjunction Child(x, y) ∨ (x = y) will lead to an exponential blowup. To resolve the two sources of difficulty just mentioned, we are going to use the following relational signature:</p><p>• a 7-ary relation C;</p><p>• unary predicates P 3 , P 4 , P 5 ;</p><p>• a unary predicate LabInd α for every label α of Λ;</p><p>• a unary predicate Leaf;</p><p>• a unary predicate Root; The relation C serves to connect a parent node p with its two children node q and r , in a way that is pictured in Fig. <ref type="figure">4</ref> and that we will detail further. The positions of C have the following intended meaning:</p><p>(i) the node identifier;</p><p>(ii) a value used to connect a parent with its first child;</p><p>(iii) a value used to connect a first child with its sibling;</p><p>LabInd α p (l p )</p><p>LabInd α q (l q )</p><p>LabInd α r (l r ) Fig. <ref type="figure">4</ref>. Example of coding of the Child relation between a parent node p and its children q and r (iv) a value used to distinguish the parent when connected to predicate P 3 ;</p><p>(v) a value used to distinguish the first child when connected to predicate P 4 ;</p><p>(vi) a value used to distinguish the second child when connected to predicate P 5 ;</p><p>(vii) a value used to connect to a label predicate LabInd α . We now define the 3-<software>GEMDL</software> query Q ′ 1 as follows; it uses 7 unary intensional predicates U 0 . . . U 6 (intuitively meant to represent each abstract domain of a position of C) as well as a goal predicate:</p><p>We define the translation of the relations Child, Child ? , <software>FirstChild</software>, <software ContextAttributes="used">SecondChild</software>, and Label α (for α ∈ Λ) over binary trees into conjunctive queries Child ′ , Child ? ′ , <software ContextAttributes="used">FirstChild</software> ′ , <software ContextAttributes="used">SecondChild</software> ′ , and Label ′ α . These will be used as subformulas of the formula Q ′ 2 that we will construct.</p><p>The "_" symbols denote anonymous existentially used variables with a single occurrence each.)</p><p>We finally construct query Q ′ 2 by replacing in Q all occurrences of R(x, y) with the R ′ (x, y) subformula, where R stands for Child, Child ? , <software>FirstChild</software>, <software ContextAttributes="used">SecondChild</software>, or Label α . The Root and Leaf atoms are left as is. We also add to Q ′ 2 the following UCQs. Their role is to ensure that the instance represents a tree structure, by forbidding a node to have two different labels, and forbidding a root node to have a parent or to be a leaf: 3   • for every α, β ∈ Λ with α β:</p><p>2 is a UCQ, and its construction is in polynomial time. We show that containment of Q ′ 1 in Q ′ 2 under the access restrictions of the schema is equivalent to the validity of Q over binary trees of S bin Ch1,Ch2,Child,Child ? . To prove one direction, consider a binary tree T over S bin Ch1,Ch2,Child,Child ? with more than one node that does not satisfy Q. We define the relational instance I of the target schema made of:</p><p>• for each leaf node p of T , a fact Leaf(p);</p><p>• for each node p of T with children q and r the facts shown on Fig. <ref type="figure">4</ref> (with all fresh variables except for p, q, r ) -in that figure α s denotes the label of node s; • for the root r of T , an additional fact Root(r ). Note that since T is not a root-only tree, every node is either a child or a parent node, and therefore there will be at least one C atom for every node ofT . By construction, the instance I satisfies Q ′ 1 and is actually a minimal monadic expansion tree witness for Q ′ 1 : this is due to the fact that for each node x in the tree T , one can show by induction on the tree structure that the <software ContextAttributes="used">MDL</software> program Q ′ 1 produces the intensional fact U 0 (x). Now, observe that for X in Child, Child ? , <software ContextAttributes="used">FirstChild</software>, <software ContextAttributes="used">SecondChild</software>, X ′ (x, y) is true in I if and only if X (x, y) is true in T (in Child ′ , the second and third C atoms can unify; in Child ? ′ all three C atoms can unify). Similarly, the translation of a Label α , Root or Leaf atom holds in I if and only if the original atom holds in T . Q ′ 2 is therefore false in I , while Q ′ 1 holds in I . Thus I is a witness to non-containment.</p><p>Conversely, assume we have a witness</p><p>By Proposition 2.6, we can assume, without loss of generality, I to be a monadic expansion tree. We also assume I to be minimal, in the sense that no subinstance of I remains a valid monadic expansion tree instance of</p><p>We construct a binary tree T from I as follows: • The set of nodes of T is the projection of C onto its first position in I ; leaves are the content of the Leaf predicate in I , which is a subset of the nodes thanks to the minimality of I . A Leaf(x) fact not connected to the first position of a C fact can be safely removed from I ; since ψ Root is not satisfied we know that there is no Leaf(x) fact directly connected to a Root(x) fact. • A node y is the first (resp., second) child of a node x if and only if <software>FirstChild</software> ′ (x, y) (resp., <software ContextAttributes="used">SecondChild</software> ′ (x, y)) holds in I . 3 Forbidding a root node to be a leaf is a technical requirement, that ensures we have a way to assign a label to this root node.</p><p>• The root of T is the unique value in Root in I (the existence is given by the satisfiability of Q ′ 1 . The uniqueness comes from the of I : if I contains two Root(x) facts with distinct</p><p>x's, one of them can be removed still resulting in a valid monadic expansion tree).</p><p>• The label of a given node x is given by the unique α such that</p><p>holds in I . The existence of α is guaranteed by the fact that, since no Leaf(x) fact is directly connected to a Root(x) fact, the only way to produce an intensional U 0 (x) fact is to have a C fact, which requires the existence of a LabInd fact. The uniqueness comes from the fact I does not satisfy any of the ψ α ,β 's.</p><p>Since we want to view T as a tree over S bin Ch1,Ch2,Child,Child ? , we add to T all facts for Child and Child ? implied by <software>FirstChild</software> and <software ContextAttributes="used">SecondChild</software>. We argue that, equivalently, Child(x, y) and Child ? (x, y) are added to T whenever Child ′ (x, y) or Child ? ′ (x, y) hold in I . Indeed, if for example Child ′ (x, y) holds, either the second and third C predicate in the definition of Child ′ unify (which means <software ContextAttributes="used">FirstChild</software> ′ (x, y) holds) or they do not, in which case the U 2 (v 2 ) intensional fact required must have been created by a rule that implies that a P 5 (w 5 ) fact also exists, and this means <software ContextAttributes="used">SecondChild</software> ′ (x, y) holds. The reasoning is similar for Child ? ′ (x, y).</p><p>Observe that by the fact that I is a monadic expansion tree and by minimality, the instance I contains, for each node x of T , one or two C facts with x as first position. If x is not a leaft, there is one fact which would be the parent of an x; this would be connected to a P 3 atom. If x is not the root, another fact would be either a first child of x, connected to a P 4 atom, or a second child, connected to a P 5 atom in the schema of Fig. <ref type="figure">4</ref>. Keep in mind that the root cannot be a leaf. Furthermore, because of the structure of the <software ContextAttributes="used">MDL</software> program Q ′ 1 , the tree T(I ) which witnesses that I is a monadic expansion tree will have the following property: if Child ′ (x, y) holds, then x is an output element of a bag that is an ancestor of the bag whose output element is y.</p><p>Following the definition of trees in Section 2.3, we check that T is indeed an ordered, labeled, binary tree.</p><p>(i) We have already shown that each node has exactly one label.</p><p>(ii) We have established that leaf nodes could not have a C(_, _, _, u 3 , _, _, _) fact such that P 3 (u 3 ) holds in I , which means they cannot be a parent in T . On the other hand, all internal nodes have exactly one first child and one second child in T . Similarly, a first child cannot be a second child. (iii) Every non-root child has a C fact in either first or second child position in I and has thus exactly one parent in T . (iv) A node cannot be a child of itself: if Child ′ (x, y) holds, x y since they are output elements of different bags. (v) We have already shown that the root r is unique. The formula ψ Root guarantees that Child ′ (x, r )</p><p>does not hold, which exactly means that r does not have a parent in T . Finally, since I does not satisfy Q ′ 2 , T does not satisfy Q, which concludes the proof. □ B PROOF OF THEOREM 5.11 Theorem 5.11. The problem of UCQ containment under limited access patterns is EXPTIME-hard. The hardness holds even if every access has at most one output position.</p><p>Proof. Let Q be a union of conjunctive queries over trees of S bin Ch1,Ch2 . We construct in polynomialtime two UCQs over some schema with access methods, such that containment under limited access holds if and only if Q is valid over all trees. We then conclude using Corollary 5.7.</p><p>We build a schema S such that any monadic expansion tree encodes a binary tree. Let R be a relation of arity 4 such the first position indicates the parent relation, the second and third positions indicate the <software>FirstChild</software> and <software ContextAttributes="used">SecondChild</software> relations, and the last position encodes the label of the node. The access method associated with R has as input the last three positions and for output the first position. Let R α for α ∈ Λ be a set of unary relations, with each of these relations having a free access method. Let R Root and R Leaf be two unary relations. The first relation has a Boolean access method, while the second relation has a free access method. Note that every access has at most one output position.</p><p>The relation <software>FirstChild</software>(x, y) is simulated by the formula φ <software ContextAttributes="used">FirstChild</software> (x, y) = ∃z∃w R(x, y, z, w). The relation <software ContextAttributes="used">SecondChild</software>(x, y) is simulated by the formula φ <software ContextAttributes="used">SecondChild</software> (x, y) = ∃z∃w R(x, z, y, w). The relation P α (x) is simulated by the formula φ α (x) = ∃y∃z∃w R(x, y, z, w) ∧ R α (w). The relation Root(x) is simulated by the formula φ Root (x) = R Root (x). The relation Leaf(x) is simulated by the formula φ Leaf (x) = ∃y∃z∃w R(x, y, z, w) ∧ R Leaf (y) ∧ R Leaf (z).</p><p>We denote by q 2 the query obtained by replacing in Q the relations of S bin Ch1,Ch2 by the associated formulas. The query q 1 is the disjunction of the following forbidden patterns of the monadic expansion tree:</p><p>(1) A value in the second or third position of R appears in the relations R α :</p><p>(2) A value in the fourth position of R appears in the relation R Leaf or in the first position of an</p><p>) A fact of R has a value in its second position appearing in R Leaf and a value in its third position appearing as the first position in another R fact, and conversely with second and third reversed:</p><p>We claim that q 0 = ∃x φ Root (x) is contained in q 1 ∧ q 2 under the access constraints iff Q is valid over trees in S bin Ch1,Ch2 . Let us first assume T is a tree on S bin Ch1,Ch2 that does not satisfy query Q. We define I the relational instance on S formed of:</p><p>• for each leaf p of T with label α, facts R(p, q, r, s), R Leaf (q), R Leaf (r ), and R α (s) for some fresh constants q, r , s; • for each internal node p of T with label α and children q and r , facts R(p, q, r, s) and R α (s) for some fresh constant s; • for the root r of T a fact R Root (r ). First, observe that AccFacts(I ) = I . Indeed, all facts of the R Leaf and R α are accessible since these relations have a free access method. Furthermore, the R fact associated to each leaf is accessible using the R Leaf and R α facts as inputs of the access method on R, and the R fact associated to an internal node is accessible as long as the R facts associated with the children of that node are accessible. We can thus show by induction on the depth of the tree that every R fact is accessible. Similarly, the R Root fact is accessible once the R fact corresponding to the root is accessible.</p><p>We then show that I |= q 0 while I ̸ |= q 1 ∧ q 2 , which will witness that q 0 is not contained in q 1 ∧ q 2 under the access constraints. It is clear that I |= q 0 . Now, observe that none of the forbidden patterns of q 1 is present in I , which means I ̸ |= q 1 . Now, I is simply a relational encoding of T and, by construction, I q 2 if and only if T |= Q, which we now not to hold. This means I ̸ |= q 1 ∧ q 2 .</p><p>Conversely, assume some instance I of S is a witness of non-containment of q 0 in q 1 ∧ q 2 under access constraints. We can assume, w.l.o.g., I to be a monadic expansion tree (by Corollary 2.15), and to be minimal among all monadic expansion tree instances; in particular, the minimality implies that I = AccFacts(I ). We construct a tree T on S bin Ch1,Ch2 in the following manner: • The nodes of T are the values in the first position of the relation R in I .</p><p>• A node q is first (resp., second) child of a node p if and only if φ <software>FirstChild</software> (p, q) (resp, φ <software ContextAttributes="used">SecondChild</software> (p, q)) holds. • A node p is a leaf if φ Leaf (p) holds.</p><p>• A node p is the root if R Root (p) holds.</p><p>• The label of a node p is the α such that φ α (p) holds. All that remains to be shown is that T is indeed well-defined. Once this is shown, since I is a relational encoding of T and I |= q 2 if and only if T |= Q, we conclude that T ̸ |= Q and thus that Q is not valid over all trees on S bin Ch1,Ch2 . So, following the definition of trees in Section 2.2, we check that T is indeed an ordered, labeled, binary tree.</p><p>(i) Since the fourth position of R is an input position, for every R fact there should be a fact that provides the value in fourth position of that fact in an output position. The pattern (2) of q 1 prevents it to be an R Leaf or R fact. The only remaining possibility is that of an R α fact, which means for every node p, some φ α (p) holds. Since I is a monadic expansion tree and minimal, there can only be one such R α fact for every R fact, and no two R facts can have the same value in first position. (ii) For every R node, by pattern (3) of R, the values in second and third position either both come from an R Leaf fact, or neither comes from an R Leaf fact. In the latter case, by pattern (1) of R, they cannot come from an R α fact either, so they must both come from the output position of an R fact, which means all non-leaf nodes indeed have two child nodes. (iii) Since I is a monadic expansion tree, no two R facts can have the same value in first position, and every non-root node indeed has a unique parent. (iv) Again, since I is a monadic expansion tree, no node can be a child of itself. (v) Since q 0 holds, there is an R Root fact in I . By minimality of I , is it is unique. □</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Provenance Circuits for Trees and Treelike Instances (Extended Version)</title>
		<author>
			<persName><forename type="first">Antoine</forename><surname>Amarilli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
		<idno>CoRR abs/1511.08723</idno>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Querying Schemas with Access Paths</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clemens</forename><surname>Ley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Analysis of Schemas with Access Restrictions</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clemens</forename><surname>Ley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">5</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Monadic Datalog Containment</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Determining relevance of accesses at runtime</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Senellart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Complexity of Boundedness for Guarded Logics</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Balder Ten Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Colcombet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boom</forename><surname>Vanden</surname></persName>
		</author>
		<ptr target="https://www.cs.ox.ac.uk/people/michael.vandenboom/papers/LICS15-gnfpb-long.pdf" />
	</analytic>
	<monogr>
		<title level="m">LICS. Extended version</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Optimizing Conjunctive Queries over Trees Using Schema Information</title>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Björklund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schwentick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MFCS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Validity of tree pattern queries with respect to schema information</title>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Björklund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schwentick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MFCS</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Conjunctive query containment over trees using schema information</title>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Björklund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schwentick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On the decidability of containment of recursive datalog queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Piero</surname></persName>
		</author>
		<author>
			<persName><surname>Bonatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Containment of Conjunctive Queries under Access Limitations</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SEBD</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Conjunctive Query Containment under Access Limitations</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Martinenghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ER</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Decidable containment of recursive queries</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giacomo</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Containment of Conjunctive Regular Path Queries with Inverse</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<editor>KR.</editor>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Alternation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ashok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><forename type="middle">J</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1981">1981. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On the Equivalence of Recursive and Nonrecursive Datalog Programs</title>
		<author>
			<persName><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the Complexity of Equivalence between Recursive and Nonrecursive Datalog Programs</title>
		<author>
			<persName><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the Equivalence of Recursive and Nonrecursive Datalog Programs</title>
		<author>
			<persName><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JCSS</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Domino-Tiling Games</title>
		<author>
			<persName><forename type="first">Bogdan</forename><forename type="middle">S</forename><surname>Chlebus</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(86)90036-X</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(86)90036-X" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="374" to="392" />
			<date type="published" when="1986">1986. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Tree Automata Techniques and Applications</title>
		<author>
			<persName><forename type="first">Max</forename><surname>Hubert Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rémi</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florent</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://www.grappa.univ-lille3.fr/tata/" />
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Decidable Optimization Problems for Database Logic Programs</title>
		<author>
			<persName><forename type="first">Stavros</forename><forename type="middle">S</forename><surname>Cosmadakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haim</forename><surname>Gaifman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paris</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Recursive queries and context-free graph grammars</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1991">1991. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Recursive Plans for Information Gathering</title>
		<author>
			<persName><forename type="first">M</forename><surname>Oliver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Duschka</surname></persName>
		</author>
		<author>
			<persName><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Tree Languages</title>
		<author>
			<persName><forename type="first">Ferenc</forename><surname>Gécseg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Magnus</forename><surname>Steinby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Formal Languages</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Rozenberg</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Salomaa</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Answering Queries with Useful Bindings</title>
		<author>
			<persName><forename type="first">Chen</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TODS</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="313" to="343" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Query containment for data integration systems</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">D</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="20" to="39" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Automata Theory for XML Researchers</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Neven</surname></persName>
		</author>
		<idno type="DOI">10.1145/601858.601869</idno>
		<ptr target="https://doi.org/10.1145/601858.601869" />
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="39" to="46" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Answering Queries Using Templates with Binding Patterns</title>
		<author>
			<persName><forename type="first">Anand</forename><surname>Rajaraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yehoshua</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Graph minors. II. Algorithmic aspects of tree-width</title>
		<author>
			<persName><forename type="first">Neil</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">D</forename><surname>Seymour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1986">1986. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Equivalence of datalog queries is undecidable</title>
		<author>
			<persName><forename type="first">Oded</forename><surname>Shmueli</surname></persName>
		</author>
		<idno type="DOI">10.1016/0743-1066(93)90040-N</idno>
		<ptr target="https://doi.org/10.1016/0743-1066(93)90040-N" />
	</analytic>
	<monogr>
		<title level="j">J. Log. Program</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Generalizations of Regular Sets and Their Application to a Study of Context-Free Languages</title>
		<author>
			<persName><forename type="first">Masako</forename><surname>Takahashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="36" />
			<date type="published" when="1975">1975. 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Unary negation</title>
		<author>
			<persName><forename type="first">Cate</forename><surname>Balder Ten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">STACS. ACM Trans. Comput. Logic</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2011-10">2011. October 2019</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>