<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Single Approach to Decide Chase Termination on Linear Existential Rules</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
							<email>leclere@lirmm.fr</email>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<email>mugnier@lirmm.fr</email>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
							<email>michael.thomazo@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
							<email>ulliana@lirmm.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">University of Montpellier</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">University of Montpellier</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">ENS</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">PSL University</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">University of Montpellier</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department" key="dep1">Leibniz International Proceedings</orgName>
								<orgName type="department" key="dep2">Informatics Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
								<orgName type="department" key="dep3">Dagstuhl Publishing</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Single Approach to Decide Chase Termination on Linear Existential Rules</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">103B7F891728F8F7FF8FEE70D47E6873</idno>
					<idno type="DOI">10.4230/LIPIcs.ICDT.2019.18</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>2012 ACM Subject Classification Theory of computation → Logic; Computing methodologies → Knowledge representation and reasoning Chase</term>
					<term>Tuple Generating Dependencies</term>
					<term>Existential rules</term>
					<term>Decidability</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Existential rules, long known as tuple-generating dependencies in database theory, have been intensively studied in the last decade as a powerful formalism to represent ontological knowledge in the context of ontology-based query answering. A knowledge base is then composed of an instance that contains incomplete data and a set of existential rules, and answers to queries are logically entailed from the knowledge base. This brought again to light the fundamental chase tool, and its different variants that have been proposed in the literature. It is well-known that the problem of determining, given a chase variant and a set of existential rules, whether the chase will halt on any instance, is undecidable. Hence, a crucial issue is whether it becomes decidable for known subclasses of existential rules. In this work, we consider linear existential rules with atomic head, a simple yet important subclass of existential rules that generalizes inclusion dependencies. We show the decidability of the all-instance chase termination problem on these rules for three main chase variants, namely semi-oblivious, restricted and core chase. To obtain these results, we introduce a novel approach based on so-called derivation trees and a single notion of forbidden pattern. Besides the theoretical interest of a unified approach and new proofs for the semi-oblivious and core chase variants, we provide the first positive decidability results concerning the termination of the restricted chase, proving that chase termination on linear existential rules with atomic head is decidable for both versions of the problem: Does every chase sequence terminate? Does some chase sequence terminate?</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The chase procedure is a fundamental tool for solving many issues involving tuple-generating dependencies, such as data integration <ref type="bibr" target="#b20">[21]</ref>, data-exchange <ref type="bibr" target="#b10">[11]</ref>, query answering using views <ref type="bibr" target="#b15">[16]</ref> or query answering on probabilistic databases <ref type="bibr" target="#b23">[24]</ref>. In the last decade, tuple-generating dependencies raised a renewed interest under the name of existential rules for the problem known as ontology-based query answering. In this context, the aim is to query a knowledge base (I, Σ), where I is an instance and Σ is an ontology given as a set of existential rules (see e.g. the survey chapters <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">23]</ref>). In more classical database terms, this problem can be recast as querying an instance I under open-world assumption, provided with a set of constraints Σ, which are tuple-generating dependencies. The chase is a fundamental tool to solve dependency-related problems as it allows one to compute a (possibly infinite) universal model of (I, Σ), i.e., a model that can be homomorphically mapped to any other model of (I, Σ). Hence, the answers to a conjunctive query (and more generally to any kind of query closed by homomorphism) over (I, Σ) can be defined by considering solely this universal model. Several variants of the chase have been introduced, and we focus in this paper on the main ones: semi-oblivious <ref type="bibr" target="#b21">[22]</ref> (aka Skolem <ref type="bibr" target="#b21">[22]</ref>), restricted <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b10">11]</ref> (aka standard <ref type="bibr" target="#b24">[25]</ref>) and core <ref type="bibr" target="#b8">[9]</ref>. Any chase variant starts from an instance and exhaustively performs a sequence of non-redundant rule applications according to a redundancy criterion which characterizes the variant itself. The built sequence is required to be fair, i.e., no rule application deemed non-redundant can be indefinitely left out. It is well known that all the above variants produce homomorphically equivalent results but obey increasingly stronger redundancy criteria, hence terminate for increasingly larger subclasses of existential rules.</p><p>The question of whether a chase variant terminates on all instances for a given set of existential rules is known to be undecidable when there is no restriction on the kind of rules <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">12]</ref>. A number of sufficient syntactic conditions for termination have been proposed in the literature for the semi-oblivious chase (see e.g. <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b26">27]</ref> for syntheses), as well as for the restricted chase <ref type="bibr" target="#b7">[8]</ref> (note that the latter paper also defines a sufficient condition for non-termination). However, only few positive results exist regarding the termination of the chase on specific classes of rules. Decidability was shown for the semi-oblivious chase on guarded-based rules (linear rules, and their extension to (weakly-)guarded rules) <ref type="bibr" target="#b3">[4]</ref>. Decidability of the core chase termination on guarded rules for a fixed instance was shown in <ref type="bibr" target="#b16">[17]</ref>.</p><p>In this work, we provide new insights on the chase termination problem for linear existential rules with atomic head, a simple yet important subclass of guarded existential rules, which generalizes inclusion dependencies <ref type="bibr" target="#b9">[10]</ref> and some practical ontological languages <ref type="bibr" target="#b5">[6]</ref>. When we are interested in the ontology-based query answering problem, we note that linear rules are first-order rewritable, hence answering conjunctive queries on linear rule knowledge bases can be solved by query rewriting <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr">18]</ref>. However, it is well known that the size and the unusual form of the rewritten query may lead to practical efficiency issues. Hence, the materialization of ontological inferences in the data is often an effective alternative to query rewriting, provided that some chase algorithm terminates. Finally, having the choice of how to process a set of linear rules extends the applicability of query answering techniques that combine query rewriting and materialization <ref type="bibr" target="#b0">[1]</ref>.</p><p>Precisely, the question of whether a chase variant terminates on all instances for a set of linear existential rules with atomic head is studied in two fashions: does every chase sequence terminate? does some chase sequence terminate?</p><p>It is well-known that these two questions have the same answer for the semi-oblivious and the core chase variants, but not for the restricted chase. Indeed, this last one may admit both terminating and non-terminating sequences over the same knowledge base. We show that the termination problem is decidable for linear existential rules with atomic head, no matter which version of the problem and which chase variant we consider.</p><p>We study chase termination by exploiting in a novel way a graph structure, namely the derivation tree, which was originally introduced to solve the ontology-based (conjunctive) query answering problem for the family of greedy-bounded treewidth sets of existential rules <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">28]</ref>, a class that generalizes guarded-based rules and in particular linear rules. We first use derivation trees to show the decidability of the termination problem for the semi-oblivious and restricted chase variants, and then generalize them to entailment trees to show the decidability of termination for the core chase. For every chase variant we consider, we adopt the same high-level procedure: starting from a finite set of canonical instances (representative of all possible instances), we build a (set of) tree structures for each canonical instance, while forbidding the occurrence of a specific pattern, that we call unbounded-path witness. The structures that we build are finite thanks to this forbidden pattern, and this allows us to decide if the chase terminates on the associated canonical instance. By doing so, we obtain a uniform approach to study the termination of several chase variants, which we believe to be of theoretical interest per se. In particular, some important differences in the chase behaviors become more visible. The derivation tree is moreover a simple structure, which makes the algorithms built on it effectively implementable. Let us also point out that our approach is constructive: if the chase terminates on a given instance, the algorithm that decides termination actually computes the result of the chase (or a superset of it in the case of the core chase), otherwise it pinpoints a forbidden pattern responsible for non-termination.</p><p>Besides providing new theoretical tools to study chase termination for linear existential rules with atomic head, we obtain the following results: a new proof of the decidability of the semi-oblivious chase termination, building on different objects than the previous proof provided in <ref type="bibr" target="#b3">[4]</ref>; we show that our algorithm provides the same complexity upper-bound; the decidability of the restricted chase termination, for both versions of the problem, i.e., termination of all chase sequences and termination of some chase sequence; to the best of our knowledge, these are the first positive results on the decidability of the restricted chase termination; a new proof of the decidability of the core chase termination, with different objects than previous work reported in <ref type="bibr" target="#b16">[17]</ref>; although this latter paper solves the question of the core chase termination given a fixed instance, the results actually allow to infer the decidability of the all-instance version of the problem (still on linear rules), by noticing that only a finite number of instances need to be considered (see the next section).</p><p>The paper is organized as follows. After introducing some preliminary notions (Section 2), we define the main components of our framework, namely derivation trees and unboundedpath witnesses (Section 3). We build on these objects to prove the decidability of the semi-oblivious and restricted chase termination (Section 4). Finally, we generalize derivationtrees to entailment trees and use them to prove the decidability of the core chase termination (Section 5). Detailed proofs are provided in <ref type="bibr" target="#b18">[19]</ref>. A previous version of this work was presented as an extended abstract in <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We consider a logical vocabulary composed of a finite set of predicates and an infinite set of constants. An atom α has the form r(t 1 , . . . , t n ) where r is a predicate of arity n and the t i are terms (i.e., variables or constants). We denote by terms(α) (resp. vars(α)) the set of terms (resp. variables) in α and extend the notations to a set of atoms. A ground atom does not contain any variable. It is convenient to identify (the existential closure of) a conjunction of atoms with the set of these atoms. A set of atoms is atomic if it contains a single atom. An instance is a set of (non-necessarily ground) atoms, which is finite unless otherwise specified. Abusing terminology, we will often see an instance as its isomorphic model. Given two sets of atoms S and S , a homomorphism from S to S is a substitution π of vars(S ) by terms(S) such that π(S ) ⊆ S. It holds that S |= S (where |= denotes classical logical entailment) iff there is a homomorphism from S to S. An endomorphism of S is a homomorphism from S to itself. A set of atoms is a core if it admits only injective endomorphisms. Any finite set of atoms is logically (or: homomorphically) equivalent to one of its subsets that is a core, and this core is unique up to isomorphism (i.e., bijective variable renaming). Given sets of atoms S and S , we say that S folds onto S if there is a homomorphism π from S \ S to S such that π is the identity on vars(S). The homomorphism π is called a folding. In particular, it is well-known that any set of atoms folds onto its core.</p><p>An existential rule (or simply rule) is of the form σ = ∀x∀y [body(x, y) → ∃z head(x, z)] where x, y and z are pairwise disjoint tuples of variables, body(x, y) and head(x, z) are non-empty conjunctions of atoms respectively on x ∪ y and x ∪ z, called the body and the head of the rule, and also denoted by body(σ) and head(σ). The variables of z are called existential variables. The variables of x form the frontier of σ, which is also denoted by fr(σ). For brevity, we will omit universal quantifiers in the examples. A knowledge base (KB) is of the form K = (I, Σ), where I is an instance and Σ is a finite set of existential rules.</p><p>A rule σ = body(σ) → head(σ) is applicable to an instance I if there is a homomorphism π from body(σ) to I. The pair (σ, π) is called a trigger for I. The result of the application of σ according to π on I is the instance I = I ∪ π s (head(σ)), where π s extends π by assigning a distinct fresh variable (also called a null) to each existential variable. <ref type="foot" target="#foot_0">1</ref> We also say that I is obtained by firing the trigger (σ, π) on I. By π |fr(σ) we denote the restriction of π to the domain fr(σ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1 (Derivation).</head><p>A Σ-derivation (or simply derivation when Σ is clear from the context) from an instance I = I 0 to an instance I n is a sequence I 0 , (σ 1 , π 1 ), I 1 . . . , (σ n , π n ), I n , such that for all 1 ≤ i ≤ n: σ i ∈ Σ, (σ i , π i ) is a trigger for I i-1 , I i is obtained by firing (σ i , π i ) on I i-1 , and I i = I i-1 . The notion of derivation can be naturally extended to an infinite sequence. Note that the condition I i = I i-1 in the above definition implies that all triggers in a derivation produce distinct atoms. We briefly introduce below the main chase variants and refer to <ref type="bibr" target="#b24">[25]</ref> for a detailed presentation.</p><p>The semi-oblivious chase prevents several applications of the same rule through the same mapping of its frontier. Given a derivation from I 0 to I i , a trigger (σ, π) for I i is said to be active according to the semi-oblivious criterion, if (1) there is no trigger (σ j , π j ) in the derivation with σ = σ j and π |fr(σ) = π j | fr(σj ) and (2) the extension of I i with (σ, π) remains a derivation, i.e., π(head(σ)) ⊆ I i . The restricted chase performs a rule application only if the added set of atoms is not redundant with respect to the current instance. Given a derivation from I 0 to I i , a trigger (σ, π) for I i is said to be active according to the restricted criterion if π cannot be extended to a homomorphism from (body(σ) ∪ head(σ)) to I i (equivalently, π s (head(σ)) does not fold onto I i ). We say that a (possibly infinite) derivation is a semioblivious (resp. restricted) derivation if it is built by firing only active triggers according to the semi-oblivious (resp. restricted) criterion. A (possibly infinite) derivation is fair if no firing of an active trigger is indefinitely delayed; formally: if some I i in the derivation admits an active trigger (σ, π), then there is j &gt; i such that, either I j is obtained by firing (σ, π) on I j-1 , or (σ, π) is not an active trigger anymore on I j . A terminating derivation is a finite fair derivation (in other words, a finite derivation that does not admit any active trigger on its final instance). A semi-oblivious (resp. restricted) chase sequence is a fair semi-oblivious (resp. restricted) derivation. Hence, a chase sequence is terminating if and only if it is finite.</p><p>In its original definition <ref type="bibr" target="#b8">[9]</ref>, the core chase proceeds in a breadth-first manner, and, at each step, first fires in parallel all active triggers according to the restricted chase criterion, then computes the core of the result. Alternatively, to bring the definition of the core chase closer to the above definitions of the semi-oblivious and restricted chases, one can define a core derivation as a possibly infinite sequence I 0 , (σ 1 , π 1 ), I 1 , . . ., alternating instances and triggers, such that each (σ i , π i ) is an active trigger on I i-1 according to the restricted criterion, and I i is obtained from I i-1 by first firing (σ i , π i ), then computing the core of the result. Then, a core chase sequence is a fair core derivation. An instance admits a terminating core chase sequence in that sense if and only if the core chase as originally defined terminates on that instance.</p><p>For the three chase variants, a chase sequence defines a (possibly infinite) universal model of the KB, but only the core chase stops if and only if the KB has a finite universal model.</p><p>It is well-known that, for the semi-oblivious and the core chase, if there is a terminating chase sequence from an instance I then all chase sequences from I are terminating. This is not the case for the restricted chase, since the order in which rules are applied has an impact on termination, as illustrated by Example 2. The semi-oblivious chase does not terminate on I as σ 1 is applied indefinitely, while the core chase terminates after one breadth-first step and returns I * . The restricted chase has a terminating sequence, for example I 0 = I, (σ 2 , {x → a, y → b}), I 1 = I * , but it also has infinite sequences, for instance sequences that apply always σ 1 before σ 2 on a given atom.</p><p>We study the following problems for the semi-oblivious, restricted and core chase variants: (All-instance) all-sequence termination: Given a set of rules Σ, is it true that, for any instance, all chase sequences are terminating? (All-instance) one-sequence termination: Given a set of rules Σ, is it true that, for any instance, there is a terminating chase sequence? Note that, according to the terminology of <ref type="bibr" target="#b13">[14]</ref>, these problems can be recast as deciding whether, for a chase variant, a given set of rules belongs to the class CT ∀∀ or CT ∀∃ , respectively.</p><p>An existential rule is called linear if its body is atomic, see e.g., <ref type="bibr" target="#b5">[6]</ref>. As often done, we moreover restrict linear rules to atomic heads (and still use the name linear rules). Linear rules generalize inclusion dependencies <ref type="bibr" target="#b9">[10]</ref> by allowing several occurrences of the same I C D T 2 0 1 9 18:6 A Single Approach to Decide Chase Termination on Linear Existential Rules variable in an atom. They also generalize positive inclusions in the description logic DL-Lite R (the formal basis of the web ontological language OWL 2 QL) <ref type="bibr" target="#b6">[7]</ref>, which can be seen as inclusion dependencies restricted to unary and binary predicates.</p><p>Note that the restriction of existential rules to rules with an atomic head is often made in the literature, considering that any existential rule with a complex head can be decomposed into several rules with an atomic head, by introducing a fresh predicate for each rule. However, while this translation preserves the termination of the semi-oblivious chase, it is not the case for the restricted and the core chases. Hence, considering linear rules with a complex head would require to extend the techniques developed in this paper.</p><p>To simplify the presentation, we assume in the following that each rule frontier is of size at least one. This assumption is made without loss of generality. <ref type="foot" target="#foot_1">2</ref>We first point out that the termination problem on linear rules can be recast by considering solely atomic instances (as already remarked in several contexts).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 3. Let Σ be a set of linear rules. The semi-oblivious (resp. restricted, core) chase terminates on all instances if and only if it terminates on all atomic instances.</head><p>We will furthermore rely on the following notion of the type of an atom. Definition 4 (Type of an atom). The type of an atom α = r(t 1 , . . . , t n ), denoted by type(α), is the pair (r, P) where P is the partition of {1, . . . , n} induced by term equality (i.e., i and j are in the same class of P iff t i = t j ).</p><p>There are finitely (more specifically, exponentially) many types for a given vocabulary. When two atoms α and α have the same type, there is a natural mapping from α to α , denoted by ϕ α→α , and defined as follows: it is a bijective mapping from terms(α) to terms(α ), that maps the i-th term of α to the i-th term of α . Note that ϕ α→α may not be an isomorphism, as constants from α may not be mapped to themselves. However, if (σ, π) is a trigger for {α}, then (σ, ϕ α→α • π) is a trigger for {α }, as there are no constants in the considered rules.</p><p>Together with Proposition 3, this implies that one can check all-instance all-sequence termination by checking all-sequence termination on a finite set of instances, called canonical instances: for each type, we take exactly one canonical instance that has this type.</p><p>We will consider different kinds of tree structures, which have in common to be trees of bags.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Tree of bags).</head><p>A tree of bags is a rooted tree whose nodes, called bags, <ref type="foot" target="#foot_2">3</ref>  Finally, we recall some classical mathematical notions. A subsequence S of a sequence S is a sequence that can be obtained from S by deleting some (or no) elements without changing the order of the remaining elements. The arity of a tree is the maximal number of children for a node. A prefix T of a tree T is a tree that can be obtained from T by repeatedly deleting some (or no) leaves of T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Derivation Trees</head><p>A classical tool to reason about the chase is the so-called chase graph (see e.g., <ref type="bibr" target="#b5">[6]</ref>), which is the directed graph consisting of all atoms that appear in the considered derivation, and with an arrow from a node n 1 to a node n 2 iff n 2 is created by a rule application on n 1 and possibly other atoms. <ref type="foot" target="#foot_3">4</ref> In the specific case of KBs of the form (I, Σ), where I is an atomic instance and Σ a set of linear rules, the chase graph is a tree. We recall below its definition in this specific case, in order to emphasize its differences with another tree, called derivation tree, on which we will actually rely.</p><p>Definition 6 (Chase Graph for Linear Rules). Let I 0 = {α} be an atomic instance, Σ be a set of linear rules, and S = I 0 , (σ 1 , π 1 ), I 1 , . . . , (σ n , π n ), I n be a semi-oblivious Σ-derivation. The chase graph (also called chase tree) assigned to S is a tree of bags built as follows:</p><p>the set of bags is in bijection with I n via the labeling function atom(); the set of edges is in bijection with the set of triggers in S and is built as follows: for each trigger (σ i , π i ) in S, there is an edge (B, B ) with atom(B) = π i (body(σ i )) and atom(B ) = π s i (head(σ i )).</p><p>Example 7. Let I 0 = q(a) and Σ = {σ 1 , σ 2 } where σ 1 = q(x) → ∃y∃z∃t p(x, y, z, t) and σ 2 = p(x, y, z, t) → p(x, z, t, y). Let S = I 0 , (σ 1 , π 1 ), I 1 , (σ 2 , π 2 ), I 3 , (σ 2 , π 3 ), I 3 with π 1 = {x → a}, π s 1 (head(σ 1 )) = p(a, y 0 , z 0 , t 0 ), π 2 = {x → a, y → y 0 , z → z 0 , t → t 0 } and π 3 = {x → a, y → z 0 , z → t 0 , t → y 0 }. The chase graph associated with S is a path of four nodes as pictured in Figure <ref type="figure" target="#fig_2">1</ref>.</p><p>To check termination of a chase variant on a given KB (with an atomic instance), the general idea is to build a tree of bags associated with the chase on this KB in such a way that the occurrence of some forbidden pattern indicates that a path of unbounded length can be developed, hence the chase does not terminate. The forbidden pattern is composed of two distinct nodes such that one is an ancestor of the other and, intuitively speaking, these nodes "can be extended in similar ways", which leads to an arbitrarily long path that repeats the pattern.</p><p>Two atoms with the same type admit the same rule triggers, however, within a derivation, the same rule applications cannot necessarily be performed on both of them because of the presence of other atoms (this is already true for datalog rules, since the same atom is never produced twice). Hence, on the one hand we will specialize the notion of type, into that of a sharing type, and, on the other hand, adopt another tree structure, called a derivation tree, in which two nodes with the same sharing type have the required similar behavior. q(a) p(a, y 0 , z 0 , t 0 ) p(a, z 0 , t 0 , y 0 ) p(a, t 0 , y 0 , z 0 )</p><formula xml:id="formula_0">B 0 B 1 B 2 B 3</formula><p>Chase Graph q(a) p(a, y 0 , z 0 , t 0 ) p(a, z 0 , t 0 , y 0 ) p(a, t 0 , y 0 , z 0 )</p><formula xml:id="formula_1">B 0 B 1 B 2 B 3</formula><p>Derivation Tree Definition 8 (Sharing Type). Given a tree of bags, the sharing type of a bag B is a pair (type(atom(B)), P ) where P is the set of positions in atom(B) in which a term of shared(B) occurs. We denote the fact that two bags B and B have the same sharing type by B ≡ st B .</p><p>We can now specify the forbidden pattern that we will consider: it is a pair of two distinct nodes with the same sharing type, such that one is an ancestor of the other. As explained below on Example 7, the chase graph is not the appropriate tool to use this forbidden pattern as a witness of chase non-termination.</p><p>Example 7 (continued). B 1 , B 2 and B 3 in the chase graph of Figure <ref type="figure" target="#fig_2">1</ref> have the same classical type, t = (p, {{1}, {2}, {3}, {4}}). The sharing type of B 1 is (t, {1}), while B 2 and B 3 have the same sharing type (t, {1, 2, 3, 4}). B 2 and B 3 fulfill the condition of the forbidden pattern, however it is easily checked that any derivation that extends this derivation is finite.</p><p>Derivation trees were introduced as a tool to define the greedy bounded treewidth set (gbts) family of existential rules <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b27">28]</ref>. A derivation tree is associated with a derivation, however it does not have the same structure as the chase graph. The fundamental reason is that, when a rule σ is applied to an atom α via a homomorphism π, the newly created bag is not necessarily attached in the tree as a child of the bag labeled by α. Instead, it is attached as a child of the highest bag in the tree labeled by an atom that contains π(fr(σ)), the image by π of the frontier of σ (note that π(fr(σ)) remains the set of terms shared between the new bag and its parent). This highest bag is unique. It is also the first created bag that contains π(fr(σ)).</p><p>In the following definition, a derivation tree is not associated with any derivation, but with a semi-oblivious derivation, which has the advantage of yielding trees with bounded arity. This is appropriate to study the termination of the semi-oblivious chase, and later the restricted chase, as a restricted derivation is a specific semi-oblivious derivation.</p><p>Definition 10 (Derivation Tree). Let I 0 = {α} be an atomic instance, Σ be a set of linear rules, and S = I 0 , (σ 1 , π 1 ), I 1 , . . . , (σ n , π n ), I n be a semi-oblivious Σ-derivation. The derivation tree assigned to S is a tree T of bags built as follows:</p><p>the root of the tree, B 0 , is such that atom(B 0 ) = α;</p><p>18:9 for each trigger (σ i , π i ), 0 &lt; i ≤ n, let B i be the bag such that atom(B i ) = π s i (head(σ i )). Let j be the smallest integer such that π i (fr(σ i )) ⊆ terms(B j ): then B i is added as a child to B j . By extension, we say that a derivation tree T is associated with α and Σ if there exists a semi-oblivious Σ-derivation S from α such that T is assigned to S.</p><p>Example 7 (continued). The derivation tree associated with S is represented in Figure <ref type="figure" target="#fig_2">1</ref>. Bags have the same sharing types in the chase tree and in the derivation tree. However, we can see here that they are not linked in the same way: B 3 was a child of B 2 in the chase tree, it becomes a child of B 1 in the derivation tree. Hence, the forbidden pattern cannot be found anymore in the tree.</p><p>Note that every non-root bag B shares at least one term with its parent (since the rule frontiers are not empty), furthermore this term is generated in its parent (otherwise B would have been added at a higher level in the tree).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Semi-Oblivious and Restricted Chase Termination</head><p>We now use derivation trees and sharing types to characterize the termination of the semioblivious chase. The fundamental property of derivation trees that we exploit is that, when two nodes have the same sharing type, the considered (semi-oblivious) derivation can always be extended so that these nodes have the same number of children, and in turn these children have the same sharing type. We first specify the notion of bag copy. Let T e be obtained from a derivation tree T by adding a copy of a bag: strictly speaking, T e may not be a derivation tree in the sense that there may be no derivation to which it can be assigned, as illustrated by Example 12. Intuitively, some rule applications that would allow to produce the copy may be missing. However, there is some derivation tree of which T e is a prefix (intuitively, one can add bags to T e to obtain a derivation tree). That is why the following proposition considers more generally prefixes of derivation trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 11 (Bag Copy). Let T and T be (possibly equal) trees of bags. Let B be a bag of T and B be a bag of T such that</head><formula xml:id="formula_2">B ≡ st B . Let B c be a child of B. A copy of B c under B is a bag B c such that atom(B c ) = ϕ s (atom(B c )),</formula><p>Example 12. Let Σ = {σ 1 , σ 2 , σ 3 } with: σ1 : r(x, y) → ∃z s(y, z) σ2 : s(x, y) → ∃z t(y, z) σ3 : t(x, y) → ∃z s(x, z) Figure <ref type="figure" target="#fig_0">2</ref> pictures the result of copying a bag in a derivation tree T associated with a Σ-derivation: T has bags B 0 , B 1 , B 2 and B 3 ; then the bag B 3 is copied under itself yielding B 3 (this copy is possible as B 1 and B 3 have the same sharing type and B 3 is a child of B 1 ). The obtained tree structure is not a derivation tree, as s(z 3 , z 4 ) cannot be generated by applying a rule on the instance associated with T , however it could be completed to yield a derivation tree.  The size of a derivation tree without UPW is bounded, since its arity is bounded and its depth is bounded by the number of sharing types. It remains to show that a derivation tree that contains a UPW can be extended to an arbitrarily large derivation tree. We recall that a similar property would not hold for the chase tree, as witnessed by Example 7.</p><formula xml:id="formula_3">B 0 s(b, z 1 ) B 1 t(z 1 , z 2 ) B 2 s(z 1 , z 3 ) B 3 s(z 3 , z 4 ) B 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 14.</head><p>There exists an arbitrary large derivation tree associated with α and Σ if and only if there exists a derivation tree associated with α and Σ that contains an unbounded-path witness.</p><p>The previous proposition yields a characterization of the existence of an infinite semioblivious derivation. At this point, one may notice that an infinite semi-oblivious derivation is not necessarily fair. However, from this infinite derivation one can always build a fair derivation by inserting missing triggers. Obviously, this operation has no effect on the termination of the semi-oblivious chase. More precaution will be required for the restricted chase.</p><p>One obtains an algorithm to decide termination of the semi-oblivious chase for a given set of rules: for each canonical instance, build a semi-oblivious derivation and the associated derivation tree by applying rules until a UPW is created (in which case the answer is no) or all possible rule applications have been performed; if no instance has returned a negative answer, the answer is yes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 15. The all-sequence termination problem for the semi-oblivious chase on linear rules is decidable.</head><p>This algorithm can be modified to run in polynomial space (which is optimal <ref type="bibr" target="#b3">[4]</ref>), by guessing a canonical instance and a UPW of its derivation tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 16. The all-sequence termination problem for the semi-oblivious chase on linear rules is in PSpace.</head><p>We now consider the restricted chase. To this aim, we call restricted derivation tree associated with α and Σ a derivation tree associated with a restricted Σ-derivation from α.</p><p>We first point out that Proposition 13 is not true anymore for a restricted derivation tree, as the order in which rules are applied matters. This is illustrated by the next example.</p><p>Example 17. Consider a restricted tree that contains bags B and B with the same sharing type, labeled by atoms q(t, u) and q(v, w) respectively, where the second term is generated. Consider the following rules (the same as in Example 2): σ 1 : q(x, y) → ∃z q(y, z) σ 2 : q(x, y) → q(y, y) Assume B has a child B c labeled by q(u, z 0 ) obtained by an application of σ 1 , and B has a child B 1 labeled by q(w, w) obtained by an application of σ 2 . It is not possible to extend this tree by copying B c under B . Indeed, the corresponding application of σ 1 does not comply with the restricted chase criterion: it would produce an atom of the form q(w, z 1 ) that folds onto q(w, w).</p><p>We thus prove a weaker proposition by considering that B is a leaf in the restricted derivation tree. The previous proposition allows us to obtain a variant of Proposition 14 adapted to the restricted chase:<ref type="foot" target="#foot_4">5</ref> Proposition 19. There exists an arbitrary large restricted derivation tree associated with α and Σ if and only if there exists a restricted derivation tree associated with α and Σ that contains an unbounded-path witness.</p><p>It is less obvious than in the case of the semi-oblivious chase that the existence of an infinite derivation entails the existence of an infinite fair derivation. However, this property still holds:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proposition 20. For linear rules, every (infinite) non-terminating restricted derivation is a subsequence of a fair restricted derivation (i.e., a restricted chase sequence).</head><p>We point out that the previous property is not true anymore if linear rules are extended to non-atomic heads, as illustrated by the next example (in which only binary atoms are used).</p><p>Example 21. Let Σ = {σ 1 : r(x, y) → r(x, x); σ 2 : r(x, y) → s(x, x); σ 3 : r(x, y) → ∃z r(x, z) ∧ s(z, x) ∧ s(y, z)}. Starting from the instance r(a, b), one builds an infinite restricted derivation that repeatedly applies σ 3 , ignoring the two other rules. In order to turn this derivation into a fair derivation, one should at some point perform the applications of σ 1 and σ 2 to the initial instance, which produce the atoms r(a, a) and s(a, a). However, as soon as these atoms are produced, all triggers involving σ 3 are deactivated. Actually, there is no infinite fair restricted Σ-derivation from r(a, b).</p><p>Similarly to Proposition 14 for the semi-oblivious chase, Proposition 19 provides an algorithm to decide termination of the restricted chase. The difference is that it is not sufficient to build a single derivation for a given canonical instance; instead, all possible restricted derivations from this instance have to be built (note that the associated restricted derivation trees are finite for the same reasons as before, and there is obviously a finite number of them). Hence, we obtain: Corollary 22. The all-sequence termination problem for the restricted chase on linear rules is decidable. A rough analysis of the proposed algorithm provides a co-N2ExpTime upper-bound for the complexity of the problem, by guessing a derivation that is of length at most double exponential, and checking whether there is a UPW in the corresponding derivation tree.</p><p>We now prove the decidability of the one-sequence termination problem. Note that a restricted derivation tree T that contains a UPW is a witness of the existence of an infinite restricted chase sequence, but does not prove that every restricted chase sequence that extends T is infinite. However, we prove that, if all restricted derivation trees contain a UPW, then there is no terminating restricted chase sequence. Proposition 23. There exists a finite fair restricted derivation (i.e., a terminating restricted chase sequence) associated with α and Σ if and only if there exists one whose associated derivation tree does not contain any UPW.</p><p>Proof sketch. We show that the derivation tree of the shortest finite fair restricted derivation cannot contain a UPW. This is done by contradiction: we assume there is a UPW in the associated derivation tree of the shortest finite fair restricted derivation, and we choose a UPW (B, B ), such that B is a deepest bag among all UPWs. We create a new derivation that is equal to the original one up to the creation of B, then (1) copy the subtree rooted in B under B and (2) perform "similarly" the missing rule applications so as to restore a fair restricted derivation. We show that during step (2) at least one trigger of the original derivation becomes inactive, which yields a strictly shorter fair restricted derivation.</p><p>An algorithm to decide the existence of a finite restricted chase sequence for any instance is as follows: for any canonical instance, build all restricted derivations until either (i) there is a UPW in their associated derivation tree or (ii) there is no active trigger. Output Yes if and only if for all instances, there is a least one restricted derivation that halts because of the second condition. Such a derivation is of size at most double exponential, and we obtain a N2ExpTime upper bound for the complexity of the one-sequence termination problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 24. The one-sequence termination problem for the restricted chase on linear rules is decidable.</head><p>Importantly, the previous algorithms are naturally able to consider solely some type of restricted derivations, i.e., build only derivation trees associated with such derivations, which is of theoretical but also of practical interest. Indeed, implementations of the restricted chase often proceed by building breadth-first derivations (which are intrinsically fair when they are infinite), or variants of these. As witnessed by the next example, the termination of all breadth-first fair derivations is a strictly weaker requirement than the termination of all fair sequences, in the sense that the restricted chase terminates on more sets of rules.</p><p>Example 25. Consider the following set of rules:</p><formula xml:id="formula_4">σ 1 = p(x, y) → q(y) σ 2 = p(x, y) → r(y, x) σ 3 = q(y) → ∃z r(y, z) σ 4 = r(x, y) → ∃z p(y, z)</formula><p>All breadth-first (fair) restricted derivations terminate, whatever the initial instance is. Remark that every application of σ 1 is followed by an application of σ 2 in the same breadth-first step, which prevents the application of σ 3 . However, there is a fair restricted derivation that does not terminate (and this is even true for any instance). Indeed, an application of σ 2 can always be delayed, so that it comes too late to prevent the application of σ 3 . See Figure <ref type="figure" target="#fig_7">3</ref>: on the left, a finite derivation tree associated with a breadth-first derivation from instance p(x, y); on the right, an infinite derivation tree associated with a (non-breadth-first) fair infinite derivation from the same instance. The numbers on edges give the order in which bags are created.</p><p>We conclude this section by noting that the previous Example 25 may give the (wrong) intuition that, given a set of rules, it is sufficient to consider breadth-first fair derivations to decide if there exists a terminating sequence. The following example shows that it is not the case: here, no breadth-first chase sequence is terminating, while there exists a terminating chase sequence for the given instance.</p><p>Example 26. Let Σ = {σ 1 , σ 2 , σ 3 } with σ 1 = p(x, y) → ∃z p(y, z), σ 2 = p(x, y) → h(y), and σ 3 = h(x) → p(x, x). In this case, for every instance, there is a terminating restricted chase sequence, where the application of σ 2 and σ 3 prevents the indefinite application of σ 1 . However, starting from I = {p(a, b)}, by applying rules in a breadth-first fashion one obtains a non-terminating restricted chase sequence, since σ 1 and σ 2 are always applied in parallel from the same atom, before applying σ 3 .</p><p>As for the all-sequence termination problem, the algorithm may restrict the derivations of interest to specific kinds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Core Chase Termination</head><p>We now consider the termination of the core chase on linear rules. Keeping the same approach, we prove that the finiteness of the core chase is equivalent to the existence of a finite tree of bags whose set of atoms is a minimal universal model. We call this a (finite) complete core.</p><p>To bound the size of a complete core, we show that it cannot contain an unbounded-path witness. However, we cannot rely on derivation trees: indeed, there are linear sets of rules for which no derivation tree forms a complete core, as shown in Example 27. We will thus introduce a more general tree structure, namely entailment trees.</p><p>Example 27. Let us consider the following rules:</p><p>s(x) → ∃y∃z p(y, z, x) p(y, z, x) → ∃v q(y, v, x) q(y, v, x) → p(y, v, x)</p><p>Let I = {s(a)}. The first rule applications yield a derivation tree T which is a path of bags B 0 , B 1 , B 2 , B 3 respectively labeled by the following atoms: s(a), p(y 0 , z 0 , a), q(y 0 , v 0 , a) and p(y 0 , v 0 , a) T is represented on the left of Figure <ref type="figure">4</ref>. Let A be this set of atoms. First, note that A is not a core: indeed it is equivalent to its strict subset A defined by {B 0 , B 2 , B 3 } with a homomorphism π that maps atom(B 1 ) to atom(B 3 ). Trivially, A is a core since it does not contain two atoms with the same predicate. Second, note that any further rule application on T is redundant, i.e., generates a set of atoms to A (and A ). Hence, A is a complete core. However, there is no derivation tree that corresponds to A . There is even no prefix of a derivation tree that corresponds to it (which ruins the alternative idea of building a prefix of a derivation tree that would be associated with a complete core). In particular, note that {B 0 , B 1 , B 2 } is indeed a core, but it is not complete.</p><formula xml:id="formula_5">I</formula><p>The following notion of twins will be used in the definition of entailment trees to ensure that they have a bounded arity. Definition 28. Two bags B and B of a tree of bags are twins if they have the same sharing type, the same parent B p and if the natural mapping ϕ atom(B)→atom(B ) is the identity on the terms of atom(B p ).</p><p>In the following definition of entailment tree, we use the notation α 1 → α 2 , where α i is an atom, to denote the rule ∀X(α 1 → ∃Y α 2 ) with X = vars(α 1 ) and Y = vars(α 2 ) \ X.</p><p>Definition 29 (Entailment Tree). An entailment tree associated with α and Σ is a tree of bags T such that: 1. B r , the root of T , is such that Σ |= α → atom(B r ) and Σ |= atom(B r ) → α; 2. For any bag B c child of a node B, the following holds:</p><formula xml:id="formula_6">(i) terms(B c ) ∩ generated(B) = ∅ (ii)</formula><p>The terms in generated(B c ) are variables that do not occur outside the subtree of T rooted in B c (iii) Σ |= atom(B) → atom(B c ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">There is no pair of twins.</head><p>If α is a ground atom, then B r is simply labeled by α. Otherwise, it may happen that α does not belong to the result of the core chase (e.g., α = p(x, y), with x and y variables, and Σ = {p(x, y) → p(x, x)}), hence Point 1.</p><p>First note that an entailment tree is independent from any derivation (in particular, fairness is not an issue). The main difference with a derivation tree is that it employs a more general parent-child relationship, that relies on entailment rather than on rule application, hence the name entailment tree. Intuitively, with respect to a derivation tree, one is allowed to move a bag B higher in the tree, provided that it contains at least one term generated in its new parent B p ; then, the terms of B that are not shared with B p are freshly renamed. Finally, since the problem of whether an atom is entailed by a linear existential rule knowledge base is decidable (precisely PSpace-complete <ref type="bibr" target="#b4">[5]</ref>, even in the case of atomic instances), one can actually generate all non-twin children of a bag. As a bag can only have a bounded number of non-twin children, we are guaranteed to keep a tree of bounded arity.</p><p>Derivation trees are entailment trees, but not necessarily conversely. A crucial distinction between these two structures is the following statement, which does not hold for derivation trees, as illustrated by Example 27.</p><p>Proposition 30. If the core chase associated with α and Σ is finite, then there exists an entailment tree T such that the set of atoms associated with T is a complete core.</p><p>Example 27 (continued). The tree defined by the path of bags B 0 , B 2 B 3 is an entailment tree, represented on the right of Figure <ref type="figure">4</ref>, which defines a complete core.</p><p>Differently from the semi-oblivious case, we cannot conclude that the chase does not terminate as soon as a UPW is built, because the associated atoms may later be mapped to other atoms, which would remove the UPW. Instead, starting from the initial bag, we recursively add bags that do not generate a UPW (for instance, we can recursively add all such non-twin children to a leaf). Once the process terminates (the non-twin condition and the absence of UPW ensure that it does), we check that the obtained set of atoms C is complete (i.e., is a model of the KB): for that, it suffices to perform each possible rule application on C and check if the resulting set of atoms is equivalent to C (i.e., maps by homomorphism to C). See Algorithm 1. The set C may not be a core, but it is complete iff it contains a complete core.</p><p>We now focus on the key properties of entailment trees associated with complete cores. We first introduce the notion of redundant bags, which captures some cases of bags that cannot appear in a finite core. As witnessed by Example 27, this is not a characterization: B 1 is not redundant (according to Definition 31 below), but cannot belong to a complete core.</p><p>Definition 31 (Redundancy). Given an entailment tree, a bag B c child of B is redundant if there exists an atom β (that may not belong to the tree) with (i) Σ |= atom(B) → β; (ii) there is a homomorphism from atom(B c ) to β that is the identity on shared(B c );</p><formula xml:id="formula_7">(iii) |terms(β) \ terms(B)| &lt; |terms(B c ) \ terms(B)|.</formula><p>Note that B c may be redundant even if the "cause" for redundancy, i.e., β, is not in the tree yet. The role of this notion in the proofs is as follows: we show that if a complete entailment tree contains a UPW then it contains a redundant bag, and that a complete core cannot contain a redundant bag, hence a UPW. To prove this, we rely on Proposition 32 below, which is the counterpart for entailment trees of Proposition 13: performing a bag copy from an entailment tree results in an entailment tree (the notion of prefix is not needed, since a prefix of an entailment tree is an entailment tree) and keeps the properties of the copied bag. In light of this, the copy of a bag can be naturally extended to the copy of the whole subtree rooted in a bag, which is a crucial element in the proof of Proposition 33 below. From Propositions 30 and 33, we conclude that Algorithm 1 decides the all-sequence termination problem for the core chase.</p><p>Corollary 34. The all-sequence termination problem for the core chase on linear rules is decidable. A rough complexity analysis of this algorithm yields a 2ExpTime upper bound for the termination problem. Indeed, the exponential number of (sharing) types yields a bound on the number of canonical instances to be checked, the arity of the tree, as well as the length of a path without UPW in the tree, and each edge can be generated with a call to a PSpace oracle.</p><p>Finally, note that for predicates of arity at most two, it would still be possible to rely on derivation trees (instead of entailment trees), provided that the initial instance is ground. Indeed, in this specific case, the core of a (finite) derivation tree is a prefix of this tree (note that Example 27 uses predicates of arity three). Then, we can incrementally build a prefix of derivation tree until no bag can be added without creating a UPW, and, as in the higher arity case, check if the built tree is complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Concluding Remarks</head><p>We have shown the decidability of all-instance chase termination over atomic-head linear rules for three main chase variants (semi-oblivious, restricted, core) following a novel approach based on derivation trees, and their generalization to entailment trees, and a single notion of forbidden pattern. As far as we know, these are the first decidability results for the restricted chase, on both versions of the termination problem (i.e., all-sequence and one-sequence termination). The simplicity of the structures and algorithms makes it realistic to implement them.</p><p>We leave for future work the study of the precise complexity of the termination problems. A straightforward analysis of the complexity of the algorithms that decide the termination of the restricted and core chases yields upper bounds, however we believe that a finer analysis of the properties of sharing types would provide tighter upper bounds. It is an open question whether our results can be extended to more complex classes of existential rules, i.e., linear rules with a complex head, which is relevant for the termination of the restricted and core chases, and more expressive classes from the guarded family. Concerning the extension to complex-head rules, the difficulty is that an infinite restricted derivation may not be transformable into a fair restricted derivation. Concerning the extension to more expressive classes, derivation trees were precisely defined to represent derivations with guarded rules and their extensions (i.e., greedy bounded treewidth sets), hence they seem to be a promising tool to study chase termination on that family, at least for the one-instance version of the problem, i.e., given a knowledge base. To consider the all-instance termination problem, a preliminary issue would be whether a finite set of canonical instances can be defined.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 2 .</head><label>2</label><figDesc>Let Σ = {σ 1 , σ 2 }, with σ 1 = p(x, y) → ∃z p(y, z) and σ 2 = p(x, y) → p(y, y). Let I = p(a, b). The KB (I, Σ) has a finite universal model, for example, I * = {p(a, b), p(b, b)}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>are labeled by an atom. For any bag B, we define the following notations: atom(B) is the label of B; terms(B) = terms(atom(B)) is the set of terms of B; terms(B) is divided into two sets of terms, those generated in B, denoted by generated(B), and those shared with its parent, denoted by shared(B); precisely, terms(B) = shared(B)∪ generated(B), shared(B) ∩ generated(B) = ∅, and if B is the root of T , then generated(B) = terms(B) (hence shared(B) = ∅), otherwise B has a parent B p and generated(B) = terms(B) \ terms(B p ) (hence, shared(B) = terms(B p ) ∩ terms(B)). Last, we denote by atoms(T ) the set of atoms that label the bags in T .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1</head><label>1</label><figDesc>Figure 1 Chase Graph and Derivation Tree of Example 7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 9 (</head><label>9</label><figDesc>Unbounded-Path Witness). An unbounded-path witness (UPW) in a derivation tree is a pair of distinct bags (B, B ) such that B and B have the same sharing type and B is an ancestor of B .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Proposition 13 . 9 18: 10 A</head><label>13910</label><figDesc>Let T be a prefix of a derivation tree, B and B be two bags of T such that B ≡ st B , and B c be a child of B. Let B c be a copy of B c under B . Then: (a) it holds that B c ≡ st B c , and (b) the tree obtained from T by adding B c under B , if no copy of B c already exists under B , is a prefix of a derivation tree. I C D T 2 0 1 Single Approach to Decide Chase Termination on Linear Existential Rules r(a, b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2</head><label>2</label><figDesc>Figure 2 Copy Operation and Derivation Trees.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Proposition 18 .</head><label>18</label><figDesc>Let T be a prefix of a restricted derivation tree, B and B be two bags of T such that B ≡ st B and B is a leaf. Let B c be a child of B and B c be a copy of B c under B . Then: (a) B c ≡ st B c and (b) the tree obtained from T by adding the copy B c of B c under B is a prefix of a restricted derivation tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 3</head><label>3</label><figDesc>Figure 3 Finite versus Infinite Derivation Tree for Example 25.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>C D T 2 0 1 9 18: 14 A 2 B 3 Figure 4</head><label>914234</label><figDesc>Figure 4 Derivation tree and entailment tree for Example 27.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Proposition 32 .</head><label>32</label><figDesc>Let B be a bag of an entailment tree T and B be a bag of an entailment tree T such that B ≡ st B . Let B c be a child of B. Let B c be a copy of B c under B . Then: (a) it holds that B c ≡ st B c , (b) the tree obtained from T by adding B c under B , if no copy of B c already exists under B , is an entailment tree, and (c) B c is redundant if and only if B c is redundant.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>I C D T 2 0 1 9 18: 16 A</head><label>916</label><figDesc>Single Approach to Decide Chase Termination on Linear Existential Rules Proposition 33. A complete core contains neither (i) a redundant bag, nor (ii) an unbounded-path witness.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Algorithm 1 :for each canonical atom α do 2 Let 3 while 4 add B to T 5 for</head><label>12345</label><figDesc>Deciding core chase termination. Input : A set of linear rules Output : true if and only if the core chase terminates on all instances 1 T be the entailment tree restricted to a single root bag labeled by α; a bag B can be added to T without creating twins nor a UPW do (σ, π) such that σ is applicable to atoms(T ) by π do 6 if atoms(T ) |= atoms(T ) ∪ π s (head(σ));</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The "s" superscript stands for safe, as newly introduced variables are fresh, hence cannot be confused with already existing variables.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For instance, it can always be ensured by adding a position to all predicates, which is filled by the same fresh constant in the initial instance and by a new frontier variable in each rule. E.g. let c0 be the new constant, then an instance atom of the form p(a, b) would become p(c0, a, b) and a rule of the form p(x, y) → ∃z1∃z2 q(z1, z2) would become p(u, x, y) → ∃z1∃z2 q(u, z1, z2), where u is a variable. This translation does not change the behavior of any chase variant.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>The trees of bags that we consider are tree decompositions<ref type="bibr" target="#b25">[26]</ref>, hence the term "bag", which is classical in this setting.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Note that the chase graph in<ref type="bibr" target="#b8">[9]</ref> is a different notion.I C D T 2 0 1 9</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Actually, a weak version of Proposition 13 where B is a leaf would be sufficient to prove Proposition 14. However, the interest of Proposition 13 is to pinpoint an important difference between the semi-oblivious and restricted chase behaviors.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>We thank the reviewers for their insightful comments, as well as <rs type="person">Antoine Amarilli</rs> for Example 21, which is simpler than a previous example and shows that the fairness issue already occurs with binary predicates.</p></div>
			</div>			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">Jean-François</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Salvat</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2011.03.002</idno>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Walking the Complexity Lines for Generalized Guarded Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-François</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-126</idno>
	</analytic>
	<monogr>
		<title level="m">IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting><address><addrLine>Barcelona, Catalonia, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>IJCAI/AAAI</publisher>
			<date type="published" when="2011">July 16-22, 2011. 2011</date>
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Implication Problem for Data Dependencies</title>
		<author>
			<persName><forename type="first">Catriel</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-10843-2_7</idno>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming, 8th Colloquium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Shimon</forename><surname>Even</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Oded</forename><surname>Kariv</surname></persName>
		</editor>
		<meeting><address><addrLine>Acre (Akko), Israel</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1981">July 13-17, 1981. 1981</date>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="73" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Chase Termination for Guarded Existential Rules</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Calautti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<idno type="DOI">10.1145/2745754.2745773</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th ACM Symposium on Principles of Database Systems, PODS 2015</title>
		<editor>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</editor>
		<meeting>the 34th ACM Symposium on Principles of Database Systems, PODS 2015<address><addrLine>Melbourne, Victoria, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015-06-04">May 31 -June 4, 2015. 2015</date>
			<biblScope unit="page" from="91" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Datalog Extensions for Tractable Query Answering over Ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-04329-1_12</idno>
	</analytic>
	<monogr>
		<title level="m">Semantic Web Information Management -A Model-Based Perspective</title>
		<editor>
			<persName><forename type="first">Roberto</forename><surname>De</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Virgilio</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fausto</forename><surname>Giunchiglia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Letizia</forename><surname>Tanca</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="249" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A general Datalog-based framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.websem.2012.03.001</idno>
	</analytic>
	<monogr>
		<title level="j">J. Web Sem</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="57" to="83" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10817-007-9078-x</idno>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reasoning</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Detecting Chase (Non)Termination for Existential Rules with Disjunctions</title>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irina</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
		</author>
		<idno type="DOI">10.24963/ijcai.2017/128</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017</title>
		<editor>
			<persName><forename type="first">Carles</forename><surname>Sierra</surname></persName>
		</editor>
		<meeting>the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">August 19-25, 2017. 2017</date>
			<biblScope unit="page" from="922" to="928" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The chase revisited</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
		<idno type="DOI">10.1145/1376916.1376938</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Seventh ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS 2008</title>
		<editor>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</editor>
		<meeting>the Twenty-Seventh ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS 2008<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">June 9-11, 2008. 2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Normal Form for Relational Databases That Is Based on Domians and Keys</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<idno type="DOI">10.1145/319587.319592</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="387" to="415" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Renée</forename><forename type="middle">J</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucian</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><surname>Popa</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2004.10.033</idno>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Single Approach to Decide Chase Termination on Linear Existential Rules 12 Tomasz Gogacz and Jerzy Marcinkowski. All-Instances Termination of Chase is Undecidable</title>
		<idno type="DOI">10.1007/978-3-662-43951-7_25</idno>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages, and Programming -41st International Colloquium, ICALP 2014</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Pierre</forename><surname>Fraigniaud</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thore</forename><surname>Husfeldt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Elias</forename><surname>Koutsoupias</surname></persName>
		</editor>
		<meeting><address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">July 8-11, 2014. 2014</date>
			<biblScope unit="volume">8573</biblScope>
			<biblScope unit="page" from="293" to="304" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Query Rewriting and Optimization for Ontological Databases</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giorgio</forename><surname>Orsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<idno type="DOI">10.1145/2638546</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="25" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Anatomy of the Chase</title>
		<author>
			<persName><forename type="first">Gösta</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Onet</surname></persName>
		</author>
		<idno type="DOI">10.3233/FI-2018-1627</idno>
	</analytic>
	<monogr>
		<title level="j">Fundam. Inform</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Acyclicity Notions for Existential Rules and Their Application to Query Answering in Ontologies</title>
		<author>
			<persName><forename type="first">Cuenca</forename><surname>Bernardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clemens</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Despoina</forename><surname>Kupke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Magka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhe</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1613/jair.3949</idno>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="741" to="808" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Answering queries using views: A survey</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><surname>Halevy</surname></persName>
		</author>
		<idno type="DOI">10.1007/s007780100054</idno>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="270" to="294" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Computing universal models under guarded TGDs</title>
		<author>
			<persName><forename type="first">André</forename><surname>Hernich</surname></persName>
		</author>
		<idno type="DOI">10.1145/2274576.2274600</idno>
	</analytic>
	<monogr>
		<title level="m">15th International Conference on Database Theory, ICDT &apos;12</title>
		<editor>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">March 26-29, 2012. 2012</date>
			<biblScope unit="page" from="222" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Sound, complete and minimal UCQ-rewriting for existential rules</title>
		<author>
			<persName><forename type="first">Mélanie</forename><surname>König</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-140153</idno>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="451" to="475" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A Single Approach to Decide Chase Termination on Linear Existential Rules</title>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1810.02132</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A Single Approach to Decide Chase Termination on Linear Existential Rules</title>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-2211/paper-45.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Workshop on Description Logics co-located with 16th International Conference on Principles of Knowledge Representation and Reasoning (KR 2018)</title>
		<title level="s">CEUR Workshop Proceedings. CEUR</title>
		<editor>
			<persName><forename type="first">Magdalena</forename><surname>Ortiz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Schneider</surname></persName>
		</editor>
		<meeting>the 31st International Workshop on Description Logics co-located with 16th International Conference on Principles of Knowledge Representation and Reasoning (KR 2018)<address><addrLine>Tempe, Arizona, US</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">October 27th -to -29th, 2018. 2211. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Data Integration: A Theoretical Perspective</title>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<idno type="DOI">10.1145/543613.543644</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-first ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">Lucian</forename><surname>Popa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Phokion</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</editor>
		<meeting>the Twenty-first ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems<address><addrLine>Madison, Wisconsin, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002-05">June 3-5. 2002</date>
			<biblScope unit="page" from="233" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Generalized schema-mappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Marnette</surname></persName>
		</author>
		<idno type="DOI">10.1145/1559795.1559799</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jianwen</forename><surname>Su</surname></persName>
		</editor>
		<meeting>the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems<address><addrLine>PODS; Providence, Rhode Island, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009-06-19">2009. June 19 -July 1, 2009. 2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An Introduction to Ontology-Based Query Answering with Existential Rules</title>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-10587-1_6</idno>
	</analytic>
	<monogr>
		<title level="m">Reasoning Web. Reasoning on the Web in the Big Data Era -10th International Summer School 2014</title>
		<meeting><address><addrLine>Athens, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">September 8-13, 2014. 2014</date>
			<biblScope unit="page" from="245" to="278" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">SPROUT: lazy vs. eager query plans for tuple-independent probabilistic databases</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiewen</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2009.123</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Data Engineering, ICDE 2009</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Yannis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dik</forename><surname>Ioannidis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Raymond</forename><forename type="middle">T</forename><surname>Lun Lee</surname></persName>
		</editor>
		<editor>
			<persName><surname>Ng</surname></persName>
		</editor>
		<meeting>the 25th International Conference on Data Engineering, ICDE 2009<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009-03-29">March 29 2009 -April 2 2009. 2009</date>
			<biblScope unit="page" from="640" to="651" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The chase procedure and its applications</title>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Onet</surname></persName>
		</author>
		<idno>18:19</idno>
		<ptr target="https://pdfs.semanticscholar.org/6b1b/327a989d3d8e2488f645488063f391391b89.pdf" />
		<imprint>
			<date type="published" when="2012">2012</date>
			<pubPlace>Canada</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Concordia University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Graph Minors. II. Algorithmic Aspects of Tree-Width</title>
		<author>
			<persName><forename type="first">Neil</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">D</forename><surname>Seymour</surname></persName>
		</author>
		<idno type="DOI">10.1016/0196-6774(86)90023-4</idno>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="309" to="322" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Querying Existential Rule Knowledge Bases: Decidability and Complexity</title>
		<author>
			<persName><forename type="first">Swan</forename><surname>Rocher</surname></persName>
		</author>
		<ptr target="https://tel.archives-ouvertes.fr/tel-01483770" />
	</analytic>
	<monogr>
		<title level="m">terrogation de Bases de Connaissances avec Règles Existentielles : Décidabilité et Complexité)</title>
		<meeting><address><addrLine>France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
		<respStmt>
			<orgName>University of Montpellier</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Conjunctive Query Answering Under Existential Rules -Decidability, Complexity, and Algorithms</title>
		<author>
			<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
		</author>
		<ptr target="https://tel.archives-ouvertes.fr/tel-00925722" />
		<imprint>
			<date type="published" when="2013">2013</date>
			<pubPlace>France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Montpellier 2 University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
