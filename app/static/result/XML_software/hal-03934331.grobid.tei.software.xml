<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Propositional and predicate logics of incomplete information</title>
				<funder ref="#_Rp3Ktwh #_y9vFwdW">
					<orgName type="full">EPSRC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marco</forename><surname>Console</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">School of Informatics</orgName>
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Propositional and predicate logics of incomplete information</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">76385D0A6B750A97F2402D4DCA611615</idno>
					<idno type="DOI">10.1016/j.artint.2021.103603</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>One of the most common scenarios of handling incomplete information occurs in relational databases. They describe incomplete knowledge with three truth values, using Kleene's logic for propositional formulae and a rather peculiar extension to predicate calculus. This design by a committee from several decades ago is now part of the standard adopted by vendors of database management systems. But is it really the right way to handle incompleteness in propositional and predicate logics? Our goal is to answer this question. Using an epistemic approach, we first characterize possible levels of partial knowledge about propositions, which leads to six truth values. We impose rationality conditions on the semantics of the connectives of the propositional logic, and prove that Kleene's logic is the maximal sublogic to which the standard optimization rules apply, thereby justifying this design choice. For extensions to predicate logic, however, we show that the additional truth values are not necessary: every many-valued extension of first-order logic over databases with incomplete information represented by null values is no more powerful than the usual two-valued logic with the standard Boolean interpretation of the connectives. We use this observation to analyze the logic underlying <software>SQL</software> query evaluation, and conclude that the many-valued extension for handling incompleteness does not add any expressiveness to it.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head>Introduction</head><p>Incomplete information is ubiquitous in applications that involve querying and reasoning about data. It is one of the oldest topics in database research <ref type="bibr" target="#b13">(Codd 1975)</ref>, and is essential in many applications such as data integration <ref type="bibr" target="#b27">(Lenzerini 2002)</ref>, data exchange <ref type="bibr" target="#b1">(Arenas et al. 2014)</ref>, inconsistent databases <ref type="bibr" target="#b7">(Bertossi 2011)</ref>, and ontology-based data access <ref type="bibr" target="#b8">(Bienvenu and Ortiz 2015)</ref>.</p><p>When it comes to querying incomplete data, practical solutions, such as relational databases, rely on many-valued logics to properly account for the lack of certainty. In fact, every database management system (DBMS) uses a threevalued logic for handling incomplete information, namely Kleene's logic <ref type="bibr" target="#b10">(Bolc and Borowik 1992)</ref>. This was the design choice of <software ContextAttributes="used">SQL</software>, the language of relational DBMSs, Copyright c 2018, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.</p><p>which is now written into the <software ContextAttributes="used">SQL</software> Standard (ISO/IEC 2016), presented in all database textbooks, and implemented in all database products. However, this is far from the only logic to have been considered for representing incomplete information. The use of Kleene's logic was first proposed by <ref type="bibr" target="#b13">Codd (1975)</ref>, but many other variants appeared afterward. <ref type="bibr" target="#b14">Codd (1987)</ref> looked at a four-valued logic, but in the end argued against it due to the additional complexity. Nonetheless, well-documented problems with incomplete information <ref type="bibr" target="#b17">(Date and Darwen 1996;</ref><ref type="bibr" target="#b18">Date 2005</ref>) led to the search of more appropriate logics for handling incompleteness. For example, <ref type="bibr" target="#b19">Gessert (1990)</ref> revisited four-valued logics, while <ref type="bibr" target="#b32">Yue (1991)</ref> considered logics with four, five, and seven values, and showed how to encode them with three. A different kind of four-valued logics for missing data was studied by <ref type="bibr" target="#b15">Console, Guagliardo, and Libkin (2016)</ref>, while <ref type="bibr" target="#b16">Darwen and Date (1995)</ref> suggested dropping nulls altogether and go back to the usual Boolean two-valued logic.</p><p>There is also no shortage of many-valued logics that have been proposed in closely related contexts. For example, a variety of many-valued logics were used in the study of default reasoning <ref type="bibr" target="#b30">(Reiter 1980)</ref> or in reasoning about inconsistency <ref type="bibr" target="#b33">(Zamansky and Avron 2006)</ref>. Those are typically based on the notion of bilattices, providing truth and knowledge orderings on the truth values <ref type="bibr" target="#b2">(Arieli and Avron 1996;</ref><ref type="bibr" target="#b20">Ginsberg 1988)</ref>. A common one is Belnap's bilattice with four truth values <ref type="bibr" target="#b6">(Belnap 1977;</ref><ref type="bibr" target="#b3">Arieli and Avron 1998)</ref>, which also found database applications <ref type="bibr" target="#b22">(Grahne, Moallemi, and Onet 2015)</ref>; but others exist as well, e.g., many generalizations of Kleene's logic based on numerical intervals describing the degree of being true <ref type="bibr">(Fitting 1991)</ref>. A manyvalued propositional logic must also provide an interpretation of propositional connectives. To make the general picture even muddier, for different sets of truth values, different semantics of propositional connectives exist, sometimes even non-deterministic ones <ref type="bibr" target="#b4">(Arieli, Avron, and Zamansky 2010)</ref>.</p><p>Thus, we are far from having a clear picture of what to use as a logic of incomplete information in data management applications. Choices are numerous, and there is no final argument as to why the approach of DBMSs that use Kleene's logic is the right one. Hence, the first question we address is:</p><p>1) What is the right many-valued propositional logic for handling incomplete information?</p><p>Now suppose we have a propositional logic that correctly accounts for truth values of statements about incomplete information, and for operations on them. In querying data, however, we use predicate logics. Indeed, the core of <software>SQL</software> is essentially a programming syntax for relational calculus, which is another name for first-order (FO) predicate logic.</p><p>Of course we know how to lift the semantics of propositional logic to the full predicate calculus by treating existential and universal quantifiers as disjunctions and conjunctions over all elements of the universe. What we do not know is how different choices of propositional logic for incomplete information affect the power of predicate calculus. As one example, consider the version of FO that underlies <software ContextAttributes="used">SQL</software> and is based on Kleene's logic. What extra power does it possess over FO under the usual two-valued Boolean interpretation of the connectives? It was recently argued, by means of rewriting <software ContextAttributes="used">SQL</software> queries, that FO based on Kleene's logic can be encoded in the usual Boolean FO <ref type="bibr" target="#b23">(Guagliardo and Libkin 2017)</ref>. But is there a general result in logic that underlies such a translation, and what is so special about Kleene's logic that makes it work?</p><p>Even more generally, the second question we would like to address is:</p><p>2) How does the choice of a propositional logic for incomplete information affect predicate logic?</p><p>Finally, we would like to understand how these theoretical considerations relate to the practice of incomplete data in relational databases. A rough approximation of the core of <software>SQL</software> -the way it is presented in many database textbooks -is first-order logic. But as soon as incomplete information enters the picture, this becomes a many-valued FO. And yet there is even more to it: in <software ContextAttributes="used">SQL</software> queries, answer tuples are split into true ones that need to be returned, and others that are not returned, thus collapsing a three-valued logic to twovalued. This leads to our last question:</p><p>3) What is the logic that underlies real-life handling of incomplete information in relational databases (i.e., <software>SQL</software>'s logic), and how much more power than the usual twovalued FO does it possess?</p><p>The goal of this paper is to address these three questions. Below we outline our main contributions.</p></div>
<div><head>Propositional logic</head><p>To understand what a proper propositional logic for reasoning about incomplete information is, we need to define its truth values, and truth tables for its connectives (we shall concentrate on the standard ones, i.e., ∧, ∨, and ¬, although we shall see others as well). We follow the approach of <ref type="bibr" target="#b20">Ginsberg (1988)</ref> to turn partial knowledge about the truth of a proposition into truth values. If we have a set W of worlds, and two of its subsets T and F in which a proposition is true and false, respectively, this produces a description (T, F, W ). It is possible that T ∪ F = W , i.e., we may have partial knowledge about the truth or falsity of a proposition. We require however that T ∩ F = ∅, as here we do not consider inconsistent descriptions.</p><p>Taking those descriptions (T, F, W ) directly as truth values, however, is not satisfactory: we shall have too many of them. Instead, we want to take as truth values what we know about such descriptions.</p><p>We abstract this knowledge as epistemic theories of such descriptions: they say what is known about a proposition being possibly or certainly true or false. Then, as truth values we take maximally consistent epistemic theories. We show that there are only six such theories, resulting in a six-valued logic L 6v . Its truth tables are again very naturally derived from epistemic theories of partial knowledge about truth of propositions.</p><p>As a final step, we then look at what makes a many-valued logic database friendly. It needs to be a sublogic of L 6v and yet satisfy some basic equivalences we expect to hold to be able to perform query evaluation and optimization. We then show that the maximal sublogic of L 6v that satisfies those equivalences is L 3v , the three-valued logic of Kleene used in all commercial DBMSs. Thus, we justify the choice that was made by <software>SQL</software> designers and standards committees in choosing L 3v as the logic to be implemented in all database products.</p></div>
<div><head>Predicate logic</head><p>We have justified Kleene's logic L 3v as the right choice for handling incompleteness in database contexts. But database languages are not propositional: they are based on FO instead. Thus, we next look at variants of FO based on propositional many-valued logics such as L 3v and L 6v , and compare their power with that of the usual Boolean FO (denoted by BFO from now on), based on just two values t and f. Our main result is that when added to FO, these many-valued propositional logics add no power: FO based on L 3v , or on L 6v , or on any other many-valued logic (under some mild restrictions on the connectives) has no more power than BFO.</p><p>The logic of <software>SQL</software> We finally apply the above observation to <software ContextAttributes="used">SQL</software>'s logic. We explain that it corresponds to a L 3v -based FO with an extra connectives that allows one to collapse truth values f and u into one, but it still has no more power than BFO. Thus, even though <software ContextAttributes="used">SQL</software> designers were justified in choosing Kleene's logic as the propositional logic for reasoning about incomplete information, they overlooked the fact that, when considered within FO, such a logic does not add any expressive power.</p><p>To sum up, our investigation validates the choice of Kleene's logic by the designers of <software>SQL</software>, but at the same time asks whether it was really necessary and opens up a possibility for future languages that handle incomplete information to avoid the recourse to many-valued logics. Notice that much of the criticism of <software ContextAttributes="used">SQL</software> concentrated on its propositional logic. However we showed that it was very reasonable: a sixvalued logic would have been better justified but the threevalued logic is better at handling computational aspects. For predicate logics, our results say that these many-valued logics could have been avoided altogether. However, the price for this is a different way of expressing logical queries, and thus this result is of more interest for future language design rather than changing the current choices.</p><p>Organization The paper is structured around three main themes: propositional logics, predicate logics, and the logic of <software>SQL</software>, followed by conclusions and future work.</p></div>
<div><head>Propositional Logics</head><p>Our study of logics for incomplete information starts at the propositional level. The goal of this section is to define a propositional logic for handling incompleteness, with a special regard to applications that deal with incomplete data, including relational databases query languages.</p><p>To this end, we first need to formally define propositional formulae. We assume a countably infinite set of symbols, referred to as propositional atoms. For a set Ω of connectives with associated (positive) arities, the propositional language L over Ω is defined inductively as follows: every propositional atom is a formula of L; if ω is an n-ary connective in Ω and α 1 , . . . , α n are formulae of L, then so is ω(α 1 , . . . , α n ); nothing else is in L. We assume that the binary connectives ∧ and ∨, for which we use the infix notation, and the unary connective ¬ are always present. As will be relevant in the next section, this general definition allows for the inclusion of additional connectives in the language.</p><p>The standard way of evaluating propositional formulae is to associate atoms with truth values, which are then propagated through the connectives by means of truth tables. We define a (propositional) logic L as a pair (T, Ω), where T is the set of truth values and Ω is the set of truth tables, which are functions ω : T n → T, of appropriate arities, associated with the connectives. We say that L is a logic for a language L if L defines truth tables for every connective of L. With a deliberate abuse of notation, we denoted by Ω both the connectives of L and the truth tables associated with them in L. When it is not clear from the context, we use ω L to explicitly denote the truth table of L for the connective ω.</p><p>Given a logic L = (T, Ω) for a language L, and a mapping µ from propositional atoms to the truth values in T, the evaluation of a formula α ∈ L under µ in L is the truth value tv L (α, µ) in T defined inductively as follows:</p><formula xml:id="formula_0">tv L (α, µ) = µ(α) if α is a propositional atom, tv L ω(α 1 , . . . , α n ), µ = ω L tv L (α 1 , µ), . . . , tv L (α n , µ) ,</formula><p>for every α, α 1 , . . . , α n ∈ L and every n-ary connective ω.</p><p>For Ω = {∧, ∨, ¬}, the standard Boolean logic L Bool has truth values {t, f} and truth tables as in Figure <ref type="figure">1</ref>, while <software ContextAttributes="used">SQL</software> uses Kleene's three-valued logic, denoted by L 3v , with truth values {t, f, u} and truth tables as in Figure <ref type="figure">2</ref>. But is L 3v the right propositional logic to deal with incomplete information in relational databases? To answer this question, we first need an appropriate model of incompleteness; then, we must define what kind of information truth values represent in this model, and how many of them are needed; finally, we need to define truth tables for ∧, ∨ and ¬ that propagate information in a consistent way.</p></div>
<div><head>Model of Incompleteness</head><p>In many data management applications, especially those involving knowledge representation and reasoning, the veracity of data is a common problem. This results in dealing with</p><formula xml:id="formula_1">∧ t f t t f f f f ∨ t f t t t f t f ¬ t f f t Figure 1: The truth tables of L Bool . ∧ t f u t t f u f f f f u u f u ∨ t f u t t t t f t f u u t u u ¬ t f f t u u Figure 2: The truth tables of L 3v .</formula><p>two main sources of incomplete information: first, queries must be answered over sets of possible worlds and, second, the answer to a query may not be well defined, or known, in some of them. In the literature on many-valued logics, the approach of <ref type="bibr" target="#b20">(Ginsberg 1988</ref>) accounts for both these sources of incomplete information, and we follow it here as a basis for our model. However, as we shall discuss later on in this section, we deviate from Ginsberg's approach with respect to what truth values are and represent.</p><p>A propositional interpretation I is a triple (t, f, W ), where W is a non-empty set of worlds, and t and f are functions from L to the powerset of W such that, for every α, β ∈ L, all of the following hold:</p><formula xml:id="formula_2">t(α) ∩ f (α) = ∅ ; f (¬α) = t(α) ; t(¬α) = f (α) ; t(α ∧ β) = t(α) ∩ t(β) ; t(α ∨ β) = t(α) ∪ t(β) ; f (α ∧ β) = f (α) ∪ f (β) ; f (α ∨ β) = f (α) ∩ f (β) .</formula><p>Intuitively, t tells us on which worlds a given formula is true, while f indicates where it is false. When a world w is neither in f (α) nor in t(α), the formula α is said to be undefined in w.</p><p>In <ref type="bibr" target="#b20">(Ginsberg 1988)</ref>, objects similar to propositional interpretations defined above are used as truth values for formulae. This is incompatible with the standard evaluation of formulae we defined earlier. Instead, we want to collate the information provided by propositional interpretations and abstract it as truth values. In a sense, a truth value should represent what we know about formulae with respect to interpretations. To formalize this intuition, it is natural to make use of some form of epistemic logic.</p><p>Given a propositional language L, the language L KP of epistemic formulae is defined inductively as follows:</p><p>• every propositional formula in L is in L KP ; • if ϕ and ψ are in L KP , then so are ϕ ∧ ψ, ϕ ∨ ψ, and ¬ϕ; • if ϕ is in L KP , then so are Kϕ and Pϕ; • nothing else is in L KP . An epistemic formula is said to be subjective if every propositional atom appears in the scope of K or P.</p><p>The semantics of epistemic formulae is given with respect to a propositional interpretation I = (t, f, W ) and an appointed world w ∈ W . Whether I and w satisfy ϕ ∈ L KP , written I, w |= ϕ, is inductively defined as follows:</p><formula xml:id="formula_3">• I, w |= α if w ∈ t(α), for α ∈ L ; • I, w |= Kϕ if I, w |= ϕ for every w ∈ W ; • I, w |= Pϕ if I, w |= ϕ for some w ∈ W ; • I, w |= ¬ϕ if I, w |= ϕ ; • I, w |= ϕ ∧ ψ if I, w |= ϕ and I, w |= ψ ; • I, w |= ϕ ∨ ψ if I, w |= ϕ or I, w |= ψ.</formula><p>Observe that whether a subjective formula ϕ is satisfied in a propositional interpretation I does not depend on the choice of the appointed world, hence we simply say that I satisfies ϕ, and write I |= ϕ. Moreover, we denote by Mod(ϕ) the set of all models of ϕ, i.e., propositional interpretations that satisfy ϕ. We say that ϕ is satisfiable whenever Mod(ϕ) is non-empty.</p><p>We also remark that, unlike the standard operators and ♦ in classical modal logic, K and P here are not dual: while Kϕ implies ¬P¬ϕ, the converse is not necessarily true. To see this, consider a propositional formula α and the interpretation I = (t, f, {w 1 , w 2 }) such that t(α) = {w 1 } and f (α) = ∅; then, it is easy to verify that I satisfies ¬P¬α but not Kα, because w 2 ∈ t(α).</p></div>
<div><head>Truth Values</head><p>We need to understand what it means for a propositional formula to be true or false in a propositional interpretation. To do that, we resort to the notion of modalities.</p><p>Given a propositional formula α, the modalities of α are the modal formulae Kα, Pα, and their negation. Intuitively, the modalities of α describe the way α is true on a given propositional interpretation. To define truth values, then, we will look at the modalities of propositional formulae and their negations.</p><p>More formally, for a propositional formula α, we denote by M(α) the set consisting of all modalities of α and ¬α. A subset M of M(α) is called consistent if there exists at least one propositional interpretation I for which every formula in M is satisfied. A subset of M(α) is maximally consistent if, in addition, none of its proper supersets is a consistent subset of M(α).</p><p>Intuitively, every maximally consistent subset of M(α) defines a possible way in which a propositional formula can be evaluated on a propositional interpretation. Thus, to capture all possibilities, we need as many truth values as there are maximally consistent subsets of M(α). The following shows that our propositional logic must be six-valued.</p><p>Theorem 1. For every propositional formula α, there are at most 6 maximally consistent subsets of M(α). These are: </p><formula xml:id="formula_4">Kα, Pα,¬K¬α,¬P¬α<label>(1</label></formula><p>Proof. Let I = (t, f, W ) be a propositional interpretation. If I satisfies Kα, then by the assumption that W = ∅ it also satisfies Pα, ¬K¬α and ¬P¬α. Thus, we get (1). Otherwise, when I |= Kα, I may or may not satisfy Pα. If it does, then I |= K¬α. Under this assumption, we have two possibilities: either I satisfies P¬α, in which case we get the set (3), or not, and we get (4).</p><p>Suppose now I |= Kα and I |= Pα. If I satisfies K¬α, then by the assumption that W = ∅ it also satisfies P¬α. Thus, we get the set (2).</p><p>Finally, if I |= K¬α, then I may or may not satisfy P¬α. Thus, we get the sets ( <ref type="formula">5</ref>) and ( <ref type="formula" target="#formula_5">6</ref>), respectively.</p><p>We now analyze the information each of the above sets gives us for an arbitrary propositional formula α, and abstract it as a truth value, referring to the six maximally consistent sets in Theorem 1.</p><p>(1) We know that α is true in all worlds (Kα). We abstract this as the truth value t (always true).</p><p>(2) We know that ¬α is true in all worlds (K¬α), hence α is false in all worlds. We abstract this as the truth value f (always false).</p><p>(3) We know that there exists a world w in which α is true (Pα) and there exists a world w in which its negation is true (P¬α). Since α cannot be both true and false in the same world, we have w = w . We abstract this as the truth value s (sometimes true and sometimes false). (4) We know that there is a world in which α is true (Pα) but we do not know whether there is a (distinct) world in which its negation is true (¬P¬α). Thus, α could be true in all worlds, but we do not know that (¬Kα). We abstract this as the truth value st (sometimes true). (5) We know that there is a world in which the negation of α is true (P¬α) and where α is then false, but we do not know whether there is a (distinct) world in which α is true (¬Pα). Thus, α could be false in all worlds, but we do not know that (¬K¬α). We abstract this as the truth value sf (sometimes false). (6) We do not know whether there exists a world in which α is true (¬Pα) nor whether there is one where its negation is true (¬P¬α). That is, we have no information at all, and we abstract this as the truth value u (unknown). Thus, our set of truth values is T 6v = {t, f, s, st, sf, u}.</p><p>With each truth value τ and each propositional formula α, we associate the (subjective) epistemic formula χ τ α given by the conjunction of all formulae in the maximally consistent subset of M(α) corresponding to τ . So, for example, χ s α is the conjunction of all formulae in (3), that is, ¬Kα ∧ Pα ∧ ¬K¬α ∧ P¬α. Intuitively, the satisfiability of χ τ α tells us whether it is possible for α to evaluate to the truth value τ .</p></div>
<div><head>Truth Tables</head><p>With the set of truth values in place, we now look at how the truth tables for the connectives are defined. Starting from the fact that truth values correspond to maximally consistent sets of modalities, we will argue that the truth tables must satisfy two reasonable requirements: consistency and generality.</p><p>Consistency Let us first consider the unary connective ¬; given a truth value τ , which truth value should ¬τ denote? If τ is t, intuition tells us that ¬τ should not be t. Indeed, such a situation cannot occur, in the sense that for every propositional formula α there exists no interpretation I that satisfies both χ t α and χ t ¬α . For binary connectives, the situation is similar; for example, t∧t should not be f, as it cannot happen that for propositional formulae α and β there exists an interpretation I that satisfies χ t α , χ t β and χ f α∧β . Thus, we require that each entry in a truth table be consistent in the following sense. Definition 1. Let τ 1 , τ 2 , and τ be truth values in T 6v , and let ω be a binary connective. We say that τ is consistent with ω on τ 1 and τ 2 if there exist propositional formulae α and</p><formula xml:id="formula_6">β such that χ τ1 α ∧ χ τ2 β ∧ χ τ ω(α,β) is satisfiable.</formula><p>Similarly, τ is consistent with ¬ on τ 1 if there exists a propositional formula α such that χ τ1 α ∧ χ τ ¬α is satisfiable. The notion of consistency directly yields the truth table of ¬ shown in Figure <ref type="figure" target="#fig_0">3c</ref>, due to the following: Proposition 1. For every τ ∈ T 6v there exists one and only one truth value in T 6v that is consistent with ¬ on τ .</p><p>However, this is not the case for binary connectives: there are combinations of truth values that admit more than one consistent truth value, so consistency alone does not suffice to univocally define the truth tables for ∧ and ∨. For example, both f and sf are consistent with sf ∧ sf, and both t and st are consistent with st ∨ st. In such cases, how do we choose a suitable truth value? This is what we answer next.</p><p>Generality When there is more than one truth value that is consistent with a binary connective, we should pick the most general among them. To illustrate this point, let us consider the case of sf ∧ sf, which admits two consistent truth values: sf and f. Choosing f would preclude the existence of interpretations where the formula is true in some world. On the other hand, sf allows for this possibility without precluding the existence of interpretations where the formula is false in all worlds. We will make this intuition more precise in what follows.</p><p>For propositional interpretations I = (t, f, W ) and I = (t , f , W ), we say that I is more general than I (and write I I), if there exists a surjective mapping h : W → W such that, for every propositional formula α and every w ∈ W , all of the following hold:</p><p>• w ∈ t(α) implies h(w) ∈ t (α), and</p><formula xml:id="formula_7">• w ∈ f (α) implies h(w) ∈ f (α).</formula><p>Intuitively, I is more general than I if, for every propositional formula α, it has more worlds where α is not known to be true or false -that is, worlds that do not belong to either t(α) nor f (α) -but I agrees with I on all the worlds for which this information is present.</p><p>Using this notion, we can define a partial ordering on subjective epistemic formulae as follows: we say that ϕ is more general than ψ (and write ψ ϕ) if for every model I of ψ there exists a model I of ϕ such that I I .</p><p>Finally, we can use generality to define a preference criterion for choosing a truth value over another when more than one are consistent with a connective. Definition 2. Let τ and τ be truth values that are consistent with ω on τ 1 and τ 2 . Then, τ is preferable to τ with respect to ω(τ 1 , τ 2 ) if</p><formula xml:id="formula_8">χ τ1 α ∧ χ τ2 β ∧ χ τ ω(α,β) χ τ1 α ∧ χ τ2 β ∧ χ τ ω(α,β)</formula><p>for all propositional formulae α and β.</p><p>Of course, the above still leaves open the possibility that, among the truth values that are consistent with a binary connective, there might not be one that is preferable to all others. Below, we show that this is not the case. Theorem 2. Let ω ∈ {∧, ∨}, let τ 1 , τ 2 ∈ T 6v , and let C be the subset of truth values in T 6v that are consistent with ω on τ 1 and τ 2 . Then, there exists a unique τ ∈ C such that, for every τ ∈ C, τ is preferable to τ with respect to ω(τ 1 , τ 2 ).</p><p>Thus, to define the truth table of a binary connective ω, for each combination of truth values τ 1 and τ 2 in T 6v we assign to ω(τ 1 , τ 2 ) the most preferable truth value that is consistent with ω on τ 1 and τ 2 . This yields the truth tables for ∧ and ∨ shown in Figure <ref type="figure" target="#fig_0">3a</ref> and 3b, respectively. Finally, we call L 6v the propositional logic consisting of the truth values in T 6v and the truth tables in Figure <ref type="figure" target="#fig_0">3</ref>. Coming back to the example of sf ∧ sf mentioned earlier, we now illustrate intuitively why the requirement of generality is indeed reasonable. Suppose that two non-equivalent propositional formulae α and β are both assigned the truth value sf. If the evaluation is correct, then for every propositional interpretation there exists a world in which α is false and a world (not necessarily the same) in which β is false. Both sf and f are consistent with sf ∧ sf, so what truth value should α ∧ β evaluate to? The truth value f would indicate that α ∧ β is false in all worlds of every interpretation for which both α and β result in sf. Clearly, there are interpretations for which this happens, for example (t, f, {w 1 , w 2 }) with f (α) = {w 1 }, f (β) = {w 2 } and t(α) = t(β) = ∅. However, there are also interpretations where this is not the case, for instance (t , f , {w 1 , w 2 ) with t (α) = t (β) = ∅ and f (α) = f (β) = {w 1 }. The truth value sf is general enough to correctly capture the outcome of sf ∧ sf in all situations, including those mentioned above, while f may be incorrect in some cases.</p></div>
<div><head>SQL's Propositional Logic</head><p>The propositional logic L 6v = T 6v , {∧, ∨, ¬} can express many nuances of the truth value of a propositional formula in the case of incomplete information. But can this logic be used in practice?</p><p>The query optimization engines of modern relational database management systems are based on decades of research that relies on a well established set of assumptions on the logic underlying the evaluation. Among these assumptions, there are two crucial properties of the binary connectives: idempotency and distributivity, see <ref type="bibr" target="#b26">(Jarke and Koch 1984;</ref><ref type="bibr" target="#b21">Graefe 1993</ref>). These are used to transform redundant expressions into equivalent non-redundant ones, in order to reduce  the number of superfluous operations to be executed during query evaluation.</p><formula xml:id="formula_9">∧ t f s st sf u t t f s st sf u f f f f f f f s s f sf sf sf sf st st f sf u sf u sf sf f sf sf sf sf u u f sf u sf u (a) ∨ t f s st sf u t t</formula><p>The binary connectives in L 6v are weakly idempotent, i.e., for every truth value τ ∈ T 6v we have τ ∧ τ ∧ τ = τ ∧ τ , and likewise for ∨. However, they are not idempotent: s ∧ s and s ∨ s give sf and st, respectively, rather than s. Moreover, ∧ does not distribute over ∨:</p><formula xml:id="formula_10">s ∧ st (s ∨ s) sf = sf (s ∧ s) ∨ sf (s ∧ s) u and ∨ does not distribute over ∧: s ∨ sf (s ∧ s) st = st (s ∨ s) ∧ st (s ∨ s) u</formula><p>Due to the lack of idempotency and distributivity, L 6v is unlikely to be implemented in real systems for query evaluation. However, we can look for sublogics of L 6v with the desired properties.</p><p>To this end, we say that L = (T, Ω) is a sublogic of L = (T , Ω ) if T ⊆ T and for every ω ∈ Ω there exists ω ∈ Ω such that ω(τ ) = ω (τ ) for every tuple of truth values in T. A sublogic L of L is maximal with respect to a property P if it has P and there is no sublogic L of L with property P such that L is a sublogic of L .</p><p>For practical purposes, we want a sublogic of L 6v that has the truth value t and it is maximal with respect to distributivity and idempotency. Theorem 3. L 3v is the only sublogic of L 6v that includes the truth value t and that is maximal with respect to distributivity and idempotency of the binary connectives (∧ and ∨).</p><p>Therefore, when it comes to balancing expressiveness and practicality, the much criticized three-valued logic used by <software>SQL</software> is in fact a good choice for dealing with incomplete information in relational databases, at least for the propositional case.</p><p>We next examine extensions of propositional logics such as L 6v and L 3v to predicate logics.</p></div>
<div><head>Predicate Logics</head><p>As already explained, the need to consider predicate logics of incomplete information arises most commonly in querying incomplete databases, where special values -commonly referred to as nulls -indicate incompleteness of some sort.</p><p>When atomic formulae may involve nulls -e.g., comparing a null with another value, or checking whether a tuple with nulls belongs to a relation -the standard approach is not to follow the Boolean semantics of FO, but instead to look for a many-valued semantics that will properly lift a propositional logic to all of FO. Such a semantics is by no means unique; we shall see three common versions later in this section.</p><p>We now define incomplete relational databases (which are in fact two-sorted relational structures), and consider manyvalued FO logics on them, based on particular propositional logic. While propagating truth values through connectives and quantifiers is completely standard, assigning them to atoms is not unique. We consider three commonly occurring ways:</p><p>• one uses the Boolean semantics <ref type="bibr" target="#b10">(Bolc and Borowik 1992)</ref>,</p><p>• one adopts the approach of <software ContextAttributes="used">SQL</software> <ref type="bibr" target="#b17">(Date and Darwen 1996)</ref>,</p><p>• and yet another is based on tuple unification, to achieve query answers with certainty guarantees <ref type="bibr" target="#b28">(Libkin 2016)</ref>.</p><p>As our main result, we show that in the context of manyvalued FO, the exact choice of semantics of atoms, or truth values, or propositional connectives, does not matter: whatever combination of these one chooses, the resulting logic can be encoded in Boolean FO.</p></div>
<div><head>Incomplete Relational Structures (Databases)</head><p>As is standard in the database field and many applications of incomplete information, elements of relational structures (or relational databases; these terms are used interchangeably) come from two disjoint sets. One is the set Const of constants, i.e., known values that are stored in databases. The other is the set Null of nulls that represent unknown values. We always assume that Const is countably infinite. For the set Null, some options exist, of which the most common are the following.</p><p>• Null too is a countably infinite set. This corresponds to the model of marked nulls used both in relational databases and their many applications, such data exchange <ref type="bibr" target="#b1">(Arenas et al. 2014)</ref>, data integration <ref type="bibr" target="#b27">(Lenzerini 2002)</ref> and OBDA <ref type="bibr" target="#b8">(Bienvenu and Ortiz 2015)</ref>. • Null is a singleton set containing one element denoted by N N N. This is the approach of <software ContextAttributes="used">SQL</software> and implementations of relational DBMSs, where there is just one single null value.</p><p>A relational vocabulary σ (which is usually called schema in the database context) is a set {R 1 , . . . , R n , =} consisting of relation names R 1 , . . . , R n , each with an associated arity, plus a binary relation symbol "=" for equality. A structure A of this vocabulary is a tuple A, R A 1 , . . . , R A n , = A , where:</p><formula xml:id="formula_11">• A is a finite subset of Const ∪ Null, • R A i ⊆ A k</formula><p>for every i ∈ {1, . . . , n}, and • = A is the binary relation defined as {(a, a) | a ∈ A}.</p></div>
<div><head>Many-valued Predicate Logics</head><p>A many-valued predicate logic is based on a many-valued propositional logic L with a set T of truth values and Ω of propositional connectives. Such a logic is a pair FO(L), of FO formulae based on the propositional logic (to be defined shortly) and the semantics of its formulae. We assume throughout that L has connectives ∨, ∧ which are commutative and associative. This is necessary to define quantifiers. Other connectives are arbitrary. We assume that truth values t and f are always included in T.</p><p>Syntax and semantics of FO(L) Given a propositional logic L with truth values T and connectives Ω, formulae of FO(L) are defined by the following rules.</p></div>
<div><head>• Atomic formulae:</head><p>if R is a k-ary vocabulary symbol, and x 1 , . . . , x k are variables, then R(x 1 , . . . , x k ) is an atomic formula; we shall also write the more common x 1 = x 2 in place of =(x 1 , x 2 ); -const(x) and null(x) are atomic formulae.</p><p>• If ω ∈ Ω is a k-ary connective, and ϕ 1 , . . . , ϕ k are formulae, then ω(ϕ 1 , . . . , ϕ k ) is a formula. • If ϕ is a formula and x is a variable, then ∃x ϕ and ∀x ϕ are formulae.</p><p>The notion of free variables is defined in the usual way.</p><p>The semantics of a formula ϕ is given with respect to a structure A with universe A and an assignment ν of values in A to free variables of ϕ (i.e., ν is a partial function that is defined on all free variables of ϕ and takes values in A). This semantics will be denoted by ϕ A,ν , and it is a value in T. In other words, assigns a truth value in T to ϕ in a structure A under assignment ν.</p><p>The semantics of atoms const and null is as follows:</p><formula xml:id="formula_12">const(x) A,ν = t if ν(x) ∈ Const, f if ν(x) ∈ Null. null(x) A,ν = t if ν(x) ∈ Null, f if ν(x) ∈ Const.</formula><p>For propositional connectives and quantifiers, the semantics is defined with the standard lifting rules:</p><formula xml:id="formula_13">ω(ϕ 1 , . . . , ϕ k ) A,ν = ω( ϕ 1 A,ν , . . . , ϕ k A,ν ) , ∃x ϕ A,ν = a∈A ϕ A,ν[a/x] , ∀x ϕ A,ν = a∈A ϕ A,ν[a/x] ,</formula><p>where ν[a/x] is the same as ν except that it assigns a to x. The last two rules rely on the fact that ∨ and ∧ are commutative and associative.</p><p>For atomic formulae R(x), with R ∈ σ, there are several options, which we now consider, when the underlying logic is either L bool or L 3v .</p><p>Boolean semantics This is the standard two-valued FO semantics, with only t and f as truth values, and it is given by</p><formula xml:id="formula_14">R(x) bool A,ν = t if ν(x) ∈ R A , f if ν(x) ∈ R A ,</formula><p>for every R in the vocabulary σ (which, recall, includes =).</p><p>It is then extended to all of FO with the above rules, resulting in the semantics bool defined for all FO formulae. When ϕ bool A,ν = t we also write the more customary A, ν |= ϕ.</p><p>The logic BFO, or Boolean FO, is now formally defined as FO(L bool ) interpreted under bool ; it is the standard FO with only t and f as truth values.</p><p>Null-free semantics A tuple ā is null-free if all of its values are from Const. The null-free semantics of FO(L 3v ) is the same as the Boolean semantics for tuples of constants; if any nulls are present, it produces the truth value u:</p><formula xml:id="formula_15">R(x) nf A,ν =    t if ν(x) ∈ R A and ν(x) is null-free, f if ν(x) ∈ R A and ν(x) is null-free, u if ν(x) contains a null,</formula><p>for every R in the vocabulary σ (which, recall, includes =).</p><p>In particular, for the equality predicate =, this is exactly the semantics used by <software ContextAttributes="used">SQL</software> <ref type="bibr" target="#b17">(Date and Darwen 1996)</ref>.</p><p>Unification semantics A semantics based on the notion of tuple unification was proposed by <ref type="bibr" target="#b28">Libkin (2016)</ref> to enforce certainty guarantees for query answers. We say that two tuples ā and b unify if there is a map h : Const ∪ Null → Const that is the identity on constants and such that h(ā) = h( b).</p><p>Then, for every relation symbol R in the vocabulary σ, the unification semantics is defined by</p><formula xml:id="formula_16">R(x) ⇑ A,ν =    t if ν(x) ∈ R A , f if ā ∈ R A s.t. ν(x) and ā unify, u otherwise.</formula><p>The semantics ⇑ is then lifted to all of FO by the standard lifting rules. The reason this semantics was introduced is that it ensures certainty of answers to FO queries: if ϕ(x) ⇑ A,ν = t, then the tuple ū = ν(x) is what is known as a certain answer to ϕ, i.e., h(A) |= ϕ h(ū) for every map h : Const ∪ Null → Const that is the identity on constants.</p><p>Mixed semantics There is a priori no reason to apply the same semantics on each relation symbol R ∈ σ; instead we can freely mix them. A mixed semantics s is then given by a function s : σ → {bool, ⇑, nf} so that R(x) s A,ν = R(x) s(R) A,ν . This generalizes Boolean, unification, and nullfree semantics.</p></div>
<div><head>Boolean FO Captures Many-valued FO</head><p>We now show that in most cases, many-valued predicate logics do not give any extra power compared to BFO, i.e., the usual FO under the standard Boolean interpretation of connectives and the Boolean semantics of atomic formulae. The notion of capturing a many-valued FO logic by BFO is defined as follows. Definition 3. A formula ϕ of FO(L) over a many-valued propositional logic L with truth values T is captured by BFO under semantics if there exist BFO formulae ϕ τ for each τ ∈ T such that for every structure A and assignment ν of free variables of ϕ we have</p><formula xml:id="formula_17">ϕ A,ν = τ ⇔ A, ν |= ϕ τ .</formula><p>FO(L) is captured by BFO if each of its formulae is.</p><p>Usually we are interested in formulae that are true in a given structure, i.e., ϕ A,ν = t. If a formula is captured by BFO, this tells us that we do not need many-valued semantics, and instead can simply check whether A, ν |= ϕ t under the usual Boolean semantics.</p><p>To capture a many-valued FO by BFO we need very few assumptions. Recall that L = T, Ω is given by a set of truth values and truth tables for connectives in Ω, which we assume to contain at least ∨, ∧ to define quantifiers. In logics such as L bool and L 3v , these connectives are idempotent, i.e., τ ∧ τ = τ ∨ τ = τ for every τ ∈ T. In L 6v , they are weakly idempotent: τ ∧ τ ∧ τ = τ ∧ τ and likewise for ∨. Notice that idempotency implies weak idempotency. This is the only condition we need to impose to be able to lift capturing formulae by Boolean FO from atoms to arbitrary formulae. Theorem 4. Let L be a propositional many-valued logic in which connectives ∧ and ∨ are weakly idempotent. Assume that every relational atom R(x), for R ∈ σ, is captured by BFO under . Then every FO(L) formula over vocabulary σ is captured by BFO under .</p><p>To apply this result to the previously considered semantics, we need to capture atomic formulae, under different semantics, in BFO. This is possible for all of them. Proposition 2. Relational atoms are captured by BFO under Boolean, unification, and null-free semantics.</p><p>Finally, this tells us that any mixed semantics (including its pure versions, i.e., Boolean, unification, null-free) coupled with any propositional many-valued logic like L 3v or L 6v (as long as it has weakly idempotent conjunction and disjunction) is no more powerful than the standard semantics over two truth values t and f. Corollary 1. Let L be a propositional many-valued logic whose truth values include {t, f, u}, with an arbitrary set of connectives where ∨ and ∧ are (weakly) idempotent. Then for every vocabulary σ, every function s defining a mixed semantics, and every formula ϕ of FO(L) there is a formula ϕ of BFO such that ϕ s A,ν = t iff A, ν |= ϕ . Using this result, we can clarify, in the next section, the question of the power of the logic that underlies real-life database applications that use incomplete information.</p></div>
<div><head>The Logic of SQL</head><p>Most database texts will claim that the core of <software>SQL</software>, the main relational database query language, is first-order logic FO. This was certainly true in the early stages of <software ContextAttributes="used">SQL</software> design, as it grew out of relational calculus, which is just another name for FO. But then the language gained many features, in particular null values, leading to more complex underlying logics.</p><p>These logics are still not well understood, as the formalization of <software ContextAttributes="used">SQL</software> mainly took a different route via relational algebra, which is the procedural counterpart of FO. Several attempts to provide a theoretical language behind <software ContextAttributes="used">SQL</software> looked at relational algebra translations of the language <ref type="bibr" target="#b11">(Ceri and Gottlob 1985;</ref><ref type="bibr" target="#b31">Van den Bussche and Vansummeren 2009)</ref> or presented semantics of various fragments of the language, often under the simplifying assumption that no nulls are present and no three-valued logic is used <ref type="bibr" target="#b12">(Chu et al. 2017;</ref><ref type="bibr" target="#b29">Negri, Pelagatti, and Sbattella 1991)</ref>. An attempt to find a logic underlying <software ContextAttributes="used">SQL</software> concentrated on its features that go beyond FO (i.e., aggregation) rather than nulls <ref type="bibr" target="#b24">(Hella et al. 2001)</ref>. More recent work <ref type="bibr" target="#b23">(Guagliardo and Libkin 2017)</ref>, while providing a direct semantics of <software ContextAttributes="used">SQL</software>, accounted for null values and three-valued logic, and even gave a translation of <software ContextAttributes="used">SQL</software> queries that, similarly in spirit to the results in the previous section, showed how to evaluate them without ever producing the unknown truth value u. This was done, however, at the level of <software ContextAttributes="used">SQL</software> queries. We now analyze the power of <software ContextAttributes="used">SQL</software> and the need for three truth values at a purely logical level.</p><p>We start with the basic fragment of relational languages that has the power of FO, or -equivalently -the basic operations of relational algebra, or <software>SQL</software>'s select-from-where queries without aggregation. These operate on databases whose values come from Const. Recall that <software ContextAttributes="used">SQL</software> uses a single null denoted here by N N N. Now we add it; how should the logic change to capture this extension? It depends on who is asked to produce such an extension. A logician's approach If the domain is extended by a single constant, we simply consider FO over Const ∪ {N N N} with a unary predicate null( ) that is only true in N N N (to keep the vocabulary relational; alternatively a constant symbol could be added). The interpretation of = is simply {(c, c) | c ∈ Const} ∪ {(N N N, N N N)}, i.e., syntactic equality: N N N is equal to itself, and not equal to any element of Const. In other words, the logic is the usual BFO, with all the atoms interpreted under the Boolean semantics bool .</p><p>It would thus be seen, by a logician, as an overkill to introduce a many-valued logic to deal with just one extra element of the domain. Nonetheless, this is what <software>SQL</software> did.</p><p><software>SQL</software> approach: a textbook version The usual explanation of the logic behind <software ContextAttributes="used">SQL</software> is that it adds a new truth value u to account for any comparisons involving nulls. In other words, the logic is FO(L 3v ), and the semantics sql is mixed, combining Boolean and null-free semantics:</p><p>• for relational atoms, R(x) sql A,ν = R(x) bool A,ν ;</p><p>• for equality, x = y sql A,ν = x = y nf A,ν .</p><p><software>SQL</software> approach: what really happens While the textbook approach comes close to describing the logic of <software ContextAttributes="used">SQL</software>, it misses one important feature of such logic. In essence, we can think of <software ContextAttributes="used">SQL</software> queries as expressions select x from Q 1 , . . . , Q n where θ(x 1 , . . . , xn ) where Q 1 , . . . , Q n are either queries or relations, xi is a tuple of variables returned by Q i , and θ is a condition composed of equalities of variables and constants, or statements Q (ȳ), where Q is another query, or statements Q = ∅, combined using ∧, ∨, and ¬.</p><p>Note that in <software ContextAttributes="used">SQL</software> query evaluation, it is the conditions θ that are evaluated in L 3v ; once the evaluation of the where θ clause is finished, only tuples that evaluated to t are kept. To capture this in logic, we need a propositional operator that collapses f and u into f. Such an operator does exist in propositional many-valued logics <ref type="bibr" target="#b9">(Bochvar 1981)</ref> and is known as an assertion operator: ↑p for a proposition p evaluates to t if p evaluates to t, and to f otherwise. Let L ↑ 3v be the extension of L 3v with this operator.</p><p>The basic <software>SQL</software> query can then be expressed in FO(L ↑ 3v ):</p><formula xml:id="formula_18">Q(x) = ∃ȳ n i=1 Q i (x i ) ∧ ↑θ(x 1 , . . . , xn ) ,</formula><p>where ȳ lists the variables present in x1 , . . . , xn but not in x. Thus, the many-valued predicate logic capturing <software>SQL</software>'s behavior is FO(L ↑ 3v ) under sql .</p><p>To sum up, there are three choices of a logic capturing <software>SQL</software>'s behavior: 1) Boolean predicate logic BFO; 2) FO based on Kleene's logic under the sql semantics; 3) FO based on Kleene's logic with the assertion operator under the sql semantics. These logics use different sets of truth values. However, it only matters when formulae evaluate to true, as this determines the output of queries. Thus, to compare logics with different sets of truth values, we say that two logics, FO(L 1 ) under 1 , and FO(L 2 ) under 2 , are true-equivalent if the models of t are the same in both. That is, for every formula ϕ 1 of FO(L 1 ) there is a formula ϕ 2 of FO(L 2 ) such that</p><formula xml:id="formula_19">ϕ 1 1 A,ν = t ⇔ ϕ 2 2</formula><p>A,ν = t for every A, ν, and vice versa, for each ϕ 2 of FO(L 2 ) there is a formula ϕ 1 of FO(L 1 ) such that the above condition holds.</p><p>Then, with respect to the truth value t, there is no difference between the logics that attempt to model <software>SQL</software>'s behavior. Theorem 5. The logics FO(L 3v ) and FO(L ↑ 3v ), both under sql , and BFO, are all true-equivalent.</p><p>Thus, the most natural logical approach to adding a null value to the language does not miss any expressiveness of the more complex solutions based on many-valued logics.</p></div>
<div><head>Conclusions</head><p>To conclude, let us revisit history. Handling incomplete information by logical languages is an important topic, especially in data management. All commercial database systems that speak <software>SQL</software> offer a solution based on a three-valued propositional logic that is lifted then to full predicate logic. This solution was heavily criticized in the literature, but at the level of the chosen propositional logic.</p><p>We proposed a principled approach to justifying a proper logic for handling incomplete information, which resulted in a six-valued logic L 6v . However, taking into account the needs of <software>SQL</software> query evaluation (e.g., distributivity laws), the largest fragment of L 6v that does not break traditional evaluation and optimization strategies is Kleene's logic L 3v , precisely the one chosen by <software ContextAttributes="used">SQL</software>.</p><p>However, even though the <software>SQL</software> designers were justified in their choice of Kleene's logic, they neglected to consider the impact that lifting it to full predicate logic would have. We showed that it leads to no increase in expressive power; had this been known to the <software ContextAttributes="used">SQL</software> designers, perhaps other choices would have been considered too.</p><p>But does this mean that we should abandon many-valued logics of incomplete information? Most likely not: while the theoretical complexity of formulae that result from eliminating many-valuedness is the same as that of original manyvalued formulae, their practical complexity (i.e., if implemented as real life database queries) is likely to be different. This is mainly due to the fact that 40 years of research on query evaluation and optimization had one particular model in mind, and that model used a many-valued logic. However, the observations we made here might have an impact on the design of new languages, since avoiding many-valued logics for handling incompleteness is now an option.</p><p>Regarding future directions, we would like to extend the propositional setup with bilattice orderings as is often done <ref type="bibr" target="#b2">(Arieli and Avron 1996;</ref><ref type="bibr" target="#b20">Ginsberg 1988)</ref>, and understand the right orderings for logics like L 6v . Yet another direction is to drop the restriction t(α) ∩ f (α) = ∅ for every propositional formula α. Such restrictions have been lifted in the study of paraconsistent logics <ref type="bibr" target="#b4">(Arieli, Avron, and Zamansky 2010;</ref><ref type="bibr" target="#b33">Zamansky and Avron 2006)</ref>, and in fact the question of looking for the right many-valued logic for reasoning about inconsistency has been raised <ref type="bibr" target="#b5">(Arieli, Avron, and Zamansky 2011)</ref>. Our focus would be slightly different, as we want to extend the current study to handle the most common case of inconsistency in data management, namely inconsistency with respect to integrity constraints <ref type="bibr" target="#b0">(Arenas, Bertossi, and Chomicki 1999;</ref><ref type="bibr" target="#b7">Bertossi 2011).</ref> </p></div><figure xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The truth tables of L 6v for ∧, ∨ and ¬.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>The authors would like to thank the anonymous referees for their helpful comments. This work was partly supported by <rs type="funder">EPSRC</rs> grants <rs type="grantNumber">M025268</rs> and <rs type="grantNumber">N023056</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_Rp3Ktwh">
					<idno type="grant-number">M025268</idno>
				</org>
				<org type="funding" xml:id="_y9vFwdW">
					<idno type="grant-number">N023056</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Consistent query answers in inconsistent databases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chomicki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="68" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Murlak</surname></persName>
		</author>
		<title level="m">Foundations of Data Exchange</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reasoning with logical bilattices</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arieli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic, Language and Information</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="63" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The logical role of the fourvalued bilattice</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arieli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="118" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Maximally paraconsistent three-valued logics</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arieli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zamansky</surname></persName>
		</author>
		<editor>KR.</editor>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">What is an ideal logic for reasoning with inconsistency</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arieli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zamansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="706" to="711" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A useful four-valued logic</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Belnap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modern Uses of Multiple-Valued Logic</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Dunn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Epstein</surname></persName>
		</editor>
		<imprint>
			<publisher>D. Reidel</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="8" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Database Repairing and Consistent Query Answering</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bertossi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Morgan&amp;Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Ontology-mediated query answering with data-tractable description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Reasoning Web</title>
		<imprint>
			<biblScope unit="page" from="218" to="307" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On a three-valued logical calculus and its application to the analysis of the paradoxes of the classical extended functional calculus</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Bochvar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Translated from Matematicheskij Sbornik</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">46</biblScope>
			<biblScope unit="page" from="287" to="308" />
			<date type="published" when="1938">1981. 1938</date>
		</imprint>
	</monogr>
	<note>History and Philosophy of Logic</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Many-Valued Logics: Theoretical Foundations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bolc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Borowik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Translating SQL into relational algebra: Optimization, semantics, and equivalence of SQL queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ceri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="324" to="345" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">HoTTSQL: Proving query rewrites with univalent SQL semantics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Weitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="510" to="524" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Understanding relations (installment #7)</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FDT -Bulletin of ACM SIGMOD</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="23" to="28" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">More commentary on missing information in relational databases</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="42" to="50" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Approximations and refinements of certain answers via many-valued logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KR</title>
		<imprint>
			<biblScope unit="page" from="349" to="358" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The third manifesto</title>
		<author>
			<persName><forename type="first">H</forename><surname>Darwen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="49" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A Guide to the SQL Standard</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Darwen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Database in Depth -Relational Theory for Practitioners</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Log. Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="797" to="810" />
			<date type="published" when="1991">2005. 1991</date>
		</imprint>
	</monogr>
	<note>Kleene's logic, generalized</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Four valued logic for relational database systems</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Gessert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="29" to="35" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Multivalued logics: a uniform approach to reasoning in artificial intelligence</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Ginsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Intelligence</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="265" to="316" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Query evaluation techniques for large databases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="73" to="170" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Intuitionistic data exchange</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moallemi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Onet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">9th Alberto Mendelzon International Workshop on Foundations of Data Management</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A formal semantics of SQL queries, its validation, and applications</title>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="39" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Logics with aggregate operators</title>
		<author>
			<persName><forename type="first">L</forename><surname>Hella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nurmonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="880" to="907" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<idno>ISO/IEC. 2016. ISO/IEC 9075:2016</idno>
		<title level="m">Information technology -Database languages -SQL</title>
		<imprint>
			<publisher>International Organization for Standardization</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Query optimization in database systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="111" to="152" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Data integration: a theoretical perspective</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Database Systems (PODS)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="233" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">SQL's three-valued logic and certain answers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Formal semantics of SQL queries</title>
		<author>
			<persName><forename type="first">M</forename><surname>Negri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pelagatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sbattella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="513" to="534" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">A logic for default reasoning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="81" to="132" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Translating SQL into the relational algebra</title>
		<author>
			<persName><forename type="first">J</forename><surname>Van Den Bussche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vansummeren</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
		<respStmt>
			<orgName>Hasselt University and Université Libre de Bruxelles</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Course notes</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A more general model for handling missing information in relational databases using a 3-valued logic</title>
		<author>
			<persName><forename type="first">K</forename><surname>Yue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="43" to="49" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Non-deterministic semantics for first-order paraconsistent logics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Zamansky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">KR</title>
		<imprint>
			<biblScope unit="page" from="431" to="439" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>