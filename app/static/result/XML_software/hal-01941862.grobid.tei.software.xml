<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Accelerating Itemset Sampling using Satisfiability Constraints on FPGA</title>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Mael</forename><surname>Gueguen</surname></persName>
							<email>mael.gueguen@irisa.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">IRISA</orgName>
								<address>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Sentieys</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">IRISA</orgName>
								<address>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexandre</forename><surname>Termier</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Univ Rennes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">IRISA</orgName>
								<address>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Accelerating Itemset Sampling using Satisfiability Constraints on FPGA</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">26AEF307EF831EA30A7171ED225E3141</idno>
					<idno type="DOI">10.23919/DATE.2019.8714932</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Finding recurrent patterns within a data stream is important for fields as diverse as cybersecurity or e-commerce. This requires to use pattern mining techniques. However, pattern mining suffers from two issues. The first one, known as "pattern explosion", comes from the large combinatorial space explored and is the result of too many patterns outputed to be analyzed. Recent techniques called output space sampling solve this problem by outputing only a sampled set of all the results, with a target size provided by the user. The second issue is that most algorithms are designed to operate on static datasets or low throughput streams. In this paper, we propose a contribution to tackle both issues, by designing an FPGA accelerator for pattern mining with output space sampling. We show that our accelerator can outperform a state-of-the-art implementation on a server class CPU using a modest FPGA product.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head>I. INTRODUCTION</head><p>When analyzing data, an important task is to discover correlations. Such correlations can be that Amazon customers that buy a laptop often buy a mouse simultaneously, or that a set of files are often accessed simultaneously in a cloud storage context. These correlations give powerful insights on the contents of the data, that may be used to take actions. For example Amazon will immediately show mouses to customers having put a laptop in their cart, and the cloud storage operator will position the files often accessed together on the same physical machine.</p><p>Discovering potentially complex correlations is handled by Pattern Mining algorithms, whose goal is to explore a huge combinatorial space efficiently. Most of them have been designed for an offline data analysis setting: a static dataset is input to the algorithm which performs pattern extraction (runtime varying from a few seconds to several days depending on the data and parameters). The results are then manually reviewed by a data analyst. However, many modern settings require an online loop, where the data is continuously arriving. In this context, patterns are extracted in few seconds at most, and are used to take automated decisions. For example, Amazon needs to be able to adapt quickly to changes in customer behavior or arrival of new products, and file access patterns will change upon completion of projects using those files.</p><p>There exist some pattern mining algorithms that handle data streams, however they have two limitations: 1) they are likely to output thousands of results of mixed interest and 2) they are not designed to cope with a high throughput. The first limitation is shared by most pattern mining algorithms: they extract patterns that are repeated frequently in the data, and in practice there are many of such repeated patterns. A large portion of these patterns contain redundant information. There are several ways to reduce the number of patterns output to a manageable size, one of the most drastic being pattern sampling. The idea is to only compute a set of frequent patterns, and to have statistical guarantees that these patterns are a "good" sample of the complete set of patterns. Pattern sampling algorithms are a promising approach for performing a pattern-based analysis of data streams.</p><p>Our contribution is to show that pattern sampling can be performed extremely efficiently on an FPGA. This paves the way for future pattern sampling hardware accelerators, able to extract on the fly patterns from data streams with a very high throughput. More precisely, we adapted the state-of-the-art algorithm <software ContextAttributes="created">Flexics</software> <ref type="bibr" target="#b0">[1]</ref> for execution on an FPGA. We explain how to sample randomly itemsets while keeping a control flow applicable for FPGA logic.</p><p>The paper is organized as follows. Section II introduces the pattern mining problem, the Eclat algorithm, and pattern sampling. Section III describes the state of the art <software>Flexics</software> algorithm for pattern sampling, as well as our algorithmic contribution to adapt <software ContextAttributes="created">Flexics</software> to FPGA. Section IV presents the architecture of our approach. Results are presented in Section V. Last, Section VI concludes the paper and hints at future works.</p></div>
<div><head>II. BACKGROUND AND RELATED WORK</head><p>We first introduce the general pattern mining problem, as well as the Eclat algorithm for mining frequent itemsets. We then present existing approaches for accelerating pattern mining algorithms on FPGA and expose pattern sampling approaches.</p></div>
<div><head>A. Pattern mining</head><p>Consider an alphabet A = {X i }, with i ∈ 1, N . The elements of A are called items, and any subset I ⊆ A is called an itemset. A database D is a multiset of transactions, each transaction being an itemset of A. The support of an itemset I ⊆ A in D corresponds to the number of transactions of D containing I. An itemset is frequent in D if its support is above a user-defined frequency threshold t. There is a vast literature on algorithms for mining frequent itemsets. In this paper, we focus on the Eclat algorithm <ref type="bibr" target="#b1">[2]</ref>. Like most pattern mining algorithms, Eclat follows a "generate and test" approach: potentially frequent itemsets are generated, then their frequency is tested in the database. Eclat explores the search space of candidate itemsets in a depth-first manner, starting with small itemsets and augmenting them one item at a time. An example of a search tree is given in Figure <ref type="figure" target="#fig_0">1</ref>. Note that the tree is asymmetric to avoid exploring twice the same itemset.</p><p>ECLAT relies on the Apriori principle <ref type="bibr" target="#b2">[3]</ref> to prune the search space. If an itemset is infrequent in the database, any itemset that contains it will have a lower frequency and it will be infrequent too.</p><p>With the search space of Figure <ref type="figure" target="#fig_0">1</ref>, consider the database D = {abc, bd, abd, acd} and t = 0.5. The itemset ab is present twice, thus has a frequency of 0.5 ≥ t, and is frequent: its children in the tree will be tested. On the other hand, the itemset abc is present only once, thus has a frequency of 0.25 &lt; t and is infrequent. Its children in the tree do not need to be generated nor tested.</p></div>
<div><head>B. Itemset mining on FPGA</head><p>Two families of methods are described in the literature for itemset mining on FPGA. A first method is to use a controller like a CPU allowing for complex controls, and restrict the FPGA to accelerate the support counting of the itemsets <ref type="bibr" target="#b3">[4]</ref>. The other methods accelerate the whole application on hardware <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>. The main difficulty is to streamline the exploration of the tree-shaped search space for an efficient execution on FPGA. The asymetry of the tree is a first problem. The second one is that pruning by the Apriori property, while strictly mandatory for performance, makes the search tree unpredictably irregular. The approach proposed by <ref type="bibr" target="#b5">[6]</ref> elegantly solves both problems, and we used it as a starting point in the design of our approach for FPGA-based pattern sampling.</p></div>
<div><head>C. Pattern Sampling</head><p>Output space sampling is tailored to return a bounded number of patterns without altering the database. Most approaches provide statistical guarantees that the distribution of the sampled patterns is similar to the distribution of the complete set of patterns. Earlier works have adapted standard statistical sampling methods to the case of frequent itemsets <ref type="bibr" target="#b6">[7]</ref>, or exploit simple statistical observations on the structure of the pattern space <ref type="bibr" target="#b7">[8]</ref>.</p><p>More recently, Dzyuba et al. <ref type="bibr" target="#b0">[1]</ref> proposed the <software ContextAttributes="used">Flexics</software> framework. Inspired by sampling strategies used in SAT (Boolean satisfiability) solvers, this approach is built on top of standard (non-sampling) frequent itemset mining algorithms. <software ContextAttributes="used">Flexics</software> adds random XOR constraints that exclude some frequent itemsets from the result. These constraints have the property to partition the frequent itemset space in "cells", where the distribution of itemsets inside each cell is similar to the distribution of the complete space. Given an expected number of frequent itemsets in the output, <software ContextAttributes="used">Flexics</software> will add as many random XOR constraints as necessary to get to a cell containing this number of frequent itemsets (within a small margin of approximation).</p><p>The <software>Flexics</software> framework is one of the most efficient for principled pattern sampling. Furthermore, the original paper shows how to build it above Eclat, an FPGA-friendly algorithm (compared to other frequent itemset miners). And the approach is based on XOR constraints, which are well handled by hardware. It thus seems especially relevant to base an FPGAbased pattern sampling method on the <software ContextAttributes="used">Flexics</software> framework. To the best of our knowledge, this is the first pattern sampling accelerator on FPGA architectures. This is our contribution in this paper, presented in the next sections.</p></div>
<div><head>III. FLEXICS ALGORITHM FOR FPGA</head><p>This section explains our algorithmic contribution to adapt <software>Flexics</software> for FPGA, while the hardware architecture of our solution will be explained in the following section. We first explain how constraints are generated by <software ContextAttributes="used">Flexics</software>. The two step approach proposed in software cannot be used on FPGA, we thus present our first improvement that allows dynamic generation of constraints on the FPGA. We then show how a major improvement of the constraint system can also be used with our approach. Finally, we explain how the constraints can be exploited in an FPGA version of Eclat.</p></div>
<div><head>A. Sampling Itemsets with a System of Binary Constraints</head><p>As introduced in the previous section, the main idea of <software ContextAttributes="used">Flexics</software> is to use random XOR constraints to cut the itemset space in regions of equivalent size and distribution. The original <software ContextAttributes="used">Flexics</software> algorithm is a two step process, where first the Weightgen oracle is called, followed by the actual itemset mining step. The Weightgen oracle, described in <ref type="bibr" target="#b8">[9]</ref>, estimates the weight of the solution (related to the number of results found) of a SAT problem. Weightgen can also be used to generate random arbitrary constraints on the variables of the SAT problem that will reduce the number of results, until the estimated weight is lower than or equal to a user specified threshold. In the case of <software ContextAttributes="used">Flexics</software>, the SAT problem given to Weightgen is finding frequent itemsets in the database. The random constraints generated to sample the results are XOR constraints using the alphabet A of size N from the database. Generated XOR constraints have the form</p><formula xml:id="formula_0">i∈ 1,N b i .X i = b 0 ,<label>(1)</label></formula><p>where b i are randomly generated independent variables in 0, 1 with a uniform distribution. For any i ∈ 1, N , a b i dictates if the item X i will be present in the XOR constraint (1 if present, 0 otherwise). The b 0 coefficient is called the parity bit, as a XOR with multiple inputs returns the parity of the sum of its boolean inputs. These XOR constraints acts as a system of boolean equations, where a given pattern can either satisfy all the equations for the system, or not satisfy at least one of them.</p><p>For example, with a database using an alphabet A = {a, b, c, d, e, f }, and given two randomly generated XOR constraints a ⊕ c ⊕ e = 1 and b ⊕ e ⊕ f = 0, we can check if two frequent candidate itemsets abde and abdf are to be outputed in the samples. For abde, the first XOR constraint gives</p><formula xml:id="formula_1">(1 ⊕ 0) ⊕ 1 = 1 ⇐⇒ (1) ⊕ 1 = 1 ⇐⇒ 0 = 1,</formula><p>which is false. Thus, abde does not satisfy all XOR constraints and is not part of the subspace to be be outputed. For abdf , the first XOR constraint gives (1 ⊕ 0) ⊕ 0 = 1 ⇐⇒ (1) ⊕ 0 = 1, which is true, and the second one gives (1 ⊕ 0) ⊕ 1 = 0 ⇐⇒ (1) ⊕ 1 = 0 ⇐⇒ 0 = 0, which is true. Thus, the frequent itemset abdf satisfies all XOR constraints and will be outputed as a sample.</p><p>The two step approach (Weightgen then mining) is not relevant on an FPGA. First, implementing Weightgen would require a lot of estate, that would be unused most of the time. Second, in a streaming context one would like to be able to quickly react to changes in the pattern distribution, which is difficult to do when pre-computing the number of constraints. Our first contribution is thus to propose a single step approach for pattern sampling, that does not use Weightgen. Instead, the mining starts immediately, and during the mining, our approach dynamically generates new XOR constraints if the potential output size goes above the user-given threshold.</p><p>This way, the number of interesting patterns does not need to be estimated in advance, but the list of interesting patterns discovered has to be maintained when new constraints are generated by dynamically pruning patterns than do not satisfy the newly added constraints. The principles of our dynamic constraint generation is as follows. First, new XOR constraints are generated randomly. Our algorithm ensures that no constraint in the system of equations can be derived from a linear combination of the other constraints. If a newly generated XOR constraint causes the system of equations to be unsolvable, it is rejected. If it is equal to a linear combination of already generated constraints, the new constraint is also rejected. After a constraint is rejected, new constraints are randomly generated, until a generated random XOR constraint respects the criteria. In practice, however, there is a probability of 1  2 N -K for a new random XOR constraint to be rejected in a system already holding K XOR constraints. Thus, this process of rejecting constraints does not impact significantly average performance.</p></div>
<div><head>B. Rewriting the Constraints with Gauss-Jordan Elimination</head><p>The problem we try to solve is the following: scan the depthfirst tree with the ECLAT algorithm, but skip the itemsets that do not satisfy the generated XOR constraints. However, when scanning the sparse samples in the tree, there is no simple relation like the prefix/suffix separation used in <ref type="bibr" target="#b5">[6]</ref> between a sample and the next.</p><p>It is harder to compute what is the next sample to test given any position in the tree, and subsequently, to know if there exist satisfying itemsets down its branch or if the branch is finished. We developed a solution to reduce the problem of mining satisfying itemsets randomly distributed in the tree to a simpler yet equivalent problem that uses ECLAT on a reduced tree that represents at least all frequent satisfying itemsets.</p><p>At any given time with K generated XOR constraints, for an alphabet of size N , the corresponding system of equations would be in the form of</p><formula xml:id="formula_2">∀k ∈ 1, K ,   i∈ 1,N b i,k .X i   = b 0,k ,<label>(2)</label></formula><p>where b i,k ∈ 0, 1 , ∀k ∈ 1, K and ∀i ∈ 1, N . With this notation, the b i,k can be considered as matrix coefficients for an array of size K × (N + 1). The parameter K is dynamic and data dependant (it increases as new samples are found) and is only theoretically bounded by N . Using linear combinations, the matrix corresponding to the system of equations can be transformed using Gauss-Jordan elimination, to generate a row echelon matrix. The solutions of the original system of equations and after the Gauss-Jordan elimination are strictly the same. The Gauss-Jordan elimination is a variant of Gaussian elimination which results in a unique normalized row echelon matrix. This unique matrix has two types of rows: one type can contain any value, while the other type of row contains exactly one 1 that delimits the echelon and 0 everywhere else. After a Gauss-Jordan elimination, our algorithm rewrites the system of equations in the form of</p><formula xml:id="formula_3">∀k ∈ 1, K , X c k =   i∈ 1,N -K ,fi&gt;c k b fi,k .X fi   ⊕ b 0,k<label>(3)</label></formula><p>where {c i } i∈ 1,K denote the indexes of the rows corresponding to the echelons. There are K indexes c i as there are K rows in the Gauss-Jordan matrix. We refer to the items X ci as constrained items. All the other indexes corresponding to rows with any values allowed are noted as {f i } i∈ 1,N -K . There are N -K indexes f i as there are N indexes in total. The items with indexes X fi are called free items.</p></div>
<div><head>C. Scanning sample space with a bijective transformation</head><p>For any system of equations resulting from XOR constraints, our approach is to cut the alphabet into two parts:</p><p>• the set of constrained items X c k that appear in only one XOR constraint after Gauss Jordan elimination and • the set containing the rest of the alphabet, denoted free alphabet, whose items X fi can appear in any XOR constraint.</p><p>In this way, there are two complementary alphabets, that can be non-contiguous, splitting items from the initial alphabet in two categories. Then, the right hand of Equation 3 is computed using the b fi,k in the Gauss-Jordan Matrix and the X fi are equal to 1 if the f i are present in the free itemset and to 0 otherwise. This formula dictates if the items X c k are present in the constrained itemset or not. For two different itemsets constructed from A that satisfy the XOR constraints, their free itemsets are necessarily different. Reciprocally, there exists a single itemset constructed from A that satisfies the XOR constraints for each free itemset. Thus, there is a bijection between the pattern space of the database alphabet and the subspace of patterns satisfying the XOR constraints: a scan of all free itemsets can be used to scan all satisfying itemsets. Furthermore, a sample constructed from the full alphabet A will always be a super-set of its reduced free itemset. Thus, the Apriori principle dictates that if a sample itemset is frequent, its corresponding free itemset is also frequent. Thus, a scan of all frequent free itemsets can be used to scan all frequent satisfying itemsets. Frequent free itemsets can lead to infrequent satisfying itemsets, but the algorithm is guaranteed to find all samples.</p><p>Finding all frequent free itemsets can be done using ECLAT on the reduced free alphabet, and for each frequent free itemset, the algorithm will test its satisfying counterpart. For each itemset in the "reduced" depth-first tree, the accelerator tests the frequency of two itemsets. The free itemset has to be tested to allow pruning with the Apriori principle, and the sample itemsets have to be tested since they will be returned as the final result.</p></div>
<div><head>IV. ACCELERATOR ARCHITECTURE</head><p>This section presents the architecture of our accelerator on an actual FPGA board, and gives details on how the solution is implemented.</p></div>
<div><head>A. Overview</head><p>Figure <ref type="figure">2</ref> shows an overview of the accelerator architecture implemented in the programmable logic fabric of a Zynq FPGA from Xilinx. The zc702 evaluation board used for the experiments holds a System on Chip, containing two Cortex A-9 CPUs and a XC7Z020-CLG484-1 FPGA, connected to an off-chip 1GB DDR3 memory. Our design uses communications between the FPGA and the CPUs only when the hardware application starts and stops, in order to interface with the user. All accesses from the accelerator in the FPGA to the main memory are achieved using the High Performance AXI port, without cache coherency protocols. This section details the support counting acceleration of Figure <ref type="figure">2</ref> and an additional feature we called correspondence list. The candidate generation mechanism is based on <ref type="bibr" target="#b5">[6]</ref>, improved to support XOR constraints, and will not be detailed here.</p></div>
<div><head>B. Support Counting</head><p>The support counting loop of the architecture takes most of the execution time, given the finite memory bandwidth. The Fig. <ref type="figure">2</ref>. Overview of the accelerator architecture loop takes in transactions from the database, checks if the current candidate is present, and if so, increments a counter. Given a transaction bitvector and a candidate itemset bitvector, for the candidate to be present in the transaction, all bits set to 1 in the candidate have to be set to 1 in the transaction too. If we call the current candidate itemset to test c, and the current transaction from the database t, one way to implement this proposition with FPGA logic is</p><formula xml:id="formula_4">c ⊂ t ⇐⇒ t&amp; c = c.<label>(4)</label></formula><p>This proposition can be simplified, since all bits set to 1 are set to 0 in t. Thus for all items in c, they have to be absent from t for c to be present in t:</p><formula xml:id="formula_5">c ⊂ t ⇐⇒ t &amp; c = 0.<label>(5)</label></formula><p>Since this feature only uses simple logic gates and a counter increment, its impact on the area cost is very low.</p></div>
<div><head>C. Correspondence List Address Cache</head><p>Many dataset reduction techniques have been developed for pattern mining in order to exclude redundant or unnecessary operations. Several of them can be seen as preprocessing techniques to optimize the ensuing pattern mining, such as removing non-frequent items from the database, or grouping identical transactions together. Some others aim to optimize the mining of patterns using knowledge discovered during the pattern mining.</p><p>In the special case of a depth-first algorithm like ECLAT, if the set of transactions containing a frequent itemset is registered in the memory of the FPGA, it is guaranteed the next candidate itemset is a child of the itemset (when it is not a leaf of the tree), and its own set of transactions is contained in the registered set of transactions. By allocating in memory the addresses of transaction containing an itemset, the accelerator is able to scan a reduced portion of the database, as illustrated in Figure <ref type="figure" target="#fig_1">3</ref>. If the set of addresses cannot fit in the allocated memory, the accelerator scans the whole database.</p><p>This technique can only work if the dataset uses a frequency threshold sufficiently low to fit in the FPGA memory. If the accelerator is tasked to find itemsets present in at least 90% of a large database, the correspondence list would not fit in the FPGA. The pattern explosion implies that a regular itemset miner could spend the majority of its execution scanning for itemsets with very low support (sometimes less than thousands or hundred of transactions depending on the database). Our proposition is to speedup the computation of these itemsets with low support, but with support still superior to the frequency threshold, when the density of the dataset favors it.</p><p>If we allow to register only the set of transactions of several frequent itemsets, it is possible to store the histories of frequent itemsets at different depths in the tree. this reduces the number of transactions accessed in memory. In order to only keep track of set of transactions of itemsets that can be reused by future candidate itemsets, the addresses of transactions of an itemset is evicted from memory depending on its depth in the tree.</p></div>
<div><head>D. Parameters' Influence on the Accelerator</head><p>In order to analyze the theoretical performance of the accelerator, we introduce two parameters: DB SIZE, the number of transactions in the database, and N B BLOCK, the number of memory accesses to get a transaction. During the support counting, the accelerator processes chunks of N N B BLOCK bits wide data in a pipelined fashion. If the memory is able to feed the accelerator without bandwidth limitation, the pipeline can process a chunk every four cycles at 100MHz. The number of cycles needed to compute the support of an itemset is 4 × DB SIZE × N B BLOCK.</p><p>If we consider an example where the memory has to deliver chunks of size N /NB BLOCK = 128 bits, the internal logic of the FPGA can process 128/4×100M b/s = 400M B/s. Thus, the accelerator will be stalled by the memory if it is unable to reach this throughput. This is often the case in I/O bound applications such as data mining. A simple way to tackle this issue is to encode the transactions inside the memory, and decode it back to bit vectors once in the FPGA. The naive approach to store potentially long bit vectors can be a huge waste of space and bandwidth, especially with sparse datasets containing many zeroes.</p><p>Figure <ref type="figure">4</ref> shows the amount of resources allocated on the XC7Z020 SoC for different values of N . An accelerator with a fixed value N can process any database with an alphabet of size less or equal to N . At the moment only rather small alphabets can be processed because of the high usage of Look-Up Tables (LUT), as nearly all of the slices are allocated for an alphabet of size 128. For the same alphabet size, only half of the available RAM and register slices are used. The parameter N is thus linked to two limiting factors: the allocated logic and the memory bandwidth. It is however noteworthy that the FPGA used in our experiments is rather small and our approach will scale efficiently with larger FPGA devices.</p></div>
<div><head>V. EXPERIMENTS</head><p>The dataset used for the performance analysis of our accelerator is available publicly from <ref type="bibr" target="#b9">[10]</ref>. This dataset uses an alphabet of size 32. We impose N/N B BLOCK = 32 bits. The FPGA thus processes 100M B/s, which is close to the bandwidth between the memory and the FPGA. The dataset consists of around 13000 transactions, and the frequency threshold used is 1%. This fits very well the use case of a low-frequency support, and allows for our design to be tested with a wide range of correspondence list sizes.</p></div>
<div><head>A. Impact of Sampling on Execution Time</head><p>Figure <ref type="figure">5</ref> shows the effects of the sampling on the execution time. In this scenario, the accelerator can return any number of samples (no user bound), but the number of random XOR constraints is fixed at compilation. Each new constraint </p></div>
<div><head>B. Impact of Correspondence List Size</head><p>Figure <ref type="figure" target="#fig_3">6</ref> compares the execution time of the accelerator with and without a correspondence list. The correspondence list brings a very noticeable speedup with rather low amounts of memory allocated. Allocating memory to store 300 addresses (roughly twice the support threshold in this case) results in a speedup of 2.1. The maximum speedup corresponding to 3000 addresses reaches 4.7. Figure <ref type="figure" target="#fig_3">6</ref> also displays the amount of memory allocated in the FPGA for the tested values. The relation is not stricly linear because only fixed amounts of block RAM can be used. The correspondence list with a size of 3000 results in all the BRAM (140) being allocated. </p></div>
<div><head>C. Comparison Against Flexics</head><p>Table <ref type="table" target="#tab_0">I</ref> shows results taken from <ref type="bibr" target="#b0">[1]</ref>, where <software ContextAttributes="used">EFlexics</software> (the fastest implementation of <software ContextAttributes="used">Flexics</software>) is tasked to return 1000 samples. These results were obtained on an Intel Xeon CPU running at 3.2GHz and with 32Gb of RAM on the CP4IM dataset <ref type="bibr" target="#b10">[11]</ref>. We compare the execution of our accelerator running on the zc702 board when tasked to return a thousand samples to the software execution time, without allocating a correspondence table. Our accelerator achieves a speedup between 2 and 10, except for the kr-vs-kp dataset. The accelerator performs best with small alphabet sizes, as these problems require a lot less memory bandwidth.</p></div>
<div><head>VI. CONCLUSION</head><p>We proposed a first approach for performing pattern sampling on FPGA. This approach is promising: despite running on a modest FPGA clocked at 100 MHz, it can be up to an order of magnitude faster than a software version running on a server class Xeon CPU clocked at 3.2 GHz. We also proposed a dataset reduction technique applicable to depthfirst algorithms as ECLAT to improve execution time, at the cost of allocated memory on the FPGA.</p><p>The current approach is sequential: an exciting research direction is to parallelize the implementation in order to explore several branches of the search space simultaneously. Since itemsets access to the same database, the transactions can be used for the support counting of multiple itemsets. These two properties allow to divide the whole tree in subtrees that can be processed in parallel without requiring more communication between the FPGA and the memory.</p><p>This parallel extension of the proposed accelerator will allow to make good use of higher-end FPGA and reach throughputs compatible with real-time analysis on demanding streaming data. The current paper focused on the FPGA algorithm and its performance. In order to process actual streams, another important element is to have efficient communications between the RAM holding the data and the FPGA. In this regard, a solution is to compress the database in RAM, which will cost a small allocation of resources on the FPGA to decode the transactions, but will allow a much better use of the bus bandwidth.</p></div><figure xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Example of a depth-first tree for the alphabet {a, b, c, d} in ECLAT</figDesc><graphic coords="3,70.45,50.54,204.60,99.00" type="bitmap" /></figure>
<figure xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Example of dataset reduction using correspondence list</figDesc><graphic coords="6,37.08,50.54,287.40,130.80" type="bitmap" /></figure>
<figure xml:id="fig_2"><head>Fig. 4 .Fig. 5 .</head><label>45</label><figDesc>Fig. 4. Execution time wrt. correspondence list size</figDesc></figure>
<figure xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Execution time wrt. correspondence list size</figDesc></figure>
<figure type="table" xml:id="tab_0"><head>TABLE I TIME</head><label>I</label><figDesc>NEEDED (IN SECONDS) TO COMPUTE 1000 SAMPLES</figDesc><table><row><cell /><cell>EFlexics (CPU)</cell><cell>Our FPGA</cell></row><row><cell>german</cell><cell>25</cell><cell>11,7</cell></row><row><cell>heart</cell><cell>45</cell><cell>11,6</cell></row><row><cell>kr-vs-kp</cell><cell>9</cell><cell>12,7</cell></row><row><cell>primary</cell><cell>10</cell><cell>1,2</cell></row><row><cell>vote</cell><cell>19</cell><cell>5,8</cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Flexible constrained sampling with guarantees for pattern mining</title>
		<author>
			<persName><forename type="first">V</forename><surname>Dzyuba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Leeuwen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Raedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<date type="published" when="2017-03">Mar. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">New algorithms for fast discovery of association rules</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Int. Conf. on Knowledge Discovery and Data Mining (KDD)</title>
		<meeting>ACM Int. Conf. on Knowledge Discovery and Data Mining (KDD)</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="283" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast algorithms for mining association rules in large databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 20th International Conference on Very Large Data Bases (VLDB)</title>
		<meeting>20th International Conference on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="487" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient and versatile fpga acceleration of support counting for stream mining of sequences and frequent itemsets</title>
		<author>
			<persName><forename type="first">A</forename><surname>Prost-Boucle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pétrot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Leroy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Alemdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Reconfigurable Technol. and Syst. (TRETS)</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">21</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Accelerating intersection computation in frequent itemset mining with fpga</title>
		<author>
			<persName><forename type="first">S</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 10th Int. Conf. on High Perf. Comp. and Comm. (HPCC)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="659" to="665" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An fpga-based accelerator for frequent itemset mining</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Bakos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Reconfigurable Technol. Syst. (TRETS)</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="2" />
			<date type="published" when="2013-05">May 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Output Space Sampling for Graph Patterns</title>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Al</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Zaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2009-08">Aug. 2009</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="730" to="741" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Linear Space Direct Pattern Sampling Using Coupling from the Past</title>
		<author>
			<persName><forename type="first">M</forename><surname>Boley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Moens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gärtner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th ACM Int. Conf. on Knowledge Discovery and Data Mining (KDD)</title>
		<meeting>18th ACM Int. Conf. on Knowledge Discovery and Data Mining (KDD)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="69" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Distribution-Aware Sampling and Weighted Model Counting for SAT</title>
		<author>
			<persName><forename type="first">S</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Fremont</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1404.2984</idno>
		<imprint>
			<date type="published" when="2014-04">Apr. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">UCI machine learning repository</title>
		<author>
			<persName><forename type="first">D</forename><surname>Dheeru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Karra</forename><surname>Taniskidou</surname></persName>
		</author>
		<ptr target="http://archive.ics.uci.edu/ml" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Itemset mining: A constraint programming perspective</title>
		<author>
			<persName><forename type="first">T</forename><surname>Guns</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nijssen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">De</forename><surname>Raedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">12-13</biblScope>
			<biblScope unit="page" from="1951" to="1983" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>