<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Reuse of process-based models: automatic transformation into many programming languages and simulation platforms</title>
				<funder>
					<orgName type="full">INRAE Divisions AgroEcoSystem and NUM</orgName>
				</funder>
				<funder>
					<orgName type="full">INRAE Division AgroEcoSystem</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
				<date type="published" when="2020-10-09">09 October 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Cyrille</forename><forename type="middle">Ahmed</forename><surname>Midingoyi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">INRAE</orgName>
								<orgName type="laboratory">LEPSE</orgName>
								<orgName type="institution" key="instit1">Univ Montpellier</orgName>
								<orgName type="institution" key="instit2">Institut Agro</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">CIRAD</orgName>
								<orgName type="department" key="dep2">INRAE</orgName>
								<orgName type="laboratory">AGAP</orgName>
								<orgName type="institution" key="instit1">Univ Montpellier</orgName>
								<orgName type="institution" key="instit2">Institut Agro</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christophe</forename><surname>Pradal</surname></persName>
							<email>christophe.pradal@cirad.fr</email>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">CIRAD</orgName>
								<orgName type="department" key="dep2">INRAE</orgName>
								<orgName type="laboratory">AGAP</orgName>
								<orgName type="institution" key="instit1">Univ Montpellier</orgName>
								<orgName type="institution" key="instit2">Institut Agro</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Univ Montpellier</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ioannis</forename><forename type="middle">N</forename><surname>Athanasiadis</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Wageningen University</orgName>
								<address>
									<settlement>Wageningen</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marcello</forename><surname>Donatelli</surname></persName>
							<affiliation key="aff4">
								<orgName type="department">Research Centre for Agriculture and Environment</orgName>
								<orgName type="institution">CREA</orgName>
								<address>
									<settlement>Bologna</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Andreas</forename><surname>Enders</surname></persName>
							<affiliation key="aff5">
								<orgName type="department">Institute of Crop Science and Resource Conservation (INRES)</orgName>
								<orgName type="institution">University of Bonn</orgName>
								<address>
									<settlement>Bonn</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Davide</forename><surname>Fumagalli</surname></persName>
							<affiliation key="aff6">
								<orgName type="department" key="dep1">Institute for Environment and Sustainability</orgName>
								<orgName type="department" key="dep2">Joint Research Centre</orgName>
								<orgName type="institution">European Commission</orgName>
								<address>
									<settlement>Ispra</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Frédérick</forename><surname>Garcia</surname></persName>
							<affiliation key="aff12">
								<orgName type="department">MIAT</orgName>
								<orgName type="institution">INRAE</orgName>
								<address>
									<settlement>Castanet-Tolosan</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dean</forename><surname>Holzworth</surname></persName>
							<affiliation key="aff8">
								<orgName type="institution">CSIRO Agriculture and Food</orgName>
								<address>
									<settlement>Toowoomba</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gerrit</forename><surname>Hoogenboom</surname></persName>
							<affiliation key="aff9">
								<orgName type="department">Institute for Sustainable Food Systems</orgName>
								<orgName type="institution">University of Florida</orgName>
								<address>
									<settlement>Gainesville</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff11">
								<orgName type="institution">CSIRO Agriculture and Food</orgName>
								<address>
									<settlement>Brisbane</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Cheryl</forename><surname>Porter</surname></persName>
							<affiliation key="aff10">
								<orgName type="department">Agricultural &amp; Biological Engineering</orgName>
								<orgName type="institution">University of Florida</orgName>
								<address>
									<settlement>Gainesville</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Hélène</forename><surname>Raynal</surname></persName>
							<affiliation key="aff7">
								<orgName type="institution" key="instit1">AGIR</orgName>
								<orgName type="institution" key="instit2">INRAE</orgName>
								<address>
									<settlement>Castanet-Tolosan</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Thorburn</surname></persName>
							<affiliation key="aff11">
								<orgName type="institution">CSIRO Agriculture and Food</orgName>
								<address>
									<settlement>Brisbane</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Martre</surname></persName>
							<email>pierre.martre@inrae.fr</email>
							<affiliation key="aff0">
								<orgName type="department">INRAE</orgName>
								<orgName type="laboratory">LEPSE</orgName>
								<orgName type="institution" key="instit1">Univ Montpellier</orgName>
								<orgName type="institution" key="instit2">Institut Agro</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff13">
								<orgName type="department">l'Alimentation et</orgName>
								<orgName type="institution">Institut National de Recherche pour l'Agriculture</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Reuse of process-based models: automatic transformation into many programming languages and simulation platforms</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2020-10-09">09 October 2020</date>
						</imprint>
					</monogr>
					<idno type="MD5">5B5870EDF9F26688703A215BF95EF3F2</idno>
					<idno type="DOI">10.1093/insilicoplants/diaa007/5918454</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Source transformation</term>
					<term>model reuse</term>
					<term>transpiler</term>
					<term>software reuse</term>
					<term>crop model</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>The diversity of plant and crop process-based modeling platforms in terms of implementation language, software design, and architectural constraints limits the reusability of the model components outside the platform in which they were originally developed, making model reuse a persistent issue. To facilitate the intercomparison and improvement of process-based models and the exchange of model components, several groups in the field joined to create the Agricultural Model Exchange Initiative (AMEI). AMEI proposes a centralized framework for exchanging and reusing model components. It provides a modular and declarative approach to describe the specification of unit models and their composition. A model algorithm is associated with each model specification, which implements its mathematical behavior. This paper focuses on the expression of the model algorithm independently of the platform specificities, and how the model algorithm can be seamlessly integrated into different platforms. We define <software>CyML</software>, a <software ContextAttributes="used">Cython</software>-derived language with minimum specifications to implement model component algorithms. We also propose <software ContextAttributes="used">CyMLT</software>, an extensible source-to-source transformation system that transforms <software ContextAttributes="used">CyML</software> source code into different target languages such as Fortran, C#, C++, Java and Python, and into different programming paradigms.</p><p><software>CyMLT</software> is also able to generate model components to target modeling platforms such as <software ContextAttributes="used">DSSAT</software>, <software ContextAttributes="used">BioMA</software>, Record, SIMPLACE and <software ContextAttributes="used">OpenAlea</software>. We demonstrate our reuse approach with a simple unit model and the capacity to extend <software ContextAttributes="used">CyMLT</software> with other languages and platforms. The approach we present here will help to improve the reproducibility, exchange and reuse of process-based models.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1.">Introduction</head><p>Process-based crop models (PBM) are increasingly developed for a wide range of applications and research purposes. Even though there are key biophysical processes in PBM such as phenology, soil water balance, or biomass production, their modeling differs from one model to another according to the biological details, influenced by the availability of input data and final use of the model. The choice of modeling approaches to represent processes and combine them is also one of the main reasons which led to the development of multiple PBM to simulate the same crops <ref type="bibr" target="#b33">(Jones et al. 2017)</ref>.</p><p>They have often been written repeatedly in several different languages with different software architectures. For example, the WOFOST model is implemented in Fortran in the <software ContextAttributes="used">WOFOST Control Centre (WCC)</software> package, in Python in the Python Crop Simulation Environment framework, in Java in the Wageningen Integrated Systems Simulator framework (WISS), in C# in the Biophysical Models Application (<software ContextAttributes="used">BioMA</software>) framework, and in C++ in the Crop Growth Monitoring System (CGMS) (de <ref type="bibr" target="#b60">Wit et al. 2019;</ref><ref type="bibr" target="#b35">van Kraalingen et al. 2020)</ref>.</p><p>The diversity of PBM has motived the development of different initiatives that intend to compare their performance and improve them by integrating new scientific knowledge to target the next generation of crop models <ref type="bibr" target="#b53">(Rosenzweig et al. 2013;</ref><ref type="bibr" target="#b12">Bindi et al. 2015)</ref>. PBM intercomparison studies <ref type="bibr" target="#b46">(Palosuo et al. 2011;</ref><ref type="bibr" target="#b54">Rötter et al. 2011;</ref><ref type="bibr" target="#b3">Asseng et al. 2013;</ref><ref type="bibr" target="#b2">Aslam et al. 2017)</ref> have pointed out the variability in model outputs but often without quantifying the sources of uncertainty or analyzing the processes involved. These studies showed the potential and limits of PBM and highlighted the need to evaluate them at the process level, but also to exchange model parts (components) between models <ref type="bibr" target="#b19">(Donatelli et al. 2014;</ref><ref type="bibr" target="#b45">Muller and Martre 2019)</ref>. PBM are increasingly implemented as autonomous components describing each biophysical process. However, there is currently little exchange and reuse of PBM components between modeling groups despite theoretical and application interests <ref type="bibr">(Holzworth et al. 2014)</ref>. The main limitation comes from compatibility issues between PBM platforms (frameworks) resulting from differences in programming languages that are used and their specificities.</p><p>The modeling frameworks used in agricultural modelling depend on the programming language in which they have been implemented, the software design, and code conventions they use. For example, the crop modeling frameworks <software ContextAttributes="used">APSIM</software> Next Generation <ref type="bibr" target="#b27">(Holzworth et al. 2018)</ref> and <software ContextAttributes="used">BioMA</software> <ref type="bibr" target="#b18">(Donatelli et al. 2010</ref>) are based on component-oriented techniques and require models to be developed in C#. <software ContextAttributes="used">DSSAT</software> <ref type="bibr" target="#b32">(Jones et al. 2003;</ref><ref type="bibr" target="#b30">Hoogenboom et al. 2019)</ref> and <software ContextAttributes="used">STICS</software> <ref type="bibr" target="#b13">(Brisson et al. 1998)</ref> provide generic crop modules in Fortran with a procedural approach that can be specialized for different species. <software ContextAttributes="used">Simplace</software> <ref type="bibr" target="#b20">(Enders et al. 2010</ref>) uses the Java language, while Record <ref type="bibr" target="#b11">(Bergez et al. 2016)</ref> uses C++; both require that their components share a built-in interface. Therefore, model components can be reused in a given platform but their reuse in other platforms remains difficult.</p><p>Existing solutions that couple models written in different languages are rather technical (generation of Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 wrappers) or low level (reading and writing in files). We propose here an abstraction, a sharing language, and a transformation system, based on the scientific content of the model, i.e., its algorithms. Multilanguage and integrated modeling frameworks like <software ContextAttributes="used">OpenAlea</software> <ref type="bibr" target="#b49">(Pradal et al. 2008</ref><ref type="bibr" target="#b50">(Pradal et al. , 2015) )</ref> and yggdrasil <ref type="bibr" target="#b36">(Lang 2019</ref>) offer a language binding approach to provide third-party developers with a choice of languages <ref type="bibr" target="#b58">(Villa 2001;</ref><ref type="bibr" target="#b36">Lang 2019)</ref>. Therefore, they overcome the difficulty of implementing algorithms efficiently in high-level languages. However, they do not provide a solution to the reuse or exchange of models between frameworks. In these platforms, models are reused as black boxes and the integrated models, therefore, lack the required transparency. Moreover, this approach requires knowledge of the frameworks they integrate and the deployment of the core of each framework. Domain-specific programming languages that are agnostic to a specific programming language have also been proposed as a solution to the problem <ref type="bibr" target="#b5">(Athanasiadis and Villa 2013;</ref><ref type="bibr" target="#b59">Villa et al. 2017)</ref> aiming to support interoperability with rich semantics.</p><p>To facilitate PBM component exchange, several groups in the field have joined forces to create the Agricultural Model Exchange Initiative (AMEI; <ref type="bibr" target="#b42">Martre et al. 2018)</ref>. AMEI brings together some of the most widely used crop modelling and simulation platforms, including <software ContextAttributes="used">APSIM</software>, <software ContextAttributes="used">BioMA</software>, <software ContextAttributes="used">DSSAT</software>, <software ContextAttributes="used">OpenAlea</software>, RECORD, <software ContextAttributes="used">Simplace</software> and other crop models such as <software ContextAttributes="used">STICS</software> and SiriusQuality <ref type="bibr" target="#b41">(Martre et al. 2006)</ref> The vision of AMEI is to (i) increase capabilities and responsiveness to model developers' needs; (ii) use modular modelling to share knowledge and rapidly develop operational tools; <ref type="bibr">(iii)</ref> reuse model parts to leverage the expertise of third parties; (iv) renovate legacy code; and (v) realize the benefit of sharing and complementing different expertise.</p><p>Based on a declarative modeling approach <ref type="bibr" target="#b4">(Athanasiadis et al. 2011)</ref>, AMEI proposes a centralized framework (Crop2ML; <ref type="bibr" target="#b43">Midingoyi et al. 2020)</ref> to exchange and reuse model components. Crop2ML provides a meta-language based on shared concepts between crop simulation platforms to describe specifications of model components and compositions. A model algorithm describes the behavior of the component in terms of the sequence of inputs, successive rules or actions, conditions or a flow of instructions from inputs to outputs including mathematical expressions. A model algorithm is associated with each model specification. After a modeler has represented the specifications of its model, two relevant questions remain to be answered: <ref type="bibr" target="#b60">(1)</ref> How can a model algorithm be described independently of the platform specificities; and (2) How can it be seamlessly integrated into existing simulation platforms? Similar approaches have been used in the Systems Biology community where several domain-specific modeling standard languages including SBML, CellML, and NeuroML have been designed to exchange and store models (Autumn <ref type="bibr" target="#b7">Cuellar et al. 2006;</ref><ref type="bibr" target="#b25">Gleeson et al. 2010;</ref><ref type="bibr" target="#b31">Hucka et al. 2015)</ref>.</p><p>These XML-based languages provide specific elements to describe model structure and equations Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 using <software ContextAttributes="used">Mathematical Markup Language (MathML</software>; <ref type="bibr" target="#b6">Ausbrooks et al. 2003</ref>) that describes mathematical notations and captures both its structure and content. However, these languages are limited to specific formalisms (e.g. chemical reactions, differential equations) and cannot be easily extended to represent crop models in their full complexity and diversity. System Biology languages support model transformation from one standard to another (e.g. form CellML to SBML; <ref type="bibr" target="#b57">Schilstra et al. 2006)</ref> and from XML to executable code. In contrast, Crop2ML provides models as components that can be integrated into simulation platforms. Therefore, our design choice was to introduce a general programming language to represent complex control flow such as loops or conditions statements.</p><p>In this paper, we present <software ContextAttributes="created">CyML</software>, a <software ContextAttributes="created">Cython</software>-derived language <ref type="bibr" target="#b9">(Behnel et al., 2011)</ref> with minimum meta-specifications to implement algorithms of Crop2ML models. This language allows encoding the model algorithm independently of any crop modeling platform and implementation language. We also propose <software ContextAttributes="created">CyMLT</software>, a source-to-source transformation system. This one-to-many transpiler transforms <software ContextAttributes="created">CyML</software> source code into different target languages such as Fortran, C#, C++, Java and Python.</p><p><software ContextAttributes="created">CyMLT</software> is also able to directly generate components to target modeling platforms such as <software ContextAttributes="created">DSSAT</software>, <software ContextAttributes="created">BioMA</software>, Record, SIMPLACE and <software ContextAttributes="created">OpenAlea</software>. Differences between platforms are not only due to the languages used to implement models but also to the software architectural design choices and modeling conventions. For instance, model components in PMF (<software ContextAttributes="created">APSIM</software> next generation) and <software ContextAttributes="created">BioMA</software> are written in C# in both platforms but the reuse of PMF components in <software ContextAttributes="created">BioMA</software> (and vice versa) can only be done at the level of binaries, and, therefore, as black boxes. <software ContextAttributes="created">CyMLT</software> takes into account platform requirements to generate model components that are compliant with existing platforms. Source to source transformation is a well-established solution used to address software reuse issues <ref type="bibr" target="#b48">(Plaisted 2013;</ref><ref type="bibr" target="#b22">Fernique and Pradal 2017)</ref>. It transforms source code from a high-level language to another one. However, to the best of our knowledge, no solution exists that targets PBM component reuse using automated source-to-source transformation. In this paper we present this issue by focusing on code reuse and reproducibility to enhance collaboration between crop modelers and to facilitate model coding for non-programmers, while keeping the transparency of model constructs.</p><p>Different source-to-source transformation systems are available for different purposes, both commercial (e.g. <ref type="bibr" target="#b8">Baxter et al. 2004</ref>) and open source <ref type="bibr" target="#b51">(Quinlan and Liao 2011)</ref>. Some lessons can be learned from these approaches. Many source-to-source transformation systems take as input a subset of one language and transform it to a single target language with specific transformation purposes without showing their extensibility <ref type="bibr" target="#b0">(Akeret et al. 2015;</ref><ref type="bibr" target="#b16">Bysiek et al. 2017;</ref><ref type="bibr" target="#b44">Misse-chanabier et al. 2019)</ref>. Few one-to-many <ref type="bibr" target="#b48">(Plaisted, 2013;</ref><ref type="bibr" target="#b56">Schaub and Malloy, 2016)</ref> and many-to-many <ref type="bibr" target="#b8">(Baxter et al. 2004</ref>) solutions have been proposed. They usually define a subset of language features and are based on a common intermediate representation of the languages provided from their similarities. However, they do not consider transformation between different programming paradigms. For instance, to our Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 knowledge, there is no system that transpiles from a procedural algorithm to both a procedural and an object-oriented program. To avoid losing assumptions or domain knowledge such as code documentation or variable units, a PBM source-to source-transformation should also integrate domain specific knowledge to generate code that is easy to read, following developer guidelines specific to each language.</p><p>First, we present the design and implementation of <software>CyML</software> language and the one-to-many transformation workflow. Then we demonstrate the use of <software ContextAttributes="created">CyML</software> and for a simple model component, which simulates wheat shoot number and the extensibility of <software ContextAttributes="created">CyMLT</software> to new languages or simulation platforms. Finally, we discuss our results and present some perspectives. This paper is not intended to provide a full description of the language and its transformation but uses them to demonstrate that a model algorithm can be implemented once and be used to generate reusable and reproducible model components in different target languages and platforms. The source code (https://github.com/AgriculturalModelExchangeInitiative/Crop2ML) and full documentation (https://crop2ml.readthedocs.io/en/latest/) of Crop2ML are available on Github.</p></div>
<div><head n="2.">Methods</head></div>
<div><head n="2.1">Brief overview of Crop2ML</head></div>
<div><head n="2.2">Requirements and CyML design choices</head><p>We designed the <software>CyML</software> language to meet the following requirements.</p><p>(i) Keep compatibility with programming languages of crop simulation platforms. A model can be reused if it can be separated from its original platform and expressed using equivalent and explicit constructs available in all supported programming languages and platforms. Therefore, a sublanguage needs to be identified that is minimal enough to express biophysical processes in all platforms but expressive enough to capture the complexity of most models. The resulting code must be removed from the technical subtleties of the platform but it will still depend on the platform language. In fact, most of these languages are direct descendants of the C language from which they inherit some constructs. Thus, they provide some similarities such as statements, the sequencing controlled by loop and conditional constructs, and functions that foster program modularization <ref type="bibr" target="#b1">(Akin 2003)</ref>. This leads to the ability to define a common language based on their common features. This language must be chosen in such a way that all its constructs are mapped to the constructs of the target languages, thus producing a fully automated source to source transformation. It must also provide some mathematical standard functions that have their equivalents in the language of the modeling platforms.</p><p>(ii) Link model specification and model algorithm to keep domain knowledge. As the model specification language is separated from the language of the algorithms in Crop2ML, it is necessary to provide and link domain knowledge information, including the context or decisions underlying the algorithm and its implementation in the language. It is also important to reduce the coding role of modelers in the implementation of model algorithms so that they can focus on the scientific knowledge <ref type="bibr" target="#b15">(Brown et al. 2018)</ref>. Our hypothesis is that model reuse can be achieved if its algorithm is closely associated with its specification. Thereby model specification can be used to generate a function signature or domain class from the description of inputs and outputs. The specification must also allow pass through documentation within the translated source code, but also to validate model algorithms with the unit tests they incorporate.</p><p>(iii) Cover the domain of interest. The abstract language must be sufficient to implement a biophysical process. This means that it must include all relevant and minimal features such as data types, modularity, and structures to encode any model algorithm. For example, in order to encode a model algorithm based on a set of mathematical expressions, a simple pseudo-code described as a Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 sequence of assignment statements are suggested. Like the model specification, this language must be modular. Model algorithms must be self-contained and reusable within a composite model.</p><p>(iv) Have a gentle learning curve. An important impact of the language is its learning curve, which must be shallow and allow modelers to focus on the science of the model rather than on its implementation. Thus, <software>CyML</software> must enable an optimal model developer experience with a learning curve that does not intimidate new users. The algorithm language must be expressive and enable users to write efficient source code that is easily understandable with minimal syntax. It must also produce readable source code within the target simulation platforms. The translated program must be a standalone program that is independent of the transformation system.</p><p>(v) Validate correctness using unit tests. Given that <software>CyML</software> is built to serve as an intermediate representation of a set of languages, its validity is practically proved if all unit tests written in <software ContextAttributes="created">CyML</software> succeed in all languages after transformation. This involves testing the generated code either in a multilanguage runtime environment or in the runtime environment of each language to ensure that the language features are well defined and that their emulation in other languages is correct.</p><p>To satisfy the above requirements, we identify common patterns often used in crop modeling simulation platforms to implement model components. They result from the intersection of a set of minimal features of different languages used by the platforms (Figure <ref type="figure" target="#fig_1">1</ref>, left part). We used these features to propose a shared modelling language. An additional design choice is to use a subset of an existing language that can satisfy our requirements and provide the common selected features. Python was a good candidate language to fit our design considerations. It is an expressive and high-level programming language that allows writing short source code and has a gentler learning curve than C, C#, Java, or C++ <ref type="bibr" target="#b37">(Linge and Langtangen 2016)</ref>. However, its dynamic typing can make transformation into programming languages with static typing ambiguous. Therefore, we proposed to add an explicit type declaration to the Python language, which led us to choose <software ContextAttributes="created">Cython</software> <ref type="bibr" target="#b10">(Behnel et al. 2000)</ref>. <software ContextAttributes="created">Cython</software> is a high-level programming language that combines the power of Python and C function calling and types on variables and class attributes. It is compiled directly in efficient C code that improves runtime speed and allows it to interact with C, C++ and Fortran source code. However, not all <software ContextAttributes="created">Cython</software> syntax can be directly translated into all target languages. For instance, the yield statement and anonymous functions are not supported by Fortran. Therefore, we defined <software ContextAttributes="created">CyML</software> as a sub-set of <software ContextAttributes="created">Cython</software> to address the implementation of the model algorithm (Figure <ref type="figure" target="#fig_1">1</ref>, right part). <software ContextAttributes="created">CyML</software> does not cover some features such as class definition, nested functions, exceptions handling, anonymous function, reading and writing files. These features are handled by the platforms in their programing language.   </p></div>
<div><head n="2.3">CyML language</head><p><software>CyML</software> is designed as a subset of the <software ContextAttributes="created">Cython</software> language based on a language specialization approach. This involves removing undesirable syntactic or/and semantic features of <software ContextAttributes="created">Cython</software> that may not be easily transformed into many different languages or are not required to implement PBM algorithms.</p><p>The conformance to the subset of <software ContextAttributes="created">Cython</software> features is guaranteed through a semantic analysis. The main concepts supported by <software ContextAttributes="created">CyML</software> are represented in Figure <ref type="figure" target="#fig_2">2</ref>. Declaration: Basic types and collection. Unlike <software ContextAttributes="created">CyML</software>, <software ContextAttributes="created">Cython</software> does not require explicit type declarations. This means that in <software ContextAttributes="created">CyML</software>, all variables have to be declared before they are used and the declared type is immutable. A variable can be initialized during or after its declaration. In the case of model algorithm implementation, a variable can be either a model input, output or a local variable required for the implementation. Explicit static typing is enforced by the semantic analysis step illustrated in Figure <ref type="figure" target="#fig_2">2</ref>. <software ContextAttributes="created">CyML</software> supports basic types (e.g. integer, real, logical and string) and two sequence types (list and array) with dynamic or fixed length. Each element of a sequence must have the same type. Moreover, since time is an important variable in the defintion of discrete-time process, <software ContextAttributes="created">CyML</software> provides datetime types in terms of year, month, day, hour, minute and second. <software ContextAttributes="created">CyML</software> suppports commonly used binary (numerical and boolean), unary and comparison operators, as well as casting operators for basic types and sequence operators such as length or sum.</p></div>
<div><head>Statements.</head><p>Statements can be either an assignment, an expression or a control structure. An assignment assigns a variable to a mathematical expression, another variable or a value using an assignment operator (e.g. -=‖). An assignment statement can, therefore, express the relationships between model inputs-outputs when those are described only by simple equations. An expression is commonly defined as a construct made up variable, operator, or function call that can be evaluated to a value. In <software>CyML</software>, expression is distinguished from assignment by the fact that, in the case of assignment construct, the evaluation result of an expression is assigned to a variable. An expression can contain standard mathematical functions such as exponential, maximum, minimum, and power functions. Unlike assignment, expressions have no assignment operator. They are built-in functions called to perform an operation (e.g. collection operations such as adding or removing an element in a sequence). <software ContextAttributes="created">CyML</software> supports structured control flow statements that can be nested. Control flow statements include conditional branching (if, elseif, and else) and loops (for-in-range, for-each, iterating over several collections, and while) statement. </p></div>
<div><head>Module and package.</head><p>A module is a file containing a set of functions that can be reused in models and functions. A package contains a set of modules and models in a set of files. These concepts allow external dependencies to be managed. </p></div>
<div><head n="2.4">CyMLT design</head><p>The <software ContextAttributes="created">CyMLT</software> architecture is composed of two main parts: the front-end and the back-end (Figure <ref type="figure" target="#fig_5">3</ref>). The <software ContextAttributes="created">Cython</software> parser provides a lexical and syntactic analysis of the source code. It detects syntactic errors and generates an Abstract Syntax Tree (AST). The AST is a data structure representing the syntactic structure of the source code as a tree where the nodes represent the syntactic components (e.g. FunctionDefinition, Assignment, If-Block…) of the grammar. Figure <ref type="figure" target="#fig_9">4</ref> shows an example of AST generated from a square function. The design choice of <software ContextAttributes="created">CyML</software> relies on the legacy <software ContextAttributes="created">Cython</software> parser. This parser uses all the syntactic components of <software ContextAttributes="created">Cython</software> instead of a restricted grammar. To restrict <software ContextAttributes="created">Cython</software> grammar, the generated Cython AST is processed to ensure that it incorporates only syntactic components defined in <software ContextAttributes="created">CyML</software>.</p><p>The AST Transformation transforms the generated AST to a self-contained representation of the source code called Abstract Semantic Graph (ASG), which is independent of the source language.</p><p>The Semantic Analysis operates during the AST transformation to perform semantic checks from the AST. It consists of various checks such as type consistency, declaration of variables before their use, or consistency of elements in a list. This analysis checks that the input and output datatypes in model specifications are well defined in relation to the model algorithm. The semantic analysis generates error messages if the verification fails. Note that, unlike the AST, each node of the ASG is labeled with at least its type and its pseudo-type (Figure <ref type="figure" target="#fig_9">4c</ref>). The pseudo-type is the expected type of a node and strengthens code generation reducing the number of ASG traversals. For example, in Figure <ref type="figure" target="#fig_9">4c</ref> a node of type -Function‖ follows -Module node‖ and has a pseudo-type <ref type="bibr">[-Function‖, -int‖, -int‖]</ref>. This pseudo-type corresponds to the function signature, meaning that this function takes as input one argument of type -int‖ and returns one value of type -int‖. Note also that, unlike the AST, the type of internal nodes of the ASG may be different from non-terminal symbols of the grammar. Another type of node is built that preserves the intention in the source code instead of the code structure. For example, in Figure <ref type="figure" target="#fig_9">4b</ref> the binary operator node -<software ContextAttributes="created">PowNode‖</software> is transformed in Figure <ref type="figure" target="#fig_9">4c</ref>  Platform Generation. A Language Generation emits the source code in a specific language with a specific programming paradigm. This source code does not contain any simulation platform features.</p><p>A Platform Generation emits a model component based on the requirements of a platform such as its implementation language, software design and code conventions.  Finally, the Notebook Generator transforms generated source code or model components into Jupyter notebook <ref type="bibr" target="#b34">(Kluyver et al. 2016)</ref> to interactively test and validate the transformation.</p></div>
<div><head n="2.5">CyMLT implementation</head><p><software ContextAttributes="created">CyMLT</software> proposes a unique approach to transform an ASG into many programming languages. It is implemented around the main classes shown in Figure <ref type="figure" target="#fig_11">5</ref>. A set of classes (suffixed by Generator) generates the code for each language and platform. It means that a sub-class of <software ContextAttributes="created">PlatformGenerator</software> and of <software ContextAttributes="created">LanguageGenerator</software> class have been implemented for each supported platform and language. A <software ContextAttributes="created">PlatformGenerator</software> class inherits attributes and properties of the <software ContextAttributes="created">LanguageGenerator</software> class related to the language used by the platform. For example, as <software ContextAttributes="created">BioMA</software> uses the C# language, the <software ContextAttributes="created">BioMAGenerator</software> class (i.e. the class that generates <software ContextAttributes="created">BioMA</software> components) inherits the CsharpGenerator class that generates the source code in C#. Each class contains a visitor method for each ASG node type. Each visitor method name is composed of -visit_‖ followed by -the type of the node‖. A visitor method emits code fragments. Each <software ContextAttributes="created">LanguageGenerator</software> sub-classes provide the same visitor method names given that the same ASG is used. A <software ContextAttributes="created">LanguageGenerator</software> class also inherits two classes: <software ContextAttributes="created">CodeGenerator</software> and <software ContextAttributes="created">LanguageRule</software>. The <software ContextAttributes="created">CodeGenerator</software> class contains the factorized methods shared by all <software ContextAttributes="created">LanguageGenerator</software> classes including the method used for code emitting and code formatting. This class inherits the super class of the transformation process called <software ContextAttributes="created">NodeVisitor</software>.</p><p><software ContextAttributes="created">CyMLT</software> implements the Visitor design pattern <ref type="bibr" target="#b23">(Gamma et al. 1995)</ref> to avoid a procedural implementation approach. <software ContextAttributes="created">NodeVisitor</software> contains a dispatch method that enables recursive traversal through the nodes. During traversal, the appropriate visitor method corresponding to the type of the current node is called in <software ContextAttributes="created">LanguageGenerator</software> or <software ContextAttributes="created">PlatformGenerator</software> and the associated code fragment is emitted. Before emitting the code fragment, some nodes undergo a transformation from the <software ContextAttributes="created">LanguageRule</software> class. This class is implemented for each language as a mapping where keys corresponds to the different methods, datatypes, and operators of <software ContextAttributes="created">CyML</software>, and values are their emulation in target languages provided from their standard libraries (Supporting Information Table <ref type="table" target="#tab_2">S1</ref> to S5). Given that the <software ContextAttributes="created">CyML</software> language is similar to Python, it is straightforward to yield Python <software ContextAttributes="created">code</software> through one ASG traversal. This is not the case for all target languages, which require more traversals to support specific features provided from the analysis of the ASG. For example, a first traversal could detect that it is necessary to declare other variables in the generated code. These additional operations have been implemented in the Adapter class containing some methods to traverse the ASG and, where the conditions have been defined, to retrieve the new features required in <software ContextAttributes="created">LanguageGenerator</software>. Likewise, the Model object generated by the model parser is used in <software ContextAttributes="created">LanguageGenerator</software> to generate the model interface with accessor and mutator methods for objectoriented languages, or to add additional semantics to variables based on platform conventions. This separation of model specification from model algorithm enhances <software ContextAttributes="created">CyMLT</software> to transform a model algorithm from a procedural approach to an object-oriented approach with different software designs.  </p></div>
<div><head n="3.">Results</head></div>
<div><head n="3.1">Model algorithm implemented in CyML</head><p>The shootnumber model is implemented in <software>CyML</software> as a function that includes all the meta information provided by the model specifications (Supporting Information Listing S2). The model documentation is generated from the model specification and is shown in red. It contains the name of the model, its version, its time step (in days) and other descriptions such as the authors' names and the reference for the model.</p><p>The algorithm shootnumber unit model requires an external function, Fibonacci, which is implemented outside of the model algorithm (Supporting Information Listing S2, Line 35) to make the code readable and shorter. This mathematical function allows to compute the shoot production from the number of emerged leaves on shoots (Supporting Information Listing S2, Line 22). We implement the code using conditional (if, line 26) and loop (for, line 29) control structures. Table <ref type="table" target="#tab_2">1</ref> gives the meaning of <software ContextAttributes="created">CyML</software> language built-in functions that are used to implement the shoot number model. Therefore, it handles different programming paradigms such as procedural, functional, and objectoriented programming by associating model specifications to the transformation workflow.</p></div>
<div><head>Structure of generated source code.</head><p>Although <software ContextAttributes="created">CyML</software> provides a procedural mechanism to implement model algorithm, the programming languages supported by <software ContextAttributes="created">CyMLT</software> can be classified in procedural and object-oriented programming paradigms. Some languages are designed to support only the object-oriented paradigm (C# and Java). Fortran and C are procedural languages even though they can -mimic‖ some object-oriented features to support object-oriented programming style <ref type="bibr" target="#b17">(Cary et al. 1997)</ref>. Python and C++ support both object-oriented and procedural paradigms. <software ContextAttributes="created">CyMLT</software> uses procedural paradigm for Python and object-oriented for C++, as these are the most often used approaches in these languages. However, <software ContextAttributes="created">CyMLT</software> can also be extended to generate models in Python with an object-oriented approach and in C++ with a procedural approach. Listing 3. Update output variables in Java. s corresponds to an instance of current state variable.</p></div>
<div><head>Data type and variable declaration.</head><p>In addition to the programming paradigms, languages supported by <software ContextAttributes="created">CyMLT</software> can be classified by their type system, in particular their type expression (explicit or implicit). This can affect the quality of the generated code. Although some languages (e.g. C# and C++) allow both implicit and explicit type expression, we chose to provide explicit typing. Basic types (integer, logical, character, and real) are built-in data types in all languages. However, other more complex types like datetime or sequence are supported but require external or standard libraries. Moreover, various libraries exist to handle the same data structure. <software ContextAttributes="created">CyMLT</software>'s datatypes map appropriately to target languages by using their standard library (Supporting Information Table <ref type="table" target="#tab_2">S1</ref>).</p><p>Some compromises have been made for the transformation of complex types. <software>CyML</software> arrays are modeled on a standard Python list. However, the size of list datatype variables is not fixed. We propose to use the Numpy array in the next version of <software ContextAttributes="created">CyMLT</software>. In Fortran, <software ContextAttributes="created">CyMLT</software> generates allocable arrays to map to <software ContextAttributes="created">CyML</software> list data types and provides some functions to handle it. These functions are extracted from <software ContextAttributes="created">CyMLT</software> library and integrated into the generated code to make it independent of the library of transformation. In C++, datetime type handling is not easy. It is converted into a string, which could be split for processing. <software ContextAttributes="created">CyML</software> arrays without a specified size in the function parameter are mapped to C++ arrays using templates (Listing 6, line 1). In Java, there are many standard Time APIs. (e.g., Date, LocalDateTime) depending on the version of Java. We have chosen to use the Date Library in Java and the DateTime Library in C#.</p><p>Type and intent preservation. Most of the target languages provide built-in methods matching with <software>CyML</software> built-in functions. However, there may be some differences between their name or return types. This is considered in the generated source code. As an example, consider the statement at  Some languages like Java, C++ and C# manage variable scope differently and this variability is handled by <software ContextAttributes="created">CyML</software>.</p><p>Consider the transformation of a simple <software>CyML</software> function that calculates the sum of elements of an array x with undefined size (Listing 6). The generated code in Fortran requires the declaration of new variable i_cyml to map the For-loop construct. However, the generation of a new variable in Java, C++ and C# preserves the scope of the variable i. The scope of the iteration index on an array variable in a For-loop construct is limited to the loop scope, whereas it is extended to all the functions in <software ContextAttributes="created">CyML</software> and Python. Assuming that in the original code this iteration index is reused after the loop, it will generate a compilation error in the target languages if the transformation did not handle this scoping issue by declaring another variable.</p><p>Listing 6. <software>CyML</software> code of a function that computes the sum of the elements of a list transformed using <software ContextAttributes="created">CyMLT</software> in Python, C++, C#, Java, and Fortran.</p></div>
<div><head>Transformation to simulation platforms</head><p>The <software>CyMLT</software> allows searching and extracting state variables from a model specification to perform code generation according to each platform.</p><p>In <software>DSSAT</software> and <software ContextAttributes="created">OpenAlea</software>, a model algorithm is implemented as a stateless functional component (declarative paradigm). The Fortran code generated by <software ContextAttributes="created">CyMLT</software> is compatible with <software ContextAttributes="created">DSSAT</software>. In this platform, the calculation of rates of change and the integration of state processes are sometimes separated with the use of a control variable. In <software ContextAttributes="created">CyML</software>, we introduce two variables that define the previous and current value of a state variable that avoids a misuse of the state variable. Although</p><p><software ContextAttributes="created">OpenAlea</software> offers capabilities to benefit of oriented-object features of Python, <software ContextAttributes="created">OpenAlea</software> components can be defined as pure Python functions, already generated by <software ContextAttributes="created">CyMLT</software>. However, model specifications need to be transformed into an <software ContextAttributes="created">OpenAlea</software> component specification for unit and composite node <ref type="bibr" target="#b49">(Pradal et al. 2008)</ref>. </p></div>
<div><head n="3.3">Extensibility</head><p>The number of languages and platforms that <software>CyMLT</software> supports can be extended due to its modular structure. The explicit separation between the production of the annotated ASG and its transformation into a readable source code of the target languages and platforms provides a great flexibility to add new target languages. The addition of a new language requires only a mapping of this intermediate representation into a set of compatible instructions based on the standard library of the language. The generated code must be independent of the transformer, clear, and easy to read while preserving the knowledge expressed in the original code. We present the steps for the extension of <software ContextAttributes="created">CYMLT</software> with R language (R Core Team 2017) and the Plant Modeling Framework (PMF). Listing 11. Operators mapping.</p><p>Adapting Standard Functions. <software>CyML</software> defines three standard libraries (i.e. math, system, and io) to provide mathematical, system, and file management functions in the different languages. A mapping is needed to link these functions to native R ones for each library. Some functions are identical between <software ContextAttributes="created">CyML</software> and R, like min or max. Others require a transformation to another type of node. It is useful for model developers to observe the generated ASG of each <software ContextAttributes="created">CyML</software> construct in order to define the equivalent of the construct. For example, the construct of a modulo binary operation in <software ContextAttributes="created">CyML</software> is a standard_call node in the ASG whose namespace is system, the function is modulo and the arguments are the two operands. This node is transformed into a binary_op node (binary operation)</p><p>with the function -translateModulo‖ (Listing 12). The new node is visited to produce R fragment code.</p><p>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</p><p>Listing 12. Standard functions mapping.</p><p>Standard methods mapping. Standard methods are functions applied to a particular data type of <software>CyML</software> language (Listing 13). Thus, a set of methods is provided for each <software ContextAttributes="created">CyML</software> datatype. Their equivalents in R language are defined using the same mapping mechanism used for standard functions. In Listing 13 at Line 9 the append method applied to a list is transformed to an assignment node whose value is a function c that takes as arguments the name of the variable of type list (receiver) and the argument of the append method (args). The definition of these rules limits the use of conditional statements in the implementation of the visit methods and facilitates the extension of <software ContextAttributes="created">CyMLT</software>.</p><p>Listing 13. Standard methods mapping.</p><p>Implementation of a R <software>code</software> generator. The <software ContextAttributes="created">RGenerator</software> class inherits the RRules class. It implements a family of visit methods like visit_assignment, visit_bool related to all types of nodes provided by the ASG. These methods emit fragments of code, which will be joined to produce a formatted source code in R. The properties that enable write and format functions for these fragments are implemented in a class named <software ContextAttributes="created">CodeGenerator</software> inherited by <software ContextAttributes="created">RGenerator</software>. Additionally,</p><p><software>CodeGenerator</software> abstracts the common behavior of these languages by providing other properties and visit methods common to all the target languages. Some methods are redefined in the language generator when it has particular features. The developer of the R <software ContextAttributes="created">code</software> generator implemented the different visit methods without bothering with the dispatching mechanism provided by the <software ContextAttributes="created">NodeVisitor</software> class. A visit() method is called for all composite child nodes while a write() method is invoked for the terminal or single node to emit the code fragment. For example, a boolean value is a terminal node. Thus, the visit_bool method allowing generation of the corresponding boolean value in R will only consist in uppercase <software ContextAttributes="created">CyML</software> logical value (Listing 14).</p><p>Listing 14. Implementation of logical value transformation.</p><p>The assignment node is a composite node that contains a target node and a value node. These two nodes could be a composite node. So, they will all be visited by the visit_assignment() method (Listing 15).</p><p>Listing 15. Implementation of assignment transformation.</p><p>All target language generators share the principle of implementing a visitor method for standard functions or standard methods call nodes, and, it is, therefore, implemented in the <software>CodeGenerator</software> class. The properties of the node are used to access to the function equivalent in the dictionary of functions in the transformation rules class.</p><p>Listing 16 shows the implementation of the standard function call node where its properties such as namespace and function are used to access the equivalent function.</p><p>Listing 16. Implementation of standard function call. This implementation approach is followed for all types of nodes and could be gradually done according to the expected R constructs. Given that it has several possibilities to implement an algorithm, it is the responsibility of the extension developer to provide the corresponding semantic for each particular node of the ASG and to validate the transformation with unit tests.</p><p>Supporting a new simulation platform: <software ContextAttributes="created">APSIM</software>-PMF. <software ContextAttributes="created">APSIM</software> <ref type="bibr">(Holzworth et al. 2014</ref>) is one of the most widely used PBM platforms for simulating the performance of a wide range of cropping systems. It has undergone a major evolution by providing the Plant Modelling Framework (PMF; <ref type="bibr" target="#b14">Brown et al. 2014)</ref>. PMF is used to build models that represent plant components of a crop composed by identical plants. It is based on the structure of a generic plant and a wide range of processes involved in plant growth and development. However, the composition and parametrization to build a particular crop model is not specified and is left to model developers. PMF, therefore, allows great flexibility in its approach for implementing biophysical processes by separating model set up and assembly. The PMF concepts and processes are implemented as generic classes at different organizational levels <ref type="bibr" target="#b14">(Brown et al. 2014)</ref>. </p></div>
<div><head>The extension of</head></div>
<div><head n="4.">Discussion</head><p>The <software>CyML</software> language provides a relatively simple structure with few specifications that can express the algorithm of a biophysical process involved in crop growth and development. The real interest of this language is to provide a common method to describe a process with the capacity to be integrated automatically in various platforms. <software ContextAttributes="created">CyMLT</software> provides export capabilities in many languages For crop modelers, learning a new language with its own learning curve adds a level of complexity to an existing complex landscape of languages and tools. We designed <software ContextAttributes="created">CyML</software> to minimize this added complexity by choosing a language that is very close to existing languages. The main source of complexity is in the model specification. The modeler has to specify the type of inputs and outputs, the documentation and unit tests. While this increases the complexity of the design of a new model, it provides an explicit and rigorous specification and enhances the transparency of the model and its reproducibility and reusability in different contexts. A transformation system embeds platform specificities to automatically generate model components conform to specific platforms. This makes the complexity of component integration in different platforms identical with a wide availability.</p><p>Several approaches and solutions exist to transform source code from one language to many higherlevel programming languages <ref type="bibr" target="#b8">(Baxter et al. 2004;</ref><ref type="bibr" target="#b48">Plaisted 2013;</ref><ref type="bibr" target="#b56">Schaub and Malloy 2016)</ref>. They demonstrate the usefulness of source-to-source transformation systems in the development of reusable software libraries. For instance, De Paolis and Bourdot (2018) allow for the implementation of motion controllers of virtual humans, which are re-used in multiple game engines. Their system is based on <software ContextAttributes="created">Haxe</software>, a language that offers the capability to transform <software ContextAttributes="created">Haxe</software> code into many programming languages. However, like most available code transformation systems, the generated code depends on the transformation system. Likewise, <software ContextAttributes="created">Cython</software> generates code into the C and C++ languages that have a high performance but the generated code has a low readability, therefore, making it difficult to understand and to maintain. To our knowledge, no solution exists to transform PBM algorithms in different languages considering the specificities of different modeling platforms. This transformation is useful in the sense that model components are not just code but embed scientific knowledge that should be preserved. In this work, we also propose a system that includes algorithm error checking with explicit error messages to guide developers. <software ContextAttributes="created">CyML</software> addresses several issues encountered in current PBM frameworks, namely:</p><p>-reproducibility: a crop model or algorithm can be written once and automatically made available in different languages and platforms;</p><p>-reusability: a model can be reused and composed with other models of a specific platform;</p><p>-transparency: model algorithms are implemented using a common approach regardless of the crop simulation platform, and maintain the biophysical process knowledge.</p><p>Our approach and strategy should greatly reduce the implementation errors and improve model reproducibility. However, neither the definition of a language nor its transformation is approached without certain constraints, essentially due to the tradeoffs between generality and abstraction. </p></div>
<div><head n="4.1">CyML transformation challenges</head><p>We provide a new language with a transformation system to produce code correctness. However, some inconsistencies or complexities could appear depending on the target language. First, the current version of <software>CyML</software> does not handle the type overflow. It means that errors related to overflow could not be detected at the <software ContextAttributes="created">CyML</software> system level. For example, the generation of the Fibonacci recursive function in Python by just removing declaration types could lead to the crash of the system due to the Python recursion limit, whereas the generated code will not produce any error in Java but the result will rapidly overflow. A method to detect overflow can be implemented to avoid this type of error at run-time level. Moreover, <software ContextAttributes="created">CyML</software> can be extended to support 64-bit C double type. Second, <software ContextAttributes="created">CyML</software> provides primitive types whose equivalence in some platforms are objects with some properties. This means that coding an existing model algorithm in <software ContextAttributes="created">CyML</software> could require an additional <software ContextAttributes="created">CyML</software> external function to emulate the properties of these objects. Third, <software ContextAttributes="created">CyML</software> has some limitations with data type conversion. For example, Datetime type is not supported in Fortran or C++. In this case, <software ContextAttributes="created">CyML</software> converts it into strings. However, the translator could be extended to depend on specific libraries used by simulation platforms to perform the transformation. Finally, some platforms are close to the philosophy of their underlying language (e.g. <software ContextAttributes="created">DSSAT</software>, <software ContextAttributes="created">BioMA</software>, <software ContextAttributes="created">OpenAlea</software>) whereas others extend their language with a high-level specificity (Record, <software ContextAttributes="created">Simplace</software>) that requires a complex transformation.</p></div>
<div><head n="4.2">Lower the barrier of crop simulation platforms</head><p>The main barrier to exchange and reuse of model components between simulation platforms is the specificities embedded in the algorithm implementation. <software>CyML</software> intends to lower the barrier of platform specificities. Our analysis of several platforms showed that each platform adopts a standard to implement model algorithms that does not vary from one implementation to another. The knowledge of platform requirements offers the possibility to integrate them into <software ContextAttributes="created">CyMLT</software> in order to make their components available to many modeling platforms. We did not conduct a performance analysis but the cost of implementation is reduced by an order of magnitude compared to the time used to manually re-encode the same model into each platform without considering the inherent errors added during the process. <software ContextAttributes="created">CyML</software> supports not only the transformation of the algorithm of unit models, but it also provides the evaluation of composite models by calling in sequential order models that are encapsulated into it. It also proposes a way to produce unit tests for each unit model algorithm in different languages based on the specifications of the inputs, outputs and parameter values. It checks the validity of the generated source code ensuring that all transformation results give the same results.</p><p>It should be noted that <software>CyML</software> adds unit test functionality to platforms that do not use test-driven development.</p></div>
<div><head n="4.3">CyML for model reuse and reproducibility</head><p><software>CyML</software> implements PBM components with a functional and procedural approach. A component describing a biophysical process (e.g. phenology, soil water balance, photosynthesis) can be decomposed into independent components, which can be implemented and composed in <software ContextAttributes="created">CyML</software>.</p><p>Components implemented at a high granularity embed more scientific knowledge, but the component becomes less reusable. The implementation of a component into small functions (unit models) enhances its readability, reduces the distance between its expression as equations or mathematical expressions and its implementation, and reduces its maintenance cost. <software>CyML</software> is designed to tackle the reproducibility of PBM components. Although PBM are described in scientific publications and their code are increasingly publicly accessible, the reproducibility of the results remains a fundamental issue. Their implementation requires a procedural or functional language that is shared between simulation platforms to ensure their reproducibility. It is, therefore, useful to propose code in the language and that follow the specifications of the target platforms. The automatic transformation of model algorithms into different languages and simulation platforms is essential for interoperability and code reuse. <software ContextAttributes="used">CyML</software> users can implement a model in <software ContextAttributes="used">CyML</software> and transform the algorithms into various targets by using <software ContextAttributes="used">CyMLT</software>. Hence, <software ContextAttributes="used">CyML</software> aims at promoting PBM re-usability and interoperability through a transformation system that parses model specifications and knowledge needed to transform algorithms.</p></div>
<div><head n="4.4">Scope of CyML language</head><p><software>CyML</software> is a subset of the <software ContextAttributes="used">Cython</software> language. Thus, it does not include many features found in generalpurpose programming languages. This choice of language limitation has its strengths and weaknesses.</p><p>The method presented herein differs from existing model interchange platforms in that it generates source code with different programming paradigms and it associates model specifications to algorithms to enhance code analysis. It allows a common implementation of the dynamics of biophysical processes by removing the specificities of the languages and platforms. It improves the readability of the code since the structure of the code and the characteristics of languages are shared by modeling platforms. It ensures the mapping of the abstract representation to other languages or platforms. Indeed, this language limitation reduces ambiguity in the language transformation since the base language (<software>Cython</software>) has some features that cannot be transformed into some target languages.</p><p>With <software ContextAttributes="used">CyML</software>, different processes provided by different platforms can be represented and composed regardless of the platforms, which enables to define a new white-box component reusable by other platforms. <software ContextAttributes="used">CyMLT</software> provides a reuse approach that is opposite to a black-box approach where the composition of model components is bound to the execution platform targeted by its modules <ref type="bibr" target="#b21">(Van Evert et al. 2005)</ref>. <software ContextAttributes="used">CyML</software> does not interact with the simulation paradigms of the platforms. Its sole concern is to represent and transform the process models. Its evaluation capabilities are only used to check the correctness of the transformation. Moreover, <software ContextAttributes="used">CyML</software> does not provide a formalism to link model components with data to build a modeling solution. Thus, the processes to read inputs, parameters values and write output values in a file is separated from the algorithm implementation given that it reduces reusability.</p><p>Although <software>CyML</software> focuses on the implementation and reuse of biophysical models, it could be used in general purpose. Thus, any code that can be implemented with <software ContextAttributes="used">CyML</software> features can be transformed into different languages without associating specifications files.</p></div>
<div><head n="4.5">Toward a standard language</head><p>The development of <software ContextAttributes="used">CyML</software> and its transformation system addresses the need of the plant and crop modeling community to enhance research collaboration by improving the capacity to exchange and reuse PBM components. The theoretical interest to provide a common approach to implement model response has been demonstrated <ref type="bibr">(Holzworth et al. 2014)</ref>. However, despite the success of simulation platforms around which different communities are built, and some proposal of declarative language implementation, the lack of a shared standard limits model reusability. This issue limits the performance of the activity of PBM intercomparison and improvement. The availability of <software ContextAttributes="used">CyMLT</software> through AMEI will allow building a large community around this system and can make <software ContextAttributes="used">CyML</software> a standard language providing a means to seamlessly compare independent biophysical processes or promote alternatives approaches.</p></div>
<div><head n="4.6">Future developments</head><p>Several  </p></div><figure xml:id="fig_0"><head /><label /><figDesc>Crop2ML has been developed to offer to the crop modeling community a common framework for crop model component development, exchange, and reuse. It provides a model component specification language based on XML meta-language. It consists of unified concepts and elements allowing to describe a biophysical process regardless of the simulation platform. A Crop2ML model is an abstract model that may be either a unit model with fine granularity or a composite model represented as a graph of unit models connected by their inputs and outputs to manage model complexity. Crop2ML separates model specification from model algorithm. A model specification contains formal descriptions of the model, the inputs, outputs, state variable initializations, auxiliary functions and a set of parameters and unit tests. Thus, it allows for checking that a model reproduces the expected outputs values with a given precision. It supports multiple tests associated to one or multiple set of parameters' values. However, baseline parameter sweeps are not supported due to limited support in various languages and unit test frameworks. The specification also contains the algorithm written in CyML and any auxiliary functions called from the model algorithms or in other functions. They reduce code length and, therefore, improve readability of model algorithm by promoting reuse and increasing abstraction. Auxiliary functions include mathematical functions such as interpolation, and lower and upper bound functions.All model units and composite models are then transformed into different languages or simulation platforms to be incorporated into modelling platforms.</figDesc></figure>
<figure xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. From the intersection of a set of languages features to a definition of an abstract language CyML, defined as a subset of Cython. Lang i corresponds to a minimal language supported by a crop simulation platform -i‖. The number of circles (n) in the left corresponds to the number of platforms.</figDesc><graphic coords="9,129.30,278.43,336.69,218.00" type="bitmap" /></figure>
<figure xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Main concepts supported by the CyML language. Black diamonds indicate composition (-contains‖) relationships and white diamonds indicate a specialization (-is-a‖).</figDesc></figure>
<figure xml:id="fig_3"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc></figure>
<figure xml:id="fig_4"><head>Function.</head><label /><figDesc>CyML uses the definition of a Python function to code the model algorithm and to represent external functions with arguments with explicit data types. A function is composed of a set of statements in its body grouped under a def statement with a signature consisting of the name of the function, their inputs arguments and return values. A function may call other functions that can be provided by an import mechanism to ensure modularity. CyML also supports recursion which means that a function can call itself in its definition. Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc></figure>
<figure xml:id="fig_5"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Design architecture of the one-to-many CyML transformer (CyMLT). It takes as input a model unit algorithm implemented in CyML with associated model specifications and applies a transformation workflow to produce crop model components or source code in different languages for different platforms.</figDesc><graphic coords="11,157.93,143.32,279.45,339.58" type="bitmap" /></figure>
<figure xml:id="fig_6"><head /><label /><figDesc>The front-end consists of a Model Parser, a Cython Parser, and a Semantic Analysis component.The Model Parser checks the model specification based on the Crop2ML grammar and generates a logical object allowing access and manipulation of the model. Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc></figure>
<figure xml:id="fig_7"><head /><label /><figDesc>by a -standard call‖ node, which takes as arguments the operands of the binary operation. The back-end of CyMLT is responsible for Code Generation (Figure 3). It is independent of the frontend. It takes as input the ASG generated by the front-end and works in relation with the Doc and Interface Generation and Transformation Rules components. The Code Generation component transforms the annotated ASG into different readable source code or platform components. It consists of two integrated sub-components: a Language Generation and a</figDesc></figure>
<figure xml:id="fig_8"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc></figure>
<figure xml:id="fig_9"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Example of abstract syntax tree (AST) and abstract semantic graph (ASG). (a) definition of function "square" in CyML. (b) simplified view of AST of function -square‖ where the internal nodes in black represent Cython constructs and the final node in blue a variable or constant. (c) Simplified view of ASG with of function -square‖ with the new annotated nodes. The leaf nodes in black are non-terminal symbols of the Cython grammar whereas the end blue nodes are terminal symbols, essentially variables and constants. A child node (c) can be accessed from its parent node (p) through an attribute ( ).</figDesc><graphic coords="13,134.15,72.00,326.70,546.71" type="bitmap" /></figure>
<figure xml:id="fig_10"><head>Finally,</head><label /><figDesc>LanguageGenerator and PlatformGenerator use DocGenerator to integrate model documentation into generated model components. DocGenerator extracts all information based on model specification and presents it in different format according to the language and the platform.</figDesc></figure>
<figure xml:id="fig_11"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Class diagram illustrating the implementation of the one-to-many CyML transformer (CyMLT).</figDesc><graphic coords="15,97.85,408.95,399.58,298.85" type="bitmap" /></figure>
<figure xml:id="fig_12"><head>ForListing 1 .</head><label>1</label><figDesc>the C++, C# and Java languages, a model algorithm implemented in CyML is transformed into a class (Listing 1) that encapsulates both the algorithm and the scientific knowledge related to the model through the integrated documentation. A class, in software engineering terms, is a data structure defining a set of common properties and methods of an object. The generated source code contains methods to access and mutate model inputs and outputs, a constructor method to create and initialize an instance of the model (object) and a calculation method encapsulating the procedural logic of the model algorithm. First, variables are used to access model input (Listing 2) values before transforming the set of instructions of the model algorithm into the new language. Then, mutator methods are applied to update the model outputs (Listing 3). Model inputs and outputs are used to Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 build a class of objects passed in argument of the calculation method. External functions are transformed into static methods of the model class (Listing 1Error! Reference source not found.). Structure of generated source code in Java, C#, Fortran, and C++. The current version of CyMLT supports Fortran 90. This Fortran version presents low-level features (pointers, allocation), which makes some transformations difficult but ensures a higher portability. In Fortran, model algorithm corresponds to a subroutine, whereas external functions are subroutines, functions or recursive functions. CyMLT automatically operates this choice. In our case study, the Fibonacci function is transformed in a recursive function, which keeps the structure of the original code. In Python, the generated source code has the same structure as the CyML function. However, CyMLT can also generate Python code with an object-oriented approach. Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 Listing 2. Access input variables (in Java), s and s1 correspond to two instances of the class of state variables to manage previous and current state. CyMLT generates variables to access the fields of these instances and uses them in the procedural logic.</figDesc></figure>
<figure xml:id="fig_13"><head>Error!</head><label /><figDesc>Reference source not found. on Line 29, where the purpose is to find the smaller integer value that is larger than or equal to the leaf number. The method ceil in the C++ Math library corresponds to the CyML ceil function but returns a floating-point value. In this case, CyMLT preserves the original type (integer) by applying an explicit type conversion (Listing 4, Line 1). Listing 4. Type preservation in CyML transformation to C++, int casting is applied to the result returned by ceil function. The generated code preserves the intent of the original code provided by the information on the ASG. Listing 5 illustrates this intent preservation in the transformation of CyML For-loop construct (Listing 4, Line 1) where the consecutive iteration is expressed into an efficient way of representation in Fortran with the DO sequence (Listing 5, Line 1). However, the sequence indexing is different between CyML and Fortran. The last parameter of the CyML range function is not contained in the CyML sequence unlike the Fortran DO sequence. This is managed by subtracting this parameter by 1 in the generated code, thereby providing a same length of sequence. Likewise, arrays in Fortran are indexed from 1 by default and this is considered during the transformation of all array operations. Listing 5. From CyML for-loop to Fortran do-loop. The subroutine Add is generated to expand leaf tiller number array. Preservation of the scope of variables. CyMLT considers the scope of the variables in the different target languages. The scope of a variable refers to a region of the code where the variable is visible.</figDesc></figure>
<figure xml:id="fig_14"><head /><label /><figDesc>transformation of a CyML code to target languages can generate a model component in different ways. These transformations have been designed to be close to the philosophy of each target language. However, from the perspective of crop model component development, high-level ://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 programming languages are the lowest level of abstraction with respect to simulation platforms and frameworks. Additional constraints in crop modeling platforms include a specific programming paradigm, software design and code conventions. These different features give them capabilities to provide code introspection and reflection support, which allows them to dynamically extract and change information or knowledge about the code at run time. Thus, the code generation should extend language code generation by considering platform coding constraints, which are often implicit. The design of programming languages is formalized using grammars and is unambiguous. Platforms use design and architectural patterns without the use of an explicit formalism. This implies adapting the transformation to each platform taking into account their specificities. The current version of CyMLT generates model components compatible with BioMA, DSSAT, Record, OpenAlea and Simplace platforms, which support C#, Fortran, C++, Python and Java, respectively. Generation of object-oriented components. An object-oriented platform provides features such as inheritance, polymorphism and software design used to implement models. Polymorphism allows a model programmer to provide a generic interface to a number of related functions, and, thus, to propose different strategies to implement a model with different assumptions. For instance, this provides the possibility to include new physiological processes that are shared among different crop types. For this, object-oriented platforms define an abstract class that specifies the interface of all model components, which implements all the abstract methods of the abstract class. Two different approaches are used for model components to inherit an abstract class. Some platforms offer an abstract class and all model components implement and extend this class. This is the case for Simplace and Record, which provide the FWSimComponent (Listing 7: Structure of ShootNumber component in Simplace. A model unit in Simplace implements and extends an abstract class called FWSimComponent. Then, a model component overrides its abstract methods including init (model initialization), clone (deep clone of the model) and process (model algorithm). The structure of the abstract class is used to define a model skeleton in CyMLT to generate a model conforms to platform requirement.) and DiscreteTimeDyn interface, respectively. Another approach followed by platforms is component-based programming. A model developer creates a component that inherits of an interface provided by the platform. Thus, model components inherit this component interface. For example, BioMA provides the IStrategy interface. The current version of CyMLT generates a component interface in addition to the generation of model components. The abstract methods depend on the platform and include a method that encapsulate the algorithm of the model. Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 Listing 7: Structure of ShootNumber component in Simplace. A model unit in Simplace implements and extends an abstract class called FWSimComponent. Then, a model component overrides its abstract methods including init (model initialization), clone (deep clone of the model) and process (model algorithm). The structure of the abstract class is used to define a model skeleton in CyMLT to generate a model conforms to platform requirement. Generation of stateless and stateful unit models. A model algorithm is implemented in CyML as a function. However, the CyMLT generates both a stateless and a stateful component. A stateless component is an immutable object whose values of fields do not change if methods are invoked.</figDesc></figure>
<figure xml:id="fig_15"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020BioMA uses the strategy design pattern to create a library of simple strategies (equivalent to Crop2ML unit models) and composite strategies for model composition. The simple strategy leads to the implementation of a model unit as a stateless component. Thus, an instance of model unit class is a stateless object since it contains only model parameters (if any) as attributes which do not change during the simulation. The method of computation is comparable to a function that takes an object as an argument (i.e. higher-order function). Concretely, these objects are instances of domain classes. Domain class contains the values and the attributes for all variables defined in model specifications.To handle the change of state variables, the method of computation of each class takes as arguments two instances of state variables domain class reproduced by CyMLT (Listing 8), one for the current value and the other one for the previous one. This is made possible by the fact that the previous state is emulated in the CyML function with variable suffixed with -_t1‖. Finally, in Record and Simplace, unlike BioMA, a model unit class contains all state variables. In Simplace, there is no convention to distinguish previous and current state variables. Thus, CyMLT considers them as distinct fields in the generated Simplace component. The Record platform handles variable history (time series) by suffixing state variable with an operator () in the code. Thus, in this case, CyMLT generates current state variables with the suffix () and previous state variables with (-1). Listing 8. Fragments of code in C# with BioMA guidelines generated with CyMLT. S1 is an instance of state domain class used for previous time, s is an instance of state domain class used for current time. This shows that leaf number has been calculated by another model at the current time step, whereas the other variables are those calculated at the previous time step. Generation of platform specific types and data-structures. Some platforms define their own types by providing a generic class to handle model variables and parameters. A generic class is either a class or an interface that can be parameterized over the language data types. It contains a specific number of methods including methods to access or update variables. In this case, CyML data types map the framework generic types. Unlike BioMA, where inputs and outputs are C# data types extended with the generation of accessors and mutators, Simplace and Record provide their own class or interface to declare model inputs and outputs. To generate a Simplace component, the process of transformation consists of declaring model variables with the specialized class FWSimVariable. Then, CyMLT generates other variables declared with Java data types, which are used to access values of the FWSimVariable instances (Listing 9). This allows expressing the model algorithm with a pure Java but requires the use of a mutator method of the generic class to update output (Listing 10). Likewise, the generated Record component implements the DiscreteTimeDyn class provided by the vle package of Record to encode discrete-time models algorithms. Listing 9. Generation of other variables to access Simplace component variables. These variables are prefixed by t. Listing 10. Update of the variables of the shootnumber unit model generated by CyMLT following Simplace specifications.</figDesc></figure>
<figure xml:id="fig_16"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 Supporting a new language: R. R is a popular language used for statistical analyses and data visualization. Many modelers use R to start the development of their model (Zhao et al. 2019). Thus, with this extension, modelers can in the same environment conduct the first steps for model development and the implementation in a simulation platform, and analyze model outputs. The extension of CyMLT for R relies on the implementation of RGenerator and RRules classes that emit fragments of code in R and define transformation rules between CyML and the desired R constructs, respectively. Implementation of transformation rules for R. Transformation rules define the mapping of CyML operators, built-in functions and methods to their equivalent in R. R is a dynamic typed language and, as with Python, the type of variables is ignored. Operators mapping. Listing 11 declares the mapping between CyML and R operators. Only the difference operators are shown between CyML and R. During the ASG traversal, the visit method considers these mappings to emit code fragments.</figDesc></figure>
<figure xml:id="fig_17"><head /><label /><figDesc>CyMLT to PMF consists in adding the capacity to generate a model component in C# that fulfills PMF requirements. The developer implements a PMF generator class that extends the C# generator class. This class contains some PMF requirements: (1) the generated model component is a C# class that inherits the Model class, and (2) it contains the getter and setter methods of all model variables and parameters with the algorithm implemented in C#.</figDesc></figure>
<figure xml:id="fig_18"><head /><label /><figDesc>and platforms, enabling users to focus on the scientific aspect of their model rather than on the internal knowledge of platforms' specificities. A model component can be reused, improved, integrated and simulated in various platforms. This improves the diffusion of models, sharing them as a software and scientific artifacts, and thus, enhancing transparency and reproducibility of crop models. Moreover, with CyML, the model development may become a collaborative task of different groups of model builders with the possibility to compose different model units provided by different platforms. Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc></figure>
<figure xml:id="fig_19"><head /><label /><figDesc>modelers have expressed their interest to extend CyMLT with other languages used by the plant and crop modeling community. The use of a well-annotated ASG with model specifications provides an intuitive representation of the model algorithms. This abstraction set up various analysis of the source code by generating different source code based on the target language features, software design and code conventions. With this flexibility offered by the ASG, future work can explore the extension of CyMLT with other imperative programming languages such as Matlab, Julia, JavaScript or other modeling platforms that use imperative languages.Reuse of legacy PBM model components without the need to encode them into CyML could reduce the investment in model exchange and could increase the interest of the platforms. Therefore, the next step would be to provide a transpiler that transforms legacy model components from various Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 languages and simulation platforms into CyML code automatically. Such a many-to-many transformer would provide a complete system of interoperability of languages and simulation platforms.CyMLT aims to enable the exchange and reuse of components between modeling platforms, notably between PBM and functional-structural plant modelling (FSPM) platforms. While crop growth models simulate plant growth and development at the scale of the canopy (m 2 ) or average plant level, FSPMs are individual-based models at the scale of the organ. The exchange (sharing) of model components between PBM and FSPMs would allow an efficient coupling of these two modeling approaches to model crop species or variety mixtures by capturing spatial heterogeneities and quantifying plant traits involved in crop mixture performance<ref type="bibr" target="#b24">(Gaudio et al. 2019)</ref>. Another application is the use of FSPMs in a model-driven phenotyping approach, where plant structural traits are estimated by reverse engineering a FSPM<ref type="bibr" target="#b38">(Liu et al. 2019</ref>) and are then used as crop model input parameters to simulate the behavior of genotypes in target agro-climatic scenarios. Currently, CyML only allows for the representation of processes as functions and does not consider the plant's structure. To extend CyML to the FSPM community will require to extend CyML language and CyMLT to support complex data structures such as 3-dimensional geometry and topology.The convergence of our approach of model reuse and reproducibility approach with other collaborations, like the Crops in Silico collaboration<ref type="bibr" target="#b40">(Marshall-Colon et al. 2017)</ref>, would greatly accelerate the development of the next generation of PBMs. The Crops in Silico collaboration aims at integrating model frameworks to build a complete crop in silico from the level of the genes to the level of the field or ecosystem using a software package, Yggdrasil<ref type="bibr" target="#b36">(Lang 2019)</ref>. Yggdrasil connects PBMs across programming languages by running asynchronously models in parallel. It requires to write wrappers in the different languages to process the asynchronous messages to manage model inputs and outputs. CyMLT may interact with Yggdrasil (i) to make available model components into the languages supported by Yggdrasil with their wrappers, (ii) to produce efficient components source code in various languages in order to improve the performance of the simulation in Yggdrasil; and (iii) by validating each component with unit tests before their integration. The interaction between CyML and Yggdrasil could enhance the integration of PBMs across different languages and scales. A complementary approach to the one presented here was demonstrated for the automated transformation of input files of four agricultural models<ref type="bibr" target="#b55">(Samourkasidis and Athanasiadis 2020)</ref> enabling the discovery and reuse of data across modelling solutions. Together with AMEI they could ensure that a complete model implementation and accompanied data can be transformed between modelling solutions.</figDesc></figure>
<figure><head /><label /><figDesc /><graphic coords="18,72.00,124.35,447.05,387.79" type="bitmap" /></figure>
<figure><head /><label /><figDesc /><graphic coords="24,79.40,426.12,435.75,154.50" type="bitmap" /></figure>
<figure><head /><label /><figDesc /><graphic coords="27,101.52,461.92,392.19,165.70" type="bitmap" /></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc><table /></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc><table /></figure>
<figure type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020 Example of built-in functions within CyML language and their meaning.</figDesc><table><row><cell cols="2">Function Description</cell></row><row><cell>max</cell><cell>Largest item in a sequence</cell></row><row><cell>min</cell><cell>Smallest item in a sequence</cell></row><row><cell>ceil</cell><cell>Smallest integer greater than or equal to the parameter</cell></row><row><cell>append</cell><cell>Add an element at the end of a dynamic array (list)</cell></row><row><cell>len</cell><cell>Number of elements in a sequence (array or list)</cell></row><row><cell>range</cell><cell>Generate a list of integers from a start value to a stop value with a step</cell></row><row><cell>integer</cell><cell>Update the actual state variable from its previous value and the rate</cell></row><row><cell>3.2</cell><cell /></row></table></figure>
<figure type="table" xml:id="tab_3"><head>Transformation of CyML source code to different languages and platforms</head><label /><figDesc /><table /><note><p>Currently, <software>CyMLT</software> supports Python, Java, C#, C++ and Fortran languages. It also has the capability of generating a model algorithm in conformance with crop simulation platforms requirements.</p></note></figure>
<figure type="table" xml:id="tab_4"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc><table /></figure>
<figure type="table" xml:id="tab_5"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc><table /></figure>
<figure type="table" xml:id="tab_6"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc><table /></figure>
<figure type="table" xml:id="tab_7"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc><table /></figure>
<figure type="table" xml:id="tab_8"><head /><label /><figDesc>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</figDesc><table /></figure>
			<note place="foot" xml:id="foot_0"><p>Downloaded from https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454 by INRAE Institut National de Recherche pour l'Agriculture, l'Alimentation et l'Environnement user on 09 October 2020</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>CM acknowledges the support of <rs type="funder">INRAE Divisions AgroEcoSystem and NUM</rs>. PM acknowledges the support of <rs type="funder">INRAE Division AgroEcoSystem</rs>.</p></div>
			</div>
			<listOrg type="funding">
			</listOrg>

			<div type="availability">
<div><p>Code The <software>CyMLT</software> source code are available publicly on Github at https://github.com/AgriculturalModelExchangeInitiative/PyCrop2ML. Full documentation for <software ContextAttributes="used">CyML</software> and <software ContextAttributes="used">CYMLT</software> can be found at https://pycrop2ml.readthedocs.io.</p></div>
			</div>

			<div type="annex">
<div><head n="5.">Conclusions</head><p>In this study, we defined a minimal language based on the <software>Cython</software> language to implement biophysical processes involved in plant and crop growth and development. We designed a system that transforms <software ContextAttributes="used">CyML</software> source code to many target languages and simulation platforms. The association of model specifications in XML-based format with the description of model algorithm based on <software ContextAttributes="used">CyML</software> specifications allows to annotate each variable used in the algorithm. With this approach we can produce code with different programming paradigms including object-oriented approach and with different software designs. We showed that this language is sufficient to express biophysical processes and to transform them in different target languages and simulation platforms. We argue that the abstract language offers some trade-off between generality due to the convergence of the platforms and the complexity hidden in each platform. Crop modelers should have some programming skill to implement a model in <software ContextAttributes="used">CyML</software> but no other skills are needed to produce automatically a model component source code in various languages and platforms. This reuse approach will help modelers to improve the reproducibility of their models and their reuse and should enhance research collaborations and model improvement and use. </p></div>
<div><head>Source of Funding</head></div>
<div><head>Conflict of interest</head><p>The authors declare no conflict of interest. </p></div>
<div><head>Supporting Information</head><p>The Following additional information are available on the online version of this article. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">‗HOPE: A Python just-in-time compiler for astrophysical computations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Akeret</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ascom.2014.12.001</idno>
	</analytic>
	<monogr>
		<title level="j">Astronomy and Computing. Elsevier B.V</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="8" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">‗Object-Oriented Programming via Fortran 90/95</title>
		<author>
			<persName><forename type="first">E</forename><surname>Akin</surname></persName>
		</author>
		<idno type="DOI">10.1017/cbo9780511530111</idno>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">‗Can growing degree days and photoperiod predict spring wheat phenology?</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Aslam</surname></persName>
		</author>
		<idno type="DOI">10.3389/fenvs.2017.00057</idno>
	</analytic>
	<monogr>
		<title level="j">Frontiers in Environmental Science</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">SEP</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">‗Uncertainty in simulating wheat yields under climate change</title>
		<author>
			<persName><forename type="first">S</forename><surname>Asseng</surname></persName>
		</author>
		<idno type="DOI">10.1038/nclimate1916</idno>
	</analytic>
	<monogr>
		<title level="j">Nature Climate Change</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="827" to="832" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">‗Enriching environmental software model interfaces through ontology-based tools</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">N</forename><surname>Athanasiadis</surname></persName>
		</author>
		<idno type="DOI">10.1504/IJASS.2011.042205</idno>
	</analytic>
	<monogr>
		<title level="j">International Journal of Applied Systemic Studies</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="94" to="105" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">‗A roadmap to domain specific programming languages for environmental modeling: Key requirements and concepts</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">N</forename><surname>Athanasiadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Villa</surname></persName>
		</author>
		<idno type="DOI">10.1145/2541928.2541934</idno>
	</analytic>
	<monogr>
		<title level="m">DSM 2013 -Proceedings of the 2013 ACM Workshop on Domain-Specific Modeling</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="27" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">‗Mathematical Markup Language ( MathML ) Version 2 . 0 ( Second Edition )</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ausbrooks</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/MathML2/" />
	</analytic>
	<monogr>
		<title level="m">Mathematical Markup Language Specification TA -Ausbrooks</title>
		<imprint>
			<date type="published" when="2003-10">2003. October</date>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="0" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">Autumn</forename><surname>Cuellar</surname></persName>
		</author>
		<ptr target="https://www.cellml.org/specifications/cellml_1.1/index_html" />
		<title level="m">CellML 1.1 Specification</title>
		<imprint>
			<date type="published" when="2006-02-20">2006. 20 February 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">‗DMS®: Program transformations for practical scalable software evolution</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">D</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pidgeon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mehlich</surname></persName>
		</author>
		<idno type="DOI">10.1109/icse.2004.1317484</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings -International Conference on Software Engineering</title>
		<meeting>-International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2004-05">2004. May</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="625" to="634" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">‗Cython: The Best of Both Worlds</title>
		<author>
			<persName><forename type="first">S</forename><surname>Behnel</surname></persName>
		</author>
		<idno type="DOI">10.1109/MCSE.2010.118</idno>
	</analytic>
	<monogr>
		<title level="j">Computing in Science &amp; Engineering</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="31" to="39" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">‗Cython: The best of both worlds Stefan</title>
		<author>
			<persName><forename type="first">S</forename><surname>Behnel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bradshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Seljebotn</surname></persName>
		</author>
		<idno type="DOI">10.1093/insilicoplants/diaa007/5918454</idno>
		<ptr target="https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454" />
	</analytic>
	<monogr>
		<title level="j">Rehab Management: The Interdisciplinary Journal of Rehabilitation</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="32" to="36" />
			<date type="published" when="2000-10-09">2000. 09 October 2020</date>
		</imprint>
		<respStmt>
			<orgName>National de Recherche pour l'Agriculture</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">‗A new plug-in under RECORD to link biophysical and decision models for crop management</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Bergez</surname></persName>
		</author>
		<idno type="DOI">10.1007/s13593-016-0357-y</idno>
	</analytic>
	<monogr>
		<title level="j">Agronomy for Sustainable Development. Agronomy for Sustainable Development</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="8" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">‗Modelling climate change impacts on crop production for food security</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bindi</surname></persName>
		</author>
		<idno type="DOI">10.3354/cr01342</idno>
	</analytic>
	<monogr>
		<title level="j">Climate Research</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="3" to="5" />
			<date type="published" when="2014">2015. February 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">‗STICS: a generic model for the simulation of crops and their water and nitrogen balances. I. Theory and parameterization applied to wheat and corn</title>
		<author>
			<persName><forename type="first">N</forename><surname>Brisson</surname></persName>
		</author>
		<idno type="DOI">10.1051/agro:19980501</idno>
	</analytic>
	<monogr>
		<title level="j">Agronomie</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="311" to="346" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">‗Plant Modelling Framework: Software for building and running crop models on the APSIM platform</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">E</forename><surname>Brown</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.envsoft.2014.09.005</idno>
	</analytic>
	<monogr>
		<title level="j">Environmental Modelling and Software</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="385" to="398" />
			<date type="published" when="2014">2014</date>
			<publisher>Elsevier Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">‗Crop model improvement in APSIM: Using wheat as a case study</title>
		<author>
			<persName><forename type="first">H</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Huth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Holzworth</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.eja.2018.02.002</idno>
	</analytic>
	<monogr>
		<title level="j">European Journal of Agronomy</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="141" to="150" />
			<date type="published" when="2018-02">2018. February</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">‗Migrating legacy fortran to python while retaining fortran-level performance through transpilation and type hints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bysiek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Drozd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Matsuoka</surname></persName>
		</author>
		<idno type="DOI">10.1109/PyHPC.2016.006</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PyHPC 2016: 6th Workshop on Python for High-Performance and Scientific Computing -Held in conjunction with SC16: The International Conference for High Performance Computing, Networking, Storage and Analysis</title>
		<meeting>PyHPC 2016: 6th Workshop on Python for High-Performance and Scientific Computing -Held in conjunction with SC16: The International Conference for High Performance Computing, Networking, Storage and Analysis</meeting>
		<imprint>
			<date type="published" when="2017-11">2017. November</date>
			<biblScope unit="page" from="9" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">‗Comparison of C++ and Fortran 90 for object-oriented scientific programming</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Cary</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0010-4655(97)00043-X</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Physics Communications</title>
		<imprint>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="20" to="36" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">‗A Component-Based Framework for Simulating Agricultural Production and Externalities</title>
		<author>
			<persName><forename type="first">M</forename><surname>Donatelli</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-90-481-3619-3_4</idno>
	</analytic>
	<monogr>
		<title level="m">Environmental and Agricultural Modeling</title>
		<meeting><address><addrLine>Dordrecht; Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="63" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">‗A generic framework for evaluating hybrid models by reuse and composition -A case study on soil temperature simulation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Donatelli</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.envsoft.2014.04.011</idno>
	</analytic>
	<monogr>
		<title level="j">Environmental Modelling and Software</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="478" to="486" />
			<date type="published" when="2014">2014</date>
			<publisher>Elsevier Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">‗The IMPETUS Spatial Decision Support Systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Enders</surname></persName>
		</author>
		<idno type="DOI">10.1093/insilicoplants/diaa007/5918454</idno>
		<idno>doi: 10.1007/978-3-642-12957-5_11</idno>
		<ptr target="https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454" />
	</analytic>
	<monogr>
		<title level="m">Impacts of Global Change on the Hydrological Cycle in West and Northwest Africa</title>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin; Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-10-09">2010. 09 October 2020</date>
			<biblScope unit="page" from="360" to="393" />
		</imprint>
		<respStmt>
			<orgName>INRAE Institut National de Recherche pour l'Agriculture</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">‗Convergence in integrated modeling frameworks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Van Evert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MODSIM05 -International Congress on Modelling and Simulation: Advances and Applications for Management and Decision Making, Proceedings</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="745" to="750" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">‗AutoWIG: Automatic Generation of Python Bindings for C++ Libraries</title>
		<author>
			<persName><forename type="first">P</forename><surname>Fernique</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pradal</surname></persName>
		</author>
		<ptr target="http://arxiv.org/abs/1705.11000" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">‗Design Patterns: Elements of Reusable Object-Oriented Software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<idno type="DOI">10.1016/b978-012663315-3/50005-8</idno>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">‗Current knowledge and future research opportunities for modeling annual crop mixtures. A review</title>
		<author>
			<persName><forename type="first">N</forename><surname>Gaudio</surname></persName>
		</author>
		<idno type="DOI">10.1007/s13593-019-0562-6</idno>
	</analytic>
	<monogr>
		<title level="j">Agronomy for Sustainable Development</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">20</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">‗NeuroML: A language for describing data driven models of neurons and networks with a high degree of biological detail</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gleeson</surname></persName>
		</author>
		<idno type="DOI">10.1371/journal.pcbi.1000815</idno>
	</analytic>
	<monogr>
		<title level="j">PLoS Computational Biology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">‗Simulation of environmental and genotypic variations of final leaf number and anthesis date for wheat</title>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.eja.2011.11.002</idno>
	</analytic>
	<monogr>
		<title level="j">European Journal of Agronomy</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="22" to="33" />
			<date type="published" when="2012">2012</date>
			<publisher>Elsevier B.V</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">‗APSIM Next Generation: Overcoming challenges in modernising a farming systems model</title>
		<author>
			<persName><forename type="first">D</forename><surname>Holzworth</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.envsoft.2018.02.002</idno>
	</analytic>
	<monogr>
		<title level="j">Environmental Modelling &amp; Software</title>
		<imprint>
			<biblScope unit="volume">103</biblScope>
			<biblScope unit="page" from="43" to="51" />
			<date type="published" when="2018">2018</date>
			<publisher>Elsevier Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">‗Agricultural production systems modelling and software: Current status and future prospects</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Holzworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Snow</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.envsoft.2014.12.013</idno>
	</analytic>
	<monogr>
		<title level="j">Environmental Modelling and Software</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="276" to="286" />
			<date type="published" when="2014">2014</date>
			<publisher>Elsevier Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">‗APSIM -Evolution towards a new generation of agricultural systems simulation</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">P</forename><surname>Holzworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename><surname>Huth</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.envsoft.2014.07.009</idno>
	</analytic>
	<monogr>
		<title level="j">Environmental Modelling and Software</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="327" to="350" />
			<date type="published" when="2014">2014</date>
			<publisher>Elsevier Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">‗The DSSAT crop modeling ecosystem</title>
		<author>
			<persName><forename type="first">G</forename><surname>Hoogenboom</surname></persName>
		</author>
		<idno type="DOI">10.19103/AS.2019.0061.10</idno>
		<ptr target="https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454" />
		<imprint>
			<date type="published" when="2019-10-09">2019. 09 October 2020</date>
			<biblScope unit="page" from="173" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">‗Promoting Coordinated Development of Community-Based Information Standards for Modeling in Biology: The COMBINE Initiative</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hucka</surname></persName>
		</author>
		<idno type="DOI">10.3389/fbioe.2015.00019</idno>
	</analytic>
	<monogr>
		<title level="j">Frontiers in Bioengineering and Biotechnology</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2015-02">2015. February</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The DSSAT cropping system model</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Jones</surname></persName>
		</author>
		<idno type="DOI">10.1016/S1161-0301(02)00107-7</idno>
	</analytic>
	<monogr>
		<title level="j">European Journal of Agronomy</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">‗Brief history of agricultural systems modeling</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Jones</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.agsy.2016.05.014</idno>
	</analytic>
	<monogr>
		<title level="j">Agricultural Systems</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="240" to="254" />
			<date type="published" when="2017-06">2017. June</date>
			<publisher>Elsevier B.V</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">‗Jupyter Notebooks-a publishing format for reproducible computational workflows</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kluyver</surname></persName>
		</author>
		<idno type="DOI">10.3233/978-1-61499-649-1-87</idno>
	</analytic>
	<monogr>
		<title level="j">Positioning and Power in Academic Publishing: Players, Agents and Agendas</title>
		<imprint>
			<biblScope unit="page" from="87" to="90" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">‗WISS a Java Continuous Simulation Framework for Agro-Ecological Modelling</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W G</forename><surname>Van Kraalingen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-39815-6_23</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="242" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">‗yggdrasil: a Python package for integrating computational models across languages and scales</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lang</surname></persName>
		</author>
		<idno type="DOI">10.1093/insilicoplants/diz001</idno>
	</analytic>
	<monogr>
		<title level="j">silico Plants</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Programming for Computations -Python</title>
		<author>
			<persName><forename type="first">S</forename><surname>Linge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">P</forename><surname>Langtangen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-32428-</idno>
	</analytic>
	<monogr>
		<title level="s">Texts in Computational Science and Engineering</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>Springer International Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">‗Estimation of plant and canopy architectural traits using the digital plant phenotyping platform1[OPEN</title>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<idno type="DOI">10.1104/pp.19.00554</idno>
	</analytic>
	<monogr>
		<title level="j">Plant Physiology</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">‗SiriusQuality-BioMa-Phenology-Component</title>
		<author>
			<persName><forename type="first">L</forename><surname>Manceau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Martre</surname></persName>
		</author>
		<idno type="DOI">10.5281/ZENODO.2478791</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">‗Crops in silico: Generating virtual crops using an integrative and multi-scale modeling platform</title>
		<author>
			<persName><forename type="first">A</forename><surname>Marshall-Colon</surname></persName>
		</author>
		<idno type="DOI">10.3389/fpls.2017.00786</idno>
	</analytic>
	<monogr>
		<title level="j">Frontiers in Plant Science</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2017-05">2017. May</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">‗Modelling protein content and composition in relation to crop nitrogen dynamics for wheat</title>
		<author>
			<persName><forename type="first">P</forename><surname>Martre</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.eja.2006.04.007</idno>
	</analytic>
	<monogr>
		<title level="j">European Journal of Agronomy</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="138" to="154" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">‗The agricultural model exchange initiative</title>
		<author>
			<persName><forename type="first">P</forename><surname>Martre</surname></persName>
		</author>
		<idno type="DOI">10.1093/insilicoplants/diaa007/5918454</idno>
		<ptr target="https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454" />
	</analytic>
	<monogr>
		<title level="m">l'Environnement user on 09 October 2020 Workshop</title>
		<meeting><address><addrLine>San José, Costa Rica</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
		<respStmt>
			<orgName>Institut National de Recherche pour l'Agriculture</orgName>
		</respStmt>
	</monogr>
	<note>IICA (ed.) 7th AgMIP Global</note>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">‗Crop2ML: The centralized framework for crop model component exchange and reuse</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Midingoyi</surname></persName>
		</author>
		<idno type="DOI">10.5281/ZENODO.3911713</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">‗Illicium A modular transpilation toolchain from Pharo to C</title>
		<author>
			<persName><forename type="first">P</forename><surname>Misse-Chanabier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Aranega</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Polito</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">‗Plant and crop simulation models: powerful tools to link physiology, genetics, and phenomics</title>
		<author>
			<persName><forename type="first">B</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Martre</surname></persName>
		</author>
		<idno type="DOI">10.1093/jxb/erz175</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Experimental Botany</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2339" to="2344" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">‗Simulation of winter wheat yield and its variability in different climates of Europe: A comparison of eight crop growth models</title>
		<author>
			<persName><forename type="first">T</forename><surname>Palosuo</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.eja.2011.05.001</idno>
	</analytic>
	<monogr>
		<title level="j">European Journal of Agronomy</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="103" to="114" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">‗Write-once, transpile-everywhere: re-using motion controllers of virtual humans across multiple game engines</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">T</forename><surname>De Paolis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bourdot</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-95282-6_51</idno>
		<imprint>
			<date type="published" when="2018-07">2018. July</date>
			<biblScope unit="page" from="1" to="E1" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">‗Source-to-Source Translation and Software Engineering</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Plaisted</surname></persName>
		</author>
		<idno type="DOI">10.4236/jsea.2013.64A005</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Software Engineering and Applications</title>
		<imprint>
			<biblScope unit="volume">06</biblScope>
			<biblScope unit="issue">04</biblScope>
			<biblScope unit="page" from="30" to="40" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">‗OpenAlea: A visual programming and component-based software platform for plant modelling</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pradal</surname></persName>
		</author>
		<idno type="DOI">10.1071/FP08084</idno>
	</analytic>
	<monogr>
		<title level="j">Functional Plant Biology</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="751" to="760" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">‗OpenAlea : Scientific Workflows Combining Data Analysis and Simulation To cite this version : HAL Id : hal-01166298 OpenAlea : Scientific Workflows Combining Data Analysis and Simulation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pradal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">‗The ROSE Source-to-Source Compiler Infrastructure</title>
		<author>
			<persName><forename type="first">D</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Liao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal</title>
		<imprint>
			<biblScope unit="page" from="1" to="3" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">‗R: A Language and Environment for Statistical Computing</title>
		<author>
			<persName><forename type="first">Team</forename><surname>Core</surname></persName>
		</author>
		<ptr target="https://www.r-project.org/" />
		<imprint>
			<date type="published" when="2017">2017</date>
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">‗The Agricultural Model Intercomparison and Improvement Project (AgMIP): Protocols and pilot studies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Rosenzweig</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.agrformet.2012.09.011</idno>
		<ptr target="https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454" />
	</analytic>
	<monogr>
		<title level="j">Agricultural and Forest Meteorology</title>
		<imprint>
			<biblScope unit="volume">170</biblScope>
			<biblScope unit="page" from="166" to="182" />
			<date type="published" when="2013-10-09">2013. 09 October 2020</date>
			<publisher>Elsevier B.V</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">‗Crop-climate models need an overhaul</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Rötter</surname></persName>
		</author>
		<idno type="DOI">10.1038/nclimate1152</idno>
	</analytic>
	<monogr>
		<title level="j">Nature Climate Change</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="175" to="177" />
			<date type="published" when="2011">2011</date>
			<publisher>Nature Publishing Group</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">‗A semantic approach for timeseries data fusion</title>
		<author>
			<persName><forename type="first">A</forename><surname>Samourkasidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">N</forename><surname>Athanasiadis</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.compag.2019.105171</idno>
	</analytic>
	<monogr>
		<title level="j">Computers and Electronics in Agriculture</title>
		<imprint>
			<biblScope unit="volume">169</biblScope>
			<biblScope unit="page">105171</biblScope>
			<date type="published" when="2019">2020. December 2019</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">‗The design and evaluation of an interoperable translation system for object-oriented software reuse</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schaub</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Malloy</surname></persName>
		</author>
		<idno type="DOI">10.5381/jot.2016.15.4.a1</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Object Technology</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">‗CellML2SBML: Conversion of CellML into SBML</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Schilstra</surname></persName>
		</author>
		<idno type="DOI">10.1093/bioinformatics/btl047</idno>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1018" to="1020" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">‗Integrating modelling architecture: A declarative framework for multi-paradigm, multi-scale ecological modelling</title>
		<author>
			<persName><forename type="first">F</forename><surname>Villa</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0304-3800(00)00422-1</idno>
	</analytic>
	<monogr>
		<title level="j">Ecological Modelling</title>
		<imprint>
			<biblScope unit="volume">137</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="23" to="42" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">‗Semantics for interoperability of distributed data and models: Foundations for better-connected information</title>
		<author>
			<persName><forename type="first">F</forename><surname>Villa</surname></persName>
		</author>
		<idno type="DOI">10.12688/f1000research.11638</idno>
	</analytic>
	<monogr>
		<title level="j">F1000Research</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">686</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">‗25 years of the WOFOST cropping systems model</title>
		<author>
			<persName><forename type="first">A</forename><surname>De Wit</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.agsy.2018.06.018</idno>
	</analytic>
	<monogr>
		<title level="j">Agricultural Systems</title>
		<imprint>
			<biblScope unit="volume">168</biblScope>
			<biblScope unit="page" from="154" to="167" />
			<date type="published" when="2017">2019. October 2017</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">‗A SIMPLE crop model</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
		<idno type="DOI">10.1016/J.EJA.2019.01.009</idno>
		<ptr target="https://academic.oup.com/insilicoplants/advance-article/doi/10.1093/insilicoplants/diaa007/5918454" />
	</analytic>
	<monogr>
		<title level="j">European Journal of Agronomy</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="page" from="97" to="106" />
			<date type="published" when="2019-10-09">2019. 09 October 2020</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>