<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Enumerating models of DNF faster: breaking the dependency on the formula size</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2018-10-09">October 9, 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Florent</forename><surname>Capelli</surname></persName>
							<email>florent.capelli@univ-lille.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">CRIStAL Laboratory</orgName>
								<orgName type="institution">Université de Lille</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yann</forename><surname>Strozecki</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">DAVID Laboratory</orgName>
								<orgName type="institution">Université de Versailles Saint-Quentin-en-Yvelines</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Enumerating models of DNF faster: breaking the dependency on the formula size</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2018-10-09">October 9, 2018</date>
						</imprint>
					</monogr>
					<idno type="MD5">751296A6E78A2AC34D70F0A5097A208F</idno>
					<idno type="DOI">10.1016/j.dam.2020.02.014</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this article, we study the problem of enumerating the models of DNF formulas. The aim is to provide enumeration algorithms with a delay that depends polynomially on the size of each model and not on the size of the formula. We succeed for two subclasses of DNF formulas: we provide a constant delay algorithm for k-DNF with fixed k by an appropriate amortization method and we give a polynomial delay algorithm for monotone formulas. We then focus on the average delay of enumeration algorithms and show that we can bring down the dependency of the average delay to the square root of the formula size and even to a logarithmic dependency for monotone formulas.</p><p>1</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>An enumeration problem is the task of listing a set of elements without redundancies, usually corresponding to the solutions of a search problem, such as enumerating the spanning trees of a graph or the satisfying assignments of a formula. One way of measuring the complexity of an enumeration algorithm is the total time needed to compute all solutions. When the total time depends both on the input and output, an algorithm is called output sensitive. It is considered tractable and said to be output polynomial when it can be solved in polynomial time in the size of the input and the output.</p><p>Output sensitivity is relevant when all elements of a set must be generated, for instance to build a library of interesting objects to be studied by experts, as it is done in biology, chemistry or network analytics <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b5">6]</ref>. However, when the output is large with regard to the input, output polynomiality is not enough to capture tractability. Indeed, if one wants only a good solution or some statistic on the set of solutions, it can be interesting to generate only a fraction of the solutions. A good algorithm for this purpose must guarantee that the more time it has, the more solutions it generates. To measure the efficiency of such an algorithm, we need to compute the delay between two consecutive solutions. A first guarantee that we can expect is to have a good average delay (sometimes referred to as amortized delay), that is, to measure the total time divided by the number of solutions. There are many enumeration algorithms which are in constant amortized time or CAT, usually for the generation of combinatorial objects, such as the unrooted trees of a given size <ref type="bibr" target="#b25">[26]</ref>, the linear extensions of a partial order <ref type="bibr" target="#b18">[19]</ref> or the integers by Gray code <ref type="bibr" target="#b13">[14]</ref>. Uno also proposed <ref type="bibr" target="#b24">[25]</ref> a general method to obtain constant amortized time algorithms, which can be applied, for instance, to find the matchings or the spanning trees of a graph.</p><p>However, when one wants to process a set in a streaming fashion such as the answers of a database query, it may be interesting to guarantee the regularity of the delay, usually by bounding it by a polynomial in the input size. We refer to such algorithms as polynomial delay algorithms. Many problems admit such algorithms, e.g. enumerate the cycles of a graph <ref type="bibr" target="#b19">[20]</ref>, the satisfying assignments of variants of SAT <ref type="bibr" target="#b7">[8]</ref> or the spanning trees and connected induced subgraphs of a graph <ref type="bibr" target="#b2">[3]</ref>. They are all based on similar techniques (see <ref type="bibr" target="#b15">[16]</ref> for a survey).</p><p>For some problems, the size of the input may be much larger than the size of the generated solutions, which makes polynomial delay an unsatisfactory measure of efficiency. In that case, algorithms whose delay depends on the size of a single solution are naturally more interesting than polynomial delay or output polynomial algorithms. We say that an algorithm is in strong polynomial delay when the delay between two consecutive solutions is polynomial in the size of the last solution. To make this notion robust and more relevant, a precomputation step is allowed before the enumeration, in time polynomial in the input size, so that the algorithm can read the whole input and set up useful data structures. Observe that the notion of strong polynomial delay is also well suited for infinite enumeration where the size of the solutions grows arbitrarily <ref type="bibr" target="#b9">[10]</ref>.</p><p>In this paper, we focus on the notion of strong polynomial delay. While strong polynomial delay is a very desirable property for an algorithm it is rarely considered, since polynomial delay is often seen as the be-all end-all answer in enumeration. We feel that understanding the difference between polynomial delay and strong polynomial delay is a challenge that complexity of enumeration must address to be more relevant for practitioners. We are especially interested in finding such algorithms for the problem of enumerating the models of DNF formulas. Indeed, one can easily solve it with delay linear in the size of the formula (see Theorem 4) but it appears that removing the dependency in the number of terms in the delay is not easy, even when allowing exponential space. DNF formulas have a simple structure as it is easy to find a large number of solutions or to approximate their number <ref type="bibr" target="#b14">[15]</ref>. Nevertheless, exactly counting the solutions of a DNF formula is a canonical #P-complete problem. Enumerating the models of a DNF formulas thus appears to be a reasonable candidate to separate the notions of strong polynomial delay and polynomial delay. Surprisingly, we manage to remove the dependency of the delay in the number of terms for k-DNF and monotone DNF and to improve it for the general case. Our results are summarized in Table <ref type="table" target="#tab_0">1</ref>.</p><p>There are few examples of strong polynomial delay in the literature. Constant delay algorithms naturally fall into this category and a whole line of research is dedicated to design such algorithm for enumerating models of first order queries for restricted classes of structures <ref type="bibr" target="#b20">[21]</ref> (see also the survey <ref type="bibr" target="#b21">[22]</ref>). However, while these algorithms are called constant delay because their delay does not depend on the database size, it often depends more than exponentially on the size of the solutions. Other examples naturally arise from logic such as the enumeration of assignments of MSO queries over trees or bounded width graphs <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b6">7]</ref>. Recently, Amarilli et al. <ref type="bibr" target="#b0">[1]</ref> presented an algorithm to enumerate the solutions of a restricted class of Boolean circuits known as structured d-DNNF used in knowledge compilation with delay linear in the number of variables and hence independent of the size of the circuit.</p><p>The paper is organized as follows. We first introduce basic notions on formulas and enumeration complexity then present tries and Gray code in Section 2. We show in Sec 3 how to adapt three classical methods to generate the models of a DNF, the best having a linear delay in the formula size. In Section 4, we give a backtrack search algorithm, using a good amortization, which is in constant delay for k-DNF. In Section 5, we give another backtrack search algorithm, whose average delay is better than linear. Finally, in Section 6, we provide a strong polynomial delay for monotone DNF formulas but with an exponential memory and we specialize and adapt the algorithm of the previous section to obtain a logarithmic delay for monotone DNF formulas. Proposition with omitted proofs due to space restrictions are labeled with ( ) and a proof is given in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Definitions and notations</head><p>Terms and DNF-formulas. Let X be a set of variables and let n and be the size of X. We fix some arbitrary order on X and write X = {x 1 , . . . , x n }. A literal is either a variable x ∈ X or the negation of a variable ¬x for some x ∈ X. A term C is a finite set of literals such that every two literals in C have a different variable. A Disjunctive Normal Form formula, DNF for short, is a finite set of terms. Given a literal , we denote its underlying variable by var( ). We extend this notation to terms by denoting var(C) := ∈C var( ) for a term C and to DNF by denoting var(D) := C∈D var(C) for a DNF D.</p><p>Given an assignment α : X → {0, 1}, we naturally extend α to literals by defining α(¬x) = 1 -α(x). An assignment α satisfies a term C if for every ∈ C, α(C) = 1. A model α is an assignment that satisfies a DNF D, that is, there exists C ∈ D such that α satisfies C. We write α |= D if α is a model of D. It is easy to see that given a term C, there exists a unique assignment of variables in var(C) satisfying C. We denote this assignment by 1 C .</p><p>Given a DNF D on variables X, we denote by sat(D) = {α | α |= D} the set of models of D. Let Y ⊆ X, τ : Y → {0, 1} and σ : X → {0, 1}, we say that σ is compatible with τ , denoted by σ τ , if the restriction of σ to Y is equal to τ . We denote by sat(D, τ ) = {α | α |= D, σ τ } the set of models of D compatible with τ . We also denote by D[τ ] the DNF defined as follows: we remove every term C from D such that there exists a literal ∈ C such that τ ( ) = 0. For the remaining terms, we remove every literal whose variable is in Y . Observe that since we consider DNF to be sets of terms, by definition, D[τ ] has no duplicated terms. It is clear that:</p><formula xml:id="formula_0">sat(D, τ ) = {τ ∪ α | α |= D[τ ]}.</formula><p>The size of a DNF D is denoted by D and is equal to C∈D |C|.</p><p>Enumeration complexity. Let Σ be a finite alphabet and Σ * be the set of finite words built on Σ. Let A ⊆ Σ * × Σ * be a binary predicate, we write A(x) for the set of y such that A(x, y) holds. The enumeration problem Enum•A is the function which associates A(x) to x.</p><p>The computational model is the random access machine model (RAM) with addition, subtraction and multiplication as its basic arithmetic operations and an operation Output(i, j) which outputs the concatenation of the values of registers R i , R i+1 , . . . , R j . We assume that all operations are in constant time except the arithmetic instructions which are in time linear in the size of their inputs. While this is arguably not a real-life scenario, this allows us to formally write algorithms with constant time delay while it is theoretically impossible if the time needed to write the output is taken into account. A RAM machine solves Enum•A if, on every input x ∈ Σ * , it produces a sequence y 1 , . . . , y n such that A(x) = {y 1 , . . . , y n } and for all i = j, y i = y j . The space used by the machine at a given step is the sum of the number of bits required to store the integers in its registers.</p><p>The delay of a RAM machine which outputs the sequence {y 1 , . . . , y n } is the maximum over all i ≤ n of the time the machine uses between the generation of y i and y i+1 . Note that we allow a precomputation phase before the machine starts to enumerate solutions, which can be in time polynomial in the size of the input.</p><p>Trie. A trie is a data structure used to represent a set of words on an alphabet M which supports efficient insertion and deletion. We refer the reader to <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b13">14]</ref> for more details. We use them to either store a formula, that is the sets of its terms, or to represent a set of assignments of a formula.</p><p>The trie is a M -ary tree, each of its inner nodes is labeled by a letter of the alphabet. A leaf represents a word: the sequence of labels traversed when going from the root to the leaf. The trie represents the set of words represented by its leaves. The children of a node are given by a linked list.</p><p>A model α of the DNF is represented by the sequence of its values: α(x 1 )α(x 2 ) . . . α(x n ). The trie we use to store these models are binary trees, since the labels are in {0, 1}. We represent a term by the sequence in ascending orders of its literals, with for all i, x i &lt; xi+1 &lt; x i+1 . The list of children of a node in the trie is maintained in this order.</p><p>We need to search, insert and suppress elements in a trie. Those three operations are in O(n) for the two tries we have defined, where n is the number of variables.</p><p>Gray Code. Gray codes are an efficient way to enumerate the integers between 0 and 2 n -1 written in binary or equivalently the subsets of a set of size n. They enjoy two important properties: the Hamming distance of two elements in the Gray enumeration order is one and each new element is produced in constant time using only additional O(log(n) 2 ) space (see <ref type="bibr" target="#b12">[13]</ref>). In other words, this enumeration algorithm has constant delay. We can generate all models of a term in constant delay, using Gray code and an additional array which contains the indexes of the free variables of the term.</p><p>Proposition 1 (( )). The models of a term C on variables X can be enumerated in constant delay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Classical enumeration algorithms</head><p>In this section we present three generic enumeration methods applied to the generation of the models of a DNF formula. The best one has a linear delay in the size of the instance, and we study in later sections several restrictions to obtain a delay polynomial in the size of a solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Union of terms</head><p>The first two methods are based on the fact that the models of a DNF formula are the union of the models of its terms. The only problem is to avoid repetitions of models. We first use a method to enumerate the union of sets of elements which preserves polynomial delay (see <ref type="bibr" target="#b22">[23]</ref>). It relies on a priority rule between the sets to avoid repetitions, as recalled in the proof of the following proposition.</p><p>Proposition 2 (( ) Adapted from proposition 2.38 and 2.40 in <ref type="bibr" target="#b22">[23]</ref>). The models of a DNF formula D with m terms can be enumerated with delay O(m D ).</p><p>By improving the way we test whether a model of a term is the model of any term of larger index, we can drop the delay to O(m 2 ). In fact, by generating the solutions of each term in the same order, we can avoid completely the redundancy test and get a better delay. The following algorithm merges several ordered arrays which are generated dynamically by enumeration procedures.</p><p>Proposition 3 (( ) Adapted from proposition 2.41 in <ref type="bibr" target="#b22">[23]</ref>). The models of a DNF formula D with m terms and n variables can be enumerated with delay O(mn).</p><p>The average delay of the two previous algorithms is lower than their delays. Let r be the average number of times a solution is produced during the algorithm, we can replace m by r in the average delay of the previous algorithm. It is possible to prove that r is smaller than m by studying how terms share models, but the complexity gains are very small and we give an algorithm with a much better average delay in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Flashlight method</head><p>We present a classical enumeration method called the Backtrack Search or sometimes the Flashlight Method used in many previous articles <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">24]</ref> in particular to solve auto-reducible problems. We describe the method in the context of the generation of the models of D a DNF formula.</p><p>We define a tree T D whose nodes are the assignments τ over variables {x 1 , . . . x k } such that there is a model σ of D which is compatible with τ . The children of a node labeled by τ are the partial assignments τ defined over {x 1 , . . . x k+1 } which are compatible with τ .</p><p>The leaves of T D are the models we want to generate, therefore a depth first traversal visits all leaves and thus outputs all solutions. Since a path from the root of the tree is of size n, it is enough to be able to find the children of a node in polynomial time to obtain a polynomial delay. Hence the Flashlight Method has a polynomial delay if and only if the following extension problem is in P: given τ over {x 1 , . . . x k } is there σ a model of D compatible with τ ?</p><p>The extension problem for a DNF is very simple to solve: compute the formula D[τ ] and decide whether it is satisfiable in time O( D ). This yields an enumeration algorithm with delay O(n D ). The delay can be improved by using the fact that we solve the extension problem several times on very similar instance as it has been done for other problems <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b16">17]</ref> such as the enumeration of the models of a monotone CNF. Proof. We use the previous algorithm which does a depth first search in T D . When it visits the node τ , we need to decide whether D[τ ] is satisfiable which is equivalent to testing whether it has a non falsified term. To speed-up the flashlight search, we use a data structure to decide quickly this problem and we need to guarantee that it can be updated fast enough when the tree is traversed.</p><p>For each term C, we store an integer f C which represents how many literals of the term are falsified by the current partial assignment. A term C is valid when f C = 0. For each literal l, we store the list of terms which contain the literal. We also store an integer vc for valid terms, which counts how many terms are not falsified by the current partial assignment.</p><p>At the beginning of the algorithm, all f C are set to 0 and vc = m. Then visiting a child τ of τ corresponds to choosing the value of some variable x k . If x k is set to 0 then for each term C containing x k , f C is incremented. The number of terms such that f C is changed from 0 to 1 is subtracted to vc. If x k is set to 1, then the same is done for xk . The fact that D[τ ] is satisfiable is equivalent to vc &gt; 0. Remark that going up the tree when backtracking works exactly as going down, but the variables f c are decremented and vc is incremented instead.</p><p>As a consequence, the complexity of the algorithm over a path in the tree is O( D ) since for each term C, the variable f C will be modified |C| times. When the algorithm goes down the tree it may first set x k to 0 and fails, but then it sets x k to 1 and goes down. Hence the cost of going down to a leaf is at most twice the cost of following the path to the leaf. Since between two outputted solutions, the algorithm follows one path up and one down, the delay is in O( D ).</p><p>This last algorithm has a delay linear in the size of the formula, however the size of the formula can be extremely large with regards to the size of a model. In the next sections we will try reduce or eliminate the dependency of the delay in the size of the input either for particular DNF formulas or by relaxing the notion of delay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Enumerating models of k-DNF</head><p>A term C is a k-term if and only if |C| ≤ k. A DNF is a k-DNF if all its terms are k-terms. In this section, we present an algorithm to enumerate the models of a k-DNF with a 2 O(k) delay. The idea is to select a k-term and use its 2 n-k models to amortize more costly operations. More precisely, we prove the following: Theorem 5. The models of a k-DNF with n variables can be enumerated with precomputation in O(n) and O(k 2 2 5k ) delay.</p><p>To explain our algorithm, we need first to introduce notations. Let H(p) = -p log(p) -(1p) log(1 -p) be the binary entropy. From the following classical inequality (see <ref type="bibr" target="#b10">[11]</ref>):</p><formula xml:id="formula_1">k i=0 n i ≤ 2 nH(k/n) ,</formula><p>we get for k ≤ n/2: Lemma 6. The number of k-terms on n variables is at most 2 nH(k/n)+k .</p><p>Let D be a DNF-formula on variables X. Assume wlog that X is ordered with &lt;. Given a term C ∈ D, we denote by</p><formula xml:id="formula_2">1 C : var(C) → {0, 1} the only model of C, that is, for every ∈ C, 1 C (x) = 1 if = x and 1 C (x) = 0 if = ¬x.</formula><p>If y ∈ var(C), we denote by</p><formula xml:id="formula_3">0 y C : {z ∈ var(C) | z ≤ y} → {0, 1} the assignment defined by 0 y C (z) = 1 C (z) for z &lt; y and z ∈ var(C) and 0 y C (y) = 1 -1 C (y). For example, if C = x 1 ∧ x 2 ∧ ¬x 3 , we have 1 C = {x 1 → 1, x 2 → 1, x 3 → 0} and 0 x 1 C = {x 1 → 0}, 0 x 2 C = {x 1 → 1, x 2 → 0} and 0 x 3 C = {x 1 → 1, x 2 → 1, x 3 → 1}.</formula><p>These assignments naturally induce a partitioning of the model of a DNF: Lemma 7. Given a DNF D and a term C ∈ D, we have: We start by picking a k-term C ∈ D. It is easy to see that for every τ : X \ var(C) → {0, 1}, we have τ ∪ 1 C |= D. Thus, enumerating sat(D, 1 C ) can be done very efficiently with a O(1) delay by simply enumerating 2 X\var(C) using a Gray code. Observe that the precomputation time boils down to choosing a term and outputting its first solution which can obviously be done in time O(n) as stated in the theorem.</p><formula xml:id="formula_4">sat(D) = sat(D, 1 C ) y∈var(C) sat(D, 0 y C ).</formula><p>Between the output of two solutions of sat(D, 1 C ), we spend some time to precompute D[0 y C ] for every y ∈ var(C). Since |var(C)| ≤ k, we have to compute at most k such DNF. Moreover, to compute each one of them, we have to inspect every term of D and every variable of these terms. Since each term has at most k variables, we need O(kM ) steps to precompute all terms in D[0 y C ] for one y ∈ var(C). We then remove all copies but one of the same terms. This can be done in time O(kM 2 ) by comparing the terms pairwise. In the end, we need O(k 2 M 2 ) steps to precompute D[0 y C ] for every y ∈ var(C). Let A be a constant such that this precomputation can be done in time A • k 2 M 2 steps at most.</p><p>Assume that between the output of two solutions of sat(D, 1 C ), we allow dA steps for this precomputation (the value of d will be fixed later depending on our needs). Since |sat(D, 1 C )| ≥ 2 N -k , this gives us a total amount of 2 N -k dA steps for this precomputation. Thus, if 2</p><formula xml:id="formula_5">N -k dA &gt; Ak 2 M 2 , that is, if 2 N -k d &gt; k 2 M 2<label>(1)</label></formula><p>we have enough time to compute D[0 y C ] for every y ∈ var(C). If this is the case, then we do the precomputation, finish the enumeration of sat(D, 1 C ) and then recursively start the enumeration of 0 y C × D[0 y C ] for each y ∈ var(C). The number n of variables of D[0 y C ] has of course decreased but we can still allow for dA steps of extra computation between the output of two solutions.</p><p>It is clear that as long as ( <ref type="formula" target="#formula_5">1</ref>) is true, we can output solutions of D with delay dA. We may however have a problem if, at some point in the recursion, the DNF D we are using to compute solutions of D may have too few variables making (1) false. We are going to pick d sufficiently large so it never happens.</p><p>Since we only consider k-DNF, we know by Lemma 6 that at each step of the recursion with n unassigned variables, the number m of terms verifies m ≤ M 0 := 2 nH(k/n)+k . Our goal is thus to find d such that for every n ≥ 2k:</p><formula xml:id="formula_6">2 n-k d ≥ k 2 M 2 0</formula><p>By rearranging the terms so that k is in factor in the exponent and denoting x = k/n, we conclude that if the following holds then ( <ref type="formula" target="#formula_5">1</ref>) is true when k ≤ n/2:</p><formula xml:id="formula_7">d ≥ k 2 2 k((2H(x)-1)/x+3)<label>(2)</label></formula><p>It is easy to compute the maximum of the function (2H(x) -1)/x + 3 over [0, 1/2]. We obtain a bound of 5 at x = 1/2. Hence for all k ≤ n/2, if d ≥ k 2 2 5k then ( <ref type="formula" target="#formula_5">1</ref>) is true at each recursive call. When n &lt; 2k, we enumerate the models using the algorithm of Theorem 4. It gives a delay of D ≤ k2 3k since by applying Lemma 6 for n = 2k, we have that that the number of k-terms with 2k variables is at most 2 2kH(1/2)+k = 2 3k . Thus, a k-DNF with less than 2k variables has size at most k2 3k .</p><p>The O(k 2 2 5k ) delay of the previous algorithm could be improved to O(k 2 2 3k ) by using a more clever algorithm to detect duplicated terms when computing D[0 y C ]. This operation can easily be done in time O(k 2 M log(M )) by sorting the terms before eliminating duplicates and even in time O(k 2 M ) by using a trie with relevant pointers allowing to test if a term is already in the trie in time O(k). Both solutions would make the presentation of the proof heavier so we chose to present this simplified version since the delay is also 2 O(k) .</p><p>Theorem 5 gives an algorithm to enumerate the models of a k-DNF with delay d = 2 O(k) and O(n) precomputation. A pseudo code for this algorithm is given in the appendix (Algorithm 1). It has constant delay for constant k and it is in strong polynomial delay (polynomial in n the size of a solution) for terms of size O(log(n)). We conjecture however that the models of a general DNF cannot be enumerated with strong polynomial delay.</p><p>We can use Algorithm 1 to significantly improve a result on the enumeration of models of first order formula with free second order variables. In <ref type="bibr" target="#b8">[9]</ref>, Theorem 10, it is proved that the models of a Σ 1 formula (a single block of existential quantifiers followed by a quantifier free formula) with free second order variables can be enumerated in polynomial delay using a method similar to Proposition 2. Moreover, this problem is shown to be equivalent to the enumeration of models of a k-DNF. As a corollary of Theorem 5, the enumeration of models of a Σ 1 formula can be done in constant delay. It is very surprising since it is the same complexity as for Σ 0 (quantifier free formulas), the first level of the hierarchy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Average delay of enumerating the models of DNF</head><p>In this section, we analyze the average delay of the Flashlight method, using appropriate data structures, to show it is better than the delay. The idea is to amortize the cost of maintaining the formula D[τ ] during the traversal of the tree over all models of D[τ ] in the spirit of <ref type="bibr" target="#b24">[25]</ref>. To do that we exhibit a relation between the number of models of a DNF and its number of terms. For any class of DNF for which it is possible to guarantee, for all partial assignments τ , that the number of models of D[τ ] is large enough with regard to |D[τ ]|, we obtain a good average delay. We then improve the delay of the Flashlight method by using a different branching (in the spirit of Algorithm 1) which guarantees that the number of terms decreases sufficiently but not too much in some branch which allows us to amortize the cost of branching.</p><p>The following lemma shows that DNF whose terms share a model have many models. It applies directly to any monotone formula, since the all one assignment is always a model of a (positive) monotone term. Proof. Let α be a model of the m terms of the DNF formula D and x be a variable of D. We claim that x appears only negatively or positively in D. Indeed, assume w.l.o.g that that α(x) = 1 and that x ∈ C 1 and ¬x ∈ C 2 . Thus α |= C 2 which contradicts the definition of α. We construct a monotone DNF D by replacing every variable that appears only negatively in D by positive occurrences. There is an obvious one-to-one correspondence between the models of D and the models of D. Now, for C ∈ D , let m C be the model of C defined as m C (x) = 1 if and only if x ∈ var(C). Since D is monotone, it is clear that m C = m C if and only if C = C , which gives m distinct models for D and thus for D.</p><p>Using the previous lemma, we prove that a DNF has at most a number of terms which is quadratic in its number of models. Lemma 9. A DNF formula with m non empty distinct terms has at least m 1/2 models.</p><p>Proof. Let α be a model of the DNF D, we denote by r α the number of terms which are compatible with α: |{C |= α | C ∈ D}|. It corresponds to the number of redundancies of α, that is the number of terms which has it as model (and the number times it is generated in the algorithm of Proposition 3). Now, let us denote by A the average of r α over all models. By definition, we have</p><formula xml:id="formula_8">|sat(D)| = C∈D |sat(C)| A .</formula><p>Since A is an average, there is an α such that r α ≥ A. It means that at least A distinct terms are compatible with α and then by Lemma 8 these terms have at least A distinct models. In the previous proof, the inequalities are not tight and we may certainly improve the result. In particular, we can avoid to bound C∈D |sat(C)| by m. We then get a lower bound on the number of models of m 1/2+c/ log(n) for some constant c. It improves the delay of the next algorithm only for superpolynomial m and require some additional computations, hence we chose to state Lemma 9 with the simpler √ m bound. The quality of the algorithms presented in this section is directly connected to this relation between the number of terms and the number of solutions of a DNF. Any improvement would have direct consequences on the complexity of enumerating the models of a DNF. Question 10. What is the best k such that we can guarantee that a DNF with m terms has at least m k solutions? We are not aware of any results concerning this fact. We only know that 1/2 ≤ k ≤ log 3 <ref type="bibr" target="#b1">(2)</ref>. The lower bound is Lemma 9 and the upper bound easily follows from the DNF having all terms of size at most n on n variables has 2 n models and 3 n terms.</p><p>To improve the average delay of the flashlight method, we need to use an adapted data structure. In particular we need that, when considering some inner node D[τ ] of T D , the cost to process it is in O(|D[τ ]|) and not in O(m). In particular, we need to guarantee that there are no redundancy of terms in the structure representing D[τ ] and that we can maintain it efficiently, that is why we use a trie.</p><p>Theorem 11. The models of a DNF can be enumerated with average delay O(n 2 √ m) and polynomial space.</p><p>Proof. We maintain the formula D[τ ] when we traverse T D using the trie containing its terms as explained in Section 2. On a node τ we can decide quickly whether D[τ ] has a model and we can maintain D[τ ] efficiently without redundancy of terms. In the flashlight search, we will fix the variables following their order x 1 , . . . , x k . Hence, visiting a child τ of τ corresponds to setting the value of some variable x k with all variables x i with i &lt; k already fixed. If we set x k to 0 then we need to remove the subtree under the root of the trie, with first node x k . Then we remove the subtree under the root of the trie, with first node xk , and insert back all elements in this subtree into the trie without the first node xk . The complexity of the latter is in O(|D[τ ]|n) since the number of terms is bounded by |D[τ ]| (no term appear several times in the trie). To set x k to 1, we do the same operation where we exchange the roles of x k and xk . To be able to go up in the tree during the flashlight search, we must restore the trie to its previous state. To do that in time O(|D[τ ]|n), it is enough to store the list of elements which have been removed or added in the trie when going down the same edge and to reverse the operations. The additional memory used during the algorithm is bounded by O(mn 2 ).</p><p>We now compute the average delay, that is the total time of the algorithm divided by the number of outputted models. To do that we distribute the time spent on each inner node A leaf receives a cost of at most n √ m for each of its n ancestors, hence the time per leaf (or the average delay) is bounded by O(n 2 √ m).</p><p>We now improve the way we choose the next variable on which we branch in order to improve the delay. The idea is to branch on variables so that the recursion tree kept as balanced as possible. We use the following lemma: Lemma 12 (( )). Let D be a DNF formula with m terms. Let m 0 and m 1 be the number of terms of D[x → 0] and D[x → 1] respectively. Then m 0 + m 1 ≥ m/2. Theorem 13. The models of a DNF can be enumerated with average delay O(n √ m) and polynomial space.</p><p>Proof. Instead of branching on a variable x 1 in the flashlight search, the branching will have the structure of a potentially large comb, similar to the one used in Algorithm 1. We define a sequence of partial assignments α i , α i with 0 ≤ i ≤ n. The assignments α i and α i are defined over the variables {x 1 , . . . , x i } and they are compatible with α i . The assignment α 0 is the empty assignment, α i is the extension of α i-1 by x i → (x i ) and α i is the extension by</p><formula xml:id="formula_9">x i → 1 -(x i ). We write m i = |D[α i ]| and m i = |D[α i ]|,</formula><p>these numbers are the number of distinct terms in D[α i ] and D[α i ] respectively. Let us now define the assignment , given D[α i-1 ], (x i ) is chosen to maximize m i .</p><p>By Lemma 12, we have that m i ≥ m i-1 /4 that is the number of terms is divided by at most 4 at each step. Since m 0 = m and m n ≤ 1, then there is a i 0 such that</p><formula xml:id="formula_10">m i 0 ∈ [m/8, m/2].</formula><p>We use the same method as in Theorem 11 to maintain the trie representing D[τ ]. During the successive construction of D[α i ] and D[α i ], each term of D will be removed or inserted twice at most in the trie. Hence the total cost of this branching and of the computation of the m i and m i is in O(mn), that is as fast as a binary branching. We assign this cost to the solutions in the branch α i 0 . By construction, D[α i 0 ] has more than m/4 terms, hence it has by Lemma 9 at least m/8 models. Therefore the cost charged to the leaves is n √ m. Now let us analyze how much a leaf is charged. Remark that in the path from the root to the a leaf, not all nodes charge the leaf. By construction the nodes which charge the leaf have less than half the terms of the previous node which has charged the leaf. Hence the complexity charged to a node is bounded by</p><formula xml:id="formula_11">i n m/2 i = n √ m i 1/2 i/2 . Since i 1/2 i/2</formula><p>is bounded by a constant, the cost of a leaf and thus the average delay is O(n √ m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Enumerating models of monotone DNF</head><p>When the underlying formula is monotone, that is it does not contain any negated literal, we can enumerate the models with a delay polynomial in the number of variables only. However, our current techniques need an exponential memory to work.</p><p>Theorem 14. There is an algorithm that given a monotone DNF with n variables and m terms, enumerate the models of D with preprocessing O(nm 2 ) and delay O(n 3 ). The space needed for this algorithm is linear in the number of solutions of D.</p><p>Proof. We start by removing from D every term C such that there exists C ∈ D with C ⊆ C . Observe that it does not change the models of C since C ⇒ C. This preprocessing phase takes O(nm 2 ) since comparing two terms may be done in time O(n). Let D be the resulting minimized monotone DNF. The algorithm then work as follows: arbitrarily order the terms of D = {C 1 , . . . , C p } and its variables X = {x 1 , . . . , x n }. We initialize a trie T that will contain the solutions that we have already enumerated, that is, in the following algorithm, each time we output a solution, we store it in T , so we can check in time O(n) if a solution has already been enumerated.</p><p>We now enumerate the solutions as follows: we start by enumerating all solutions of C 1 . Then, we proceed by induction: once we have enumerated all solutions of</p><formula xml:id="formula_12">D i = C 1 ∨ • • • ∨ C i ,</formula><p>we enumerate all solutions of C i+1 that are not solutions of D i until i = p. Once we are done, we have, by induction, enumerated all models of D.</p><p>We claim that we can do this with delay O(n 3 ) using a classical reverse search method. Let Y = (y 1 , . . . , y m ) be the variables that are not in var(C i ), ordered following the natural order we have on X. The solutions of C i are in one-to-one correspondence with 2 Y as follows: given S ⊆ Y , we have a solution m S defined as m S (x) = 1 if x ∈ var(C i ) ∪ S and m(x) = 0 otherwise. We explore the solution of C i by following a tree A whose nodes are labeled with m S for every S ⊆ Y . The root of the tree is label-led by m ∅ and for every S, the unique predecessor of node m S is m S with S = S \ max(S). In other words, given S, the successors of m S are m S∪{x k } for k &gt; max(S).</p><p>We enumerate the solution by following the structure of A. We start from the root of A, that is, we enumerate m ∅ . We claim that m ∅ has not yet been enumerated. Indeed, assume toward a contradiction that m ∅ |= C j for j &lt; i. Then since D is monotone, it means that C j ⊆ C i which is absurd since D is minimized. Thus, the first model we enumerate is guaranteed to be fresh. Now we follow the structure of A by depth first search. When we visit a node of A label-led with m S , we start by checking in the trie if m S has already been enumerated. It can be done in O(n). If m S has not been enumerated, then we output it and keep on going down in the tree A. If m S has been enumerated then we can discard the whole subtree of A rooted in m S . Indeed, by definition, every solution m S in this subtree verifies S ⊇ S. Thus, if m S has been enumerated then m S |= D i-1 and since D i-1 is monotone, m S |= D i-1 , so m S has already been enumerated.</p><p>Thus, if m S has already been enumerated, we backtrack in the tree to the next node in A that has not yet been explored and that is not in the discarded subtree. This can be done in O(1) if we maintain in each visited node a pointer to the first ancestor that has an unexplored child.</p><p>We claim that we will visit at most n 2 nodes of A before finding a new solution or realizing that we have enumerated all solutions of D i and should proceed with C i+1 . Indeed, by the previous argument, we only have to check the maximal unexplored nodes of A since if a solution has already been enumerated, so have all its descendants. Now, each node of A has at most n children and A is of depth n. Hence, during the depth-first search, we will have at most n 2 such maximal nodes (at most n per level). Since checking if a solution is already in the trie can be done in O(n), our algorithm will have delay at most O(n 3 ). By using a better data structure to store the solutions and another organization of the models of a term we should bring the delay down to O(n 2 ) or better, but we leave that for further researchs. Moreover, observe that, using the reduction in the proof of Lemma 8 to the monotone case, the algorithm described in Theorem 14 also works if every variable appears only positively or negatively in all terms of the formula.</p><p>We now consider algorithms with a good average delay for enumerating the models of a monotone DNF formula. This allows to obtain a better delay that the previous theorem, while only using a polynomial space. First, recall that monotone DNF formulas have at least as many models as terms because of Lemma 8. Hence, using the algorithm of Theorem 13 on a monotone formula, we obtain the following theorem.</p><p>Theorem 15. The models of a monotone DNF can be enumerated with average delay O(n) and polynomial space.</p><p>To improve the bound on the average delay using a similar algorithm, we should either guarantee a better relationship between the number of terms and solution or we should reduce the complexity of maintaining the trie during the algorithm. Note that the formula with all positive terms has 2 n models but also 2 n terms. If we further assume that no term are redundant, that is there are no C 1 , C 2 such that C 1 ⊆ C 2 , then the formula with all terms of size n -1 has n + 1 models and n terms. Even when m is large, the relationship is almost linear: the formula with all terms of size n/2 has 2 n /2 models and O(2 n / √ n) terms. Hence, to improve the average delay, it seems hard to rely on a better bound on the number of solutions. However, the cost to deal with the trie can be reduced, as long as m is not too large as shown in the next theorem.</p><p>Theorem 16. The models of a monotone DNF can be enumerated with average delay O(log(n)(log(m)+ log(n)) and polynomial space.</p><p>Proof. First remark that when a term contains n -k variables, then it has 2 k models. Hence, in the algorithm of Theorem 13, when we compute the cost distributed over all solutions of D[τ ], we can make the following adjustment. We consider two cases. First say that D[τ ] has n τ variables and assume there is a term with n τ -k variables such that k &gt; log(|D[τ ]|) + 2 log(n). Then D[τ ] has at least 2 k models which is larger than |D[τ ]|n 2 . As a consequence, the complexity which is charged to the leaves is only 1/n and the total cost charged to a leaf by branching steps of this king is bounded by 1. Now assume that for some partial assignment τ , all terms in D[τ ] contain more than n τ -k literals, with k = log(|D[τ ]|) + 2 log(n). Then we change the encoding of the formula: each term of D is represented by its complementary. Since the formula is monotone, we need only to store</p><p>The complementary terms are stored in a trie where the children of a node are organized in an AVL tree instead of an ordered list. All operation can be done on this trie in time O(log(n) * k), where k is the size of the object to insert. The algorithm works as the one in Theorem 13 on this new data structure with the following difference in branching. When x i is set to 1, we remove the subtree under the roof with first node x i and add back all elements without x i . When x i is set to 0, we keep only the subtree under the roof with first node x i and remove the rest.</p><p>The cost of a step is now bounded by O(|D[τ ]|k log(n)) and the cost charged to the leaf is bounded by k log(n), that is by (log(m) + 2 log(n)) log(n) which proves the proposition.</p><p>A better data structure can be used in the previous theorem: a trie where the children of a node are stored in an array of size n. Then the operations are in time O(k) if we accept that we have an arbitrary supply of initialized memory. The average delay then drop to O(log(n) + log(m)) and we conjecture that there is a good data structure allowing such delay without needing initialized memory.</p><p>The result on monotone DNFs can easily be transferred to a problem studied in <ref type="bibr" target="#b16">[17]</ref>: the generation of all unions of given subsets. An instance {s 1 , . . . , s m } is a set of m subsets of <ref type="bibr">[1, n]</ref> and we want to generate all distinct unions of these s i . The delay of the algorithm in <ref type="bibr" target="#b16">[17]</ref> is O(nm), using a flashlight search algorithm similar to the algorithm of Theorem 4. Among the enumeration problems captured by the framework of saturation by set operators <ref type="bibr" target="#b16">[17]</ref> it is the only one not proved to be in strong polynomial delay and it is also proved to be at least as hard to enumerate as the models of a monotone DNF.</p><p>If there are m distinct subsets in the instance, these subsets are also solutions then we have an equivalent of Lemma 8. Moreover, if we restrict a set of subsets by fixing an element, we have an inequality similar to Lemma 12. Hence we obtain an algorithm to enumerate union of sets with an average delay O(n) using the branching scheme of Theorem 13. However, the algorithm of Theorem 14 do not seem usable for generating the union of sets, leaving the question of obtaining an algorithm with strong polynomial delay open.</p><p>have the only allowed value by C. The delay between two solutions is constant since we only look the value of σ(i) in an array and switch the value of a register between two outputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Proof of Proposition 2</head><p>Proof. As explained in Proposition 1, a term C ∈ D, sat(C) can be enumerated in constant delay using Gray code enumeration. The terms of D are indexed from C 1 to C m in an arbitrary order. During the algorithm, the state of the enumeration by Gray Code for each term is maintained so that we can query in constant time the next model of a given term. At each step, the algorithm does a loop from C 1 to C m . For a term C i the next model is generated and the algorithm tests whether it is a model of some C j with j &gt; i. If not, it is outputted. If a term has no more models we skip it.</p><p>By this method, we guarantee that each model is outputted when generated by the term of largest index it satisfies, hence all models are generated and without repetitions. Moreover, at each step of the algorithm, the model given by the last term which has still models will be outputted, therefore the delay is bounded by the time to execute one step of the algorithm.</p><p>The cost of the generating new models at each step is bounded by O(m) since each solution is produced in O(1). The cost of testing whether a model satisfies some term of larger index is bounded by D and it is done at most m times before outputting a solution which implies that the delay is O(m D ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Proof of Proposition 3</head><p>Proof. As in the previous algorithm, we run a simple enumeration algorithm on each term and we maintain their states so that we can easily query the next model of a term. We chose to enumerate the models of the terms in lexicographic ascending order (for some arbitrary order of the variables), which can be done with delay O(n) for each term.</p><p>The first model of each term which has not yet been outputted is stored in a trie; if all models of a term have been outputted then nothing is stored for this term. Moreover, for each model in the trie, we maintain the list of terms from which it has been generated.</p><p>At each step of the algorithm, the smallest model α is found in the trie, then outputted and removed from the trie all in time O(n). Then we use the list of terms which had α as a model, to generate for each of them their next model and add it to the trie in time O(mn) since the insertion can be done in time O(n) and the number of new models is bounded by O(m). The delay of this algorithm is thus bounded by O(mn). By induction, we prove that at each step the smallest non outputted model is outputted, which implies that all models are outputted without repetitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Pseudocode for Theorem 5 E Proof of Lemma 12</head><p>Proof. Denote by n 0 the number of terms of D which contain x, n 1 the number which contain x and n the number which do not contain variable x. The terms of D[x → 0] are the terms of D which contains the literal x or which does not contain the variable x. Remark that fixing the variable x </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Proposition 4 .</head><label>4</label><figDesc>The models of a DNF formula D can be enumerated with delay O( D ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Proof.</head><label></label><figDesc>The right-to-left inclusion is clear as sat(D, τ ) ⊆ sat(D) for any τ . Moreover, these unions are clearly disjoint since for every y, z ∈ var(C), y &lt; z, we have 0 z C (y) = 0 y C (y) and 1 C (y) = 0 y C (y). For the left-to-right inclusion, let τ ∈ sat(D). If τ 1 C , then τ ∈ sat(D, 1 C ). Otherwise, let y be the smallest variable of var(C) such that τ (y) = 1 C (y). Then we have τ 0 y C . Proof (of Theorem 5). Given a k-DNF D on variables X, we use Lemma 7 to enumerate sat(D). We denote by X = var(D), N = |X| and M = |D|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Lemma 8 .</head><label>8</label><figDesc>A DNF formula D with m distinct terms which have a common model has at least m models.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Hence we have |sat(D)| ≥ A. Now, multiplying both equations and observing the fact that |sat(C)| ≥ 1 for every C ∈ D, we obtain |sat(D)| 2 ≥ C∈D |sat(C)| ≥ m.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>D[τ ] to the models in the leaves of the subtree rooted at D[τ ]. As we have explained, the time spent on the node D[τ ] (to do the branching on some variable x k ) is in O(|D[τ ]|n). By Lemma 9, we have that D[τ ] has at least |D[τ ]| models. The time spent in D[τ ] is distributed uniformly over all leaves of the tree rooted at D[τ ]. Hence each leaf receive at most n |D[τ ]| = n|D[τ ]|/ |D[τ ]|.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 1 :</head><label>1</label><figDesc>Enumerates the models of k-DNF with delay 2 O(k) . Data: A k-DNF-formula D begin if D = ∅ then return ∅ ; if D = {C} then Enumerates the models of C ; else d ← Ak 2 2 kα ; Pick C ∈ D ; Every d steps of computation in the next block, output a new model of D[1 C ] ; begin for y ∈ var(C) do D y ← D[0 y C ] ; for y ∈ var(C) do Recursively enumerates 0 y C × sat(D y );to 0 cannot make two terms equal except when one contains x and the other does not contain the variable x. Hence m 0 ≥ max(n 0 , n ). Similarly,m 1 ≥ max(n 1 , n ). Since max(a, b) ≥ (a + b)/2, we have m 0 + m 1 ≥ (n 0 + n )/2 + (n 1 + n )/2 ≥ (n 0 + n 1 + n )/2. By definition m = n 0 + n 1 + n , then we have proved the lemma.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Overview of the results. In this table, D is a DNF, n its number of models and m its number of terms. New contributions are annotated with ( ).</figDesc><table><row><cell>Class</cell><cell>Delay</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proof of Proposition 1</head><p>Proof. The models of C on variables X are exactly the assignments of the form 1 C ∪ τ for any τ : X \ var(C) → {0, 1}. Enumerating the models of C intuitively boils down to enumerating all assignments on variables X \ var(C). We use a Gray code to do this in constant time.</p><p>More precisely, we represent a model of C in n registers R 1 , . . . , R n where R i holds the value of x i in this model. We initialize the registers such that</p><p>∈ var(C). Now let k = |X \ var(C)| and σ : {1, . . . , k} → {1, . . . , n} be such that X \ var(C) = {x σ(1) , . . . , x σ(k) } with σ(1) &lt; • • • &lt; σ(k). We start by storing the values of σ in an array of size k. We then execute Output(1, n) which outputs the first model of C. After that, we run a Gray code enumeration on the subsets of a set of size k. For each new element generated, the Gray code algorithm flips a bit at some position i. We thus switch the bit of R σ(i) and call Output <ref type="bibr">(1, n)</ref>. This generates all solutions of C since all possible values of the variables not in C are set, while the other</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A circuit-based approach to efficient enumeration</title>
		<author>
			<persName><forename type="first">Antoine</forename><surname>Amarilli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Jachiet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Mengel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">44th International Colloquium on Automata, Languages, and Programming, ICALP 2017</title>
		<meeting><address><addrLine>Warsaw, Poland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">July 10-14, 2017. 2017</date>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="page" from="1" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Enumeration of minimal stoichiometric precursor sets in metabolic networks</title>
		<author>
			<persName><forename type="first">Ricardo</forename><surname>Andrade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Wannagat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cecilia</forename><forename type="middle">C</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vicente</forename><surname>Acuña</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Marchetti-Spaccamela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paulo</forename><forename type="middle">V</forename><surname>Milreu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leen</forename><surname>Stougie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-France</forename><surname>Sagot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms for Molecular Biology</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Reverse search for enumeration</title>
		<author>
			<persName><forename type="first">D</forename><surname>Avis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fukuda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="46" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Mso queries on tree decomposable structures are computable with linear delay</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Bagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Computer Science Logic</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="167" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient generation of stable planar cages for chemistry</title>
		<author>
			<persName><forename type="first">Dominique</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franck</forename><surname>Quessette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>Reinhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Strozecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandrine</forename><surname>Vial</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Experimental Algorithms</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="235" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Computing and listing st-paths in public transportation networks</title>
		<author>
			<persName><forename type="first">Kateřina</forename><surname>Böhmová</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luca</forename><surname>Häfliger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matúš</forename><surname>Mihalák</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Pröger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gustavo</forename><surname>Sacomoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-France</forename><surname>Sagot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="600" to="621" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Linear delay enumeration and monadic second-order logic</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Courcelle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2675" to="2700" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On generating all solutions of generalized satisfiability problems</title>
		<author>
			<persName><forename type="first">Nadia</forename><surname>Creignou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Jacques</forename><surname>Hébrard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Informatique théorique et applications</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="499" to="511" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Enumeration complexity of logical query problems with second-order variables</title>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Strozecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LIPIcs-Leibniz International Proceedings in Informatics</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Naive infinite enumeration of context-free languages in incremental polynomial time</title>
		<author>
			<persName><forename type="first">Christophe</forename><surname>Costa Florêncio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonny</forename><surname>Daenen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Ramon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dries</forename><surname>Van Dyck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. UCS</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="891" to="911" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Parameterized complexity theory</title>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Flum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Trie memory</title>
		<author>
			<persName><forename type="first">Edward</forename><surname>Fredkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="490" to="499" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Combinatorial algorithms, part 1, volume 4a of the art of computer programming</title>
		<author>
			<persName><forename type="first">E</forename><surname>Donald</surname></persName>
		</author>
		<author>
			<persName><surname>Knuth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The art of computer programming</title>
		<author>
			<persName><forename type="first">Donald</forename><surname>Ervin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Knuth</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Pearson Education</publisher>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On deterministic approximation of dnf</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boban</forename><surname>Veličković</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4-5</biblScope>
			<biblScope unit="page" from="415" to="433" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Mary</surname></persName>
		</author>
		<title level="m">Énumération des Dominants Minimaux d&apos;un graphe</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>Université Blaise Pascal</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient enumeration of solutions produced by closure operations</title>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Mary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yann</forename><surname>Strozecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">33rd Symposium on Theoretical Aspects of Computer Science</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient algorithms for dualizing large-scale hypergraphs</title>
		<author>
			<persName><forename type="first">Keisuke</forename><surname>Murakami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takeaki</forename><surname>Uno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">170</biblScope>
			<biblScope unit="page" from="83" to="94" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Generating linear extensions fast</title>
		<author>
			<persName><forename type="first">Gara</forename><surname>Pruesse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Ruskey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Bounds on backtrack algorithms for listing cycles, paths, and spanning trees</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Read</surname></persName>
		</author>
		<author>
			<persName><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="237" to="252" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Enumeration for fo queries over nowhere dense graphs</title>
		<author>
			<persName><forename type="first">Nicole</forename><surname>Schweikardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Vigny</surname></persName>
		</author>
		<idno type="DOI">10.1145/3196959.3196971</idno>
		<idno>doi:10.1145/3196959. 3196971</idno>
		<ptr target="http://doi.acm.org/10.1145/3196959.3196971" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, SIGMOD/PODS &apos;18</title>
		<meeting>the 37th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, SIGMOD/PODS &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="151" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Enumerating with constant delay the answers to a query</title>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Database Theory</title>
		<meeting>the 16th International Conference on Database Theory</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="10" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Enumeration complexity and matroid decomposition</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Strozecki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">7, 2010</date>
			<pubPlace>Paris</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">On enumerating monomials and other combinatorial structures by polynomial interpolation</title>
		<author>
			<persName><forename type="first">Yann</forename><surname>Strozecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory of Computing Systems</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="532" to="568" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Constant time enumeration by amortization</title>
		<author>
			<persName><forename type="first">Takeaki</forename><surname>Uno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Algorithms and Data Structures</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="593" to="605" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Constant time generation of free trees</title>
		<author>
			<persName><forename type="first">Alan</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Richmond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brendan</forename><forename type="middle">D</forename><surname>Odlyzko</surname></persName>
		</author>
		<author>
			<persName><surname>Mckay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="540" to="548" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
