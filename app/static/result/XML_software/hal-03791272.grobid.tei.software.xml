<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Speeding Up Graph-Relational Queries in RDBMSs</title>
				<funder ref="#_6v6KCQv">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christos</forename><surname>Angelos</surname></persName>
							<email>angelos.anadiotis@oracle.com</email>
						</author>
						<author>
							<persName><forename type="first">FranÃ§ois</forename><surname>Anadiotis</surname></persName>
						</author>
						<author>
							<persName><roleName>Mhd</roleName><forename type="first">Yamen</forename><surname>GoasdouÃ©</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><forename type="middle">Manolescu</forename><surname>Haddad</surname></persName>
						</author>
						<author>
							<persName><surname>Manolescu</surname></persName>
						</author>
						<author>
							<persName><surname>Towards</surname></persName>
						</author>
						<author>
							<persName><surname>Anadiotis</surname></persName>
							<affiliation key="aff4">
								<orgName type="department">Work done while at Ecole Polytechnique</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">FranÃ§ois</forename><surname>GoasdouÃ©</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yamen</forename><surname>Mhd</surname></persName>
						</author>
						<author>
							<persName><surname>Haddad</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<email>ioana.manolescu@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Oracle Zurich</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">UniversitÃ© de Rennes</orgName>
								<address>
									<settlement>Irisa Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Speeding Up Graph-Relational Queries in RDBMSs</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">4FEEDA7BEB47DCAEEA4398F83EA4AD9C</idno>
					<idno type="DOI">10.1145/nnnnnnn.nnnnnnn</idno>
					<note type="submission">Submitted on 29 Sep 2022</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Graph data management</term>
					<term>query execution</term>
					<term>indexing</term>
					<term>query optimization</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>Graphs are ubiquitous in modern applications. They are used to represent financial data, social networks, etc. There are many ways to model and represent graphs, with the most popular being: the RDF model, adopted in the Semantic Web movement, and Property Graphs, increasingly studied and promoted by systems such as Neo4j [1], TigerGraph <ref type="bibr" target="#b2">[4]</ref> and Graphflow <ref type="bibr" target="#b10">[12]</ref>.</p><p>In our study, we focus on Property Graph Data Model <ref type="bibr" target="#b18">[20]</ref>. In this model, edges and vertices have labels and a set of properties. For example, a simple property graph contains vertices of labels "Person, University" and edges with "Follows, StudyAt" labels. Graph vertices and edges may also have properties, e.g., "Person" vertices may have (name, age, birthday). Thus, a graph database needs to store:</p><p>(1) The graph topology, representing the connectivity between nodes, typically stored as adjacency lists <ref type="bibr" target="#b8">[10]</ref>. Such lists allow accessing the neighbors of a vertex in constant time. <ref type="bibr" target="#b0">(2)</ref> Vertices and edges properties.</p><p>The more regular the data is, the more suitable a relational model is to representing and storing the data <ref type="bibr" target="#b16">[18]</ref>. On the contrary, if the graph is irregular, a key-value store may be used. In this paper, we consider the common case where the properties of nodes having a certain label are well-structured, thus they can be easily stored in a table. For example, all the properties of "Person" nodes might be stored in one table.</p><p>When storing a graph in an RDBMS, the topology is also stored in relations, allowing graph queries to be expressed in (possibly recursive) SQL. However, the performance of path traversals may be poor, because they translate into many join operators and thus significant random data access. Native GDBMSs aim at solving this issue by storing the graph in a way that entails fewer or no random accesses when traversing paths <ref type="bibr" target="#b13">[15]</ref>. However, reorganizing the data in this way may not be favorable to the performance of selectproject-join style queries.</p><p>In this work, we study ways to efficiently process both relationalstyle and traversal queries while storing the data in a relational format. Specifically, we investigate the impact of storing the topology of the graph in a form of "relational adjacency list", inspired by the CSR data structure previously proposed in <ref type="bibr" target="#b19">[21]</ref>. We call the resulting storage model, separating node properties from the graph edges, CSR Optimized Schema, or COS, in short.</p><p>This paper is organized as follows. Section 2 introduces a motivating example, then Section 3 discusses graph storage models in RDBMSs, following which Section 4 describes our COS proposal. Section 5 describes the SQL query rewriting method we need in order to adapt incoming queries to our storage. We then discuss some optimization issues involved in processing the queries resulting from our approach in Section 6, before presenting our experimental evaluation in Section 7 and concluding.</p></div>
<div><head n="2">MOTIVATING EXAMPLE</head><p>We consider graph data expressed using the property graph data model. In this model, a graph ğº is noted ğº = (ğ‘‰ , ğ¸) and consists of a set ğ‘‰ of vertices and a set ğ¸ of edges between these vertices. Furthermore, vertices and edges are labeled (or typed); a given label indicates with which set of properties (or attributes) a vertex or edge is described. A vertex is at least described with an id, while an edge is at least described with an id plus the ids of the vertices it connects.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> displays a small social network represented as a property graph. Vertices (circles) are labeled with Person, Message (Msg, in short), and Tag, while edges (arrows) are labeled with Created, Knows, Likes, and hasTag. Same-label vertices are described using the same properties, e.g., each Person vertex is described with an id, a name, and an age. Similarly, edges sharing the same label are described using the same set of properties, e.g., each Knows edge is described by the ids of the two vertices it connects, and since when they know each other. We will use ğ‘ 1 , ğ‘ 2 , ğ‘ 3 to refer to the Person nodes with the IDs 1, 2 and 3, respectively, and similarly use ğ‘š 1 for the Message with ID 1, ğ‘˜ 1 for the first Knows edge, etc. This graph states, for instance, that the ğ‘ 1 , whose name is Bob and age is 25, knows since 2012-01-01 the person ğ‘ 2 , whose name is Alice and age is 23. In addition, the person ğ‘ 1 authored on 2022-07-15 the message ğ‘š 1 , whose content is "A sunny day in Ibiza!", etc.</p><p>Storing Vertex and Edge Properties A popular way to store node and edge attributes coming from a property graph, in a relational schema, consists of creating one relation for each vertex label, and each edge label. For instance, for the graph shown in Figure <ref type="figure" target="#fig_0">1</ref>, Person vertices are stored in a Person(id, name, age) relation, Knows edges are stored in a Knows(id, src-id, dest-id, since) relation, etc, as illustrated in Figure <ref type="figure" target="#fig_1">2</ref>. The Knows edges are bidirectional in our example; accordingly, each of them is represented by two directed edges in the storage.</p><p>Sample Query An example of graph-relational query that we might encounter in such graphs is:</p><p>â€¢ Given a start person, denote their friends, and friends of friends (excluding the start person) as other person.  (1) Graph component, in this example, the traversal getting friends, and friends of friends; (2) Relational component, specifically, the relational operators such as filtering and aggregation.</p><p>We do not currently handle unbounded-length (recursive) path traversals. Their translation into recursive SQL queries may lead to inefficient execution; to mitigate this, we should probably integrate into our approach some form of structural index, e.g., <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b15">17]</ref>, that can simplify the query and make it easier to optimize and evaluate. This is part of our future work.</p></div>
<div><head n="3">GRAPH DATA LAYOUT</head><p>Various data structures have been used in GDBMSs to store the graph topology, on one hand, and the attributes of vertices and edges, on the other hand. We describe here the main data structures.</p></div>
<div><head n="3.1">Adjacency Matrix</head><p>An adjacency matrix ğ‘€ is a two dimensional matrix of size |ğ‘‰ | Ã— |ğ‘‰ | where ğ‘€ [ğ‘–] [ ğ‘—] has a value of 1 if and only if there exists an edge between vertex ğ‘– and vertex ğ‘—; otherwise, it is 0. The neighbors of a vertex ğ‘– are obtained by iterating over all the values stored in the ğ‘– th row of ğ‘€, i.e., in ğ‘‚ (ğ‘‰ ). Adjacency matrices are particularly useful for queries that require fast checks of whether two vertices are connected since this operation is performed in ğ‘‚ (1). However, as its storage requirements are quadratic to the size of the vertex set, the adjacency matrix is generally not considered efficient for storing sparse graphs, that is, those such that |ğ¸| â‰ª |ğ‘‰ | Ã— |ğ‘‰ |.</p></div>
<div><head n="3.2">Adjacency List</head><p>Adjacency lists <ref type="bibr" target="#b17">[19]</ref> reduce the storage costs of adjacency matrices by storing only the neighbors of every vertex in the graph. Specifically, an adjacency list is a linked list that contains the neighbors of every vertex, with storage requirements of ğ‘‚ (|ğ‘‰ | + |ğ¸|). However, the improvement in storage w.r.t. adjacency matrices comes at the price of increased cost for getting the neighbors of a given vertex ğ‘–, since the linked list traversal incurs random accesses. Cachefriendly solutions <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b20">22]</ref> have been proposed to amortize the linked list traversal problem by replacing the linked list of individual values with a linked list of fixed-sized arrays of values.</p></div>
<div><head n="3.3">Compressed Sparse Row</head><p>The compressed sparse row (CSR, in short) <ref type="bibr" target="#b7">[9]</ref> is a data structure used to store the topological information for sparse graphs. In a nutshell, CSR stores the adjacency matrix of a graph in a compressed fashion. It consists of three one-dimensional arrays offset, destination and edge defined as follows:</p><p>â€¢ the offset array stores for each source vertex ğ‘£ the position of its first neighbor in the destination array, â€¢ the destination array stores the destination vertices contiguously for every source vertex in the offset array, in the order of the source vertices in the offset array, â€¢ the edge array stores the edge id that connects vertex ğ‘£ from the offset array with vertex ğ‘‘ from the destination array.</p><p>When the data is in the CSR format, the neighbors of a vertex ğ‘£ are obtained by first probing the offset array to know where the neighbors of ğ‘£ are in the destination array start. </p></div>
<div><head n="4">CSR OPTIMISED SCHEMA (COS)</head><p>This section describes how we optimize the standard relational schema for property graphs in a CSR-like fashion, to support graph operators efficiently. The objectives of our design are as follows:</p><p>â€¢ The new design should be general and works on any RDBMS without the need for a system-specific modification and customization. This means that our approach should be easy to deploy in any RDBMS without any changes to the system's internals. â€¢ System users should not have to be aware of the underlying reorganization of the data, in particular, they should be able to query the graph as if vertex and edge attributes were stored in dedicated tables.</p><p>To reach our first objective, we replace each L(eid, src-id, dest-id, ep1,..., epn) edge relation that stores all the edges with label L (recall Section 2) into the two L-id-to-offset and L-destination tables defined as follows.</p><p>â€¢ L-id-to-offset(src-id, offset-start, length) stores every source vertex (src-id), as well as the offset at which starts its neighbours in the L-destination table (offset-start) and how many neighbours it has (length). â€¢ L-destination(vid, eid, ep1,..., epm, dest-id) stores for every offset the L-labeled edge (eid) together with its properties (ep1,..., epn), as well as its destination vertex (dest-id).</p><p>We remark that vertex relations remain unchanged with our CSR optimized schema, as the topological information of a graph is stored in edge relations only. Vertex properties can be accessed knowing the node id by joining with the corresponding vertex relation.</p><p>Figure <ref type="figure" target="#fig_2">3</ref> shows how the Knows relation "left" that follows from Figure <ref type="figure" target="#fig_0">1</ref> is replaced by the corresponding two relations of the CSR optimized schema.</p><p>To reach our second design objective, we introduce a query rewriting procedure which takes as an input a user query unaware Knows relation eid src-id dest-id</p><formula xml:id="formula_0">ğ‘˜ 1 ğ‘ 1 ğ‘ 2 ğ‘˜ 2 ğ‘ 2 ğ‘ 1 ğ‘˜ 3 ğ‘ 2 ğ‘ 3 ğ‘˜ 4 ğ‘ 3 ğ‘ 2 nid offset-start length ğ‘ 1 0 1 ğ‘ 2 1 2 ğ‘ 3 3 1 Knows-id-to-offset vid eid dest-id 1 ğ‘˜ 1 ğ‘ 2 2 ğ‘˜ 2 ğ‘ 1 3 ğ‘˜ 3 ğ‘ 3 4 ğ‘˜ 4 ğ‘ 2</formula><p>Knows-destination CSR Optimized Schema of the CSR-style reorganization, and produces a logically equivalent query over the COS, as we explain next.</p></div>
<div><head n="5">QUERY REWRITING</head><p>We explain now how a SQL query expressed on the standard relational schema for property graphs is rewritten into a SQL query expressed on the CSR-optimised schema. Every L(eid, src-id, dest-id, ep1,..., epn) edge relation in the FROM clause of a query is first replaced by the corresponding COS tables: L-id-to-offset(src-id, offset-start, length) and L-destination(vid, eid, ep1, ..., epm, dest-id). Furthermore, to relate the source vertices of L-edges with the appropriate destination vertices, we add the following condition in the WHERE clause: vid BETWEEN offset-start AND offset-start+length.</p><p>For instance, consider the property graph in Figure <ref type="figure" target="#fig_0">1</ref> and the following query asking for the name and age of every person known by a person named Bob: The query then is sent to the <software ContextAttributes="used">PostgreSQL</software> optimizer as any relational query, thus allowing it to be optimized and executed in the standard way.</p><p>As can be seen from our example, the positional encoding in COS leads to interval (inequality) joins, materialized by the BETWEEN predicate. This leads to specific optimization issues, as we discuss next.</p></div>
<div><head n="6">COS AWARE CARDINALITY ESTIMATIONS</head><p>In this section, we explain an important challenge we had when running the set of graph-relational queries using the CSR index on top of <software>PostgreSQL</software>. As explained above, we replace each manyto-many edge table with the two corresponding CSR tables id-tooffset, destination, then join them together using a range filter in the WHERE clause. In this way, we get the neighbors of a certain node using the offset-start and length columns to determine where to start scanning the adjacent nodes and for what length in the destination table. The main advantage, in this case, is that getting the neighbors of a node requires scanning only a continuous part of the destination table that have the neighbors without the need to scan the whole edge relation in the fully relational case.</p><p>However, when we implemented that in <software>PostgreSQL</software>, we noticed that running the queries using the CSR index tables yields slower execution time which was surprising at first (as scanning only the useful part of the edges relation should be faster than scanning the whole relation). When we investigated the query plans that <software ContextAttributes="used">PostgreSQL</software> optimizer produced on the COS layout, we noticed the following:</p><p>â€¢ The optimizer chooses hash join to join some tables instead of using the index nested loop join, despite the fact that the index nested loop join is faster in execution. In order to know why the optimizer takes this decision, we investigated <software>PostgreSQL</software> cardinality estimators, which predict the number of output rows that each operator produces. â€¢ It turned out that the cardinality estimator of <software ContextAttributes="used">PostgreSQL</software> significantly overestimates the number of rows in the destination relation that satisfies the range filter to get the set of nodes in the range [offset, offset+length]. For example, if the range query asks for the rows in the destination relation that have vid values in the range [100,150], the actual number of returned rows is 51. However, the estimator predicts the output to be about 80.000 rows which is an overestimation of 1.600Ã—.</p><p>This overestimation leads the optimizer to prefer using a hash join for joining the output of the filter with the other operators. However, using hash join, in this case, makes the performance worse, because it needs to build a hash table for one side of the join and start probing using the other side. In contrast, using an index nested loop join would only need a few index accesses (51 in our example), and thus lead to faster execution. Therefore, we had to investigate further why the <software>PostgreSQL</software> estimator significantly overestimates the number of rows resulting from the range query. We discuss this next.</p></div>
<div><head n="6.1">PostgreSQL Estimation of Range Queries</head><p>Consider a range query in the following form:</p><formula xml:id="formula_1">SELECT * FROM R WHERE R.c &gt;A AND R.c&lt;B</formula><p>where R.c is a column of integer values and A and B are some integer values. The estimator distinguishes between two cases in order to estimate the number of rows that validate the range filter:</p><p>(1) If A and B are known to the optimiser at query optimization time (i.e A and B are constants written in the query), then the <software ContextAttributes="used">PostgreSQL</software> cardinality estimator uses its materialised statistics available about the column R.c in the system catalogue, such as the histogram of R.c, the set of most common values of R.c, and their frequencies, in order to estimate the number of tuples that satisfy the range predicate <ref type="bibr" target="#b1">[3]</ref>.</p><p>(2) Otherwise, A and B may be unknown to the optimizer at query optimization time, in particular when A and B are values that we get from the tables that we scan and possibly select, join, etc. in the query itself. In this case, at query optimization time, the estimator is unable to proceed as above, and instead defaults to some default selectivity constants <ref type="bibr" target="#b0">[2]</ref> as a last resort. Unfortunately, our COS layout falls in the second case: the role of values A and B is played by the offset-start and offset-start+length; they are not known at query optimization time, but become known only at runtime when they are read from the CSR index table. Looking within the source code of <software ContextAttributes="used">PostgreSQL</software> <ref type="bibr" target="#b0">[2]</ref> uncovered a default selectivity of 0.11 in an example case we considered: the optimizer estimated 800.000 rows in the table, combined this with the default selectivity factor, and concluded that approximately 80.000 rows were going to be selected when the true value was closer to 50 (1.600Ã— overestimation).</p></div>
<div><head n="6.2">Adapting Estimations to Graph Queries</head><p>In order to solve the problem discussed, we had to choose a good replacement for the default selectivity the <software>PostgreSQL</software> estimator uses in order to fit our case. The goal of the new selectivity value is to be used in the graph scenario and to not overestimate the number of rows that validates the range query. We also want this value to be generic enough so that it still behaves reasonably when moving to a different graph.</p><p>As the expected number of rows that validates the range query is the same number of nodes that are neighbors of a node in the graph, we expect the average degree of nodes in the graph to be a good default estimator for the range queries in the destination relation. From that argument, we can recalculate the appropriate default selectivity for a given graph and replace the default selectivity value in <software>PostgreSQL</software>. We did that and it gives the desired behavior from the query optimizer which chooses index nested loop join in the cases where the number of scanned vertices is not big. Our experimental results (see below) validate the interest in this modification.</p></div>
<div><head n="7">EXPERIMENTAL EVALUATION</head><p>This section presents the experimental results that we obtained by evaluating the performance of the CSR Optimised Schema compared to traditional ways of graph query processing such as RDBMSs or GDBMSs. We consider queries that include both a graph and a relational component, to (ğ‘–) demonstrate that COS can be easily applied on top of any relational database, and (ğ‘–ğ‘–) evaluate the performance of COS in a mixed workload with queries stressing either the graph or the relational component.</p><p>In all experiments, we report the execution time of running the same graph-relational query in two deployment settings: (ğ‘–) when the graph edges are stored as many-to-many relation, we call this scenario the fully relational setting; (ğ‘–ğ‘–) after introducing our COS approach to represent the edges in the graph. We call this scenario the COS setting.</p></div>
<div><head n="7.1">Experimental Setup</head></div>
<div><head n="7.1.1">Software.</head><p>A key COS advantage is that it can be trivially deployed on top of an already existing RDBMS. Accordingly, we decided to use <software>PostgreSQL</software> v12.7 due to its maturity and its wide adoption.</p><p>7.1.2 Hardware. All experiments were executed on a machine equipped with two 10-core Intel Xeon E5-2640 v4 @ 2.40GHz CPUs and 256 GB of DRAM.</p><p>7.1.3 Benchmark. Following several works in the related literature, in our experiments, we used the dataset and the workload described in the LDBC Social Network Benchmark (SNB, in short) <ref type="bibr" target="#b3">[5]</ref>. The SNB dataset represents a social network of people who can be friends with each other, join forums, and post messages as well as comments on the posts. The size of the graph is controlled by a scale factor. For instance, with scale factor 10, we generate about 36 million nodes and 124 million edges. Cocerning the workload, we consider the Interactive Complex (IC) queries that include both graph traversal and standard relational operators without changing the dataset. The queries access a large part of the database (often the two-step friendship neighborhood and associated messages). Nevertheless, their graph traversal component considers close proximity to a single node, that is from one to three hops away <ref type="bibr" target="#b6">[8]</ref>.</p></div>
<div><head n="7.2">Experimental Results</head><p>Figure <ref type="figure">4</ref>: SNB-M 1-hop queries</p><p>We executed the set of Interactive Complex queries of SNB on both the fully relational scenario and the proposed COS scenario. We chose a subset of the SNB-IC queries where the execution varies between the two scenarios. This is the case for queries: 1 to 6, 9, and 11. The rest of the queries do not show any difference in the two scenarios and, therefore, we omit them from the experiments.</p><p>As our approach does not support recursive queries, we split the queries that traverse a range of hops into a set of queries with a fixed number of hops away from the source node. For example, IC1 asks for nodes of type person that are connected to starting person x through at most three knows edges. This query is split into 3 queries: IC1-1 which gives direct friends of a given node ğ‘¥, IC1-2 that gives friends of friends of ğ‘¥ and IC1-3 which gives the set of nodes that are connected by exactly 3 knows edges to ğ‘¥. In the related literature <ref type="bibr" target="#b9">[11]</ref> queries with this modification have been referred to as SNB-Modified. We study two cases described in the following sections. 7.2.1 1-hop Queries. We consider queries that explore the nodes in the graph that are 1-hop away from the starting node. This subset of queries are referred to in the SNB-M benchmark as IC*-1. Figure <ref type="figure">4</ref> shows the runtime of running SNB-M IC queries on <software ContextAttributes="used">PostgreSQL</software> with and without using COS. We divide the queries according to the behaviour of the proposed approach into three main categories: C1. Queries where COS improved the performance significantly such as IC1, IC4, and IC11 where the speedup compared to fully relational is 34Ã—, 177Ã—, and 41Ã— respectively. Here, COS exploits the CSR access patterns to get the node neighbours efficiently, instead of doing the value based join used in traditional DBMSs. C2. Queries where the COS performance improvement was smaller such as IC6, and IC9 where the speed up in execution was 1.9Ã—, and 1.2Ã— respectively. To explain why the speedup was smaller, we analyzed the execution plans produced by <software ContextAttributes="used">PostgreSQL</software> for each one of the queries. We discovered that for queries IC6 and IC9, the graph traversal part of the query was executed very fast on the COS. However, the relational part of the query joins the nodes resulted from the graph traversal with large tables, hence dominating the execution time. C3. Queries where COS underperformed such as IC2 and IC3 where the performance was slowed down by 1.5Ã— and 2Ã— respectively. By analyzing the execution plans, we discovered that most of the execution time is spent on getting the vertices' properties rather than in graph traversal. In order to get the properties, the query optimizer expects a small number of vertices and chooses an index nested loop join. For example, in IC3 there is an index nested loop join that accesses one table 310K times by index scan. A hash join would be a reasonable alternative. In fact, the optimizer underestimated the output of graph traversal in IC3 by a factor of 4700Ã— which leads to so many index accesses to get the properties. Bad cardinality estimation has been shown to have a negative effect on the query plan <ref type="bibr" target="#b12">[14]</ref>. We consider the queries that explore the nodes in the graph that are 2-hop away from the starting node. This subset of queries is referred to in the SNB-M benchmark as IC*-2. We selected a subset of the SNB-IC queries that explores more than 2 hops away from a starting node and compared their runtimes with/out using COS in Figure <ref type="figure" target="#fig_4">5</ref>. The figure shows that using COS leads to performance improvements on queries IC1, IC5, and IC11, due to the COS's ability to efficiently get the neighbors of a node in the graph. However, performance was hurt in IC6 and IC9. This is due to a bad cardinality estimation of the query optimizer on the output of the graph traversal part of the query, again resulting in an index nested loop join instead of hash join to get the vertex properties. The problem is more obvious in 2-hops queries as the number of vertices resulted from graph traversal is significantly larger than a 1-hop query. Therefore, more index scans occur which leads to slower execution.</p><p>Overall, we observe that COS enhanced the performance in most of the SNB graph-relational queries, whereas the graph traversal part is always improved. The relational part of the query slows down the execution in some queries due to suboptimal query plans. We can avoid the slowing down in the relational part of some queries by having better cardinality estimations which can lead to better plans.</p></div>
<div><head n="7.3">Scalability Experiments</head><p>We investigate how the COS approach scales with the size of the graph (in terms of the number of nodes and edges). We chose a subset of the SNB-M IC queries and we report the runtime of this query with different scale factors. We executed the queries of IC*-2, which traverse 2-hops in the graph, with SF3 (3GB dataset) and SF10 (10GB dataset) and we report the results in Figure <ref type="figure" target="#fig_5">6</ref>. We can see in Figure <ref type="figure" target="#fig_5">6</ref> that executing the same query on SF10 has a larger runtime compared to SF3, with and without using COS, as expected. Another interesting observation is that COS scalability seems to be better correlated to the size of the graph compared to the fully relational model, that is: the running time for most queries at SF10 using COS is roughly 3Ã— more than for SF3. In contrast, in the fully relational model, the running time did not change much between SF3 and SF10 in some queries like IC5, or it become 4Ã— larger in some others like IC6. The reason for the constant execution time of IC5 is the fixed cost spent in building the hash table of the edges' relationship.</p></div>
<div><head n="7.4">Conclusion</head><p>The experiments demonstrated that CSR-organised schema provides performance improvements on some of the Interactive-Complex queries of SNB compared to storing the graph in a fully relational schema. We showed how some queries can have significant, ordersof-magnitude improvements in performance compared to the fully relational version. Some of them have a slightly better performance due to the large portion of the relational component, and some register a performance penalty due to bad cardinality estimation from the query optimizer. We also showed how running the queries on top of COS scales linearly with respect to the size of the graph. More experiments can be done on the cardinality estimation of the query optimizer to further improve the performance.</p></div><figure xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Sample property graph, representing a social network.</figDesc><graphic coords="3,53.80,83.70,240.20,185.67" type="bitmap" /></figure>
<figure xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Part of the relational schema storing vertex and edge attributes for the social network example in Figure 1.</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Reorganising the knows table (left) by replacing it with the two tables of the CSR Optimised Schema (right)</figDesc></figure>
<figure xml:id="fig_3"><head /><label /><figDesc>SELECT p2.Name, p2.Age FROM Knows k, Person p1, Person p2 WHERE k.src-id=p1.id AND p1.name='Bob' AND k.dest-id=p2.id This query is rewritten as follows: SELECT p2.Name, p2.Age FROM Knows-id-to-offset kito, Knows-destination kd, Person p1, Person p2 WHERE kito.src-id=p1.id AND p1.name='Bob' AND kd.dest-id=p2.id AND kd.vid BETWEEN kito.offset-start AND kito.offset-start+kito.length</figDesc></figure>
<figure xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: SNB-M 2-hop queries</figDesc><graphic coords="6,317.96,466.90,240.24,117.77" type="bitmap" /></figure>
<figure xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: SNB-M 2-hop with SF3 and SF10</figDesc><graphic coords="7,53.80,347.52,240.23,131.11" type="bitmap" /></figure>
<figure type="table" xml:id="tab_0"><head>â€¢</head><label /><figDesc>Find messages that any person from otherPerson has posted after a given min date. For those messages, count the number of each tag attached to the message.</figDesc><table><row><cell>Person</cell><cell>Knows</cell><cell /></row><row><cell>id name age ğ‘ 1 Bob 25 ğ‘ 2 Alice 23 ğ‘ 3 John 30</cell><cell>id src-id dest-id ğ‘˜ 1 ğ‘ 1 ğ‘ 2 ğ‘˜ 2 ğ‘ 2 ğ‘ 1 ğ‘˜ 3 ğ‘ 2 ğ‘ 3 ğ‘˜ 4 ğ‘ 3 ğ‘ 2</cell><cell>since 1-1-2012 1-1-2012 2-1-2019 2-1-2019</cell></row><row><cell>The query consists of two components:</cell><cell /><cell /></row></table></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>The neighbors of ğ‘£ end at the offset of the vertex that follows ğ‘£ in the offset array. Then, retrieving the neighbors of ğ‘£ takes a scan of the values in the destination array in the range between [start, end]. CSR requires ğ‘‚ (|ğ‘‰ | + |ğ¸|) for storage and it is very efficient in getting the neighbors of a specific vertex (scanning a continuous range in an array).</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments. This work is funded by <rs type="funder">ANR CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_6v6KCQv">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="https://github.com/postgres/postgres/blob/master/src/include/utils/selfuncs.h" />
		<title level="m">PostgreSQL cardinality estimation defaults</title>
		<imprint>
			<date type="published" when="2022-06-10">10-June-2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="https://www.postgresql.org/docs/current/row-estimation-examples.html" />
		<title level="m">PostgreSQL cardinality estimation documentation</title>
		<imprint>
			<date type="published" when="2022-06">2022. 10-June-2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title />
		<author>
			<persName><surname>Tigergraph</surname></persName>
		</author>
		<ptr target="https://www.tigergraph.com/" />
		<imprint>
			<date type="published" when="2022-06">2022. 10-June-2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The LDBC social network benchmark</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">JÃ¡nos</forename><surname>Benjamin Antal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Averbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orri</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vlad</forename><surname>Haprian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josep</forename><surname>LluÃ­s Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norbert</forename><surname>MartÃ­nez-Bazan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">JÃ³zsef</forename><surname>Marton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcus</forename><surname>Paradies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minh-Duc</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnau</forename><surname>Prat-PÃ©rez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mirko</forename><surname>Spasic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">A</forename><surname>Steer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">GÃ¡bor</forename><surname>SzÃ¡rnyas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jack</forename><surname>Waudby</surname></persName>
		</author>
		<idno>CoRR, abs/2001.02299</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Time-and space-efficient regular path queries on graphs</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Arroyuelo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gonzalo</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javiel</forename><surname>Rojas-Ledesma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Tracking structure of streaming social networks</title>
		<author>
			<persName><forename type="first">David</forename><surname>Ediger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><surname>Riedy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Bader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henning</forename><surname>Meyerhenke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 IEEE International Symposium on Parallel and Distributed Processing Workshops and Phd Forum</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1691" to="1699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The LDBC Social Network Benchmark: Interactive workload</title>
		<author>
			<persName><forename type="first">Orri</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Averbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josep-Lluis</forename><surname>Larriba-Pey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnau</forename><surname>Prat-PÃ©rez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minh-Duc</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="619" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Csr++: A fast, scalable, update-friendly graph data structure</title>
		<author>
			<persName><forename type="first">Soukaina</forename><surname>Firmli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vasileios</forename><surname>Trigonakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Pierre</forename><surname>Lozi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iraklis</forename><surname>Psaroudakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Weld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chiadmi</forename><surname>Dalila</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">12 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Representation of graphs</title>
		<author>
			<persName><forename type="first">Alon</forename><surname>Itai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Rodeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Inf</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page">6</biblScope>
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Making rdbmss efficient on graph workloads through predefined joins</title>
		<author>
			<persName><forename type="first">Guodong</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1011" to="1023" />
			<date type="published" when="2022-01">jan 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Graphflow: An active graph database</title>
		<author>
			<persName><forename type="first">Chathura</forename><surname>Kankanamge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddhartha</forename><surname>Sahu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amine</forename><surname>Mhedbhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data, SIGMOD '17</title>
		<meeting>the 2017 ACM International Conference on Management of Data, SIGMOD '17<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1695" to="1698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Path indexing in the cypher query pipeline</title>
		<author>
			<persName><forename type="first">Jochem</forename><surname>Kuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="582" to="587" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">How good are query optimizers, really?</title>
		<author>
			<persName><forename type="first">Viktor</forename><surname>Leis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atanas</forename><surname>Mirchev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfons</forename><surname>Kemper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the VLDB Endowment</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="204" to="215" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">A+ indexes: Lightweight and highly flexible adjacency lists for graph database management systems</title>
		<author>
			<persName><forename type="first">Amine</forename><surname>Mhedhbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pranjal</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shahid</forename><surname>Khaliq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Semih</forename><surname>Salihoglu</surname></persName>
		</author>
		<idno>CoRR, abs/2004.00130</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Regular path query evaluation sharing a reduced transitive closure based on graph reduction</title>
		<author>
			<persName><forename type="first">Inju</forename><surname>Na</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilyeop</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyu-Young</forename><surname>Whang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang-Sae</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soon</forename><forename type="middle">J</forename><surname>Hyun</surname></persName>
		</author>
		<idno>CoRR, abs/2111.06918</idno>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Answering reachability and k-reach queries on large graphs with label constraints</title>
		<author>
			<persName><forename type="first">You</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ying</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenjie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="101" to="127" />
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Sqlgraph: An efficient relational-based property graph store</title>
		<author>
			<persName><forename type="first">Wen</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Achille</forename><surname>Fokoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kavitha</forename><surname>Srinivas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guo</forename><surname>Tong Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2015 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Sqlgraph: An efficient relational-based property graph store</title>
		<author>
			<persName><forename type="first">Wen</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kavitha</forename><surname>Srinivas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Achille</forename><surname>Fokoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guotong</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Pgql: A property graph query language</title>
		<author>
			<persName><forename type="first">Sungpack</forename><surname>Oskar Van Rest</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinha</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuming</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hassan</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><surname>Chafi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth International Workshop on Graph Data Management Experiences and Systems, GRADES '16</title>
		<meeting>the Fourth International Workshop on Graph Data Management Experiences and Systems, GRADES '16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Packed compressed sparse row: A dynamic graph representation</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Wheatman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helen</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE High Performance extreme Computing Conference (HPEC)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Numa-aware graph-structured analytics</title>
		<author>
			<persName><forename type="first">Kaiyuan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM SIGPLAN symposium on principles and practice of parallel programming</title>
		<meeting>the 20th ACM SIGPLAN symposium on principles and practice of parallel programming</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="183" to="193" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>