<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Datalog Unchained</title>
				<funder ref="#_uXNpgX8">
					<orgName type="full">National Science Foundation</orgName>
				</funder>
				<funder ref="#_8YQQxDz">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
							<email>vianu@ucsd.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">UC San Diego &amp; Inria</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Datalog Unchained</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">1C5EC2CE7D082D64993A539FA88AC668</idno>
					<idno type="DOI">10.1145/3452021.3458815</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>This is the companion paper of a talk in the Gems of PODS series, that reviews the development, starting at PODS 1988, of a family of Datalog-like languages with procedural, forward chaining semantics, providing an alternative to the classical declarative, model-theoretic semantics. These languages also provide a unified formalism that can express important classes of queries including fixpoint, while, and all computable queries. They can also incorporate in a natural fashion updates and nondeterminism. Datalog variants with forward chaining semantics have been adopted in a variety of settings, including active databases, production systems, distributed data exchange, and data-driven reactive systems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>Datalog emerged in the 80's as a simple, elegant formalism providing the basis for deductive databases and the study of recursion in database languages. Datalog was introduced as a specialization of logic programming to databases (a discussion of the history can be found in <ref type="bibr" target="#b96">[95,</ref><ref type="bibr" target="#b97">96]</ref>). Datalog ¬ , its extension with negation, was also studied through the lens of logic programming and non-monotonic reasoning, by which programs are viewed as specifications of consistent states of the world, best understood via model-theoretic semantics. This approach has led, most prominently, to stratified Datalog ¬ <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b50">50,</ref><ref type="bibr" target="#b61">61,</ref><ref type="bibr" target="#b92">92]</ref>. While stratified semantics provides a very natural interpretation for negation, it is limited to programs without recursion through negation. The quest to provide semantics to all Datalog ¬ programs culminated with the elegant well-founded semantics <ref type="bibr" target="#b63">[63]</ref>. However, its conceptual complexity, involving 3valued models (or equivalently, alternating fixpoints), has precluded its widespread adoption in practice.</p><p>At PODS 1988, two articles <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b87">87]</ref> independently suggested an alternative approach, aptly captured by the title of <ref type="bibr" target="#b87">[87]</ref>: "Why not negation by fixpoint?". Both articles proposed to depart from the declarative approach and adopt a procedural semantics for Datalog ¬ based on forward chaining of rules, called inflationary fixpoint semantics. As shown in <ref type="bibr" target="#b4">[5]</ref>, Datalog ¬ with inflationary semantics combines simplicity with expressiveness: it captures precisely the robust class of fixpoint queries, previously defined by extensions of first-order logic with a fixpoint operator.</p><p>The two PODS 1988 articles initiated a line of research <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b105">104,</ref><ref type="bibr" target="#b117">116]</ref> that extended the forward chaining approach to an entire family of Datalog-like languages, providing an alternative paradigm for database queries, with natural counterparts to classical query languages including the fixpoint and while queries, and all the way to computable queries. The forward chaining approach turned out to also be suitable for studying nondeterministic languages, yielding an appealing unifying formalism. The present paper tells the story of this development.</p><p>After a brief review of classical query languages, we turn to Datalog and its extensions. We begin with an informal overview of Datalog and Datalog ¬ with stratified and well-founded semantics. We then present the procedural, forward chaining semantics of Datalog ¬ . One of the nicest results in regard to expressive power is the convergence of the procedural and declarative semantics to the fixpoint queries. We also present a further extension denoted Datalog ¬¬ that allows for explicit retraction of facts and expresses the while queries. Finally, we discuss Datalog ¬ new , a variant of Datalog that allows for the invention of new values in heads of rules, and expresses all computable queries. Value invention also arises in the object-oriented context, where object creation is a very useful and common feature <ref type="bibr" target="#b11">[12]</ref>.</p><p>Deterministic languages, including rule-based languages, have well-known limitations of expressive power. For example, there is no known language that expresses precisely the ptime queries (e.g., see <ref type="bibr" target="#b79">[79]</ref>). This limitation is overcome in the presence of an order. For example, Datalog ¬ with inflationary or well-founded semantics expresses on ordered databases exactly the queries computable in polynomial time (and so do the weaker semi-positive and stratified Datalog ¬ ). Another approach, intimately related to the first, trades off determinism for expressiveness. Indeed, as shown in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14]</ref>, nondeterministic variants of Datalog with negation can express all (deterministic and nondeterministic) queries computable in polynomial time. The nondeterminism arises from the firing of rule instantiations in arbitrary order. As argued in <ref type="bibr" target="#b14">[15]</ref>, nondeterminism can be a very useful feature, independently of issues of expressiveness. Indeed, nondeterminism has long been present in expert systems and production systems (e.g., see <ref type="bibr" target="#b38">[38]</ref>).</p><p>The paper is organized as follows. Some background is provided in Section 2. The declarative approach is briefly surveyed next. This reviews Datalog, stratified Datalog ¬ , and Datalog ¬ with wellfounded semantics. The procedural, forward chaining approach is presented in Section 4, together with results on the relative expressive power of the declarative and procedural languages. Nondeterministic languages are discussed in Section 5. A brief review of intervening Datalog research is outlined in Section 6. To conclude, we compare the forward chaining and declarative semantics for Datalog and discuss the adoption of the forward chaining semantics in practice. The presentation relies largely on material from <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b117">116]</ref>. The work surveyed in this paper is joint with Serge Abiteboul.</p></div>
<div><head n="2">BACKGROUND</head><p>In this section, we review some terminology relating to relational databases. In particular, we recall some of the traditional query languages, including extensions of first-order logic with recursion (the fixpoint <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b99">98]</ref> and while <ref type="bibr" target="#b47">[47]</ref> queries).</p><p>We assume the existence of four infinite and pairwise disjoint sets of symbols: the set rel of relation symbols, the set att of attributes, the set dom of constants, and the set var of variables. A relation schema is a relation symbol together with a finite set of attributes. The set of attributes of a relation R is denoted by att(R). A database schema is a finite set of relation schemas. A free tuple over a relational schema R is a mapping from att(R) into dom ∪ var. A constant tuple over a relational schema R is a mapping from att(R) into dom. An instance over a relation schema R is a finite set of constant tuples over R. An instance I over a database schema R is a mapping from R such that for each R in R, I(R) is an instance over R. The set of all instances over a schema R is denoted by inst(R). Note that we only consider finite instances. For an instance I, we denote by adom(I) the set of elements of dom occurring in I.</p><p>A deterministic database query is a mapping from inst(R) to inst(answer), where R is a database schema and answer is a relation schema not in R. We also discuss nondeterministic queries. A nondeterministic query is a subset of inst(R) × inst(answer) for some R and answer (so it is a relation rather than a mapping). Some settings use a more general notion of database transformation allowing answer schemas with several relations, some of which may be part of the input schema (thus capturing updates).</p><p>Queries are usually required to obey three conditions: welltypedness, computability and genericity <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b48">48]</ref>. Well-typedness requires that the results of the query be instances of a fixed relation schema. A query is computable if there is a Turing machine that, given any standard encoding of an input database (depedent on a total order on the domain), produces a standard encoding of the query answer. Genericity requires that the graph of a database query be closed under isomorphisms of the domain that fix a specified finite set of constants depending on the query.</p><p>We will refer to complexity classes of queries. For each Turing machine complexity class c, there is a corresponding complexity class of (nondeterministic) queries denoted (n)db-c. In particular, the class of nondeterministic queries which can be computed by a (nondeterministic) Turing machine in polynomial time is denoted (n)db-ptime. It is important to distinguish between classes ndb-c of nondeterministic queries and classes of deterministic queries defined using nondeterministic devices. For example, by Savitch's theorem, pspace = npspace, so db-pspace = db-npspace. Both are classes of deterministic queries. However, ndb-pspace contains nondeterministic queries, so db-pspace ndb-pspace (and ndbpspace db-npspace). Similarly, db-np is not to be confused with ndb-ptime ! Below are some informal examples. All queries take as input a binary relation representing edges in a graph:</p><p>• The query whose answer consists of all vertices lying on a cycle is a query in db-ptime. Some query languages. Most practical query languages in relational databases are based on FO, first-order logic on relations, sometimes called relational calculus (e.g. see <ref type="bibr" target="#b1">[2]</ref>). FO has an algebraization called relational algebra <ref type="bibr" target="#b51">[51]</ref>. Relational algebra provides the following operations on relations: π X (projection on attributes X ), σ C (selection of tuples satisfying condition C consisting of (in)equalities among attributes and/or constants), δ A→B (rename attribute A to B), (join of two relations), -(difference), and ∪ (union).</p><p>There are many useful queries that FO cannot express, such as the transitive closure of a graph. Numerous extensions of FO with recursion have been proposed. Most of them converge towards two very robust classes of queries: fixpoint <ref type="bibr" target="#b49">[49,</ref><ref type="bibr" target="#b99">98]</ref> and while <ref type="bibr" target="#b47">[47]</ref>. These can be defined in various ways: by adding fixpoint operators to FO <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b99">98]</ref>, looping constructs to relational algebra <ref type="bibr" target="#b47">[47,</ref><ref type="bibr" target="#b49">49]</ref>, or by extensions of Datalog <ref type="bibr" target="#b5">[6]</ref>. We briefly review here the definition of fixpoint and while based on the eponymous languages, using looping constructs (see <ref type="bibr" target="#b1">[2]</ref>).</p><p>While is an imperative language that extends FO with recursion. It provides relation variables, assignment statements of the form R := φ where φ is an FO query, and a looping construct while φ do where φ is an FO sentence. An equivalent variation uses loops of the form while change do which iterate the body as long as some change is made to some relation. Fixpoint is the same as while except the semantics of assignment is cumulative (i.e., an assignment denoted R + = φ adds φ to the current content of R). This guarantees termination of fixpoint programs in polynomial time, whereas while programs require polynomial space. On ordered databases, fixpoint expresses precisely db-ptime <ref type="bibr" target="#b83">[83,</ref><ref type="bibr" target="#b115">114]</ref> and while expresses db-pspace <ref type="bibr" target="#b115">[114]</ref>. It was further shown in <ref type="bibr" target="#b6">[7]</ref> that fixpoint = while iff ptime = pspace, even without the order assumption.</p></div>
<div><head n="3">THE DECLARATIVE APPROACH</head><p>We briefly review the classical model-theoretic semantics of Datalog and its extension with negation. For a detailed presentation see <ref type="bibr" target="#b1">[2]</ref>, and <ref type="bibr" target="#b97">[96]</ref> for a more comprehensive survey.</p></div>
<div><head n="3.1">Datalog</head><p>Much of the activity in deductive databases has focused on a toy language called Datalog. Some of the early history of Datalog is discussed in <ref type="bibr" target="#b96">[95,</ref><ref type="bibr" target="#b97">96]</ref>. Although limited, Datalog highlights some aspects of recursion present in many practical languages. Most of the optimization techniques in deductive databases have been developed around Datalog.</p><p>As an example, following is a Datalog program that computes the transitive closure of a graph. The graph is represented in relation G and its transitive closure in relation T :</p><formula xml:id="formula_0">T (x, y) ← G(x, y) T (x, y) ← G(x, z),T (z, y).</formula><p>A Datalog program "defines" the relations occurring in heads of rules, from the other relations. The definition is recursive, so defined relations can also occur in bodies of rules. Thus, a Datalog program is interpreted as a mapping from instances over the relations occurring in the bodies only, to instances over the relations occurring in the heads. For example, the program above maps a relation over G (a graph) to a relation over T (its transitive closure).</p><p>We now define the syntax of Datalog.</p><p>Definition 3.1. A (Datalog) rule is an expression of the form: The set of constants occurring in a Datalog program P is denoted adom(P); and for an instance I, we use adom(P, I) as an abbreviation for adom(P) ∪ adom(I).</p><formula xml:id="formula_1">R 1 (u 1 ) ← R 2 (u 2 ), . . . , R n (u n ) where n ≥ 1, R 1 , . . . ,</formula><p>Let P be a Datalog program. An extensional relation is a relation occurring only in the body of the rules. An intensional relation is a relation occurring in the head of some rule of P. The extensional (database) schema, denoted edb(P), consists of the set of all extensional relation names; whereas the intensional schema idb(P) consists of all the intensional ones. The schema of P, denoted sch(P) is the union of edb(P) and idb(P). The semantics of a Datalog program is a mapping from database instances over edb(P) to database instances over idb(P). Typically, one relation of idb(P) is designated as the answer relation.</p><p>The key idea of the declarative approach of deductive databases is to view the program as a set of first-order sentences that describes the desired answer. To a Datalog rule</p><formula xml:id="formula_2">ρ : R 1 (u 1 ) ← R 2 (u 2 ), . . . , R n (u n )</formula><p>we can associate the logical sentence:</p><formula xml:id="formula_3">∀x 1 , . . . , x m (R 1 (u 1 ) ← R 2 (u 2 ) ∧ . . . ∧ R n (u n ))</formula><p>where x 1 , . . . , x m are the variables occurring in the rule; and "←" is the standard logical implication. For a program P, the set of sentences associated with the rules of P is denoted by Σ P . It turns out that for each Datalog program P, and input I, there is a minimum model of Σ P extending I. This model is the semantics of P on input I and is denoted by P(I).</p></div>
<div><head n="3.2">Stratified Datalog ¬</head><p>Datalog ¬ extends Datalog with negations in the bodies of rules. The syntax of Datalog ¬ is a straightforward extensions of Datalog. A Datalog ¬ rule is an expression of the form R 1 (u 1 ) ← L 1 , ..., L n where: R 1 is a relation, u 1 a free tuple, and each L i is a literal of the form R i (u i ) (in which case it is called positive) or ¬R i (u i ) (in which case it is called negative). Each variable in u 1 must occur in some literal L i of the body.</p><p>A Datalog ¬ program is a non-empty finite set of Datalog ¬ rules. As for Datalog programs, sch(P) denotes the database schema consisting of all relations involved in the program P; the relations occurring in heads of rules are the idb relations of P, and the others are the edb relations of P.</p><p>Similarly to Datalog, we can associate to a Datalog ¬ program P the set Σ P of FO sentences corresponding to the rules of P. For Datalog, the model-theoretic semantics of a program P is given by the unique minimal model of Σ P extending the input. Unfortunately, this simple solution no longer works for Datalog ¬ , since uniqueness of a minimal model extending the input is not guaranteed. Short of this guarantee, a model-based semantics must specify an "intended" model that is intuitive and easy to compute. This is the core problem of "non-monotonic reasoning": make sense in a consistent way of the co-existence of negative and positive facts, in a way that reflects a natural reasoning process.</p><p>The most intuitive and widely accepted declarative semantics for Datalog ¬ requires a syntactic restriction that, informally, prohibits recursion through negation. The resulting syntactic class is called stratified Datalog ¬ . Intuitively, the restriction allows to "read" the program so that, for each idb relation R, the portion of P defining R comes before the negation of R is used. Once R is computed, the set of negative facts over R (restricted to the active domain) is well defined. For example, consider the following stratified Datalog ¬ program P defining the complement of transitive closure of a graph G:</p><p>T (x, y) ← G(x, y) T (x, y) ← G(x, z),T (z, y) CT (x, y) ← ¬T (x, y).</p><p>According to stratified semantics, the idb relation T is defined by the first two rules, and then its negation is used in the rule defining CT . Thus, the first two rules are applied before the third. This approach can be naturally extended to any stratified Datalog ¬ program. Not surprisingly, this appealing semantics has been independently proposed by quite a few investigators <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b50">50,</ref><ref type="bibr" target="#b61">61,</ref><ref type="bibr" target="#b92">92]</ref>.</p></div>
<div><head n="3.3">The Well-Founded Semantics</head><p>While stratification provides a simple and elegant approach to defining semantics of Datalog ¬ programs, it has two major limitations. First, it does not provide semantics to all Datalog ¬ programs. Second, stratified Datalog ¬ programs are not quite satisfactory with regard to expressive power. From a computational point of view, they provide recursion and negation. Therefore, one might expect that they express the fixpoint queries. Unfortunately, as shown <ref type="bibr" target="#b86">[86]</ref> (making use of earlier results from <ref type="bibr" target="#b53">[53]</ref> and <ref type="bibr" target="#b49">[49]</ref>), stratified Datalog ¬ programs fall short of expressing all fixpoint queries. Intuitively, this is due to the fact that the stratification condition prohibits recursive application of negation, whereas in other languages expressing fixpoint this computational restriction does not exist.</p><p>The quest for declarative semantics for all Datalog ¬ program has resulted in various proposals, of which the most prominent is the well-founded semantics <ref type="bibr" target="#b63">[63]</ref>. It relies on a fundamental revision of the expectations on the answer to a Datalog ¬ program. Previously, the answer was required to provide information on the truth or falsehood of every fact. The well-founded semantics is based on the idea that a given program may not necessarily provide such information on all facts. Instead, some facts may simply be indifferent to it, and the answer should be allowed to say that the truth value of those facts is unknown. Relaxing expectations about the answer in this fashion allows to provide an elegant, model-theoretic semantics to all Datalog ¬ programs. The price to pay is that the answer is no longer guaranteed to provide total information. In particular, the model-theoretic semantics requires a 3-valued logic.</p><p>Example 3.2. <ref type="bibr" target="#b63">[63,</ref><ref type="bibr" target="#b65">65]</ref> The example concerns a game with states, a, b, . . . . The game is between two players. The possible moves of the games are held in a binary relation moves. A tuple ⟨a, b⟩ in moves indicates that when in state a, one can choose to move to state b. A player loses if they are in a state from which there are no moves. The goal is to compute the set of winning states, i.e., the set of states such that there exists a winning strategy for a player in this state. These are obtained in a unary predicate win.</p><p>Consider the input K with the following value for moves:</p><formula xml:id="formula_4">K(moves) = {⟨b, c⟩, ⟨c, a⟩, ⟨a, b⟩, ⟨a, d⟩, ⟨d, e⟩, ⟨d, f ⟩, ⟨f , д⟩}</formula><p>It is easily seen that there are indeed winning strategies from states d (move to e) and f (move to д). Slightly more subtle is the fact that there is no winning strategy from any of states a, b, or c. Indeed, a given player can prevent the other from winning, essentially by forcing a non-terminating sequence of moves. Now consider the following nonstratifiable program P win :</p><formula xml:id="formula_5">win(x) ← moves(x, y), ¬win<label>(y)</label></formula><p>Intuitively, P win states that a state x is in win if there is at least one state y that one can move to from x, for which the opposing player looses. Following is a 3-valued model J of P win , that agrees with K on moves, and is in fact the well-founded semantics of P win on input K. Instance J is such that J(moves) = K(moves) and the values of win-atoms are given as follows:</p><p>true win(d), win(f ) false win(e), win(д) unknown win(a), win(b), win(c).</p><p>The well-founded semantics can be compared against classical 2valued model-theoretic semantics by casting its 3-valued semantics into a 2-valued model by taking the true facts as the answer to a program. In fact, it turns out that for every Datalog ¬ program P there is a Datalog ¬ program P whose well-founded semantics yields a classical 2-valued model whose true facts are the same as those of P under well-founded semantics <ref type="bibr" target="#b57">[57,</ref><ref type="bibr" target="#b58">58]</ref>. It was shown in <ref type="bibr" target="#b62">[62]</ref> that with the 2-valued interpretation, well-founded semantics has the same expressive power as the fixpoint queries, and can also be evaluated in ptime. This non-trivial result makes use of an equivalent formulation of the well-founded semantics as an alternating fixpoint computation <ref type="bibr" target="#b62">[62]</ref>. Thus, well-founded semantics overcomes the expressiveness limitations of stratified Datalog ¬ .</p><p>Research on well-founded semantics, and the related notion of 3-stable model, has its roots in investigations of stable and default model semantics. Stable model semantics was introduced in <ref type="bibr" target="#b65">[65]</ref> and default model semantics in <ref type="bibr" target="#b36">[36,</ref><ref type="bibr" target="#b37">37]</ref>. Stable semantics is based on Moore's autoepistemic logic <ref type="bibr" target="#b98">[97]</ref>, and default semantics is based on Reiter's default logic <ref type="bibr" target="#b109">[108]</ref>. The equivalence between autoepistemic and default logic in the general case has been shown in <ref type="bibr" target="#b88">[88]</ref>. The equivalence between stable model semantics and default model semantics was shown in <ref type="bibr" target="#b37">[37]</ref>.</p><p>Several equivalent definitions of the well-founded semantics have been proposed. The 3-valued model-theoretic approach is due to <ref type="bibr" target="#b107">[106]</ref>. In addition to the alternating fixpoint computation of <ref type="bibr" target="#b62">[62]</ref>, other approaches for computing the well-founded semantics are exhibited in <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b106">105]</ref>. Historically, the first definition of the well-founded semantics was proposed in <ref type="bibr" target="#b63">[63,</ref><ref type="bibr" target="#b64">64]</ref>.</p><p>In summary, the stratified semantics provides a very natural, intuitive interpretation for the sublass of Datalog ¬ without recursion through negation. While the well-founded semantics provides model-theoretic semantics to all Datalog ¬ programs, it is far less intuitive and its widespread use remains unlikely. In terms of expressiveness, Datalog ¬ with well-founded semantics overcomes the limitations of stratified Datalog ¬ by capturing the fixpoint queries. At the time, no model-theoretic semantics had been defined for Datalog-like languages that yielded expressiveness beyond fixpoint. These limitations motivated the study of the forward chaining approach to Datalog-like languages, that had already been in practical use in production systems <ref type="bibr" target="#b38">[38]</ref> and active databases <ref type="bibr" target="#b118">[117]</ref>.</p></div>
<div><head n="4">THE FORWARD CHAINING APPROACH</head><p>We describe next the forward chaining semantics of Datalog ¬ (expressing the fixpoint queries) and two extensions: Datalog ¬¬ (allowing negations in heads of rules and expressing the while queries) and Datalog ¬ new (allowing for the "invention" of new values, and expressing all computable queries).</p></div>
<div><head n="4.1">Datalog ¬</head><p>The forward chaining (or inflationary) semantics of Datalog ¬ is intuitively very simple: the rules of the program are fired in parallel with all applicable instantiations, until a fixpoint is reached. We first illustrate this straightforward semantics with an example.   <ref type="figure">(d(a,</ref><ref type="figure">b</ref>) is infinite if there is no path from x to y.) The program is:</p><formula xml:id="formula_6">closer (x, y, x ′ , y ′ ) = {⟨x, y, x ′ , y ′ ⟩ | d(x, y) ≤ d(x ′ , y ′ )},</formula><formula xml:id="formula_7">T (x, y) ← G(x, y) T (x, y) ← T (x, z), G(z, y) closer (x, y, x ′ , y ′ ) ← T (x, y), ¬T (x ′ , y ′ ).</formula><p>The program is evaluated as follows. The rules are fired simultaneously with all applicable valuations. At each such firing, some facts are inferred. This is repeated until no new facts can be inferred. A negative fact such as ¬T (x ′ , y ′ ) is true if T (x ′ , y ′ ) has not been inferred so far. This does not preclude T (x ′ , y ′ ) from being inferred at a later firing of the rules. One firing of the rules is called a "stage" in the evaluation of the program. In the above program, the transitive closure of G is computed in T . Consider the consecutive stages in the evaluation of the program. Note that, if the fact T (x, y) is inferred at stage n, then d(x, y) = n. So, if T (x ′ , y ′ ) has not been inferred yet, this means that the distance between x and y is less than that between x ′ and y ′ . Thus, if T (x, y) and ¬T (x ′ , y ′ ) hold at some stage n, then d(x, y) ≤ n and d(x ′ , y ′ ) &gt; n and closer (x, y, x ′ , y ′ ) is then inferred.</p><p>Formally, the forward chaining semantics of Datalog ¬ is defined as follows. Let P be a Datalog ¬ program and K an instance over sch(P). An instantiation of a rule A ← L 1 , . . . , L n with respect to K is a rule ν (A) ← ν (L 1 ), . . . , ν(L n ) where ν is a valuation which maps each variable into adom(P, K). A fact A ′ is an immediate consequence for K and</p><formula xml:id="formula_8">P if A ′ ∈ K(R) for some edb relation R, or A ′ ← L ′ 1 , ..., L ′</formula><p>n is an instantiation of a rule in P and: each positive L ′ i is a fact in K, and for each negative</p><formula xml:id="formula_9">L ′ i = ¬A ′ i , A ′ i K.</formula><p>The immediate consequence operator of P, denoted Γ P , is now defined as follows. For each K over sch(P),</p><formula xml:id="formula_10">Γ P (K) = K ∪ {A | A is an immediate consequence for K and P }.</formula><p>Given an instance I over edb(P), one can compute Γ P (I), Γ 2 P (I), Γ 3 P (I), etc. As suggested in Example 4.1, each application of Γ P is called a stage in the evaluation. From the definition of Γ P , it follows that Γ P (I) ⊆ Γ 2 P (I) ⊆ Γ 3 P (I) ⊆ . . . As for Datalog, the sequence reaches a fixpoint, denoted Γ ω P (I), after a finite number of steps. The restriction of this to the idb relations (or some subset thereof) is called the image (or answer) of P on I.</p><p>In the procedural semantics described above, increasing sets of facts are inferred by firings of the rules. For that reason, this semantics is also referred to as the inflationary semantics for Datalog ¬ (there is an "inflation" of tuples!). The language Datalog ¬ with inflationary semantics is also referred to as inflationary Datalog ¬ . This semantics was first proposed for Datalog ¬ in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b87">87]</ref>. It extends the fixpoint semantics proposed for Datalog in <ref type="bibr" target="#b50">[50]</ref>, also considered earlier in the context of logic programming <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b114">113]</ref>.</p><p>In the case of Datalog, the minimum model semantics and the inflationary fixpoint semantics coincide. For Datalog ¬ , this perfect match of declarative and procedural semantics is lost. First, a Datalog ¬ program may not have a unique minimal model. Moreover, while the result produced by inflationary semantics is a model of the program, it is not necessarily a minimal one.</p><p>Datalog ¬ with inflationary semantics provides recursion and negation, and it is straightforward to see that every query it expresses is a fixpoint query. The converse would seem unlikely, since Datalog ¬ is a much simpler language than those previously known to express the fixpoint queries. Surprisingly, the following was shown in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>: Theorem 4.2. Inflationary Datalog ¬ expresses precisely the fixpoint queries.</p><p>The simulation of fixpoint by inflationary Datalog ¬ presents two main difficulties, related to the simulation of the control capabilities available in fixpoint. The first involves delaying the firing of a rule until after the completion of a fixpoint by another set of rules. Intuitively, this is hard because checking that the fixpoint has been reached involves checking the non-existence rather than the existence of some valuation, and Datalog ¬ is more naturally geared towards checking the existence of valuations. The solution to this difficulty is illustrated in the following example.</p><p>Example 4.3. The following Datalog ¬ program computes the complement of the transitive closure of a graph G. The example illustrates the technique used to delay the firing of a rule (computing the complement) until the fixpoint of a set of rules (computing the transitive closure) has been reached, i.e., until the application of the transitivity rule yields no new tuples. To monitor this, the relations old-T , old-T -except-f inal are used. old-T follows the computation of T , but is one step behind it. The relation old-T -except-f inal is identical to old-T , but includes a clause which prevents it from firing when T has reached its last iteration. Thus, old-T and old-Texcept-f inal differ only in the iteration after the transitive closure T reaches its final value. In the subsequent iteration, the program recognizes that the fixpoint has been reached, and fires the rule computing the complement in relation CT . The program is:</p><formula xml:id="formula_11">T (x, y) ← G(x, y) T (x, y) ← G(x, z),T (z, y) old-T (x, y) ← T (x, y) old-T -except-f inal(x, y) ← T (x, y),T (x ′ , z ′ ),T (z ′ , y ′ ), ¬T (x ′ , y ′ ) CT (x, y) ← ¬T (x, y), old-T (x ′ , y ′ ), ¬old-T -except-f inal(x ′ , y ′ ).</formula><p>(It is assumed that G is not empty.)</p><p>The second difficulty concerns keeping track of iterations of the body in the computation of a loop. Given a loop while chanдe do body the simulation of body itself may involve numerous relations, whose behavior may be "sabotaged" by an overly zealous application of iteration. To overcome this we separate the "internal" computation of the body from the "external" iteration, as illustrated in the following example. Note that the query computes the set of nodes in G that are not reachable from a cycle. (In other words, the nodes such that the lengths of paths leading to them are bounded.) One iteration is achieved by the Datalog ¬ program P: bad(x) ← G(y, x), ¬дood(y) delay ← дood(x) ← delay, ¬bad(x) Simply iterating P does not yield the desired result. Intuitively, the relations delay and bad, which are used as "scratch paper" in the computation of a single iteration of the loop, cannot be re-initialized, and so cannot be effectively re-used to perform the computation of subsequent iterations.</p><p>To overcome this problem, we essentially create a version of P for each iteration The versions are distinguished by using "timestamps". The nodes themselves serve as timestamps. The timestamps marking iteration i are the values newly introduced in relation good at iteration i -1. Relations delay and delay-stamped are used to delay the derivation of new tuples in дood until bad and bad-stamped (respectively) have been computed in the current iteration. The process continues until no new values are introduced in an iteration. The full program is the union of the three rules given above, which perform the first iteration, and the following rules, which perform the iteration with timestamp t: bad-stamped(x, t) ← G(y, x), ¬дood(y), дood(t) delay-stamped(t) ← дood(t) дood(x)</p><p>← delay-stamped(t), ¬bad-stamped(x, t).</p></div>
<div><head n="4.2">Datalog ¬¬</head><p>Recall that in Datalog ¬ with inflationary semantics, a fact that has been inferred can never be retracted. Datalog ¬¬ allows explicit retraction of a previously inferred fact (thus, the semantics of Datalog ¬¬ is "noninflationary") <ref type="bibr" target="#b5">[6]</ref> 1 . Syntactically, this is done using negations in heads of rules, interpreted as deletions of facts. Moreover, input relations are allowed in heads of rules, thus providing the ability to perform updates. The resulting language is denoted by Datalog ¬¬ , to indicate that negations are allowed in both heads and bodies of rules. The immediate consequence operator Γ P and semantics of a Datalog ¬¬ program are analogous to those for Datalog ¬ with the following important proviso. If a negative literal ¬A is inferred, the fact A is removed, unless A is also inferred in the same firing of the rules. This gives priority to inference of positive over negative facts and is somewhat arbitrary. Other possibilities are: (i) give priority to negative facts, (ii) interpret the simultaneous inference of A and ¬A as a "no-op", i.e., including A in the new instance only if it is there in the old one; and (iii) interpret the simultaneous inference of A and ¬A as a contradiction which makes the result undefined. The chosen semantics has the advantage over (iii) that the result is always defined. In any case, the choice of semantics is not crucial: it results in equivalent languages. With the semantics chosen above, termination is no longer guaranteed. For instance, the program</p><formula xml:id="formula_12">T (0) ← T (1) ¬T (1) ← T (1) T (1)</formula><p>← T (0) ¬T (0) ← T (0) never terminates on input T (0). Indeed, the value of T flip-flops between {⟨0⟩} and {⟨1⟩} so no fixpoint is reached.</p><p>By a method similar to the above, it can be shown that Datalog ¬¬ expresses precisely the while queries <ref type="bibr" target="#b5">[6]</ref>.</p><p>How about the relationship between Datalog ¬ and Datalog ¬¬ ? Clearly, Datalog ¬ is subsumed by Datalog ¬¬ . Intuitively, it is tempting to believe that Datalog ¬¬ is more powerful than Datalog ¬ (considering only terminating queries). However, this is far from obvious. Indeed, the following is a consequence of results in <ref type="bibr" target="#b6">[7]</ref> on the relationship between fixpoint and while: Theorem 4.5. Inflationary Datalog ¬ is strictly less expressive than Datalog ¬¬ iff ptime pspace.</p><p>Since it is open whether ptime pspace, the relationship between inflationary (or well-founded) Datalog ¬ and Datalog ¬¬ remains open. However, the strict inclusion is conjectured to be true. 1 The language Datalog ¬¬ is denoted in <ref type="bibr" target="#b5">[6]</ref> by Datalog ¬⋆</p></div>
<div><head n="4.3">Datalog ¬ new</head><p>All the languages considered so far express queries within dbpspace. Intuitively, this is so because each program uses a fixed number of relations of fixed arity, which are filled in the course of the computation with tuples over the elements of the input. Thus, such programs can build an amount of space which is no more than polynomial in the number of elements of the input.</p><p>Suppose that we wish to have a complete language, i.e. a language expressing all queries. One way to break the polynomial "space barrier", first suggested in <ref type="bibr" target="#b3">[4]</ref>, is to allow programs to invent new values in the course of the computation. Besides the computational justification, this is useful in object-oriented databases, where the creation of new object identifiers is a useful and very common feature. Such a feature was studied in the object-oriented language IQL <ref type="bibr" target="#b11">[12]</ref>.</p><p>We describe an extension of Datalog ¬ , defined in <ref type="bibr" target="#b5">[6]</ref>, that expresses all deterministic queries. This extension introduces new values in the course of the computation (but not in the answer). We informally describe the language, denoted by Datalog ¬ new . The syntax is the same as that of Datalog ¬ , except that variables that do not appear in body of a rule may appear in its head. The inflationary semantics of this language is similar to that of Datalog ¬ . The only difference consists in the use of the variables that occur only in heads of rules: these are valuated outside the current active domain, thus resulting in the "invention" of new values. Specifically, in the application of the immediate consequence operator, each instantiation of a rule body in the current active domain is extended with one instantiation of the remaining variables with distinct values outside the active domain. The choice of the particular new values is nondeterministic. However, this is the only source of nondeterminism. If the final result contains only values from the input, which can be enforced by a straightforward syntactic safety restriction, then the query defined by such a program is deterministic. Furthermore, Datalog ¬ new is complete: Theorem 4.6.</p><p>[6] Datalog ¬ new expresses all deterministic queries.</p><p>Intuitively, the proof uses the invented values to simulate the Turing machine computing the query, as well as the encodings of the input database on the initial Turing tape, and the decoding of the output. Each total order of the active domain generates one standard encoding, and the computation is carried out in parallel on all the encodings. The new values provide the unbounded amount of space needed for the simulation, thus overcoming the pspace barrier.</p><p>The relative expressive power of the various rule-based languages is summarized in Figure <ref type="figure" target="#fig_3">1</ref>. The arrow ⇑ indicates strict inclusion and the arrow ↑ indicates strict inclusion iff ptime pspace.</p><p>We note that Datalog extensions with forward chaining semantics that model various active databases are investigated in <ref type="bibr" target="#b105">[104]</ref>. The results provide insight into the programming paradigm of active databases, the interplay of various features, and their impact on expressiveness and complexity. In particular, this yields highly expressive active database languages capturing pspace, exptime, expspace, as well as all computable queries, on ordered databases.</p></div>
<div><head>Datalog ¬</head><p>new ≡ all computable queries ⇑ Datalog ¬¬ ≡ while ↑ well-founded Datalog ¬ ≡ inflationary Datalog ¬ ≡ fixpoint ⇑ stratified Datalog ¬ ⇑ Datalog </p></div>
<div><head n="4.4">Limitations in expressive power</head><p>Although the languages discussed here are quite powerful, they have certain shortcomings with regard to expressive power. Indeed, there are very "simple" queries that none of the languages can express. The prototypical example is the evenness query on a unary relation:</p><formula xml:id="formula_13">even(R) = true if | R | is even f alse if | R | is odd.</formula><p>where |R| is the number of elements in R.</p><p>This difficulty is not specific to rule-based languages. Indeed, it extends to most deterministic languages. To understand the difficulty involved, consider the natural way to compute the query: remove elements from R one at a time, and keep a binary counter. However, the elements of R are logically undistinguishable one from another, so no deterministic language that adheres to the data independence principle can perform the algorithm just described. There are two ways out: (i) sacrifice data independence, or (ii) sacrifice determinism by allowing a nondeterministic construct to pick an arbitrary element from a set. We will explore each of these tradeoffs in turn. Suspending the data independence principle is modeled by access to an order among the elements in the database (which is a reasonable mathematical metaphor for access to the additional symmetry-breaking information provided by the internal storage).</p><p>Intuitively, there is a strong connection between the use of order (i.e., information on the internal storage) and nondeterminism. If a query is implemented using information on internal storage, then the answer may depend on such information and thus appear nondeterministic at the logical level.</p></div>
<div><head n="4.5">The impact of order</head><p>The assumption that databases are ordered can have dramatic impact on the expressive power of languages. In ordered databases, the schema is assumed to contain a binary relation providing a total order on the active domain of each instance. With this assumption, it turns out that stratified Datalog ¬ , inflationary Datalog ¬ , and Datalog ¬ with well-founded semantics are all equivalent and express precisely db-ptime. Furthermore, the apparently much weaker semi-positive Datalog ¬ , consisting of Datalog ¬ where negation is only applied to edb relations, is almost as powerful as these languages. The "almost" is due to a technicality concerning the order: we also need to assume that the minimum and maximum constants are explicitly given. Surprisingly, these constants, that can be computed with an FO query if an order is given, cannot be computed with semi-positive programs. Theorem 4.7. Stratified Datalog ¬ , Datalog ¬ with well-founded semantics, and inflationary Datalog ¬ are equivalent on ordered databases and express exactly the db-ptime queries. They are also equivalent to semi-positive Datalog ¬ on ordered databases with min and max and express exactly the db-ptime queries.</p><p>The result that semi-positive Datalog ¬ expresses db-ptime on ordered databases with min and max is due to <ref type="bibr" target="#b102">[101]</ref>. The result that inflationary Datalog ¬ expresses db-ptime follows from results in <ref type="bibr" target="#b5">[6]</ref> (equivalence of inflationary Datalog ¬ and fixpoint) and <ref type="bibr" target="#b83">[83,</ref><ref type="bibr" target="#b115">114]</ref> (who showed that fixpoint expresses db-ptime on ordered databases).</p><p>Without the order assumption, there is no known deterministic language that expresses precisely the db-ptime queries. Indeed, the existence of such a language remains one of the main open problems in the theory of query languages (e.g., see <ref type="bibr" target="#b79">[79]</ref>).</p><p>The following characterizes the power of Datalog ¬¬ on ordered databases. It follows from a result of <ref type="bibr" target="#b5">[6]</ref> showing the equivalence of Datalog ¬¬ and while, and from a result of <ref type="bibr" target="#b115">[114]</ref> showing that while expresses db-pspace on ordered databases. Theorem 4.8. Datalog ¬¬ expresses exactly the db-pspace queries on ordered databases.</p></div>
<div><head n="5">NONDETERMINISTIC LANGUAGES</head><p>The arguments in favor of nondeterministic languages are both practical and theoretical. The first is that nondeterminism occurs naturally in many practical settings. There are natural nondeterministic queries and updates, whose implementation using deterministic languages is contrived and inefficient. There are well-known applications in Artificial Intelligence which naturally lead to nondeterminism, and expert systems shells (such as KEE or OPS5 <ref type="bibr" target="#b39">[39,</ref><ref type="bibr" target="#b59">59]</ref>) whose rule-based components work nondeterministically. Reactive systems, such as data-driven workflows, are usually nondeterministic (e.g., see <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b78">78]</ref>). The theoretical arguments for nondeterminism involve primarily the expressive power of nondeterministic languages. Indeed, the use of nondeterminism circumvents some of the expressiveness limitations discussed above, associated with deterministic languages. As mentioned, it is conjectured that there is no deterministic language expressing exactly the queries computable in polynomial time. On the other hand, there are nondeterministic languages expressing exactly the (deterministic and nondeterministic) queries computable in polynomial time.</p></div>
<div><head n="5.1">Nondeterministic Datalog ¬(¬)</head><p>We next consider nondeterministic versions of the Datalog ¬(¬) languages. Recall that the procedural, deterministic semantics for these languages was the result of evaluating programs by repeatedly firing all rules in parallel, up to a fixpoint. The nondeterministic semantics is obtained by firing one instantiation of a rule at a time, based on a nondeterministic choice. For instance consider the program:</p><formula xml:id="formula_14">¬G(x, y) ← G(x, y), G(y, x).</formula><p>With deterministic semantics, the program removes from the graph G all cycles of length two. With the nondeterministic semantics, the program computes one of several possible "orientations" for G (i.e., for every pair of edges (x, y) and (y, x) in G, one of the edges is removed).</p><p>We first define the syntax of the nondeterministic version of Datalog ¬¬ , denoted N-Datalog ¬¬ <ref type="bibr" target="#b5">[6]</ref>. The difference with the deterministic version is that heads of rules may contain several literals, and equality can be used in bodies. It can be seen that these features would be redundant with the deterministic semantics. Definition 5.1. A N-Datalog ¬¬ program is a finite set of rules of the form</p><formula xml:id="formula_15">A 1 ,...,A k ← B 1 ,...,B n (k ≥ 1, n ≥ 0)</formula><p>, where each A j is a literal of the form (¬) Q(x 1 ,...,x m ) (m ≥ 0), and each B i is a literal of the same form, or (¬) x 1 = x 2 (the x i 's are variables or constants). It is required that each variable occurring in the head of a rule also occur positively bound in the body. □ To formally define the nondeterministic semantics, we introduce the notion of (nondeterministic) immediate successor of a set of facts using a rule. Let r be an N-Datalog ¬¬ rule. Let I be a set of facts and r ′ be an instantiation of r such that (i) each literal of the body of r ′ is true in I , (ii) the head of r ′ is consistent and (iii) each variable is valuated to some constant occurring in I . Then the instance J obtained from I by deleting the facts A such that ¬A is in the head of r ′ , and inserting the facts A in the head of r ′ , is called an immediate successor of I using r .</p><p>By condition (ii) above, an instantiation of a rule is not considered if its head contains a literal and its negation. Definition 5.2. Let P be an N-Datalog ¬¬ program. The effect of P is a relation over sets of facts defined as follows: for each I , (I, J ) is in eff(P) iff there exists a sequence I 0 = I, ..., I n = J such that (i) for each i, I i+1 is an immediate successor of I i using some r in P, and (ii) there is no immediate successor J ′ J of J using some rule in P. □</p><p>The language N-Datalog ¬ is a specialization of N-Datalog ¬¬ obtained by disallowing negative literals in heads of rules (thus, negation can only occur in bodies of rules).</p></div>
<div><head n="5.2">Expressive power</head><p>We present several results on the expressive power of N-Datalog ¬ and N-Datalog ¬¬ . As discussed earlier, the most significant result involves expressibility of ndb-ptime.</p><p>We consider first the expressive power of N-Datalog ¬¬ .</p><p>Theorem 5.3.</p><p>[6] N-Datalog ¬¬ expresses exactly ndb-pspace.</p><p>Consider next the expressive power of N-Datalog ¬ . It is easy to see that each N-Datalog ¬ query is in ndb-ptime. It turns out that there are simple ndb-ptime queries that cannot be expressed in N-Datalog ¬ . We show this next, and then show how N-Datalog ¬ can be augmented to increase the expressive power to ndb-ptime.</p><p>The strict inclusion in ndb-ptime is shown using the following example <ref type="bibr" target="#b5">[6]</ref>.</p><p>Example 5.4. Let R = {P(A),Q(AB)}. It can be shown that there is no N-Datalog ¬ program which computes Pπ A (Q).</p><p>The precise characterization of the power of N-Datalog ¬ is open. We note, however, that N-Datalog ¬ expresses exactly ndb-ptime in the presence of order. As seen in the example above, there are very simple queries that N-Datalog ¬ cannot compute. We now look at the origin of this weakness and show how it can be corrected. Note that N-Datalog ¬ does not provide sufficient control capability to simulate the composition of two programs. Indeed, P -π A (Q) can be obtained as the composition of the mappings defined by the following two rules:</p><p>T (x) ← Q(x, y), and answer (x) ← P(x), ¬T (x).</p><p>The weak control capability of N-Datalog ¬ makes it impossible for programs in this language to simulate the explicit control necessary to compute ndb-ptime queries. Note that, in the case of N-Datalog ¬¬ , the control needed is provided by deletions. For example, the query in Example 5.4 is computed by the following N-Datalog ¬¬ program:</p><formula xml:id="formula_16">answer (x) ← P(x) ¬answer (x), ¬P(x) ← Q(x, y).</formula><p>The constructs we add to N-Datalog ¬ essentially provide sufficient control to simulate composition (in an inflationary manner). We consider two alternative constructs. The first construct allows for an "inconsistency" symbol ⊥ to appear in heads of rules. The resulting language is denoted N-Datalog ¬ ⊥. The idea is that if such a symbol is derived in a computation, that particular computation is abandoned. The second construct is universal quantification in bodies of rules and yields the language N-Datalog ¬ ∀. We first present N-Datalog ¬ ⊥, then N-Datalog ¬ ∀. These languages are from <ref type="bibr" target="#b5">[6]</ref>.</p><p>N-Datalog ¬ ⊥: The language N-Datalog ¬ is extended with the symbol ⊥ that can occur only as a literal in the head of rules. A pair (I,J) is in the effect of a N-Datalog ¬ ⊥ program iff J is obtained by a computation where ⊥ is not derived.</p><p>N-Datalog ¬ ∀: The language N-Datalog ¬ is extended to allow rules of the form:</p><formula xml:id="formula_17">A 1 , ..., A q ← ∀ì xB 1 , ..., B n ,</formula><p>where ì</p><p>x is a sequence of variables occurring only in the body of the rule. Let ì y be the vector of the variables occurring in B 1 , ..., B n and not in ì</p><p>x, and v be a valuation of ì y. The rule is fired with valuation v if for each extension v of v to the variables in ì</p><p>x (which valuates variables in ì</p><p>x in the active domain), vB 1 ∧ ... ∧ vB n holds. To illustrate these two languages, we show how to compute the query of Example 5.4 with N-Datalog ¬ ∀ or N-Datalog ¬ ⊥ programs.</p><p>Example 5.5. The mapping Pπ A (Q) is computed by the following N-Datalog ¬ ∀ program: answer (x) ← ∀yP(x), ¬Q(x, y).</p><p>A N-Datalog ¬ ⊥ program computing the same query is:</p><formula xml:id="formula_18">PRO J (x)</formula><p>← ¬done-with-proj, Q(x, y) done-with-proj ← ⊥ ← done-with-proj, Q(x, y), ¬PRO J (x) answer (x) ← done-with-proj, P(x), ¬PRO J (x).</p><p>Intuitively, in N-Datalog ¬ ∀, one can check that a stage is completed (using ∀) before proceeding to the next one; this allows simulating composition. In N-Datalog ¬ ⊥, a detected error leads to the derivation of ⊥. The following shows that in fact these constructs provide sufficient power to bridge the gap between N-Datalog ¬ and ndb-ptime. Theorem 5.6. <ref type="bibr" target="#b5">[6]</ref> For each query τ the following are equivalent:</p><formula xml:id="formula_19">• τ is in ndb-ptime,</formula><p>• τ is defined by a N-Datalog ¬ ⊥ program, and • τ is defined by a N-Datalog ¬ ∀ program.</p><p>We have seen so far nondeterministic languages capturing ndbpspace and ndb-ptime. Similarly to the deterministic case, a complete language can be obtained by augmenting N-Datalog ¬ with the ability to create new values. The resulting language is denoted N-Datalog ¬ new .</p><p>Theorem 5.7.</p><p>[6] N-Datalog ¬ new expresses all nondeterministic queries.</p><p>It turns out that the nondeterministic languages described above are closely related to nondeterministic extensions of fixpoint logics, introduced in <ref type="bibr" target="#b13">[14]</ref> (see also <ref type="bibr" target="#b14">[15]</ref>). In these languages, nondeterminism is provided by a witness operator W . Informally, W xφ( x) results in nondeterministically choosing a value of x that satisfies φ( x). The addition of W to fixpoint logics yields nondeterministic extensions FO + IFP + W of inflationary fixpoint logic, and FO + PFP + W of partial fixpoint logic. It is shown in <ref type="bibr" target="#b13">[14]</ref> that N-Datalog ¬¬ is equivalent to FO + PFP + W , and N-Datalog ¬ ∀ (as well as N-Datalog ¬ ⊥) is equivalent to FO + IFP + W .</p><p>We note that another way to introduce nondeterminism in rulebased languages is provided by the choice operator first presented in <ref type="bibr" target="#b90">[90]</ref>. This construct has been included in the language LDL, an implementation of Datalog ¬ <ref type="bibr" target="#b100">[99]</ref>. Variations of the choice operator, and its connection with stable models of Datalog ¬ programs, are further studied in <ref type="bibr" target="#b66">[66,</ref><ref type="bibr" target="#b110">109]</ref>. The expressive power of the choice operator in the context of Datalog is investigated in <ref type="bibr" target="#b52">[52]</ref>. The main result exhibits a language expressing exactly ndb-ptime. Further Datalog languages using the choice operator and expressing the Boolean hierarchy are exhibited in <ref type="bibr" target="#b76">[76]</ref>.</p></div>
<div><head n="5.3">Connections with Determinism</head><p>Recall that one of the motivations for considering nondeterministic languages is their ability to express more deterministic queries. In this section we consider the ability of various nondeterministic languages to express deterministic queries. We also consider the deterministic queries definable by considering the "possible" and "certain" answers of a nondeterministic query, in the spirit of queries on databases with incomplete information. The results are from <ref type="bibr" target="#b2">[3]</ref>.</p><p>The notion of deterministic fragment expressed by a language is defined next.</p><p>Definition 5.8. The deterministic fragment of a (nondeterministic) language is the set of deterministic queries defined by programs in the language. The deterministic fragment of a language L is denoted det(L). □</p><p>In the previous section we characterized the nondeterministic queries expressible in the various languages. These results can be used to characterize the deterministic fragments expressible in these languages. Thus, we have: Theorem 5.9.</p><p>(1) det(N-Datalog ¬ ∀) = det(N-Datalog ¬ ⊥) = db-ptime.</p><p>(2) det(N-Datalog ¬¬ ) = db-pspace.</p><p>It is important to note that (1) does not provide a language expressing db-ptime, since it is undecidable whether a N-Datalog ¬ ∀ or N-Datalog ¬ ⊥ program defines a deterministic query.</p><p>An alternative way of obtaining deterministic queries using nondeterministic programs is suggested by the work of <ref type="bibr" target="#b82">[82]</ref> on incomplete information. Indeed, there is a natural connection between incomplete information and nondeterminism. As noted in <ref type="bibr" target="#b0">[1]</ref>, incomplete information can be seen as resulting from incompletely specified (therefore nondeterministic) updates. The notions of possible and certain answers in <ref type="bibr" target="#b82">[82]</ref> suggest the following definition: The poss or cert semantics yield significant power: Theorem 5.11.</p><p>(1) poss(N-Datalog ¬ ∀) = poss(N-Datalog ¬ ⊥) = db-np.</p><p>(2) cert(N-Datalog ¬ ∀) = cert(N-Datalog ¬ ⊥) = db-co-np.</p><p>(3) cert(N-Datalog ¬¬ ) = poss(N-Datalog ¬¬ ) = db-pspace.</p><p>Observe that, for N-Datalog ¬¬ , the poss and cert semantics do not yield additional power. In particular, these semantics can be simulated within the deterministic fragment of N-Datalog ¬¬ . This concludes our review of the Datalog-like languages with forward chaining semantics, studied in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b117">116]</ref>. We next discuss briefly some of the developments in Datalog research since these languages have been proposed, and situate them in the broader context.</p></div>
<div><head n="6">DATALOG REDUX</head><p>Over time, research on recursive queries has been received by the database systems community with varying degrees of enthusiasm. By the end of the 80's, the attitude towards Datalog research had turned largely negative. This is perhaps best exemplified by the influential Laguna Beach report of 1989 <ref type="bibr" target="#b103">[102]</ref>, which includes this statement: "The participants were unanimously negative on the prospective research contribution of general recursive query processing, and interfaces between a DBMS and Prolog. " As late as 1998, the no less influential <ref type="bibr" target="#b112">[111]</ref>, stated that "No practical applications of recursive query processing have been found to date".</p><p>And yet they persisted. Despite the ups-and-downs in popularity, work on Datalog-like languages continued in the database and logic programming communities in the 80's and 90's. On the theoretical front, there was much work on the expressiveness and complexity of Datalog-like languages (for a comprehensive survey, see <ref type="bibr" target="#b54">[54]</ref>). Driven by theoretical and practical considerations, many extensions of Datalog have been put forward. They include arithmetic, sets, disjunction, aggregation, constraints, object-oriented constructs, complex objects, updates, etc. This has resulted in an entire ecosystem of languages, many of which were implemented. An excellent survey of these developments is provided in <ref type="bibr" target="#b97">[96]</ref>.</p><p>Research on Datalog was eventually rehabilitated in the database systems community and beyond. In an invited PODS 2010 talk <ref type="bibr" target="#b80">[80]</ref> and companion paper <ref type="bibr" target="#b81">[81]</ref>, Joe Hellerstein delivered an impassioned rehabilitation of Datalog from the viewpoint of the systems community, pointing out the widespread use and effectiveness of Datalog-like languages in areas as diverse as security and privacy protocols, program analysis, natural language processing, probabilistic inference, modular robotics, multiplayer games, telecom diagnosis, networking, and distributed systems.</p><p>The last two decades have seen a robust "Datalog Spring" in which Datalog research has expanded with renewed energy. The sequence of Datalog workshops on the theme of the "Resurgence of Datalog in Academia and Industry" <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b55">55]</ref> was emblematic of this optimism. A broad account of this renewed activity, within and beyond the database community, can be found in <ref type="bibr" target="#b97">[96]</ref>. Notable in the database theory community has been an increased symbiosis between theoretical research and practice (even yielding a number of start-ups!), as well as increased presence in adjacent areas such as AI and Knowledge Representation. Following are a few representative examples.</p><p>Datalog for networking Networking is an area where recursive processing and reasoning occurs naturally, and has led to the rise of "declarative networking", in which Datalog variants are used to specify and reason about distributed protocols and services (e.g., see <ref type="bibr" target="#b81">[81,</ref><ref type="bibr" target="#b94">93,</ref><ref type="bibr" target="#b95">94]</ref>). These languages extend Datalog with a variety of features, including location identifiers, timestamps, and states (in the spirit of Statelog <ref type="bibr" target="#b91">[91]</ref>). Dedalus and Bloom, both Datalog variants, were put forward by Hellerstein's team as a promising foundation for programming and reasoning about distributed systems <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19]</ref>. Their investigation of consistency properties of distributed systems led to the so called "CALM conjecture", <ref type="bibr" target="#b80">[80,</ref><ref type="bibr" target="#b81">81]</ref> which was subsequently studied in the database theory community using a model of communicating transducers <ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref>. The use of the declarative approach in network monitoring was also explored in <ref type="bibr" target="#b8">[9]</ref>. It should be noted that the term "declarative" refers broadly to Datalog-like rule-based languages, with a mix of declarative and procedural semantics (e.g., see <ref type="bibr" target="#b104">[103]</ref>). Negation, when present, is typically restricted to be stratified (and interpreted under stratified semantics). See <ref type="bibr" target="#b95">[94]</ref> for a survey on declarative networking circa 2012.</p><p>Datalog for data extraction The Lixto project <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b69">69]</ref> is a poster child for successful practical applications of Datalog relying on significant theoretical foundations. Lixto focuses on Web data extraction and has at its core Monadic Datalog over trees. The approach relies on deep and elegant theoretical results on the expressiveness and complexity of Monadic Datalog on trees and structures of bounded tree width <ref type="bibr" target="#b67">[67,</ref><ref type="bibr" target="#b68">68,</ref><ref type="bibr" target="#b70">[70]</ref><ref type="bibr" target="#b71">[71]</ref><ref type="bibr" target="#b72">[72]</ref><ref type="bibr" target="#b73">[73]</ref><ref type="bibr" target="#b74">[74]</ref>. In particular, it is shown in <ref type="bibr" target="#b68">[68]</ref> that Monadic Datalog captures exactly Monadic Second Order logic over trees. This provides the expressiveness needed by wrappers for Web data extraction, while also guaranteeing efficiency. The Lixto project has been incorporated in a commercial product, McKinsey Periscope. A follow-up project, DIADEM, aimed to achieve fully automatic wrapper generation and uses at its core a related language based on Datalog <ref type="bibr" target="#b60">[60]</ref>.</p><p>Datalog for ontologies Datalog has proven to be an effective formalism for specifying and answering queries over ontologies. In particular, it provides an elegant unifying formalism that subsumes well-known description logics. Datalog+/-is a family of Datalog variants put forward for this purpose <ref type="bibr" target="#b40">[40]</ref><ref type="bibr" target="#b41">[41]</ref><ref type="bibr" target="#b42">[42]</ref>. The Datalog+/-languages are obtained by first extending Datalog with existentially quantified variables in heads of rules, then considering various restrictions (guarded, linear, and weakly guarded) to ensure tractability. Other extensions, such as falsity in heads of rules, keys, and stratified negation, are also considered, and their complexity characterized. Importantly, the Datalog+/-family of languages can express the popular DLite family <ref type="bibr" target="#b44">[44,</ref><ref type="bibr" target="#b45">45]</ref> of descriprion logics. It also subsumes F-logic Lite <ref type="bibr" target="#b43">[43]</ref>, a tractable fragment of the well-known F-logic <ref type="bibr" target="#b85">[85]</ref>, central in deductive object-oriented databases.</p><p>Datalog for knowledge graphs An outgrowth of Datalog+/-, <software ContextAttributes="created">Vadalog</software> is a Datalog-based language geared towards reasoning about knowledge graphs <ref type="bibr" target="#b33">[33]</ref><ref type="bibr" target="#b34">[34]</ref><ref type="bibr" target="#b35">[35]</ref>. <software ContextAttributes="created">Vadalog</software> has at its core Warded Datalog+/-, a variant of Datalog+/-that has good properties in terms of expressiveness and complexity <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b75">75]</ref>. <software ContextAttributes="created">Vadalog</software> is part of the VADA project <ref type="bibr" target="#b89">[89,</ref><ref type="bibr">112]</ref>, in which <software ContextAttributes="created">Vadalog</software> is extended with various features, including access to external resources such as text processing, data analytics and machine learning, modeled uniformly as transducers. The VADA project has generated considerable interest from industrial partners. Data analytics on big graphs is also provided by the <software ContextAttributes="created">BigDatalog</software> system <ref type="bibr" target="#b111">[110]</ref> that relies on Datalog extended with aggregates, with fixpoint semantics <ref type="bibr" target="#b119">[118]</ref>.</p><p>Datalog for data exchange on the Web Datalog variants are used in several approaches for high-level specifications of data sharing and exchange on the Web. Orchestra <ref type="bibr" target="#b78">[78,</ref><ref type="bibr" target="#b84">84]</ref> is a collaborative data sharing system that supports the exchange of data and updates among peers and relies on an extension of Datalog with Skolem functions. <software ContextAttributes="used">Webdamlog</software> is a Datalog variant used to exchange data among peers on the Web, with the novel twist that rules can also be exchanged, in addition to data <ref type="bibr" target="#b10">[11]</ref>. <software ContextAttributes="used">Webdamlog</software> also uses updates in heads of rules, similarly to N-Datalog ¬¬ (see Section 4.2). The semantics is nondeterministic and based on forward chaining, similarly to active rules. Interestingly, the abilty to exchange rules is more than syntactic sugar: it increases the expressiveness of the language. The exchange of rules is also used in Active XML, whose core is a rule-based language using tree patterns <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13]</ref>.</p><p>Datalog for data management Several startups have emerged that provide full data management systems relying on Datalog variants. <software ContextAttributes="used">LogicBlox</software> is a commercial database system that supports sophisticated analytics and is implemented on top of LogiQL, a rich extension of Datalog <ref type="bibr" target="#b29">[29]</ref>. LogiQL can support business applications, workflows and data analytics, and is evaluated bottom-up. <software ContextAttributes="used">LogicBlox</software> also contains updates needed for interactive features, in the spirit of Datalog ¬¬ <ref type="bibr" target="#b77">[77]</ref>. Interestingly, the <software ContextAttributes="used">LogicBlox</software> team included a substantial number of database theoreticians and produced some remarkable algorithms, such as the leapfrog trie join, shown to be optimal <ref type="bibr" target="#b116">[115]</ref> in the sense of <ref type="bibr" target="#b101">[100]</ref>. DATOMIC is another startup that has built a full data management system driven by a Datalog-like language <ref type="bibr" target="#b25">[26]</ref>.</p></div>
<div><head n="7">CONCLUSION</head><p>We have reviewed the procedural, forward chaining approach to Datalog developed in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b117">116]</ref>, and briefly the state of contemporaneous Datalog research and later developments.</p><p>How does the procedural, forward chaining semantics measure up against the declarative alternative? The two paradigms are philosophically very different. The declarative approach attempts to model a natural reasoning process. In particular, consistency in the reasoning process is required: one cannot use a fact and later infer its negation, as can happen in the procedural semantics. As we have seen, the solution is ideally described as a model of the program satisfying certain desirable properties, such as minimality. However, in the presence of negation, the lack of a unique minimal model leads to the need to specify an "intended" model among several possible candidates. Beyond stratified semantics, the criteria for selecting the intended model become increasingly contrived. Furthermore, the assumption that the chosen criterion captures a fictitious programmer's natural reasoning process rests on shallow ground.</p><p>In contrast, the procedural, forward chaining approach provides semantics that is extremely simple to describe. However, the semantics is purely computational and does not yield a solution easily justifiable in model theoretic terms, beyond the fact that the answer is one model of the program. Also, despite the simplicity of the computational semantics, programs can be hard to understand, as their effect is very sensitive to timing (e.g., see Examples 4.1 and 4.3). In terms of expressiveness, the Datalog-like languages with forward chaining semantics provide a unifying formalism capable of capturing the main classes of queries, including fixpoint, while, and all the way to computable queries. They can also incorporate in a natural manner nondeterminism and updates. Declarative semantics seems to hit an expressiveness ceiling with well-founded semantics, capturing the fixpoint queries.</p><p>The final test for the various semantics has to rest with programmers and adoption in practical languages. In that respect, the forward chaining approach was an early leader, having been adopted in production systems and expert systems <ref type="bibr" target="#b39">[39,</ref><ref type="bibr" target="#b59">59]</ref> as well as active databases <ref type="bibr" target="#b118">[117]</ref>, at a time when implementations of deductive databases were limited to prototypes (see <ref type="bibr" target="#b108">[107]</ref> for an early survey of deductive database implementations). Subsequently, the landscape became much more diverse. There have been many implementations of Datalog variants, with declarative and procedural semantics (e.g., see <ref type="bibr" target="#b97">[96]</ref>). Most practical Datalog-like languages use stratified negation, which emerges as the indisputable success story of declarative semantics. As seen above, Datalog-like languages with forward chaining semantics, with features including updates and nondeterminism, remain common in a limited class of applications, mostly those that can be viewed as data-driven reactive systems. Such applications include active databases, production systems, data-driven workflows, peer-to-peer data exchange, and systems supporting interactive features (e.g., see <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b56">56,</ref><ref type="bibr" target="#b77">77,</ref><ref type="bibr" target="#b104">103,</ref><ref type="bibr" target="#b118">117]</ref>).</p><p>Overall, the forward chaining paradigm has demonstrated its theoretical appeal and persistence in practice. It will most likely continue to provide a useful alternative within the rich landscape of Datalog.</p></div><figure xml:id="fig_0"><head>Example 4 . 1 .</head><label>41</label><figDesc>We present a Datalog ¬ program with input a graph in binary relation G. The program computes the relation closer (x, y, x ′ , y ′ ) defined as follows:</figDesc></figure>
<figure xml:id="fig_1"><head /><label /><figDesc>where d(a, b) denotes the distance between nodes a and b in G.</figDesc></figure>
<figure xml:id="fig_2"><head>Example 4 . 4 .</head><label>44</label><figDesc>Let G be a binary relation schema. Consider the fixpoint program дood + = ∅; while chanдe do дood + = φ where φ = ∀y (G(y, x) → дood(y)).</figDesc></figure>
<figure xml:id="fig_3"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Relative expressive power of Datalog variants.</figDesc></figure>
<figure xml:id="fig_4"><head>Definition 5 . 10 .</head><label>510</label><figDesc>Given a nondeterministic program P, the image of an input I under P with the possibility semantics (denoted poss(I, P)) and the certainty semantics (denoted cert(I, P)) are defined by: poss(I, P) = {J | (I, J) ∈ eff(P)}, and cert(I, P) = {J | (I, J) ∈ eff(P)}. The deterministic queries expressed by a program P under possibility semantics is denoted poss(P), and under certainty semantics cert(P). For a language L, poss(L) = {poss(P) | P ∈ L} and cert(L) = {cert(P) | P ∈ L}.</figDesc></figure>
<figure type="table" xml:id="tab_0"><head>•</head><label /><figDesc>The nondeterministic query whose answer is obtained by deleting one of the edges ⟨a, b⟩ or ⟨b, a⟩ for every cycle {⟨a, b⟩, ⟨b, a⟩} is a query in ndb-ptime.• The query whose answer is a unary relation which is empty if the graph has no Hamiltonian circuit and is the set of vertices of the graph otherwise, is in db-np (because testing for Hamiltonicity has complexity np).</figDesc><table /></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>R n are relation names, and u 1 , . . . , u n are free tuples (tuples of variables and constants). Each variable occurring in u 1 must occur in at least one of u 2 , . . . , u n . A Datalog program is a finite set of Datalog rules. The head of the rule is the expression R 1 (u 1 ); and R 2 (u 2 ), . . . , R n (u n ) forms the body.</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This work was supported in part by the <rs type="funder">ANR</rs> <rs type="projectName">Headwork</rs> project <rs type="grantNumber">ANR-16-CE23-0015</rs> and the <rs type="funder">National Science Foundation</rs> under award <rs type="grantNumber">III-1815247</rs>. The author is grateful to <rs type="person">Pierre Bourhis</rs> and <rs type="person">Luc Segoufin</rs> for their insightful comments on this paper. Special thanks to <rs type="person">Serge Abiteboul</rs> for revisiting our joint work and providing many useful suggestions for the presentation.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_8YQQxDz">
					<idno type="grant-number">ANR-16-CE23-0015</idno>
					<orgName type="project" subtype="full">Headwork</orgName>
				</org>
				<org type="funding" xml:id="_uXNpgX8">
					<idno type="grant-number">III-1815247</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Update semantics for incomplete databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Very Large Data Bases</title>
		<meeting>of Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Foundations of databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Non-deterministic languages to express deterministic transformations</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A transaction language complete for database update and specification</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="260" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Procedural and declarative database update languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="240" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Datalog extensions for database queries and updates</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="62" to="124" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Generic computation and its complexity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGACT Symp. on the Theory of Computing</title>
		<meeting>ACM SIGACT Symp. on the Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="209" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Non-determinism in logic-based languages</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Math. and Artif. Int</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="151" to="186" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Diagnosis of asynchronous discrete event systems: datalog to the rescue!</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zoë</forename><surname>Abrams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Haar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="358" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Active XML project: an overview</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omar</forename><surname>Benjelloun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1019" to="1040" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A rule-based language for web data management</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alban</forename><surname>Galland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Émilien</forename><surname>Antoine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="293" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Object identity as a query language primitive</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paris</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="798" to="842" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Static analysis of active XML systems</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="23" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>Also in PODS 2008</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Fixpoint extensions of first-order logic and Datalog-like languages</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Logic in Computer Science</title>
		<meeting>IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="71" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Non-determinism in logic-based languages</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math. Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2-4</biblScope>
			<biblScope unit="page" from="151" to="186" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Collaborative data-driven workflows: think global, act local</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="91" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Universality of data retrieval languages</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Programming Languages</title>
		<meeting>ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="110" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Consistency analysis in Bloom: a CALM and collected approach</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Alvaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neil</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">R</forename><surname>Marczak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR 2011, Fifth Biennial Conference on Innovative Data Systems Research</title>
		<title level="s">Online Proceedings</title>
		<meeting><address><addrLine>Asilomar, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">January 9-12, 2011. 2011</date>
			<biblScope unit="page" from="249" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Dedalus: Datalog in time and space</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Alvaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">R</forename><surname>Marczak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neil</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Russell</forename><surname>Sears</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Datalog Reloaded -First International Workshop, Datalog 2010</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">March 16-19, 2010. 2010</date>
			<biblScope unit="volume">6702</biblScope>
			<biblScope unit="page" from="262" to="281" />
		</imprint>
	</monogr>
	<note>Revised Selected Papers</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<ptr target="-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Datalog 2.0 2019 -3rd International Workshop on the Resurgence of Datalog in Academia and Industry co-located with the 15th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2019) at the Philadelphia Logic Week 2019</title>
		<title level="s">CEUR Workshop Proceedings. CEUR</title>
		<editor>
			<persName><forename type="first">Mario</forename><surname>Alviano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</editor>
		<meeting><address><addrLine>Philadelphia, PA (USA)</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">June 4-5, 2019. 2019</date>
			<biblScope unit="volume">2368</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Declarative networking: Recent theoretical work on coordination, correctness, and declarative semantics</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tom</surname></persName>
		</author>
		<author>
			<persName><surname>Ameloot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="5" to="16" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Deciding eventual consistency for a simple class of relational transducer networks</title>
		<author>
			<persName><forename type="first">Tom</forename><forename type="middle">J</forename><surname>Ameloot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Database Theory</title>
		<editor>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</editor>
		<meeting>of Intl. Conf. on Database Theory</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="86" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Putting logic-based distributed systems on stable grounds</title>
		<author>
			<persName><forename type="first">Tom</forename><forename type="middle">J</forename><surname>Ameloot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">R</forename><surname>Marczak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Alvaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Pract. Log. Program</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="378" to="417" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Weaker forms of monotonicity for declarative networking: A more fine-grained answer to the calm-conjecture</title>
		<author>
			<persName><forename type="first">Tom</forename><forename type="middle">J</forename><surname>Ameloot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bas</forename><surname>Ketsman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Zinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="21" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Relational transducers for declarative networking</title>
		<author>
			<persName><forename type="first">Tom</forename><forename type="middle">J</forename><surname>Ameloot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Also in PODS 2011</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The Datomic database</title>
		<author>
			<persName><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gaare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Holguın</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pratley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Professional Clojure</title>
		<imprint>
			<publisher>Wiley Online Library</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="169" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Contributions to the theory of logic programming</title>
		<author>
			<persName><forename type="first">K</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Van Emden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="841" to="862" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Towards a theory of declarative knowledge</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Apt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Blair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Deductive Databases and Logic Programming</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="89" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title />
		<author>
			<persName><forename type="first">Morgan</forename><surname>Kaufmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>Los Altos, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Design and implementation of the LogicBlox system</title>
		<author>
			<persName><forename type="first">Molham</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Balder Ten Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emir</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">L</forename><surname>Pasalic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Veldhuizen</surname></persName>
		</author>
		<author>
			<persName><surname>Washburn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1371" to="1382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Expressive languages for querying the semantic web</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="14" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Datalog in Academia and Industry -Second International Workshop, Datalog 2</title>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">7494</biblScope>
			<biblScope unit="issue">0</biblScope>
			<date type="published" when="2012">September 11-13, 2012. 2012</date>
			<publisher>Springer</publisher>
			<pubPlace>Vienna, Austria</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Visual web information extraction with lixto</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Baumgartner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Flesca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Very Large Data Bases</title>
		<meeting>of Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Swift logic for big data and knowledge graphs</title>
		<author>
			<persName><forename type="first">Luigi</forename><surname>Bellomarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Intl. Joint Conference on Artificial Intelligence, IJCAI 2017</title>
		<meeting>of the Intl. Joint Conference on Artificial Intelligence, IJCAI 2017</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The Vadalog system: Datalog-based reasoning for knowledge graphs</title>
		<author>
			<persName><forename type="first">Luigi</forename><surname>Bellomarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="975" to="987" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The space-efficient core of Vadalog</title>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGAI Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGAI Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="270" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Minimalism subsumes default logic and circumscription</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Froidevaux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Logic in Computer Science</title>
		<meeting>IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="89" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">General logic databases and programs: Default logic semantics and stratification</title>
		<author>
			<persName><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Froidevaux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Information and Computation</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="15" to="54" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">L</forename><surname>Brownston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Farrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Martin</surname></persName>
		</author>
		<title level="m">Programming Expert Systems in OPS5</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Programming Expert Systems in OPS5: An Introduction to Rule-Based Programming</title>
		<author>
			<persName><forename type="first">Lee</forename><surname>Brownston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Farrell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elaine</forename><surname>Kant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nancy</forename><surname>Martin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<pubPlace>USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Datalog ± : a unified approach to ontologies and integrity constraints</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Database Theory</title>
		<editor>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</editor>
		<meeting>of Intl. Conf. on Database Theory</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">361</biblScope>
			<biblScope unit="page" from="14" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Datalog ± : a unified approach to ontologies and integrity constraints</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Database Theory</title>
		<meeting>of Intl. Conf. on Database Theory</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">361</biblScope>
			<biblScope unit="page" from="14" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Datalog+/-: A family of logical knowledge representation and query languages for new applications</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Marnette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Logic in Computer Science</title>
		<meeting>IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="228" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Containment of conjunctive object meta-queries</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd International Conference on Very Large Data Bases</title>
		<meeting>the 32nd International Conference on Very Large Data Bases<address><addrLine>Seoul, Korea</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">September 12-15, 2006. 2006</date>
			<biblScope unit="page" from="942" to="952" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Dl-lite: Tractable description logics for ontologies</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, The Twentieth National Conference on Artificial Intelligence and the Seventeenth Innovative Applications of Artificial Intelligence Conference</title>
		<meeting>The Twentieth National Conference on Artificial Intelligence and the Seventeenth Innovative Applications of Artificial Intelligence Conference<address><addrLine>Pittsburgh, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">July 9-13, 2005. 2005</date>
			<biblScope unit="page" from="602" to="607" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Tractable reasoning and efficient query answering in description logics: The DL-Lite family</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reason</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Foundations of data-aware process analysis: a database theory perspective</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giacomo</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Montali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Programming primitives for database languages</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Symp. on Principles of Programming Languages</title>
		<meeting>ACM Symp. on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="50" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Computable queries for relational data bases</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="156" to="178" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Structure and complexity of relational queries</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="99" to="128" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Horn clause queries and generalizations</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="15" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A relational model of data for large shared data banks</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">F</forename><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of the ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="377" to="387" />
			<date type="published" when="1970">1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Datalog with non-deterministic choice computes NDB-PTIME</title>
		<author>
			<persName><forename type="first">L</forename><surname>Corciulo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Giannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pedreschi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD)</title>
		<meeting>of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD)</meeting>
		<imprint>
			<biblScope unit="volume">93</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Skolem normal forms concerning the least fixpoint</title>
		<author>
			<persName><forename type="first">E</forename><surname>Dalhaus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computation Theory and Logic</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Börger</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin/New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">270</biblScope>
			<biblScope unit="page" from="101" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Complexity and expressive power of logic programming</title>
		<author>
			<persName><forename type="first">Evgeny</forename><surname>Dantsin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="374" to="425" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Datalog Reloaded -First International Workshop, Datalog 2010</title>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Oege De Moor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tim</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andrew</forename><forename type="middle">Jon</forename><surname>Furche</surname></persName>
		</editor>
		<editor>
			<persName><surname>Sellers</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">6702</biblScope>
			<date type="published" when="2010">March 16-19, 2010. 2011</date>
			<publisher>Springer</publisher>
			<pubPlace>Oxford, UK</pubPlace>
		</imprint>
	</monogr>
	<note>Revised Selected Papers</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Automatic verification of databasecentric systems</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="5" to="17" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Total and partial wellfounded Datalog coincide</title>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Flum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Max</forename><surname>Kubierschky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bertram</forename><surname>Ludäscher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Database Theory</title>
		<meeting>of Intl. Conf. on Database Theory</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="113" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Games and total Datalog¬ queries</title>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Flum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Max</forename><surname>Kubierschky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bertram</forename><surname>Ludäscher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">239</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="257" to="276" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">OPS5 user's manual</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Forgy</surname></persName>
		</author>
		<idno>CMU-CS-81-135</idno>
		<imprint>
			<date type="published" when="1981">1981</date>
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">DIADEM: thousands of websites to a single database</title>
		<author>
			<persName><forename type="first">Tim</forename><surname>Furche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giovanni</forename><surname>Grasso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaonan</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giorgio</forename><surname>Orsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Schallhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cheng</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="1845" to="1856" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Negation as failure using tight derivations for general logic programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symp. on Logic Programming</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="127" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">The alternating fixpoint of logic programs with negation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">The well-founded semantics for general logic programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Schlipf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="221" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">The well-founded semantics for general logic programs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Schlipf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="620" to="650" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">The stable model semantics for logic programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gelfond</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Logic Programming</title>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1070" to="1080" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Nondeterminism in deductive databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Giannotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Pedreschi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Saccà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD)<address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="volume">566</biblScope>
			<biblScope unit="page" from="129" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Monadic queries over tree-structured data</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Logic in Computer Science</title>
		<meeting>IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="189" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Monadic datalog and the expressive power of languages for web information extraction</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="74" to="113" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>Also in PODS 2002</note>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">The lixto data extraction project -back and forth between theory and practice</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Baumgartner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcus</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Flesca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Function symbols in tuple-generating dependencies: Expressive power and computability</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="65" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Bounded treewidth as a key to tractability of knowledge representation and reasoning</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fang</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, The Twenty-First National Conference on Artificial Intelligence and the Eighteenth Innovative Applications of Artificial Intelligence Conference</title>
		<meeting>The Twenty-First National Conference on Artificial Intelligence and the Eighteenth Innovative Applications of Artificial Intelligence Conference<address><addrLine>Boston, Massachusetts, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">July 16-20, 2006. 2006</date>
			<biblScope unit="page" from="250" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Tractable database design through bounded treewidth</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fang</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="124" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Abduction with bounded treewidth: From theoretical tractability to practically efficient computation</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fang</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence, AAAI 2008</title>
		<meeting>the Twenty-Third AAAI Conference on Artificial Intelligence, AAAI 2008<address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">July 13-17, 2008. 2008</date>
			<biblScope unit="page" from="1541" to="1546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Monadic datalog over finite structures of bounded treewidth</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fang</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Log</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="3" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>Also in PODS 2007</note>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Beyond SPARQL under OWL 2 QL entailment regime: Rules to the rescue</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence, IJCAI 2015</title>
		<meeting>the Twenty-Fourth International Joint Conference on Artificial Intelligence, IJCAI 2015<address><addrLine>Buenos Aires, Argentina</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">July 25-31, 2015. 2015</date>
			<biblScope unit="page" from="2999" to="3007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Extending stratified datalog to capture complexity classes ranging from P to QH</title>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Greco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Saccà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="699" to="725" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Datalog and recursive query processing</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shan</forename><forename type="middle">Shan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boon Thau</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenchao</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Found. Trends Databases</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="195" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">ORCHESTRA: facilitating collaborative data sharing</title>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olivier</forename><surname>Biton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1131" to="1133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">The quest for a logic capturing PTIME</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Grohe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Logic in Computer Science</title>
		<meeting>IEEE Symp. on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="267" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Datalog redux: experience and conjecture</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">The declarative imperative: experiences and conjectures in distributed logic</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="19" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">The relational model of data and cylindric algebras</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="80" to="102" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Relational queries computable in polynomial time</title>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="86" to="104" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">The ORCHESTRA collaborative data sharing system</title>
		<author>
			<persName><forename type="first">Zachary</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grigoris</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Partha</forename><forename type="middle">Pratim</forename><surname>Talukdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><forename type="middle">C N</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="26" to="32" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Logical foundations of objectoriented and frame-based languages</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Lausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="741" to="843" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">The expressive power of stratified logic programs</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="50" to="66" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Why not negation by fixpoint?</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="231" to="239" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">On the relation between default and autoepistemic logic</title>
		<author>
			<persName><forename type="first">S</forename><surname>Konolige</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="343" to="382" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">The VADA architecture for costeffective data wrangling</title>
		<author>
			<persName><forename type="first">Nikolaos</forename><surname>Konstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Koehler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edward</forename><surname>Abel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristina</forename><surname>Civili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Neumayr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Alvaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Fernandes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">A</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Keane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norman</forename><forename type="middle">W</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><surname>Paton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1599" to="1602" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Nondeterministic choice in datalog</title>
		<author>
			<persName><forename type="first">R</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Naqvi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">5th Int'l. Conf. on Data and Knowledge Bases</title>
		<meeting><address><addrLine>Los Altos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="416" to="424" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">On active deductive databases: The Statelog approach</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Lausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bertram</forename><surname>Ludäscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Transactions and Change in Logic Databases, International Seminar on Logic Databases and the Meaning of Change</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Schloss Dagstuhl, Germany; Port Jefferson, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996-10-27">September 23-27, 1996. October 17, 1997. 1998</date>
			<biblScope unit="volume">1472</biblScope>
			<biblScope unit="page" from="69" to="106" />
		</imprint>
	</monogr>
	<note>Surveys and Selected Papers</note>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">On the declarative semantics of logic programs with negation</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lifschitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Deductive Databases and Logic Programming</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Minker</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="177" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<monogr>
		<title />
		<author>
			<persName><forename type="first">Morgan</forename><surname>Kaufmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>Los Altos, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Declarative networking</title>
		<author>
			<persName><forename type="first">Thau</forename><surname>Boon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tyson</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName><surname>Condie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Minos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">E</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Petros</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothy</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="87" to="95" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Recent advances in declarative networking</title>
		<author>
			<persName><forename type="first">Thau</forename><surname>Boon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harjot</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changbin</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yun</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><forename type="middle">R</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Micah</forename><surname>Marczak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anduo</forename><surname>Sherr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenchao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Practical Aspects of Declarative Languages -14th International Symposium, PADL 2012</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Claudio</forename><forename type="middle">V</forename><surname>Russo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Neng-Fa</forename><surname>Zhou</surname></persName>
		</editor>
		<meeting><address><addrLine>Philadelphia, PA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">January 23-24, 2012. 2012</date>
			<biblScope unit="volume">7149</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<monogr>
		<title level="m" type="main">Computing with Logic: Logic Programming with Prolog</title>
		<author>
			<persName><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Warren</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Benjamin Cummings</publisher>
			<pubPlace>Menlo Park, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Datalog: concepts, history, and outlook</title>
		<author>
			<persName><forename type="first">David</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Tuncay</forename><surname>Tekle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Warren</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Declarative Logic Programming: Theory, Systems, and Applications</title>
		<editor>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Annie</forename><surname>Yanhong</surname></persName>
		</editor>
		<editor>
			<persName><surname>Liu</surname></persName>
		</editor>
		<imprint>
			<publisher>ACM / Morgan &amp; Claypool</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="3" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Semantics considerations on non-monotonic logic</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="75" to="94" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<monogr>
		<title level="m" type="main">Elementary Induction on Abstract Structures</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">N</forename><surname>Moschovakis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974">1974</date>
			<pubPlace>North Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<monogr>
		<title level="m" type="main">A language for data and knowledge bases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Naqvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tsur</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>Computer Science Press</publisher>
			<pubPlace>Rockville, Maryland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">Worst-case optimal join algorithms</title>
		<author>
			<persName><forename type="first">Hung</forename><forename type="middle">Q</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ely</forename><surname>Porat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atri</forename><surname>Rudra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
	<note>extended abstract</note>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">A note on the expressive power of prolog</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">P</forename><surname>Papadimitriou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of the EATCS</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="21" to="23" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Future directions in DBMS research</title>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="26" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
	<note>The Laguna Beach Participants</note>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Operational semantics for declarative networking</title>
		<author>
			<persName><forename type="first">Juan</forename><surname>Antonio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Navarro</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Rybalchenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Practical Aspects of Declarative Languages, 11th International Symposium, PADL 2009</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Savannah, GA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">January 19-20, 2009. 2009</date>
			<biblScope unit="volume">5418</biblScope>
			<biblScope unit="page" from="76" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Semantics and expressiveness issues in active databases</title>
		<author>
			<persName><forename type="first">Philippe</forename><surname>Picouet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="325" to="355" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>Also in ICDT 1997</note>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Every logic program has a natural stratification and an iterated least fixpoint model</title>
		<author>
			<persName><forename type="first">T</forename><surname>Przymusinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="11" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">Well-founded semantics coincides with three-valued stable semantics</title>
		<author>
			<persName><forename type="first">T</forename><surname>Przymusinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">XIII</biblScope>
			<biblScope unit="page" from="445" to="463" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">A survey of deductive database systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Logic Programming</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="125" to="149" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">A logic for default reasoning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="80" to="132" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Stable models and non-determinism in logic programs with negation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Saccà</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<meeting>ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="205" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">Big data analytics with datalog queries on spark</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Shkapsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohan</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matteo</forename><surname>Interlandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hsuan</forename><surname>Chiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tyson</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1135" to="1149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<monogr>
		<title level="m" type="main">Readings in Database Systems</title>
		<editor>Michael Stonebraker and Joseph M. Hellerstein</editor>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Morgan Kaufmann</publisher>
		</imprint>
	</monogr>
	<note>Third Edition</note>
</biblStruct>

<biblStruct xml:id="b113">
	<monogr>
		<ptr target="http://vada.org.uk" />
		<title level="m">VADA project website</title>
		<imprint>
			<date type="published" when="2021-03-04">2021. 2021-03-04</date>
			<biblScope unit="page">112</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">The semantics of predicate logic as a programming language</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Van Emden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kowalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="733" to="742" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">The complexity of relational query languages</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGACT Symp. on the Theory of Computing</title>
		<meeting>ACM SIGACT Symp. on the Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Triejoin: A simple, worst-case optimal join algorithm</title>
		<author>
			<persName><forename type="first">L</forename><surname>Todd</surname></persName>
		</author>
		<author>
			<persName><surname>Veldhuizen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conf. on Database Theory</title>
		<meeting>of Intl. Conf. on Database Theory</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="96" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Rule-based languages</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math. Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="215" to="259" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<monogr>
		<title level="m" type="main">Active Database Systems: Triggers and Rules for Advanced Database Processing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ceri</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Morgan-Kaufmann</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">Fixpoint semantics and optimization of recursive datalog programs with aggregates</title>
		<author>
			<persName><forename type="first">Carlo</forename><surname>Zaniolo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohan</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariyam</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><surname>Shkapsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tyson</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matteo</forename><surname>Interlandi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Pract. Log. Program</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="1048" to="1065" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>