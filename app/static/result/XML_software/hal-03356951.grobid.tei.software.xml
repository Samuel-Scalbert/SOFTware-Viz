<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Complexity of Counting Problems Over Incomplete Databases</title>
				<funder ref="#_gA6c5pK #_6tkKNwr">
					<orgName type="full">Barceló</orgName>
				</funder>
				<funder ref="#_RMYnnae">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2021-04-28">28 Apr 2021</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
							<email>marenas@ing.puc.cl</email>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Institute for Mathematical and Computational Engineering</orgName>
								<orgName type="department" key="dep3">School of Engineering</orgName>
								<orgName type="institution">Pontificia Universidad Católica de Chile</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
							<email>pbarcelo@uc.cl</email>
							<affiliation key="aff3">
								<orgName type="department" key="dep1">Institute for Mathematical and Computational Engineering</orgName>
								<orgName type="department" key="dep2">School of Engineering and Faculty of Mathematics</orgName>
								<orgName type="institution">Pontificia Universidad Católica de Chile</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mikaël</forename><surname>Monet</surname></persName>
							<email>mikael.monet@inria.fr.</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Universidad Católica &amp; IMFD Chile</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">IMFD Chile MIKAËL MONET</orgName>
								<orgName type="laboratory">UMR 9189 CRIStAL</orgName>
								<orgName type="institution" key="instit1">Universidad Católica</orgName>
								<orgName type="institution" key="instit2">Univ. Lille</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<orgName type="institution" key="instit4">CNRS</orgName>
								<orgName type="institution" key="instit5">Centrale Lille</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Universidad Católica &amp; IMFD Chile</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Universidad Católica &amp; IMFD Chile</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="department">Mikaël Monet</orgName>
								<orgName type="laboratory">UMR 9189 CRIStAL</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Centrale Lille</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Complexity of Counting Problems Over Incomplete Databases</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2021-04-28">28 Apr 2021</date>
						</imprint>
					</monogr>
					<idno type="MD5">D8B0CB6656DF1560051A366623753175</idno>
					<idno type="DOI">10.1145/3461642</idno>
					<idno type="arXiv">arXiv:2011.06330v2[cs.DB]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CCS Concepts:</term>
					<term>Theory of computation → Complexity theory and logic</term>
					<term>Incomplete, inconsistent, and uncertain databases</term>
					<term>• Mathematics of computing → Approximation algorithms Incomplete databases, closed-world assumption, counting complexity, Fully Polynomial-time Randomized Approximation Scheme (FPRAS)</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study the complexity of various fundamental counting problems that arise in the context of incomplete databases, i.e., relational databases that can contain unknown values in the form of labeled nulls. Specifically, we assume that the domains of these unknown values are finite and, for a Boolean query 𝑞, we consider the following two problems: given as input an incomplete database 𝐷, (a) return the number of completions of 𝐷 that satisfy 𝑞; or (b) return the number of valuations of the nulls of 𝐷 yielding a completion that satisfies 𝑞. We obtain dichotomies between #P-hardness and polynomial-time computability for these problems when 𝑞 is a self-join-free conjunctive query, and study the impact on the complexity of the following two restrictions:</p><p>(1) every null occurs at most once in 𝐷 (what is called Codd tables); and (2) the domain of each null is the same. Roughly speaking, we show that counting completions is much harder than counting valuations: for instance, while the latter is always in #P, we prove that the former is not in #P under some widely believed theoretical complexity assumption. Moreover, we find that both (1) and ( <ref type="formula">2</ref>) can reduce the complexity of our problems. We also study the approximability of these problems and show that, while counting valuations always has a fully polynomial-time randomized approximation scheme (FPRAS), in most cases counting completions does not. Finally, we consider more expressive query languages and situate our problems with respect to known complexity classes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Context. In the database literature, incomplete databases are often used to represent missing information in the data; see, e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b51">52]</ref>. These are traditional relational databases whose active domain can contain both constants and nulls, the latter representing unknown values <ref type="bibr" target="#b29">[30]</ref>. There are many ways in which one can define the semantics of such a database, each being equally meaningful depending on the intended application. Under the so called closed-world assumption <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b44">45]</ref>, a standard, complete database 𝜈 (𝐷) is obtained from an incomplete database 𝐷 by applying a valuation 𝜈 which replaces each null ⊥ in 𝐷 with a constant 𝜈 (⊥). The goal is then to reason about the space formed by all valuations 𝜈 and completions 𝜈 (𝐷) of 𝐷.</p><p>Decision problems related to querying incomplete databases have been well studied already. Consider for instance the problem Certainty(𝑞( x)) which, for a fixed query 𝑞( x), takes as input an incomplete database 𝐷 and a tuple ā and asks whether ā is an answer to 𝑞 for every possible completion of 𝐷. By now, we have a deep understanding of the complexity of these kind of decision Table <ref type="table">1</ref>. Our dichotomies for counting valuations and completions of sjfBCQs. For each of the eight cases, if an sjfBCQ 𝑞 contains a pattern mentioned in that case, then the problem is #P-hard (and #P-complete for counting valuations, as well as for counting completions over Codd tables). In turn, for each case if an sjfBCQ 𝑞 does not have any of the patterns mentioned in that case, then the problem is in FP. Table <ref type="table">2</ref>. Our results on the existence of FPRAS for solving the problems studied in the article (assuming</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FPRAS for counting valuations FPRAS for counting completions</head><formula xml:id="formula_0">NP ≠ RP).</formula><p>exactly once, which corresponds to the well-studied setting of Codd tables -as opposed to naive tables where nulls are allowed to have multiple occurrences. We denote the corresponding problems by #Val Cd (𝑞) and #Comp Cd (𝑞). For the second restriction, we consider uniform incomplete databases in which all the nulls share the same domain -as opposed to the basic non-uniform setting in which all nulls come equipped with their own domain. We denote the corresponding problems by #Val u (𝑞) and #Comp u (𝑞). When both restrictions are in place, we denote the problems by #Val u Cd (𝑞) and #Comp u Cd (𝑞). Our dichotomies for exact counting. We provide complete characterizations of the complexity of counting valuations and completions satisfying a given sjfBCQ 𝑞, when the input is a Codd table or a naive table, and is a non-uniform or a uniform incomplete database (hence we have eight cases in total). Our eight dichotomies express that these problems are either tractable or #P-hard, and that the tractable cases can be fully characterized by the absence of certain forbidden patterns in 𝑞. In essence, a pattern is simply an sjfBCQ which can be obtained from 𝑞 by deleting atoms and occurrences of variables (the exact definition of this notion is given in Section 3). Our characterizations are presented in Table <ref type="table">1</ref>. By analyzing this table we can draw some important conclusions as explained next.</p><p>#Comp(𝑞) and #Val(𝑞) are computationally difficult: For very few sjfBCQs 𝑞 the aforementioned problems can be solved in polynomial time. Take as an example the uniform setting over naive tables. Then #Val u (𝑞) is #P-hard as long as 𝑞 contains the pattern 𝑅(𝑥, 𝑥), or 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦), or 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). That is, as long as there is an atom in 𝑞 that contains a repeated variable 𝑥, or a pair (𝑥, 𝑦) of variables that appear in an atom and both 𝑥 and 𝑦 appear in some other atoms in 𝑞. By contrast, for this same setting, #Comp u (𝑞) is #P-hard as long as 𝑞 contains the pattern 𝑅(𝑥, 𝑦) or 𝑅(𝑥, 𝑥), that is, as long as there is an atom in 𝑞 that is not of arity one.</p><p>Our dichotomies for approximate counting. Although #Val(𝑞) can be #P-hard, we prove that good randomized approximation algorithms can be designed for this problem. More precisely, we give a general condition under which #Val(𝑞) admits a fully polynomial-time randomized approximation scheme <ref type="bibr" target="#b32">[33]</ref> (FPRAS). This condition applies in particular to all unions of Boolean conjunctive queries. Remarkably, we show that this no longer holds for #Comp(𝑞); more precisely, there exists an sjfBCQ 𝑞 such that #Comp(𝑞) does not admit an FPRAS under a widely believed complexity theoretical assumption. More surprisingly, even counting the completions of a uniform incomplete database containing a single binary relation does not admit an FPRAS under such an assumption (and in the non-uniform case, a single unary relation suffices). Generally, for sjfBCQs, we obtain seven dichotomies for our problems between polynomial-time computability of exact counting and non admissibility of an FPRAS. The only case that we did not completely solve is that of #Comp u Cd (𝑞). Our dichotomies for approximate counting are illustrated in Table <ref type="table">2</ref>. Beyond #P. It is easy to see that the problem of counting valuations is always in #P, provided that the model checking problem for 𝑞 is in P. This is no longer the case for counting completions, and in fact we show that, under a complexity theoretical assumption, there is an sjfBCQ 𝑞 for which #Comp u (𝑞) is not in #P. This does not hold if restricted to Codd tables, however, as we prove that #Comp Cd (𝑞) is always in #P when the model checking problem for 𝑞 is in P.</p><p>For reasons that we explain in the article, a suitable complexity class for the problem #Comp(𝑞) is SpanP, which is defined as the class of counting problems that can be expressed as the number of different accepting outputs of a nondeterministic Turing machine running in polynomial time. While we have not managed to prove that there is an sjfBCQ 𝑞 for which #Comp(𝑞) is SpanPcomplete, we show that this is the case for the problem of counting completions for the negation of an sjfBCQ, even in the uniform setting; that is, we show that #Comp u (¬𝑞) is SpanP-complete for some sjfBCQ 𝑞. Finally, we also show that SpanP is the right complexity class for counting valuations of queries for which model checking is in NP.</p><p>Extension to queries with constants and free variables. As we said already, for pedagogical reasons we mostly present our results by considering queries that are Boolean and that do not have constants. In Section 7 however, we explain how to extend these results to the case of queries that have free variables and that can contain constants. For the case of a query 𝑞( x) with free variables x, our counting problems are defined in the expected way; for instance the problem #Val(𝑞( x)) takes as input an incomplete database 𝐷, a tuple of constants ā of same arity as x, and it outputs the number of valuations 𝜈 of 𝐷 such that ā in an answer to 𝑞( x) on 𝜈 (𝐷). We then extend our dichotomies and approximation results in this setting.</p><p>The current article extends the conference article <ref type="bibr" target="#b7">[8]</ref> in the following ways:</p><p>• In <ref type="bibr" target="#b7">[8]</ref> we left open the dichotomy for #Val u Cd (𝑞), i.e., for counting valuations of sjfBCQs for Codd tables under the uniform setting. We close this case here, by finding one more hard pattern (namely, the pattern ∃𝑥, 𝑦 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)) and showing that the problem can be solved in polynomial time for all other queries. • We added Section 7 which explains how our framework can be extended to handle queries with constants and free variables; • Proposition 6.3, which establishes the NP-completeness of checking if a set of facts is a possible completion of an incomplete database, is new; • Finally, full proofs of most results are included in the body of the article.</p><p>Organization of the article. We start with the main terminology used in the article in Section 2, and then present in Section 3 our four dichotomies on #Val(𝑞) when 𝑞 is an sjfBCQ, and the input incomplete database can be Codd or not, and the domain can be uniform or not. We then establish the four dichotomies on #Comp(𝑞) in Section 4. In Section 5, we study the approximability complexity of our problems. We then give in Section 6 some general considerations about the exact complexity of the problem #Comp(𝑞) going beyond #P. We explain in Section 7 how to extend our results to queries with constants and free variables. In Section 8, we discuss related work and explain the differences with the problems considered in this article. Last, we provide some conclusions and mention possible directions for future work in Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>Relational databases and conjunctive queries. A relational schema 𝜎 is a finite non-empty set of relation symbols written 𝑅, 𝑆, 𝑇 , . . . , each with its associated arity, which is denoted by arity(𝑅). Let Consts be a countably infinite set of constants. A database 𝐷 over 𝜎 is a set of facts of the form 𝑅(𝑎 1 , . . . , 𝑎 arity(𝑅) ) with 𝑅 ∈ 𝜎, and where each element 𝑎 𝑖 ∈ Consts. For 𝑅 ∈ 𝜎, we denote by 𝐷 (𝑅) the subset of 𝐷 consisting of facts over 𝑅. Such a set is usually called a relation of 𝐷.</p><p>A Boolean query 𝑞 is a query that a database 𝐷 can satisfy (written 𝐷 |= 𝑞) or not (written 𝐷 ̸ |= 𝑞). If 𝑞 is a Boolean query, then ¬𝑞 is the Boolean query such that 𝐷 |= ¬𝑞 if and only if 𝐷 ̸ |= 𝑞. A Boolean conjunctive query (BCQ) over 𝜎 is an FO formula of the form</p><formula xml:id="formula_1">∃ x 𝑅 1 ( x1 ) ∧ . . . ∧ 𝑅 𝑚 ( x𝑚 ) ,<label>(1)</label></formula><p>where all variables are existentially quantified, and where for each 𝑖 ∈ [1, 𝑚], we have that 𝑅 𝑖 is a relation symbol in 𝜎 and x𝑖 is a tuple of variables with | x𝑖 | = arity(𝑅 𝑖 ). To avoid trivialities, we will always assume that 𝑚 ⩾ 1, i.e., the query has at least one atom, and also that arity(𝑅 𝑖 ) ⩾ 1 for all atoms. Observe that we do not allow constants to appear in the query (but we will come back to this issue in <ref type="bibr">Section 7)</ref>. For simplicity, we typically write a BCQ 𝑞 of the form <ref type="bibr" target="#b0">(1)</ref> as</p><formula xml:id="formula_2">𝑅 1 ( x1 ) ∧ . . . ∧ 𝑅 𝑚 ( x𝑚 ),</formula><p>and it will be implicitly understood that all variables in 𝑞 are existentially quantified. As usual, we define the semantics of a BCQ in terms of homomorphisms. A homomorphism from 𝑞 to a database 𝐷 is a  mapping from the variables in 𝑞 to the constants used in 𝐷 such that {𝑅 1 (ℎ( x1 )), . . . , 𝑅 𝑚 (ℎ( x𝑚 ))} ⊆ 𝐷. Then, we have 𝐷 |= 𝑞 if there exists a homomorphism from 𝑞 to 𝐷. A self-join-free BCQ (sjfBCQ) is a BCQ such that no two atoms use the same relation symbol.</p><p>Incomplete databases. Let Nulls be a countably infinite set of nulls (also called labeled or marked nulls in the literature), which is disjoint with Consts. An incomplete database over schema 𝜎 is a pair 𝐷 = (𝑇 , dom), where 𝑇 is a database over 𝜎 whose facts contain elements in Consts ∪ Nulls, and where dom is a function that associates to every null ⊥ occurring in 𝐷 a subset dom(⊥) of Consts. Intuitively, 𝑇 is a database that can mention both constants and nulls, while dom tells us where nulls are to be interpreted. Following the literature, we call 𝑇 a naive table <ref type="bibr" target="#b29">[30]</ref>.</p><p>An incomplete database 𝐷 = (𝑇 , dom) can represent potentially many complete databases, via what are called valuations. A valuation of 𝐷 is simply a function 𝜈 that maps each null ⊥ occurring in 𝑇 to a constant 𝜈 (⊥) ∈ dom(⊥). Such a valuation naturally defines a completion of 𝐷, denoted by 𝜈 (𝑇 ), which is the complete database obtained from 𝑇 by substituting each null ⊥ appearing in 𝑇 by 𝜈 (⊥). It is understood, since a database is a set of facts, that 𝜈 (𝑇 ) does not contain duplicate facts. By paying attention to completions of incomplete databases that are generated exclusively by applying valuations to them, we are sticking to the so called closed-world semantics of incompleteness <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b44">45]</ref>. This means that the databases represented by an incomplete database 𝐷 = (𝑇 , dom) are not open to adding facts that are not "justified" by the facts in 𝑇 .</p><p>Example 2.1. Let 𝐷 = (𝑇 , dom) be the incomplete database consisting of the naive table 𝑇 = {𝑆 (⊥ 1 , ⊥ 1 ), 𝑆 (𝑎, ⊥ 2 )}, and where dom(⊥ 1 ) = {𝑎, 𝑏} and dom(⊥ 2 ) = {𝑎, 𝑐}. Let 𝜈 1 be the valuation mapping ⊥ 1 to 𝑏 and ⊥ 2 to 𝑐. Then 𝜈 1 (𝑇 ) is {𝑆 (𝑏, 𝑏), 𝑆 (𝑎, 𝑐)}. Let 𝜈 2 be the valuation mapping both ⊥ 1 and ⊥ 2 to 𝑎. Then 𝜈 2 (𝑇 ) is {𝑆 (𝑎, 𝑎)}. On the other hand, the function 𝜈 mapping ⊥ 1 and ⊥ 2 to 𝑏 is not a valuation of 𝐷, because 𝑏 ∉ dom(⊥ 2 ). □</p><p>When every null occurs at most once in 𝑇 , then 𝐷 is what is called a Codd table <ref type="bibr" target="#b15">[16]</ref>; for instance, the incomplete database in Example 2.1 is not a Codd table because ⊥ 1 occurs twice. We also consider uniform incomplete databases in which the domain of every null is the same. Formally, a uniform incomplete database is a pair 𝐷 = (𝑇 , dom), where 𝑇 is a database over 𝜎 and dom is a subset of Consts. The difference now is that a valuation 𝜈 of 𝐷 must simply satisfy 𝜈 (⊥) ∈ dom for every null of 𝐷.</p><p>We will often abuse notation and use 𝐷 instead of 𝑇 ; for instance, we write 𝜈 (𝐷) instead of 𝜈 (𝑇 ), or 𝑅(𝑎, 𝑎) ∈ 𝐷 instead of 𝑅(𝑎, 𝑎) ∈ 𝑇 , or again 𝐷 (𝑅) instead of 𝑇 (𝑅).</p><p>Counting problems on incomplete databases. We will study two kinds of counting problems for incomplete databases: problems of the form #Val(𝑞), that count the number of valuations 𝜈 that yield a completion 𝜈 (𝐷) satisfying a given BCQ 𝑞, and problems of the form #Comp(𝑞), that count the number of completions that satisfy 𝑞. The query 𝑞 is assumed to be fixed, so that each query gives rise to different counting problems, and we are considering the data complexity <ref type="bibr" target="#b52">[53]</ref> of these problems.</p><p>Before formally introducing our problems, let us observe that they are well defined if we assume that the set of constants to which a null can be mapped to is finite. Hence, for the (default) case of an incomplete database 𝐷 = (𝑇 , dom), we assume that dom(⊥) is always a finite subset of Consts. Similarly, for the case of a uniform incomplete database 𝐷 = (𝑇 , dom), we assume that dom is a finite subset of Consts. Finally, given a Boolean query 𝑞, we use notation sig(𝑞) for the set of relation symbols occurring in 𝑞. With these ingredients, we can define our problems for the (default) case of incomplete naive tables and a Boolean query 𝑞. We also consider the uniform variants of these problems, in which the input 𝐷 is a uniform incomplete database over sig(𝑞), and the restriction of these problems where the input is a Codd table instead of a naive table. We then use the terms #Val u (𝑞), #Comp u (𝑞) when restricted to the uniform case, #Val Cd (𝑞), #Comp Cd (𝑞) when restricted to Codd tables, and #Val u Cd (𝑞), #Comp u Cd (𝑞) when both restrictions are applied.</p><p>As we will see, even though the problems #Val(𝑞) and #Comp(𝑞) look similar, they are of a different computational nature; this is because two distinct valuations can produce the same completion of an incomplete database. We illustrate this phenomenon in the following example.</p><p>Example 2.2. Let 𝑞 be the Boolean conjunctive query ∃𝑥 𝑆 (𝑥, 𝑥), and 𝐷 be the (non-uniform) incomplete database 𝐷 = (𝑇 , dom), with 𝑇 = {𝑆 (𝑎, 𝑏), 𝑆 (⊥ 1 , 𝑎), 𝑆 (𝑎, ⊥ 2 )}, dom(⊥ 1 ) = {𝑎, 𝑏, 𝑐} and dom(⊥ 2 ) = {𝑎, 𝑏}. We have depicted in Figure <ref type="figure" target="#fig_0">1</ref> the six valuations of 𝐷 together with the completions that they define. Out of these six valuations 𝜈, only four are such that 𝜈 (𝐷) |= 𝑞, so we have #Val(𝑞) (𝐷) = 4. Moreover, there are only 3 distinct completions of 𝐷 that satisfy 𝑞 -because the first two are the same -so #Comp(𝑞) (𝐷) = 3. □ Counting complexity classes. Given two problems 𝐴, 𝐵, we write 𝐴 ⩽ p T 𝐵 when 𝐴 reduces to 𝐵 under polynomial-time Turing reductions. When both 𝐴 and 𝐵 are counting problems, we write 𝐴 ⩽ p par 𝐵 when 𝐴 can be reduced to 𝐵 under polynomial-time parsimonious reductions, i.e., when there exists a polynomial-time computable function 𝑓 that transforms an input 𝑥 of 𝐴 to an input 𝑓 (𝑥) of 𝐵 such that 𝐴(𝑥) = 𝐵(𝑓 (𝑥)). We say that a counting problem is in FP when it can be solved in polynomial time. We will consider the counting complexity class #P <ref type="bibr" target="#b49">[50]</ref> of problems that can be expressed as the number of accepting paths of a nondeterministic Turing machine running in polynomial time. Following <ref type="bibr" target="#b49">[50,</ref><ref type="bibr" target="#b50">51]</ref>, we define #P-hardness using Turing reductions. It is clear that FP ⊆ #P. Moreover, this inclusion is widely believed to be strict. Therefore, proving that a counting problem is #P-hard implies that it cannot be solved in polynomial time under such an assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DICHOTOMIES FOR COUNTING VALUATIONS</head><p>In this section, for a fixed sjfBCQ q, we study the complexity of the problem of computing, given as input an incomplete database 𝐷, the number of valuations 𝜈 of 𝐷 such that 𝜈 (𝐷) satisfies 𝑞. Recall that we have four cases to consider for this problem depending on whether we focus on naive or on Codd tables, where nulls are restricted to appear at most once, and whether we focus on non-uniform or uniform incomplete databases, where nulls are restricted to have the same domain. Our specific goal then is to understand whether the problem is tractable (in FP) or #P-hard in these scenarios, depending on the shape of 𝑞.</p><p>To this end, the shape of an sjfBCQ 𝑞 will be characterized by the presence or absence of certain specific patterns. In the following definition, we introduce the necessary terminology to formally talk about the presence of a pattern in a query. Definition 3.1. Let 𝑞, 𝑞 ′ be sjfBCQs. We say that 𝑞 ′ is a pattern of 𝑞 if 𝑞 ′ can be obtained from 𝑞 by using an arbitrary number of times and in any order the following operations: deleting an atom, deleting an occurrence of a variable, renaming a relation to a fresh one, renaming a variable to a fresh one, and reordering the variables in an atom. <ref type="foot" target="#foot_0">1</ref>□ Example 3.2. Recall that we always omit existential quantifiers in Boolean queries. Then we have that 𝑞 ′ = 𝑅 ′ (𝑢, 𝑢, 𝑦) ∧ 𝑆 ′ (𝑧) is a pattern of 𝑞 = 𝑅(𝑢, 𝑥, 𝑢) ∧ 𝑆 ′ (𝑦, 𝑦) ∧ 𝑇 (𝑥, 𝑠, 𝑧, 𝑠). Indeed, 𝑞 ′ can be obtained from 𝑞 by deleting atom 𝑇 (𝑥, 𝑠, 𝑧, 𝑠), renaming 𝑅(𝑢, 𝑥, 𝑢) as 𝑅 ′ (𝑢, 𝑥, 𝑢) to obtain 𝑅 ′ (𝑢, 𝑥, 𝑢) ∧ 𝑆 ′ (𝑦, 𝑦), reordering the variables in 𝑅 ′ (𝑢, 𝑥, 𝑢) to obtain 𝑅 ′ (𝑢, 𝑢, 𝑥) ∧ 𝑆 ′ (𝑦, 𝑦), renaming variable 𝑦 into 𝑧 to obtain 𝑅 ′ (𝑢, 𝑢, 𝑥) ∧ 𝑆 ′ (𝑧, 𝑧), deleting the second variable occurrence in 𝑆 ′ (𝑧, 𝑧) to obtain 𝑅 ′ (𝑢, 𝑢, 𝑥) ∧ 𝑆 ′ (𝑧), and finally renaming variable 𝑥 into 𝑦 to obtain 𝑞 ′ . □</p><p>We point out that in Definition 3.1, the important parts are those about deleting atoms and variable occurrences. The parts about reordering variable occurences inside an atom and about renaming relations and variables to fresh ones have obviously no effect on the complexity of the problem<ref type="foot" target="#foot_1">2</ref> ; these are only here to allow us to formally say, for instance, that "𝑅(𝑥) is a pattern of 𝑅(𝑦)", or that "𝑆 (𝑥, 𝑢, 𝑥) is a pattern of 𝑇 (𝑤, 𝑧, 𝑧)" (as these are, in essence, the same queries).</p><p>In the following general lemma, we show that if 𝑞 ′ is a pattern of 𝑞, then each of the problems considered in this section is as hard for 𝑞 as it is for 𝑞 ′ . Recall in this result that unless stated otherwise, our problems are defined for naive tables under the non-uniform setting. Lemma 3.3. Let 𝑞, 𝑞 ′ be sjfBCQs such that 𝑞 ′ is a pattern of 𝑞. Then we have #Val(𝑞 ′ ) ⩽ p par #Val(𝑞). Moreover, the same results hold if we restrict to Codd tables, and/or to the uniform setting.</p><p>Proof. We first present the proof for #Val(𝑞 ′ ) ⩽ p par #Val(𝑞), that is, for naive tables in the nonuniform setting. First of all, observe that we can assume without loss of generality that we did not reorder the variables in the atoms nor renamed relation names or variables by fresh ones, because, as mentioned above, this does not change the complexity of the problem. <ref type="foot" target="#foot_2">3</ref> We can then write 𝑞 as</p><formula xml:id="formula_3">𝑅 1 (𝑥 1 ) ∧ . . . ∧ 𝑅 𝑚 (𝑥 𝑚 ) and 𝑞 ′ as 𝑅 𝑗 1 (𝑥 ′ 𝑗 1 ) ∧ . . . ∧ 𝑅 𝑗 𝑝 (𝑥 ′ 𝑗 𝑝 )</formula><p>, where 1 ⩽ 𝑗 1 &lt; . . . &lt; 𝑗 𝑝 ⩽ 𝑚 and 𝑥 ′ 𝑗 𝑘 is obtained from 𝑥 𝑗 𝑘 by deleting some variable occurrences but not all <ref type="foot" target="#foot_3">4</ref> , and the other atoms have been deleted. Let 𝐷 ′ be an incomplete database input of #Val(𝑞 ′ ). Let 𝐴 be the set of constants that are appearing in 𝐷 ′ or are in a domain of some null occurring in 𝐷 ′ . For 1 ⩽ 𝑘 ⩽ 𝑝, we construct the relation 𝐷 (𝑅 𝑗 𝑘 ) from the relation 𝐷 ′ (𝑅 𝑗 𝑘 ). Let us assume that 𝑥 𝑗 𝑘 is the tuple (𝑥 1 , . . . , 𝑥 𝑟 ) (with some variables possibly being equal). We initialize 𝐷 (𝑅 𝑗 𝑘 ) to be empty, and then for every tuple 𝑡 ′ in 𝐷 ′ (𝑅 𝑗 𝑘 ) we add to 𝐷 (𝑅 𝑗 𝑘 ) all the tuples 𝑡 that can be obtained from 𝑡 ′ in the following way for 1 ⩽ 𝑖 ⩽ 𝑟 : a) If 𝑥 𝑖 is a variable occurrence that has not been deleted from 𝑥 𝑗 𝑘 , then copy the element (constant or null) of 𝑡 ′ corresponding to that variable occurrence to the 𝑖-th position of 𝑡; b) Otherwise, if 𝑥 𝑖 is a variable occurrence that has been deleted from 𝑥 𝑗 𝑘 , then fill the 𝑖-th position of 𝑡 with every possible constant from 𝐴.</p><p>Then we construct the relations 𝐷 (𝑅 𝑖 ) where 𝑅 𝑖 does not appear in 𝑞 ′ (this can happen if we have deleted the atom 𝑅 𝑖 (𝑥 𝑖 )) by filling it with every possible 𝑅 𝑖 -fact over 𝐴. We leave the domains of all nulls unchanged. The whole construction can be performed in polynomial time (this uses the fact that 𝑞 is assumed to be fixed, so that the arities of the relations mentioned in 𝑞 are fixed). Hence, it only remains to be checked that #Val(𝑞 ′ ) (𝐷 ′ ) = #Val(𝑞) (𝐷), that is, that the reduction works and is indeed parsimonious. It is clear that the valuations of 𝐷 ′ are exactly the same as the valuations of 𝐷 (because they have the same sets of nulls). Hence it is enough to verify that for every valuation 𝜈, we have 𝜈 (𝐷 ′ ) |= 𝑞 ′ if and only if 𝜈 (𝐷) |= 𝑞. Let ℎ ′ be a homomorphism from 𝑞 ′ to 𝜈 (𝐷 ′ ) witnessing that 𝜈 (𝐷 ′ ) |= 𝑞 ′ (i.e., we have ℎ ′ (𝑞) ⊆ 𝜈 (𝐷 ′ )). Then ℎ ′ can clearly be extended in the expected way into a homomorphism ℎ from 𝑞 to 𝜈 (𝐷): this is in particular thanks to the fact that we filled the missing columns with every possible constant. Conversely, let ℎ be a homomorphism from 𝑞 to 𝜈 (𝐷) witnessing that 𝜈 (𝐷) |= 𝑞. Then the restriction ℎ ′ of ℎ to the variables occurring in 𝑞 ′ is such that ℎ(𝑞 ′ ) ⊆ 𝜈 (𝐷 ′ ), hence we have 𝜈 (𝐷 ′ ) |= 𝑞 ′ . This concludes the proof for the case of naive tables in the non-uniform setting. For the cases of Codd tables and/or for the uniform setting, the reduction is exactly the same. Indeed, the domains of the nulls are unchanged, and it is clear that the presented construction preserves the property of being a Codd table . 
□</p><p>The idea is then to show the #P-hardness of our problems for some simple patterns, which then we combine with Lemma 3.3 and with some tractability proofs to obtain the desired dichotomies. Our findings are summarized in the first two columns of Table <ref type="table">1</ref> in the introduction. We first focus on the two dichotomies for the non-uniform setting in Section 3.1, and then we move to the case of uniform incomplete databases in Section 3.2. We explicitly state when a #P-hardness result holds even in the restricted setting in which there is a fixed domain over which nulls are interpreted. In other words, when there is a fixed domain 𝐴 such that the incomplete databases used in the reductions are of the form 𝐷 = (𝑇 , dom) and dom(⊥) ⊆ 𝐴, for each null ⊥ of 𝑇 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The complexity on the non-uniform case</head><p>In this section, we study the complexity of the problems #Val(𝑞) and #Val Cd (𝑞), providing dichotomy results in both cases. We start by proving the #P-hardness results needed for these dichotomies. We first show that #Val(𝑅(𝑥, 𝑥)) is #P-hard by actually proving that hardness holds already in the uniform case. Proposition 3.4. #Val u (𝑅(𝑥, 𝑥)) is #P-hard. This holds even in the restricted setting in which all nulls are interpreted over the same fixed domain {1, 2, 3}.</p><p>Proof. We reduce from the problem of counting the number of 3-colorings of a graph 𝐺 = (𝑉 , 𝐸), which is #P-hard <ref type="bibr" target="#b31">[32]</ref>. For every node 𝑣 ∈ 𝑉 we have a null ⊥ 𝑣 , and for every edge {𝑢, 𝑣 } ∈ 𝐸 we have the facts 𝑅(⊥ 𝑣 , ⊥ 𝑢 ) and 𝑅(⊥ 𝑢 , ⊥ 𝑣 ). The domain of the nulls is {1, 2, 3}. It is then clear that the number of valuations of the constructed database that do not satisfy 𝑅(𝑥, 𝑥) is exactly the number of 3-colorings of 𝐺. Since the total number of valuations can be computed in PTIME, this concludes the reduction. □</p><p>The next pattern that we consider is 𝑅(𝑥) ∧ 𝑆 (𝑥). This time, we can show #P-hardness of the problem even for Codd databases.</p><formula xml:id="formula_4">Proposition 3.5. #Val Cd (𝑅(𝑥) ∧ 𝑆 (𝑥)) is #P-hard.</formula><p>Proof. We start by recalling the setting of consistent query answering under key constraints. Intuitively, in this case we are given a set Σ of keys and a database 𝐷 that does not necessarily satisfy Σ. Then the task is to reason about the set of all repairs of 𝐷 with respect to Σ <ref type="bibr" target="#b8">[9]</ref>. In our context, this means that one wants to count the number of repairs of 𝐷 with respect to Σ that satisfy a given CQ 𝑞. When 𝑞 and Σ are fixed, we call this problem #Repairs(𝑞, Σ); see, e.g., <ref type="bibr" target="#b39">[40]</ref>. We formalize these notions below.</p><p>Here we focus on the case when Σ is a set of primary keys. Recall that this means that each relation name 𝑅 ∈ 𝜎 of arity 𝑛 comes equipped with its own key, i.e., key(𝑅) = 𝐴, where 𝐴 = ∅ or 𝐴 = [1, . . . , 𝑝] for some 𝑝 ∈ {1, . . . , 𝑛}. Henceforth, 𝐷 is inconsistent with respect to Σ if there is a relation name 𝑅 ∈ 𝜎 and facts 𝑅( ā), 𝑅( b) ∈ 𝐷 with ā ≠ b such that key(𝑅) = 𝐴 and 𝜋 𝐴 ( ā) = 𝜋 𝐴 ( b).</p><p>In this case we say that the pair (𝑅( ā), 𝑅( b)) is key-violating. Let us define a block in a database 𝐷 with respect to a set Σ of primary keys to be any maximal set 𝐵 of facts from 𝐷 such that the facts in 𝐵 are pairwise key-violating. A repair of 𝐷 with respect to Σ is a subset 𝐷 ′ of 𝐷 that is obtained by choosing exactly one tuple from each block of 𝐷 with respect to Σ.</p><p>Let us consider a schema 𝜎 with two binary relations 𝑅 ′ and 𝑆 ′ , such that key(𝑅 ′ ) = key(𝑆 ′ ) = {1}. That is, the first attribute of both 𝑅 ′ and 𝑆 ′ defines a key over such relations. We define this set of keys over 𝜎 to be Σ. Also, let 𝑞 = ∃𝑥, 𝑦, 𝑧 (𝑅 ′ (𝑦, 𝑥) ∧ 𝑆 ′ (𝑧, 𝑥)). For simplicity, we write the pair (𝑞, Σ) as 𝑅 ′ (y, 𝑥) ∧ 𝑆 ′ (z, 𝑥). The problem #Repairs(𝑅 ′ (y, 𝑥) ∧ 𝑆 ′ (z, 𝑥)), which given a database 𝐷 ′ over schema 𝜎 aims at computing the number of repairs of 𝐷 ′ under Σ that satisfy 𝑞, is known to be #P-complete <ref type="bibr" target="#b39">[40]</ref>. <ref type="foot" target="#foot_4">5</ref>Now, observe that the #P-hardness of #Val Cd (𝑅(𝑥) ∧ 𝑆 (𝑥)) easily follows from the hardness of the problem #Repairs(𝑅 ′ (y, 𝑥) ∧𝑆 ′ (z, 𝑥)). In fact, let 𝐷 ′ be a database with binary relation 𝑅 ′ , 𝑆 ′ . We construct an incomplete Codd database 𝐷 with unary relations 𝑅, 𝑆 as follows. For every constant 𝑎 that appears in the first attribute of 𝑅 ′ , we have a tuple 𝑅(⊥) in 𝐷, where ⊥ is a fresh null, and we set dom(⊥) = {𝑏 | 𝑅 ′ (𝑎, 𝑏) ∈ 𝐷 ′ }. For every constant 𝑎 that appears in the first attribute of 𝑆 ′ , we have a tuple 𝑆 (⊥) in 𝐷, where ⊥ is a fresh null, and we set dom(⊥) = {𝑏 | 𝑆 ′ (𝑎, 𝑏) ∈ 𝐷 ′ }. It is then clear that the number of repairs of 𝐷 ′ that satisfy 𝑅 ′ (y, 𝑥) ∧ 𝑆 ′ (z, 𝑥) is equal to the number of valuations of 𝐷 that satisfy 𝑅(𝑥) ∧ 𝑆 (𝑥), thus concluding the proof. We point out here that another proof of Proposition 3.5, that uses different techniques, can be found in the conference version of the article <ref type="bibr" target="#b7">[8]</ref> (the proof that we presented here is shorter). □</p><p>Already with Propositions 3.5 and 3.4, we have all the relevant hard patterns for the non-uniform setting. We start by proving our dichotomy result for naive tables, which is our default case. Theorem 3.6 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥) ∧ 𝑆 (𝑥) is a pattern of 𝑞, then #Val(𝑞) is #P-complete. Otherwise, #Val(𝑞) is in FP.</p><p>Proof. The #P-hardness part of the claim follows from the last two propositions and from Lemma 3.3. We explain why the problems are in #P right after this proof. When 𝑞 does not have any of these two patterns then all variables have exactly one occurrence in 𝑞. This implies that every valuation 𝜈 of 𝐷 is such that 𝜈 (𝐷) satisfies 𝑞 (except when one relation is empty, in which case the result is simply zero). We can then compute the total number of valuations in FP by simply multiplying the sizes of the domains of every null in 𝐷. □</p><p>Notice that in this theorem, the membership of #Val(𝑞) in #P can be established by considering a nondeterministic Turing Machine 𝑀 that, with input a non-uniform incomplete database 𝐷, guesses a valuation 𝜈 of 𝐷 and verifies whether 𝜈 (𝐷) satisfies 𝑞. This machine works in polynomial time as we can verify whether 𝜈 (𝐷) satisfies 𝑞 in polynomial time (since 𝑞 is a fixed FO query). Then given that #Val(𝑞) (𝐷) is equal to the number of accepting runs of 𝑀 with input 𝐷, we conclude that #Val(𝑞) is in #P. Obviously, the same idea works for codd tables, that is, #Val Cd (𝑞) is also in #P. But with this restriction we obtain more tractable cases, as shown by the following dichotomy result. Theorem 3.7 (dichotomy). Let 𝑞 be an sjfBCQ.</p><formula xml:id="formula_5">If 𝑅(𝑥) ∧ 𝑆 (𝑥) is a pattern of 𝑞, then #Val Cd (𝑞) is #P-complete. Otherwise, #Val Cd (𝑞) is in FP.</formula><p>Proof. We only need to prove the tractability claim, since hardness follows from Proposition 3.5 and Lemma 3.3. We will assume without loss of generality that 𝐷 contains no constants, as we can introduce a fresh null with domain {𝑐} for every constant 𝑐 appearing in 𝐷, and the result is again a Codd table, and this does not change the output of the problem. Let 𝑞 be 𝑅 1 ( x1 ) ∧ . . . ∧ 𝑅 𝑚 ( x𝑚 ). Observe that since 𝑞 does not have 𝑅(𝑥) ∧ 𝑆 (𝑥) as a pattern then any two atoms cannot have a variable in common. But then, since 𝐷 is a Codd table we have</p><formula xml:id="formula_6">#Val Cd (𝑞) (𝐷) = 𝑚 𝑖=1 #Val Cd (𝑅 𝑖 ( x𝑖 )) (𝐷 (𝑅 𝑖 )).</formula><p>Hence it is enough to show how to compute #Val Cd (𝑅 𝑖 ( x𝑖 )) (𝐷 (𝑅 𝑖 )) for every 1 ⩽ 𝑖 ⩽ 𝑚. Let t1 , . . . , t𝑛 be the tuples of 𝐷 (𝑅 𝑖 ). Let us write 𝜌 ( t𝑗 ) for the number of valuations of the nulls appearing in t𝑗 that do not match x𝑖 . Clearly, #Val Cd (𝑅 𝑖 ( x𝑖 )) (𝐷 (𝑅 𝑖 )) = ⊥ appears in 𝐷 (𝑅 𝑖 ) |dom(⊥)| -𝑛 𝑗=1 𝜌 ( t𝑗 ), so we only have to show how to compute 𝜌 ( t𝑗 ) for 1 ⩽ 𝑗 ⩽ 𝑛. Since we can easily compute the total number of valuations of t𝑗 , it is enough to show how to compute the number of valuations of t𝑗 that match x𝑖 . For every variable 𝑥 that appears in x𝑖 , compute the size of the intersection of the domains of the corresponding nulls in t𝑗 , and denote it 𝑠 𝑥 . Then the number of valuations of t𝑗 that match x𝑖 is simply 𝑥 appears in x𝑖 𝑠 𝑥 . This concludes the proof. □ At this stage, we have completed the first column of Table <ref type="table">1</ref>, and we also know that 𝑅(𝑥, 𝑥) is a hard pattern in the uniform setting for naive tables (but not for Codd tables, by Theorem 3.7). In the next section, we treat the uniform setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The complexity on the uniform case</head><p>In this section, we study the complexity of the problems #Val u (𝑞) and #Val u Cd (𝑞), again providing dichotomy results in both cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Naïve tables.</head><p>We start our investigation with the case of naive tables. In Proposition 3.4, we already showed that #Val u (𝑅(𝑥, 𝑥)) is #P-hard. In the following proposition, we identify two other simple queries for which this problem is still intractable. Proposition 3.8. #Val u (𝑅(𝑥) ∧𝑆 (𝑥, 𝑦) ∧𝑇 (𝑦)) and #Val u (𝑅(𝑥, 𝑦) ∧𝑆 (𝑥, 𝑦)) are both #P-hard. This holds even in the restricted setting in which all nulls are interpreted over the same fixed domain {0, 1}.</p><p>Proof. We reduce both problems from the problem of counting the number of independent sets in a graph (denoted by #IS), which is #P-complete <ref type="bibr" target="#b43">[44]</ref>. We start with #Val u (𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)). Let 𝑞 = 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) and 𝐺 = (𝑉 , 𝐸) be a graph. Then we define an incomplete database 𝐷 as follows. For every node 𝑣 ∈ 𝑉 , we have a null ⊥ 𝑣 , and the uniform domain is {0, 1}. For every edge {𝑢, 𝑣 } ∈ 𝐸, we have facts 𝑆 (⊥ 𝑢 , ⊥ 𝑣 ) and 𝑆 (⊥ 𝑣 , ⊥ 𝑢 ) in 𝐷. Finally, we have facts 𝑅(1) and 𝑇 (1) in 𝐷. For a valuation 𝜈 of the nulls, consider the corresponding subset 𝑆 𝜈 of nodes of 𝐺, given by 𝑆 𝜈 = {𝑡 ∈ 𝑉 | 𝜈 (⊥ 𝑡 ) = 1}. This is a bijection between the valuations of the database and the node subsets of 𝐺. Moreover, we have that 𝜈 (𝐷) ̸ |= 𝑞 if and only if 𝑆 𝜈 is an independent set of 𝐺. Since the total number of valuations of 𝐷 is 2 |𝑉 | , we have that the number of independent sets of 𝐺 is equal to 2 |𝑉 | -#Val u (𝑞) (𝐷). Hence, we conclude that #IS ⩽ p T #Val u (𝑞). The idea is similar for #Val u (𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)): we encode the graph with the relation 𝑆 in the same way, and this time we add the fact 𝑅 <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b0">1)</ref>. □</p><p>As shown in the following result, it turns out that the three aforementioned patterns are enough to fully characterize the complexity of counting valuations for naive tables in the uniform setting. Theorem 3.9 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥)∧𝑆 (𝑥, 𝑦)∧𝑇 (𝑦) or 𝑅(𝑥, 𝑦)∧𝑆 (𝑥, 𝑦) is a pattern of 𝑞, then #Val u (𝑞) is #P-complete. Otherwise, #Val u (𝑞) is in FP.</p><p>The #P-completeness part of the claim follows directly from what we have proved already. Here, the most challenging part of the proof is actually the tractability part. We only present a simple example to give an idea of the proof technique, and defer the full proof to Appendix A.1. We will use the following definition. Given 𝑛, 𝑚 ∈ N, let us write surj 𝑛→𝑚 for the number of surjective functions from {1, . . . , 𝑛} to {1, . . . , 𝑚}. By an inclusion-exclusion argument, one can show that surj 𝑛→𝑚 = 𝑚-1 𝑖=0 (-1) 𝑖 𝑚 𝑖 (𝑚 -𝑖) 𝑛 (for instance, see <ref type="bibr" target="#b2">[3]</ref>). It is clear that this can be computed in FP, when 𝑛 and 𝑚 are given in unary.</p><p>Example 3.10. Let 𝑞 be the sjfBCQ 𝑅(𝑥) ∧ 𝑆 (𝑥), and 𝐷 be an incomplete database over relations 𝑅, 𝑆. Notice that 𝑞 does not have any of the patterns mentioned in Theorem 3.9. We will show that #Val u (𝑞) is in FP. Since 𝑞 contains only two unary atoms we can also assume without loss of generality that the input 𝐷 is a Codd table (otherwise all valuations are satisfying).</p><p>Since we can compute in FP the total number of valuations, it is enough to show how to compute the number of valuations of 𝐷 that do not satisfy 𝑞. Let dom be the uniform domain, 𝑑 be its size, 𝑛 𝑅 (resp., 𝑛 𝑆 ) be the number of nulls in 𝐷 (𝑅) (resp., in 𝐷 (𝑆)) and 𝐶 𝑅 (resp., 𝐶 𝑆 ) be the set of constants occurring in 𝐷 (𝑅) (resp., in 𝐷 (𝑆)), with 𝑐 𝑅 (resp., 𝑐 𝑆 ) its size. We can assume without loss of generality that 𝐶 𝑅 ∩ 𝐶 𝑆 = ∅, as otherwise all the valuations are satisfying, and this is computable in PTIME. Furthermore, we can also assume that 𝐶 𝑅 ∪𝐶 𝑆 ⊆ dom, since we can remove the constants that are not in dom, as these can never match.</p><p>Let 𝑀 := dom \ (𝐶 𝑅 ∪ 𝐶 𝑆 ), and 𝑚 its size (i.e., with our assumptions we have 𝑚 = 𝑑 -𝑐 𝑅 -𝑐 𝑆 ). Fix some subsets 𝑀 ′ ⊆ 𝑀 and 𝑅 ′ ⊆ 𝐶 𝑅 . The quantity surj 𝑛 𝑅 →|𝑀 ′ |+|𝑅 ′ | then counts the number of valuations of the nulls of 𝐷 (𝑅) that span exactly 𝑀 ′ ∪ 𝑅 ′ . Moreover, letting 𝜈 𝑅 be a valuation of the nulls of 𝐷 (𝑅) that spans exactly 𝑀 ′ ∪ 𝑅 ′ , the quantity (𝑑 -𝑐 𝑅 -|𝑀 ′ |) 𝑛 𝑆 is the number of ways to extend 𝜈 𝑅 into a valuation 𝜈 of all the nulls of 𝐷 so that 𝜈 (𝐷) ̸ |= 𝑞: indeed, every null of 𝐷 (𝑆) can take any value in dom \ (𝐶 𝑅 ∪ 𝑀 ′ ). The number of valuations of 𝐷 that do not satisfy 𝑞 is then (keeping in mind that a null in 𝐷 (𝑅) cannot take a value in 𝐶 𝑆 ):</p><formula xml:id="formula_7">∑︁ 𝑀 ′ ⊆𝑀 𝑅 ′ ⊆𝐶 𝑅 surj 𝑛 𝑅 → |𝑀 ′ |+ |𝑅 ′ | × (𝑑 -𝑐 𝑅 -|𝑀 ′ |) 𝑛 𝑆</formula><p>The complexity of counting problems over incomplete databases 1:13</p><p>and since the summands only depends on the sizes of 𝑀 ′ and 𝑅 ′ , this is equal to</p><formula xml:id="formula_8">∑︁ 0⩽𝑚 ′ ⩽𝑚 0⩽𝑟 ′ ⩽𝑐 𝑅 𝑚 𝑚 ′ 𝑐 𝑅 𝑟 ′ surj 𝑛 𝑅 →𝑚 ′ +𝑟 ′ × (𝑑 -𝑐 𝑅 -𝑚 ′ ) 𝑛 𝑆</formula><p>This last expression can clearly be computed in PTIME. <ref type="foot" target="#foot_6">6</ref>□ 3.2.2 Codd tables. We conclude this section by turning our attention to the case of Codd tables. Notice that none of the results proved so far provides a hard pattern in this case. We identify in the following proposition a simple query for which the problem is intractable.</p><formula xml:id="formula_9">Proposition 3.11. #Val u Cd (𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)) is #P-hard.</formula><p>Proof. We reduce from the problem of counting the number of independent sets of a bipartite (simple) graph, written #BIS, which is #P-hard <ref type="bibr" target="#b43">[44]</ref>. <ref type="bibr">Let</ref>  </p><formula xml:id="formula_10">) with 𝑆 1 ⊆ 𝑋, 𝑆 2 ⊆ 𝑌 , such that (𝑆 1 × 𝑆 2 ) ∩ 𝐸 = ∅.</formula><p>We will call such a pair an independent pair. For 0 ⩽ 𝑖, 𝑗 ⩽ 𝑛, let 𝑍 𝑖,𝑗 be the number of independent pairs (𝑆 1 , 𝑆 2 ) such that |𝑆 1 | = 𝑖 and |𝑆 2 | = 𝑗. It is clear that (★) the number of independent sets of 𝐺 is then #BIS(𝐺) = 0⩽𝑖,𝑗 ⩽𝑛 𝑍 𝑖,𝑗 . The idea of the reduction is to construct in polynomial time (𝑛 + 1) 2 incomplete databases 𝐷 𝑎,𝑏 for 0 ⩽ 𝑎, 𝑏 ⩽ 𝑛 such that, letting 𝐶 𝑎,𝑏 be the number of valuations 𝜈 of 𝐷 𝑎,𝑏 with 𝜈 (𝐷 𝑎,𝑏 ) ̸ |= 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦), the values of the variables 𝑍 𝑖,𝑗 and 𝐶 𝑖,𝑗 form a linear system of equations AZ = C, with A an invertible matrix. This will allow us, using (𝑛 + 1) 2 calls to an oracle for #Val u Cd (𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧𝑇 (𝑦)), to recover the 𝑍 𝑖,𝑗 values, and then to compute #BIS(𝐺) using (★). We now explain how we construct 𝐷 𝑎,𝑏 from 𝐺 for 0 ⩽ 𝑎, 𝑏 ⩽ 𝑛, and define A. First, we fix an arbitrary linear order 𝑥 1 , . . . , 𝑥 𝑛 of 𝑋 , and similarly 𝑦 1 , . . . , 𝑦 𝑛 for 𝑌 . The database 𝐷 𝑎,𝑏 has constants 𝑎 𝑖 for 1 ⩽ 𝑖 ⩽ 𝑛, and has a fact 𝑆 (𝑎 𝑖 , 𝑎 𝑗 ) whenever (𝑥 𝑖 , 𝑦 𝑗 ) ∈ 𝐸. It has nulls ⊥ 1 , . . . , ⊥ 𝑎 and facts 𝑅(⊥ 𝑖 ) for 1 ⩽ 𝑖 ⩽ 𝑎 (if 𝑎 = 0 there are no such nulls and facts), and nulls ⊥ ′ 1 , . . . , ⊥ ′ 𝑏 and facts 𝑇 (⊥ ′ 𝑖 ) for 1 ⩽ 𝑖 ⩽ 𝑏; in particular, this is a Codd table. The uniform domain of the nulls is {𝑎 𝑖 | 1 ⩽ 𝑖 ⩽ 𝑛}. Given a valuation 𝜈 of 𝐷 𝑎,𝑏 , let 𝑃 (𝜈) be the pair of subsets of 𝑉 defined by</p><formula xml:id="formula_11">𝑃 (𝜈) def = ({𝑥 𝑖 | ∃1 ⩽ 𝑘 ⩽ 𝑎 s.t. 𝜈 (⊥ 𝑘 ) = 𝑎 𝑖 }, {𝑦 𝑖 | ∃1 ⩽ 𝑘 ⩽ 𝑏 s.t. 𝜈 (⊥ ′ 𝑘 ) = 𝑎 𝑖 })</formula><p>One can then easily check that the following two claims hold:</p><p>• For every valuation 𝜈 of 𝐷 𝑎,𝑏 , we have that</p><formula xml:id="formula_12">𝜈 (𝐷 𝑎,𝑏 ) ̸ |= 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) iff 𝑃 (𝜈) is an independent pair of 𝐺; 7 • For every independent pair (𝑆 1 , 𝑆 2 ) of 𝐺, there are exactly surj 𝑎→|𝑆 1 | × surj 𝑏→|𝑆 2 | valuations 𝜈 such that 𝑃 (𝜈) = (𝑆 1 , 𝑆 2 ).</formula><p>But then, we have 𝐶 𝑎,𝑏 = 0⩽𝑖,𝑗 ⩽𝑛 (surj 𝑎→𝑖 × surj 𝑏→𝑗 )𝑍 𝑖,𝑗 . In other words, we have the linear system of equations AZ = C, where A is the (𝑛 + 1) 2 × (𝑛 + 1) 2 matrix defined by A (𝑎,𝑏),(𝑖,𝑗) def = surj 𝑎→𝑖 × surj 𝑏→𝑗 . This matrix is the Kronecker product A ′ ⊗ A ′ of the (𝑛 + 1) × (𝑛 + 1) matrix with entries A ′ 𝑎,𝑖 def = surj 𝑎→𝑖 . Since A ′ is a triangular matrix with non-zero coefficients on the diagonal, it is invertible, hence so is A, which concludes the proof. □ Note that in Proposition 3.8, we proved that #Val u (𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦)) is #P-hard in the general case where naive tables are allowed. Hence, the hardness of that query for naive tables was in fact a consequence of Proposition 3.11. However, we decided to provide a separate proof for Proposition 3.8, because in this case intractability holds already when nulls are interpreted over the fixed domain {0, 1}, whereas we do not know if this is true for Codd tables.</p><p>The second pattern that we show is hard for #Val u for Codd tables is 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). Again, notice that we already showed this query to be hard in the case of naive tables (as Proposition 3.8), even for a fixed domain of {0, 1}. In the case of Codd tables, hardness still holds, but the proof is more complicated and uses domains of unbounded size (which is why we provide separate proofs). We show:</p><formula xml:id="formula_13">Proposition 3.12. #Val u Cd (𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦)) is #P-hard.</formula><p>Proof. Let 𝑞 be the query 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). We reduce from the problem of counting the number of matchings of a 2-3-regular bipartite graph, which is #P-complete <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b54">55]</ref>. Let 𝐺 = (𝐴 ⊔ 𝐵, 𝐸) be a 2-3-regular bipartite graph, with the nodes in 𝐴 having degree 3 and those in 𝐵 having degree 2, and let 𝑛 𝐴 def = |𝐴|, and 𝑛 𝐵 def = |𝐵|. Notice that since 𝐺 is 2-3-regular we have that 𝑛 𝐵 = 3𝑛 𝐴 2 . We say that a set 𝑆 ⊆ 𝐸 of edges of 𝐺 is an 𝐴-semimatching if every node 𝑎 of 𝐴 is adjacent to at most 1 edge of 𝑆; formally, for every 𝑎 ∈ 𝐴 we have |{𝑒 ∈ 𝑆 | 𝑎 ∈ 𝑒}| ⩽ 1. The type of an 𝐴-semimatching 𝑆 is the number 𝑐 of nodes in 𝐵 that are adjacent to exactly 2 edges of 𝑆;</p><formula xml:id="formula_14">formally, 𝑐 def = |{𝑏 ∈ 𝐵 | |{𝑒 ∈ 𝑆 | 𝑏 ∈ 𝑒}| = 2}|. For 0 ⩽ 𝑐 ⩽ 𝑛 𝐵 ,</formula><p>we write 𝑇 𝑐 for the number of 𝐴-semimatchings of 𝐺 of type 𝑐. Observe then that 𝑇 0 is simply the number of matchings of 𝐺. The idea of the reduction is then as follows. We will construct databases 𝐷 𝑘 for 0 ⩽ 𝑘 ⩽ 𝑛 𝐵 such that, letting 𝐶 𝑘 be the number of valuations 𝜈 of 𝐷 𝑘 such that 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞, the values of the variables 𝑇 𝑘 and 𝐶 𝑘 form a system of linear equations AT = C, with A and invertible matrix. This will allow us, using 𝑛 𝐵 + 1 calls to and oracle for #Val u Cd (𝑞), to recover the values 𝑇 𝑘 , and thus to obtain 𝑇 0 in polynomial time, that is, the number of matchings of 𝐺. We now explain how to construct the database 𝐷 𝑘 for 0 ⩽ 𝑘 ⩽ 𝑛 𝐵 . In what follows we use the convention that {1, . . . , 𝑘 } = ∅ when 𝑘 = 0. The database 𝐷 𝑘 contains the following facts:</p><p>(1) One fact 𝑅(𝑎, ⊥ 𝑎 ) for every 𝑎 ∈ 𝐴;</p><p>(2) One fact 𝑆 (⊥ 𝑏 , 𝑏) for every 𝑏 ∈ 𝐵;</p><p>(3) One fact 𝑆 (⊥ 𝑎 ′, 𝑎 ′ ) for every 𝑎 ∈ 𝐴 where 𝑎 ′ is a fresh constant. In particular, observe that there are 𝑛 𝐴 such facts. In what follows we will write</p><formula xml:id="formula_15">𝐴 ′ def = {𝑎 ′ | 𝑎 ∈ 𝐴}. (4) One fact 𝑆 (𝑎 1 , 𝑎 ′ 2 ) for every (𝑎 1 , 𝑎 2 ) ∈ 𝐴 × 𝐴 with 𝑎 1 ≠ 𝑎 2 ; (5) One fact 𝑆 (𝑎, 𝑖) for every (𝑎, 𝑖) ∈ 𝐴 × {1, . . . , 𝑘 }; (6) One fact 𝑆 (𝑢, 𝑣) for every (𝑢, 𝑣) ∈ (𝐴 ∪ 𝐵) 2 such that {𝑢, 𝑣 } is not in 𝐸. (7) One fact 𝑅(𝑢, 𝑣) for every (𝑢, 𝑣) ∈ (𝐴 ′ ∪ 𝐵) 2 .</formula><p>And finally, the (uniform) domain for all the nulls is dom def = 𝐴 ∪ 𝐵 ∪ 𝐴 ′ ∪ {1, . . . , 𝑘 }. Note that this is indeed a Codd database. Now, let us compute 𝐶 𝑘 , the number of valuations 𝜈 of 𝐷 𝑘 such that 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞. For such a valuation 𝜈 of 𝐷 𝑘 such that 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞, observe that (★) for every 𝑎 ∈ 𝐴 it holds that 𝜈 (⊥ 𝑎 ) is either 𝑎 ′ or is one of the nodes in 𝐵 that is a neighbor of 𝑎; this is because otherwise, the facts from (4-6) would make the query be satisfied. Then, for a valuation 𝜈 of 𝐷 𝑘 such that 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞, let us define SM(𝜈) def = {{𝑎, 𝑏} | (𝑎, 𝑏) ∈ (𝐴 × 𝐵) ∩ 𝑅(𝜈 (𝐷 𝑘 ))}. Because of (★), observe that SM(𝜈) is a subset of 𝐸, and that it is in fact an 𝐴-semimatching. We can then partition the valuations 𝜈 of 𝐷 𝑘 with 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞 according to the type of SM(𝜈) as follows:</p><formula xml:id="formula_16">{𝜈 | 𝜈 is a valuation of 𝐷 𝑘 with 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞} = 0⩽𝑐 ⩽𝑛 𝐵 𝑆: 𝑆 is an 𝐴-semimatching of 𝐺 of type 𝑐 𝜈: 𝜈 valuation of 𝐷 𝑘 𝜈 (𝐷 𝑘 )̸ |=𝑞 SM(𝜈)=𝑆 {𝜈 }.</formula><p>(2) Fix an 𝐴-semimatching 𝑆 of 𝐺 of type 𝑐 ∈ {0, . . . , 𝑛 𝐵 }, and let us count how many valuations 𝜈 of 𝐷 𝑘 there are such that 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞 and SM(𝜈) = 𝑆. First of all, observe that for such a valuation 𝜈, the value of 𝜈 (⊥ 𝑎 ) for every 𝑎 ∈ 𝐴 is forced: it is 𝑎 ′ if 𝑎 is adjacent to no edge of 𝑆, and otherwise it is 𝑏 for the unique {𝑎, 𝑏} ∈ 𝑆. Therefore we have to count how many possibilities there are for the remaining nulls, those of the form ⊥ 𝑎 ′ and ⊥ 𝑏 from facts (2-3). We have:</p><p>• For a null ⊥ 𝑏 such that 𝑏 is adjacent to two edges of 𝑆, there are 𝑛 𝐴 + 𝑘 -2 possible values in order to not satisfy the query. Note that there are 𝑐 such nulls ⊥ 𝑏 . • For a null ⊥ 𝑎 ′ such that 𝑎 is not adjacent to an edge in 𝑆 (so that we know that 𝜈 (⊥ 𝑎 ) = 𝑎 ′ ), there are 𝑛 𝐴 + 𝑘 -1 possible values in order to not satisfy the query. For a null ⊥ 𝑏 such that 𝑏 is adjacent to exactly one edge {𝑎, 𝑏} of 𝑆 (i.e., we have 𝜈 (⊥ 𝑎 ) = 𝑏) there are again 𝑛 𝐴 + 𝑘 -1 possible values to not satisfy the query. Observe that in total there are 𝑛 𝐴 -2𝑐 such nulls ⊥ 𝑎 ′ or ⊥ 𝑏 , because 𝑆 is an 𝐴-semimatching. • For a null ⊥ 𝑎 ′ such that 𝑎 is adjacent to an edge in 𝑆 (so that we know that 𝜈 (⊥ 𝑎 ) ≠ 𝑎 ′ ) there are 𝑛 𝐴 + 𝑘 possibilities, and similarly for a null ⊥ 𝑏 such that 𝑏 is not adjacent to an edge in 𝑆 there are 𝑛 𝐴 + 𝑘 possible values. By the previous two items, in total there are</p><formula xml:id="formula_17">𝑛 𝐴 + 𝑛 𝐵 -𝑐 -(𝑛 𝐴 -2𝑐) = 𝑛 𝐵 + 𝑐 such nulls ⊥ 𝑎 ′ or ⊥ 𝑏 . Therefore, there are exactly (𝑛 𝐴 + 𝑘 -2) 𝑐 (𝑛 𝐴 + 𝑘 -1) 𝑛 𝐴 -2𝑐 (𝑛 𝐴 + 𝑘) 𝑛 𝐵 +𝑐 valuations 𝜈 of 𝐷 𝑘 such that 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞 and SM(𝜈) = 𝑆.</formula><p>Since this depends only on the type of the 𝐴-semimatching 𝑆 (and not on 𝑆 itself), we obtain from Equation <ref type="formula" target="#formula_19">2</ref>that</p><formula xml:id="formula_18">𝐶 𝑘 = |{𝜈 | 𝜈 is a valuation of 𝐷 𝑘 with 𝜈 (𝐷 𝑘 ) ̸ |= 𝑞}| = ∑︁ 0⩽𝑐 ⩽𝑛 𝐵 𝑇 𝑐 × (𝑛 𝐴 + 𝑘 -2) 𝑐 (𝑛 𝐴 + 𝑘 -1) 𝑛 𝐴 -2𝑐 (𝑛 𝐴 + 𝑘) 𝑛 𝐵 +𝑐 .</formula><p>That is, we have the linear system of equations AT = C, with A 𝑘,𝑐 = (𝑛 𝐴 + 𝑘 -2) 𝑐 (𝑛 𝐴 + 𝑘 -1) 𝑛 𝐴 -2𝑐 (𝑛 𝐴 + 𝑘) 𝑛 𝐵 +𝑐 for 0 ⩽ 𝑐, 𝑘 ⩽ 𝑛 𝐵 . But observe that we have A = DV, with D being the diagonal (𝑛 𝐵 + 1) × (𝑛 𝐵 + 1) matrix with entries (𝑛 𝐴 + 𝑘 -2) 𝑛 𝐴 (𝑛 𝐴 + 𝑘) 𝑛 𝐵 , and V being the (𝑛 𝐵 + 1) × (𝑛 𝐵 + 1) Vandermonde matrix with coefficients (𝑛 𝐴 +𝑘-2) (𝑛 𝐴 +𝑘) (𝑛 𝐴 +𝑘-1) 2 for 0 ⩽ 𝑘 ⩽ 𝑛 𝐵 . Hence to show that A is invertible, we only need to argue that the coefficients of this Vandermonde matrix V are all distinct. But for the function</p><formula xml:id="formula_19">𝑓 𝑛 𝐴 (𝑥) def = (𝑛 𝐴 +𝑥-2) (𝑛 𝐴 +𝑥) (𝑛 𝐴 +𝑥-1) 2 , one can check that 𝑓 ′ 𝑛 𝐴 (𝑥) =<label>2</label></formula><p>(𝑛 𝐴 +𝑥-1) 3 , so that 𝑓 𝑛 𝐴 is strictly increasing on [0, 𝑛 𝐵 ] (we assume 𝑛 𝐴 ⩾ 2 without loss of generality), so that all the coefficients are indeed distinct. This concludes the proof. □</p><p>As we show next, the patterns from Propositions 3.12 and 3.11 are the only hard patterns for #Val u Cd . The following is then the last dichotomy of this section.</p><p>Theorem 3.13 (dichotomy). Let 𝑞 be an sjfBCQ.</p><formula xml:id="formula_20">If 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) or 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦) is a pattern of 𝑞, then #Val u Cd (𝑞) is #P-complete. Otherwise, #Val u Cd (𝑞) is in FP.</formula><p>We only need to show the tractability part of that claim, as hardness follows from Propositions 3.12 and 3.11 and Lemma 3.3. First of all, observe that we can assume without loss of generality that the sjfBCQ 𝑞 is connected. This is because 𝑞 has no self-join and the database 𝐷 is Codd, so, letting 𝑞 1 , . . . , 𝑞 𝑡 be the connected components of 𝑞, and letting 𝐷 𝑖 be the database 𝐷 restricted to the relations appearing in 𝑞 𝑖 , we have that</p><formula xml:id="formula_21">#Val u Cd (𝑞) (𝐷) = 𝑡 𝑖=1 #Val u Cd (𝑞 𝑖 ) (𝐷 𝑖 ).</formula><p>Second, notice that, for a connected sjfBCQ 𝑞, not containing any of these two patterns is equivalent to the following: there exists a variable 𝑥 such that all atoms of 𝑞 contain variable 𝑥, and for any two atoms of 𝑞, the only variable that they have in common is 𝑥. In other words, 𝑥 is in every atom and every other variable occurs in only one atom. For instance 𝑅 1 (𝑥, 𝑦, 𝑦) ∧ 𝑅 2 (𝑥, 𝑥, 𝑧, 𝑧, 𝑧, 𝑢, 𝑢) ∧ 𝑅 3 (𝑥, 𝑥, 𝑣, 𝑡, 𝑡) is such a query. We now provide an example of a connected query with only two atoms.</p><p>Example 3.14. We consider the query 𝑞 = 𝑅(𝑥, 𝑥, 𝑦, 𝑦) ∧ 𝑆 (𝑥, 𝑥). Let 𝐷 be an incomplete Codd database over relations 𝑅, 𝑆, with uniform domain dom of size 𝑑. In this proof we will use symbols 𝑎, 𝑎 1 , 𝑎 2 , . . . to denote a constant or a null, and symbols 𝑐, 𝑐 1 , 𝑐 2 , . . . to denote constants. Moreover, unless stated otherwise, these symbols can refer to the same constant (but not to the same null because 𝐷 is a Codd database). A fact that contains only constants is called a ground fact. Furthermore, since that database is Codd we will always represent a null with ⊥, being understood that they are all distinct.</p><p>We start with a few simplifications. First, we assume wlog that 𝐷 does not contain ground facts that already satisfy the query. Second, we assume wlog that 𝐷 does not contain facts of the form 𝑅(𝑎, 𝑎 ′ , 𝑐, 𝑐 ′ ) or 𝑅(𝑐, 𝑐 ′ , 𝑎, 𝑎 ′ ) or 𝑆 (𝑐, 𝑐 ′ ) where 𝑐 and 𝑐 ′ are distinct constants. Indeed, because 𝐷 is Codd and such a fact 𝑓 can never be part of a match, we could simply remove 𝑓 from 𝐷 and multiply the end result by the appropriate value (namely, 𝑑 𝑡 where 𝑡 is the number of nulls of 𝑓 ). Last, we assume wlog that for any fact of the form 𝑅(𝑎, 𝑎 ′ , 𝑐, ⊥) or 𝑅(𝑎, 𝑎 ′ , ⊥, 𝑐) or 𝑅(⊥, 𝑐, 𝑎, 𝑎 ′ ) or 𝑅(𝑐, ⊥, 𝑎, 𝑎 ′ ) or 𝑆 (𝑐, ⊥) or 𝑆 (⊥, 𝑐), we have 𝑐 ∈ dom; indeed otherwise, those facts can never be part of a match and we could again remove them and multiply the result by the appropriate value.</p><p>Next, we need to introduce some notation. For a fact 𝑓 of 𝐷, the type of 𝑓 is the word in {0, 1} arity(𝑓 ) that has a 1 in position 𝑖 iff the 𝑖-th element of 𝑓 is a null. For instance the type of 𝑅(⊥, ⊥, 𝑐, ⊥) is 1101 and that of 𝑆 (𝑐, 𝑐) is 00. Observe that there are a fixed number of possible types, because the query is fixed. For a constant 𝑐 and fact 𝑓 of 𝐷, we say that 𝑓 is 𝑐-determined if 𝑓 contains the constant 𝑐 at a position for variable 𝑥. For instance 𝑅(⊥, 𝑐, 𝑐 ′ , ⊥) is 𝑐-determined and so is 𝑆 (𝑐, 𝑐). A fact 𝑓 that contains only nulls on the positions for 𝑥 is called free. With the simplifications of the last paragraph, a fact of 𝐷 is either free or it is 𝑐-determined for a unique constant 𝑐. Let t be a type of 𝐷 (for 𝑅 or for 𝑆). We say that t is free if it has only 1s in the positions corresponding to variable 𝑥; in other words, if it is the type of a free fact. Otherwise we say that t is determined. For a constant 𝑐 and determined type t, we write 𝑛 𝑅,𝑐,t (resp., 𝑛 𝑅,𝑐,t ) the number of 𝑅-facts (resp., of 𝑆-facts) of 𝐷 that are 𝑐-determined of type t. For a free type t of 𝑅 (resp., of 𝑆) we write 𝐹 𝑅,t (resp., 𝐹 𝑆,t ) for the set of free 𝑅-facts (resp., of free 𝑆-facts) and f 𝑅,t (resp.,f t ) for its size. Let 𝑓 be a fact that is 𝑐-determined. We write 𝛼 𝑓 for the number of valuations 𝜈 of the nulls in 𝑓 such that 𝑓 matches the corresponding atom in 𝑞. For instance if 𝑓 is 𝑅(⊥, 𝑐, 𝑐 ′ , ⊥) or again 𝑅(𝑐, 𝑐, 𝑐 ′ , 𝑐 ′ ) then 𝛼 𝑓 = 1, while if 𝑓 is 𝑅(𝑐, 𝑐, ⊥, ⊥) then 𝛼 𝑓 = 𝑑. <ref type="foot" target="#foot_8">8</ref> Similarly we let 𝛽 𝑓 denote the number of valuations 𝜈 of the nulls in 𝑓 such that 𝑓 does not match the corresponding atom in 𝑞; which is then equal to 𝑑 𝑡 -𝛼 𝑓 , for 𝑡 the number of nulls in 𝑓 . Observe that 𝛼 𝑓 and 𝛽 𝑓 depend only on the type t of 𝑓 . Hence we will write 𝛼 t and 𝛽 t instead. Let 𝑓 be a free fact. We let 𝛼 𝑓 be the number of valuations of the nulls in 𝑓 that are not on a position for variable 𝑥 that match the corresponding part of the atom in 𝑞. For instance if 𝑓 is 𝑅(⊥, ⊥, 𝑐 ′ , ⊥) then 𝛼 𝑓 = 1 and if 𝑓 is 𝑅(⊥, ⊥, ⊥, ⊥) then 𝛼 𝑓 = 𝑑. We also define 𝛽 𝑓 def = 𝑑 𝑡 -𝑑𝛼 𝑓 where 𝑡 is the number of nulls, which correspond to the number of valuations of the nulls in 𝑓 such that the ground fact obtained does not match its corresponding atom. Again, since 𝛼 𝑓 and 𝛽 𝑓 depend only on the free type t of 𝑓 , we will write 𝛼 t and 𝛽 t instead. It is clear that we can compute all values 𝛼 𝑓 ,𝑐 and 𝛽 𝑓 ,𝑐 , for every determined fact 𝑓 and constant 𝑐 of 𝐷, and values 𝛼 𝑓 for every free fact in polynomial time. Last, we fix a linear order 𝑐 1 , . . . , 𝑐 𝑛 on the constants 𝑐 𝑖 such that there exists a fact of 𝐷 that is 𝑐 𝑖 -determined.</p><p>Next, we explain how we can compute in FP the number of valuations of 𝐷 that do not satisfy 𝑞. To do so, we will first define some quantities, and then show that we can compute these quantities in polynomial time using a dynamic programming approach. One of these quantities will be the number of valuations of 𝐷 that do not satisfy 𝑞, which is what we want to compute. The quantities that we will define are of the form 𝑉 (params), where params consist of the following parameters ( †):</p><p>(a) one parameter 𝑣 whose range is 0 . . . 𝑛; (b) one parameter 𝑞 𝑅,t for every free type t ∈ {0, 1} 4 of 𝑅, with range 0 . . . f 𝑅,t ; (c) one parameter 𝑟 𝑅 with range 0, . . . , 𝑛; (d) one parameter 𝑟 𝑆 with range 0, . . . , 𝑟 𝑅 ;</p><p>We now explain what the quantity 𝑉 (params) with these parameters represent. To that end, we define the incomplete database 𝐷 (params) to be the database that contains only</p><p>• all of the facts that are 𝑐 𝑖 -determined for 1 ⩽ 𝑖 ⩽ 𝑣 (if 𝑣 = 0 then 𝐷 𝑣 contains no determined facts); • for every free type t of 𝑅, 𝐷 (params) contains 𝑞 𝑅,t free 𝑅-facts of 𝐷 of type t (it doesn't matter which ones, say the first 𝑞 𝑅,t ones); • 𝐷 (params) contains all the free 𝑆-facts of 𝐷.</p><p>(Note that parameters (c) and (d) are not used to define the database but we still write 𝐷 (params).) The quantity 𝑉 (params) is then defined to be the number of valuations 𝜈 of database 𝐷 (params) such that 𝜈 (𝐷 (params)) ̸ |= 𝑞 and such that the following holds: (1) for every 1 ⩽ 𝑖 ⩽ 𝑟 𝑆 and free fact 𝑓 of 𝑅 or of 𝑆, the ground fact 𝜈 (𝑓 ) does not match the corresponding atom in 𝑞 with variable 𝑥 mapped to 𝑐 𝑖 (this condition is empty if 𝑟 𝑆 = 0); and (2) for every 𝑟 𝑆 + 1 ⩽ 𝑖 ⩽ 𝑟 𝑅 and every free fact 𝑓 of 𝑅, the ground fact 𝜈 (𝑓 ) does not match 𝑅(𝑥, 𝑥, 𝑦, 𝑦) with variable 𝑥 mapped to 𝑐 𝑖 (this condition is empty if 𝑟 𝑅 = 𝑟 𝑆 ). By definition we then have that, when 𝑣 = 𝑛, 𝑞 𝑅,t = f 𝑅,t for every free type t of 𝑅 -so that 𝐷 (params) is equal to 𝐷 -, 𝑟 𝑅 = 0 and 𝑟 𝑆 = 0 then 𝑉 (params) is then equal to #Val u Cd (𝑞) (𝐷). Observe that there are a fixed number of parameters in params (because the query is fixed), and that the possible values of these parameters are polynomial in the size of the input. We explain how compute the values 𝑉 (params) by dynamic programming.</p><p>Base case. Our base case will be when 𝑣 is equal to zero (and the other parameters are arbitrary as in ( †)); in other words, the database 𝐷 (params) does not contain any determined facts, it contains only free facts. We have to compute the number of valuations of 𝐷 (params) that do not satisfy the query and such that (1) and (2) hold. We do so as follows. We guess a subset 𝑆 𝑅 of dom \ {𝑐 1 , . . . , 𝑐 𝑟 𝑅 }; this will be the set of constants 𝑐 such that 𝑅(𝑐, 𝑐, 𝑐 ′ , 𝑐 ′ ) ∈ 𝜈 (𝐷 (params)) for some 𝑐 ′ . We also guess a subset 𝑆 𝑆 of dom \ {𝑐 1 , . . . , 𝑐 𝑟 𝑆 } ∪ 𝑆 𝑅 ; this will be the set of constants 𝑐 such that 𝑆 (𝑐, 𝑐) ∈ 𝜈 (𝐷 (params)) (observe that 𝑆 𝑅 and 𝑆 𝑆 are disjoint; this is in order to avoid satisfying the query). To "achieve" these subsets, we for each free type t of 𝑅 guess a subset 𝑊 𝑅,t of the free facts of 𝑅 of type t; these will be the 𝑅-facts 𝑓 of type t such that 𝜈 (𝑓 ) matches 𝑅(𝑥, 𝑥, 𝑦, 𝑦) with a constant in 𝑆 𝑅 for variable 𝑥. Similarly we for each free type t of 𝑆 guess a subset 𝑊 𝑆,t of the free facts of 𝑆 of type t; these will be the 𝑆-facts 𝑓 of type t such that 𝜈 (𝑓 ) matches 𝑆 (𝑥, 𝑥) with a constant in 𝑆 𝑆 for variable 𝑥. To ensure that these subsets are indeed enough to cover 𝑆 𝑅 and 𝑆 𝑆 , we surjectively assign each of the corresponding facts a constant in 𝑆 𝑅 (for 𝑅-facts) or 𝑆 𝑆 (for 𝑆-facts). For such facts 𝑓 , we then choose one of the 𝛼 t valuations of 𝑓 that ensure that the ground fact obtained satisfies the correspoinding atom of the query; crucially, this quantity depends only on the type of 𝑓 . For the remaining (free) facts 𝑓 , we choose one of the 𝛽 t valuations of 𝑓 that ensure that the ground facts obtained do not satisfy the corresponding atom of the query. In the end we obtain that 𝑉 (params) is equal to the following expression: </p><formula xml:id="formula_22">∑︁ 𝑆 𝑅 ⊆dom\{𝑐 1 ,...,𝑐 𝑟 𝑅 } ∑︁ 𝑆 𝑆 ⊆dom\ {𝑐 1 ,...,𝑐 𝑟 𝑆 }∪𝑆 𝑅 ∑︁ 𝑊 𝑅,t 1 ⊆𝑄 𝑅,t 1 • • • ∑︁ 𝑊 𝑅,t J ⊆𝑄 𝑅,t J ∑︁ 𝑊 𝑅,t ′ 1 ⊆𝐹 𝑆,t ′ 1 • • • ∑︁ 𝑊 𝑅,t ′ K ⊆𝐹 𝑆,t ′ K 𝛾<label>(3)</label></formula><formula xml:id="formula_23">𝛾 = surj 𝑧→ |𝑆 𝑅 | × surj 𝑧 ′ → |𝑆 𝑆 | × 𝐽 𝑖=1 𝛼 |𝑊 𝑅,t i | t i 𝛽 |𝑄 𝑅,t i |-|𝑊 𝑅,t i | t i × 𝐾 𝑖=1 𝛼 |𝑊 𝑆,t ′ i | t ′ i 𝛽 |𝐹 𝑆,t ′ i |-|𝑊 𝑆,t ′ i | t ′ i .</formula><p>Obviously, we cannot compute the expression in 3 in polynomial time, since we are summing over subsets of the input facts. However, because 𝛾 depends only on the sizes of all these sets, we can express 𝑉 (params) as</p><formula xml:id="formula_24">∑︁ 0⩽𝑠 𝑅 ⩽𝑑-𝑟 𝑅 ∑︁ 0⩽𝑠 𝑆 ⩽𝑑-𝑟 𝑆 -𝑠 𝑅 ∑︁ 0⩽𝑤 𝑅,t 1 ⩽𝑞 𝑅,t 1 • • • ∑︁ 0⩽𝑤 𝑅,t J ⩽𝑞 𝑅,t J ∑︁ 0⩽𝑤 𝑅,t ′ 1 ⩽f 𝑅,t ′ 1 • • • ∑︁ 0⩽𝑤 𝑅,t ′ K ⩽f 𝑅,t ′ K 𝛿,<label>(4)</label></formula><p>where, letting again 𝑧 def = 𝐽 𝑖=1 𝑤 𝑅,t i and 𝑧 ′ def = 𝐾 𝑖=1 𝑤 𝑆,t ′ i , we have</p><formula xml:id="formula_25">𝛿 =surj 𝑧→𝑠 𝑅 × surj 𝑧 ′ →𝑠 𝑆 × 𝐽 𝑖=1 𝛼 𝑤 𝑅,t i t i 𝛽 𝑞 𝑅,t i -𝑤 𝑅,t i t i × 𝐾 𝑖=1 𝛼 𝑤 𝑆,t ′ i t ′ i 𝛽 f 𝑆,t ′ i -𝑤 𝑆,t ′ i t ′ i × 𝑑 -𝑑 𝑅 𝑠 𝑅 𝑑 -𝑟 𝑆 -𝑠 𝑅 𝑠 𝑆 × 𝐽 𝑖=1 𝑞 𝑅,t i 𝑤 𝑅,t i × 𝐾 𝑖=1 f 𝑆,t ′ i 𝑤 𝑆,t ′ i .</formula><p>But then, because the expression 4 contains a fixed number of nested sums (this number depends only on the query 𝑞), and because indices and summands are polynomial, this quantity can be computed in polynomial time. This concludes the base case, that was when 𝑣 = 0.</p><p>Inductive case. Next we explain how we can compute the quantities 𝑉 (params) (with the parameters params as in ( †)) in polynomial time from quantities 𝑉 (params ′ ) with a strictly smaller value for parameter (a). Hence we assume that parameter 𝑣 is ⩾ 1. The idea is to get rid of the 𝑐 𝑣determined facts of 𝐷 (params), by partitioning the valuations of 𝐷 (params) that do not satisfy 𝑞 and satisfy (1) and ( <ref type="formula" target="#formula_19">2</ref>) into (A) those valuations 𝜈 that do not satisfy the query and satisfy (1) and ( <ref type="formula" target="#formula_19">2</ref>) and such that no 𝑐 𝑣determined 𝑅-fact or free 𝑅-fact 𝑓 of 𝐷 (params) is such that 𝜈 (𝑓 ) matches 𝑅(𝑥, 𝑥, 𝑦, 𝑦) with variable 𝑥 mapped to 𝑐 𝑣 ; and (B) those valuations 𝜈 that do not satisfy the query and satisfy (1) and <ref type="bibr" target="#b1">(2)</ref> and such that at least one 𝑐 𝑣 -determined 𝑅-fact or free 𝑅-fact 𝑓 of 𝐷 (params) is such that 𝜈 (𝑓 ) matches 𝑅(𝑥, 𝑥, 𝑦, 𝑦)</p><p>with variable 𝑥 mapped to 𝑐 𝑣 (and thus, no 𝑐 𝑣 -determined 𝑆-fact or free 𝑆-fact 𝑓 of 𝐷 (params) is such that 𝜈 (𝑓 ) matches 𝑆 (𝑥, 𝑥) with variable 𝑥 mapped to 𝑐 𝑣 ). To compute valuations in (A), we choose for each 𝑅-fact 𝑓 that is 𝑐 𝑣 -determined one of the 𝛽 𝑓 ,𝑐 𝑣 valuations of its nulls that is such that 𝜈 (𝑓 ) does not match 𝑅(𝑥, 𝑥, 𝑦, 𝑦), we disallow the free facts of 𝑅 to have valuations that would match on 𝑐 𝑣 by increasing 𝑟 𝑅 by one, and we choose any valuation for the 𝑐 𝑣 -determined facts of 𝑆 (since we know that they will not be part of a match). Formally, letting 𝑡 𝑓 be the number of nulls of a fact 𝑓 , we have the expression</p><formula xml:id="formula_26">𝐴 = 𝑐 𝑣 -determined 𝑅-fact 𝑓 𝛽 𝑓 × 𝑐 𝑣 -determined 𝑆-fact 𝑓 𝑑 𝑡 𝑓 × 𝑉 (params ′ )</formula><p>where params ′ is equal to params except that 𝑣 ′ = 𝑣 -1 and 𝑟 ′ 𝑅 = 𝑟 ′ 𝑅 + 1. This can be computed in polynomial time if we know the value 𝑉 (params ′ ). For valuations in (B), we do as follows. We choose exactly which subset of the 𝑐 𝑣 -determined and free facts of 𝑅 will match 𝑅(𝑥, 𝑥, 𝑦, 𝑦) with 𝑥 = 𝑐 𝑣 by partioning according to the types, for the remaining 𝑐 𝑣 -determined 𝑅-facts we choose one of the 𝛽 valuations that do not match on 𝑐 𝑣 , for the remaining free facts of 𝑅 we disallow to match on 𝑐 𝑣 by increasing 𝑟 𝑅 by one, for each 𝑐 𝑣 -determined fact 𝑓 of 𝑆 we choose one of the 𝛽 𝑓 ,𝑐 𝑣 valuations of 𝑓 that are such that 𝜈 (𝑓 ) is not 𝑆 (𝑐 𝑣 , 𝑐 𝑣 ), and for the free facts of 𝑆 we disallow matching on 𝑐 𝑣 by increasing 𝑟 𝑆 by one. Formally, letting t 1 , . . . , t J be the types of the 𝑐 𝑣 -determined 𝑅-facts and t ′ 1 , . . . , t ′ J be the free types of 𝑅 we obtain an expression of the form</p><formula xml:id="formula_27">𝐵 = ∑︁ 0⩽ℎ t 1 ⩽𝑛 𝑅,𝑐𝑣 ,t 1 • • • ∑︁ 0⩽ℎ t J ⩽𝑛 𝑅,𝑐𝑣 ,t J ∑︁ 0⩽ℎ ′ t ′ 1 ⩽𝑞 𝑅,t ′ 1 • • • ∑︁ 0⩽ℎ ′ t ′ K ⩽𝑞 𝑅,t ′ K 𝛾 × 𝛿 × 𝑉 (params ′ )<label>(5)</label></formula><p>where 𝛾 is equal to 1 if 𝐽 𝑖=1 ℎ t i + 𝐾 𝑖=1 ℎ t ′ i ⩾ 1 and to 0 otherwise (in order to match on 𝑐 𝑣 in 𝑅), 𝛿 is</p><formula xml:id="formula_28">𝐽 𝑖=1 𝑛 𝑅,𝑐 𝑣 ,t i ℎ t i 𝛼 ℎ t i t i 𝛽 𝑛 𝑅,𝑐𝑣 ,t i -ℎ t i t i × 𝐽 𝑖=1 𝑞 𝑅,t ′ i ℎ ′ t ′ i 𝛼 ℎ ′ t ′ i t ′ i × 𝑐 𝑣 -determined 𝑆-fact 𝑓 𝛽 𝑓 ,</formula><p>and where params ′ is equal to params except that:</p><p>• we have 𝑣 ′ = 𝑣 -1;</p><p>• for every free type t of 𝑅, we have</p><formula xml:id="formula_29">𝑞 ′ 𝑅,t = 𝑞 ′ 𝑅,t -ℎ ′ t ; • we have 𝑟 ′ 𝑅 = 𝑟 𝑅 + 1; • we have 𝑟 ′ 𝑆 = 𝑟 𝑆 + 1.</formula><p>The crucial point to see that expressions A and B indeed compute what we want is that we do not need to remember exactly which susbsets of constants are disallowed to match for the free facts, but we only need to remember their numbers (this is what allows us to use a dynamic programming approach); and similarly for the free facts of 𝑅, we only need to remember how many we have left at each stage of each type, but not their precise subsets. Again, if we know the values of 𝑉 (params ′ ) where in params ′ parameter 𝑣 ′ is equal to 𝑣 -1 then we can compute in polynomial time the value 𝑉 (params) = 𝐴 + 𝐵. Thus, we can compute all values 𝑉 (params) in polynomial time, and this concludes this example. □ The proof in this example can be extended as-is to any connected sjfBCQ containing only two atoms and having only one variable (𝑥) that joins. We claim that the same idea works for an arbitrary number of atoms, which concludes Theorem 3.13. Since a full proof is technically tedious and does not provide new insights, we omit it here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DICHOTOMIES FOR COUNTING COMPLETIONS</head><p>In this section, we study the complexity of the problems of counting completions satisfying an sjfBCQ 𝑞, in the four cases that can be obtained by considering naive or Codd tables and nonuniform or uniform domains. We will again use the notion of pattern as introduced in Definition 3.1. Our first step is to observe that Lemma 3.3, which we used in the last section for the problems or counting valuations, extends to the problems of counting completions. Lemma 4.1. Let 𝑞, 𝑞 ′ be sjfBCQs such that 𝑞 ′ is a pattern of 𝑞. Then we have that #Comp(𝑞 ′ ) ⩽ p par #Comp(𝑞). Moreover, the same results hold if we restrict to the case of Codd tables, and/or to the uniform setting.</p><p>Proof. The reduction is exactly the same as the one of Lemma 3.3. To show that this reduction works properly for counting completions, it is enough to observe that for every pair of valuations 𝜈 1 , 𝜈 2 of 𝐷 ′ (or of 𝐷, since 𝐷 and 𝐷 ′ have exactly the same set of nulls), we have that</p><formula xml:id="formula_30">𝜈 1 (𝐷 ′ ) = 𝜈 2 (𝐷 ′ ) iff 𝜈 1 (𝐷) = 𝜈 2 (𝐷). □</formula><p>We will then follow the same general strategy as in the last section, i.e., prove hardness for some simple patterns and combine these with Lemma 4.1 and tractability proofs to obtain dichotomies. Our findings are summarized in the last two columns of Table <ref type="table">1</ref> in the introduction. We start in Section 4.1 with the non-uniform cases and continue in Section 4.2 with the uniform cases. Again, we explicitly state when a #P-hardness result holds even in the restricted setting in which there is a fixed domain over which nulls are interpreted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The complexity on the non-uniform case</head><p>Here, we study the complexity of the problems #Comp(𝑞) and #Comp Cd (𝑞), providing dichotomy results in both cases. In fact, it turns out that these problems are #P-hard for all sjfBCQs. To prove this, it is enough to show that the problem #Comp Cd (𝑅(𝑥)) is hard, that is, even counting the completions of a single unary table is #P-hard in the non-uniform setting. Proposition 4.2. #Comp Cd (𝑅(𝑥)) is #P-hard.</p><p>Proof. We provide a polynomial-time parsimonious reduction from the problem of counting the vertex covers of a graph, which we denote by #VC. Let 𝐺 = (𝑉 , 𝐸) be a graph. We construct a Codd table 𝐷 using a single unary relation 𝑅 such that the number of completions of 𝐷 equals the number of vertex covers of 𝐺. For every edge 𝑒 = {𝑢, 𝑣 } of 𝐺, we have one null ⊥ 𝑒 with dom(⊥ 𝑒 ) = {𝑢, 𝑣 } and the fact 𝑅(⊥ 𝑒 ). Let 𝑎 be a fresh constant. For every node 𝑢 ∈ 𝑉 we have a null ⊥ 𝑢 with dom(⊥ 𝑢 ) = {𝑢, 𝑎} and the fact 𝑅(⊥ 𝑢 ). Last, we add the fact 𝑅(𝑎). We now show that the number of completions of 𝐷 equals the number of vertex covers of 𝐺.</p><p>Let VC(𝐺) be the set of vertex covers of 𝐺. For a valuation 𝜈 of 𝐷, define the set 𝑆 𝜈 := {𝑢 ∈ 𝑉 | 𝑅(𝑢) ∈ 𝐷 }. Since the fact 𝑅(𝑎) is in every completion of 𝐷, it is clear that the number of completions of 𝐷 is equal to |{𝑆 𝜈 | 𝜈 is a valuation of 𝐷 }|. We claim that VC(𝐺) = {𝑆 𝜈 | 𝜈 is a valuation of 𝐷 }, which shows that the reduction works. (⊆) Let 𝐶 ∈ VC(𝐺), and let us show that there exists a valuation 𝜈 of 𝐷 such that 𝑆 𝜈 = 𝐶. For a null of the form ⊥ 𝑒 with 𝑒 = {𝑢, 𝑣 } ∈ 𝐸, assuming wlog that 𝑢 ∈ 𝐶, we define 𝜈 (⊥ 𝑒 ) to be 𝑢. For a null of the form ⊥ 𝑢 with 𝑢 ∈ 𝑉 , we define 𝜈 (⊥ 𝑢 ) to be 𝑢 if 𝑢 ∈ 𝐶 and 𝑎 otherwise. It is then clear that 𝑆 𝜈 = 𝐶. (⊇) Let 𝜈 be a valuation of 𝐷, and let us show that 𝑆 𝜈 is a vertex cover. Assume by contradiction that there is an edge 𝑒 = {𝑢, 𝑣 } such that 𝑒 ∩ 𝑆 𝜈 = ∅. By definition of 𝐷, we must have 𝜈 (⊥ 𝑒 ) ∈ {𝑢, 𝑣 }, so that one of 𝑢 or 𝑣 must be in 𝑆 𝜈 , hence a contradiction. Therefore, we conclude that #VC ⩽ p par #Comp Cd (𝑅(𝑥)). □</p><p>Recall from Section 2 that, to avoid trivialities, we assume all sjfBCQs to contain at least one atom and that all atoms have at least one variable. Using Lemma 4.1, this allows us to obtain the following dichotomy result. Theorem 4.3 (Dichotomy). For every sjfBCQ 𝑞, it holds that #Comp(𝑞) and #Comp Cd (𝑞) are #Phard.</p><p>Notice here that we do not claim membership in #P; in fact, we will come back to this issue in Section 6 to show that this is unlikely to be true for naive tables. However, we can still show that membership in #P holds for Codd tables. We then obtain: Theorem 4.4 (Dichotomy). For every sjfBCQ 𝑞, the problem #Comp Cd (𝑞) is #P-complete.</p><p>Proof. Hardness is from Theorem 4.3. To show membership in #P we will actually prove a more general result in Section 6.1. There, we show that for every Boolean query 𝑞 such that 𝑞 has model checking in P the problem #Comp Cd (𝑞) is in #P. This in particular applies to all sjfBCQs. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The complexity on the uniform case</head><p>We now investigate the complexity of #Comp u (𝑞) and #Comp u Cd (𝑞). Recall that in the non-uniform case, even counting the completions of a single unary table is a #P-hard problem. This no longer holds in the uniform case, as we will show that #Comp u (𝑞) is in FP for every sjfBCQ that is defined over a schema consisting exclusively of unary relation symbols.</p><p>Such a positive result, however, cannot be extended much further. In fact, we show next that 𝑅(𝑥, 𝑥) and 𝑅(𝑥, 𝑦) are hard patterns, both for naive and Codd tables (and, thus, we also conclude that the problem of counting the completions of a single binary Codd table is a #P-hard problem). We start with the case of naive tables, for which hardness even holds when nulls are interpreted over the fixed domain {0, 1}. Proof. We reduce from #IS, the problem of counting the number of independent sets of a graph. Let 𝐺 = (𝑉 , 𝐸) be a graph. We will construct an incomplete database 𝐷 containing a single binary predicate 𝑅 such that each completion of 𝐷 satisfies 𝑅(𝑥, 𝑥) and the number of completions of 𝐷 is 2 |𝑉 | + #IS(𝐺), thus establishing hardness for the two queries. For every node 𝑢 ∈ 𝑉 , we have a null ⊥ 𝑢 with dom(⊥ 𝑢 ) = {0, 1}. We then construct the naive table 𝐷 as follows:</p><p>• for every node 𝑢 ∈ 𝑉 we add to 𝐷 the fact 𝑅(𝑢, ⊥ 𝑢 );</p><p>• then for every edge {𝑢, 𝑣 } ∈ 𝐸, we add the facts 𝑅(⊥ 𝑢 , ⊥ 𝑣 ) and 𝑅(⊥ 𝑣 , ⊥ 𝑢 ) to 𝐷; and</p><p>• last, we add the facts 𝑅(0, 0), 𝑅(0, 1), 𝑅(1, 0), and 𝑅(⊥, ⊥), where ⊥ is a fresh null.</p><p>It is clear that every completion of 𝐷 satisfies 𝑅(𝑥, 𝑥) (thanks to the fact 𝑅(⊥, ⊥)). Let us now count the number of completions of 𝐷. First, we observe that, thanks to the facts of the form 𝑅(𝑢, ⊥ 𝑢 ), for 𝑢 ∈ 𝑉 , for every two valuations 𝜈, 𝜈 ′ that do not assign the same value to the nulls of the form ⊥ 𝑢 , it is the case that 𝜈 (𝐷) ≠ 𝜈 (𝐷 ′ ). We then partition the completions of 𝐷 into those that contain the fact 𝑅(1, 1), and those that do not contain 𝑅(1, 1). Because of the facts of the form 𝑅(𝑢, ⊥ 𝑢 ), for 𝑢 ∈ 𝑉 , and thanks to the fact 𝑅(⊥, ⊥) which becomes 𝑅(1, 1) when we assign 1 to ⊥, there are exactly 2 |𝑉 | completions of 𝐷 that contain 𝑅(1, 1). Moreover, it is easy to see that there are #IS(𝐺) valuations 𝜈 of 𝐷 that assign 0 to ⊥ and that yield a completion not containing 𝑅(1, 1). Indeed, one can check that a valuation of 𝐷 that assigns 0 to ⊥ yields a completion not containing 𝑅(1, 1) if and only if the set {𝑢 ∈ 𝑉 | 𝜈 (⊥ 𝑢 ) = 1} is an independent set of 𝐺. Therefore, we conclude that the number of completions of 𝐷 is indeed 2 |𝑉 | + #IS(𝐺), and therefore that #IS ⩽ p T #Comp u (𝑞), where 𝑞 can be 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦). □</p><p>Next, we prove hardness of the same queries for Codd tables (but in this case we do not know if harness holds when nulls are interpreted over a fixed domain, as our proof will use domains of unbounded size). We will reduce from the problem of counting the number of induced pseudoforests of a graph, as defined next. Definition 4.6. A graph 𝐺 is a pseudoforest if every connected component of 𝐺 contains at most one cycle. Let 𝐺 = (𝑉 , 𝐸) be a graph. For 𝑆 ⊆ 𝐸, let us denote by 𝐺 [𝑆] the graph (𝑉 ′ , 𝑆), where 𝑉 ′ is the set of nodes of 𝐺 that appear in some edge of 𝑆. The problem #PF is the problem that takes as input a graph 𝐺 = (𝑉 , 𝐸) and outputs the number of edge sets 𝑆 ⊆ 𝐸 such that 𝐺 [𝑆] is a pseudoforest.</p><p>Using techniques from matroid theory, the authors of <ref type="bibr" target="#b25">[26]</ref> have shown that #PF is #P-hard on graphs. We explain in Appendix B.1 how their proof actually shows hardness of this problem for bipartite graphs (which we need); formally, we have: Proposition 4.7 (Implied by <ref type="bibr" target="#b25">[26]</ref>). The problem #PF restricted to bipartite graphs is #P-hard.</p><p>To prove that the reduction that we will present is correct, we will also need the following folklore lemma about pseudoforests. We recall that an orientation of an undirected graph 𝐺 = (𝑉 , 𝐸) is a directed graph that can be obtained from 𝐺 by orienting every edge of 𝐺. Equivalently, one can see such an orientation as a function 𝑓 : 𝐸 → 𝑉 that assigns to every edge in 𝐺 a node to which it is incident. We then have: Lemma 4.8. A graph 𝐺 is a pseudoforest if and only if there exists an orientation of 𝐺 such that every node has outdegree at most 1.</p><p>Proof. Folklore, see, e.g., <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b35">36]</ref>. □</p><p>Using the hardness of #PF on bipartite graphs, we are able show hardness of #Comp u Cd (𝑅(𝑥, 𝑥)) and #Comp u Cd (𝑅(𝑥, 𝑦)) as follows.</p><p>Proposition 4.9. The problems #Comp u Cd (𝑅(𝑥, 𝑥)) and #Comp u Cd (𝑅(𝑥, 𝑦)) are both #P-hard.</p><p>Proof. We reduce both problems from #PF on bipartite graphs. Let 𝐺 = (𝑈 ⊔ 𝑉 , 𝐸) be a bipartite graph. We will construct a uniform Codd table 𝐷 over binary relation 𝑅 such that (1) all the completions of 𝐷 satisfy both queries; and (2) the number of completions of 𝐷 is equal to #PF(𝐺), thus establishing hardness. For every (𝑡, 𝑡 ′ ) ∈ (𝑈 ∪ 𝑉 ) 2 \ 𝐸, we add to 𝐷 the fact 𝑅(𝑡, 𝑡 ′ ); we call these the complementary facts. For every 𝑢 ∈ 𝑈 we add to 𝐷 the fact 𝑅(𝑢, ⊥ 𝑢 ) and for every 𝑣 ∈ 𝑉 the fact 𝑅(⊥ 𝑣 , 𝑣). Finally, we add to 𝐷 a fact 𝑅(𝑓 , 𝑓 ) where 𝑓 is a fresh constant. The uniform domain of the nulls if dom = 𝑈 ∪𝑉 . It is clear that 𝐷 is a Codd table and that every completion of 𝐷 satisfies both queries (thanks to the fact 𝑅(𝑓 , 𝑓 )), so (1) holds. We now prove that (2) holds. First of all, observe that a completion 𝜈 (𝐷) of 𝐷 is uniquely determined by the set of edges {(𝑢, 𝑣) ∈ 𝐸 | 𝑅(𝑢, 𝑣) ∈ 𝜈 (𝐷)}: this is because 𝜈 (𝐷) already contains all the complementary facts. For a set 𝑆 ⊆ 𝐸 of edges, let us define 𝐷 𝑆 to be the complete database that contains all the complementary facts and all the facts 𝑅(𝑢, 𝑣) for (𝑢, 𝑣) ∈ 𝑆 (note that 𝐷 𝑆 is not necessarily a completion of 𝐷). We now argue that for every set 𝑆 ⊆ 𝐸, we have that 𝐷 𝑆 is a completion of 𝐷 if and only if 𝐺 [𝑆] is a pseudoforest, which would conclude the proof. By Lemma 4.8 we only need to show that 𝐷 𝑆 is a completion of 𝐷 if and only if 𝐺 [𝑆] admits an orientation with maximum outdegee 1. We show each direction in turn. (⇒) Assume 𝐷 𝑆 is a completion of 𝐷, and let 𝜈 be a valuation witnessing this fact, i.e., such that 𝜈 (𝐷) = 𝐷 𝑆 . First, observe that we can assume without loss of generality that (★) for every 𝑒 = (𝑢, 𝑣) ∈ 𝑆, we have either 𝜈 (⊥ 𝑢 ) = 𝑣 or 𝜈 (⊥ 𝑣 ) = 𝑢 but not both. Indeed, if we had both then we could modify 𝜈 into 𝜈 ′ by redefining, say, 𝜈 ′ (⊥ 𝑢 ) to be 𝑢, and we would still have that 𝜈 ′ (𝐷) = 𝐷 𝑆 (because 𝑅(𝑢, 𝑢) is already present in 𝐷: it is a complementary fact). We now define an orientation 𝑓 𝜈 : 𝑆 → 𝑈 ∪ 𝑉 of 𝐺 [𝑆] from 𝜈 as follows. Let 𝑒 = (𝑢, 𝑣) ∈ 𝑆. Then: if we have 𝜈 (⊥ 𝑢 ) = 𝑣 we define 𝑓 𝜈 ((𝑢, 𝑣)) to be 𝑣, i.e., we orient the (undirected) edge (𝑢, 𝑣) from 𝑢 to 𝑣. Else, if we have 𝜈 (⊥ 𝑣 ) = 𝑢 we define 𝑓 𝜈 ((𝑢, 𝑣)) to be 𝑢, i.e., we orient the (undirected) edge (𝑢, 𝑣) from 𝑣 to 𝑢. Observe that by (★) 𝑓 𝜈 is well defined. It is then easy to check that the maximal outdegree of the directed graph defined by 𝑓 𝜈 is 1: this is because for every 𝑢 ∈ 𝑈 (resp., 𝑣 ∈ 𝑉 ), there is only one fact in 𝐷 of the form 𝑅(𝑢, null) (resp., 𝑅(null, 𝑣)), namely, the fact 𝑅(𝑢, ⊥ 𝑢 ) (resp., 𝑅(⊥ 𝑣 , 𝑣)). (⇐) Let 𝑓 : 𝑆 → 𝑈 ∪ 𝑉 be an orientation of 𝐺 [𝑆] with maximum outdegree 1. Let 𝜈 𝑓 be the valuation of 𝐷 defined from 𝑓 as follows: for every 𝑢 ∈ 𝑈 (resp., 𝑣 ∈ 𝑉 ), if there is an edge (𝑢, 𝑣) ∈ 𝑆 such that 𝑓 ((𝑢, 𝑣)) = 𝑣 (resp., such that 𝑓 ((𝑢, 𝑣)) = 𝑢), then define 𝜈 𝑓 (⊥ 𝑢 ) to be 𝑣 (resp., define 𝜈 𝑓 (⊥ 𝑣 ) to be 𝑢). Observe that there can be at most one such edge because 𝑓 has maximum outdegree 1, so this is well defined. If there is no such edge, define 𝜈 𝑓 (⊥ 𝑢 ) to be 𝑢 (resp., define 𝜈 𝑓 (⊥ 𝑣 ) to be 𝑣). Since all edges in 𝑆 are given an orientation by 𝑓 , it is clear that for every (𝑢, 𝑣) ∈ 𝑆 we have 𝑅(𝑢, 𝑣) ∈ 𝜈 𝑓 (𝐷). Moreover, since 𝜈 𝑓 (𝐷) contains all the complementary facts, we have that 𝜈 𝑓 (𝐷) = 𝐷 𝑆 , which shows that 𝐷 𝑆 is a completion of 𝐷 and concludes this proof. □</p><p>As we show next, these two patterns suffice to characterize the complexity of #Comp u (𝑞) and #Comp u Cd (𝑞). Theorem 4.10 (Dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) is a pattern of 𝑞, then #Comp u (𝑞) and #Comp u Cd (𝑞) are #P-hard. Otherwise, these problems are in FP. From what precedes, we only have to prove the tractability part of that claim, and this for naive tables. To this end, we define a conjunction of basic singletons sjfBCQ to be an sjfBCQ of the form 𝐶 1 (𝑥 1 ) ∧ . . . ∧ 𝐶 𝑚 (𝑥 𝑚 ), where each 𝐶 𝑖 (𝑥 𝑖 ) is a conjunction of unary atoms over the same variable 𝑥 𝑖 (here the 𝑥 𝑖 are pairwise distinct). Since 𝑞 does not contain the pattern 𝑅(𝑥, 𝑥) nor the pattern 𝑅(𝑥, 𝑦), observe that 𝑞 must in fact be a conjunction of basic singletons sjfBCQ. The main difficulty is to decompose the computation in such a way that we do not count the same completion twice. Moreover, the fact that the database is naive and not Codd, and the fact that constants can appear everywhere, complicate a lot the description of the algorithm. For these reasons, we provide in the next section an example that gives the intuition of the general proof, and defer the general proof to Appendix B.2.</p><p>Note that, as in the last section, we do not claim membership in #P in the statement of Theorem 4.10. However, and also as in the last section, we can show that these problems are in #P for Codd tables, which allows us to obtain our last dichotomy for exact counting. In this section, we prove that for the query 𝑞 def = 𝑅(𝑥) ∧ 𝑆 (𝑦), the problem #Comp u Cd (𝑞) is in FP. Observe that 𝑞 is a conjunction of basic singletons query, and that it is always satisfied (as long as the database is not empty). We will show that #Comp u (𝑞) is in FP. Let 𝐶 𝑅𝑆 , 𝐶 𝑅 , 𝐶 𝑆 (resp, 𝑁 𝑅𝑆 , 𝑁 𝑅 , 𝑁 𝑆 ) be the sets of constants (resp., nulls) that occur respectively: in 𝑅 and in 𝑆, only in 𝑅, only in 𝑆, and denote 𝑐 𝑅𝑆 , 𝑐 𝑅 , 𝑐 𝑆 (resp., 𝑛 𝑅𝑆 , 𝑛 𝑅 , 𝑛 𝑆 ) their sizes. Let dom be the uniform domain of the nulls, and let 𝑑 be its size. First of all, observe that we can assume without loss of generality that that are not in dom and this would not change the result. Let 𝑐 = 𝑐 𝑅𝑆 + 𝑐 𝑅 + 𝑐 𝑆 . The next two claims explain how we can decompose the computation in a way that we do not count a same completion twice (Claim 4.12), and that we count all the possible completions (Claim 4.13).</p><formula xml:id="formula_31">𝐶 def = 𝐶 𝑅𝑆 ∪ 𝐶 𝑅 ∪ 𝐶 𝑆 ⊆ dom,</formula><p>Claim 4.12. For a triplet (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) of subsets of dom satisfying the conditions (★) 𝐼 𝑅 ⊆ dom \ 𝐶, 𝐼 𝑆 ⊆ dom \ (𝐶 ∪ 𝐼 𝑅 ), and 𝐼 𝑅𝑆 ⊆ dom \ (𝐶 𝑅𝑆 ∪ 𝐼 𝑅 ∪ 𝐼 𝑆 ), let us define 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) to be the complete database consisting of the following facts:</p><p>(1) 𝑅(𝑎) and 𝑆 (𝑎) for 𝑎 ∈ 𝐶 𝑅𝑆 ∪ 𝐼 𝑅𝑆 ;</p><p>(2) 𝑅(𝑎) for 𝑎 ∈ 𝐼 𝑅 ∪ (𝐶 𝑅 \ 𝐼 𝑅𝑆 );</p><p>(3) 𝑆 (𝑎) for 𝑎 ∈ 𝐼 𝑆 ∪ (𝐶 𝑆 \ 𝐼 𝑅𝑆 ); Then, for any two such triplets of sets (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) and (𝐼 ′ 𝑅 , 𝐼 ′ 𝑆 , 𝐼 ′ 𝑅𝑆 ) that are different, the complete databases 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) and 𝑃 (𝐼 ′ 𝑅 , 𝐼 ′ 𝑆 , 𝐼 ′ 𝑅𝑆 ) are distinct. Proof. To help the reader, we have drawn in Figure <ref type="figure">2</ref>  </p><formula xml:id="formula_32">= 𝐷 ′ (𝑆) \ (𝐶 𝑆 ∪ 𝐷 ′ (𝑅)); • 𝐼 𝑅𝑆 def = (𝐷 ′ (𝑅) ∩ 𝐷 ′ (𝑆)) \ 𝐶 𝑅𝑆 .</formula><p>Then one can easily check that (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) satisfies (★) and that 𝐷 ′ = 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ). □</p><p>By combining these two claims, we have that the result that we wish to compute (which, we recall, is simply the total number of completions of 𝐷, because any valuation satisfies the query) is equal to ∑︁ Proof. We prove the claim informally by explaining the main ideas, because a formal proof would be too long and not that interesting. Conditions (1-3) are easily checked to be necessary. We now explain why condition (4) is also necessary. Suppose that 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) is a completion of 𝐷. Observe that ( †) to obtain the constants in 𝐼 𝑅𝑆 , we had to use some or all of the following:</p><formula xml:id="formula_33">𝐼</formula><p>• the nulls in 𝑁 𝑅𝑆 ; or ⩽ 𝑑, we have done the same for the nulls in 𝑁 𝑆 and we also used a subset of the constants of 𝐶 𝑅 (and 𝐶 𝑆 ) in such a way that, according to ( †):</p><p>• the nulls in 𝑍 {𝑁 𝑅 } 𝑁 𝑅 have been used to obtain the set 𝐼 𝑅 (which, we recall, is the set of constants that occur only in 𝑅 and that are not in 𝐶 𝑅 ). Note that only the nulls in 𝑁 𝑅 could have been used to obtain constants in 𝐼 𝑅 . This is what the fifth equation expresses. ) constants in this manner.</p><p>The first 4 equations express the partitioning process, and the last equation then expresses that by combining all these constants we indeed obtained the whole set 𝐼 𝑅𝑆 .</p><p>We now explain why conditions (2-4) are sufficient. If |𝐼 𝑅 |, |𝐼 𝑆 | and 𝐼 𝑅𝑆 are all ⩾ 1 then condition ( <ref type="formula" target="#formula_24">4</ref>) is sufficient, because we can use the nulls and constants as explained above, and we have enough of them to obtain the sets 𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 . We explain what happens when 𝐼 𝑅 = ∅ for instance. In that case, condition <ref type="bibr" target="#b0">(1)</ref> ensures us that we have either 𝑛 𝑅 = 0 or 𝐶 𝑅 ∪ 𝐶 𝑅𝑆 ∪ 𝐼 𝑅𝑆 ≠ ∅. If we have 𝑛 𝑅 = 0 then it is fine, since the only nulls that could be used to fill 𝐼 𝑅 are those in 𝑁 𝑅 . If we have 𝑛 𝑅 ⩾ 1 and 𝐶 𝑅 ∪ 𝐶 𝑅𝑆 ∪ 𝐼 𝑅𝑆 ≠ ∅ then we can use these to absorb the values of the nulls in 𝑁 𝑅 , and we are fine (i.e., we will be able to obtain 𝐼 𝑅 = ∅). We leave it to the reader to complete the small gaps in this proof. □</p><p>Using this, we have that the value of check(𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) only depends on the sizes of 𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 , and moreover can be computed in polynomial time Proof. The fact that this value only depends on the sizes of these sets is simply by inspection of the conditions in Claim 4.14. Conditions (1-3) can obviously be checked in PTIME. The fact that condition (4) can be checked in PTIME is because we can test all possible assignments between 0 and 𝑑 for all these variables and see if there is one assignment that satisfies the equations; indeed, observe that the number of variables is fixed because the query is fixed.</p><p>□</p><p>But then, we can express the result as follows</p><formula xml:id="formula_34">∑︁ 0⩽𝑖 𝑅 ,𝑖 𝑆 ,𝑖 𝑅𝑆 ⩽𝑑 𝑑 -𝑐 𝑖 𝑅 𝑑 -𝑐 -𝑖 𝑅 𝑖 𝑆 𝑑 -𝑐 𝑅𝑆 -𝑖 𝑅 -𝑖 𝑆 𝑖 𝑅𝑆 × check(𝑖 𝑅 , 𝑖 𝑆 , 𝑖 𝑅𝑆 )</formula><p>and we can evaluate this expression as-is in FP because computing check(𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) ∈ {0, 1} is in PTIME by the last claim. This concludes this (long) example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">APPROXIMATING THE NUMBERS OF VALUATIONS AND COMPLETIONS</head><p>As we saw in the previous sections, counting valuations and completions of an incomplete database are usually intractable problems. However, this does not necessarily rule out the existence of efficient approximation algorithms for such counting problems, in particular if some source of randomization is allowed. In this section, we investigate this question by focusing on the well-known notion of Fully Polynomial-time Randomized Approximation Scheme (FPRAS) for counting problems <ref type="bibr" target="#b32">[33]</ref>. Formally, let Σ be a finite alphabet and 𝑓 : Σ * → N be a counting problem. Then 𝑓 is said to have an FPRAS if there is a randomized algorithm A : Σ * × (0, 1) → N and a polynomial 𝑝 (𝑢, 𝑣) such that, given 𝑥 ∈ Σ * and 𝜀 ∈ (0, 1), algorithm A runs in time 𝑝 (|𝑥 |, 1 /𝜀) and satisfies the following condition:</p><formula xml:id="formula_35">Pr |𝑓 (𝑥) -A (𝑥, 𝜀)| ⩽ 𝜀 𝑓 (𝑥) ⩾<label>3 4</label></formula><p>.</p><p>Observe that the property of having an FPRAS is closed under polynomial-time parsimonious reductions, that is, if we have an FPRAS for a counting problem 𝐴 and for counting problem 𝐵 we have that 𝐵 ⩽ p par 𝐴, then we also have an FPRAS for 𝐵.</p><p>The complexity of counting problems over incomplete databases 1:27</p><p>In the following sections, we investigate the existence of FPRAS for the problems of counting valuations and completions of an incomplete database. The overall picture that we obtain is shown in Table <ref type="table">2</ref>. We first deal with counting valuations in Section 5.1, where we show a general condition under which this problem has an FPRAS (which will apply, in particular, to all Boolean conjunctive queries). Then, in Section 5.2, we show that the situation is quite different for counting completions, as in most cases this problem does not admit an FPRAS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Approximating the number of valuations</head><p>To prove the main result of this section, we need to consider the counting complexity class SpanL <ref type="bibr" target="#b4">[5]</ref>. Given a finite alphabet Σ, an NL-transducer 𝑀 over Σ is a nondeterministic Turing Machine with input and output alphabet Σ, a read-only input tape, a write-only output tape (where the head is always moved to the right once a symbol in Σ is written on it, so that the output cannot be read by 𝑀), and a work-tape of which, on input 𝑥, only the first 𝑐 • log(|𝑥 |) cells can be used for a fixed constant 𝑐 &gt; 0 (so that the space used by 𝑀 is logarithmic). Moreover, 𝑦 ∈ Σ * is said to be an output of 𝑀 with input 𝑥, if there exists an accepting run of 𝑀 with input 𝑥 such that 𝑦 is the string in the output tape when 𝑀 halts. Then a function 𝑓 : Σ * → N is said to be in SpanL if there exists an NL-transducer 𝑀 over Σ such that for every 𝑥 ∈ Σ * , the value 𝑓 (𝑥) is equal to the number of distinct outputs of 𝑀 with input 𝑥. In <ref type="bibr" target="#b4">[5]</ref>, it was proved that SpanL ⊆ #P, and also that this inclusion is strict unless NL = NP.</p><p>Very recently, the authors of <ref type="bibr" target="#b9">[10]</ref> have shown that every problem in SpanL has an FPRAS. By using this result, we can give a general condition on a Boolean query 𝑞 under which #Val(𝑞) has an FPRAS, as this condition ensures that #Val(𝑞) is in SpanL. More precisely, a Boolean query 𝑞 is said to be monotone if for every pair of (complete) databases 𝐷, 𝐷 ′ such that 𝐷 ⊆ 𝐷 ′ , if 𝐷 |= 𝑞, then 𝐷 ′ |= 𝑞. Moreover, 𝑞 is said to have bounded minimal models if there exists a constant 𝐶 𝑞 (that depends only on 𝑞) satisfying that for every (complete) database 𝐷, if 𝐷 |= 𝑞, then there exists 𝐷 ′ ⊆ 𝐷 such that 𝐷 ′ |= 𝑞 and the number of facts in 𝐷 ′ is at most 𝐶 𝑞 . Finally, the model checking problem for 𝑞, denoted by MC(𝑞), is the problem of deciding, given a (complete) database 𝐷, whether 𝐷 |= 𝑞. Then 𝑞 is said to have a model checking in a complexity class C if MC(𝑞) ∈ C. With this terminology, we can state the main result of this section. Proposition 5.2. Assume that a Boolean query 𝑞 is monotone, has model checking in nondeterministic linear space, and has bounded minimal models. Then #Val(𝑞) is in SpanL.</p><p>Proof. Let 𝐷 be the input incomplete database, with the domains for each null. First, the machine guesses a subset 𝐷 ′ ⊆ 𝐷 of size ⩽ 𝐶 𝑞 , such that each fact of 𝐷 ′ is over a relation symbol that appears in 𝑞. Observe that 𝐷 ′ contains at most |𝐷 ′ | × arity(𝑞) ⩽ 𝐶 𝑞 × arity(𝑞) distinct nulls, and that this is a constant. The machine then guesses and remembers a valuation 𝜈 of 𝐷 ′ and computes 𝜈 (𝐷 ′ ). The encoding size ||𝜈 (𝐷 ′ )|| of 𝜈 (𝐷 ′ ) is 𝑂 (log |𝐷 |), so the machine can check in nondeterministic linear space whether 𝜈 (𝐷 ′ ) |= 𝑞, and stops and rejects in the branches that fail the test. Then, the machine reads the input tape left to right and for every occurrence of a null ⊥ (appearing in 𝐷) that it finds, it does the following:</p><p>• It checks whether ⊥ appears before on the input tape and if so it simply continues;</p><p>• Else if ⊥ does not appear before on the input tape but appears in 𝐷 ′ then the machine writes 𝜈 (⊥) on its output tape; • Else if ⊥ does not appear before on the input tape and does not appear in 𝐷 ′ then it guesses a value for it and writes that value on the output tape (but it does not remember that value).</p><p>It is easy to see that this procedure can be carried out by a logspace nondeterministic transducer, so we only need to show that the distinct outputs of the machine correspond exactly to the distinct valuations 𝜈 of 𝐷 such that 𝜈 (𝐷) |= 𝑞. Since the machine writes values for nulls in order of first appearance on the input tape, it is clear that every valuation is outputted exactly once. Let 𝜈 be a valuation that is outputted, and let 𝐷 ′ be the subdatabase such that 𝜈 (𝐷 ′ ) |= 𝑞. Since 𝜈 (𝐷 ′ ) ⊆ 𝜈 (𝐷) and 𝑞 is monotone, we have 𝜈 (𝐷) |= 𝑞. Inversely, let 𝜈 be a valuation of 𝐷 such that 𝜈 (𝐷) |= 𝑞, and let us show that it must be outputted. Since 𝜈 (𝐷) |= 𝑞 and 𝑞 has bounded minimal models, there exists 𝐷 𝜈 ⊆ 𝜈 (𝐷) of size ⩽ 𝐶 𝑞 such that 𝐷 𝜈 |= 𝑞. But 𝐷 𝜈 is 𝜈 (𝐷 ′ ) for some 𝐷 ′ ⊆ 𝐷 of size ⩽ 𝐶 𝑞 .</p><p>Then it is clear that one of the branches of the machine has guessed 𝐷 ′ and then 𝜈 |𝐷 ′ and then has written 𝜈 on the output tape. □</p><p>In particular, given that a union of Boolean of conjunctive queries satisfies the three properties of the previous proposition, we conclude from Theorem 5.1 that #Val(𝑞) can be efficiently approximated by using a randomized algorithm if 𝑞 is a union of BCQs. 9   Corollary 5.3. If 𝑞 is a union of BCQs, then #Val(𝑞) has an FPRAS (and the same holds if restricted to the uniform setting and/or to Codd tables).</p><p>We prove in the next section that the good properties stated in Proposition 5.2 do not hold for counting completions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Approximating the number of completions</head><p>In this section, we prove that the problem of counting completions of an incomplete database is much harder in terms of approximation than the problem of counting valuations. In this investigation, two randomized complexity classes play a fundamental role. Recall that RP is the class of decision problems 𝐿 for which there exists a polynomial-time probabilistic Turing Machine 𝑀 such that: (a) if 𝑥 ∈ 𝐿, then 𝑀 accepts with probability at least 3 /4; and (b) if 𝑥 ∉ 𝐿, then 𝑀 does not accept 𝑥. Moreover, BPP is defined exactly as RP but with condition (b) replaced by: (b') if 𝑥 ∉ 𝐿, then 𝑀 accepts with probability at most 1 /4. Thus, BPP is defined as RP but allowing errors for both the elements that are and are not in 𝐿. It is easy to see that RP ⊆ BPP. Besides, it is known that RP ⊆ NP, and this inclusion is widely believed to be strict. Finally, it is not known whether BPP ⊆ NP or NP ⊆ BPP, but it is widely believed that NP is not included in BPP.</p><p>The non-uniform case. Recall that #IS is the problem of counting the number of independent sets of a graph. This problem will play a fundamental role when showing non-approximability of counting completions in the non-uniform case. More precisely, the following is known about the approximability of #IS. In the proof of Proposition 4.2, we considered the problem #VC of counting the number of vertex covers of a graph 𝐺 = (𝑉 , 𝐸), and showed that #VC ⩽ p par #Comp Cd (𝑅(𝑥)). By observing that 𝑆 ⊆ 𝑉 is an independent set of 𝐺 if and only if 𝑉 \ 𝑆 is a vertex cover of 𝐺, we can conclude that #IS(𝐺) = #VC(𝐺) and, thus, the same reduction from the proof of Proposition 4.2 establishes that #IS ⩽ p par #Comp Cd (𝑅(𝑥)). Therefore, from the fact that the reduction in Lemma 4.1 is also parsimonious and preserves the property of being a Codd table, and the fact that the existence of an FPRAS is closed under polynomial-time parsimonious reductions, we obtain the following result from Theorem 5.4. 9 As a matter of fact, this holds even for the larger class of unions of BCQs with inequalities (that is, atoms of the form 𝑥 ≠ 𝑦), as such queries also satisfy the aforementioned three properties.</p><p>The complexity of counting problems over incomplete databases 1:29 Theorem 5.5 (Dichotomy). For every sjfBCQ 𝑞, it holds that #Comp Cd (𝑞) does not admit an FPRAS unless NP = RP (and, hence, the same holds for #Comp(𝑞)). <ref type="foot" target="#foot_9">10</ref>The uniform case. Recall that from Theorem 4.10, we know that if an sjfBCQ 𝑞 contains neither 𝑅(𝑥, 𝑥) nor 𝑅(𝑥, 𝑦) as a pattern, then #Comp u (𝑞) is in FP. Thus, the question to answer in this section is whether #Comp u (𝑞) and #Comp u Cd (𝑞) can be efficiently approximated if 𝑞 contains any of these two patterns. For the case of naive tables, we will give a negative answer to this question. Notice that, this time, our reduction from #IS in Proposition 4.5 is not parsimonious, so we cannot use Theorem 5.4 as we did for the non-uniform case. Instead, we will rely on the following wellknown fact: if there exists a BPP algorithm for a problem that is NP-complete, then NP ⊆ BPP, which in turn implies that NP = RP <ref type="bibr" target="#b33">[34]</ref>. Proposition 5.6. Neither #Comp u (𝑅(𝑥, 𝑥)) nor #Comp u (𝑅(𝑥, 𝑦)) admits an FPRAS unless NP RP. This holds even in the restricted setting in which all nulls are interpreted over the same fixed domain {1, 2, 3}.</p><p>Proof. Let 𝐺 = (𝑉 , 𝐸) be a graph. First, we explain how to construct an incomplete database 𝐷 containing a single binary relation 𝑅, with uniform domain {1, 2, 3}, and such that (a) all completions of 𝐷 satisfy both queries; (b) if 𝐺 is 3-colorable then 𝐷 has 8 completions; and (c) if 𝐺 is not 3colorable then 𝐷 has 7 completions. For every node 𝑢 ∈ 𝑉 we have a null ⊥ 𝑢 . The database 𝐷 consists of the following three disjoint sets of facts:</p><p>• For every edge {𝑢, 𝑣 } ∈ 𝐸, we have the two facts 𝑅(⊥ 𝑢 , ⊥ 𝑣 ) and 𝑅(⊥ 𝑣 , ⊥ 𝑢 ); we call these the coding facts. • We have the facts 𝑅(1, 2), 𝑅(2, 1), 𝑅(2, 3), 𝑅(3, 2), 𝑅(1, 3), and 𝑅(3, 1); we call these the triangle facts;</p><formula xml:id="formula_36">• We have six fresh nulls ⊥ 1 , ⊥ ′ 1 , ⊥ 2 , ⊥ ′ 2 , ⊥ 3 , ⊥ ′</formula><p>3 and the facts 𝑅(⊥ 𝑖 , ⊥ ′ 𝑖 ) and 𝑅(⊥ ′ 𝑖 , ⊥ 𝑖 ) for 1 ⩽ 𝑖 ⩽ 3; we call these the auxiliary facts;</p><p>• Last, we have a fact 𝑅(𝑐, 𝑐), where 𝑐 is a fresh constant.</p><p>It is clear that all the completions of 𝐷 satisfy both queries (thanks to the fact 𝑅(𝑐, 𝑐)), so we only need to prove (b) and (c). Observe that a candidate completion of 𝐷 can be equivalently seen as an undirected graph, possibly with self-loops, over the nodes {1, 2, 3} (we omit the fact 𝑅(𝑐, 𝑐) since it is in every completion) and that contains the triangle. Thanks to the auxiliary facts, it is easy to show that all such graphs with at least one self-loop can be obtained as a completion of 𝐷. For instance, the completion that is triangle with a self-loop only on 1 can be obtained by assigning 1 to all the nulls in the coding facts, assigning 1 to ⊥ 1 , ⊥ ′ 1 , ⊥ 2 and ⊥ 3 and assigning 2 to ⊥ ′ 2 and ⊥ ′ 3 . There are 7 such completions in total. Then, the completion whose graph is the triangle with no self-loops is obtainable if and only if 𝐺 is 3-colorable (we assign a 3-coloring to the nulls in the coding facts, and assign 1 to ⊥ 𝑖 and 2 to ⊥ ′ 𝑖 for every 𝑖 ∈ {1, 2, 3}). This indeed proves (b) and (c). Next, we show that any FRPAS with 𝜀 = 1 /16 for counting the number of completions of 𝐷 would yield a BPP algorithm to solve 3-colorability, thus implying NP = RP since 3-colorability is an NP-complete problem.</p><p>Let A be an FPRAS for #Comp u (𝑞), with 𝑞 being 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦), and let us define a BPP algorithm B for 3-colorability using A. On input graph 𝐺, algorithm B does the following. First, it computes in polynomial time the naive table 𝐷 as described above. Then B calls A with input (𝐷, 1 /16), and if A (𝐷, 1 /16) ⩾ 7.5, then B accepts, otherwise B rejects. We now prove that B is indeed a BPP algorithm for 3-colorability. Assume first that 𝐺 is 3-colorable. Then by (b) and by definition of what is an FPRAS, we have that Pr |8 -A (𝐷, It is clear that every node corresponding to a ground fact 𝑓 ∈ 𝑆 is incident to (exactly) one edge of 𝑀; let us denote that edge by 𝑒 𝑓 . Moreover, since 𝑀 is a matching, the mapping that associates to a ground fact 𝑓 ∈ 𝑆 the fact 𝑓 ′ 𝑓 at the other end of 𝑒 𝑓 is injective. Hence, we can define 𝜈 (⊥) of every null ⊥ occurring in such a fact 𝑓 ′ 𝑓 ∈ 𝐷 to be the unique constant such that 𝜈 (𝑓 ′ 𝑓 ) = 𝑓 holds, and for every other fact 𝑓 ′ in 𝐷 not incident to an edge in 𝑀, we chose a value for its nulls so that 𝜈 (𝑓 ′ ) ∈ 𝑆, which we can do thanks to (★). It is then clear that we have 𝜈 (𝐷) = 𝑆. But then, we can simply accept if 𝑚 = |𝑆 | and reject otherwise. □</p><p>We can now prove Proposition 6.1:</p><p>Proof of Proposition 6.1. We define a non-deterministic turing machine 𝑀 𝑞 such that, given as input an incomplete Codd table 𝐷, its number of accepting computation paths is exactly the number of completions of 𝐷 that satisfy 𝑞. First, compute in polynomial time the set 𝐴 def = 𝑓 ∈𝐷 𝑃 (𝑓 ), where 𝑃 (𝑓 ) is defined just as in Lemma 6.2. Then, the machine 𝑀 𝑞 guesses a subset 𝑆 of 𝐴. It then checks in polynomial time if 𝑆, when seen as a database, satisfies 𝑞, and rejects if it is not the case. Then, using Lemma 6.2, it checks in polynomial time whether there exists a valuation 𝜈 of 𝐷 such that 𝜈 (𝐷) = 𝑆, and accepts iff this is the case. It is then clear that 𝑀 𝑞 satisfies the conditions, which shows that #Comp Cd (𝑞) is in #P. □</p><p>In the next two sections, all upper bounds will be proved for the most general scenario of nonuniform naive tables, while all lower bounds will be proved for the most restricted scenario of uniform naive tables with a fixed domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Non-membership in #P of #Comp(𝑞)</head><p>We now want to show that #P is not the right complexity class for problems of the form #Comp(𝑞), over naive tables. One could try to show membership in #P of #Comp(𝑞) as we did in the proof of Proposition 6.1; that is, guess a set of ground facts, then check in polynomial time that it satisfies the query and that it is a possible completion of the incomplete database. However, this proof strategy does not work, as we show next that checking if a set of ground fact is a completion of an incomplete database is an NP-complete problem. Moreover, this holds already for a fixed schema containing only a binary relation and for a fixed set of ground facts. Proposition 6.3. The exist a set 𝑆 of ground facts over binary relation 𝑅 such that the following is NP-complete: given as input an incomplete database 𝐷 over 𝑅, decide if 𝑆 is a completion of 𝐷.</p><p>Proof. We reduce from 3-colorability. Given a graph 𝐺, we build the same incomplete database 𝐷 as in the proof of Proposition 5.6, and the (fixed) set of ground facts is the triangle, that is, 𝑆 = {𝑅(1, 2), 𝑅(2, 1), 𝑅(2, 3), 𝑅(3, 2), 𝑅(1, 3), 𝑅(3, 1)}. Then, as in that proof, we have that 𝑆 is a completion of 𝐷 if and only if 𝐺 is 3-colorable. □</p><p>This does not, however, constitute a proof that #Comp(𝑞) is not in #P (but it is a good hint). To prove that #Comp(𝑞) is unlikely to be in #P, we need to define the complexity class SPP introduced in <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b41">42]</ref>. Given a nondeterministic Turing Machine 𝑀 and a string 𝑥, let accept 𝑀 (𝑥) (resp., reject 𝑀 (𝑥)) be the number of accepting (resp., rejecting) runs of 𝑀 with input 𝑥, and let gap 𝑀 (𝑥) = accept 𝑀 (𝑥)reject 𝑀 (𝑥). Then a language 𝐿 is said to be in SPP <ref type="bibr" target="#b23">[24]</ref> if there exists a polynomial-time nondeterministic Turing Machine 𝑀 such that: (a) if 𝑥 ∈ 𝐿, then gap 𝑀 (𝑥) = 1; and (b) if 𝑥 ∉ 𝐿, then gap 𝑀 (𝑥) = 0. It is conjectured that NP ⊈ SPP as, for example, for every known polynomial-time nondeterministic Turing Machine 𝑀 accepting an NP-complete problem, the function gap 𝑀 is not bounded. In the following proposition, we show how this conjecture helps us to reach our second goal. Proposition 6.4. There exists an sjfBCQ 𝑞 such that #Comp u (𝑞) is not in #P unless NP ⊆ SPP.</p><p>The proof of this result relies on the proof of Theorem 6.6, in the next section (we presented the results in this order for narrative purposes). We will then defer its presentation until the proof of Theorem 6.6 is given.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">An appropriate counting complexity class for #Comp(𝑞): SpanP</head><p>To meet our third goal, we need to introduce one last counting complexity class. The class SpanP <ref type="bibr" target="#b34">[35]</ref> is defined exactly as the class SpanL introduced in Section 5.1, but considering polynomial-time nondeterministic Turing machines with output, instead of logarithmic-space nondeterministic Turing machines with output. It is straightforward to prove that #P ⊆ SpanP. Besides, it is known that #P = SpanP if and only if NP = UP <ref type="bibr" target="#b34">[35]</ref>. 11 Therefore, it is widely believed that #P is properly included in SpanP. The following easy observation can be seen as a first hint that SpanP is a good alternative to describe the complexity of counting completions. Observation 6.5. If 𝑞 is a Boolean query such that MC(𝑞) is in P, then #Comp(𝑞) is in SpanP.</p><p>Notice that this result applies to all sjfBCQs and, more generally, to all FO Boolean queries. In fact, this results applies to even more expressive query languages such as Datalog <ref type="bibr" target="#b0">[1]</ref>. More surprisingly, in the following theorem we show that #Comp u (𝑞) can be SpanP-complete for an FO query 𝑞 and, in fact, already for the negation of an sjfBCQ. Theorem 6.6. There exists an sjfBCQ 𝑞 such that #Comp u (¬𝑞) is SpanP-complete under polynomial-time parsimonious reductions.</p><p>To prove this result, we will use the problem of counting the number of satisfying assignments of a 3-CNF formula that are distinct in the first 𝑘 variables, that we denote by #k3SAT. Formally, the problem #k3SAT takes as input a 3-CNF formula 𝐹 on variables {𝑥 1 , . . . , 𝑥 𝑛 } and an integer 1 ⩽ 𝑘 ⩽ 𝑛, and outputs the number of assignments of the first 𝑘 variables that can be extended to a satisfying assignment of 𝐹 . This problem is shown to be SpanP-complete in <ref type="bibr" target="#b34">[35]</ref>: Proposition 6.7 ([35, Section 6]). #k3SAT is SpanP complete (under polynomial-time parsimonious reductions).</p><p>We are ready to prove Theorem 6.6.</p><p>Proof of Theorem 6.6. Notice that we only need to show hardness for a fixed sjfBCQ 𝑞. We reduce from #k3SAT to #Comp u (¬𝑞), for a fixed sjfBCQ 𝑞 to be defined. Let 𝐹 be a 3-CNF on variables {𝑥 1 , . . . , 𝑥 𝑛 }, and 1 ⩽ 𝑘 ⩽ 𝑛. We first explain how we build the incomplete database 𝐷, and we will define the sjfBCQ 𝑞 after. For every variable 𝑥 𝑖 , 1 ⩽ 𝑖 ⩽ 𝑛, we have a null ⊥ 𝑥 𝑖 , and the 11 Recall that UP is the class Unambiguous Polynomial-Time introduced in <ref type="bibr" target="#b48">[49]</ref>, and that 𝐿 ∈ UP if and only if there exists a polynomial-time nondeterministic Turing Machine 𝑀 such that if 𝑥 ∈ 𝐿, then accept 𝑀 (𝑥) = 1, and if 𝑥 ∉ 𝐿, then accept 𝑀 (𝑥) = 0.</p><p>(uniform) domain is {0, 1}. For (𝑎, 𝑏, 𝑐) ∈ {0, 1} 3 , we have a relation 𝐶 𝑎𝑏𝑐 of arity 3, and we fill it with every tuple of the form 𝐶 𝑎𝑏𝑐 (𝑎 ′ , 𝑏 ′ , 𝑐 ′ ) with (𝑎 ′ , 𝑏 ′ , 𝑐 ′ ) ∈ {0, 1} 3 such that 𝑎 = 𝑎 ′ ∨𝑏 = 𝑏 ′ ∨𝑐 = 𝑐 ′ holds; hence for every (𝑎, 𝑏, 𝑐) ∈ {0, 1} 3 there are exactly 7 facts of this form. For every clause 𝐾 = 𝑙 1 ∨𝑙 2 ∨𝑙 3 of 𝐹 with 𝑙 1 , 𝑙 2 , 𝑙 3 being literals over variables 𝑦 1 , 𝑦 2 , 𝑦 3 , letting (𝑎 1 , 𝑎 2 , 𝑎 3 ) ∈ {0, 1} 3 be the unique tuple such that 𝑎 𝑖 = 1 iff 𝑙 𝑖 is a positive literal, we add to 𝐶 𝑎 1 𝑎 2 𝑎 3 the fact 𝐶 𝑎 1 𝑎 2 𝑎 3 (⊥ 𝑦 1 , ⊥ 𝑦 2 , ⊥ 𝑦 3 ). Last, we have a binary relation 𝑆 that we fill with the tuples 𝑆 (𝑖, ⊥ 𝑥 𝑖 ) for 1 ⩽ 𝑖 ⩽ 𝑘. The sjfBCQ 𝑞 then simply says that there exists a tuple that appears in all the relations 𝐶 𝑎𝑏𝑐 :</p><formula xml:id="formula_37">𝑞 = ∃𝑥∃𝑦 𝑆 (𝑥, 𝑦) ∧ ∃𝑥∃𝑦∃𝑧 (𝑎,𝑏,𝑐) ∈ {0,1} 3 𝐶 𝑎𝑏𝑐 (𝑥, 𝑦, 𝑧)<label>(6)</label></formula><p>Note that we added the seemingly useless query ∃𝑥∃𝑦 𝑆 (𝑥, 𝑦) to 𝑞 because the set of relations in 𝐷 has to be a subset of the set of relations occurring in 𝑞 (indeed, this is how we defined our problems in Section 2). We now show that the number of completions of 𝐷 that do not satisfy 𝑞 is equal to the number of assignments of the first 𝑘 variables that can be extended to a satisfying assignment of 𝐹 , thus establishing that #Comp u (¬𝑞) is SpanP-hard (under polynomial-time parsimonious reductions). First, observe that the assignments of the variables are in bijection with the valuations of the nulls of 𝐷. One can then readily observe the following:</p><p>• If 𝑞 is falsified in a completion of 𝐷, it can only be because there does not exist a tuple that occurs in all the relations; this is because the query ∃𝑥∃𝑦 𝑆 (𝑥, 𝑦) is always satisfied by any completion of 𝐷. • For every assignment of the variables, letting 𝜈 be the corresponding valuation of the nulls, there exists a tuple that is in all relations 𝐶 𝑎𝑏𝑐 of 𝜈 (𝐷) if and only if that assignment is not satisfying for 𝐹 . Indeed, this happens if and only if there exists a relation 𝐶 𝑎𝑏𝑐 such that 𝜈 (𝐷) (𝐶 𝑎𝑏𝑐 ) contains exactly 8 facts. • For every two valuations 𝜈, 𝜈 ′ such that the corresponding assignments are not satisfying the formula, we have that 𝜈 (𝐷) ≠ 𝜈 ′ (𝐷) if and only if 𝜈 and 𝜈 ′ differ on the first 𝑘 variables. This is because, by the previous item, each relation 𝐶 𝑎𝑏𝑐 contains exactly the 7 ground tuples that we initially put in 𝐷.</p><p>By putting it all together, we obtain that the reduction works as expected. □</p><p>This theorem gives evidence that SpanP is the right class to describe the complexity of counting completions for FO queries (and even for queries with model checking in polynomial time). It is important to notice that SpanP-hardness is proved in Theorem 6.6 by considering parsimonious reductions. This is a delicate issue, because from the main result in <ref type="bibr" target="#b47">[48]</ref>, it is possible to conclude that every counting problem that is #P-hard (even under polynomial-time parsimonious reductions) is also SpanP-hard under polynomial-time Turing reductions, so a more restrictive notion of reduction has to be used when proving that a counting problem is SpanP-hard <ref type="bibr" target="#b34">[35]</ref>.</p><p>Before continuing, we prove Proposition 6.4.</p><p>Proof of Proposition 6.4. Let 𝑞 be the sjfBCQ defined in Equation ( <ref type="formula" target="#formula_37">6</ref>) in the proof of Theorem 6.6. Its schema 𝜎 = {𝑆 } ∪ {𝐶 𝑎𝑏𝑐 | (𝑎, 𝑏, 𝑐) ∈ {0, 1} 3 } consists of 10 relation symbols, with 𝑆 being binary and each 𝐶 𝑎𝑏𝑐 being ternary. Let us denote by #Comp u (𝜎) the problem that takes as input an incomplete database over schema 𝜎 and outputs its number of completions. The first part of our proof is to reduce #Comp u (𝜎) to #Comp u (𝑞); formally, we claim that #Comp u (𝜎) ⩽ p par #Comp u (𝑞). Indeed, let 𝐷 be an incomplete database over schema 𝜎, that is an input of #Comp u (𝜎). We construct in polynomial time an incomplete database 𝐷 ′ over the same schema such that #Comp u (𝜎) (𝐷) = #Comp u (𝑞) (𝐷 ′ ), thus establishing the parsimonious reduction.</p><p>Let 𝑓 be a fresh constant that does occurs neither in 𝐷 nor in the domain of some null. Then the relation 𝐷 ′ (𝑆) is the same as the relation 𝐷 (𝑆), plus a fact 𝑆 (𝑓 , 𝑓 ). Moreover, for every (𝑎, 𝑏, 𝑐) ∈ {0, 1} 3 , the relation 𝐷 ′ (𝐶 𝑎𝑏𝑐 ) consists of all the facts in 𝐷 (𝐶 𝑎𝑏𝑐 ), plus a fact 𝐶 𝑎𝑏𝑐 (𝑓 , 𝑓 , 𝑓 ). It is easy to see that 𝐷 and 𝐷 ′ have the same number of completions. Moreover, thanks to the facts that use the constant 𝑓 , we have that every completion of 𝐷 ′ satisfies 𝑞. Therefore, we indeed have that #Comp u (𝜎) (𝐷) = #Comp u (𝑞) (𝐷 ′ ). This proves that #Comp u (𝜎) ⩽ p par #Comp u (𝑞). For the second part of the proof, we need to introduce the complexity class GapP. This class consists of function problems that can be expressed as the difference of two functions in #P <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b28">29]</ref>. It is known that if the inclusion SpanP ⊆ GapP holds, then we have that NP ⊆ SPP <ref type="bibr" target="#b38">[39]</ref>. <ref type="foot" target="#foot_10">12</ref> With this, we are able to prove the proposition. Assume that #Comp u (𝑞) is in #P. Then, by the first part of the proof we have that #Comp u (𝜎) ∈ #P as well (because #P is closed under polynomial-time parsimonious reductions). Now, observe that for every incomplete database 𝐷 over 𝜎, the following holds:</p><formula xml:id="formula_38">#Comp u (¬𝑞) (𝐷) = #Comp u (𝜎) (𝐷) -#Comp u (𝑞) (𝐷).</formula><p>But then this means that #Comp u (¬𝑞) is in GapP (since both problems in the right hand side are in #P). Since #Comp u (¬𝑞) is SpanP-complete by Theorem 6.6 under polynomial-time parsimonious reductions, and since GapP is closed under polynomial-time parsimonious reductions, this would indeed imply that SpanP ⊆ GapP and, hence, that NP ⊆ SPP. □</p><p>We conclude this section by considering an even more general scenario where queries have model checking in NP. Interestingly, in this case SpanP is again the right class to describe the complexity not only of counting completions, but also of counting valuations. Theorem 6.8. If 𝑞 is a Boolean query with MC(𝑞) ∈ NP, then both #Val(𝑞) and #Comp(𝑞) are in SpanP. Moreover, there exists such a Boolean query 𝑞 for which #Val u (𝑞) is SpanP-complete under polynomial-time parsimonious reductions (and for #Comp u (𝑞), we can even take 𝑞 to be the negation of an sjfBCQ, hence with model checking in P, as given by Theorem 6.6).</p><p>Proof. It is straightforward to prove that these problems are in SpanP. The part in between parenthesis has been shown in theorem 6.6. Thus, we need to prove that #Val u (𝑞) is SpanP-hard for a fixed Boolean query 𝑞 such that MC(𝑞) ∈ NP, under polynomial-time parsimonious reductions. To do this, we will reduce from the SpanP-complete problem #HamSubgraphs, defined as follows.</p><p>Let 𝐺 = (𝑉 , 𝐸) be a undirected graph, and let 𝑆 ⊆ 𝑉 . The subgraph of 𝐺 induced by 𝑆, denoted by 𝐺 [𝑆], is the graph with set of nodes 𝑆 and set of edges {{𝑢, 𝑣 } ∈ 𝐸 | 𝑢, 𝑣 ∈ 𝑆 }, We recall that a graph 𝐺 is Hamiltonian when there exists a cycle in 𝐺 that visits every node of 𝐺 exactly once. The problem #HamSubgraphs takes as input a simple graph 𝐺 = (𝑉 , 𝐸) and an integer 𝑘, and outputs the number of induced subgraphs 𝐺 [𝑆] with |𝑆 | = 𝑘 such that 𝐺 [𝑆] is Hamiltonian. Proposition 6.9 ([35, Section 6]). #HamSubgraphs is SpanP-complete (under polynomial-time parsimonious reductions).</p><p>Next we show that #HamSubgraphs ⩽ p par #Val u (𝑞), for a fixed Boolean query 𝑞 (to be defined). Let 𝐺 = (𝑉 , 𝐸) be an undirected graph. We first explain how we construct the incomplete database 𝐷, and we will then define the query 𝑞. The schema contains two binary relation symbols 𝑅,𝑇 and one unary relation symbol 𝐾. Fix a linear order 𝑎 1 , . . . , 𝑎 𝑛 of the nodes of 𝐺. For every edge {𝑢, 𝑣 } ∈ 𝐸 we have the facts 𝑅(𝑢, 𝑣) and 𝑅(𝑣, 𝑢). For 1 ⩽ 𝑖 ⩽ 𝑛 we have a fact 𝑇 (𝑎 𝑖 , ⊥ 𝑖 ), and the domain of the nulls is {0, 1}. For 1 ⩽ 𝑗 ⩽ 𝑘 we have a fact 𝐾 ( 𝑗). Observe that 𝐷 is a Codd table. We now define the Boolean query 𝑞, which will be a sentence in existential second-order logic (∃SO) over relational signature 𝑅,𝑇 , 𝐾. Before doing so, we explain the main idea: intuitively, 𝑞 will check that there are exactly 𝑘 facts of the form 𝑇 (𝑎 𝑖 , 1) in the relation 𝑇 and that, letting 𝑆 be the set of nodes 𝑣 such that 𝑇 (𝑣, 1) is in relation 𝑇 , the induced subgraph 𝐺 [𝑆] is Hamiltonian. This will indeed ensure that we have #Val u (𝑞) (𝐷) = #HamSubgraphs(𝐺, 𝑘), thus completing this reduction, which is parsimonious and can be performed in polynomial-time. The query is</p><formula xml:id="formula_39">𝑞 = ∃𝑆 𝜓 1 (𝑆) ∧ 𝜓 2 (𝑆)</formula><p>where 𝑆 is a unary second order variable and the formula 𝜓 1 (𝑆) states that (a) the elements 𝑠 of 𝑆 are exactly all the elements such that 𝑇 (𝑠, 1) holds, and that (b) there are exactly the same number of elements in 𝑆 as there are elements 𝑗 for which 𝐾 ( 𝑗) holds. It is clear that (a) can be expressed in FO. Moreover, (b) can be expressed in ∃SO by asserting the existence of a binary second-order relation 𝑈 that represents a bijective function from 𝑆 to the elements in 𝐾. Then 𝜓 2 (𝑆) is a formula that asserts that 𝐺 [𝑆] is Hamiltonian. Since this is a property in NP, 𝜓 2 (𝑆) can be expressed in ∃SO by Fagin's theorem (see, e.g., <ref type="bibr" target="#b30">[31]</ref>). This shows that the reduction is correct. Finally, the fact that MC(𝑞) is in NP again follows from Fagin's theorem. This concludes the proof. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXTENSIONS TO QUERIES WITH CONSTANTS AND FREE VARIABLES</head><p>So far, we have only considered our counting problems for queries that are Boolean and that do not contain constants. In this section we explain how our framework can be adapted to queries with constants and with free variables. Specifically, we will explain how one can obtain dichotomies for self-join-free conjunctive queries with constants and free variables.</p><p>Before that, we have to formally define our counting problems for a query with free variables. Let 𝑞( x) be a query with free variables x. For a tuple of constants t of appropriate arity, we write 𝑞( t) the Boolean query obtained by substituting the variables x with the constants t. The problem #Val(𝑞( x)) then takes as input an incomplete database 𝐷 over relations sig(𝑞( x)), a tuple of constants t, and returns the number of valuations 𝜈 of 𝐷 such that 𝜈 (𝐷) |= 𝑞( t). We write this output #Val(𝑞( x)) (𝐷, t). The problem #Comp(𝑞( x)) is defined similarly.</p><p>We first explain in Section 7.1 how to obtain dichotomies for self-join-free conjunctive query with free variables and constants, assuming we have dichotomies for self-join-free Boolean conjunctive queries with constants. In section 7.2, we then explain how to obtain dichotomies for the later case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Dealing with free variables</head><p>Suppose in this section that we have a dichotomy between #P-hardness and FP of our counting problems, for every sjfBCQ that is allowed to contain constants. We then show how to obtain dichotomies, for every self-join-free CQ that is allowed to have constants and free variables. To this end, we will need the following definition. Let 𝑞( x) be a self-join-free CQ with free variables x, and let t and t ′ be two tuples of constants with appropriate arity. We say that t and t ′ are equivalent with respect to 𝑞( x) if one can go from 𝑞( t) to 𝑞( t ′ ) by iteratively renaming constants into fresh constants. For instance, if 𝑞(𝑥 1 , 𝑥 2 ) is ∃𝑦 𝑅(𝑦, 𝑐, 𝑥 1 , 𝑥 2 ) ∧ 𝑆 (𝑐 ′ , 𝑥), then (𝑐, 𝑐 ′′ ) is equivalent to (𝑐, 𝑐 ′′′ ), and (𝑐 ′′ , 𝑐 ′′′ ) and (𝑐 ′′′ , 𝑐 ′′ ) are also equivalent. It is clear that, if 𝑞( x) is fixed, this defines an equivalence relation that has only finitely many classes. Furthermore, it is also clear that if t and t ′ are equivalent with respect to 𝑞( x) then the problems #Val(𝑞( t)) and #Val(𝑞( t ′ )) (resp., #Comp(𝑞( t)) and #Comp(𝑞( t ′ ))) have the same complexity. We can now show what we wanted. In what follows, hardness refers to #P-hardness (but it is not important for the proof). Lemma 7.1. Assume that the following is true: for every sjfBCQ 𝑞 that is allowed to have constants, the problem #Val(𝑞) is either hard or is tractable. Then the following is also true: for every self-join-free conjunctive query 𝑞( x), the problem #Val(𝑞( x)) is either hard or is tractable. This holds also for counting completions, and when restricted to Codd tables and/or to the uniform setting.</p><p>Proof. We only deal with counting valuations for the naive and non-uniform case, as the other cases are similar. We prove the following for any self-join-free CQ 𝑞( x), which implies the claim: if there exists a tuple of constants t such that #Val(𝑞( t)) is hard, then #Val(𝑞( x)) is hard as well, otherwise #Val(𝑞( x)) is tractable. We start with the "if" direction. Let t be a tuple of constants such that #Val(𝑞( t)) is hard. By definition, it is clear that, for any incomplete database 𝐷, we have that #Val(𝑞( t)) (𝐷) = #Val(𝑞( x)) (𝐷, t); this shows hardness of #Val(𝑞( x)). Now for the "otherwise" direction. Let t1 , . . . , t 𝑘 be representatives of the finitely many equivalence classes of the equivalence relation defined above. We have access to oracles for #Val(𝑞( t1 )), . . . , #Val(𝑞( t 𝑘 )). Let 𝐷, t be an input of #Val(𝑞( x)). We then simply recognize (in constant time since the query if fixed) to which t𝑖 the tuple t is equivalent with respect to 𝑞( x), and call the appropriate oracle. □ (Notice that this idea actually works for conjunctive queries (with self-joins), or even unions of conjunctive queries.) Hence, the problem becomes that of obtaining dichotomies for self-join-free Boolean conjunctive queries that can contain constants. We explain in the next section how this can be done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Dealing with constants</head><p>In this section, we simply write "an sjfBCQ" to mean an sjfBCQ that can contain some constants. To the best of our knowledge, there is no general reduction that allows us to easily obtain dichotomies for the case with constants from the case where queries do not have constants. Hence, the strategy to obtain dichotomies will be the same as in Section 3; namely, we will again use the notion of pattern to find a set of hard patterns, and then show that when a query does not have any of the hard patterns then the problem is tractable. The notion of pattern for an sjfBCQ that can contain constants is the same as the one we used in Definition 3.1, but we simply add the possibility of deleting an occurrence of a constant. For instance the query 𝑅(𝑥, 𝑐) is a pattern of the query 𝑅(𝑥, 𝑥, 𝑐, 𝑐, 𝑐 ′ ) (in this section all variables are existentially quantified, since we consider only Boolean queries). The main property of patterns that we used then extends in this setting, as shown next. Lemma 7.2. Let 𝑞, 𝑞 ′ be sjfBCQs such that 𝑞 ′ is a pattern of 𝑞. Then we have #Val(𝑞 ′ ) ⩽ p par #Val(𝑞). Moreover, the same results hold if we restrict to Codd tables, and/or to the uniform setting, and/or to counting completions.</p><p>Proof. The reduction is exactly the same as that of Lemma 3.3, the only difference being that, when we delete an occurrence of a constant 𝑐, we simply fill the corresponding columns of every tuple with this constant. □ Next, we prove dichotomies for counting valuations for the non-uniform setting, for naive and Codd databases. For Codd databases, it turns out that there is no new hard pattern that involves constants, so the dichotomy is the same as for sjfBCQs without constants. Formally:</p><formula xml:id="formula_40">Theorem 7.3 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥) ∧ 𝑆 (𝑥) is a pattern of 𝑞, then #Val Cd (𝑞) is #P-complete. Otherwise, #Val Cd (𝑞) is in FP.</formula><p>Proof. The proof is exactly as the proof of Theorem 3.7, with the following modification: we let 𝜌 ( t𝑗 ) be the number of valuations of the nulls appearing in t𝑗 that do not match the corresponding atom of 𝑞; and clearly, this can again be computed in polynomial time. □</p><p>For naive tables however, we find two new hard patterns that involve constants, as shown next.</p><p>Proposition 7.4. Let 𝑐, 𝑐 ′ be two distinct constants. The problems #Val(𝑅(𝑐, 𝑐)) and #Val(𝑅(𝑐, 𝑐 ′ )) are both #P-hard.</p><p>Proof. We only explain for #Val(𝑅(𝑐, 𝑐 ′ )), as the other case is analogous. The reduction is similar to that used in Proposition 3.8, but we reduce from counting the number of independent sets in bipartite graphs (in Proposition 3.8 we did not need the graphs to be bipartite). Let 𝐺 = (𝑈 ⊔ 𝑉 , 𝐸) be a bipartite graph. We have one null ⊥ 𝑢 for every node 𝑢 ∈ 𝑈 with domain dom(⊥ 𝑢 ) = {0, 𝑐}, and one null ⊥ 𝑣 for every node 𝑢 ∈ 𝑉 with domain dom(⊥ 𝑣 ) = {0, 𝑐 ′ }. For every edge (𝑢, 𝑣) ∈ 𝐸 we have a fact 𝑅(⊥ 𝑢 , ⊥ 𝑣 ) in 𝐷. Then it is clear that the number of valuations of 𝐷 that do not contain 𝑅(𝑐, 𝑐 ′ ) is equal to the number of independent sets of 𝐺, thus establishing hardness. (Note that for 𝑅(𝑐, 𝑐), we do not need the graph to be bipartite for the reduction to work.) □</p><p>We then claim that these are the only additional patterns that are necessary to obtain a dichotomy for #Val(𝑞) for sjfBCQs with constants. Theorem 7.5 (dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥) ∧ 𝑆 (𝑥) or 𝑅(𝑐, 𝑐) or 𝑅(𝑐, 𝑐 ′ ) for 𝑐 ≠ 𝑐 ′ is a pattern of 𝑞, then #Val(𝑞) is #P-complete. Otherwise, #Val(𝑞) is in FP.</p><p>The #P-hardness part of the claim follows from Lemma 7.2 and Propositions 3.4 and 3.5 and 7.4. We now show the tractability claim. First, observe that not having any of these patterns means the following: every variable in 𝑞 has exactly one occurrence and every atom of 𝑞 contains at most one constant (but notice that the same constant can appear in multiple atoms). But then, because the database is Codd and because 𝑞 has no self-joins, by multiplying by the appropriate factor, the problem #Val(𝑞) reduces to the problem #Val(𝑞 ′ ) where 𝑞 ′ is an sjfBCQ of the form 𝑅 1 (𝑐 1 ) ∧ 𝑅 2 (𝑐 2 ) ∧ . . . ∧ 𝑅 𝑘 (𝑐 𝑘 ), where the constants 𝑐 1 , . . . 𝑐 𝑘 are not necessarily distinct. We give next an example proof that the problem is tractable for such a simple query.</p><p>Example 7.6. Let 𝑞 be the query 𝑅(𝑐) ∧ 𝑆 (𝑐 ′ ) with 𝑐 ≠ 𝑐 ′ , and 𝐷 be an incomplete naive database. We explain how to compute #Val(¬𝑞) (𝐷) (the number of valuations that do not satisfy the query) in FP. This is enough, since the total number of valuations can clearly be computed in FP. First of all, we can assume without loss of generality that 𝐷 does not contain ground atoms that already satisfy the query. Then, let 𝐵 𝑅𝑆 def = {⊥ 𝑅𝑆 1 , . . . , ⊥ 𝑅𝑆 𝑛 𝑅𝑆 } be the set of nulls that occur in both 𝐷 (𝑅) and 𝐷 (𝑆), 𝐵 𝑅 def = {⊥ 𝑅 1 , . . . , ⊥ 𝑅 𝑛 𝑅 } be the set of nulls that occur in 𝐷 (𝑅) but not in 𝐷 (𝑆), and 𝐵 𝑆 def = {⊥ 𝑆 1 , . . . , ⊥ 𝑆 𝑛 𝑆 } be the set of nulls that occur in 𝐷 (𝑆) but not in 𝐷 (𝑅). Let 𝐷 ′ be the database that contains only the facts 𝑅(⊥) and 𝑆 (⊥) for ⊥ ∈ 𝐵 𝑅𝑆 . Notice that the number of valuations of the nulls in 𝐵 𝑅 such that no null has value 𝑐 is 𝑛 𝑅 𝑖=1 |dom(⊥ 𝑅 𝑖 ) \ {𝑐}|, and that the number of valuations of the nulls in 𝐵 𝑅 such that some null has value 𝑐 is then 𝑛 𝑅 𝑖=1 |dom(⊥ 𝑅 𝑖 )| -𝑛 𝑅 𝑖=1 |dom(⊥ 𝑅 𝑖 ) \ {𝑐}|, and a similar expression can be obtained for the valuations of the nulls in 𝐵 𝑆 and constant 𝑐 ′ . Then, by case analysis of whether some null in 𝐵 𝑅 has value 𝑐 or not, and whether some null in 𝐵 𝑆 has value 𝑐 ′ or not, we obtain that #Val(¬𝑞) (𝐷) = 𝐴 + 𝐵 + 𝐶, where</p><formula xml:id="formula_41">𝐴 = 𝑛 𝑅 𝑖=1 |dom(⊥ 𝑅 𝑖 )| - 𝑛 𝑅 𝑖=1 |dom(⊥ 𝑅 𝑖 ) \ {𝑐}| × 𝑛 𝑆 𝑖=1 |dom⊥ 𝑆 𝑖 | \ {𝑐 ′ }| × 𝑛 𝑅𝑆 𝑖=1 |dom⊥ 𝑅𝑆 𝑖 \ {𝑐 ′ }|</formula><p>is the number of valuations of 𝐷 that do not satisfy 𝑞 and such that some null in 𝐵 𝑅 has value 𝑐,</p><formula xml:id="formula_42">𝐵 = 𝑛 𝑅 𝑖=1 |dom(⊥ 𝑅 𝑖 )| \ {𝑐}| × 𝑛 𝑆 𝑖=1 |dom(⊥ 𝑆 𝑖 )| - 𝑛 𝑆 𝑖=1 |dom(⊥ 𝑆 𝑖 ) \ {𝑐 ′ }| × 𝑛 𝑅𝑆 𝑖=1 |dom⊥ 𝑅𝑆 𝑖 \ {𝑐})</formula><p>is the number of valuations of 𝐷 that do not satisfy 𝑞 and such that no null in 𝐵 𝑅 has value 𝑐 and some null in 𝐵 𝑆 has value 𝑐 ′ , and</p><formula xml:id="formula_43">𝐶 = 𝑛 𝑅 𝑖=1 |dom(⊥ 𝑅 𝑖 ) \ {𝑐}| × 𝑛 𝑆 𝑖=1 |dom(⊥ 𝑆 𝑖 ) \ {𝑐 ′ }| × #Val(¬𝑞) (𝐷 ′ )</formula><p>is the number of valuations of 𝐷 that do not satisfy 𝑞 and such that no null in 𝐵 𝑅 has value 𝑐 and no null in 𝐵 𝑆 has value 𝑐 ′ . Hence, we only have to explain how to compute #Val(¬𝑞) (𝐷 ′ ) in polynomial time. For 𝑘 ∈ {0, . . . , 𝑛 𝑅𝑆 }, let 𝐷 ′ 𝑘 be the database containing only the facts of 𝐷 ′ over the nulls ⊥ 𝑅𝑆 1 , . . . , ⊥ 𝑅𝑆 𝑘 . We then define the quantities 𝑉 (𝑆, 𝑘), for 𝑆 ∈ {{𝑐}, {𝑐 ′ }, {𝑐, 𝑐 ′ }, ∅} and 𝑘 ∈ {0, . . . , 𝑛 𝑅𝑆 } to be the number of valuations of 𝐷 𝑘 that do not satisfy 𝑞 and such that no null has a value that is in 𝑆. Notice then that 𝑉 (∅, 𝑛 𝑅𝑆 ) = #Val(¬𝑞) (𝐷 ′ ). For an element 𝑎 and set 𝐴, we write [𝑎 ∈ 𝐴] to mean 1 if 𝑎 ∈ 𝐴 and 0 otherwise. But then we can easily compute the quantities 𝑉 (𝑆, 𝑘) by dynamic programming using the following relations: The proof for the general case is simply a tedious generalization of the proof for this example, and is not very interesting, so we omit it.</p><formula xml:id="formula_44">𝑉 (∅, 𝑘) =[𝑐 ∈ dom(⊥ 𝑅𝑆 𝑘 )] × 𝑉 ({𝑐}, 𝑘 -1) + [𝑐 ′ ∈ dom(⊥ 𝑅𝑆 𝑘 )] × 𝑉 ({𝑐 ′ }, 𝑘 -1) + |dom(⊥ 𝑅𝑆 𝑘 ) \ {𝑐, 𝑐 ′ }| × 𝑉 (∅, 𝑘<label>-1)</label></formula><p>Therefore, by combining Theorems 7.3 and 7.5 with Lemma 7.1, we obtain dichotomies for counting valuations of self-join-free conjunctive queries that can contain constants and free variable, for the non-uniform setting for both naive and Codd tables. It is likely that dichotomies can be obtained for counting valuations in the uniform setting by using the same methodology, but we do not pursue this further as our goal in this section is not to be exhaustive but rather to give the main ideas to be able to handle free variables and constants.</p><p>For counting completions, the reader can check that the pattern 𝑅(𝑐) is hard for #Comp Cd (so that in this case again all queries are hard), and that for #Comp u Cd , any query that contains an atom that is not unary is again hard (it is evident from the proof of Proposition 4.9). By combining these observations with Lemma 7.1 and with the tractability proof for #Comp u (which can be shown to extend in this case), we obtain four dichotomies for counting completions for self-join-free conjunctive queries that can contain constants and free variables.</p><p>Last, we point out that by using the same methodology, one also can extend our results on approximations to the case of queries containing constants and free variables (since the relevant reductions are parsimonious).</p><p>The complexity of counting problems over incomplete databases 1:39</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RELATED WORK</head><p>There are two main lines of work that must be compared to what we do in this article. In both cases the goal is to go beyond the traditional notion of certain answers that so far had been used almost exclusively to deal with query answering over uncertain data. We discuss them here, explain how they relate to our problems and what are the fundamental differences.</p><p>Best answers and 0-1 laws for incomplete databases. Libkin has recently introduced a framework that can be used to measure the certainty with which a Boolean query holds on an incomplete database, and also to compare query answers (for a non-Boolean query) <ref type="bibr" target="#b37">[38]</ref>. For a Boolean query 𝑞, incomplete database 𝐷, and integer 𝑘, he defines the quantity 𝜇 𝑘 (𝑞, 𝐷) as</p><formula xml:id="formula_45">|Supp 𝑘 (𝑞,𝐷) | |𝑉 𝑘 (𝐷) |</formula><p>, where 𝑉 𝑘 (𝐷) denotes the set of valuations of 𝐷 with domain {1, . . . , 𝑘 }, and Supp 𝑘 (𝑞, 𝐷) denotes the set of valuations 𝜈 ∈ 𝑉 𝑘 (𝐷) such that 𝜈 (𝐷) |= 𝑞; hence, 𝜇 𝑘 (𝑞, 𝐷) represents the relative frequency of valuations 𝜈 in {1, . . . , 𝑘 } for which the query is satisfied. He then shows that, for a very large class of queries (namely, generic queries), the value 𝜇 𝑘 (𝑞, 𝑑) always tends to 0 or 1 as 𝑘 tends to infinity (and the same results holds when considering completions instead of valuations). This means that, intuitively, over an infinite domain the query 𝑞 is either almost certainly true or almost certainly false.</p><p>He also studies the complexity of finding best answers for a non Boolean query 𝑞. As mentioned in the introduction, a tuple 𝑎 is a better answer than another tuple 𝑏 when for every valuation 𝜈 of 𝐷, if we have 𝑏 ∈ 𝑞(𝜈 (𝑑)) then we also have 𝑎 ∈ 𝑞(𝜈 (𝑑)). A best answer is then an answer such that there is no other answer strictly better than it (under inclusion of the sets of satisfying valuations). He studies the complexity of comparing answers under this semantics, and that of computing the set of best answers (see also <ref type="bibr" target="#b24">[25]</ref>).</p><p>There are several crucial differences between this previous work and ours. First, Libkin does not study the complexity of computing 𝜇 𝑘 (𝑞, 𝑑). We do this under the name #Val u (𝑞); moreover, we also study the setting in which the domains are not uniform. Second, knowing that a tuple is the best answer might not tell us anything about the size of its "support", i.e., the number of valuations that support it. In particular, a best answer is not necessarily an answer which has the biggest support. Finally, under the semantics of better answers it does not matter if we look at the completions or at the valuations (i.e., a tuple is a best answer with respect to inclusion of valuations iff it is the best answer with respect to completions); while we have shown that it does matter for counting problems.</p><p>Counting problems for probabilistic databases and consistent query answering. Remarkably, counting problems have received considerable attention in other database scenarios where uncertainty issues appear. As mentioned in the introduction, this includes the settings of probabilistic databases and inconsistent databases. In the former case, uncertainty is represented as a probability distribution on the possible states of the data <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b46">47]</ref>. There, query answering amounts to computing a weighted sum of the probabilities of the possible states of the data that satisfy a query 𝑞. We call this problem Prob(𝑞). In the case of inconsistent databases, we are given a set Σ of constraints and a database 𝐷 that does not necessarily satisfy Σ; cf. <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13]</ref>. Then the task is to reason about the set of all repairs of 𝐷 with respect to Σ <ref type="bibr" target="#b8">[9]</ref>. In our context, this means that one wants to count the number of repairs of 𝐷 with respect to Σ that satisfy a given query 𝑞. When 𝑞 and Σ are fixed, we call this problem #Repairs(𝑞, Σ).</p><p>Both Prob(𝑞) and #Repairs(𝑞, Σ) have been intensively studied already. To start with, counting complexity dichotomies have been obtained for the problem #Repairs(𝑞, Σ); e.g., <ref type="bibr" target="#b39">[40]</ref> gives a dichotomy for this problem when 𝑞 is an sjfBCQ and 𝜎 consists of primary keys, and <ref type="bibr" target="#b40">[41]</ref> extends this result to CQs with self-joins but only for unary keys constraints. We also mention <ref type="bibr" target="#b14">[15]</ref>, where the problem of counting repairs such that a particular input tuple is in the result of the query on the repair is studied. A seemingly close counting problem for probabilistic databases is the problem Prob(𝑞) over block independent disjoint (BIDs) databases. We do not define it formally here, but counting repairs under primary keys can be seen as a special case of this problem, where the tuples in a "block" all have the same probability, and where the sum of the probabilities sum to 1 (and in BIDs this sum is allowed to be &lt; 1, meaning that a block can be completely erased). Dichotomies for this problem have been obtained in <ref type="bibr" target="#b17">[18]</ref> for sjfBCQs. Counting complexity dichotomies for other models of probabilistic databases also exist; e.g., for tuple-independent probabilistic databases in which each fact is assigned an independent probability of being part of the actual dataset. Interestingly, dichotomies in this case hold for arbitrary unions of BCQs, and thus not just for sjfBCQs <ref type="bibr" target="#b18">[19]</ref>.</p><p>In some cases, one can use a problem of the form #Repairs(𝑞, Σ) (or Prob(𝑞)) to show the hardness of a problem of the form #Val(𝑞 ′ ). For instance, in Section 3.1 we used the #P-hardness of #Repairs(𝑅 ′ (y, 𝑥) ∧ 𝑆 ′ (z, 𝑥)) to prove that of #Val Cd (𝑅(𝑥) ∧ 𝑆 (𝑥)). In general however, the problems #Repairs(𝑞, Σ) and Prob(𝑞) seem to be unrelated to our problems, for the following reasons. First, in our setting the nulls can appear anywhere, so there is no notion of primary keys here; hence it seems unlikely that one can design a generic reduction from the problem of counting valuations/completions to the problem of counting repairs. In fact, it would perfectly make sense to study our counting problems where we add constraints such as functional dependencies. Second, in the BID and counting repairs problems, each "valuation" (repair) gives a different complete database, while in our case we have seen that this is not necessarily the case. In particular, problems of the form #Comp(𝑞) have no analogues in these settings, whereas we have seen that they behave very differently in our setting.</p><p>Concerning approximation results, it is known that the problems #Repairs(𝑞, Σ) and Prob(𝑞) admit an FPRAS in some important settings. In particular, when 𝑞 is a union of BCQs, this holds for #Repairs(𝑞, Σ) when Σ is a set of primary keys <ref type="bibr" target="#b14">[15]</ref>, and for Prob(𝑞) over BID and tuple-independent probabilistic databases <ref type="bibr" target="#b17">[18]</ref>. We observe here that this is reminescent of our Corollary 5.3, which shows that problems of the form #Val(𝑞) have an FPRAS for every union of BCQs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">FINAL REMARKS</head><p>Our work aims to be a first step in the study of counting problems over incomplete databases. The main conclusion behind our results is that the counting problems studied in this article are particularly hard from a computational point of view, especially when compared to more positive results obtained in other uncertainty scenarios; e.g., over probabilistic and inconsistent databases. As we have shown, a particularly difficult problem in our context is that of counting completions, even in the uniform setting where all nulls have the same domain. In fact, Proposition 4.9 shows that this problem is #P-hard even in very restricted scenarios, and Proposition 5.6 that it cannot be approximated by an FPRAS. It seems then that the only way in which one could try to tackle this problem is by developing suitable tractable heuristics, without provable quantitative guarantees, but that work sufficiently well in practical scenarios. An example of this could be developing algorithms that compute "under-approximations" for the number of completions of a naive table satisfying a certain sjfBCQ 𝑞. Notice that a related approach has been proposed by Console et al. for constructing under-approximations of the set of certain answers by applying methods based on many-valued logics <ref type="bibr" target="#b16">[17]</ref>.</p><p>We plan to continue working on several interesting problems that are left open in this article. First of all, we would like to pinpoint the complexity of #Comp(𝑞) when 𝑞 is an sjfBCQ; in particular, whether this problem is SpanP-complete for at least one such a query. We also want to study whether the non-existence of FPRAS for #Comp u (𝑞) established in Proposition 5.6 continues to hold over Codd tables. We would also like to develop a more thorough understanding of the role of fixed domains in our dichotomies. In several cases, that we have explicitly stated, our lower bounds hold even if nulls in tables are interpreted over a fixed domain. Still, in some cases we do not know whether this holds. These include, e.g., Proposition 3.11, Proposition 4.2, and Proposition 4.9. Finally, it would also be interesting to study these counting problems under bag semantics (instead of the set semantics used in this article), or consider arbitrary conjunctive queries as opposed to only self-join-free ones. the appropriate factor. Therefore, we can assume that 𝑆 is [𝑚]. We now need to fix some notation. Let us write the conjunction of basic singleton sjfBCQ 𝑞 as</p><formula xml:id="formula_46">𝑅 1 (𝑥 1 ) ∧ . . . ∧ 𝑅 𝑚 1 (𝑥 1 ) ∧ 𝑅 𝑚 1 +1 (𝑥 2 ) ∧ . . . ∧ 𝑅 𝑚 1 +𝑚 2 (𝑥 2 ) ∧ . . . ∧ 𝑅 𝑚-1 𝑖=1 𝑚 𝑖 (𝑥 𝑚 ) ∧ . . . ∧ 𝑅 𝑚 𝑖=1 𝑚 𝑖 (𝑥 𝑚 )</formula><p>and let 𝐾 be the number of atoms in 𝑞, that is, 𝐾 def = 𝑚 𝑖=1 𝑚 𝑖 . Let dom be the uniform domain of the nulls occurring in 𝐷 and 𝑑 its size. For s ⊆ [𝐾], we write 𝐶 s the set of constants that occur in each of the relations 𝐷 (𝑅 𝑖 ) for 𝑖 ∈ s but in none of the others, and write 𝑐 s the size of that set. We call such a set a block of constants. Similarly for the nulls, we write 𝑁 s the set of nulls that occur in each of the relations 𝐷 (𝑅 𝑖 ) for 𝑖 ∈ s but in none of the others (and we call this a block of nulls), and 𝑛 s for its size. We can assume wlog that: (a) For every 1 ⩽ 𝑖 ⩽ 𝑚, there is no constant that occurs in every 𝐷 (𝑅) for 𝑅 a relation name in 𝐶 𝑖 (𝑥 𝑖 ). Indeed otherwise any valuation would satisfy 𝐶 𝑖 (𝑥 𝑖 ), thus 𝑁 [𝑚] (𝐷) would simply be 0. (b) Every constant 𝑐 appearing in 𝐷 is in dom. Indeed otherwise, with the last item, this constant would have no chance to be part of a match, so we could simply remove it (i.e., remove all tuples of the form 𝑅(𝑐) from 𝐷).</p><p>For a subset 𝐴 ⊆ dom, let us write 𝐴 ∁ def = dom \ 𝐴. Finally, for a set 𝑍 = {𝐴 1 , . . . , 𝐴 𝑙 } of subsets of dom, we denote by I (𝑍 ) the set</p><formula xml:id="formula_47">I (𝑍 ) def = { 𝑙 𝑖=1 𝐵 𝑖 | (𝐵 1 , . . . , 𝐵 𝑙 ) ∈ {𝐴 1 , 𝐴 ∁ 1 } × . . . × {𝐴 𝑙 , 𝐴 ∁ 𝑙 }}</formula><p>We now explain informally how we can compute 𝑁 [𝑚] (𝐷). Let 𝐿 = s 1 , . . . , s 2 𝐾 be an arbitrary linear order of the set of subsets of [𝐾]. We will define by induction on 𝑖 ∈ [2 𝐾 ] an expression computing 𝑁 [𝑚] (𝐷), which will be a nested sum of the form • First, we need to ensure that each basic singleton query 𝐶 𝑖 (𝑥 𝑖 ) of 𝑞 will not be satisfied. In order to do that, sum s 𝑖 will actually sum over all the possible partitions (𝐵 ), where 𝑍 𝑖-1 contains all the blocks of constants and all the other 𝐵 𝑟 s j for 𝑗 &lt; 𝑖. We iteratively build that sum from the outside to the inside, starting with 𝑍 0 def = {dom} ∪ {𝐶 s | s ⊆ [𝐾]}. This will allow us to avoid summing over the 𝐵 𝑗 s i that would render a basic singleton query true. • Second, as is, such a sum is obviously not going to be computable in PTIME, as we are summing over subsets of dom. To fix this, observe that the value of the subsum for s 𝑖 actually only depends on the sizes of the sets in 𝑍 𝑖-1 . Hence, iterating from the outside to the inside, whenever sum s 𝑖 contains a sum of the form, say, 𝐵 𝑘 s i ⊆ 𝐵 𝑘 ′ s j for 𝑗 &lt; 𝑖, we can replace this with a sum over 0 ⩽ 𝑏 𝑘 s i ⩽ 𝑏 𝑘 ′ s j , and add to 𝑓 s 𝑖 a factor of</p><formula xml:id="formula_48">∑︁ sum s 1 𝑓 s 1 × ∑︁ sum s 2 𝑓 s 2 × . . . ( ∑︁ sum s 2 𝐾 𝑓 s 2 𝐾 ) . . .<label>(7</label></formula><formula xml:id="formula_49">𝑏 𝑘 ′ s j 𝑏 𝑘 s i</formula><p>. Now, because of how 𝑍 0 is defined, and because of how I works, all the initial numbers in the first sum are either |dom \ 𝐾 𝑖=1 𝐶 {𝑖 } | or one of the numbers 𝑐 s for s ⊆ <ref type="bibr">[𝐾]</ref>. These can all be computed in polynomial time.</p><p>Definition B.4. Let 𝐺 = (𝑉 , 𝐸) be a graph and I = {𝑆 ⊆ 𝐸 | 𝐺 [𝑆] is a pseudoforest}. Then one can check that (𝐸, I) is a matroid <ref type="bibr" target="#b55">[56]</ref>. This matroid is called the bicircular matroid of 𝐺, and is denoted by 𝐵(𝐺).</p><p>Notice then that the problem #PF is exactly the same as the problem of computing, given as input a graph 𝐺, the quantity T(𝐵(𝐺); 2, 1). We now explain the steps used in <ref type="bibr" target="#b25">[26]</ref> to prove that computing T(𝐵(𝐺); 2, 1) is #P-hard for graphs. The starting point of our explanation is that computing T(𝐵(𝐺); 1, 1) is #P-hard. Proposition B.5 <ref type="bibr" target="#b25">([26,</ref><ref type="bibr">Corollary 4.3]</ref>). The problem of computing, given a graph 𝐺, the quantity T(𝐵(𝐺); 1, 1) is #P-hard.</p><p>Second, let us define the following univariate polynomial: for a graph 𝐺, let 𝑃 𝐺 (𝑥) be 𝑃 𝐺 (𝑥) = T(𝐵(𝐺); 𝑥, 1).</p><p>Notice that this is indeed a polynomial and that its degree is at most |𝐸| (the degree is exactly |𝐸| iff 𝐺 is itself a pseudoforest). If we could compute efficiently the coefficients of 𝑃 𝐺 , then we could in particular compute the value 𝑃 𝐺 (1) = T(𝐵(𝐺); 1, 1), which is #P-hard by the previous proposition. We recall that to compute the coefficients of a polynomial of degree 𝑛, it is enough to know its value on 𝑛 + 1 distinct points; in fact, given these values in 𝑛 + 1 distinct points, it is possible to efficiently compute the coefficients of the polynomial by using standard interpolation techniques (for example, by using Lagrange polynomials).</p><p>We need one last definition.</p><p>Definition B.6. Let 𝐺 be a graph. For 𝑘 ∈ N, let s 𝑘 (𝐺) be the graph obtained from 𝐺 by replacing each edge of 𝐺 by a path of lenght 𝑘; this graph is called the 𝑘-stretch of 𝐺.</p><p>Then, using a result attributed to Brylawski (see <ref type="bibr" target="#b31">[32]</ref>), the authors of <ref type="bibr" target="#b25">[26]</ref> obtain that, "up to a trivial factor", we have T(𝐵(s 𝑘 (𝐺)); 2, 1) ≃ T(𝐵(𝐺); 2 𝑘 , 1).</p><p>A careful inspection of <ref type="bibr" target="#b31">[32]</ref> reveals 13 that, in fact, we have T(𝐵(s 𝑘 (𝐺)); 2, 1) = (2 𝑘 -1) |𝐸 |-rk 𝐵 (𝐺 ) (𝐸) × T(𝐵(𝐺); 2 𝑘 , 1).</p><p>Notice that rk 𝐵 (𝐺) (𝐸) is the size (number of edges) of a pseudoforest of 𝐺 that is maximal by inclusion of edges, which we can compute in polynomial time. 14  With this, the authors of <ref type="bibr" target="#b25">[26]</ref> can conclude the proof that computing T(𝐵(𝐺); 2, 1) is hard for (non-necessarily bipartite) graphs, i.e., that #PF is #P-hard. Indeed, given as input 𝐺 = (𝑉 , 𝐸), we can construct in polynomial time the graphs s 𝑘 (𝐺) for |𝐸| + 1 distinct values of 𝑘, then use oracle calls to obtain the numbers T(𝐵(s 𝑘 (𝐺)); 2, 1), which gives us the value of 𝑃 𝐺 on |𝐸| + 1 distinct points. With that we can recover the coefficients of 𝑃 𝐺 and compute 𝑃 𝐺 (1) = T(𝐵(𝐺); 1, 1) as argued above, thus proving hardness for general graphs. To obtain hardness for bipartite graphs, it is enough to observe that when 𝑘 is even then the 𝑘-stretch of 𝐺 is bipartite (even if 𝐺 is not bipartite). Hence, to obtain a proof of Proposition 4.7 for bipartite graphs, we can simply change that proof and specify that we make |𝐸| + 1 calls to the oracle T(𝐵(s 𝑘 (𝐺)); 2, 1) for |𝐸| + 1 disctinct even values of 𝑘. 13 To be precise, we use Equations (7.1) and (7.2) of <ref type="bibr" target="#b31">[32]</ref> with 𝑥 = 1, 𝑦 = 0, and Equation (2.2) with 𝑥 = 2, 𝑦 = 1. 14 This is because, since 𝐵 (𝐺) is a matroid, any two such pseudoforests have the same number of edges. We can then simply start from the empty subgraph and iteratively add edges until it is not possible to add an edge such that the resulting graph is a pseudoforest. This also relies on the fact that we can check in polynomial time whether a graph is a pseudoforest. Let 𝑞 be an sjfBCQ not containing any of these two patterns. Then, as observed in Section 4.2, 𝑞 is a conjunction of basic singletons query. Let 𝜎 = {𝑅 1 , . . . , 𝑅 𝑙 } be the set of relation symbols of 𝑞, and 𝐷 be an incomplete database over these relations, with dom the uniform domain of the nulls and 𝑑 its size. For every s ⊆ 𝜎, s ≠ ∅, let:</p><p>• 𝐶 s be the set of constants that occur in all relations of s and in none of the others; 𝑐 s be its size; • 𝑁 s be the set of nulls that occur in all relations of s and in none of the others; 𝑛 s be its size.</p><p>We also define 𝑐 as ∅≠s⊆𝜎 𝑐 s . We can assume wlog that 𝐶 s ⊆ dom for all ∅ ≠ s ⊆ 𝜎, otherwise we can simply remove from 𝐷 the corresponding facts. Let 𝐿 def = 2 𝑙 -1, and let s 1 , . . . , s 𝐿 be an arbitrary linear order of {s ⊆ 𝜎 | s ≠ ∅} (for instance, by non-decreasing size). We will follow the same steps as in the example of Section 4.3. The following lemma is the generalization of Claim 4.12, and explains how we can guide the computation so that we do not count the same completion twice: Lemma B.7. For a tuple (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) of subsets of dom satisfying (★) Proof. Let us write 𝑃 = 𝑃 (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) and 𝑃 ′ = 𝑃 (𝐼 ′ s 1 , . . . , 𝐼 ′ s 𝐿 ). Assume that 𝑃 = 𝑃 ′ , and let us show that (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) = (𝐼 ′ s 1 , . . . , 𝐼 ′ s 𝐿 ). Assume by way of contradiction that for some ∅ ≠ s ⊆ 𝜎 we have 𝐼 s ≠ 𝐼 ′ s . Then (wlog) there exists 𝑎 ∈ 𝐼 s \ 𝐼 ′ s . By the definition of 𝑃, we have that 𝑃 contains all the facts 𝑅(𝑎) for 𝑅 ∈ s. Let us show that 𝑃 does not contain any fact 𝑅(𝑎) for 𝑅 ∉ s. Otherwise, assume that 𝑃 contains 𝑅(𝑎) with 𝑅 ∉ s. Then there exists s ′ ⊆ 𝜎 such that 𝑅 ∈ s ′ and such that 𝑎 ∈ 𝐼 s ′ ∪ (𝐶 s ′ \ s ′ ⊋s ′′ 𝐼 s ′′ ). Since s does not contain 𝑅 while s ′ does, we have s ′ ⊈ s. But then by (★) we have that 𝐼 s and 𝐼 s ′ ∪ 𝐶 s ′ are disjoint, which is a contradiction because 𝑎 is supposed to be in both 𝐼 s and 𝐼 s ′ ∪ (𝐶 s ′ \ s ′ ⊋s ′′ 𝐼 s ′′ ). Therefore, it is indeed the case that 𝑃 does not contain any fact 𝑅(𝑎) for 𝑅 ∉ s. Now, if 𝑃 ′ contains a fact 𝑅(𝑎) for some 𝑅 ∉ 𝜎 then we are done since this would imply 𝑃 ≠ 𝑃 ′ , a contradiction. Hence we can assume that 𝑃 ′ does not contain any fact 𝑅(𝑎) for 𝑅 ∉ 𝜎. We will now prove that 𝑃 ′ does not contain all the facts 𝑅(𝑎) for 𝑅 ∈ 𝜎, thus establishing a contradiction (because 𝑃 does, so we would have 𝑃 ≠ 𝑃 ′ ) and concluding this proof. Assume by contradiction that 𝑃 ′ contains all the facts 𝑅(𝑎) for 𝑅 ∈ s. First of all, observe that we have 𝑎 ∉ 𝐶 s because by (★) we have that 𝐼 s and 𝐶 s are disjoint, and we know that 𝑎 ∈ 𝐼 s . Hence, the only way in which 𝑃 ′ could contain all the facts 𝑅(𝑎) for 𝑅 ∈ s is if there exist s ′ 1 , . </p><formula xml:id="formula_50">𝐼</formula><p>We give here the necessary and sufficient conditions for 𝑃 (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) to be a completion of 𝐷 that satisfies 𝑞. Lemma B.9. We have check(𝐼 s 1 , . . . , 𝐼 s 𝐿 ) = 1 if and only if the following conditions hold: (1) for every basic singleton query 𝐶 𝑖 (𝑥) of 𝑞, letting s be its sets of relation symbols, there exists s ⊆ s ′ ⊆ 𝜎 such that we have |𝐼 s ′ | ⩾ 1 or 𝑐 s ′ ⩾ 1.</p><p>(2) for every ∅ ≠ s ⊆ 𝜎, if 𝑛 s ⩾ 1 and | s ′ ⊇s 𝐶 s ′ ∪ s ′ ⊋s 𝐼 s ′ | = 0 then |𝐼 s | ≠ 0.</p><p>(3) consider the following system of equations, with integer variables between 0 and 𝑑:</p><p>• for every two sets 𝐴, 𝐴 ′ of subsets of {∅ ≠ s ⊆ 𝜎 }, we have a variable 𝑧 𝐴,𝐴 ′ 𝑁 s for every s ∈ 𝐴 and a variable 𝑧 𝐴,𝐴 ′ 𝐶 s for every s ∈ 𝐴 ′ . For instance if 𝜎 = {𝑅, 𝑆,𝑇 , 𝑈 } and if 𝐴 = {{𝑅, 𝑆 }, {𝑆,𝑇 }} and 𝐴 ′ = {{𝑈 }} we have the variables 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } } 𝑁 {𝑅,𝑆 } and 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } } 𝑁 {𝑆,𝑇 } and 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } } 𝐶 {𝑈 } .</p><p>The intuition is that we will use 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } } 𝑁 {𝑅,𝑆 } of the nulls in 𝑁 {𝑅,𝑆 } and combine them with 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } } 𝑁 {𝑆,𝑇 } of the nulls in 𝑁 {𝑆,𝑇 } and with 𝑧 { {𝑅,𝑆 },{𝑆,𝑇 } },{ {𝑈 } } 𝐶 {𝑈 } of the constants in 𝐶 {𝑈 } in order to obtain constants in 𝐼 {𝑅,𝑆,𝑇 ,𝑈 } . Let us write 𝑉 this set of variables. (we note here that we are using sligthly different notation than for the example in Section 4.3; this is for readability reasons only.) intuitively meaning that we have allocated the groups of nulls and constants in a way that allows us to fill the set 𝐼 s . Then this system of equations must have a solution.</p><p>Proof. The idea is the same as in Claim 4.14. The only difference is that we added condition (1), which ensures that the guessed completion indeed satisfies the query. □</p><p>As in the example of Section 4.3, this implies that the value of check(𝐼 s 1 , . . . , 𝐼 s 𝐿 ) only depends on (|𝐼 s 1 |, . . . , |𝐼 s 𝐿 |) and can be computed in FP (by testing all assignments of the 𝑧 * * variables; because the schema is fixed so there are only a fixed number of such variables). But then we can compute the result in FP by evaluating the expression 9, which finishes the proof.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. The six valuations of the (non-uniform) incomplete database 𝐷 = (𝑇 , dom) with 𝑇 = {𝑆 (𝑎, 𝑏), 𝑆 (⊥ 1 , 𝑎), 𝑆 (𝑎, ⊥ 2 )} from Example 2.2, and their corresponding completions. The Boolean conjunctive query 𝑞 is ∃𝑥 𝑆 (𝑥, 𝑥).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Proposition 4 . 5 .</head><label>45</label><figDesc>The problems #Comp u (𝑅(𝑥, 𝑥)) and #Comp u (𝑅(𝑥, 𝑦)) are both #P-hard, even when nulls are interpreted over the same fixed domain {0, 1}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 4 . 11 ( 4 . 3</head><label>41143</label><figDesc>Dichotomy). Let 𝑞 be an sjfBCQ.If 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) is a pattern of 𝑞, then #Comp u Cd (𝑞) is #P-complete.Otherwise, this problem is in FP. Proof. Hardness follows from Theorem 4.10, while membership in #P follows from the result proven in Section 6.1.□ Example of tractability for Theorem 4.10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Claim 4 . 15 .</head><label>415</label><figDesc>The value of check(𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) only depends on |𝐼 𝑅 |, |𝐼 𝑆 |, |𝐼 𝑅𝑆 |, 𝑛 𝑅 , 𝑛 𝑆 , 𝑛 𝑅𝑆 , 𝑐 𝑅 , 𝑐 𝑆 , 𝑐 𝑅𝑆 , and can be computed in FP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Theorem 5 . 1 ([ 10 ,</head><label>5110</label><figDesc>Corollary 3]). Every problem in SpanL has an FPRAS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Theorem 5 . 4 ([ 20 ,</head><label>5420</label><figDesc>Theorem 3.1]). The problem #IS does not admit an FPRAS unless NP = RP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>and𝑉 ({𝑐, 𝑐 ′ }, 𝑘) = |dom(⊥ 𝑅𝑆 𝑘 ) \ {𝑐, 𝑐 ′ }| × 𝑉 ({𝑐, 𝑐 ′ }, 𝑘 -1) and 𝑉 ({𝑐}, 𝑘) =[𝑐 ′ ∈ dom(⊥ 𝑅𝑆 𝑘 )] × 𝑉 ({𝑐, 𝑐 ′ }, 𝑘 -1) + |dom(⊥ 𝑅𝑆 𝑘 ) \ {𝑐, 𝑐 ′ }| × 𝑉 ({𝑐, 𝑐 ′ }, 𝑘-1)and a similar relation for 𝑉 ({𝑐 ′ }, 𝑘). □</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>The complexity of counting problems over incomplete databases 1 : 49 B. 2</head><label>1492</label><figDesc>Proof of Theorem 4.10In this section we prove the tractability part of the following: Theorem 4.10 (Dichotomy). Let 𝑞 be an sjfBCQ. If 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) is a pattern of 𝑞, then #Comp u (𝑞) and #Comp u Cd (𝑞) are #P-hard. Otherwise, these problems are in FP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>𝐺 = (𝑋 ⊔ 𝑌 , 𝐸) be a bipartite graph. Without loss of generality, we can assume that |𝑋 | = |𝑌 | = 𝑛; indeed, if |𝑋 | &lt; |𝑌 | then we could simply add |𝑌 | -|𝑋 | isolated nodes to complete the graph, which simply multiplies the number of independent sets by 2 |𝑌 |-|𝑋 | . Also, observe that counting the number of independent sets of 𝐺 is the same as counting the number of pairs (𝑆 1 , 𝑆 2</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>where t 1 . . . t J are all the free types of 𝑅, t ′ 1 . . . t ′ K are all the free types of 𝑆, 𝑄 𝑅,t i is the set of the first 𝑞 𝑅,t i free 𝑅-facts of type t i , and where, letting 𝑧</figDesc><table /><note><p>def = 𝐽 𝑖=1 |𝑊 𝑅,t i | and 𝑧 ′ def = 𝐾 𝑖=1 |𝑊 𝑆,t ′ i |, we have</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>as otherwise we could simply remove the facts of 𝐷 that are over constants How the sets dom, 𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 , 𝐶 𝑅𝑆 , 𝐶 𝑅 and 𝐶 𝑆 from Claim 4.12 are allowed to intersect when they satisfy (★). The sets themselves and the intersections can be empty.</figDesc><table><row><cell>dom</cell><cell></cell></row><row><cell>𝐶 𝑅𝑆</cell><cell></cell></row><row><cell>𝐼 𝑅𝑆</cell><cell></cell></row><row><cell>𝐶 𝑅</cell><cell>𝐶 𝑆</cell></row><row><cell>𝐼 𝑅</cell><cell>𝐼 𝑆</cell></row><row><cell>Fig. 2.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>how the sets can intersect. If we have 𝐼 𝑅𝑆 ≠ 𝐼 ′ 𝑅𝑆 ) does not. So let us assume now that 𝐼 𝑅𝑆 = 𝐼 ′ 𝑅𝑆 . If we have 𝐼 𝑅 ≠ 𝐼 ′ 𝑅 with 𝑎 ∈ 𝐼 𝑅 and 𝑎 ∉ 𝐼 ′ 𝑅 then one can check that 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) contains the fact 𝑅(𝑎) while 𝑃 (𝐼 ′ 𝑅 , 𝐼 ′ 𝑆 , 𝐼 ′ 𝑅𝑆 ) does not. Hence let us assume that 𝐼 𝑅 = 𝐼 ′ 𝑅 . Using the same reasoning we obtain that 𝐼 𝑆 = 𝐼 ′ 𝑆 , thus completing the proof. □ Our next step is to show that every completion of 𝐷 is of the form 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) for some triplet (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) satisfying (★): Claim 4.13. For every completion 𝐷 ′ of 𝐷, there exist a triplet (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) satisfying (★) such that 𝐷 ′ = 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ).</figDesc><table><row><cell>Proof. We define:</cell></row><row><cell>• 𝐼 𝑅</cell></row></table><note><p>𝑅𝑆 with 𝑎 ∈ 𝐼 𝑅𝑆 and 𝑎 ∉ 𝐼 ′ 𝑅𝑆 , then 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) contains both facts 𝑅(𝑎) and 𝑆 (𝑎), while 𝑃 (𝐼 ′ 𝑅 , 𝐼 ′ 𝑆 , 𝐼 ′ def = 𝐷 ′ (𝑅) \ (𝐶 𝑅 ∪ 𝐷 ′ (𝑆)); where we see 𝐷 ′ (𝑅) as the set of constants occurring in relation 𝑅 of 𝐷 ′ . • 𝐼 𝑆 def</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>𝑅 ⊆dom\𝐶 ∑︁ 𝐼 𝑆 ⊆dom\(𝐶∪𝐼 𝑅 ) ∑︁ 𝐼 𝑅𝑆 ⊆dom\(𝐶 𝑅𝑆 ∪𝐼 𝑅 ∪𝐼 𝑆 ) check(𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) where check(𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) is a possible completion of 𝐷 0 otherwise . Next, we show that the value of check(𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) can be computed in polynomial time and actually only depends on the sizes of these sets. In order to show this, we will use the following: Claim 4.14. We have check(𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) = 1 if and only if the following conditions hold: (1) if 𝑛 𝑅 ⩾ 1 and |𝐶 𝑅 ∪ 𝐶 𝑅𝑆 ∪ 𝐼 𝑅𝑆 | = 0, then we have |𝐼 𝑅 | ≠ 0. Intuitively, this means that the value of a null in 𝑁 𝑅 cannot be "absorbed" by 𝐶 𝑅 ∪ 𝐶 𝑅𝑆 ∪ 𝐼 𝑅𝑆 . (2) if 𝑛 𝑆 ⩾ 1 and |𝐶 𝑆 ∪ 𝐶 𝑅𝑆 ∪ 𝐼 𝑅𝑆 | = 0, then we have |𝐼 𝑆 | ≠ 0. (Same reasonning for nulls in 𝑁 𝑆 .) (3) if 𝑛 𝑅𝑆 ⩾ 1 and |𝐶 𝑅𝑆 | = 0, then we have |𝐼 𝑅𝑆 | ≠ 0. (Same reasonning for nulls in 𝑁 𝑅𝑆 .) (4) the following system of equations, whose variables are natural numbers between 0 and 𝑑, has a solution:</figDesc><table /><note><p><p>def = 1 if 𝑃 (𝐼 𝑧 {𝑁 𝑅 } 𝑁 𝑅 + 𝑧 {𝑁 𝑅 ,𝐶 𝑆 } 𝑁 𝑅 + 𝑧 {𝑁 𝑅 ,𝑁 𝑆 } 𝑁 𝑅 ⩽ 𝑛 𝑅 𝑧 {𝑁 𝑆 } 𝑁 𝑆 + 𝑧 {𝑁 𝑆 ,𝐶 𝑅 } 𝑁 𝑆 + 𝑧 {𝑁 𝑆 ,𝑁 𝑅 } 𝑁 𝑆 ⩽ 𝑛 𝑅 𝑧 {𝐶 𝑅 ,𝑁 𝑆 } 𝐶 𝑅 ⩽ 𝑐 𝑅 𝑧 {𝐶 𝑆 ,𝑁 𝑅 } 𝐶 𝑆 ⩽ 𝑐 𝑆 𝑧 {𝑁 𝑅 } 𝑁 𝑅 ⩾ |𝐼 𝑅 | 𝑧 {𝑁 𝑆 } 𝑁 𝑆 ⩾ |𝐼 𝑆 | 𝑛 𝑅𝑆 + min(𝑧</p>{𝑁 𝑅 ,𝐶 𝑆 } 𝑁 𝑅 , 𝑧 {𝐶 𝑆 ,𝑁 𝑅 } 𝐶 𝑆 ) + min(𝑧 {𝑁 𝑅 ,𝑁 𝑆 } 𝑁 𝑅 , 𝑧 {𝑁 𝑆 ,𝑁 𝑅 } 𝑁 𝑆 ) + min(𝑧 {𝑁 𝑆 ,𝐶 𝑅 } 𝑁 𝑆 , 𝑧 {𝐶 𝑅 ,𝑁 𝑆 } 𝐶 𝑅 ) ⩾ |𝐼 𝑅𝑆 |</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>• the nulls in 𝑁 𝑅 together with those in 𝑁 𝑆 ; or • the nulls in 𝑁 𝑅 together with the constants in 𝐶 𝑆 ; or • the nulls in 𝑁 𝑆 together with the constants in 𝐶 𝑅 . But then, to obtain 𝑃 (𝐼 𝑅 , 𝐼 𝑆 , 𝐼 𝑅𝑆 ) as a completion, we must have used three disjoint (possibly empty) sets 𝑍 {𝑁 𝑅 } 𝑁 𝑅 , 𝑍 {𝑁 𝑅 ,𝐶 𝑆 } 𝑁 𝑅 , 𝑍 {𝑁 𝑅 ,𝑁 𝑆 } 𝑁 𝑅 of the nulls in 𝑁 𝑅 of sizes 0 ⩽ 𝑧 {𝑁 𝑅 } 𝑁 𝑅 , 𝑧 {𝑁 𝑅 ,𝐶 𝑆 }</figDesc><table><row><cell></cell><cell>, 𝑧 {𝑁 𝑅 ,𝑁 𝑆 }</cell></row><row><cell>𝑁 𝑅</cell><cell>𝑁 𝑅</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>• the nulls in 𝑍 {𝑁 𝑅 ,𝐶 𝑆 } 𝑁 𝑅 have values in 𝑍 {𝐶 𝑆 ,𝑁 𝑅 } 𝐶 𝑆 , which gives us constants in 𝐼 𝑅𝑆 . Observe that at maximum we could obtain min(𝑧 {𝑁 𝑅 ,𝐶 𝑆 } 𝑁 𝑅 , 𝑧 {𝐶 𝑆 ,𝑁 𝑅 } • the nulls in 𝑍 {𝑁 𝑅 ,𝑁 𝑆 } 𝑁 𝑅 and those in 𝑍 {𝑁 𝑅 ,𝑁 𝑆 } 𝑁 𝑅 have common values, which gives us constants in 𝐼 𝑅𝑆 . Again, observe that we can get at most min(𝑧 {𝑁 𝑅 ,𝑁 𝑆 } 𝑁 𝑅 , 𝑧 {𝑁 𝑆 ,𝑁 𝑅 } • the nulls in 𝑍 {𝑁 𝑆 ,𝐶 𝑅 } 𝑁 𝑆 have values in 𝑍 {𝐶 𝑅 ,𝑁 𝑆 } 𝐶 𝑅 , which gives us constants in 𝐼 𝑅𝑆 . Observe that at maximum we could obtain min(𝑧 {𝑁 𝑆 ,𝐶 𝑅 }</figDesc><table><row><cell></cell><cell></cell><cell>𝑁 𝑆</cell><cell>) constants using these.</cell></row><row><cell></cell><cell>, 𝑧 {𝐶 𝑅 ,𝑁 𝑆 }</cell></row><row><cell>𝑁 𝑆</cell><cell>𝐶 𝑅</cell></row><row><cell></cell><cell>𝐶 𝑆</cell><cell>) constants in this manner.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head></head><label></label><figDesc>If 𝑚 &lt; |𝑆 |, then let us show that there is no such valuation. Indeed, assume by way of contradiction that such a valuation 𝜈 exists. Let 𝐵 be a subset of 𝐷 of minimal size such that 𝜈 (𝐵) = 𝑆. It is clear that such a subset exists, and moreover that its size is exactly |𝑆 |. But then, consider the set 𝑀 of edges of 𝐺 𝐷,𝑆 defined by 𝑀 Then 𝑀 is a matching of 𝐺 𝐷,𝑆 of size |𝑆 |, contradicting the fact that 𝑚 is the size of a maximum-cardinality matching.• If 𝑚 = |𝑆 |, let us show that such a valuation exists. Let 𝑀 be a matching of 𝐺 𝐷,𝑆 of size |𝑆 |.</figDesc><table /><note><p>1 /16)| ⩽ 8 /16 ⩾ 3 4 . This implies in particular that Pr A (𝐷, 1 /16) ⩾ 8 -8 /16 ⩾ 3 4 . Since 8 -8 /16 = 7.5 we conclude that if 𝐺 is 3-colorable, then B • def = {(𝑓 , 𝜈 (𝑓 )) | 𝑓 ∈ 𝐵}.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head></head><label></label><figDesc>)where each sum s 𝑖 sums over the possible images 𝐴 s 𝑖 of the nulls in 𝑁 s 𝑖 by a valuation, and 𝑓 s 𝑖 will simply be surj 𝑛 s 𝑖 →𝑎 s 𝑖 , where 𝑎 s 𝑖</figDesc><table /><note><p>def = |𝐴 s 𝑖 |, i.e., the number of valuations 𝜈 of 𝑁 s 𝑖 with image exactly 𝐴 s 𝑖 . But there are two technicalities:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>1 s i , . . . , 𝐵 |I (𝑍 𝑖-1 |) 𝑖 , where each of the 𝐵 𝑗 s 𝑖 is included in one of the sets in I (𝑍 𝑖-1</figDesc><table><row><cell>s i</cell><cell>)</cell></row><row><cell>of 𝐴 s</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>s ⊆ (dom \ (𝐶 ∪ ∅≠s ′ ⊆𝜎 s ′ ≠s 𝐼 s ′ )) ∪ ∅≠s ′ ⊊s 𝐶 s ′ for every s ∈ (s 1 , . . . , s 𝐿 ) (in other words, all the sets 𝐼 s are mutually disjoint subsets of dom, and a set 𝐼 s can only contain a constant 𝑏 ∈ 𝐶 if 𝑏 is in one of the sets 𝐶 s ′ for which s ′ is striclty included in s), let us define 𝑃 (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) to be the complete database consisting of the following facts, for every ∅ ≠ s ⊆ 𝜎: • 𝑅(𝑎) for every 𝑅 ∈ s and 𝑎 ∈ 𝐼 s or 𝑎 ∈ 𝐶 s \ s⊋s ′ 𝐼 s ′ Then, for every two such tuples (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) and (𝐼 ′ s 1 , . . . , 𝐼 ′ s 𝐿 ) satisfying (★) and that are distinct, we have that 𝑃 (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) ≠ 𝑃 (𝐼 ′ s 1 , . . . , 𝐼 ′ s 𝐿 ).</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head></head><label></label><figDesc>𝑘 such that 1⩽ 𝑗 ⩽𝑘 s ′ 𝑗 = s and such that for every 1 ⩽ 𝑗 ⩽ 𝑘 we have that (i) 𝑎 ∈ 𝐼 s ′ 𝑗 ∪ (𝐶 s ′ 𝑗 \ s ′ 𝑗 ⊋s ′′ 𝐼 s ′′ ). Observe that there must exist 1 ⩽ 𝑗 1 , 𝑗 2 ⩽ 𝑘 such that s ′ 𝑗 1 and s ′ 𝑗 2 are incomparable by inclusion (otherwise, since all s 𝑗 are strictly included in s, their union could not be equal to s). Also observe that by (★) we have that the sets 𝐼 s ′ 𝑗 1 ∪ 𝐶 s ′ 𝑗 1 and 𝐼 s ′ 𝑗 2 ∪ 𝐶 s ′ 𝑗 2 must be disjoint. But then (i) applied to 𝑗 1 and 𝑗 2 gives a contradiction (namely, these two sets are not disjoint since they both contain 𝑎). This finishes the proof. □ This next Lemma generalizes Claim 4.13 and tells us that by summing over all such tuples (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) we cannot miss a completion of 𝐷: Lemma B.8. Let 𝐷 ′ be a completion of 𝐷. Then there exists a tuple (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) of subsets of dom satisfying (★) such that 𝐷 ′ = 𝑃 (𝐼 s 1 , . . . , 𝐼 s 𝐿 ). Proof. For ∅ ≠ s ⊆ 𝜎, let us define 𝐷 s to be the set of constants that occur in all relation of s and in none of the others. Define the set 𝐼 s for ∅ ≠ s ⊆ 𝜎 as follows: 𝐼 s def = 𝐷 s \ 𝐶 s . It is then routine to check that (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) satisfies (★) and is such that 𝐷 ′ = 𝑃 (𝐼 s 1 , . . . , 𝐼 s 𝐿 ). □ Lemma B.7 and B.8 allows us to express the result as ∑︁ 𝐼 s 1 ⊆dom\𝐶 . . . ∑︁ 𝐼 s 𝑗 ⊆ (dom\(𝐶∪ 1⩽𝑘 &lt; 𝑗 𝐼 s 𝑘 ))∪ ∅≠s ′ ⊊s 𝐶 s ′ . . . ∑︁ 𝐼 s 𝐿 ⊆dom\(𝐶 s 𝐿 ∪ 1⩽𝑘 &lt;𝐿 𝐼 s 𝑘 ) check(𝐼 s 1 , . . . , 𝐼 s 𝐿 ) (8) where check(𝐼 s 1 , . . . , 𝐼 s 𝐿 ) ∈ {0, 1} is defined by check(𝐼 s 1 , . . . , 𝐼 s 𝐿 ) As such we cannot evaluate this expression in P. The next step is to show that the value of check(𝐼 s 1 , . . . , 𝐼 s 𝐿 ) only depends on (|𝐼 s 1 |, . . . , |𝐼 s 𝐿 |), which would allow us to rewrite the result as ∑︁ 0⩽𝑖 s 1 ,...,𝑖 s 𝐿 ⩽𝑑 1⩽ 𝑗 ⩽𝐿 𝑑 -𝑐 -1⩽𝑘&lt; 𝑗 𝑖 s 𝑘 + ∅≠s ′ ⊊s 𝐶 s ′ 𝑖 s 𝑗 × check(𝑖 s 1 , . . . , 𝑖 s 𝐿 )</figDesc><table /><note><p>. . , s ′ 𝑘 with 𝑘 ⩾ 1 and s ′ 𝑗 ⊊ s for 1 ⩽ 𝑗 ⩽ def = 1 if 𝑃 (𝐼 s 1 , . . . , 𝐼 s 𝐿 ) is a completion of 𝐷 that satisfies 𝑞 0 otherwise .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15"><head>•</head><label></label><figDesc>Now, for every ∅ ≠ s ⊆ 𝜎 we have the constraint ∑︁ 𝑧 𝐴,𝐴 ′ 𝑁s ∈𝑉 𝑧 𝐴,𝐴 ′ 𝑁 s ⩽ 𝑛 s as well as the constraint ∑︁ 𝑧 𝐴,𝐴 ′ 𝐶s ∈𝑉 𝑧 𝐴,𝐴 ′ 𝑁 s ⩽ 𝑐 s intuitively expressing that we do not use more nulls and constants than there are available. • for every ∅ ≠ s ⊆ 𝜎 we have a constraint</figDesc><table><row><cell>∑︁ 𝐴,𝐴 ′ ⊆ { ∅≠s⊆𝜎 }</cell><cell>min  *  ∈𝑉 𝑧 𝐴,𝐴 ′</cell><cell>𝑧 𝐴,𝐴 ′  *</cell><cell>⩾ 𝐼 s</cell></row><row><cell>𝐴∪𝐴 ′ =s</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We remind the reader that we assume all sjfBCQs to contain at least one atom and that all atoms must contain at least one variable.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This is in particular because the conjunctive queries we consider have no self-joins (otherwise, reordering variables inside an atom could change the complexity).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Formally, one can first check that we can assume without loss of generality that 𝑞 ′ was obtained from 𝑞 by first deleting some atoms and variable occurences to obtain a query 𝑞 ′′ , and then performing some renamings and variable reorderings to obtain 𝑞 ′ (that is, we can always push the renaming and reordering parts at the end of the transformation). But then, since #Val(𝑞 ′′ ) and #Val(𝑞 ′ ) are obviously the same problem, we can assume 𝑞 ′ = 𝑞 ′′ .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>See Footnote 1.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>To see that<ref type="bibr" target="#b39">[40]</ref> establishes the hardness of 𝑞 = 𝑅 ′ (y, 𝑥) ∧ 𝑆 ′ (z, 𝑥), first apply their rewrite rule R7 (from Fig.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_5"><p><ref type="bibr" target="#b5">6)</ref> to obtain 𝑞 ′ = 𝑅 ′ (y, 𝑥) ∧ 𝑆 ′ (x, 𝑥), then apply rewrite rule R10 to obtain 𝑞 ′′ = 𝑅 ′ (y, 𝑥) ∧ 𝑆 ′ (x, 𝑎). Then, 𝑞 ′′ is #P-hard by Lemma 19, and so is 𝑞 by Lemma 7.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Note that in the sum we do not need to specify that 𝑚 ′ + 𝑟 ′ ⩽ 𝑛 𝑅 , as when 𝑎 &lt; 𝑏 we have surj 𝑎→𝑏 = 0.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_7"><p>This observation, and in fact the idea of reducing from #BIS, is due to Antoine Amarilli.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_8"><p>When 𝑓 is a ground fact -such as 𝑅 (𝑐, 𝑐, 𝑐 ′ , 𝑐 ′ ) -we recall the mathematical convention that there exists a unique function with emtpy domain, hence a unique valuation of the nulls of 𝑓 .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>Again, we remind the reader that, to avoid trivialities, we assume all sjfBCQs to contain at least one atom and all atoms to have at least one variable.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_10"><p>In fact, the class GapSpanP is defined in<ref type="bibr" target="#b38">[39]</ref>, where it is proved that a function 𝑓 is in GapSpanP if and only if 𝑓 = 𝑔ℎ, where ℎ, 𝑔 are functions in SpanP. Then it is shown in<ref type="bibr" target="#b38">[39,</ref> Corollary 3.5] that the inclusion GapSpanP ⊆ GapP implies that NP ⊆ SPP. But if we have that SpanP ⊆ GapP, then we also have that GapSpanP ⊆ GapP as GapP is closed under subtraction and, therefore, we conclude that NP ⊆ SPP as desired.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We thank <rs type="person">Antoine Amarilli</rs> for suggesting to use #BIS in the proof of Proposition 3.11, as well as the anonymous reviewers for their careful proofreading. This work was partially funded by <rs type="programName">ANID -Millennium Science Initiative Program</rs> -Code <rs type="grantNumber">ICN17_002</rs>. Arenas is funded by <rs type="grantName">Fondecyt grant</rs> <rs type="grantNumber">1191337</rs> and <rs type="funder">Barceló</rs> by <rs type="grantName">Fondecyt</rs> grant <rs type="grantNumber">1200967</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_RMYnnae">
					<idno type="grant-number">ICN17_002</idno>
					<orgName type="grant-name">Fondecyt grant</orgName>
					<orgName type="program" subtype="full">ANID -Millennium Science Initiative Program</orgName>
				</org>
				<org type="funding" xml:id="_gA6c5pK">
					<idno type="grant-number">1191337</idno>
					<orgName type="grant-name">Fondecyt</orgName>
				</org>
				<org type="funding" xml:id="_6tkKNwr">
					<idno type="grant-number">1200967</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>accepts with probability at least 3 /4. Next, assume that 𝐺 is not 3-colorable. Then by (c) we have that Pr |7 -A (𝐷, 1 /16)| ⩽ 7 /16 ⩾ 3  4 . This implies in particular that Pr A (𝐷, 1 /16) ⩽ 7 + 7 /16 ⩾ 3 4 . Since 7 + 7 /16 &lt; 7.5, this implies in particular that Pr A (𝐷, 1 /16) &lt; 7.5 ⩾ 3  4 . From this, we conclude that if 𝐺 is not 3-colorable, then B rejects with probability at least 3 /4. This concludes the proof of the proposition.</p><p>□</p><p>By observing again that the reduction in Lemma 4.1 is parsimonious, and that the existence of an FPRAS is closed under parsimonious reductions, we obtain that #Comp u (𝑞) cannot be efficiently approximated if 𝑞 contains 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) as a pattern. Theorem 5.7 (Dichotomy). Let 𝑞 be an sjfBCQ. If 𝑞 has 𝑅(𝑥, 𝑥) or 𝑅(𝑥, 𝑦) as a pattern, then #Comp u (𝑞) does not admit an FPRAS unless NP = RP. Otherwise, this problem is in FP (by Theorem 4.10).</p><p>We do not know if this result still holds for Codd tables, or if it is possible to design an FPRAS in this setting. We leave this question open for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">ON THE GENERAL LANDSCAPE: BEYOND #P</head><p>Recall that, when studying the complexity of counting completions for sjfBCQs in Section 4, we did claim that these problems are in #P for Codd tables, but that we did not claim so for naive tables. The goal of this section is then threefold. First, we want to prove that the problem of counting completions in indeed in #P for Codd tables. Second, we want to give formal evidence that we indeed could not show membership in #P for naive tables. Third, we want to identify a counting complexity class that is more appropriate to describe the complexity of #Comp(𝑞). We deal with these three objectives in the next three sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Membership in</head><p>In this section, and as promised in the proofs of Propositions 4.4 and 4.11, we show that for any Boolean query 𝑞, if the model checking problem for 𝑞 (denoted MC(𝑞), recall the definition from Section 5.1) is in P then the problem of counting completions for 𝑞 under Codd tables is in #P. Proposition 6.1. If a Boolean query 𝑞 has the property that model checking is in P, then we have that #Comp Cd (𝑞) is in #P.</p><p>We recall that a fact that contains only constants is a ground fact. To show Proposition 6.1, we first prove that we can check in polynomial time if a given set of ground facts is a possible completion of an incomplete database: Lemma 6.2. Given as input an incomplete Codd table 𝐷 and a set 𝑆 of ground facts, we can decide in polynomial time whether there exists a valuation 𝜈 of 𝐷 such that 𝜈 (𝐷) = 𝑆.</p><p>Proof. For every fact 𝑓 of 𝐷, let us denote by 𝑃 (𝑓 ) the set of ground facts that can be obtained from 𝑓 via a valuation (𝑃 (𝑓 ) can be {𝑓 } if 𝑓 is already a ground fact). The first step is to check that for every fact 𝑓 of 𝐷, it holds that (★) 𝑃 (𝑓 ) ∩ 𝑆 ≠ ∅. If this is not the case, then we know for sure that for every valuation 𝜈 of 𝐷 we will have 𝜈 (𝐷) ⊈ 𝑆, so that we can safely reject. Next, we build the bipartite graph 𝐺 𝐷,𝑆 defined as follows: the nodes in the left partition of 𝐺 𝐷,𝑆 are the facts of 𝐷, the nodes in the right partition are the facts in 𝑆, and we connect a fact 𝑓 of 𝐷 with all the ground facts in the right partition that are in 𝑆 ∩ 𝑃 (𝑓 ). It is clear that we can construct 𝐺 𝐷,𝑆 in polynomial time. We then compute in polynomial time the size 𝑚 of a maximum-cardinality matching of 𝐺 𝐷,𝑆 , for instance using <ref type="bibr" target="#b20">[21]</ref>. It is clear that we have 𝑚 ⩽ |𝑆 |. At this stage, we claim that there exists a valuation 𝜈 of 𝐷 such that 𝜈 (𝐷) = 𝑆 if and only if 𝑚 = |𝑆 |. We prove this by analysing the two possible cases: In this section we prove the tractability claim of the following dichotomy theorem. Theorem 3.9 (dichotomy). Let 𝑞 be an sjfBCQ.</p><p>First, to characterize the queries that do not have these patterns, we will use the notion of connectivity graph of an sjfBCQ 𝑞: Definition A.1. Let 𝑞 be an sjfBCQ. The connectivity graph of 𝑞 is the graph 𝐺 𝑞 = (𝑉 , 𝐸) with labeled edges, where 𝑉 is the set of atoms of 𝑞, and for every two atoms 𝑅( x𝑖 ), 𝑆 ( ȳ𝑖 ) of 𝑞, if they share a variable then we have an edge between the corresponding nodes of 𝐺 𝑞 , that edge being labeled with the variables in x𝑖 ∩ ȳ𝑖 .</p><p>Example A.2. Figure <ref type="figure">3</ref> shows the connectivity graph of the query The following is then readily observed:</p><p>Lemma A.3. Let 𝑞 be an sjfBCQ that does not contain any of the patterns mentioned in Theorem 3.9. Then for every connected component 𝐶 of 𝐺 𝑞 , 𝐶 is a clique and there exists a variable such that all edges of 𝐶 are labeled by exactly that variable.</p><p>Proof. First, observe that every edge of 𝐺 𝑞 must be labeled by exactly one variable, as otherwise the query 𝑞 would contain the pattern 𝑅(𝑥, 𝑦) ∧ 𝑆 (𝑥, 𝑦). Let 𝐶 be a connected component of 𝐺 𝑞 . Then we have:</p><p>• 𝐶 is a clique. Indeed, assume by contradiction that 𝐶 is not a clique. Then, since 𝐶 is connected and is not a clique, we can find 3 nodes 𝐴 1 (𝑥), 𝐴 2 (𝑥 ′ ), 𝐴 3 (𝑥 ′′ ) such that 𝐴 1 (𝑥) is adjacent to 𝐴 2 (𝑥 ′ ), 𝐴 2 (𝑥 ′ ) is adjacent to 𝐴 3 (𝑥 ′′ ), and 𝐴 1 (𝑥) is not adjacent to 𝐴 3 (𝑥 ′′ ). Let 𝑋 be 𝑥 ∩ 𝑥 ′ and 𝑌 be 𝑥 ′ ∩ 𝑥 ′′ , i.e., the labels on the two corresponding edges of 𝐶. By definition of 𝐺 𝑞 and since 𝐴 1 (𝑥) is not adjacent to 𝐴 3 (𝑥 ′′ ), we must have 𝑋 ∩ 𝑌 = ∅. But 𝑋 and 𝑌 are not empty (again by definition of 𝐺 𝑞 ), so by picking 𝑥 in 𝑋 and 𝑦 in 𝑌 we see that 𝑞 contains the pattern 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦), a contradiction.</p><p>• There exists a variable that labels every edge of 𝐶. Indeed, since every edge of 𝐺 𝑞 is labeled by exactly one variable, and since 𝐶 is a clique, if it was not the case then again we could find the pattern 𝑅(𝑥) ∧ 𝑆 (𝑥, 𝑦) ∧ 𝑇 (𝑦) in 𝑞. This concludes the proof. □</p><p>For instance, the query from Example A.2 does not satisfy this criterion, since the edge in the first connected component of 𝐺 𝑞 is labeled by two variables. However if we consider the query 𝑆 1 (𝑥 2 , 𝑡 3 ), 𝑆 2 (𝑥 2 , 𝑡 4 ), 𝑆 3 (𝑥 2 ),𝑇 1 (𝑥 3 ),𝑇 2 (𝑥 3 ),𝑇 3 (𝑥 3 ),𝑇 4 (𝑥 3 , 𝑡 5 ) (i.e., we remove the first connected component), then it satisfies the criterion.</p><p>We will also use the general fact that for an sjfBCQ 𝑞, we can assume wlog that 𝑞 does not contain variables that occur only once: Lemma A.4. Let 𝑞 be an sjfBCQ, and let 𝑞 ′ be the sjfBCQ obtained from 𝑞 by deleting all the variables that have only one occurrence in 𝑞. Then #Val u (𝑞) ⩽ p T #Val u (𝑞 ′ ). Proof. Let 𝐷 be an incomplete database input of #Val u (𝑞). Let 𝑆 be set of nulls ⊥ such that:</p><p>• ⊥ occurs in a column corresponding to a variable that has been deleted; and • ⊥ does not occur in a column corresponding to a variable that has not been deleted.</p><p>Then, letting 𝐷 ′ be the database obtained from 𝐷 by projecting out the columns corresponding to the deleted variables, it is clear that we have</p><p>where dom is the uniform domain of the nulls. We note here that this lemma is also true in the non-uniform setting. □ By Lemma A.3 and Lemma A.4, it is enough to show the tractability of #Val u (𝑞) when 𝑞 is of the form 𝐶 1 (𝑥 1 ) ∧ . . . ∧ 𝐶 𝑚 (𝑥 𝑚 ), where each 𝐶 𝑖 (𝑥 𝑖 ) is what we call a basic singleton query, i.e., is a conjunction of unary atoms over the same variable 𝑥 𝑖 . We call such an sjfBCQ a conjunction of basic singletons. For instance,</p><p>is such a query, with 𝑚 = 2. We will use the following: Lemma A.5. Let 𝑞 = 𝐶 1 (𝑥 1 ) ∧ . . . ∧𝐶 𝑚 (𝑥 𝑚 ) be a conjunction of basic singletons sjfBCQ, and let 𝐷 be an incomplete database. For 𝑆 ⊆ [𝑚], we define 𝑁 𝑆 (𝐷)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Direct, by inclusion-exclusion. □</head><p>Hence, and remembering that we consider data complexity, it is enough to show how to compute 𝑁 𝑆 (𝐷) for every 𝑆 ⊆ [𝑚]. The main difficulties in computing 𝑁 𝑆 (𝐷) is that the relations can have nulls in common (since we consider naive tables), and that they may also have constants; this makes it technically painful to express a closed-form expression for 𝑁 𝑆 (𝐷). We explain how to do it next, thus finishing the proof of Theorem 3.9.</p><p>Proposition A.6. Let 𝑞 = 𝐶 1 (𝑥 1 ) ∧ . . . ∧ 𝐶 𝑚 (𝑥 𝑚 ) be a conjunction of basic singletons sjfBCQ and 𝑆 ⊆ [𝑚]. Then, given an incomplete database 𝐷 as input, we can compute 𝑁 𝑆 (𝐷) in polynomial time.</p><p>Proof. First, observe that to compute 𝑁 𝑆 (𝐷) we can assume without loss of generality that the input database 𝐷 only contains facts over relation names that occur in some 𝐶 𝑖 (𝑥 𝑖 ), for 𝑖 ∈ 𝑆. Indeed, 𝑁 𝑆 (𝐷) counts the valuations 𝜈 of 𝐷 that do not satisfy any of the 𝐶 𝑖 (𝑥 𝑖 ) for 𝑖 ∈ 𝑆, so that for any 𝑗 ∉ 𝑆 we do not care if 𝜈 satisfies 𝐶 𝑗 (𝑥 𝑗 ) or not; hence, we could simply multiply the result by The resulting expression then indeed evaluates to 𝑁 [𝑚] (𝐷), and is in a form that allows us to directly compute it in polynomial time (but non-elementary in the query). This concludes the proof of Proposition A. In this section we explain how to obtain the following hardness result.</p><p>Proposition 4.7 (Implied by <ref type="bibr" target="#b25">[26]</ref>). The problem #PF restricted to bipartite graphs is #P-hard.</p><p>This result is proven for (non-necessarily bipartite) graphs in <ref type="bibr" target="#b25">[26]</ref> using techniques from matroid theory, in particular using the notions of bicircular matroid of a graph and of Tutte polynomial of a matroid. We did not find a way to show that the result holds on bipartite graphs without explaining their proof for general graphs, and we did not find a way to explain the proof for general graphs without introducing these concepts. Therefore, we need to define these concepts here. We have tried to keep this exposition as brief as possible, but more detailed introductions to matroid theory and to the Tutte polynomial can be found in <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b53">54]</ref>. First, we define what is a matroid. Definition B.1. A matroid 𝑀 = (𝐸, I) is a pair where 𝐸 is a finite set (called the ground set) and I is a set of subsets of 𝐸 whose elements are called independent sets and that satisfies the following properties: Non emptiness. I ≠ ∅; Heritage. For every 𝐴 ′ ⊆ 𝐴 ⊆ 𝐸, if 𝐴 ∈ I then 𝐴 ′ ∈ I; Independent set exchange. For every 𝐴, 𝐵 ∈ I, if |𝐴| &gt; |𝐵| then there exists 𝑥 ∈ 𝐴 \ 𝐵 such that 𝐵 ∪ {𝑥 } ∈ I.</p><p>In a matroid 𝑀 = (𝐸, I), an independent set 𝐴 ∈ I is called a basis if every strict superset 𝐴 ⊊ 𝐴 ′ ⊆ 𝐸 is not in I. Notice that, thanks to the independent set exchange property, all bases of 𝑀 have the same number of elements. The rank of 𝑀 is defined as the number of elements in any basis of 𝑀. Given a matroid 𝑀 = (𝐸, I) and 𝐴 ⊆ 𝐸, we can define the submatroid of 𝑀 generated by 𝐴 to be 𝑀 𝐴 = (𝐴, I ′ ), where for 𝐴 ′ ⊆ 𝐴 we have 𝐴 ′ ∈ I ′ iff 𝐴 ′ ∈ I (one should check that this is indeed a matroid). The rank function rk 𝑀 : {𝐴 | 𝐴 ⊆ 𝐸} → N of 𝑀 is then defined with rk 𝑀 (𝐴) being the rank of the matroid 𝑀 𝐴 . We will now omit the subscript in rk 𝑀 as this will not cause confusion. We are ready to define the Tutte polynomial of a matroid. We will use the following observation:</p><p>Observation B.3. Let 𝑀 = (𝐸, I) be a matroid. Then T(𝑀; 2, 1) = |I|, i.e., evaluating the Tutte polynomial of a matroid at point (2, 1) simply counts its number of independent sets.</p><p>Proof. We have T(𝑀; 2, 1) = 𝐴 ⊆𝐸 0 |𝐴 |-rk(𝐴) . We recall the convention that 0 0 = 1, and the fact that 0 𝑘 = 0 for 𝑘 &gt; 0. Observe then that we always have rk </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<ptr target="http://webdam.inria.fr/Alice/" />
	</analytic>
	<monogr>
		<title level="m">Foundations of databases</title>
		<title level="s">Addison-Wesley Reading</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the representation and querying of sets of possible worlds</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paris</forename><surname>Kanellakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gösta</forename><surname>Grahne</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/0304397551900072" />
	</analytic>
	<monogr>
		<title level="j">Theoretical computer science</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="159" to="187" />
			<date type="published" when="1991">1991. 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><surname>Adam</surname></persName>
		</author>
		<ptr target="https://math.stackexchange.com/a/615136/378365" />
		<title level="m">Number of surjective functions</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Foundations of uncertain-data integration</title>
		<author>
			<persName><forename type="first">Parag</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anish</forename><forename type="middle">Das</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><surname>Ullman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
		<ptr target="http://ilpubs.stanford.edu:8090/846/2/main.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1080" to="1090" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A very hard log-space counting class</title>
		<author>
			<persName><forename type="first">Carme</forename><surname>Álvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Birgit</forename><surname>Jenner</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/030439759390252O" />
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="30" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Clean answers over dirty databases: A probabilistic approach</title>
		<author>
			<persName><forename type="first">Periklis</forename><surname>Andritsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Fuxman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Renee</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<ptr target="ftp://ftp.cs.toronto.edu/csrg-technical-reports/513/tr513.pdf" />
	</analytic>
	<monogr>
		<title level="m">22nd International Conference on Data Engineering (ICDE&apos;06)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="30" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">10 (10 6 ) worlds and beyond: efficient representation and processing of incomplete information</title>
		<author>
			<persName><forename type="first">Lyublena</forename><surname>Antova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/cs/0606075" />
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1021" to="1040" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Counting Problems over Incomplete Databases</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikaël</forename><surname>Monet</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1912.11064" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 39th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="165" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Consistent query answers in inconsistent databases</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Chomicki</surname></persName>
		</author>
		<ptr target="http://marenas.sitios.ing.uc.cl/publications/pods99.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the eighteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</title>
		<meeting>the eighteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="68" to="79" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient logspace classes for enumeration, counting, and uniform generation</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alberto</forename><surname>Luis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rajesh</forename><surname>Croquevielle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Jayaram</surname></persName>
		</author>
		<author>
			<persName><surname>Riveros</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1906.09226" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="59" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Databases with uncertainty and lineage</title>
		<author>
			<persName><forename type="first">Omar</forename><surname>Benjelloun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anish</forename><forename type="middle">Das</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
		<ptr target="http://ilpubs.stanford.edu:8090/811/1/2007-26.pdf" />
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="243" to="264" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Database repairing and consistent query answering</title>
		<author>
			<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
		</author>
		<ptr target="https://www.cs.ubc.ca/~laks/cpsc504/dc-leo.pdf" />
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Data Management</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1" to="121" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Database repairs and consistent query answering: Origins and further developments</title>
		<author>
			<persName><forename type="first">Leopoldo</forename><surname>Bertossi</surname></persName>
		</author>
		<ptr target="https://dl.acm.org/citation.cfm?id=3322190" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="48" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Holographic reduction, interpolation and hardness</title>
		<author>
			<persName><forename type="first">Jin-Yi</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pinyan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingji</forename><surname>Xia</surname></persName>
		</author>
		<ptr target="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.145.8882&amp;rep=rep1&amp;type=pdf" />
	</analytic>
	<monogr>
		<title level="j">Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="573" to="604" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Counting database repairs under primary keys revisited</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Calautti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<ptr target="https://core.ac.uk/download/pdf/224804156.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 38th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="104" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Understanding relations (installment# 7)</title>
		<author>
			<persName><surname>Codd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FDT Bull. of ACM Sigmod</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="23" to="28" />
			<date type="published" when="1975">1975. 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Approximations and refinements of certain answers via many-valued logics</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<ptr target="https://homepages.inf.ed.ac.uk/libkin/papers/kr16.pdf" />
	</analytic>
	<monogr>
		<title level="m">KR</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="349" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Queries and materialized views on probabilistic databases</title>
		<author>
			<persName><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://www-cs.stanford.edu/~chrismre/papers/jcss-probdb.pdf" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="473" to="490" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The dichotomy of probabilistic inference for unions of conjunctive queries</title>
		<author>
			<persName><forename type="first">Nilesh</forename><surname>Dalvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<ptr target="https://homes.cs.washington.edu/~suciu/jacm-dichotomy.pdf" />
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1" to="87" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On counting independent sets in sparse graphs</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Frieze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Jerrum</surname></persName>
		</author>
		<ptr target="http://yaroslavvb.com/papers/dyer-on.pdf" />
	</analytic>
	<monogr>
		<title level="j">SIAM J. on Computing</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1527" to="1541" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Paths, trees, and flowers</title>
		<author>
			<persName><forename type="first">Jack</forename><surname>Edmonds</surname></persName>
		</author>
		<ptr target="https://math.nist.gov/~JBernal/p_t_f.pdf" />
	</analytic>
	<monogr>
		<title level="j">Can. J. of Math</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="449" to="467" />
			<date type="published" when="1965">1965. 1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Decomposing a graph into pseudoforests with one having bounded degree</title>
		<author>
			<persName><forename type="first">Genghua</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ning</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daqing</forename><surname>Yang</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/S0095895615000581" />
	</analytic>
	<monogr>
		<title level="j">Journal of Combinatorial Theory, Series B</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="72" to="95" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Conditional functional dependencies for capturing data inconsistencies</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xibei</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<ptr target="https://www.inf.ed.ac.uk/publications/online/0949.pdf" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="48" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Gap-definable counting classes</title>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">A</forename><surname>Fenner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lance</forename><forename type="middle">J</forename><surname>Fortnow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stuart</forename><forename type="middle">A</forename><surname>Kurtz</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/S0022000005800248" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="116" to="148" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Best answers over incomplete data: Complexity and first-order rewritings</title>
		<author>
			<persName><forename type="first">Amélie</forename><surname>Gheerbrant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristina</forename><surname>Sirangelo</surname></persName>
		</author>
		<ptr target="https://www.ijcai.org/proceedings/2019/236" />
	</analytic>
	<monogr>
		<title level="m">the Twenty-Eighth International Joint Conference on Artificial Intelligence (IJCAI 2019)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On the complexity of computing the Tutte polynomial of bicircular matroids</title>
		<author>
			<persName><forename type="first">Omer</forename><surname>Giménez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Noy</surname></persName>
		</author>
		<ptr target="https://www.cambridge.org/core/journals/combinatorics-probability-and-computing/article/on-the-complexity-of-computing-the-tutte-polynomial-of-bicircular-matroids/8B45505EDDDF91337" />
	</analytic>
	<monogr>
		<title level="j">Combinatorics, Probability and Computing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="395" />
			<date type="published" when="2006">2006. 2006. 62D45B143</date>
		</imprint>
	</monogr>
	<note>EC</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">Logan</forename><surname>Grout</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Moore</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1904.12435</idno>
		<ptr target="https://arxiv.org/abs/1904.12435" />
		<title level="m">On decomposing graphs into forests and pseudoforests</title>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The power of witness reduction</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Gupta</surname></persName>
		</author>
		<ptr target="https://ieeexplore.ieee.org/abstract/document/160242" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth Annual Structure in Complexity Theory Conference</title>
		<meeting>the Sixth Annual Structure in Complexity Theory Conference</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1991">1991. 1991</date>
			<biblScope unit="page" from="43" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Closure properties and witness reduction</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Gupta</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/S002200008571032X" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="412" to="432" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Incomplete Information in Relational Databases</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Witold</forename><surname>Lipski</surname><genName>Jr</genName></persName>
		</author>
		<ptr target="https://cs.uwaterloo.ca/~david/cs848s14/il84.pdf" />
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984">1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Descriptive complexity</title>
		<author>
			<persName><forename type="first">Neil</forename><surname>Immerman</surname></persName>
		</author>
		<ptr target="https://people.cs.umass.edu/~immerman/book/ch0_1_2.pdf" />
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On the computational complexity of the Jones and Tutte polynomials</title>
		<author>
			<persName><forename type="first">François</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dirk</forename><forename type="middle">L</forename><surname>Vertigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dominic Ja</forename><surname>Welsh</surname></persName>
		</author>
		<ptr target="https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/on-the-computational-complexity-of-the-jones-and-tutte-polynomials/0EA052341269A2816C36B15380" />
	</analytic>
	<monogr>
		<title level="m">Mathematical Proc. of the Cambridge Phil. Soc</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1990">1990. AA02</date>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="35" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Random generation of combinatorial structures from a uniform distribution</title>
		<author>
			<persName><forename type="first">Leslie</forename><forename type="middle">G</forename><surname>Mark R Jerrum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><forename type="middle">V</forename><surname>Valiant</surname></persName>
		</author>
		<author>
			<persName><surname>Vazirani</surname></persName>
		</author>
		<ptr target="http://www2.stat.duke.edu/~scs/Courses/Stat376/Papers/ConvergeRates/RandomizedAlgs/JerrumValiantVaziraniTCS1986.pdf" />
	</analytic>
	<monogr>
		<title level="j">Theoretical computer science</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="169" to="188" />
			<date type="published" when="1986">1986. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Some observations on the probabilistic algorithms and NP-hard problems</title>
		<author>
			<persName><forename type="first">-I</forename><surname>Ker</surname></persName>
		</author>
		<author>
			<persName><surname>Ko</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/0020019082901399" />
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="43" />
			<date type="published" when="1982">1982. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">On counting and approximation</title>
		<author>
			<persName><forename type="first">Johannes</forename><surname>Köbler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uwe</forename><surname>Schöning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacobo</forename><surname>Torán</surname></persName>
		</author>
		<ptr target="https://www.researchgate.net/publication/226508658_On_counting_and_approximation" />
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="363" to="379" />
			<date type="published" when="1989">1989. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Approximation scheme for lowest outdegree orientation and graph density measures</title>
		<author>
			<persName><forename type="first">Łukasz</forename><surname>Kowalik</surname></persName>
		</author>
		<ptr target="https://www.mimuw.edu.pl/~kowalik/papers/orient.pdf" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Algorithms and Computation</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="557" to="566" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Incomplete data: what went wrong, and how to fix it</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<ptr target="https://homepages.inf.ed.ac.uk/libkin/papers/pods14.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</title>
		<meeting>the 33rd ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Certain answers meet zero-one laws</title>
		<author>
			<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
		</author>
		<ptr target="https://homepages.inf.ed.ac.uk/libkin/papers/pods18.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 37th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="195" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A note on SpanP functions</title>
		<author>
			<persName><forename type="first">Meena</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Thierauf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">V</forename><surname>Vinodchandran</surname></persName>
		</author>
		<ptr target="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.24.9933&amp;rep=rep1&amp;type=pdf" />
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="7" to="10" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A dichotomy in the complexity of counting database repairs</title>
		<author>
			<persName><forename type="first">Dany</forename><surname>Maslowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jef</forename><surname>Wijsen</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/S0022000013000214" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="958" to="983" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Counting database repairs that satisfy conjunctive queries with self-joins</title>
		<author>
			<persName><forename type="first">Dany</forename><surname>Maslowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jef</forename><surname>Wijsen</surname></persName>
		</author>
		<ptr target="http://www.openproceedings.org/ICDT/2014/paper_17.pdf" />
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="155" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A complexity theory for feasible closure properties</title>
		<author>
			<persName><forename type="first">Mitsunori</forename><surname>Ogiwara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lane</forename><forename type="middle">A</forename><surname>Hemachandra</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/002200009390006I" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="295" to="325" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">What is a matroid</title>
		<author>
			<persName><forename type="first">James</forename><surname>Oxley</surname></persName>
		</author>
		<ptr target="https://www.math.lsu.edu/~oxley/survey4.pdf" />
	</analytic>
	<monogr>
		<title level="j">Cubo Matemática Educacional</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="179" to="218" />
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">The complexity of counting cuts and of computing the probability that a graph is connected</title>
		<author>
			<persName><forename type="first">Provan</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">O</forename><surname>Ball</surname></persName>
		</author>
		<idno type="DOI">10.1137/0212053</idno>
		<ptr target="https://epubs.siam.org/doi/abs/10.1137/0212053" />
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="777" to="788" />
			<date type="published" when="1983">1983. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">On closed world data bases</title>
		<author>
			<persName><forename type="first">Raymond</forename><surname>Reiter</surname></persName>
		</author>
		<ptr target="https://pdfs.semanticscholar.org/d82a/786f460a5d5c2c6d97aa60f0ead0e70dc67e.pdf" />
	</analytic>
	<monogr>
		<title level="j">Springer US</title>
		<imprint>
			<biblScope unit="page" from="55" to="76" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Representing uncertain data: models, properties, and algorithms</title>
		<author>
			<persName><forename type="first">Anish</forename><surname>Das Sarma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omar</forename><surname>Benjelloun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shubha</forename><surname>Nabar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
		<ptr target="http://ilpubs.stanford.edu:8090/924/1/uncertainData.pdf" />
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="989" to="1019" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Probabilistic databases</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<idno type="DOI">10.2200/S00362ED1V01Y201105DTM016</idno>
		<ptr target="https://www.morganclaypool.com/doi/abs/10.2200/S00362ED1V01Y201105DTM016" />
	</analytic>
	<monogr>
		<title level="j">Morgan &amp; Claypool</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Polynomial-time 1-Turing reductions from# PH to# P</title>
		<author>
			<persName><forename type="first">Seinosuke</forename><surname>Toda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Osamu</forename><surname>Watanabe</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/030439759290369Q" />
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="205" to="221" />
			<date type="published" when="1992">1992. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Relative complexity of checking and evaluating</title>
		<author>
			<persName><forename type="first">Leslie</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
		<ptr target="https://www.sciencedirect.com/science/article/pii/0020019076900971" />
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="20" to="23" />
			<date type="published" when="1976">1976. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">The complexity of computing the permanent</title>
		<author>
			<persName><forename type="first">G</forename><surname>Leslie</surname></persName>
		</author>
		<author>
			<persName><surname>Valiant</surname></persName>
		</author>
		<ptr target="https://core.ac.uk/download/pdf/82500417.pdf" />
	</analytic>
	<monogr>
		<title level="j">Theoretical computer science</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="189" to="201" />
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">The complexity of enumeration and reliability problems</title>
		<author>
			<persName><forename type="first">Leslie</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
		<ptr target="https://www.math.cmu.edu/~af1p/Teaching/MCC17/Papers/enumerate.pdf" />
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="410" to="421" />
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Logical approaches to incomplete information: A survey</title>
		<author>
			<persName><forename type="first">Ron</forename><surname>Van Der Meyden</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4615-5643-5_10</idno>
		<ptr target="https://link.springer.com/chapter/10.1007/978-1-4615-5643-5_10" />
	</analytic>
	<monogr>
		<title level="m">Logics for databases and information systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="307" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">The complexity of relational query languages</title>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<ptr target="http://www.dis.uniroma1.it/~degiacom/didattica/semingsoft/SIS05-06/materiale/1-query-congiuntive/riferimenti/vardi-1982.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fourteenth annual ACM symposium on Theory of computing</title>
		<meeting>the fourteenth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="137" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">The Tutte polynomial</title>
		<author>
			<persName><forename type="first">Dominic</forename><surname>Welsh</surname></persName>
		</author>
		<idno type="DOI">10.1002/(SICI)1098-2418(199910/12)15:3/4%3C210::AID-RSA2%3E3.0.CO;2-R</idno>
		<ptr target="https://onlinelibrary.wiley.com/doi/pdf/10.1002/(SICI)1098-2418(199910/12)15:3/4%3C210::AID-RSA2%3E3.0.CO;2-R" />
	</analytic>
	<monogr>
		<title level="j">Random Structures &amp; Algorithms</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="210" to="228" />
			<date type="published" when="1999">1999. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Computational complexity of counting problems on 3-regular planar graphs</title>
		<author>
			<persName><forename type="first">Mingji</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenbo</forename><surname>Zhao</surname></persName>
		</author>
		<ptr target="https://core.ac.uk/download/pdf/82063901.pdf" />
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">384</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="111" to="125" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Bicircular geometry and the lattice of forests of a graph</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Zaslavsky</surname></persName>
		</author>
		<ptr target="https://academic.oup.com/qjmath/article-abstract/33/4/493/1498307?" />
	</analytic>
	<monogr>
		<title level="j">The Quarterly Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="493" to="511" />
			<date type="published" when="1982">1982. 1982</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
