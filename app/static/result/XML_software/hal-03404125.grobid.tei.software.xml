<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Beyond Classical SERVICE Clause in Federated SPARQL Queries: Leveraging the Full Potential of URI Parameters</title>
				<funder ref="#_SuCcJhN">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Corby</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d'Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Catherine</forename><surname>Faron</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d'Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d'Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Damien</forename><surname>Graux</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d'Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Franck</forename><surname>Michel</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université Côte d'Azur</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">I3S</orgName>
								<address>
									<settlement>Sophia Antipolis</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Beyond Classical SERVICE Clause in Federated SPARQL Queries: Leveraging the Full Potential of URI Parameters</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">8057488724BFB4BF84475C008ED908F3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Semantic Web</term>
					<term>URI parameters</term>
					<term>federated querying</term>
					<term>SPARQL</term>
					<term>SPARQL federated query services</term>
					<term>extended SPARQL-based services</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>Semantic Web applications integrating very different software and data sources have to face the heterogeneity of the quality and compliance to standards exhibited by each involved resource. In this paper we propose a uniform way of adapting and customizing the behavior of both the client and the server components of an HTTP exchange to cope with this diversity. We revisit the classical SERVICE clause in <software>SPARQL</software> federated queries in order to parameterize the behavior of both the <software ContextAttributes="used">SPARQL</software> client and the <software ContextAttributes="used">SPARQL</software> service. We propose mechanisms to identify and specify <software ContextAttributes="used">SPARQL</software> federated query services and extended <software ContextAttributes="used">SPARQL</software>-based services.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>Thanks to the W3C standards, the Web benefits from an unprecedented interoperability that propelled it beyond an "Information management proposal" <ref type="bibr" target="#b3">(Berners-Lee, 1989</ref>) to a universal "application integration platform" <ref type="bibr" target="#b9">(Fielding et al., 2017)</ref> and toward a platform linking all forms of intelligence <ref type="bibr" target="#b1">(Berendt et al., 2021)</ref>.</p><p>To parameterize the calls made between the applications on the Web, the RFC 3986 <ref type="bibr" target="#b2">(Berners-Lee et al., 2005)</ref> defines the query component of a URI as indicated by the first question mark ("?" character) and terminated by a number sign ("#" character) or by the end of the URI. However, the exact structure of the query string is not standardized at the URI level. Although methods used to compose a query string may differ between websites, the original usage in HTML forms popularized the use of query strings composed of a series of field-value pairs where the field name and value are separated by an equals sign ("=") and the pairs are separated by the ampersand sign ("&amp;") as in this example with two parameters gname and fname respectively set to "doe" and "john". The query string of a URI is essentially perceived as a way to pass parameters to the server and to the logic invoked in producing a response. But the position we take in that paper is that, because they are at the frontier between the client and the servers of a Web application, URI parameters can be used to influence the behavior of both these components. Instead of resolving to adhoc hacks, we propose a uniform way, based on the URI query string, to adapt and customize the behavior of the client and the server components of an HTTP exchange. By relying on the standard URI parameters, the approach remains backward compatible as it is transparent for clients or servers that do not implement them and simply ignore them. Moreover, in the context of federated systems, for instance, the same software component may endorse the role of a client or a server in different interactions and this uniform way of parameterizing behaviours works seamlessly in that case too.</p><p>In particular, we propose to exploit the full potential of the query string of a URI in the context of Semantic Web applications <ref type="bibr" target="#b10">(Gandon, 2018)</ref> where the communication between clients and servers is based on <software ContextAttributes="used">SPARQL</software>, standing for <software ContextAttributes="used">SPARQL</software> Protocol and RDF Query Language <ref type="bibr" target="#b11">(Harris and Seaborne, 2013)</ref>. It provides a fully declarative language for query and update operations <ref type="bibr" target="#b0">(Allemang et al., 2020)</ref>. Therefore, unlike with imperative programming languages, it is not possible to embed any instruction to tune the behavior of the <software ContextAttributes="used">SPARQL</software> query processor that is evaluating a SERVICE clause, or to control the query plan that it will come up with. Yet, we may want to customize its behavior based on what we know about the remote service <ref type="bibr">(quotas, supported features, etc.)</ref>.</p><p>In this article, we report our return on experience on using URI parameters to parameterize the behavior of both <software>SPARQL</software> clients and services. Our proposal is motivated by the fact that, although the W3C standards provide an excellent common ground for interoperability, in practice applications integrating very different software and data sources have to face the heterogeneity of the quality and compliance to standards exhibited by each involved resource. One application of great interest is to cope with heterogeneity in the context of federated querying. In particular, in real-world scenarios, a <software ContextAttributes="used">SPARQL</software> query processor evaluating a federated query must be able, on one side, to parameterize the remote <software ContextAttributes="used">SPARQL</software> services' behaviors (for which it is the client) according to their capabilities and specificity, and, on the other side, to adapt its own behavior to the limitations and characteristics of these remote services.</p><p>Nowadays, many national or international projects are facing such a situation, in particular any project targeting scientific data integration will have to address this heterogeneity, for example: the German DFG project FAIR Data Infrastructure for Condensed-Matter Physics and the Chemical Physics of Solids (FAIRmat<ref type="foot" target="#foot_0">1</ref> ) aiming to integrate and make accessible and reusable the enormous amount of data on materials (basic and applied science and engineering) produced in recent years; the French ANR project Data to Knowledge in Agronomy and Biodiversity (D2KAB<ref type="foot" target="#foot_1">2</ref> ) aiming to create a framework to turn agronomy and biodiversity data into an integrated, interoperable and open knowledge graph; the European ERIC project Analysis and Experimentation on Ecosystems (AnaEE<ref type="foot" target="#foot_2">3</ref> ) aiming to integrate all the steps of the scientific experimental methods, modelling and experimentation in order to understand the impact of change drivers on terrestrial and aquatic continental ecosystems across Europe; etc. A common challenge in the development of such research infrastructures (RI) is to provide a unique entry point to the databases provided by the project partners; these are most of the time hugely heterogeneous, not only regarding the data they store and their schemas, but also regarding the servers chosen to store and serve them and the practices adopted by the research teams in charge of configuring them and managing their creation and maintenance.</p><p>Thus, the main research question of this article is: do URI parameters provide an effective way to improve and extend <software>SPARQL</software>-based interaction between Web clients and services? It entails two specific subquestions : can URI parameters allow <software ContextAttributes="used">SPARQL</software>-based interactions that could not be done before? and can URI parameters make existing <software ContextAttributes="used">SPARQL</software>-based interactions more efficient in time, space, etc.?</p><p>To answer these questions, this article is organized as follows: Section 2 discusses related work on the parameterization of client/server exchanges in the context of <software>SPARQL</software> services. Section 3 presents the general principle of our approach to customize the behavior of <software ContextAttributes="used">SPARQL</software> services and clients. The three next sections start from what is already possible to do in terms of parameterization with the standards, and gradually build on it to provide controls over the behaviors of both the client and the server components of a <software ContextAttributes="used">SPARQL</software> exchange. Section 7 presents some experiments that we conducted to validate and demonstrate our approach. Section 8 draws some conclusions and gives directions for future work.</p></div>
<div><head n="2">RELATED WORK</head><p>Nowadays, there are many <software ContextAttributes="used">SPARQL</software> endpoints and most of them suffer from partial coverage of the <software ContextAttributes="used">SPARQL</software> query language together with a lack of availability for a great majority of them, as reported by <ref type="bibr" target="#b5">(Buil-Aranda et al., 2013)</ref>. In addition, one recurring problem when dealing with <software ContextAttributes="used">SPARQL</software> endpoints is the limitation of the server's resources allocated to each individual query, often leading to timeouts, errors if the queries were too complex, or even incomplete results. To circumvent these limitations some efforts have been made to set up alternative solutions to the "traditional" <software ContextAttributes="used">SPARQL</software> endpoints such as the <software ContextAttributes="used">SaGe</software> initiative by Minier et al. which relies on Web preemption <ref type="bibr" target="#b15">(Minier et al., 2019)</ref>. Others like C. <ref type="bibr" target="#b6">Buil-Aranda et al. (Buil-Aranda et al., 2014)</ref> propose to split the query into pieces so as to respect the various quotas of the distant <software ContextAttributes="used">SPARQL</software> server. Another approach tackles the challenge the other way around by providing specific interfaces, named Linked Data Fragments <ref type="bibr" target="#b12">(Hartig et al., 2017)</ref> to access the datasets which can then be chosen by users depending on their needs. For example, in the Triple Pattern Fragments approach <ref type="bibr" target="#b20">(Verborgh et al., 2016)</ref>, the server only evaluates triple patterns. However, these fragment approaches generate a large number of subqueries and substantial data transfer.</p><p>Unfortunately, all these methods are applied after reaching these limitations. We aim at preventing these situations. We propose to consider that a wide set of URI parameters -to tune the server's behavior-could prevent these issues by providing <software>SPARQL</software> practitioners with the useful tools. Moreover, we also introduce URI parameters to be interpreted by the client too; which is, to the best of our knowledge, unprece-dented. In particular, we focus our effort (and validate it) on the parameterization of federated querying using the <software ContextAttributes="used">SPARQL</software> SERVICE clause 4 .</p><p>Technically, <software>SPARQL</software> 1.1 Graph Store HTTP Protocol 5 defines a mean for updating and fetching RDF graph content from a Graph Store over HTTP in the REST style. For example the following: DELETE /rdf -graph -store ? graph =&lt; graph_uri &gt; HTTP /1.1 Host : examp . le would be the equivalent of the following <software ContextAttributes="used">SPARQL</software> 1.1. Update operation:</p><formula xml:id="formula_0">DROP GRAPH &lt; graph_uri &gt;</formula><p>As a consequence, some <software ContextAttributes="used">SPARQL</software> engines such as <software ContextAttributes="used">GraphDB</software> 6 , <software ContextAttributes="used">Fuseki</software> 7 or BrightStarDB 8 rely on this to let the <software ContextAttributes="used">SPARQL</software> practitioners slightly tune the queries with additional parameters. Typically, practitioners are e.g. able to select the return format of a query using output=xml to obtain RDF/XML. In addition, <software ContextAttributes="used">GraphDB</software> also provides some additional features for internal federation 9 which unfortunately does not comply with the <software ContextAttributes="used">SPARQL</software> 1.1 standard anymore, at the time of writing of this article, in June 2021. Other solutions like RDF4J 10 <ref type="bibr" target="#b4">(Broekstra et al., 2002)</ref>, <software ContextAttributes="used">Virtuoso</software> 11 <ref type="bibr" target="#b8">(Erling and Mikhailov, 2010)</ref>, <software ContextAttributes="used">Anzo</software> 12 or also <software ContextAttributes="used">BlazeGraph</software> 13 extend the set of possible parameters. For example, RDF4J allows the practitioner to add timeout or limit; with explain, <software ContextAttributes="used">BlazeGraph</software> enables a mode where the query results are extended with explanations of the query plan. When compared to these approaches, we notice that, while these <software ContextAttributes="used">SPARQL</software> endpoint implementations support parameters, they remain specific to the server side and in particular the idea of using them in the context of <software ContextAttributes="used">SPARQL</software> SERVICE clauses is not widespread yet.</p><p>Alternatively to using the SERVICE keyword to access additional endpoints, one may use federated <software ContextAttributes="used">SPARQL</software> services which provide a unified access interface to a set of autonomous data sources. Their main objective is to transform a query posed on a federation of data sources into a query composed of the union of subqueries over individual data sources of the federation. In particular, Saleem et al. studied federated RDF query engines with web access interfaces <ref type="bibr" target="#b17">(Saleem et al., 2016)</ref>. So far, most of the ef-4 <software ContextAttributes="used">SPARQL</software> 1.1 Federated Query 5 Graph Store HTTP Protocol 6 <software ContextAttributes="used">GraphDB</software> compliance with the Graph Store HTTP Protocol 7 Jena <software ContextAttributes="used">Fuseki</software> endpoint configuration 8 BrightStarDB configuration 9 <software ContextAttributes="used">GraphDB</software> internal federation 10 RDF4J repository queries 11 <software ContextAttributes="used">Virtuoso</software> documentation 12 <software ContextAttributes="used">Anzo</software> endpoint configuration 13 <software ContextAttributes="used">BlazeGraph</software> rest API forts have been tackling challenges such as source selection or query planning and few implemented tools provide the practitioners with a way to configure the behaviour of the data sources' endpoints. For example, <software ContextAttributes="used">FedX</software> <ref type="bibr" target="#b18">(Schwarte et al., 2011)</ref> only provides setMaxExecutionTime to define the maximum time for the whole query.</p><p>Finally, regarding the technique we present about unifiying several endpoints under the same banner (see Section 6.1), it is worth mentioning that Comunica <ref type="bibr" target="#b19">(Taelman et al., 2018)</ref> does also provide a similar concept of querying several-at-once. However, Comunica requires practitioners to enter all the wanted sources' URLs<ref type="foot" target="#foot_3">14</ref> from the beginning when our implementation allows the description of a set of endpoints through the use of a dedicated vocabulary. In addition, Comunica does not set up a process to configure the endpoints' behaviors as we propose.</p></div>
<div><head n="3">GENERAL PRINCIPLE</head><p>We start with a reminder of the terms of the <software ContextAttributes="used">SPARQL</software> 1.1 Protocol<ref type="foot" target="#foot_4">15</ref> that describes a means for <software ContextAttributes="used">SPARQL</software> protocol clients to submit <software ContextAttributes="used">SPARQL</software> protocol operations (either query or update operations) to a <software ContextAttributes="used">SPARQL</software> protocol service. For brevity, from now on we will omit the protocol term, speaking simply of <software ContextAttributes="used">SPARQL</software> client, <software ContextAttributes="used">SPARQL</software> operation and <software ContextAttributes="used">SPARQL</software> service. We will use the term <software ContextAttributes="used">SPARQL</software> query to denote a <software ContextAttributes="used">SPARQL</software> operation of type query. Furthermore, we will use the terms <software ContextAttributes="used">SPARQL</software> endpoint and <software ContextAttributes="used">SPARQL</software> service interchangeably. In the rest of the paper, we also use the term URL instead of URI because <software ContextAttributes="used">SPARQL</software> endpoints are identified and accessed using URLs.</p><p>A <software ContextAttributes="used">SPARQL</software> client submits a <software ContextAttributes="used">SPARQL</software> operation over HTTP to a <software ContextAttributes="used">SPARQL</software> service that handles the operation and sends the response back to the client. query operations may be submitted using either the HTTP GET or POST method, whereas update operations must be submitted using the POST method. When a <software ContextAttributes="used">SPARQL</software> query is submitted using the GET method, the URL includes, among other possible parameters, the URL-encoded <software ContextAttributes="used">SPARQL</software> query parameter. For instance, the following URL conveys a <software ContextAttributes="used">SPARQL</software> query to a <software ContextAttributes="used">SPARQL</software> service to get all its triples<ref type="foot" target="#foot_5">16</ref> : http :// e.g/ sparql ? query = select * where {? x ?p ?y}</p><p>We propose to use the standard mechanism of URL-encoded query string parameters as a common means to tune the behavior of <software>SPARQL</software> clients and servers involved in an HTTP exchange. Newly defined parameters may pertain to different aspects of the submitted <software ContextAttributes="used">SPARQL</software> operation, such as query planning, authentication, output format, or execution traces. For instance, we can amend the previous example URL to instruct the service to provide some execution traces: http :// e.g/ sparql ?log_level log_level log_level = debug &amp; query = select * where {? x ?p ?y}</p><p>This use of parameters in the URL of an HTTP query is "natural" in the sense that the parameters are interpreted by the service being invoked. We call them "server-side" parameters and explore them in Section 4. We propose to complement this approach with a set of "client-side" parameters in the URL of an HTTP query, meant to tune the behavior of the <software>SPARQL</software> client that initiates the exchange. As far as we know, this is the first documented case of usage of URL parameters for tuning <software ContextAttributes="used">SPARQL</software> clients and it is detailed in Section 5. The primary use case that we foresee is when the <software ContextAttributes="used">SPARQL</software> client is processing a federated query. Within a federated <software ContextAttributes="used">SPARQL</software> query, the SERVICE keyword instructs the query processor to invoke (a portion of) the <software ContextAttributes="used">SPARQL</software> query against a remote <software ContextAttributes="used">SPARQL</software> endpoint identified by its URL. 17 Our rationale here is to tune the behavior of the <software ContextAttributes="used">SPARQL</software> federated query processor that takes the role of a <software ContextAttributes="used">SPARQL</software> client with respect to the remote <software ContextAttributes="used">SPARQL</software> services it federates, by adding query string parameters to the URL of the remote endpoint in a SERVICE clause. For example, if we know that a remote endpoint does not support the HTTP POST method, we can instruct the federated query processor to use only the GET method to communicate with it: SERVICE &lt; http :// e.g/ sparql ?method method method =get &gt; { SELECT * WHERE {? x ?p ?y} }</p><p>Other methods could be figured out to pass such parameters to the <software>SPARQL</software> federated query processor, in the form of <software ContextAttributes="used">SPARQL</software> extensions, for instance using Java-like annotations (introduced with the '@' character). Yet, this would make the <software ContextAttributes="used">SPARQL</software> query invalid for processors that do not support this extension.</p><p>The main interest of using query string parameters in the URL of the SERVICE clause of a <software>SPARQL</software> federated query is that the query remains syntactically fully <software ContextAttributes="used">SPARQL</software>-compliant. Finally, in the continuation of this incremental enrichment of the <software ContextAttributes="used">SPARQL</software> 1.1 Protocol, we propose to also leverage URL parameters as a means to control the behavior of what we call "extended 17 https://www.w3.org/TR/sparql11-federated-query/ <software ContextAttributes="used">SPARQL</software>-based services". Such services are invoked with regular <software ContextAttributes="used">SPARQL</software> query operations, but their behavior differs from regular <software ContextAttributes="used">SPARQL</software> services in that their output may be different from regular <software ContextAttributes="used">SPARQL</software> query results, or they may implement a custom service logic fulfilling specific needs. Typically, a <software ContextAttributes="used">SPARQL</software> federated query processor can be such an extended <software ContextAttributes="used">SPARQL</software>-based service: it takes as an input a <software ContextAttributes="used">SPARQL</software> query, rewrites it into a federated query, communicates with remote <software ContextAttributes="used">SPARQL</software> services to evaluate the query, then returns the <software ContextAttributes="used">SPARQL</software> results. Although its interface complies with that of a <software ContextAttributes="used">SPARQL</software> service, it implements a different logic and therefore may require additional parameters to properly tune its behavior. Another example is that of a service that evaluates an input <software ContextAttributes="used">SPARQL</software> query, applies a custom transformation to the results (e.g. generates an HTML page), and returns the result of this transformation instead of the <software ContextAttributes="used">SPARQL</software> query results. For instance, the following URL asks an extended and named <software ContextAttributes="used">SPARQL</software>-based service to get all its triples and transforms the results in XML format into, by using an XSLT transformation. In the next three sections we will present in details the three patterns of URL parameters for <software ContextAttributes="used">SPARQL</software>:</p><p>• Parameters that modify the behavior of a <software>SPARQL</software> service in Section 4;</p><p>• Parameters that modify the behavior of a <software>SPARQL</software> client, focusing on the case of federated querying using SERVICE clauses, in Section 5;</p><p>• Parameters that impact the behavior of a named extended <software>SPARQL</software>-based service in Section 6.</p><p>The list of all the URL parameters presented in the paper is given in Table <ref type="table" target="#tab_0">1</ref>. It is worth noticing 1) that this is not a closed list and that other URL parameters may be introduced following the same approach to answer new needs, and that 2) the same parameter can modify both the behavior of a service and the behavior of the client, for instance enforcing the format in which a result will be serialized on one side and parsed on the other side. This is notably the case every time a parameter concerns some aspect of the communication (HTTP method, representation format, etc.). As a result, such parameters will appear in both Section 4 and Section 5 where their impact on the behaviors will be explained respectively for the service side and the client side. Yet it can be noticed that, while many SPARQL endpoint implementations support parameters (<software ContextAttributes="used">Virtuoso</software>, <software ContextAttributes="used">BlazeGraph</software>, etc.), the idea of using them in the context of <software ContextAttributes="used">SPARQL</software> SERVICE clauses is not widespread yet. In this section, we first want to establish the interest of these parameters in the context of a SERVICE clause and then propose several new parameters for <software ContextAttributes="used">SPARQL</software> query and update operations.</p><p>The default-graph-uri and the named-graph-uri parameters provide an immediate and standard example as they are defined in the <software>SPARQL</software> 1.1 Protocol to specify the dataset to be used by a <software ContextAttributes="used">SPARQL</software> service in solving a query. In the context of a SERVICE clause, this ability addresses an important limitation of the <software ContextAttributes="used">SPARQL</software> query language that does not support the declarative specification of the dataset for such a clause: FROM and FROM NAMED are not supported at the SERVICE clause level in <software ContextAttributes="used">SPARQL</software>. Although this usage is neither documented in the standards nor widespread in online documentation, it is a perfect example from the standards of the impact of being able to parameterize the behavior of the invoked <software ContextAttributes="used">SPARQL</software> service directly through the URL query string.</p><p>The format parameter was introduced in our implementation to enable us to specify the format of the <software ContextAttributes="used">SPARQL</software> query result expected from the <software ContextAttributes="used">SPARQL</software> service (the <software ContextAttributes="used">SPARQL</software> update operation is not concerned). The motivating scenario is that, in a perfect Web, <software ContextAttributes="used">SPARQL</software> services all support content negotiation and provide correctly formatted results, but in the World Wild Web, <software ContextAttributes="used">SPARQL</software> services may have limitations or bugs in their content negotiation or serializer implementations. The value of a format parameter is a media type<ref type="foot" target="#foot_6">18</ref> . If set, this parameter overrides values provided by the optional HTTP Accept header, if any, and thus bypasses any content negotiation process. For instance, the following URL asks a <software ContextAttributes="used">SPARQL</software> service to provide all its triples in the JSON-LD format.</p><p>http :// e.g/ sparql ?format format format = application / ld + json &amp; query = select * where {? x ?p ?y}</p><p>The access parameter introduced in our implementation enables us to enforce a key-based access control policy on <software>SPARQL</software> services. The motivating scenario is that, in a perfect Web, <software ContextAttributes="used">SPARQL</software> services should serve open data at will to all users, but in the World Wild Web, some private or critical <software ContextAttributes="used">SPARQL</software> services need to limit their access to authorized users for security and privacy concerns or to avoid saturation. Typically, a <software ContextAttributes="used">SPARQL</software> service running in protected mode will not process an HTTP query operation unless this request is parameterized with an authentication key that was delivered by the <software ContextAttributes="used">SPARQL</software> service manager to the authorized users. For instance, the following URL can be used by an authorized user to submit a <software ContextAttributes="used">SPARQL</software> query to a <software ContextAttributes="used">SPARQL</software> service while passing the authentication key a6h3fb58Fbd3:</p><p>http :// e.g/ sparql ?access access access =a6h3fb58Fbd3 a6h3fb58Fbd3 a6h3fb58Fbd3 &amp; query = select * where {? x ?p ?y}</p><p>Note that other authentication and/or authorization mechanisms may be required. For instance, Section 5 describes how a header parameter can pass a security token via the standard Authorization HTTP header.</p><p>The log level parameter was introduced in our implementation to enable us to instruct <software>SPARQL</software> services to turn on the generation of execution traces.</p><p>The motivating scenario is that, in a perfect Web, <software>SPARQL</software> services should always receive <software ContextAttributes="used">SPARQL</software> queries implementing the actual user need and serve the expected data, but in the World Wild Web, some unexpected or missing data may be delivered by a <software ContextAttributes="used">SPARQL</software> service, and like for any program, execution traces are highly valuable to understand abnormal behavior, detect bugs in the service or modify the <software ContextAttributes="used">SPARQL</software> query sent to it. An example URL containing a log level=debug parameter is provided in Section 3. The execution traces are produced in the <software ContextAttributes="used">SPARQL</software> service's logging system. Another implementation could choose to provide the client with such traces by means of the header's link field within XML or JSON <software ContextAttributes="used">SPARQL</software> results.</p></div>
<div><head n="5">URL PARAMETERS FOR SPARQL CLIENTS</head><p>In a perfect Web, all <software>SPARQL</software> services implement the full set of <software ContextAttributes="created">SPARQL</software> recommendations, have no timeout nor limited number of results, and perfectly comply with serialization specifications. In the World Wild Web, a <software ContextAttributes="created">SPARQL</software> service may support the HTTP GET method but not the POST method, or may be able to return a valid JSON document but an invalid XML document. Furthermore, public <software ContextAttributes="created">SPARQL</software> endpoints often limit the maximum number of results with quotas, such that a client would need to add the LIMIT and OFFSET modifiers to its <software ContextAttributes="created">SPARQL</software> query in order to incrementally get a complete result set. This is even more striking when federated querying. In the worstcase scenario, to evaluate the SERVICE clauses in a <software ContextAttributes="created">SPARQL</software> federated query, the <software ContextAttributes="created">SPARQL</software> query processor may need to adapt its behavior to the issues or limitations of each one of the <software ContextAttributes="created">SPARQL</software> remote services that the query involves. Unfortunately, <software ContextAttributes="created">SPARQL</software> does not allow specifying such a fine-tuning in a declarative manner. Therefore, in this section we consider the case where URL parameters are not only meant for the <software ContextAttributes="created">SPARQL</software> service being invoked but also, or rather, meant to modify the behavior of the <software ContextAttributes="created">SPARQL</software> client sending an HTTP request to a <software ContextAttributes="created">SPARQL</software> service or receiving its response. More precisely, in our implementation we have introduced several query string parameters in the URL of the SERVICE clause, that are interpreted by the <software ContextAttributes="created">SPARQL</software> federated query processor (the client) to tune its behavior -and that may also be interpreted by the remote <software ContextAttributes="created">SPARQL</software> service or simply be ignored.</p><p>The method parameter specifies the HTTP method (GET or POST) to be used by the federated query processor to submit a <software>SPARQL</software> query to a remote <software ContextAttributes="created">SPARQL</software> service. For instance, the URL in the following SERVICE clause can be used to ask the federated query processor (the client) to use the HTTP POST method to submit its query to the remote <software ContextAttributes="created">SPARQL</software> service -and to pass the authentication key a6h3fb58Fbd3. The remote <software ContextAttributes="created">SPARQL</software> service may use or ignore any of the parameters, in particular it can ignore the method parameter but enforce the authentication key: SERVICE &lt; http :// e.g/ sparql ?method method method =post post post &amp; access = a6h3fb58Fbd3 &gt; { ?x ?p ?y }</p><p>The format parameter specifies the media type of the query results returned by the <software>SPARQL</software> service. It may be used when the <software ContextAttributes="created">SPARQL</software> service does not support content negotiation and returns results in a fixed format. It may also be the counterpart of the server-side format parameter described in Section 4, that skips the content negotiation process and forces the <software ContextAttributes="created">SPARQL</software> service to return results in the specified media type. Accordingly, on the client side, this parameter instructs the <software ContextAttributes="created">SPARQL</software> federated query processor to select an appropriate parser for the results of a remote service without considering any content negotiation.</p><p>The log level parameter is the counterpart of the server-side log level parameter presented in Section 4. When federated querying, it instructs the client <software>SPARQL</software> federated query processor to turn on the generation of execution traces. This is particularly handy when drafting a <software ContextAttributes="created">SPARQL</software> federated query. Indeed, how a federated query processor rewrites each SERVICE clause, for instance by adding variable bindings, is implementation-dependent. The log level parameter can help query debugging by providing insight into the strategy adopted by the federated query processor when rewriting a certain SERVICE clause.</p><p>The header parameter specifies an HTTP header to be sent by the client <software>SPARQL</software> federated query processor to a remote <software ContextAttributes="created">SPARQL</software> service along with the <software ContextAttributes="created">SPARQL</software> operation. Each parameter value, formatted as name:value, will be passed as a header of the HTTP request. For instance, let us consider the following SERVICE clause: SERVICE &lt; http :// e.g/ sparql ?</p><p>header header header = Authorization : Basic YvcGVuc2VzY &gt; { ?s ?p ?o }</p><p>In this example, the value of parameter header is the HTTP Authorization request header with the Basic type and YvcGVuc2VzY for the credentials value. If the federated query processor uses the HTTP POST method to send the query to the remote <software>SPARQL</software> service, the HTTP request that it will send will look like this:</p><p>POST / sparql HTTP /1.1 Host : e.g Content -Type : application / sparql -query Authorization : Basic YvcGVuc2VzYW SELECT * WHERE { ?s ?p ?o } The limit parameter specifies a limit for the number of results returned by one service call. It instructs the client <software>SPARQL</software> federated query processor to add a LIMIT solution modifier to the query it submits to the remote <software ContextAttributes="created">SPARQL</software> service. For example, the URL in the following SERVICE clause tells the query processor to query the remote service for only its 100 first results for the graph pattern in the clause. SERVICE &lt; http :// e.g/ sparql ?limit limit limit =100 &gt; { ?s ?p ?o }</p><p>The timeout parameter specifies a time quota (in milliseconds) during which the client <software>SPARQL</software> federated query processor will wait for the remote <software ContextAttributes="created">SPARQL</software> service to respond. Once this timeout expires without receiving a response, the federated query processor deems the query as failed. Example: SERVICE &lt; http :// e.g/ sparql ?timeout timeout timeout =5000 &gt; {? s ?p ?o} For simplicity, we consider the connect and read timeouts at once, however they could be distinguished by introducing two different timeout parameters.</p><p>Binding-related parameters. The query plan and strategy adopted by a <software>SPARQL</software> federated query processor to evaluate a <software ContextAttributes="created">SPARQL</software> federated query is implementation-dependent. We introduced in our implementation a set of binding-related, client-side URL parameters to enable a <software ContextAttributes="created">SPARQL</software> practitioner to leverage prior knowledge about a <software ContextAttributes="created">SPARQL</software> service to help the client <software ContextAttributes="created">SPARQL</software> federated query processor to come up with a more efficient query plan.</p><p>The binding parameter specifies the way the client <software ContextAttributes="created">SPARQL</software> federated query processor should pass variable bindings to a remote <software ContextAttributes="created">SPARQL</software> service. Bindings coming from the evaluation of some graph pattern in the federated query are passed to a remote <software ContextAttributes="created">SPARQL</software> service in case the graph pattern it should evaluate shares in-scope<ref type="foot" target="#foot_7">19</ref> variables with the previously evaluated ones. The method used by a client <software ContextAttributes="created">SPARQL</software> federated query processor to pass variable bindings to a remote <software ContextAttributes="created">SPARQL</software> service is implementation-dependent. In a perfect Web, the "natural" way to pass bindings would be to use a VALUES block in the SERVICE clause. But, in the World Wild Web, some <software ContextAttributes="created">SPARQL</software> services do not implement the VALUES clause. Therefore, for the sake of interoperability, by default our implementation uses filters to pass bindings, and we defined a binding parameter to choose among both possible ways. For instance, let us consider the following federated query:</p><p>SELECT * WHERE { ?s ?p ?o. SERVICE &lt; http :// e.g/ sparql ?&gt; {? s ?q ?v. ?o ?q ?w }} and the intermediate variable binding coming from the evaluation of triple pattern ?s ?p ?o: {(?s , s1 ), (?p , p1 ), (?o , o1 )}</p><p>Adding parameter binding=filter to the URL of the SERVICE clause (the default behavior) will cause the federated query processor to generate the <software>SPARQL</software> code:</p><formula xml:id="formula_1">FILTER (? s = s1 &amp;&amp; ?o = o1 )</formula><p>Conversely, adding parameter binding=values will generate the <software>SPARQL</software> code:</p><formula xml:id="formula_2">VALUES (? s ?o) { ( s1 o1 ) }</formula><p>The binding focus and binding skip parameters specify a subset of variables for which variable bindings should or should not be passed to the service. In the example below, the bindings consider variable s and not variable o. The binding slice parameter enables to specify the number of distinct variable bindings sent within one service call. The set of variable bindings is split into subsets of size less than or equal to this number. The service is called once for each such subset of variable bindings. In our implementation, the default value of binding slice is 20. But one could, for instance, force one call per binding:</p><p>SELECT * WHERE { ?s ?p ?o. SERVICE &lt; http :// e.g/ sparql ?binding_slice binding_slice binding_slice =1 &gt; { ?s ?q ?o } }</p></div>
<div><head n="6">NAMED AND EXTENDED SPARQL-BASED SERVICES</head><p>In this section, we generalize on the server-side parameters approach of Section 4. We now propose to mint 20 URLs that identify and specify "extended <software>SPARQL</software>-based services", a kind of services invoked with regular <software ContextAttributes="created">SPARQL</software> query operations, but whose behavior differs from that of regular <software ContextAttributes="created">SPARQL</software> services in that their output may be different from regular <software ContextAttributes="created">SPARQL</software> query results, or they may implement a custom service logic fulfilling specific needs. Their URLs are minted to unambiguously name these services. We put a specific stress on this naming concern because what is at stake here is not just to figure out the URL to access such a service. We mean to use those URLs as URIs, free from any optional query component, identifying these services as firstclass resources, so that we can not only invoke these services, but also annotate them in RDF descriptions, and configure them with server-side URL parameters.</p></div>
<div><head n="6.1">The common case of SPARQL Federated Query Services</head><p>As federated querying over multiple sources is a very common and important use case in applications such as scientific data integration, this section makes a focus on <software>SPARQL</software> federated query services. In Section 5 we considered the client role of a <software ContextAttributes="created">SPARQL</software> federated query processor communicating with remote <software ContextAttributes="created">SPARQL</software> services to evaluate a <software ContextAttributes="created">SPARQL</software> federated query. Here we consider the service role of a <software ContextAttributes="created">SPARQL</software> federated query processor, serving its results to <software ContextAttributes="created">SPARQL</software> clients that ignore everything about the federation. We denote by "<software ContextAttributes="created">SPARQL</software> federated query service" a set of approaches implementing the federation of several <software ContextAttributes="created">SPARQL</software> services. These can be seen as extended <software ContextAttributes="created">SPARQL</software>-based services insofar as they take as input a regular <software ContextAttributes="created">SPARQL</software> query, but implement a service logic that differs from that of a regular <software ContextAttributes="created">SPARQL</software> service.</p><p>We defined a succinct vocabulary to declare in RDF a <software>SPARQL</software> federated query service. For instance the following RDF/Turtle configuration describes the X <software ContextAttributes="created">SPARQL</software> federated query service, identified by http://e.g/X/sparql, that federates three <software ContextAttributes="created">SPARQL</software> services.</p><p>prefix st : &lt; http :// e.g/ sparql -template /&gt; &lt; http :// e.g ./ X/ sparql &gt; a st : Federation ; st : definition ( &lt; http :// a.b/ blazegraph /Y/ sparql &gt; 20 Minting a URI is the act of establishing the association between the URI and the resource it denotes <ref type="bibr" target="#b0">(Allemang et al., 2020)</ref>.</p><p>&lt; https :// c.d/ fuseki / annotation / sparql &gt; &lt; http :// i.j/ repositories / sparql &gt; ) .</p><p>Below we present two examples of alternative implementations of such <software>SPARQL</software> federated query services that we developed and tested.</p><p>The first one receives a <software>SPARQL</software> query and sends it as is to the remote <software ContextAttributes="created">SPARQL</software> services that it federates, performs the union of partial results and aggregates, if any, and returns the results. The URLs of this first implementation continue to use the /sparql that appears in the URL of standard <software ContextAttributes="created">SPARQL</software> services to suggest that they do not change the query itself.</p><p>The second implementation is what is commonly referred to as a "federation engine". It starts by asking remote <software>SPARQL</software> services which properties and classes occur in their datasets and builds an index from the results. Then, using this index, it rewrites the <software ContextAttributes="created">SPARQL</software> query it received with SERVICE clauses. Each clause is targeting a <software ContextAttributes="created">SPARQL</software> service that, according to the index, may contain results for the triple patterns it specifies. To distinguish this second implementation from the first one, the endpoint URL is minted with /federate in its name: http :// e.g/X/federate federate federate ? query = select * where {? x ?p ?y}</p><p>Similarly to what we demonstrated in Section 4, like for any <software>SPARQL</software> service, we can tune the behavior of such a named <software ContextAttributes="created">SPARQL</software> federated query service by adding query string parameters to its URL:</p><p>The mode=provenance parameter enables to track the provenance of each result. For instance, the query below asks the D2KAB federated service to retrieve arboriculture sub-concepts from any of the federated endpoints.</p></div>
<div><head>SELECT DISTINCT * WHERE {</head><p>[] skos : prefLabel " arboriculture " @fr ; skos : narrower + [ skos : prefLabel ? lbl ]. }</p><p>We can submit it with the URL below, where the URL-encoded query is ommitted for clarity: http :// corese . inria . fr / d2kab / sparql ? mode mode mode = provenance &amp; query =...</p><p>Table <ref type="table" target="#tab_2">2</ref> shows a short subset of the results returned, where a pseudo-variable server is added to output the provenance of the variable bindings.</p><p>The accept and reject parameters specify a subset of the <software>SPARQL</software> services to be involved in the evaluation of the query submitted to the <software ContextAttributes="created">SPARQL</software> federated query service. The value of these parameters is Example query result when using the mode=provenance parameter. Variable server provides the URL of the service that yielded this variable binding. server lbl http://ontology.irstea.fr/bsv/sparql vigne de cuve http://ontology.inrae.fr/frenchcropusage/sparql abricotier a string pattern. The <software ContextAttributes="created">SPARQL</software> federated query service should skip the services in its federation whose URL matches the pattern value of the reject parameter and/or consider those whose URL matches the pattern value of the accept parameter. For instance, assuming that the federation configuration names the endpoints of several DBpedia chapters, to answer the <software ContextAttributes="created">SPARQL</software> query encoded in the following URL, the X <software ContextAttributes="created">SPARQL</software> federated query service should consider any DBpedia chapter except the French one.</p><p>http :// e.g/X/ sparql ?accept accept accept =dbpedia dbpedia dbpedia &amp;reject reject reject =dbpedia dbpedia dbpedia .fr fr fr &amp; query = select * where {? x ?p ?y}</p></div>
<div><head n="6.2">Extended SPARQL-based services for application integration</head><p>Generalizing on the previous example of <software>SPARQL</software> federated query services and data integration, we now report on a number of other extended services we experimented with in the more general context of Web application integration. The approach remains the same but is no longer focused on the problem of query federation: we mint URLs to unambiguously name a new service, to annotate it in RDF descriptions, to call it and to configure it with URL parameters.</p><p>RDF transformation services. The transform parameter enables us to turn a <software ContextAttributes="created">SPARQL</software> service into an RDF transformation service. In an ideal Web, everyone would be using the same transformation and rendering techniques and pipelines. In the World Wild Web, the loose coupling of applications and the variety of formats and presentation solutions requires flexible transformation means. A parameterized RDF transformation service returns the result of a transformation that could come from any existing approach such as XSLT <ref type="bibr" target="#b13">(Kay, 2021)</ref>, FRESNEL <ref type="bibr" target="#b16">(Pietriga et al., 2006)</ref> or STTL <ref type="bibr" target="#b7">(Corby et al., 2015)</ref>. For instance, the following parameterized service outputs the transformation of the query results into an HTML page.</p><p>http :// e.g/X/ sparql ?transform transform transform = st :rdf2html rdf2html rdf2html &amp; query = select * where {? x ?p ?y}</p><p>Another example is the generation of widgets exploiting dimensions of the data (time, location, etc.), for instance, a map with plots when the <software>SPARQL</software> query results contain longitude and latitude values.</p><p><software>SPARQL</software> query result annotation services. The mode=link parameter together with the transform parameter enable us to turn a <software ContextAttributes="created">SPARQL</software> service into a <software ContextAttributes="created">SPARQL</software> query result annotation service. The result of the transformation is stored in a document on the server, a URL is provided for this document and is returned as the value of the link element in the head of the <software ContextAttributes="created">SPARQL</software> query result. For example, the following parameterized service will generate a map with location longitude and latitude, and a link mode that adds the URL of the generated map in the head of the <software ContextAttributes="created">SPARQL</software> query result. SHACL services. In a perfect Web, the data sources we consume would be complete and would meet the level of quality we need. In the World Wild Web, data sources do not always match our criteria and we need means to check if the constraints we have are met. The mode=shacl parameter used in combination with the uri parameter enables to turn a <software ContextAttributes="created">SPARQL</software> service into a SHACL service that evaluate the shapes in the SHACL document, the URL of which is given as value of parameter uri, on the RDF graph it serves. Moreover, the query passed as parameter in the URL is executed on the SHACL validation report graph. For example, the following parameterized service will output the conformity boolean value.</p><p>http :// e.g/X/ sparql ?mode mode mode =shacl shacl shacl &amp;uri uri uri =shape shape shape .rdf rdf rdf &amp; query = select * where {? report sh : conforms ?b }</p><p>Service Definition Specifying a list of parameter values to define extended <software>SPARQL</software>-based services may be cumbersome for some developers and one may want to synthesize a specific list of parameter values within a specific mode. For this purpose, we defined a small vocabulary to enable the user to define in RDF new modes as the combination of several parameters that can be used to parameterize a service just like any predefined mode. For example, the following RDF description defines a map mode as the combination of the st:map transformation that generates a map with location longitude and latitude, and a link mode that adds the URL of the generated map in the head of the <software ContextAttributes="created">SPARQL</software> query result.</p><p>[] st : mode " map " ; st : param ((" mode " " link ")(" transform " st : map )) .</p><p>Developers can then use such defined modes to define an extended service. For example, the following parameterized service is equivalent to the example service illustrating the annotation services.</p><p>http :// e.g/X/ sparql ?mode mode mode =map map map &amp; query = select * where {? x ?p ?y} A generic mode, named "*", enables us to specify parameters that are shared by all the <software>SPARQL</software>-based services offered at a given <software ContextAttributes="created">SPARQL</software> service. For example, the following RDF description states that all the services will run in debug mode.</p><p>[] st : mode "*" ; st : param ((" mode " " debug ")) .</p><p>Services can also be described to associate them a parameter setting, so that the URL that should be used to invoke them will not have any query string parameter. For example, the following RDF description defines a service as parameterized by the (user-defined) map mode:</p><p>&lt; http :// e.g/ map / sparql &gt; st : param ((" mode " " map ")) .</p><p>Once defined like this it can be invoked without any other parameter than the standard query one: http :// e.g/map map map / sparql ? query = select * where {? x ?p ?y}</p></div>
<div><head n="7">EXPERIMENTS &amp; EVALUATION</head><p>The URL query string parameters presented in the previous sections have been implemented in the Corese Semantic Web factory. 21 In this section, we demonstrate their interest in the context of two example queries that originate from on-going scientific data integration projects. In particular, we show the impact of this parameterization against baseline queries solving the same issues in standard conditions. 21 https://project.inria.fr/corese/</p></div>
<div><head n="7.1">Binding variables: FILTER / VALUES</head><p>The following query searches the URIs of some spatial entities in a local dataset, and tries to fetch additional information about each of them from Wikidata using a SERVICE clause.</p><p>SELECT ?e ? label WHERE { [] dct : spatial ?e. SERVICE &lt; https :// query . wikidata . org / sparql &gt; { ?e rdfs : label ? label . FILTER ( lang (? label ) = " en ") }} When a <software>SPARQL</software> engine evaluates this query, a possible strategy is to first retrieve the values of variable e (91 distinct values in our case), then pass them to the SERVICE clause as variable bindings. The <software ContextAttributes="created">SPARQL</software> federated query recommendation does not specify the way to pass such bindings. A possible way is to pass them using a filter, i.e. the following query is submitted to Wikidata:</p><p>SELECT * WHERE { ?e rdfs : label ? label . FILTER ( lang (? label ) = " en ") FILTER ((? e= wd : Q6730 ) || (? e= wd : Q12589 ) || ...) }} Unfortunately, Wikidata systematically times out when evaluating such a query. 22 However, we can work around this issue using the binding URL parameter described in Section 5. When we add it to the Wikidata URL as depicted below, &lt; https :// query . wikidata . org / sparql ?binding binding binding =values values values &gt; we instruct our <software>SPARQL</software> engine to use a VALUES block instead of a FILTER. The rewritten query sent to Wikidata now completes in less than one second:</p><p>SELECT * WHERE { VALUES (? entity ) { ( wd : Q6730 ) ( wd : Q12589 ) ... } ?e rdfs : label ? label . FILTER ( lang (? label ) = " en ") }}</p></div>
<div><head n="7.2">Slicing variables bindings</head><p>In the same on-going projects, we identified a second use case that involves the following <software>SPARQL</software> federated query to match resources from two RDF sources using their names: In the first SERVICE clause, variable ?name is matched with 166 values. In the second SERVICE clause, variable ?fullname is matched with over 600,000 values. The second SERVICE clause cannot retrieve values for the ?name variable which is only used in the FILTER. Therefore, our implementation will start with the evaluation of the first SERVICE clause, and then pass the values of variable ?name as bindings to the second SERVICE clause. Furthermore, building on the experience of the use case described in Section 7.1, we added the parameter binding=values to perform the binding using a VALUES block rather than a FILTER.</p><p>The join between the two SERVICE clauses must be done on the ?name variable. Note however that, in the second SERVICE clause, ?name is not directly used as the term of a triple pattern but instead used in a string comparison (strstarts). This makes the query optimization much harder and, consequently, during our experimentations, the <software>Virtuoso</software> OS server at http://e2.g/sparql took in the order of 45 minutes to return the results.</p><p>We made further experiments to assess the number of values that can be passed in the VALUES block while keeping the query processing time below one minute. With one value, <software>Virtuoso</software> consistently took between 4s and 8s to respond. With two values, it took between 2min 30s and 3min. The more values, the longer it took to respond. Therefore, we added parameter binding slice=1 to pass the values of variable ?name one by one. The URL of the second SERVICE clause is as follows:</p><p>&lt; http :// e2 .g/ sparql ?binding binding binding = values &amp;binding_slice binding_slice binding_slice =1 &gt;</p><p>The whole query processing completed in approximately 21 minutes, which is roughly half of the time it took to process the query without the binding slice. The improvement may be deemed modest. It is however important to remind that with a public <software>SPARQL</software> endpoint, where the time quota is typically in the order of one minute, the initial query would never complete, whereas, with our method, it will take time but will complete eventually.</p><p>Without the URL query string parameters introduced in this paper and demonstrated in this section, it is hardly possible to obtain the results solely within <software>SPARQL</software>. Instead, the <software ContextAttributes="created">SPARQL</software> practitioner would have to code a hack in another language to circumvent the limitations. As a comparison, we developed a Python <software ContextAttributes="created">application</software> to achieve the same goal. Based on the <software ContextAttributes="created">SPARQLWrapper</software> library, the program evaluates the first SERVICE clause, stores the temporary results in a DataFrame, and submits the second SERVICE clause one value at a time. This does exactly the same that what we achieve declaratively with just one parameter: binding slice. While the <software ContextAttributes="created">SPARQL</software> query is 10 lines long, the Python <software ContextAttributes="created">program</software> is approximately 100 lines long. Besides, both solutions complete in a similar time since they submit the same number of queries.</p><p>Ultimately, this example also shows that beyond the federated querying use cases we used to demonstrate the interest of URL parameters in <software ContextAttributes="created">SPARQL</software>, this technique is also a way to provide customized proxies masking the limitations and specificities of <software ContextAttributes="created">SPARQL</software> service implementations and supporting the loose-coupling that make the Web an attractive application integration platform <ref type="bibr" target="#b9">(Fielding et al., 2017)</ref>.</p></div>
<div><head n="8">CONCLUSION</head><p>In a perfect Web, following standards would be enough. In the World Wild Web, the ability to tune, customize, parameterize the applications may make the difference between a running application and a frozen one. In this paper, we proposed a uniform way of adapting and customizing the behavior of both the client and the server components of an HTTP exchange to cope with the heterogeneity of implementations we find in Web applications. More specifically we designed and experimented the use of URL parameters to parameterize the behaviors of both the <software>SPARQL</software> client and the <software ContextAttributes="created">SPARQL</software> service, in particular in the context of SERVICE clauses used in <software ContextAttributes="created">SPARQL</software> federated queries. We believe that this method has the potential to make federated querying in <software ContextAttributes="created">SPARQL</software> more flexible, actionable, and suited to World Wild Web contexts, far beyond the examples that are generally demonstrated in ideal, controlled environments.</p><p>Another interesting general use case we did not develop here is the debugging of federated queries in the case where the query result is empty. It may be interesting to provide parameters such as mode=explain to obtain additional data such as intermediate query results that can be provided using linked results (mode=link). Hence, URL parameters could be used to tune a debugger.</p><p>In our future work, we also intend to study the relation of the extension we proposed with other parts of the <software ContextAttributes="created">SPARQL</software> standard such as the <software ContextAttributes="created">SPARQL</software> Service Description that "provides a mechanism by which a client or end user can discover information about the <software ContextAttributes="created">SPARQL</software> service" <ref type="bibr" target="#b21">(Williams, 2013)</ref>.</p><p>In the longer term, the annotation technique in-troduced by the mode=link parameter holds the huge potential to turn what are essentially one-off queries into entry points of a hypermedia network of queries. For instance, by providing links to reformulated or relaxed queries, expanded queries, suggested follow-up queries, etc., we would allow non <software>SPARQL</software> clients with classical Web client capabilities to still navigate and discover the content of endpoints as a classical Web hypermedia space just by applying the "follow your nose" principle.</p></div><figure xml:id="fig_0"><head /><label /><figDesc>https :// examp . le / search ? gname = doe &amp; fname = john</figDesc></figure>
<figure xml:id="fig_1"><head /><label /><figDesc>http :// e.g/transform transform transform / sparql ? format = text / xml &amp; transform transform transform =transfo transfo transfo .xsl xsl xsl &amp; query = select * where {? x ?p ?y}</figDesc></figure>
<figure type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Overview of URL parameters examples. Parameters in bold are part of the SPARQL protocol.</figDesc><table><row><cell>Parameter</cell><cell>Definition</cell></row><row><cell>default-graph-uri</cell><cell>specify the default named graph</cell></row><row><cell>named-graph-uri</cell><cell>specify the named graphs to use</cell></row><row><cell>format</cell><cell>specify expected result format</cell></row><row><cell>access</cell><cell>provide an access control key</cell></row><row><cell>log level</cell><cell>require logs of the execution</cell></row><row><cell>method</cell><cell>force the HTTP method to use</cell></row><row><cell>header</cell><cell>add an HTTP header</cell></row><row><cell>limit</cell><cell>maximum number of results</cell></row><row><cell>timeout</cell><cell>maximum time for a response</cell></row><row><cell>binding</cell><cell>specify variable binding method</cell></row><row><cell>binding focus</cell><cell>variables to pass in bindings</cell></row><row><cell>binding skip</cell><cell>variables not to pass in bindings</cell></row><row><cell>binding slice</cell><cell>size of bindings for each call</cell></row><row><cell>mode</cell><cell>generic behaviour customizing</cell></row><row><cell>accept</cell><cell>subset of federated services to be used</cell></row><row><cell>reject</cell><cell>subset of federated services not to be used</cell></row><row><cell>transform</cell><cell>apply a transformation to the data</cell></row><row><cell cols="2">4 URL PARAMETERS FOR</cell></row><row><cell cols="2">SPARQL SERVICES</cell></row></table><note><p>This first family of URL parameters is certainly the most natural, standard and common one. It aims at modifying the behavior of the <software>SPARQL</software> service being invoked: a <software ContextAttributes="created">SPARQL</software> service receiving a parameterized HTTP request should adapt its behavior and the returned answer according to the query parameters.</p></note></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>Alternatively, in the example below the bindings do not consider s and consider o only.</figDesc><table><row><cell>SELECT * WHERE {</cell></row><row><cell>?s ?p ?o.</cell></row><row><cell>SERVICE &lt; http :// e.g/ sparql ?binding_focus binding_focus binding_focus =s &gt;</cell></row><row><cell>{ ?s ?q ?o }</cell></row><row><cell>}</cell></row><row><cell>SELECT * WHERE {</cell></row><row><cell>?s ?p ?o.</cell></row><row><cell>SERVICE &lt; http :// e.g/ sparql ?binding_skip binding_skip binding_skip =s &gt;</cell></row><row><cell>{ ?s ?q ?o }</cell></row><row><cell>}</cell></row></table></figure>
<figure type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc /><table /></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>https://www.fair-di.eu/fairmat/proposal</p></note>
			<note place="foot" n="2" xml:id="foot_1"><p>http://www.d2kab.org/</p></note>
			<note place="foot" n="3" xml:id="foot_2"><p>https://www.anaee.eu/</p></note>
			<note place="foot" n="14" xml:id="foot_3"><p>Comunica endpoint over multiple sources</p></note>
			<note place="foot" n="15" xml:id="foot_4"><p>https://www.w3.org/TR/sparql11-protocol/</p></note>
			<note place="foot" n="16" xml:id="foot_5"><p>For readability, the <software>SPARQL</software> query is not URL-encoded.</p></note>
			<note place="foot" n="18" xml:id="foot_6"><p>https://www.iana.org/assignments/media-types/media-types.xhtml</p></note>
			<note place="foot" n="19" xml:id="foot_7"><p>https://www.w3.org/TR/sparql11-query/#variableScope</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGEMENTS</head><p>This work was partially supported by the <rs type="funder">French National Research Agency</rs> under grant <rs type="grantNumber">ANR-18-CE23-0017</rs> (<rs type="projectName">D2KAB</rs> project).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_SuCcJhN">
					<idno type="grant-number">ANR-18-CE23-0017</idno>
					<orgName type="project" subtype="full">D2KAB</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Semantic Web for the Working Ontologist</title>
		<author>
			<persName><forename type="first">D</forename><surname>Allemang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
			<publisher>ACM Books</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Web Futures: Inclusive, Intelligent, Sustainable The 2020 Manifesto for Web Science</title>
		<author>
			<persName><forename type="first">B</forename><surname>Berendt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Halford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Kinder-Kurlanda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Ntoutsi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staab</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Dagstuhl Manifestos</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Uniform resource identifier (URI): Generic syntax</title>
		<author>
			<persName><forename type="first">T</forename><surname>Berners-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Masinter</surname></persName>
		</author>
		<ptr target="http://www.rfc-editor.org/rfc/rfc3986.txt" />
	</analytic>
	<monogr>
		<title level="j">STD</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Information management: A proposal</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Berners-Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>CERN</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Sesame: A generic architecture for storing and querying RDF and RDF schema</title>
		<author>
			<persName><forename type="first">J</forename><surname>Broekstra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kampman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International semantic web conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="54" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">SPARQL web-querying infrastructure: Ready for action?</title>
		<author>
			<persName><forename type="first">C</forename><surname>Buil-Aranda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Umbrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-Y</forename><surname>Vandenbussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="277" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Strategies for executing federated queries in SPARQL 1.1</title>
		<author>
			<persName><forename type="first">C</forename><surname>Buil-Aranda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Umbrich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="390" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Generic RDF Transformation Software and its Application to an Online Translation Service for Common Languages of Linked Data</title>
		<author>
			<persName><forename type="first">O</forename><surname>Corby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faron-Zucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th International Semantic Web Conference</title>
		<meeting>14th International Semantic Web Conference<address><addrLine>Bethlehem, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ISWC</publisher>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Virtuoso: RDF support in a native RDBMS</title>
		<author>
			<persName><forename type="first">O</forename><surname>Erling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mikhailov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Semantic Web Information Management</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="501" to="519" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reflections on the rest architectural style and" principled design of the modern web architecture</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Fielding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Erenkrantz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Gorlick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Whitehead</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Khare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Oreizy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</title>
		<meeting>the 2017 11th Joint Meeting on Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="4" to="14" />
		</imprint>
	</monogr>
	<note>impact paper award</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Survey of the First 20 Years of Research on Semantic Web and Linked Data</title>
		<author>
			<persName><forename type="first">F</forename><surname>Gandon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Revue des Sciences et Technologies de l'Information -Série ISI</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<publisher>Ingénierie des Systèmes d'Information</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">SPARQL 1.1 Query Language</title>
		<author>
			<persName><forename type="first">S</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Seaborne</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/sparql11-query/" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Recommendation, W3C</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A formal framework for comparing linked data fragments</title>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Letter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ternational semantic web conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="364" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">XSL transformations (XSLT) version 2.0</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kay</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2021/REC-xslt20-20210330/" />
	</analytic>
	<monogr>
		<title level="m">W3C recommendation, W3C</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
	<note>second edition)</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Knublauch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Idehen</surname></persName>
		</author>
		<ptr target="https://www.w3.org/Submission/spin-overview/" />
		<title level="m">SPIN-overview and motivation</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>W3C.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">SaGe: Web preemption for public SPARQL query services</title>
		<author>
			<persName><forename type="first">T</forename><surname>Minier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Skaf-Molli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Molli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The World Wide Web Conference</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1268" to="1278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fresnel: A browser-independent presentation vocabulary for rdf</title>
		<author>
			<persName><forename type="first">E</forename><surname>Pietriga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="158" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A fine-grained evaluation of SPARQL endpoint federation systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Saleem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hasnain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Ermilov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-C</forename><surname>Ngonga Ngomo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="493" to="518" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fedx: Optimization techniques for federated query processing on linked data</title>
		<author>
			<persName><forename type="first">A</forename><surname>Schwarte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Haase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schenkel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ternational semantic web conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="601" to="616" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Comunica: a modular SPARQL query engine for the Web</title>
		<author>
			<persName><forename type="first">R</forename><surname>Taelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Herwegen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vander Sande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Verborgh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="239" to="255" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Triple Pattern Fragments: a low-cost knowledge graph interface for the Web</title>
		<author>
			<persName><forename type="first">R</forename><surname>Verborgh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Vander Sande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van Herwegen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Vocht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>De Meester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Haesendonck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Colpaert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="184" to="206" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Williams</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2013/REC-sparql11-service-description-20130321/" />
		<title level="m">SPARQL 1.1 service description. W3C recommendation, W3C</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>