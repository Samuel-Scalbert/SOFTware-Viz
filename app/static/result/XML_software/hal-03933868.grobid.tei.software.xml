<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Study of the Discovery and Redundancy of Link Keys Between Two RDF Datasets Based on Partition Pattern Structures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nacira</forename><surname>Abbas</surname></persName>
							<email>nacira.abbas@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université de Lorraine</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<addrLine>Loria</addrLine>
									<postCode>F-54000</postCode>
									<settlement>Nancy</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alexandre</forename><surname>Bazin</surname></persName>
							<email>alexandre.bazin@umontpellier.fr</email>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Université de Montpellier</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">LIRMM</orgName>
								<address>
									<postCode>F-34095</postCode>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jérôme</forename><surname>David</surname></persName>
							<email>jerome.david@inria.fr</email>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Université Grenoble Alpes</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Grenoble INP</orgName>
								<orgName type="institution" key="instit5">LIG</orgName>
								<address>
									<postCode>F-38000</postCode>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amedeo</forename><surname>Napoli</surname></persName>
							<email>amedeo.napoli@loria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Université de Lorraine</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<addrLine>Loria</addrLine>
									<postCode>F-54000</postCode>
									<settlement>Nancy</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Study of the Discovery and Redundancy of Link Keys Between Two RDF Datasets Based on Partition Pattern Structures</title>
					</analytic>
					<monogr>
						<idno type="ISSN">1613-0073</idno>
					</monogr>
					<idno type="MD5">CDE00920D373B253B1AC8A5055906820</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A link key between two RDF datasets 𝐷 1 and 𝐷 2 is a set of pairs of properties allowing to identify pairs of individuals 𝑥 1 and 𝑥 2 through an identity link such as x 1 owl ∶ sameAs x 2 . In this paper, relying on and extending previous work, we introduce an original formalization of link key discovery based on the framework of Partition Pattern Structures (pps). Our objective is to study and evaluate the redundancy of link keys based on the fact that owl:sameAs is an equivalence relation. In the pps concept lattice, every concept has an extent representing a link key candidate and an intent representing a partition of instances into sets of equivalent instances. Experiments show three main results. Firstly redundancy of link keys is not so significant in real-world datasets. Nevertheless, the link key discovery approach based on pps returns a reduced number of non redundant link key candidates when compared to a standard approach. Moreover, the pps-based approach is efficient and returns link keys of high quality.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>In this paper, we are interested in data interlinking whose objective is to discover identity links across two RDF datasets over the web of data <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b2">3]</ref>. The same real world entity can be represented in two RDF datasets by different subjects in RDF triples having the form (subject, property, object). Then, for cleaning data and providing data of better quality, it is meaningful to detect such identities. There are both numerical and logical approaches for discovering these identities. For example, interlinking methods have been implemented in systems such as LIMES <ref type="bibr" target="#b3">[4]</ref> and SILK <ref type="bibr" target="#b4">[5]</ref>. These systems use link specifications, i.e. rules that declare whether two IRIs should be linked. Link specifications can also be specified by users or learned from data <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8]</ref>.</p><p>In particular, link keys which are under investigation in this paper are special kinds of rules allowing to infer identity links between two RDF datasets. More formally, a link key is composed of two sets of pairs of properties ({(𝑝 𝑖 , 𝑞 𝑖 )} 𝑖 , {(𝑝 ′ 𝑗 , 𝑞 ′ 𝑗 )} 𝑗 ) associated with a pair of classes (𝑐 1 , 𝑐 2 ). Then, whenever an instance 𝑎 1 of class 𝑐 1 has the same (non empty) set of values as an instance 𝑏 1 of class 𝑐 2 , i.e. 𝑝 𝑖 (𝑎 1 ) = 𝑞 𝑖 (𝑏 1 ) for all pairs of properties in the first set (universal quantification), and shares at least one value for all pairs of properties in the second set (existential quantification), i.e. 𝑝 ′ 𝑗 (𝑎 1 ) ∩ 𝑞 ′ 𝑗 (𝑏 1 ) ≠ ∅, then 𝑎 1 and 𝑏 1 denote the same entity, i.e., an owl:sameAs relation can be established between 𝑎 1 and 𝑏 1 . More concretely, the expression k=({(designation,title)},{(designation,title),(creator,author)}, (Book,Novel))</p><p>states that whenever an instance 𝑎 of class Book has the same non empty values for the property designation as an instance 𝑏 of the class Novel for title, and that 𝑎 and 𝑏 share at least one value for the properties creator and author, then 𝑎 and 𝑏 denote the same entity a owl:sameAs link can be established between 𝑎 and 𝑏.</p><p>Link keys are not provided with the datasets and algorithms are designed for automatically discovering such link keys <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11]</ref>. Given two RDF datasets, these algorithms reduce the search space and focus on the discovery of "link key candidates" instead of checking every combination of pairs of properties and pairs of classes. The notion of a link key candidate -made precise below-involves maximality and closure. Following this line, natural links were established in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> between link key discovery and Formal Concept Analysis (FCA <ref type="bibr" target="#b11">[12]</ref>). Indeed, FCA appeared as a suitable framework for the discovery of link key candidates, which are then evaluated thanks to appropriate quality measures <ref type="bibr" target="#b8">[9]</ref>.</p><p>Given two RDF datasets, FCA is applied in <ref type="bibr" target="#b9">[10]</ref> to a binary table where rows correspond to pairs of individuals and columns to pairs of properties. The intent of a resulting concept corresponds to a link key candidate, which remains to be validated thanks to suitable quality measures. The extent of the concept includes the potential identity links between individuals. A generalization of the former approach is proposed in <ref type="bibr" target="#b10">[11]</ref>, which is based on pattern structures <ref type="bibr" target="#b12">[13]</ref> and which takes into account different pairs of classes at the same time in the discovery of link keys.</p><p>Actually, "good" link key candidates over two RDF datasets have to generate different and maximal link sets, i.e., a mapping between individuals which is "close to a bijection". However it appears that two different link key candidates may generate the same link set when the link set is considered as a partition w.r.t. the owl:sameAs equivalence relation. This means that these two link key candidates present a certain redundancy, and then they can be considered as equivalent and merged in a way to be defined. This redundancy can be detected thanks to the properties of owl:sameAs as an equivalence relation, i.e. reflexivity, symmetry, and transitivity. Then, the owl:sameAs relation generates partitions among pairs of individuals that can be used for reducing the number of potential link key candidates. Indeed, two candidates relying on the same partition are considered as redundant and can be merged. However, we do not have a concrete idea of the importance of such redundancy and we should find a way to measure it. This is one objective of this paper to try to materialize this redundancy and to measure its importance.</p><p>For doing so, taking inspiration from the work carried out in <ref type="bibr" target="#b13">[14]</ref> on the discovery of functional dependencies, we provide a formalization of link key discovery based on "partition pattern structures" (pps), which allow us to take into account sets of equivalent individuals w.r.t. owl:sameAs as partitions. Then, a pattern concept represents a link key candidate and the related partition induced by the candidate. This approach is able to retrieve all link key candidates as a set of "non redundant" link keys. Moreover, this link key discovery process based on pps is operational and original 1 . Actually, this is the first time that the characteristics of owl:sameAs as an equivalence relation are considered, and that the related partitions of pairs of individuals are directly used for defining link key candidates. Thanks to pps, we are able to define redundancy of link key candidates and we also introduce a new measure based on the size of partitions for evaluating the quality of the discovered candidates. Finally, the experiments proposed in the last part of this paper provide three main results. Firstly, the redundancy of link keys in real-world datasets appears to be not so significant. Nevertheless, the current link key discovery approach based on pps is efficient and returns a reduced number of non redundant link key candidates. Moreover, this pps-based approach returns link keys of very high quality when compared to competitors.</p><p>The summary of the paper is as follows. Section 2 presents some basics about link keys. Then the discovery of non-redundant link keys based on pattern structures and partition pattern structures is made precise in Section 3. A running example illustrates all these constructions. New quality measures related to non redundant link keys are defined in Section 4. Finally, experiments in Section 5 show the capability and efficiency of the pps-based approach in link key discovery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>This section introduces the basic definitions relative to data interlinking with link keys. We recall what an RDF dataset is and then we introduce two forms of link keys, namely link key expressions and link key candidates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">RDF Data</head><p>Definition 1 (RDF Dataset). Let 𝑈 denote a set of IRIs, i.e., "Internationalized Resource Identifiers", 𝐵 a set of blank nodes, i.e., "anonymous resources", and 𝐿 a set of literals, i.e., "string values".</p><p>An RDF dataset is a set of triples (𝑠, 𝑝, 𝑜) ∈ (𝑈 ∪ 𝐵) × 𝑈 × (𝑈 ∪ 𝐵 ∪ 𝐿).</p><p>Let 𝐷 be an RDF dataset, 𝑆(𝐷) = {𝑠 | ∃ 𝑝, 𝑜 (𝑠, 𝑝, 𝑜) ∈ 𝐷} denotes the set of individual identifiers, 𝑃(𝐷) = {𝑝 | ∃ 𝑠, 𝑜 (𝑠, 𝑝, 𝑜) ∈ 𝐷} the set of property identifiers, and 𝐶(𝐷) = {𝑐 | ∃ 𝑠 (𝑠, rdf:type, 𝑐) ∈ 𝐷} the set of class identifiers.</p><p>Moreover, 𝐼 (𝑐) = {𝑠 | ∃ 𝑠 (𝑠, rdf:type, 𝑐) ∈ 𝐷} denotes the set of instances of 𝑐 ∈ 𝐶(𝐷) while 𝑝(𝑠) = {𝑜 | (𝑠, 𝑝, 𝑜) ∈ 𝐷} denotes the set of objects -or values-associated with 𝑠 through property 𝑝.</p><p>An identity link is an RDF triple of the form (𝑎, owl:sameAs, 𝑏) stating that the IRIs 𝑎 and 𝑏 are referring to the same entity, alternatively 𝑎 and 𝑏 are denoting the same individual.</p><p>Example 1. In Figure <ref type="figure">1</ref>, the RDF datasets 𝐷 1 and 𝐷 2 include 𝑃(𝐷 1 ) = {𝑝 1 , 𝑝 2 , 𝑝 3 , 𝑝 4 } and 𝑃(𝐷 2 ) = {𝑞 1 , 𝑞 2 , 𝑞 3 , 𝑞 4 } as sets of property identifiers, and 𝐶(𝐷 1 ) = {𝑐 1 } and 𝐶(𝐷 2 ) = {𝑐 2 } as class identifiers. In addition, 𝐼 (𝑐 1 ) = {𝑎 1 , 𝑎 2 , 𝑎 3 , 𝑎 4 , 𝑎 5 } and 𝐼 (𝑐 2 ) = {𝑏 1 , 𝑏 2 , 𝑏 3 , 𝑏 4 , 𝑏 5 } denote respectively the sets of instances of class 𝑐 1 and class 𝑐 2 . Finally, considering subject 𝑏 3 and property 𝑞 2 , the related set of objects or the "value" of 𝑏 3 for property 𝑞 2 is 𝑞 2 (𝑏 3 ) = {𝑜 8 , 𝑜 9 }. 1 The present paper extends a short preliminary version published in <ref type="bibr" target="#b14">[15]</ref>.</p><formula xml:id="formula_0">𝑎 1 𝑎 2 𝑎 3 𝑎 4 𝑎 5 𝑜 1 𝑜 2 𝑜 3 𝑜 4 𝑜 5 𝑜 6 𝑜 7 𝑜 8 𝑜 9 𝑜 10 𝑜 11 𝑜 12 𝑜 13 𝑏 1 𝑏 2 𝑏 3 𝑏 4 𝑏 5 𝑝1 𝑞 1 𝑝2 𝑞 2 𝑝 2 𝑞 2 𝑝1 𝑞1 𝑝 2 𝑞 2 𝑝 1 𝑞1 𝑝 1 𝑞 1 𝑝 2 𝑞2 𝑞2 𝑝 3 𝑞3 𝑝 4 𝑞 4 𝑝 3 𝑞 3 𝑝 4 𝑞 4 𝑐 1 𝑐 2 𝐷 1 𝐷 2 Figure 1:</formula><p>An example of two related RDF datasets. On the left-hand side, the dataset 𝐷 1 is populated with instances of class 𝑐 1 while on the right-hand side the dataset 𝐷 2 is populated with instances of class 𝑐 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Link Keys</head><p>Link keys are logical constructions allowing to infer identity links between instances of two classes lying in two RDF datasets. In the following we introduce two syntactic definitions of link keys, namely "link key expressions" and "link key candidates". A definition of a link key and its semantics using Description Logics interpretation is proposed in <ref type="bibr" target="#b15">[16]</ref>. However, in this paper we will stick to these two syntactic definitions for the sake of simplicity. Intuitively, a link key expression 𝑘 = (𝐸𝑞, 𝐼 𝑛, (𝑐 1 , 𝑐 2 )) is composed of two sets of pairs of properties, i.e., 𝐸𝑞 and 𝐼 𝑛, where 𝐸𝑞 is based on equality and 𝐼 𝑛 on non empty intersection, while links are generated between instances of classes 𝑐 1 and 𝑐 2 . More formally we have: Definition 2 (Link key expression). Let 𝐷 1 and 𝐷 2 be two RDF datasets, 𝑘 = (𝐸𝑞, 𝐼 𝑛, (𝑐 1 , 𝑐 2 )) is a link key expression over 𝐷 1 and 𝐷 2 iff 𝐼 𝑛 ⊆ 𝑃(𝐷 1 ) × 𝑃(𝐷 2 ), 𝐸𝑞 ⊆ 𝐼 𝑛, 𝑐 1 ∈ 𝐶(𝐷 1 ) and 𝑐 2 ∈ 𝐶(𝐷 2 ).</p><p>The set of links generated by 𝑘 is denoted by 𝐿(𝑘) and includes a set of pairs of instances (𝑎, 𝑏) ∈ 𝐼 (𝑐 1 ) × 𝐼 (𝑐 2 ) satisfying:</p><p>(i) for all (𝑝, 𝑞) ∈ 𝐸𝑞, 𝑝(𝑎) = 𝑞(𝑏) and 𝑝(𝑎) ≠ ∅, (ii) for all (𝑝, 𝑞) ∈ 𝐼 𝑛 ⧵ 𝐸𝑞, 𝑝(𝑎) ∩ 𝑞(𝑏) ≠ ∅.</p><p>The number of link key expressions may be exponential w.r.t. the number of properties. To reduce the search space, algorithms for link key discovery only consider "link key candidates", i.e., link key expressions which generate at least one link and which are "maximal" among the set of link key expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PS objects (g) descriptions (𝛿(𝑔))</head><formula xml:id="formula_1">(𝑎 1 , 𝑏 1 ) {∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )} (𝑎 1 , 𝑏 2 ) {∃(𝑝 2 , 𝑞 2 )} (𝑎 2 , 𝑏 1 ) {∃(𝑝 1 , 𝑞 1 )} (𝑎 2 , 𝑏 2 ) {∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )} (𝑎 3 , 𝑏 3 ) {∀(𝑝 1 , 𝑞 1 ), ∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )} (𝑎 4 , 𝑏 4 ) {∀(𝑝 3 , 𝑞 3 ), ∃(𝑝 3 , 𝑞 3 )} (𝑎 4 , 𝑏 5 ) {∀(𝑝 4 , 𝑞 4 ), ∃(𝑝 4 , 𝑞 4 )} (𝑎 5 , 𝑏 4 ) {∀(𝑝 4 , 𝑞 4 ), ∃(𝑝 4 , 𝑞 4 )} (𝑎 5 , 𝑏 5 ) {∀(𝑝 3 , 𝑞 3 ), ∃(𝑝 3 , 𝑞 3 )}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 1</head><p>The pattern structure related to datasets 𝐷 1 and 𝐷 2 given in Fig. <ref type="figure">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Link key candidate). A link key expression</head><formula xml:id="formula_2">𝑘 1 = (𝐸𝑞 1 , 𝐼 𝑛 1 , (𝑐 1 , 𝑐 2 )) is a link key candidate if: (i) 𝐿(𝑘 1 ) ≠ ∅,<label>(</label></formula><p>ii) there does not exist another link key expression</p><formula xml:id="formula_3">𝑘 2 = (𝐸𝑞 2 , 𝐼 𝑛 2 , (𝑐 1 , 𝑐 2 )) over 𝐷 1 and 𝐷 2 such that 𝐸𝑞 1 ⊂ 𝐸𝑞 2 , 𝐼 𝑛 1 ⊂ 𝐼 𝑛 2 , and 𝐿(𝑘 1 ) = 𝐿(𝑘 2 ).</formula><p>For example, consider the expressions 𝑘 1 and 𝑘 2 :</p><p>(i)</p><formula xml:id="formula_4">𝑘 1 = ({(𝑝 1 , 𝑞 1 )}, {(𝑝 1 , 𝑞 1 ), (𝑝 2 , 𝑞 2 )}, (𝑐 1 , 𝑐 2 )), (ii) 𝑘 2 = ({(𝑝 1 , 𝑞 1 )}, {(𝑝 1 , 𝑞 1 )}, (𝑐 1 , 𝑐 2 )). The related link sets are 𝐿(𝑘 1 ) = 𝐿(𝑘 2 ) = {(𝑎 3 , 𝑏 3 )}.</formula><p>Then 𝑘 1 and 𝑘 2 are both link key expressions but only 𝑘 1 is a link key candidate as it is maximal on the link set {(𝑎 3 , 𝑏 3 )} while 𝑘 2 is not.</p><p>The set of link key expressions is denoted by lke, the set of link key candidates by lkc, and we have that lkc ⊆ lke. The definition of link key candidates is based on the idea of maximality which involves a certain form of closure. This gave rise to a number of papers studying the potential relations existing between Formal Concept Analysis (FCA <ref type="bibr" target="#b11">[12]</ref>) and the discovery of link keys <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. Following the same line, we make precise in the next section two ways of discovering link key candidates based on two extensions of FCA, pattern structures <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b16">17]</ref> and partition pattern structures <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">From Link Keys to Non Redundant Link Keys</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Discovering Link Keys with Pattern Structures</head><p>In this section we shortly recall how pattern structures can be used in the discovery of link keys (details can be read in <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b17">18]</ref>). For the sake of simplicity and readability, we rely on a motivating example. Then we show how "Partition Pattern Structures" <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b18">19]</ref> allow to discover the so-called "non-redundant link key candidates" denoted as nrlkc.</p><p>Example 2. Let us consider the pattern structure lkps = (𝐺, (𝐸, ⊓), 𝛿) displayed in Table <ref type="table">1</ref>. All details for building lkps and the associated pattern concept lattice are given in <ref type="bibr" target="#b10">[11]</ref>. In the rows ("PS objects"), 𝐺 includes pairs of related instances, i.e., (𝑎 𝑖 , 𝑏 𝑗 ) with 𝑎 𝑖 ∈ 𝐼 (𝑐 1 ) and 𝑏 𝑗 ∈ 𝐼 (𝑐 2 ), which correspond to the objects of lkps. The set of potential descriptions (𝐸, ⊓) includes all possible pairs of properties preceded either by ∀ or ∃. For the sake of simplicity, the ⊓ operator corresponds here to set intersection. The mapping 𝛿 relates a pair of instances (𝑎, 𝑏) ∈ 𝐼 (𝑐 1 ) × 𝐼 (𝑐 2 ) to a description as follows: (i) 𝛿(𝑎, 𝑏) includes ∀(𝑝, 𝑞) whenever 𝑝(𝑎) = 𝑞(𝑏) and 𝑝(𝑎) ≠ ∅, (ii) 𝛿(𝑎, 𝑏) includes ∃(𝑝, 𝑞) whenever 𝑝(𝑎) ∩ 𝑞(𝑏) ≠ ∅. Actually, such descriptions correspond to link key expressions w.r.t. the pairs of classes (𝑐 1 , 𝑐 2 ). In this work, we only consider the pair of classes 𝑐 1 and 𝑐 2 , while dealing with several pairs of classes is explained in <ref type="bibr" target="#b10">[11]</ref>.</p><p>Based on Fig. <ref type="figure">1</ref>, the description of 𝛿(𝑎 1 , 𝑏 1 ) is given by</p><formula xml:id="formula_5">{∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )} because 𝑝 1 (𝑎 1 ) ∩ 𝑞 1 (𝑏 1 ) ≠ ∅ and 𝑝 2 (𝑎 1 ) ∩ 𝑞 2 (𝑏 1 ) ≠ ∅, while 𝛿(𝑎 2 , 𝑏 1 ) = {∃(𝑝 1 , 𝑞 1 )} because 𝑝 1 (𝑎 2 ) ∩ 𝑞 1 (𝑏 1 ) ≠ ∅.</formula><p>Then, 𝛿(𝑎 1 , 𝑏 1 ) ⊓ 𝛿(𝑎 2 , 𝑏 1 ) = {∃(𝑝 1 , 𝑞 1 )} and thus 𝛿(𝑎 2 , 𝑏 1 ) ⊑ 𝛿(𝑎 1 , 𝑏 1 ). This can be read in the pattern concept lattice displayed in Fig. <ref type="figure">2</ref> where the pattern concept 𝑝𝑐 5 is subsumed by the pattern concept 𝑝𝑐 4 , i.e., the intent {∃(𝑝 1 , 𝑞 1 )} of 𝑝𝑐 4 is included in the intent {∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )} of 𝑝𝑐 5 , while the extent {(𝑎 1 , 𝑏 1 ), (𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} of 𝑝𝑐 5 is included in the extent of 𝑝𝑐 4 which is {(𝑎 1 , 𝑏 1 ), (𝑎 2 , 𝑏 1 ), (𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )}.</p><p>In this way, the set of all pattern concepts is organized within the pattern concept lattice in Fig. <ref type="figure">2</ref>. Moreover, all link key candidates are lying in the intents of the pattern concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Discovering Non Redundant Link Keys with Partition Pattern Structures</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1.">Motivation: sameAs is an Equivalence Relation.</head><p>Having a careful look at Fig. <ref type="figure">2</ref>, one can verify that more compact link keys could be designed. For example, in the extent of 𝑝𝑐 3 , {(𝑎 1 , 𝑏 1 ), (𝑎 1 , 𝑏 2 ), (𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )}, the three first pairs have a non empty intersection when considered in a particular order, i.e., 𝑎 1 is shared by {(𝑎 1 , 𝑏 1 ), (𝑎 1 , 𝑏 2 )} and 𝑏 2 is shared by {(𝑎 1 , 𝑏 2 ), (𝑎 2 , 𝑏 2 )}. Actually there exists a potential owl:sameAs -or simply sameAsrelation between the elements in such pairs. Being an equivalence relation, sameAs generates an equivalence class. Hence, we can "merge" some of these pairs in such an equivalence class. For example (𝑎 1 , 𝑏 1 ) and (𝑎 1 , 𝑏 2 ) can be merged, i.e., a 1 sameAs b 1 and a 1 sameAs b 2 yield b 1 sameAs b 2 (symmetry and transitivity of sameAs). Moreover (𝑎 1 , 𝑏 2 ) and (𝑎 2 , 𝑏 2 ) can be merged because a 1 sameAs b 2 and a 2 sameAs b 2 yield a 1 sameAs a 2 . Finally, from a 1 sameAs a 2 and a 1 sameAs b 1 it comes a 2 sameAs b 1 . Then a 1 , a 2 , b 1 , b 2 , are in the same equivalence class w.r.t. sameAs.</p><p>Two important facts should be noticed: (i) the link a 2 sameAs b 1 , absent in 𝑝𝑐 3 but present in 𝑝𝑐 4 , is inferred from the extent of 𝑝𝑐 3 thanks to the properties of sameAs while in the same way a 1 sameAs b 2 could be inferred in 𝑝𝑐 4 , (ii) the equivalence class {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 )} which can be built in 𝑝𝑐 3 and as well in 𝑝𝑐 4 , allows us to merge the link keys in 𝑝𝑐 3 and 𝑝𝑐 4 because they have now the "same extent". Relying on this observation, we define an equivalence relation over the extents of pattern concepts as follows.</p><p>Let us consider two RDF datasets 𝐷 1 and 𝐷 2 , a link key 𝑘, two classes 𝑐 1 and 𝑐 2 , and the set of instances 𝐼 = 𝐼 (𝑐 1 ) ∪ 𝐼 (𝑐 2 ). Given 𝑥 0 and 𝑥 𝑛 ∈ 𝐼, there exists a chain of sameAs relations between 𝑥 0 and 𝑥 𝑛 iff there exists a sequence of elements 𝑥 1 , 𝑥 2 , … , 𝑥 𝑛-1 such that x 0 sameAs x 1 , x 1 sameAs x 2 , … , x n-1 sameAs x n holds, where the symmetry of sameAs may be used. Then, we define a relation between 𝑥 0 and 𝑥 𝑛 in 𝐼 w.r.t. the link key 𝑘, denoted as 𝑥 0 ≃ 𝑘 𝑥 𝑛 , iff there exists a chain of sameAs relations between 𝑥 0 and 𝑥 𝑛 . It can be checked that ≃ 𝑘 is an equivalence relation as sameAs itself is an equivalence relation. For example, 𝐸𝑥𝑡(𝑝𝑐 3 )/≃ ∃(𝑝 2 ,𝑞 2 ) = {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} where 𝐸𝑥𝑡(𝑝𝑐 3 ) denotes the extent of 𝑝𝑐 3 . In the same way, 𝐸𝑥𝑡(𝑝𝑐 4 )/≃ ∃(𝑝 1 ,𝑞 1 ) = {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )}. Then the two link keys ∃(𝑝 1 , 𝑞 1 ) and ∃(𝑝 2 , 𝑞 2 ) can be "identified" or "merged" because they have the same equivalence classes.</p><p>As a consequence, one may obtain more comparable sets of linked elements and thus minimize the number of possible link key candidates. Moreover, it can be noticed that an equivalence class determines a partition within the set of instances under study (singletons if any are omitted here).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2.">The design of a PPS for "Non Redundant Link Keys".</head><p>Hereafter, one main objective is to build a specific pattern structure where concepts are related to unique equivalence classes and yield "non redundant link key candidates" denoted as nrlkc. Here "non redundant" means any two elements in nrlkc are associated with different equivalence classes. In addition, an equivalence class corresponds to a partition of the set of instances. Accordingly, we define a "partition pattern structure" (pps) based on descriptions which are partitions and used to discover non redundant link key candidates. Indeed, in such a pps, objects in the rows correspond to pairs of properties and descriptions correspond to partitions. An example of pps is proposed in <ref type="bibr" target="#b13">[14]</ref> where pps are introduced for mining functional dependencies.</p><p>Accordingly, we define a partition pattern structure over classes 𝑐 1 and 𝑐 2 as a triple (lkc, (𝑃𝑎𝑟𝑡(𝐼 ), ⊓ 𝑝𝑎𝑟𝑡 ), 𝛿) such as:</p><p>• lkc is the set of all link key candidates w.r.t. classes 𝑐 1 and 𝑐 2 which are given by a pattern concept lattice (as displayed in Fig. <ref type="figure">2</ref>).</p><p>pps objects (𝑘 𝑖 )</p><formula xml:id="formula_6">Descriptions (partitions, 𝛿(𝑘 𝑖 )) 𝑘 1 = {∃(𝑝 4 , 𝑞 4 ), ∀(𝑝 4 , 𝑞 4 )} {(𝑎 4 , 𝑏 5 ), (𝑎 5 , 𝑏 4 )} 𝑘 2 = {∃(𝑝 3 , 𝑞 3 ), ∀(𝑝 3 , 𝑞 3 )} {(𝑎 4 , 𝑏 4 ), (𝑎 5 , 𝑏 5 )} 𝑘 3 = {∃(𝑝 2 , 𝑞 2 )} {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} 𝑘 4 = {∃(𝑝 1 , 𝑞 1 )} {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} 𝑘 5 = {∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )} {(𝑎 1 , 𝑏 1 ), (𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} 𝑘 6 = {∀(𝑝 1 , 𝑞 1 ), ∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )} {(𝑎 3 , 𝑏 3 )}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2</head><p>The partition pattern structure related to the pattern structure in Table <ref type="table">1</ref> over the classes 𝑐 1 and 𝑐 2 in datasets 𝐷 1 and 𝐷 2 .</p><p>• (𝑃𝑎𝑟𝑡(𝐼 ), ⊓ 𝑝𝑎𝑟𝑡 ) is the set of potential descriptions or partitions and ⊓ 𝑝𝑎𝑟𝑡 is the "meet" of two partitions. • 𝛿 maps a link key candidate 𝑘 to the partition 𝐼 / ≃ 𝑘 , which is the quotient set of 𝐼 w.r.t. ≃ 𝑘 .</p><p>As it can be seen in Table <ref type="table">2</ref>, pps objects are the link key candidates already computed and lying in the intents of the pattern concept lattice. This means that link key candidates will compose pps-concept extents, while partitions involving elements are declared in the descriptions and thus will compose pps-concept intents. Moreover, partitions reduced to a singleton are omitted in the descriptions of the pps objects.</p><p>Let us examine a concrete example of pps based on the pattern structure given in Table 1. For 𝑝𝑐 3 , we have 𝐸𝑥𝑡(𝑝𝑐 3 ) = {(𝑎 1 , 𝑏 1 ), (𝑎 1 , 𝑏 2 ), (𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} and 𝐼 𝑛𝑡(𝑝𝑐 3 ) = {∃(𝑝 2 , 𝑞 2 )}. The related partition, 𝐸𝑥𝑡(𝑝𝑐 3 )/≃ ∃(𝑝 2 ,𝑞 2 ) = {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )}, where singletons are omitted, is associated with row 𝑘 3 ({∃(𝑝 2 , 𝑞 2 )}) in Table <ref type="table">2</ref> . In the same way, considering 𝑝𝑐 4 and {∃(𝑝 1 , 𝑞 1 )}, 𝐸𝑥𝑡(𝑝𝑐 4 )/≃ ∃(𝑝 1 ,𝑞 1 ) is associated with row 𝑘 4 ({∃(𝑝 1 , 𝑞 1 )}) in Table <ref type="table">2</ref>. Moreover, 𝐸𝑥𝑡(𝑝𝑐 4 )/≃ ∃(𝑝 1 ,𝑞 1 ) = {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} and is equal to 𝐸𝑥𝑡(𝑝𝑐 3 )/≃ ∃(𝑝 2 ,𝑞 2 ) . As already observed, 𝑘 3 and 𝑘 4 are inducing the same partition and can be "merged". The other pps objects, namely 𝑘 1 , 𝑘 2 , 𝑘 5 , and 𝑘 6 , are obtained from the corresponding pattern concepts in Fig. <ref type="figure">2</ref> in the same way. Finally, the pps over classes 𝑐 1 and 𝑐 2 related to the datasets 𝐷 1 and 𝐷 2 is displayed in Table <ref type="table">2</ref>.</p><p>The meet -or similarity-operation used to compare the rows in the pps corresponds to the meet of two partitions 𝑝𝑎𝑟𝑡 1 and 𝑝𝑎𝑟𝑡 2 over 𝐼 and is denoted by 𝑝𝑎𝑟𝑡 1 ⊓ 𝑝𝑎𝑟𝑡 𝑝𝑎𝑟𝑡 2 . This meet operation is classically defined as the intersection of the respective equivalence classes, also known as the "coarsest common refinement of the two partitions" (see <ref type="bibr" target="#b13">[14]</ref>). For example the meet 𝛿(𝑘 4 ) ⊓ 𝑝𝑎𝑟𝑡 𝛿(𝑘 5 ) is given by {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} ⊓ 𝑝𝑎𝑟𝑡 {(𝑎 1 , 𝑏 1 ), (𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )} which yields the partition {(𝑎 1 , 𝑏 1 ), (𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )}. In particular, this means that 𝛿(𝑘 4 ) ⊓ 𝛿(𝑘 5 ) = 𝛿(𝑘 5 ) and thus that 𝛿(𝑘 5 ) ⊑ 𝛿(𝑘 4 ).</p><p>Based on this meet operation, the pps concept lattice is constructed and shown in Fig. <ref type="figure" target="#fig_0">3</ref>. The extent of a pps concept includes the 𝐸𝑞 and the 𝐼 𝑛 parts of a link key candidate (𝐸𝑞, 𝐼 𝑛, (𝑐 1 , 𝑐 2 )) in lkc. For example, the intent of 𝑝𝑝𝑠𝑐 6 is {(𝑎 3 , 𝑏 3 )} and its extent is 𝑘 6 , i.e., {∀(𝑝 1 , 𝑞 1 ), ∃(𝑝 1 , 𝑞 1 ), ∃(𝑝 2 , 𝑞 2 )}. As all elements in the extents of the pps concept lattice, 𝑘 6 is an element of nrlkc, i.e., a non redundant link key candidate. Moreover, 𝑘 6 corresponds to a closed set and thus verifies maximality, and it is non redundant w.r.t. the partition in the associated intent, i.e., no other link key candidate induces the same partition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3.">Discussion: From LKC to NRLKC.</head><p>We now discuss what is gained in relying on pattern structures and then on partition pattern structures. Actually, the discovery of link key candidates (lkc) is based on the construction of the pattern concept lattice. Then the construction of the pps concept lattice yielding the non redundant link key candidates should be considered as a "refinement" where equivalent link key candidates, i.e., link key candidates inducing the same partition, are merged. For example, both concepts 𝑝𝑐 3 and 𝑝𝑐 4 in Fig. <ref type="figure">2</ref> are merged into a single concept 𝑝𝑝𝑠𝑐 34 in Fig. <ref type="figure" target="#fig_0">3</ref>. The resulting pps concept lattice is of smaller size and more concise as link key candidates in the concept extents are non redundant.</p><p>The relations existing between lkc and nrlkc can be characterized as follows. By construction, nrlkc ⊆ lkc as the discovery of non redundant link keys is based on lkc, i.e., the link key candidates lying in the intents of concepts in the pattern concept lattice. Then, the candidates which have the same equivalence classes w.r.t. the sameAs relation are merged to produce the non redundant link key candidates in nrlkc. Thus, it comes that nrlkc ⊆ lkc and that |nrlkc | ≤ |lkc | (where |X| denotes the cardinality of set X). In other words, a non redundant link key candidate is always a link key candidate while the converse is not true.</p><p>The definition of nrlkc allows us to introduce a new quality measure for evaluating and validating non redundant link key candidates. In the next section we make precise this new quality measure and we discuss the benefits related to the discovery of non redundant link key candidates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Quality Measures for Non Redundant Link Key Candidates</head><p>Not all link key candidates are eligible to be final link keys. Some candidates can be too general or related to noise in the data and thus they may generate owl:sameAs links which are not correct or have a bad quality. For example the link key candidate ({}, {(country,country)}, (Person,Human)) states that two individuals (subjects) sharing the same country represent the same person, and this is obviously not true. The candidate ({}, {(name,title)}, (Person,Book)) may be discovered by chance and will generate non correct links as well.</p><p>An ideal link key candidate should be "correct" and "complete", and specific "quality measures" are defined for assessing these properties. In a supervised setting, when a set of reference links is available, the correctness of a link key candidate is measured thanks to "precision" and the completeness thanks to "recall". In an unsupervised setting as this is the case here, the measures of "coverage" and "discriminability" are defined over the set of links directly generated by a link key candidate <ref type="bibr" target="#b8">[9]</ref>. The global quality of a link key candidate is then estimated thanks to the harmonic mean of these two measures.</p><p>The coverage of a set 𝐿 of links over 𝑐 1 and</p><formula xml:id="formula_7">𝑐 2 is 𝑐𝑜𝑣(𝐿, 𝑐 1 , 𝑐 2 ) = |𝜋 1 (𝐿) ∪ 𝜋 2 (𝐿)| |𝐼 (𝑐 1 ) ∪ 𝐼 (𝑐 2 )| where 𝜋 1 (𝐿) = {𝑎|(𝑎, 𝑏) ∈ 𝐿} and 𝜋 2 (𝐿) = {𝑏|(𝑎, 𝑏) ∈ 𝐿}.</formula><p>The</p><formula xml:id="formula_8">discriminability of 𝐿 is 𝑑𝑖𝑠(𝐿) = 𝑚𝑖𝑛(|𝜋 1 (𝐿)|, |𝜋 2 (𝐿)|) |𝐿| .</formula><p>Link  Coverage and discriminability evaluate how close a set of links is to a total, respectively bijective, mapping. Coverage is maximum when all instances of the considered classes are linked to at least another instance, while discriminability is maximum when instances are linked to at most one instance.</p><p>In the present setting, we are interested in the "redundancy" of link key candidates, and we would like to evaluate the quality of "non redundant" candidates. A link key candidate 𝑘 is said to be "redundant" in 𝐻 ⊆ lkc if there exists another link key candidate ℎ ∈ 𝐻 such that 𝐼 /≃ 𝑘 = 𝐼 /≃ ℎ , i.e., 𝑘 generates the same partition as ℎ. This is the case in the running example for the link key candidates 𝑘 3 and 𝑘 4 . One main consequence of detecting redundancy is to reduce the number of candidates by merging candidates inducing the same partition. Then, since ≃ 𝑘 3 and ≃ 𝑘 4 induce the same partition, 𝑘 3 and 𝑘 4 are merged into a non redundant link key candidate 𝑘 34 = {𝑘 3 , 𝑘 4 } interpreted as "𝑘 3 or 𝑘 4 ".</p><p>Accordingly, we introduce the new quality measure 𝑝𝑆𝑖𝑧𝑒(𝑘) that is compliant with the semantics of sameAs and defined w. The normalized measure 𝑛𝑝𝑆𝑖𝑧𝑒(𝑘) evaluates how close are 𝑐 1 and 𝑐 2 w.r.t. ≃ 𝑘 , and is maximal when all instances are linked. However, this is not always satisfactory, especially when the cardinalities of the two classes significantly differ (i.e., classes are not balanced). Then, it is more accurate to maximize the measure as soon as all instances of one class are linked as follows: 𝑠𝑠𝑝𝑐(𝑘) = 𝑝𝑆𝑖𝑧𝑒(𝑘)/𝑚𝑖𝑛(|𝐼 (𝑐 1 )/≃ 𝑘 |, |𝐼 (𝑐 2 )/≃ 𝑘 |) (also known as the "Szymkiewicz-Simpson partition coefficient"). For example, 𝑠𝑠𝑝𝑐(𝑘 3 ) = 2/4 with: 𝑠𝑠𝑝𝑐(𝑘 3 ) = |{(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )}|/𝑚𝑖𝑛(|{(𝑎 1 , 𝑎 2 ), 𝑎 3 , 𝑎 4 , 𝑎 5 }|, |{(𝑏 1 , 𝑏 2 ), 𝑏 3 , 𝑏 4 , 𝑏 5 }|).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Datasets and experimental settings</head><p>We run experiments on DB-Yago datasets provided in <ref type="bibr" target="#b19">[20]</ref>. These datasets are used by the approaches to which we compare our results in the last series of experiments. They have been rewritten into Terse RDF Triple Language (Turtle) which is a syntax for expressing RDF data <ref type="bibr" target="#b20">[21]</ref>. They are derived from DBpedia and Yago and organized into nine tasks. One particular task consists in finding links between instances of a class in DBpedia and instances of a class in Yago, e.g., db:Actor and yago:Actor. A set of reference links (i.e., owl:sameAs links) denoted by 𝐿 𝑟𝑒𝑓 is provided for each task. The statistics of DB-Yago datasets are given in Table <ref type="table" target="#tab_2">3</ref>.</p><p>Experiments were run on a MacBook Pro 2018 with Intel Core i7-8850H@2,6 GHz, 16GB of RAM. The link key candidates are provided by a tool called Linkex<ref type="foot" target="#foot_0">2</ref> in which we have implemented the lkps algorithm i.e. the link key discovery algorithm based on pattern structures proposed in <ref type="bibr" target="#b10">[11]</ref>. A basic text normalization consisting in removing diacritics, tokenizing and sorting the resulting bag of tokens is performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Redundancy of Link Key Candidates is not so Significant</head><p>In Table <ref type="table" target="#tab_2">3</ref>, column |lkc| represents the number of link key candidates discovered by lkps algorithm while column |nrlkc| represents the number of non redundant link key candidates. In most of the tasks, we can observe that |nrlkc| is equal to |lkc|, except for the tasks Actor and Film where |nrlkc| is lower than |lkc| by 1% and by 5% respectively. This means that, in general, link key candidates produce different partitions and only a few are redundant. By contrast, if redundancy does not significantly reduce the number of link key candidates, it gives a good idea of the compactness of partitions related to link key candidates.</p><p>Nevertheless, even if redundancy is not so significant, we decided to compare the quality of the resulting sets of candidates measured with 𝑝𝑆𝑖𝑧𝑒 and the results of competitors, namely keys and conditional keys as they are studied in <ref type="bibr" target="#b19">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Non Redundant Candidates, Classical Keys and Conditional Keys</head><p>The 𝑝𝑆𝑖𝑧𝑒 measure is used to evaluate and select the best link key candidates, -in this experiment the link key candidate ranked first-in every task listed in Table <ref type="table" target="#tab_2">3</ref>. Then, we compare recall, precision, and F-measure of the links generated by the best link key candidates selected by 𝑝𝑆𝑖𝑧𝑒 against interlinking approaches providing classical keys and conditional keys as reported in <ref type="bibr" target="#b19">[20]</ref>.</p><p>In Figure <ref type="figure" target="#fig_2">4</ref> we can observe that: (i) recall of link keys is significantly better than recall of classical and conditional keys, (ii) precision of classical and conditional keys is slightly better than precision of link keys in most of the tasks, (iii) F-measure is much higher for selected link key candidates than for classical and conditional keys.</p><p>Link keys have a better recall because they are more flexible than classical keys, i.e., a link key is not necessarily a pair of keys and an instance of class 𝑐 1 may be linked to many instances of class 𝑐 2 .</p><p>For summarizing, it can be concluded that considering the best link key candidates selected by 𝑝𝑆𝑖𝑧𝑒 will ensure a higher interlinking quality compared to classical and conditional keys. We also observe that the best link key according to discriminability and coverage is the same that the best non redundant link key selected thanks to 𝑝𝑆𝑖𝑧𝑒. Actually, the Actor dataset makes an exception: the link key candidate selected with 𝑝𝑆𝑖𝑧𝑒 obtains an F-measure of 0.95 contrasting the score of 0.34 obtained with coverage and discriminability. In addition, contrasting key-based approaches, link key discovery does not require any prior knowledge such as property or class alignments.  <ref type="bibr" target="#b19">[20]</ref> and link keys. Actually a recall of 0 stands for a very small recall close to 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Synthesis and Conclusion</head><p>This paper introduces a formalization of link key discovery based on partition pattern structures (pps). This approach allows to discover the set nrlkc of link key candidates which are not redundant w.r.t. the owl:sameAs equivalence relation, while still being correct and complete. In addition, new appropriate quality measures are proposed.</p><p>Practically, we observe in experiments that the redundancy of link key candidates in public datasets is rather rare. Nevertheless, the experiments and the associated results show that link key based on pps obtain better F-measure values than two other key-based approaches to data-interlinking.</p><p>Among the perspectives, a first one is to consolidate the theory and practice of link key discovery based on pps introduced and detailed in this paper. A second and very important direction of investigation is related to the discovery of "fuzzy link keys". We make the hypothesis that the redundancy of link key candidates is rather rare because we are using the crisp equality operator when we are building the link key candidates. Instead, in considering the discovery of link key candidates as depending on a similarity relation, i.e., reflexive and symmetric -also called a tolerance relation-rather than on an equality, then we could propose a formalization of fuzzy link key candidates in the spirit of approximate-matching dependencies as they are studied in <ref type="bibr" target="#b18">[19]</ref>. We could also expect much more differences between crisp and fuzzy link key candidates. In addition, a reduction of the size of the concept lattice related to nrlkc could also be investigated thanks to similarities between partitions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The pps concept lattice over the partition pattern structure and the pattern concept lattice given in Fig. 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>r.t. the partition associated with the equivalence relation ≃ 𝑘 : 𝑝𝑆𝑖𝑧𝑒(𝑘) = | {𝑥 ∈ 𝐼 /≃ 𝑘 | |𝑥| &gt; 1} | where 𝐼 = 𝐼 (𝑐 1 ) ∪ 𝐼 (𝑐 2 ) and 𝐼 /≃ 𝑘 is the quotient set of 𝐼 w.r.t. ≃ 𝑘 . For example, 𝑝𝑆𝑖𝑧𝑒(𝑘 3 ) = 𝑝𝑆𝑖𝑧𝑒(𝑘 4 ) = |{(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 )}| = 2. The lower bound of 𝑝𝑆𝑖𝑧𝑒(𝑘) is 1 since 𝑘 generates at least one link. The upper bound is 𝑚𝑖𝑛(|𝐼 (𝑐 1 )|, |𝐼 (𝑐 2 )|) and this is achieved when 𝑘 determines a 1-1 mapping. Moreover, pSize can be normalized into 𝑛𝑝𝑆𝑖𝑧𝑒(𝑘) = 𝑝𝑆𝑖𝑧𝑒(𝑘)/|𝐼 / ≃ 𝑘 |. Then 𝑛𝑝𝑆𝑖𝑧𝑒(𝑘 3 ) = 2/6 as 𝐼 / ≃ 𝑘 3 = {(𝑎 1 , 𝑏 1 , 𝑎 2 , 𝑏 2 ), (𝑎 3 , 𝑏 3 ), 𝑎 4 , 𝑏 4 , 𝑎 5 , 𝑏 5 }, where this time singletons are counted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4:Interlinking performances of classical keys, conditional keys as given in<ref type="bibr" target="#b19">[20]</ref> and link keys. Actually a recall of 0 stands for a very small recall close to 0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3</head><label>3</label><figDesc>DB-Yago datasets statistics, where |triples| denotes the number of triples in each dataset, |subjects| the number of instances, and |properties| the number of properties.</figDesc><table><row><cell cols="2">Interlinking task datasets</cell><cell>|triples|</cell><cell cols="2">|subjects| |properties|</cell><cell>|lkc|</cell><cell cols="2">|nrlkc| time</cell></row><row><cell>Actor</cell><cell>db:Actor yago:Actor</cell><cell>94 606 1 029 580</cell><cell>5 807 108 415</cell><cell>16 16</cell><cell>2 198</cell><cell>2 177</cell><cell>56s</cell></row><row><cell>Album</cell><cell>db:Album yago:Album</cell><cell>594 144 762 238</cell><cell>85 002 136 848</cell><cell>5 5</cell><cell>44</cell><cell>44</cell><cell>28s</cell></row><row><cell>Book</cell><cell>db:Book yago:Book</cell><cell>247 372 185 032</cell><cell>29 846 41 849</cell><cell>7 7</cell><cell>82</cell><cell>82</cell><cell>39s</cell></row><row><cell>Film</cell><cell>db:Film yago:Film</cell><cell>1 369 600 1 067 084</cell><cell>82 099 123 822</cell><cell>9 9</cell><cell cols="3">18 718 17 643 34m</cell></row><row><cell>Mountain</cell><cell>db:Mountain yago:Mountain</cell><cell>135 442 233 562</cell><cell>16 397 32 874</cell><cell>5 5</cell><cell>39</cell><cell>39</cell><cell>5m</cell></row><row><cell>Museum</cell><cell>db:Museum yago:Museum</cell><cell>15 940 163 342</cell><cell>1 826 21 050</cell><cell>7 7</cell><cell>48</cell><cell>48</cell><cell>9s</cell></row><row><cell>Organization</cell><cell cols="2">db:Organization yago:Organization 4 410 854 4 487 205</cell><cell>183 665 430 071</cell><cell>17 17</cell><cell>1 425</cell><cell>1 425</cell><cell>57m</cell></row><row><cell>Scientist</cell><cell>db:Scientist yago:Scientist</cell><cell>128 360 671 266</cell><cell>18 409 92 828</cell><cell>10 18</cell><cell>862</cell><cell>862</cell><cell>2m</cell></row><row><cell>University</cell><cell>db:University yago:University</cell><cell>241 838 263 624</cell><cell>10 352 23 334</cell><cell>9 9</cell><cell>213</cell><cell>213</cell><cell>56s</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>Linkex is available online at https://gitlab.inria.fr/moex/linkex.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Data Linking for the Semantic Web</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ferrara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nikolov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Scharffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Semantic Web and Information Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="46" to="76" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Data Matching -Concepts and Techniques for Record Linkage, Entity Resolution, and Duplicate Detection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Christen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A survey of current Link Discovery frameworks</title>
		<author>
			<persName><forename type="first">M</forename><surname>Nentwig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hartung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A.-C</forename><surname>Ngonga Ngomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Rahm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web Journal</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="419" to="436" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">LIMES -A Time-Efficient Approach for Large-Scale Link Discovery on the Web of Data</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Ngomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Auer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI), IJCAI/AAAI</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI), IJCAI/AAAI</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="2312" to="2317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Silk -A Link Discovery Framework for the Web of Data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Volz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gaedke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kobilarov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the WWW2009 Workshop on Linked Data on the Web (LDOW), CEUR Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Heath</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Berners-Lee</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Idehen</surname></persName>
		</editor>
		<meeting>the WWW2009 Workshop on Linked Data on the Web (LDOW), CEUR Workshop Proceedings</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">538</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Active learning of expressive linkage rules using genetic programming</title>
		<author>
			<persName><forename type="first">R</forename><surname>Isele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of web semantics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="2" to="15" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">EAGLE: Efficient Active Learning of Link Specifications Using Genetic Programming</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Ngomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lyko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Extended Semantic Web Conference (ESWC</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Simperl</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Cimiano</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ó</forename><surname>Corcho</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Presutti</surname></persName>
		</editor>
		<meeting>the 9th Extended Semantic Web Conference (ESWC</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7295</biblScope>
			<biblScope unit="page" from="149" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Unsupervised learning of link specifications: deterministic vs. non-deterministic</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Ngomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Lyko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Ontology Matching (at ISWC), CEUR Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Shvaiko</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><surname>Srinivas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Mao</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Jiménez-Ruiz</surname></persName>
		</editor>
		<meeting>the 8th International Workshop on Ontology Matching (at ISWC), CEUR Workshop Proceedings</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">1111</biblScope>
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Data interlinking through robust linkkey extraction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ECAI</title>
		<meeting>ECAI</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="15" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Link key candidate extraction with relational concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vizzini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="2" to="20" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Discovery of Link Keys in RDF Data Based on Pattern Structures: Preliminary Steps</title>
		<author>
			<persName><forename type="first">N</forename><surname>Abbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Concept Lattices and Their Applications (CLA), CEUR Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">J</forename><surname>Valverde-Albacete</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Trnecka</surname></persName>
		</editor>
		<meeting>the International Conference on Concept Lattices and Their Applications (CLA), CEUR Workshop Proceedings</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">2668</biblScope>
			<biblScope unit="page" from="235" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wille</surname></persName>
		</author>
		<title level="m">Formal Concept Analysis: Mathematical Foundations</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pattern Structures and Their Projections</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Conceptual Structures (ICCS)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Delugach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Stumme</surname></persName>
		</editor>
		<meeting>the International Conference on Conceptual Structures (ICCS)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">2120</biblScope>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Characterizing functional dependencies in formal concept analysis with pattern structures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baixeries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaytoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="129" to="149" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Non-Redundant Link Keys in RDF Data: Preliminary Steps</title>
		<author>
			<persName><forename type="first">N</forename><surname>Abbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bazin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the FCA4AI Workshop at IJCAI, CEUR Workshop Proceedings</title>
		<meeting>the FCA4AI Workshop at IJCAI, CEUR Workshop Proceedings</meeting>
		<imprint>
			<date type="published" when="2021">2972. 2021</date>
			<biblScope unit="page" from="125" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On the relation between keys and link keys for data interlinking</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web Journal</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="547" to="567" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Mining Gene Expression Data with Pattern Structures in Formal Concept Analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kaytoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Duplessis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="page" from="1989" to="2001" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Sandwich: An Algorithm for Discovering Relevant Link Keys in an LKPS Concept Lattice</title>
		<author>
			<persName><forename type="first">N</forename><surname>Abbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bazin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Formal Concept Analysis (ICFCA)</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Braud</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Buzmakov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Hanika</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Ber</surname></persName>
		</editor>
		<meeting>the 16th International Conference on Formal Concept Analysis (ICFCA)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">12733</biblScope>
			<biblScope unit="page" from="243" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Characterizing Approximate-Matching Dependencies in Formal Concept Analysis with Pattern Structures</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baixeries</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Codocedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaytoue</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">249</biblScope>
			<biblScope unit="page" from="18" to="27" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">VICKEY: Mining Conditional Keys on Knowledge Bases</title>
		<author>
			<persName><forename type="first">D</forename><surname>Symeonidou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Galárraga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pernelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Saïs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 16th International Semantic Web Conference (ISWC)</title>
		<title level="s">LNCS</title>
		<meeting>16th International Semantic Web Conference (ISWC)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10587</biblScope>
			<biblScope unit="page" from="661" to="677" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Beckett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Berners-Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Prud'hommeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Carothers</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/turtle/" />
		<title level="m">RDF 1.1 Turtle, W3C Recommendation, W3C</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
