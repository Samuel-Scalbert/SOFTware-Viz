<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Query Rewriting with Disjunctive Existential Rules and Mappings</title>
				<funder ref="#_9GmED4q">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Michel</forename><surname>Leclère</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<email>mugnier@lirmm.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Guillaume</forename><surname>Pérution-Kihli</surname></persName>
							<email>guillaume.perution-kihli@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Query Rewriting with Disjunctive Existential Rules and Mappings</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">D578522E4E1A02CC9A3F51254C3BEF57</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We consider the issue of answering unions of conjunctive queries (UCQs) with disjunctive existential rules and mappings. While this issue has already been well studied from a chase perspective, query rewriting within UCQs has hardly been addressed yet. We first propose a sound and complete query rewriting operator, which has the advantage of establishing a tight relationship between a chase step and a rewriting step. The associated breadth-first query rewriting algorithm outputs a minimal UCQ-rewriting when one exists. Second, we show that for any "truly disjunctive" nonrecursive rule, there exists a conjunctive query that has no UCQrewriting. It follows that the notion of finite unification sets (fus), which denotes sets of existential rules such that any UCQ admits a UCQ-rewriting, seems to have little relevance in this setting. Finally, turning our attention to mappings, we show that the problem of determining whether a UCQ admits a UCQ-rewriting through a disjunctive mapping is undecidable. We conclude with a number of open problems.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Existential rules <ref type="bibr" target="#b14">(Calì, Gottlob, and Kifer 2008;</ref><ref type="bibr" target="#b6">Baget et al. 2009;</ref><ref type="bibr" target="#b15">Calì, Gottlob, and Lukasiewicz 2009)</ref>, aka tuple generating dependencies <ref type="bibr" target="#b9">(Beeri and Vardi 1984)</ref>, are an extension of datalog (i.e., first-order function-free Horn rules), which allows for existentially quantified variables in the rule heads, e.g., ∀x(human(x) → ∃y isParent(y, x)). They have become a popular language to model ontologies and do reasoning on data. Then, a key issue is ontology-mediated query answering, which consists of computing the answers to a query on a knowledge base (KB), composed of a set of facts (or data) F and an ontology O. In this context, most works focus on the prominent class of (unions of) conjunctive queries ((U)CQs). There are two main dual techniques to compute the answers to a query Q: the chase, which enriches the facts F by performing a fixpoint computation with the ontology O until a canonical model of F and O is obtained (then Q is evaluated on this canonical model), and query rewriting, where Q is rewritten using O into a query Q , such that for any set of facts F , the evaluation of Q on F yields the answers to Q on the KB. Query answering with general existential rules is undecidable, however a wide range of decidable subclasses have been defined, based on syntactic restrictions that ensure the termination of chase-like or query rewriting techniques. Tuple generating dependencies (TGDs) are also the main formalism to represent schema mappings, which are high-level specifications of the relationships between two database schemas <ref type="bibr" target="#b20">(Fagin et al. 2005)</ref>. Schema mappings are at the core of many data interoperability tasks, such as data exchange, data integration or peer data management. More specifically, a mapping is a set of TGDs, with bodies and heads expressed on disjoint sets of predicates, namely S and T , called the source and the target schemas. Given a database instance I on S and a mapping M, a query expressed on T is posed on the set of facts produced from I by triggering M; again, query answering can be solved by chasing I with M or rewriting Q with M into a query that is evaluated on I. Since mappings are inherently nonrecursive, both techniques always terminate. Finally, in the Ontology-Based Data Access (OBDA) framework <ref type="bibr" target="#b31">(Poggi et al. 2008)</ref>, mappings specify relationships between a database schema and an ontology. Here, existential rules can be used as a uniform language to express both the ontology and the mapping <ref type="bibr" target="#b13">(Buron, Mugnier, and Thomazo 2021)</ref>.</p><p>Existential rules generalize popular description logics (DLs) used to do reasoning on data, such as DL-Lite <ref type="bibr" target="#b17">(Calvanese et al. 2007)</ref>, EL <ref type="bibr" target="#b5">(Baader, Brandt, and Lutz 2005;</ref><ref type="bibr" target="#b28">Lutz, Toman, and Wolter 2009)</ref> and more expressive Horn-DLs <ref type="bibr" target="#b26">(Krötzsch, Rudolph, and Hitzler 2006)</ref>. However, they do not capture nondeterministic features, as offered by some key DLs such as ALC <ref type="bibr" target="#b33">(Schmidt-Schauß and Smolka 1991)</ref> or the Semantic Web ontology language OWL <ref type="bibr">(W3C 2009)</ref>.</p><p>In this paper, we consider the extension of existential rules with disjunction, e.g., ∀x∀y(isGrandParent(x, y) → ∃z 1 (isParent(x, z 1 ) ∧ isMother(z 1 , y)) ∨ ∃z 2 (isParent(x, z 2 ) ∧ isFather(z 2 , y))). From a KR perspective, the usefulness of such rules has long been acknowledged for ontology modeling, but also for expressing nondeterministic guessing in problem solving, see e.g., <ref type="bibr" target="#b19">(Eiter, Gottlob, and Mannila 1997)</ref>. From a database perspective, disjunction in schema mappings received considerable attention in the context of mapping management, where mapping composition and inversion emerged as fundamental operators <ref type="bibr" target="#b10">(Bernstein and Ho 2007;</ref><ref type="bibr" target="#b3">Arenas et al. 2010)</ref>. Indeed, disjunction is required to express several kinds of inverse mappings, like so-called quasiinverses or maximum recovery mappings <ref type="bibr" target="#b21">(Fagin et al. 2008;</ref><ref type="bibr" target="#b4">Arenas, Pérez, and Riveros 2008)</ref>. Beside the issue of constructing such mappings, the design of associated query answering techniques is highly relevant. For instance, in a peer data management system, a mapping M from peer P 1 to peer P 2 allows to rewrite a query on P 2 in terms of P 1 , while an inverse of M allows to rewrite a query on P 1 in terms of P 2 . As another example, consider a mapping M from schema A to schema B, and assume that A evolves into A , which is expressed by a mapping M ; the relation between A and B can be obtained by inverting M and composing it with M; then, a query on B can be translated into a query on A by rewriting it first with M, then with the inverse of M (Pérez 2013). Such scenario is also relevant in OBDA, taking for B an ontology instead of a schema.</p><p>So far, reasoning with disjunctive existential rules has been mainly studied through the chase. It was shown that decidable classes of (conjunctive) existential rules, based on the behavior of the chase, can be generalized to disjunctive rules in a quite natural way, whether in relation to acyclicity notions <ref type="bibr" target="#b18">(Carral, Dragoste, and Krötzsch 2017)</ref> or based on guardedness <ref type="bibr" target="#b2">(Alviano et al. 2012;</ref><ref type="bibr" target="#b24">Gottlob et al. 2012;</ref><ref type="bibr" target="#b12">Bourhis et al. 2016)</ref>, although these generalizations come with a huge increase in the complexity of query answering.</p><p>In contrast, query rewriting within UCQs has been barely addressed yet. A notable exception is the work in <ref type="bibr" target="#b1">(Alfonso, Chortaras, and Stamou 2021)</ref>, which provides a rewriting technique based on first-order resolution (see Section 3). A large body of work has studied the rewritability of ontology-mediated queries, i.e., pairs of the form (Q, O) with Q a (U)CQ and O an ontology, into query languages of various expressivity. However, for ontologies expressed in fragments of disjunctive existential rules, most studies target expressive rewriting languages, like disjunctive datalog <ref type="bibr" target="#b11">(Bienvenu et al. 2014;</ref><ref type="bibr" target="#b0">Ahmetaj, Ortiz, and Simkus 2018)</ref>. As far as we are aware, the only result directly relevant to our purpose comes from the fine-grained complexity study in <ref type="bibr" target="#b23">(Gerasimova et al. 2020)</ref>, which provides syntactic rewritability conditions for ontology-mediated queries where the ontology is composed of a single specific disjunctive rule, called a covering axiom (see Section 4).</p><p>Our contributions are the following:</p><p>• We first define a sound and complete query rewriting operator for UCQs and disjunctive existential rules, which has the advantage of establishing a tight relationship between a chase step and a rewriting step (Theorem 3). The associated breadth-first query rewriting algorithm outputs a minimal UCQ-rewriting when one exists (Theorem 4).</p><p>• We then turn our attention to the notion of finite unification sets (fus), which denotes sets of existential rules for which any UCQ is UCQ-rewritable, i.e., admits a finite sound and complete rewriting under the form of a UCQ. Noting that the known fus classes for conjunctive existential rules do not seem to be generalizable to disjunctive rules, we show that, in fact, for any "truly disjunctive" nonrecursive rule, there is a CQ that is not UCQrewritable (Theorem 5). This leads to question the relevance of fus for disjunctive rules and to consider the problem of whether a specific UCQ is UCQ-rewritable.</p><p>• Finally, considering (disjunctive) mappings, we show that the problem of determining whether a given UCQ on the target schema admits a UCQ-rewriting on the source schema is undecidable (Theorem 6). Based on these results, we conclude with a number of open problems. Detailed proofs are available in a technical report <ref type="bibr" target="#b27">(Leclère, Mugnier, and Pérution-Kihli 2023)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Generalities. We consider logical vocabularies of the form V = (P, C), where P is a finite set of predicates and C is a (possibly infinite) set of constants. A term on V is a constant from C or a variable. An atom on V has the form p(t) where p ∈ P is a predicate of arity n and t is a tuple of terms on V with |t| = n. An atom with predicate p is also called a p-atom. Given a formula or set of formulas S, we denote by vars(S), consts(S) and terms(S) its sets of variables, constants and terms, respectively. We will often see a tuple x of pairwise distinct variables as a set. We denote by |= and ≡ classical logical entailment and equivalence, respectively. Given two sets of atoms S 1 and S 2 , a homomorphism h from S 1 to S 2 is a substitution of vars(S 1 ) by terms(S 2 ) such that h(S 1 ) ⊆ S 2 (we say that S 1 maps to S 2 by h). It is well-known that, when we see S 1 and S 2 as existentially closed conjunctions of atoms, S 2 |= S 1 iff S 1 maps to S 2 .</p><p>A safe copy of an atom set S is obtained from S by a bijective renaming of its variables with fresh variables (i.e., that do not occur elsewhere in the context of the computation). Knowledge base. A set of facts F is a possibly infinite set of atoms, logically seen as an existentially closed conjunction. When this set is finite we call it a fact base. A disjunctive existential rule R (or simply rule hereafter) is a closed formula of the form</p><formula xml:id="formula_0">∀x∀y ( B[x, y] → n i=1 ∃z i H i [x i , z i ] )</formula><p>where n ≥ 1, B and the H i are non-empty finite conjunctions of atoms with vars(B) = x ∪ y and vars(H i ) =</p><formula xml:id="formula_1">x i ∪ z i , x = n i=1</formula><p>x i and x, y and the z i are pairwise disjoint; B is the body of R, also denoted by body(R), and {H 1 , . . . , H n } is the head of R, also denoted by head(R). We also denote by head i (R) the i-th disjunct H i of the head of R. The set x is the frontier of R and is denoted by fr(R). Its elements are called frontier variables. The set z i is the set of existential variables of H i , also denoted by exist(H i ), and the union of all the exist(H i ) is the set of existential variables of R, also denoted by exist(R). Note that constants may occur anywhere. For brevity, we often denote by B → H 1 ∨ . . . ∨ H n a rule with body B and head</p><formula xml:id="formula_2">{H 1 , . . . , H n }. A rule R is conjunctive if n = 1. A (dis- junctive) rule R is (disjunctive) datalog if exist(R) = ∅.</formula><p>A (disjunctive) knowledge base (KB) is a pair (F, R), where F is a fact base and R is a finite set of (disjunctive) existential rules. We assume w.l.o.g. that distinct rules in R have disjoint sets of variables. In examples, we may reuse variables for simplicity.</p><p>Disjunctive chase. A rule R = B → H 1 ∨ . . . ∨ H n is applicable on a fact base F if there is a homomorphism h from body(R) to F . The pair (R, h) is called a trigger on F . The application of (R, h) to F is denoted by α ∨ (F, R, h); it produces a set of n fact bases, each obtained by adding to F a set of atoms obtained from head i (R) by replacing each frontier variable x by h(x) and each existential variable by a fresh variable. We denote by h safei the extension of h that safely renames exist(head i (R)) by fresh variables. Then:</p><formula xml:id="formula_3">α ∨ (F, R, h) = {F ∪ h safei (head i (R)) | 1 ≤ i ≤ n}</formula><p>The disjunctive chase procedure iteratively applies triggers towards a fixpoint. This procedure is often seen as the construction of a tree, see in particular <ref type="bibr" target="#b12">(Bourhis et al. 2016;</ref><ref type="bibr" target="#b18">Carral, Dragoste, and Krötzsch 2017)</ref>. Definition 1 (Derivation tree). A derivation tree T of a KB (F, R) is a (possibly infinite) rooted labeled tree (V, E, λ), where V is the set of vertices, E the set of edges, and λ a vertex labeling function inductively defined as follows:</p><formula xml:id="formula_4">• λ(r) = F for the root r of T ; • For each vertex v with children {v 1 , ..., v n }, there is a trigger (R, h) on λ(v) with R = B → H 1 ∨. . .∨H n ∈ R</formula><p>and the restriction of λ to the domain {v 1 , ..., v n } is a bijection to α ∨ (λ(v), R, h). Note that we do not impose any criterion of trigger applicability, as we do not aim at studying a particular chase strategy. A branch γ of a rooted tree is a maximal path from the root; we denote by nodes(γ) its set of vertices. Given a derivation tree T , we denote by Γ(T ) the set of all its branches. A trigger (R, h) on F is satisfied (by F ) if there is an extension h of h with h (head i (R)) ⊆ F for some i. A derivation tree (V, E, λ) is fair if, for each branch γ and each vertex v ∈ nodes(γ), any trigger on λ(v) is satisfied in a λ(v ) with v ∈ nodes(γ). Finally, a chase tree is a fair derivation tree. Definition 2 (Disjunctive chase result). The result of a disjunctive chase of</p><formula xml:id="formula_5">F by R is chase(F, R) = { v∈nodes(γ) λ(v) | γ ∈ Γ(T )}</formula><p>where T is a chase tree and λ its labeling function.</p><p>From a logical viewpoint, the chase result is a disjunction of existentially closed conjunctions of atoms. Neither the chase tree nor the chase result are unique, however all the results entail the same queries (see next Theorem 1). Although the degree of each vertex in a chase tree is bounded by the maximal number of disjuncts in a rule head, the tree may have infinite branches, and an infinite number of them. When the chase tree is finite, the result of the chase is the (finite) set of fact bases associated with its leaves.</p><p>It is sometimes convenient to consider a linearization of a finite derivation tree, which we call a derivation. A derivation of ({F }, R) is a finite sequence of sets of fact bases and triggers</p><formula xml:id="formula_6">D = (F 0 = {F }) t1 -→ F 1 t2 -→ . . . t k -→ F k where t i = (R, h) is a trigger of R ∈ R on an F j ∈ F i-1 and F i = (F i-1 \ {F j }) ∪ α ∨ (F j , R, h), for all 1 ≤ i ≤ k.</formula><p>To each finite derivation tree can be assigned a derivation obtained from any total ordering of the trigger applications associated with the inner vertices in the tree, in a compatible way with the parent-child partial order. When R is a set of conjunctive rules, a derivation tree is a path and the F i in a derivation are singletons; then, a derivation can be seen as a sequence of fact bases (instead of sets of fact bases).</p><p>Query Answering. A conjunctive query (CQ) Q takes the form ∃y φ[x, y], where x and y are disjoint tuples of variables, and φ is a finite conjunction of atoms with vars(φ) = x ∪ y. The variables in x are called answer variables.</p><p>A Boolean CQ has no answer variables. In a full CQ, all variables are answer variables. An atomic CQ has a single atom. A (Boolean) union of conjunctive queries (UCQ) is a disjunction of (Boolean) CQs with the same tuple of answer variables x. For clarity, we denote a UCQ by Q and a CQ by Q. A set of facts F answers positively to a Boolean CQ Q if F |= Q. More generally, a tuple of constants c is an answer to a CQ Q on F if there is a substitution s such that s(x) = c and F |= s(Q). This extends to a UCQ Q and a set of sets of facts F : a tuple of constants c is an answer to</p><formula xml:id="formula_7">Q on F if for every F i ∈ F , there is a CQ Q j ∈ Q such that c is an answer to Q j on F i .</formula><p>W.l.o.g. we focus in this paper on Boolean queries, to avoid technicalities related to answer variables. Hence, in the following, by UCQ and CQ we refer to Boolean queries, unless otherwise specified. We will often see a CQ as a set of atoms, and a UCQ as a set of atoms sets.</p><p>The following theorem states that the disjunctive chase provides a sound and complete procedure to decide whether a UCQ is entailed by a disjunctive KB.</p><p>Theorem 1 (from <ref type="bibr" target="#b12">(Bourhis et al. 2016)</ref>). Let Q be a (Boolean) UCQ and (F, R) be a disjunctive KB. Then</p><formula xml:id="formula_8">F, R |= Q iff chase(F, R) |= Q (i.e., F i |= Q for all F i ∈ chase(F, R)).</formula><p>Example 1 (Colorability). Let F be a fact base on predicates v (vertex) and e (edge) describing a graph G. Let R = v(x) → g(x) ∨ r(x) ("Every vertex has color green or red"). Then, chase(F, {R}) yields all ways of coloring each vertex. Let the UCQ Q</p><formula xml:id="formula_9">= {Q 1 , Q 2 } with Q 1 = {g(u), e(u, w), g(w)} and Q 2 = {r(u), e(u, w), r(w)}. The KB (F, {R}) answers positively to Q iff G is not 2- colorable. Given UCQs Q 1 and Q 2 , we say that Q 1 is more specific than Q 2 if Q 1 |= Q 2 . Note that Q 1 |= Q 2 iff for all Q 1 ∈ Q 1 , there is Q 2 ∈ Q 2 such that Q 1 |= Q 2 (i.e., Q 2 maps to Q 1 by homomorphism). A CQ Q is minimal if it has no strict subset Q Q such that Q ≡ Q (i.e., Q |= Q). A UCQ Q is minimal if it has no strict subset Q Q such that Q ≡ Q (whether each CQ in the UCQ is itself minimal is not relevant for our results). A cover of a UCQ Q is a minimal subset Q ⊆ Q such that Q ≡ Q . It is known that, given two equivalent UCQs Q 1 and Q 2 ,</formula><p>there is a bijection from any cover of Q 1 to any cover of Q 2 that maps each CQ in Q 1 to an equivalent CQ in Q 2 (see, e.g., <ref type="bibr" target="#b25">(König et al. 2015)</ref>).</p><p>Mappings. Given two disjoint sets of predicates S and T , respectively called the source and the target predicates, a source-to-target (or S-to-T ) rule R is such that body(R) uses predicates in S and head(R) uses predicates in T . A (disjunctive) mapping M on (S, T ) is a finite set of S-to-T (disjunctive) rules. In this setting, a fact base (or database instance) is expressed on S and a query on T . Note that the chase of a fact base with a mapping is always finite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UCQ rewritability.</head><p>In the following, by rewriting of a UCQ Q with a set of rules R, we mean a possibly infinite set of CQs Q , such that for all fact base F , if</p><formula xml:id="formula_10">F |= Q then F, R |= Q (in other words, a rewriting is by definition sound). A rewriting Q of Q with R is complete if for all fact base F , if F, R |= Q then F |= Q . A finite complete rewriting is called a UCQ-rewriting. A pair (Q, R) is called UCQ-rewritable if it admits a UCQ-rewriting. The set R itself is called UCQ-rewritable if for any UCQ Q, the pair (Q, R) is UCQ-rewritable.</formula><p>In the framework of conjunctive existential rules, a UCQ-rewritable set is also called a finite unification set (fus) <ref type="bibr" target="#b7">(Baget et al. 2011)</ref>. We shall extend this term to disjunctive rules. Example 2 (Transitivity). Let R = p(x, y) ∧ p(y, z) → p(x, z). The (Boolean) CQ Q 1 = {p(a, b)}, where a and b are constants, has no UCQ-rewriting with {R}, while the (Boolean) CQ Q 2 = {p(u, v)} has one, which is {Q 2 }. Indeed, any complete rewriting of Q 1 is infinite as it contains all the "paths" of p-atoms from a to b, which are pairwise incomparable by homomorphism. In contrast, the atom p(u, v) maps by homomorphism to any path of p-atoms.</p><p>Finally, we recall some fundamental notions on rewriting with conjunctive existential rules. We will rely on these to define rewriting with disjunctive rules.</p><p>Query rewriting with conjunctive existential rules In the setting of conjunctive existential rules, query rewriting can be performed using piece-unifiers; these are a generalization of classical unifiers that take care of existential variables in rule heads by unifying sets of atoms instead of single atoms <ref type="bibr" target="#b32">(Salvat and Mugnier 1996;</ref><ref type="bibr" target="#b6">Baget et al. 2009)</ref>. In short, a piece-unifier unifies a subset Q of a CQ Q and a subset H of a rule head, such that existential variables from H are unified only with variables of</p><formula xml:id="formula_11">Q that do not occur in Q \ Q . Next, we call separating variables of Q (w.r.t. Q) the variables of Q that also occur in Q \ Q . It is con- venient to represent</formula><p>a unifier as a partition of a set of terms rather than a substitution. Hence, we say that a partition P of a set of terms is admissible if no class of P contains two constants; we associate a substitution u with an admissible partition P u by selecting one term in each class with priority given to constants: for each class C in P u , let t i be the selected term, then for every t j ∈ C, we set u(t j ) = t i . <ref type="figure"></ref>and<ref type="figure">P</ref> u is an admissible partition on terms(Q ) ∪ terms(H ) such that: 1. u(Q ) = u(H ), with u a substitution associated with P u ; 2. If a class C ∈ P u contains an existential variable (from H ), then the other terms in C are non-separating variables from Q . Let µ = (Q , H , P u ) be a piece-unifier of Q with R : B → H and u a substitution associated with P u . The application of µ produces the following CQ:</p><formula xml:id="formula_12">Definition 3 (Piece-unifier). 1 Let Q be a CQ and R = B → H be a conjunctive existential rule such that vars(Q) ∩ vars(B ∪ H) = ∅. A piece-unifier of Q with R is a triple µ = (Q , H , P u ) with Q = ∅, Q ⊆ Q, H ⊆ H,</formula><formula xml:id="formula_13">β(Q, R, µ) = u(B) ∪ u(Q \ Q ) Example 3 (Piece-Unifier). Let R = p(x, y) → ∃z p 1 (x, z) ∧ p 2 (y, z) and Q 1 = {p 1 (u, v), s(v)}. There is no piece-unifier of Q 1 with R since v is a separating vari- able of Q 1 = {p 1 (u, v)}, hence cannot be unified with z. Let Q 2 = {p 1 (u, v), s(u)}: now, there is a piece-unifier of Q 2 with R, namely µ 2 = ({p 1 (u, v)}, {p 1 (x, z)}, P u2 ) with P u2 = {{x, u}, {y}, {z, v}}.</formula><p>Taking the substitution</p><formula xml:id="formula_14">u 2 = {u → x, v → z}, we obtain β(Q 2 , R, µ 2 ) = {p(x, y), s(x)}. Finally, let Q 3 = {p 1 (u, v), p 2 (u, w), p 1 (t, v), s(t)}, and Q 3 = Q 3 \ {s(t)}. The triple µ 3 = (Q 3 , head(R), P u3 ) with P u3 = {{x, y, t, u}, {z, v, w}} is a piece-unifier of Q 3 with R. If we select x and z in P u3 , β(Q 3 , R, µ 3 ) = {p(x, x), s(x)}. A piece-rewriting of a UCQ Q with a (conjunctive) rule set R is a UCQ Q k obtained by a finite sequence of piece- unifier applications, i.e., (Q 0 = Q), . . . , Q k (k ≥ 0) such that, for all 0 &lt; i ≤ k, there is a piece-unifier µ of Q ∈ Q i-1 with R ∈ R such that Q i = Q i-1 ∪ {β(Q, R, µ)}.</formula><p>As stated below, piece-unifiers provide a sound and complete query rewriting procedure: Theorem 2 (from <ref type="bibr" target="#b7">(Baget et al. 2011))</ref>. For any (conjunctive) KB (F, R) and UCQ Q, there is a derivation of (F, R) leading to an F i such that</p><formula xml:id="formula_15">F i |= Q iff there is a piece- rewriting Q j of Q with R such that F |= Q j .</formula><p>It follows that, when a pair (Q, R) is UCQ-rewritable, a UCQ-rewriting can be obtained as a piece-rewriting. Let us point out that a conjunctive mapping is always UCQrewritable (or fus). Indeed, since it is made of S-to-T rules, the application of a piece-unifier of a CQ Q produces a CQ with strictly fewer atoms on T than Q. Also, CQs that contain predicates on T are useless in a rewriting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Query Rewriting with Disjunctive Rules</head><p>Our generalization of query rewriting to disjunctive rules relies on a simple idea: a query Q can be rewritten with a rule</p><formula xml:id="formula_16">R = B → H 1 ∨ • • • ∨ H n if each H i contributes</formula><p>to partially answer Q. Therefore, a unification step consists of unifying each H i (using a piece-unifier) with a safe copy Q i of a CQ from Q ; safe copies ensure that the CQs involved in the unification have pairwise disjoint sets of variables. Note that several safe copies of the same CQ from Q can be involved. This yields a new CQ made of body(R) and the remaining parts of the unified CQs, according to some aggregation of the piece-unifiers. We need a few auxiliary notions to specify this aggregation. Let P be a set of partitions (not necessarily of the same set). The join of P, denoted by join(P), is the partition obtained from P by making the union of the partitions in P, then merging all non-disjoint classes until fixed point. E.g., given P composed of partitions {{x, u}, {y, v}, {z, w}} and {{x, y, a}, {z , t}}, we obtain join(P) = {{x, u, y, v, a}, {z, w}, {z , t}}. We say that a set of partitions associated with piece-unifiers is admissible if its join is an admissible partition (i.e., it does not contain a class with two constants). Definition 4 (Disjunctive Piece-Unifier and One-step Piece-Rewriting).</p><formula xml:id="formula_17">Let a rule R = B → H 1 ∨ • • • ∨ H n and a UCQ Q. A disjunctive piece-unifier µ ∨ of Q with R is a set {µ 1 , . . . , µ n } such that: • for 1 ≤ i ≤ n, µ i = (Q i , H i , P ui ) is a (conjunctive)</formula><p>piece-unifier of Q i , a safe copy of a CQ from Q, with the (conjunctive) rule B → H i ; • and P u∨ = {P u1 , . . . , P un } is admissible. Given a substitution u ∨ associated with join(P u∨ ), the application of µ ∨ produces the CQ</p><formula xml:id="formula_18">β ∨ (Q, R, µ ∨ ) = u ∨ (B) ∪ 1≤i≤n u ∨ (Q i \ Q i ) The one-step piece-rewriting of Q w.r.t. µ ∨ is Q ∪ {β ∨ (Q, R, µ ∨ )} Example 4. Let R = p(x, y) → ∃z 1 r(x, z 1 ) ∨ ∃z 2 r(y, z 2 ) and the UCQ Q = {Q} with Q = {s(u), r(u, v)}. Let Q 1 = {s(u 1 ), r(u 1 , v 1 )} and Q 2 = {s(u 2 ), r(u 2 , v 2 )} be two safe copies of Q, and let µ ∨ = {µ 1 , µ 2 } with µ 1 = ({r(u 1 , v 1 )}, {r(x, z 1 )}, {{u 1 , x}, {v 1 , z 1 }}) and µ 2 = ({r(u 2 , v 2 )}, {r(y, z 2 )}, {{u 2 , y}, {v 2 , z 2 }}).</formula><p>Assume we give priority to variables from R, i.e., we take the substitution</p><formula xml:id="formula_19">u ∨ = {u 1 → x, v 1 → z 1 , u 2 → y, v 2 → z 2 }. Then β ∨ (Q, R, µ ∨ ) = {p(x, y), s(x), s(y)}.</formula><p>Definition 5 (Piece-Rewriting). Given a disjunctive rule set R, a UCQ Q is a piece-rewriting (or simply rewriting when clear from the context) of a UCQ Q with R if there is a finite sequence (called rewriting sequence)</p><formula xml:id="formula_20">Q = Q 0 , Q 1 , . . . , Q k = Q (k ≥ 0), such that for all 0 &lt; i ≤ k, there is a disjunctive piece-unifier µ ∨ of Q i-1 with R ∈ R such that Q i is the one-step rewriting of Q i-1 w.r.t. µ ∨ .</formula><p>The following lemmas highlight fundamental properties of α ∨ and β ∨ . Lemma 1 (Preservation of entailment by α ∨ and β ∨ ). Let R be a disjunctive rule. 1. For any fact bases F 1 and F 2 such that</p><formula xml:id="formula_21">F 2 |= F 1 : if there is a trigger (R, h 1 ) on F 1 then there is a trigger (R, h 2 ) on F 2 such that α ∨ (F 2 , R, h 2 ) |= α ∨ (F 1 , R, h 1 ). 2. For any UCQs Q 1 and Q 2 such that Q 2 |= Q 1 : if there is a (disjunctive) piece-unifier µ 2 of Q 2 with R then ei- ther β ∨ (Q 2 , R, µ 2 ) |= Q 1 , or there is a (disjunctive) piece-unifier µ 1 of Q 1 with R such that β ∨ (Q 2 , R, µ 2 ) |= β ∨ (Q 1 , R, µ 1 ).</formula><p>The second lemma clarifies the tight relationship between α ∨ and β ∨ (we recall that fact bases and CQs have the same logical form; this is also true of finite sets of fact bases and UCQs). Lemma 2 (Composition of α ∨ and β ∨ ). Let R be a disjunctive rule.</p><formula xml:id="formula_22">F α ∨ (F, R, h) Q β ∨ (Q, R, µ ∨ ) α ∨ |= β ∨ |= F α ∨ (F, R, h) Q β ∨ (Q, R, µ ∨ ) |= α ∨ |= β ∨</formula><p>1. For any fact base F : if there is a trigger (R, h) on F then there is a (disjunctive) piece-unifier</p><formula xml:id="formula_23">µ of α ∨ (F, R, h) with R such that F |= β ∨ (α ∨ (F, R, h), R, µ). 2. For any UCQ Q: if there is a piece-unifier µ of Q with R then there is a trigger (R, h) on β ∨ (Q, R, µ) such that α ∨ (β ∨ (Q, R, µ), R, h) |= Q.</formula><p>These two lemmas are keys to establish the soundness and completeness of piece-rewriting, as stated next. Theorem 3 (Soundness and completeness of piece-rewriting). Let R be a set of disjunctive rules and Q be a UCQ. Then, for any fact base F , holds</p><formula xml:id="formula_24">F, R |= Q iff there is a piece-rewriting Q of Q such that F |= Q .</formula><p>Proof. (Sketch) We show that there is a derivation of ({F }, R) leading to an F i such that F i |= Q iff there is a rewriting Q j of Q with R such that F |= Q j (with moreover j ≤ i). This equivalence relies on the following two lemmas, which are corollaries of previous Lemmas 1 and 2. Given any Boolean UCQ Q, disjunctive rule R and fact base F , the following holds (see Figure <ref type="figure" target="#fig_0">1</ref>):</p><formula xml:id="formula_25">• (Backward-forward Lemma) For any disjunctive piece- unifier µ ∨ of Q with R, if F |= β ∨ (Q, R, µ ∨ ) then there is a trigger (R, h) on F such that α ∨ (F, R, h) |= Q; • (Forward-backward Lemma) For any trigger (R, h) on F , if α ∨ (F, R, h) |= Q then either F |= Q or there is a disjunctive piece-unifier µ ∨ of Q with R, such that F |= β ∨ (Q, R, µ ∨ ).</formula><p>The (⇒) direction of the theorem is proved by induction on the length k of a derivation from {F } to F k such that F k |= Q, using forward-backward Lemma (which itself follows from Lemma 2 (Point 1) and Lemma 1 (Point 2)). The (⇐) direction is proved by induction on the length k of a rewriting sequence from Q to Q k such that F |= Q k , using backward-forward Lemma (which itself follows from Lemma 2 (Point 2) and Lemma 1 (Point 1)).</p><p>To actually compute a UCQ-rewriting of Q when one exists, it is convenient to proceed in a breadth-first manner, i.e., extend Q at each step with all the CQs that can be generated with (new) disjunctive piece-unifiers. More specifically, we inductively define the following operator W , which takes as input a UCQ Q and a disjunctive rule set R, and returns a possibly infinite set of CQs:</p><formula xml:id="formula_26">• W 0 (Q, R) = Q • For i &gt; 0, W i (Q, R) = W i-1 (Q, R)∪ {β ∨ (W i-1 (Q, R), R, µ ∨ )|µ ∨ piece-unifier with R ∈ R} • Finally, W (Q, R) = i∈N W i (Q, R).</formula><p>Proposition 1 (Properties of W ). For any UCQ Q and disjunctive rule set R, the following holds:</p><formula xml:id="formula_27">1. W (Q, R) is a complete rewriting of (Q, R). 2. If (Q, R) admits a UCQ-rewriting Q , then there is i ≥ 0 such that Q ≡ W i (Q, R). Proof. (1) Each W i (Q, R) is a piece-rewriting of Q with R and, for any piece-rewriting Q of Q with R, there is i such that Q ⊆ W i (Q, R). Hence, the union of all the W i (Q, R) is a complete rewriting of Q. (2) If (Q, R</formula><p>) admits a UCQrewriting Q , then by Theorem 3 it admits a complete piecerewriting Q , and both are necessarily equivalent. Then,</p><formula xml:id="formula_28">Q ⊆ W i (Q, R) for some i and, since Q is complete, Q ≡ W i (Q, R).</formula><p>We propose a query rewriting algorithm (see Algorithm 1) that mimics the computation of W (Q, R), while including two optimizations at each step i &gt; 0. First, it only considers new disjunctive piece-unifiers, i.e., those that involve at least one CQ generated at step i-1. Second, it removes redundant CQs in the rewriting under construction, by the computation of a cover. More specifically, Q denotes the rewriting under construction and Q new the set of CQs generated at a given step. The function cover (Lines 1 and 6) returns a cover of the given set. The function generate (Line 5) takes as input the current rewriting Q , its subset Q prev of CQs generated at the previous step, as well as R, and returns the set of generated CQs, i.e., all the β ∨ (Q , R, µ ∨ ) where µ ∨ is a new disjunctive piece-unifier. This yields the set Q new . To compute a cover of Q ∪ Q new , priority is given to Q in case of query equivalence, for termination reasons. The function removeMoreSpecific takes as input two sets of CQs and returns the first set minus its queries more specific than a query of the second set. The computation of a cover of Q ∪ Q new is decomposed into three steps (Lines 6-8): compute a cover of Q new ; remove from Q new the queries more specific than a query from Q ; and remove from Q the queries more specific than a query from Q new . Then, Q new is added to Q (Line 9). We remind that a query may have rewritings of unbounded size but still a UCQ-rewriting (see Example 2), hence the role of the cover computation is not only to remove redundancies but also to ensure that the algorithm halts when a UCQ-rewriting has been found.</p><p>The correctness of the algorithm is based on the soundness and completeness of the W operator, however attention should be paid to the potential impact of query removal on completeness (Lines 6 to 8). Indeed, when a CQ Q 2 is removed because it is more specific than another CQ Q 1 , we have to ensure that any CQ that could be generated using Q 2 is more specific than another CQ already present in the curent rewriting, or than a CQ that can be generated using Q 1 . Fortunately, this property is ensured by Lemma 1 (Point 2), considering Q and Q new at the end of Line 5, then taking</p><formula xml:id="formula_29">Q 2 = Q ∪ Q new and Q 1 = Q 2 \ {Q 2 }.</formula><p>Algorithm 1: BREADTH-FIRST REWRITING Data: UBCQ Q and set of disjunctive rules R Result: A sound and complete rewriting of</p><formula xml:id="formula_30">Q 1 Q new ← cover(Q); // new CQs 2 Q ← Q new ; // result 3 while Q new = ∅ do 4 Q prev ← Q new // CQs from the preceding step 5 Q new ← generate(Q , Q prev , R); // new CQs 6 Q new ← cover(Q new ) 7 Q new ← removeMoreSpecific(Q new , Q ) 8 Q ← removeMoreSpecific(Q , Q new ) 9 Q ← Q ∪ Q new 10 return Q Theorem 4.</formula><p>Algorithm 1 computes a sound and complete rewriting. Moreover, it halts and outputs a minimal rewriting when (Q, R) is UCQ-rewritable.</p><p>Proof. By induction on the number of iterations of the while loop, we prove the following invariant of the algorithm, using Lemma 1 (Point 2): after step i, Q is equivalent to W i (Q, R). Then, soundness and completeness follow from Proposition 1. Line 7 ensures that Q new becomes empty when Q is a complete rewriting. Since a cover of Q is computed at each step, the output set is of minimal size.</p><p>Further remarks on completeness. When it comes to practical implementations, one may find simpler to rely on (conjunctive) piece-unifiers that unify the smallest possible subsets of a CQ. Such piece-unifiers are called singlepiece <ref type="bibr" target="#b25">(König et al. 2015)</ref>. In the specific case of datalog, a single-piece unifier unifies a single atom of a CQ with a rule head. Piece-rewriting restricted to single-piece unifiers is complete for conjunctive rules <ref type="bibr" target="#b25">(König et al. 2015)</ref>, but it is no longer so with disjunctive rules. This occurs already in the case of disjunctive datalog, as illustrated next.</p><p>Example 5. Consider again the colorability example (Ex. 1) with R <ref type="figure">e(u,</ref><ref type="figure">w</ref>), g(w)} and Q 2 = {r(u), e(u, w), r(w)}. With single-piece unifiers we obtain CQs that have the shape of "chains" with a g-atom or an r-atom at each extremity. However, there are also rewritings without any occurrence of g nor r, and the only way of obtaining them is to unify two query atoms together. For instance, the CQ {v(u), e(u, u)} is obtained by unifying, on the one hand both g-atoms of a safe copy of Q 1 with g(x), and on the other hand both r-atoms of a safe copy of Q 2 with r(x). More generally, using such piece-unifiers, one can produce all the CQs that describe the odd-length cycles in the graph. Note that these CQs are incomparable with the CQs generated with single-piece unifiers. This example also shows that a UCQ may have no UCQ-rewriting although each of its CQs has one (which is here the CQ itself).</p><formula xml:id="formula_31">= v(x) → g(x) ∨ r(x) and Q = {Q 1 , Q 2 } with Q 1 = {g(u),</formula><p>Related work. To the best of our knowledge, <ref type="bibr" target="#b1">(Alfonso, Chortaras, and Stamou 2021)</ref> is the only previous work proposing a UCQ rewriting technique for general disjunctive existential rules. This technique is based on a restricted form of first-order resolution, where at each step a CQ is unified with a disjunct of a rule head (using a conjunctive piece-unifier), which produces a new disjunctive rule with fewer disjunctions; when the unified rule is conjunctive, (the negation of) a CQ is produced. In comparison, the main advantages of our proposal are the following: (1) a rewriting step directly produces a CQ and not a rule, (2) intermediate rules, which may not lead to a CQ, are avoided, and (3) there is a direct correspondence between a chase step and a rewriting step, which makes it easier to study the properties of query rewriting, especially as the rule set is not updated.</p><p>4 What are fus Disjunctive Rules?</p><p>We now address the question of identifying classes of disjunctive rules that are UCQ-rewritable. By extension of the term coined for conjunctive existential rules, we also call them fus. To the best of our knowledge, the only fus class of disjunctive rules mentioned in the literature (Alfonso, Chortaras, and Stamou 2021) is actually a slight extension of fus conjunctive rules: this class consists of disjunctive rules with an empty frontier and it is shown that such rules can be safely added to a set of fus conjunctive rules. As a matter of fact, known fus classes of conjunctive rules do not seem to be extensible to the disjunctive case. And worse, the straightforward extension of syntactic criteria that underlie fus in the conjunctive case seems to easily lead to undecidability of query answering, as shown for example in <ref type="bibr" target="#b29">(Morak 2021)</ref> for the syntactic restriction called stickiness <ref type="bibr" target="#b16">(Calì, Gottlob, and Pieris 2010)</ref>.</p><p>At first glance, one may expect nonrecursive disjunctive rule sets to be fus, as it happens for conjunctive rules. However, it is not the case, as shown by the next example: a CQ (on unary predicates) may have no UCQ-rewriting even with a single non-recursive body-atomic (disjunctive) datalog rule.</p><p>Example 6. Let the rule R = p(x, y) → t 1 (x) ∨ t 2 (y) and the BCQ Q = {t 1 (u), t 2 (u)}. Then the pair ({Q}, {R}) has no UCQ-rewriting. Indeed, a complete rewriting contains all the CQs of the following shape for any n ∈ N:</p><formula xml:id="formula_32">t 2 (u 0 ) ∧ n i=1 p(u i-1 , u i ) ∧ t 1 (u n )</formula><p>All these queries are pairwise incomparable w.r.t. homomorphism. Let us detail the first rewriting step. To unify {Q} with R, we have to make two safe copies of Q, let Q 1 and Q 2 , which are respectively unified with t 1 (x) and t 2 (y). This produces the CQ {t 2 (x), p(x, y), t 1 (y)}, isomorphic to {t 2 (u 0 ), p(u 0 , u 1 ), t 1 (u 1 )}. If we switch the unified atoms of head(R), we obtain an isomorphic CQ. All subsequent rewriting steps lead to longer paths of p-atoms.</p><p>A similar observation follows from <ref type="bibr" target="#b23">(Gerasimova et al. 2020)</ref>, which focuses on a specific disjunctive rule of the form A(x) → T (x) ∨ F (x), called a covering axiom and denoted by cov A ; their complexity results imply that the singleton set {cov A } is not fus,<ref type="foot" target="#foot_2">2</ref> which can be checked for instance by considering the query Q = {T (u), p(u, v), F (v)}.</p><p>Next, we show that such observations can be generalized to almost any source-to-target disjunctive rule. Evidently, we have to exclude disjunctive rules that are equivalent to a conjunctive rule, as classes of fus conjunctive rules are known. We also exclude disconnected rules, i.e., rules R such that body(R) ∪ head(R) is not a connected set of atoms (where connectivity is defined in the obvious way based on shared variables). Note that a rule with a head H i that has an empty frontier is disconnected, as well as a rule whose body has a connected component with an empty frontier. However, a rule with a disconnected body may not be disconnected, since head atoms may connect several connected components of the body (e.g., a "product" rule like b</p><formula xml:id="formula_33">1 (x)∧b 2 (y) → t 1 (x)∨t 2 (y)∨p(x, y) is not disconnected). Example 7 (Fus disconnected rule). Let the disconnected rule R = b(x) → t 1 (x) ∨ ∃z t 2 (z). R is not equivalent to a conjunctive rule.</formula><p>Let us check that it is fus. Given any UCQ Q, let Q 2 be the subset of Q that contains all the CQs that can be unified with ∃z t 2 (z). Any Q ∈ Q 2 necessarily contains a disconnected component of the form ∃u t 2 (u). Moreover, it is useless to unify Q with t 1 (x): in such case, let Q 2 be the CQ unified with ∃z t 2 (z), then the obtained rewriting is more specific than Q 2 . Hence, we can ignore all the produced CQs that contain a connected component of the form ∃u t 2 (u).</p><formula xml:id="formula_34">Rewriting Q with {R} amounts to rewriting Q \ Q 2 with the conjunctive rule set R = {b(x) ∧ (Q 2 \ {∃u t 2 (u)}) → t 1 (x) | Q 2 ∈ Q 2 },</formula><p>which belongs to the fus class called domain restricted <ref type="bibr" target="#b7">(Baget et al. 2011)</ref>.</p><p>In the next theorem, we restrict the head of the rule to a disjunction of two atom sets, to keep the proof simple. Theorem 5. Let R = B → H 1 ∨ H 2 be a source-to-target rule that is not disconnected nor equivalent to a conjunctive rule. Then, there is a CQ Q such that ({Q}, {R}) is not UCQ-rewritable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. (Sketch</head><formula xml:id="formula_35">) Let R = B[x 1 , x 2 , y] → ∃z 1 H 1 [x 1 , z 1 ] ∨ ∃z 2 H 2 [x 2 , z 2 )]</formula><p>, where:</p><p>• fr(R) = x 1 ∪ x 2 ; x 1 and x 2 may share variables;</p><formula xml:id="formula_36">• x i = ∅ (i = 1, 2) since R is not disconnected.</formula><p>We build the following (Boolean) CQ:</p><formula xml:id="formula_37">Q = {H s 1 [v 1 , w 1 ], p(v 1 , v 2 ), H s 2 [v 2 , w 2 ]} where each H s i [v i , w i ] is a safe copy of H i [x i , z i ]</formula><p>and p is a fresh predicate. Note that, since R is connected, both H 1 and H 2 have a frontier variable, and frontier variables being renamed in each H s i , the arity of p is at least 2. In p(v 1 , v 2 ) the order on the variables is important: a fixed order is chosen on x i (hence, v i ) and the tuple v 1 comes before the tuple v 2 . Hence, p(v 1 , v 2 ) can be seen as "directed" from v 1 to v 2 . We then proceed in two steps.</p><p>1. We show that we can produce an infinite set Q whose element CQs are pairwise incomparable by homomorphism. , where occurrences of p-atoms all have the same direction; hence, two "adjacent" p-atoms, i.e., that share variables with the same copy B i of a B, cannot be mapped one onto the other (by a homomorphism that maps B i to itself). 2. We show that no CQ Q that can be produced by piecerewriting maps by homomorphism to a CQ from Q, except by isomorphism. When there is no (conjunctive) piece-unifier that unifies</p><formula xml:id="formula_38">Let Q 0 = Q. At each step i ≥ 1, Q i is</formula><formula xml:id="formula_39">H 1 [v 1 , w 1 ] in Q with H 2 [x 2 , z 2 ]</formula><p>(the same holds if we exchange H 1 and H 2 ), all the produced Q are more specific than (including isomorphic to) CQs from Q. Otherwise, assume that a CQ Q is produced by unifying</p><formula xml:id="formula_40">H 1 [v 1 , w 1 ] with H 2 [x 2 , z 2 ].</formula><p>If Q can be mapped by homomorphism to a Q n ∈ Q, the arguments of any p-atom in Q must be pairwise distinct variables. We show that it leads to have R equivalent to the conjunctive rule B → H i (with i = 1 or i = 2), which contradicts the hypothesis on R.</p><p>It follows that Q is a subset of any sound and complete rewriting of {Q} with {R}, hence the pair ({Q}, {R}) does not admit a UCQ-rewriting.</p><p>One interest of the above proof is to provide a general construction that applies to any rule (fulfilling the conditions of the theorem). Also, the proof can be generalized to a rule head with k disjuncts, taking Q containing a safe copy of each H i plus a p-atom that connects these copies through their frontier variables.</p><p>Given this result, the notion of fus disjunctive rules does not seem to be particularly relevant. Studying the problem of deciding whether a pair (Q, R) is UCQ-rewritable seems more interesting, although it is known to be undecidable already for (conjunctive) datalog rules.<ref type="foot" target="#foot_3">3</ref> Again, little is known about classes of disjunctive rules and UCQs for which this problem would be decidable. Let us point out a few immediate cases of UCQ-rewritable pairs (Q, R):</p><p>• Q is composed of atomic CQs and R is a set of disjunctive linear existential rules (i.e., rules with an atomic body).</p><p>Indeed, only atomic CQs can be produced, and there is a finite number of them on a given set of predicates. This case was already noticed in <ref type="bibr" target="#b12">(Bourhis et al. 2016</ref>).</p><p>• Q is composed of atomic queries and R is a set of S-to-T rules. The produced CQs are obtained from the rule bodies by specializing their frontier (i.e., merging variables and replacing them by constants occurring in Q and rule heads). Hence, there is a finite number of them.</p><p>• Q is composed of variable-free CQs<ref type="foot" target="#foot_4">4</ref> and R is a set of lossless existential rules (i.e., such that all the variables in a rule body are frontier). Then, no variable is introduced by rewriting, hence the number of terms in a CQ is bounded by |consts(Q) ∪ consts(R)|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Disjunctive Mappings</head><p>We now consider UCQ-rewritability with (disjunctive) mappings. Let S and T be the sets of source and target predicates, respectively, and let M be a mapping on (S, T ).</p><p>Given a query on T , the aim is to obtain a complete rewriting w.r.t. fact bases on S. Because S and T are disjoint, CQs that contain atoms on T are useless in a rewriting. Hence, we define a mapping rewriting as a rewriting on S and use the notation S-rewriting to distinguish it from a rewriting on</p><formula xml:id="formula_41">S ∪ T . An S-rewriting Q of a UCQ Q with M is complete if, for all fact base F on S, if F, M |= Q then F |= Q . A finite complete S-rewriting is called a UCQ-S-rewriting.</formula><p>Example 8 (Colorability). We adapt Example 5 to transform the rule into a mapping. Let S = {v, e}, T = {ê, g, r} and M = {m 1 , m 2 }, with:</p><formula xml:id="formula_42">m 1 = e(x, y) → ê(x, y) m 2 = v(x) → g(x) ∨ r(x). Let Q = {Q 1 , Q 2 } with Q 1 = {g(u)</formula><p>, ê(u, w), g(w)} and Q 2 = {r(u), ê(u, w), r(w)}. Any complete S-rewriting of Q contains CQs that describe all the cycles of odd length (in other words, it defines non-2-colorability). All the other CQs that can be produced by piece-rewriting contain predicates g and r, hence are discarded.</p><p>Note that a query may have a UCQ-S-rewriting, while it does not have any UCQ-rewriting (on S ∪ T ), as illustrated by the next example. Example 9. Let S = {p} and T = {t 1 , t 2 }. Consider the (Boolean) CQ Q = {t 1 (u), t 2 (u)} and the rule R = p(x, y) → t 1 (x) ∨ t 2 (y) from Example 6. While the pair ({Q}, {R}) has no UCQ-rewriting, it has a UCQ-Srewriting, which is empty. Indeed, all the CQs that can be obtained by piece-rewriting contain an atom on T .</p><p>Let disjunctive mapping rewritability be the following problem: Given a disjunctive mapping M on (S, T ) and a UCQ Q on T , does (Q, M) have a UCQ-S-rewriting ? Theorem 6. Disjunctive mapping rewritability is undecidable.</p><p>Proof. (Sketch) We build a reduction from the following undecidable problem: Given a (Boolean) CQ Q and a set of (conjunctive) datalog rules R, is the pair ({Q}, R) UCQrewritable? W.l.o.g. we assume that rules in R have no constants (and an atomic head). The reduction translates each instance (Q, R) defined on a set of predicates P, into an instance (Q Q,R , M Q,R ) of the disjunctive mapping rewritability problem, defined on a pair of predicats sets (S, T ) such that:</p><p>• S = P ∪ {T }, where T is a fresh unary predicate, • T is the union of: (1) a set of predicates in bijection with S, where p denotes the predicate obtained from p ∈ S, and (2) a set of fresh predicates in bijection with R, where p Ri denotes the predicate associated with the rule R i ; the arity of each p Ri is |fr(R i )|.</p><p>Given a conjunction Q (on P), we denote by Q T the conjunction (on S) obtained from Q by adding a T -atom on each term; given a conjunction Q (on S), we denote by Q the conjunction (on T ) obtained from Q by renaming all the predicates p into p. Hence, Q T is obtained by performing the first operation, then the second. Given</p><formula xml:id="formula_43">x = x 1 , . . . , x n , T [x] denotes the conjunction T (x 1 )∧• • •∧T (x n ). Similarly, T [x] = T (x 1 ) ∧ • • • ∧ T (x n ). Let Q and R = {R 1 , . . . , R n }, where R i = B i [x i , y i ] → H i [x i ]. The instance (Q Q,R , M Q,R ) is defined as follows: • Q Q,R = {Q Q } ∪ Q R with: Q Q = Q T , Q R = {Q Ri = ∃x i , y i (B i ) T [x i , y i ] ∧ p Ri (x i )|R i ∈ R} • M Q,R = M R ∪ M trans with: M R = {m Ri = T [x i ] → p Ri (x i ) ∨ Ĥi (x i ) | R i ∈ R} M trans = {p(x) → p(x) | p ∈ S}</formula><p>Based on the natural bijection between the CQs Q P defined on P and the CQs (Q P ) T defined on S, we prove that Q P belongs to a rewriting of {Q} with R iff (Q P ) T belongs to a rewriting of Q Q,R with M Q,R . Note that set membership is up to isomorphism throughout the proof. More specifically, we first prove the following lemmas:</p><p>1. For any CQ Q w in a piece-rewriting of {Q} with R, (Q w ) T belongs to a piece-rewriting of Q Q,R with M Q,R . Indeed, to each R i are associated a CQ Q Ri and a rule m Ri that allow to simulate any rewriting step performed with R i , using fresh predicate p Ri . 2. Any CQ Q S in an S-rewriting of Q Q,R with M Q,R is of the form Q S = (Q P ) T , with Q P the subset of Q S on P. 3. For any CQ of the form (Q P ) T , with Q P on P, that belongs a piece-rewriting of Q Q,R with M Q,R , Q P belongs to a piece-rewriting of {Q} with R , where R is the reflexive and transitive closure of R by unfolding (i.e., rule composition). Note that R is logically equivalent to R.</p><p>We rely on these lemmas to prove the following: if there is a UCQ-rewriting of ({Q}, R) then there is a UCQ-Srewriting of (Q Q,R , M Q,R ). The proof of the opposite direction is similar. Let Q be a UCQ-rewriting of ({Q}, R). Then there is a piece-rewriting Q i of {Q} with R such that Q i ≡ Q. By Lemma 1, there is a piece-rewriting</p><formula xml:id="formula_44">Q j of Q Q,R with M Q,R</formula><p>that contains all the CQs of the form (Q w ) T in bijection with the Q w in Q i . By definition, Q j is a finite rewriting of (Q Q,R , M Q,R ) and the subset Q S j of Q j that contains only the CQs on S is a finite S-rewriting of (Q Q,R , M Q,R ). Now, assume Q S j is not complete, i.e., there is a CQ that belongs to an Srewriting of (Q Q,R , M Q,R ) but that is not more specific than a CQ in Q S j ; by Lemma 2, such CQ is of the form (Q P ) T . Then there is a piece-rewriting Q j of Q Q,R with M Q,R that contains a CQ entailed by (Q P ) T ; hence such CQ is also on S, and by Lemma 2 it is of the form (Q P ) T . By Lemma 3, Q P belongs to a piece-rewriting of {Q} with R . Since R ≡ R, there is a CQ equivalent to Q P in some rewriting of ({Q}, R). Since Q i is complete, there is</p><formula xml:id="formula_45">Q c ∈ Q i such that Q P |= Q c . Hence, (Q P ) T |= (Q c ) T , so (Q P ) T |= (Q c ) T ; by Lemma 1, (Q c ) T ∈ Q j , hence (Q c ) T ∈ Q S j</formula><p>, which contradicts the fact that (Q P ) T is not more specific than a CQ in Q S j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Perspectives</head><p>In conclusion, UCQ rewriting with disjunctive existential rules appears to be extremely challenging. The main classes that ensure termination for conjunctive rules fail to be generalized. As suggested by previous work in <ref type="bibr" target="#b23">(Gerasimova et al. 2020</ref>) and our Theorem 5, the fus notion applied to disjunctive rules does not seem to add much w.r.t. fus conjunctive rules. However, it might be more relevant in the context of mappings (when it becomes UCQ-S-rewritability), which still has to be studied. Beside, a number of interesting issues remain open, in relationship with the finite rewritability of a pair (Q, R). We list here some of them: 1. Clarify the boundary between decidability and undecidability for the problem of determining whether a pair (Q, R) is UCQ-rewritable, according to specific classes of rules (and queries). In particular, UCQ-rewritability is decidable for guarded conjunctive rules and some of their generalizations <ref type="bibr" target="#b8">(Barceló et al. 2018)</ref>, does this extend to the disjunctive case?</p><p>2. We have shown that the UCQ-S-rewritability of a pair (Q, M) is undecidable (Theorem 6). Is it still the case for a pair ({Q}, M) where Q is a CQ? 3. Our undecidability proof for UCQ-S-rewritability (Theorem 6) exploits the fact that rewritings are restricted to predicates in S. If we consider instead UCQ-rewritings with source-to-target rules, we know that the problem can only be simpler, as there is an easy reduction from UCQrewritability with S-to-T -rules to UCQ-S-rewritability with mappings (one simply has to add a mapping rule per target predicate to give it an existence at the source level). Is the UCQ-rewritability of a pair (Q, R) decidable when R is a set of S-to-T rules?</p><p>4. Design an algorithm that, given a pair (Q, M), outputs a UCQ-S-rewriting for this pair when one exists.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Correspondences between β∨ (in blue) and α∨ (in red)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>produced from a safe copy of Q unified with H 1 and a safe copy of Q i-1 unified with H 2 . The piece-unifiers unifyH s 1 (resp. H s 2 ) in Q (resp. Q i-1 ) according to the isomorphism from H s 1 (resp. H s 2 ) to H 1 (resp. H 2 ). Any CQ Q k in Q is connected and follows the "pattern" H s 2 .p.(B.p) k .H s 1</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Proceedings of the 20th International Conference on Principles of Knowledge Representation and ReasoningMain Track</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>In non-Boolean queries, answer variables have to be treated as separating variables.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>That paper studies syntactic conditions on ontology-mediated CQs of the form (Q, covA) that determine the data complexity of query answering and the rewritability in some target query language. In particular, it is shown that if a (connected) CQ Q has no term x with both atoms T (x) and F (x) and contains at least one F -atom and one T -atom then answering (Q, covA) is L-hard for data complexity. Since answering a UCQ-rewritable ontologymediated query is in AC 0 for data complexity, and AC 0 ⊂ L, it follows that no covA is fus. Proceedings of the 20th International Conference on Principles of Knowledge Representation and Reasoning Main Track</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>This follows from the undecidability of determining whether a datalog program is uniformly bounded<ref type="bibr" target="#b22">(Gaifman et al. 1993)</ref>. Indeed, a datalog program R is uniformly bounded iff the pair (Q, R) is UCQ-rewritable for any full atomic query Q. In turn, UCQ-rewritability of (Q, R) can be reduced to UCQ-rewritability of (Q , R) with Q a Boolean CQ.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4"><p>If non-Boolean CQs are considered, Q can be extended to a set of full CQs. Proceedings of the 20th International Conference on Principles of Knowledge Representation and Reasoning Main Track</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>This work is partly supported by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_9GmED4q">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Rewriting guarded existential rules into small datalog programs</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ahmetaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Simkus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st International Conference on Database Theory, ICDT</title>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Ucq-rewritings for disjunctive knowledge and queries with negated atoms</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Alfonso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Chortaras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Stamou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="685" to="709" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Disjunctive datalog with existential quantifiers: Semantics, decidability, and complexity issues</title>
		<author>
			<persName><forename type="first">M</forename><surname>Alviano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Faber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Manna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Pract. Log. Program</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4-5</biblScope>
			<biblScope unit="page" from="701" to="718" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Foundations of schema mapping management</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riveros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<meeting><address><addrLine>PODS</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="page" from="227" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The recovery of a schema mapping: bringing exchanged data back</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riveros</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<meeting><address><addrLine>PODS</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Pushing the EL envelope</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th International Joint Conference on Artificial Intelligence, IJCAI 2005</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="364" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Extending Decidable Cases for Rules with Existential Variables</title>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-L</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st International Joint Conference on Artificial Intelligence, IJCAI</title>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="677" to="682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Firstorder rewritability of frontier-guarded ontology-mediated queries</title>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th International Joint Conference on Artificial Intelligence, IJCAI 2018</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1707" to="1713" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A proof procedure for data dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="718" to="741" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Model management and schema mappings: Theory and practice</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">A</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">33rd International Conference on Very Large Data Bases</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="1439" to="1440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Ontology-based data access: A study through disjunctive datalog, csp, and MMSNP</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ten Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="33" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Guarded-Based Disjunctive Tuple-Generating Dependencies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Morak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parallelisable existential rules: a story of pieces</title>
		<author>
			<persName><forename type="first">M</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting><address><addrLine>KR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="page" from="162" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Taming the infinite chase: Query answering under expressive relational constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting><address><addrLine>KR</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A General Datalog-Based Framework for Tractable Query Answering over Ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<meeting><address><addrLine>PODS</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="page" from="77" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Advanced processing for ontological queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="554" to="565" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Restricted Chase (Non)Termination for Existential Rules with Disjunctions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th International Joint Conference on Artificial Intelligence, IJCAI 2017</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="922" to="928" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Disjunctive datalog</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="364" to="418" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Quasi-inverses of schema mappings</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Undecidable optimization problems for database logic programs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Gaifman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">G</forename><surname>Mairson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="683" to="713" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A data complexity and rewritability tetrachotomy of ontology-mediated queries with a covering axiom</title>
		<author>
			<persName><forename type="first">O</forename><surname>Gerasimova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kikot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kurucz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">V</forename><surname>Podolskii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting><address><addrLine>KR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="page" from="403" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the complexity of ontological reasoning under disjunctive existential rules</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Morak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Foundations of Computer Science 2012 -37th International Symposium, MFCS 2012</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7464</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Sound, complete and minimal ucq-rewriting for existential rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>König</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="451" to="475" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On the complexity of Horn description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
		<ptr target="-WS.org" />
	</analytic>
	<monogr>
		<title level="m">2nd Workshop on OWL: Experiences and Directions</title>
		<title level="s">CEUR WS Proceedings. CEUR</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">216</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Query rewriting with disjunctive existential rules and mappings</title>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pérution-Kihli</surname></persName>
		</author>
		<idno>CoRR abs/2306.05973</idno>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Conjunctive Query Answering in the Description Logic EL Using a Re-lational Database System</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st International Joint Conference on Artificial Intelligence, IJCAI 2009</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="2070" to="2075" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Sticky Existential Rules and Disjunction are Incompatible</title>
		<author>
			<persName><forename type="first">M</forename><surname>Morak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting><address><addrLine>KR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="page" from="691" to="695" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The inverse of a schema mapping</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pérez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Exchange, Integration, and Streams, volume 5 of Dagstuhl Follow-Ups</title>
		<title level="s">Schloss Dagstuhl -Leibniz-Zentrum für Informatik</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="69" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Linking Data to Ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Data Semant</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="133" to="173" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Sound and Complete Forward and Backward Chainings of Graph Rules</title>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th International Conference on Conceptual Structures</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>ICCS</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996. 1996</date>
			<biblScope unit="volume">1115</biblScope>
			<biblScope unit="page" from="248" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Attributive concept descriptions with complements</title>
		<author>
			<persName><forename type="first">M</forename><surname>Schmidt-Schauß</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="26" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">OWL 2 Web Ontology Language: Document Overview</title>
		<author>
			<persName><surname>W3c</surname></persName>
		</author>
		<ptr target="http://www.w3.org/TR/owl2-overview/" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
