<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Integrating connection search in graph queries</title>
				<funder ref="#_tsxEjUB">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christos</forename><surname>Angelos</surname></persName>
							<email>angelos.anadiotis@oracle.com</email>
						</author>
						<author>
							<persName><surname>Anadiotis</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<email>ioana.manolescu@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Madhulika</forename><surname>Mohanty</surname></persName>
							<email>madhulika.mohanty@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<address>
									<settlement>Oracle</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Inria and IPP</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Inria and IPP</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Integrating connection search in graph queries</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">3AF57392A5F46952DCC6362CFC37658C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Graph data management and querying has many practical applications. When graphs are very heterogeneous and/or users are unfamiliar with their structure, they may need to find how two or more groups of nodes are connected in a graph, even when users are not able to describe the connections. This is only partially supported by existing query languages, which allow searching for paths, but not for trees connecting three or more node groups. The latter is related to the NP-hard Group Steiner Tree problem, and has been previously considered for keyword search in databases.</p><p>In this work, we formally show how to integrate connecting tree patterns (CTPs, in short) within a graph query language such as <software>SPARQL</software> or Cypher, leading to an Extended Query Language (or EQL, in short). We then study a set of algorithms for evaluating CTPs; we generalize prior keyword search work, most importantly by (ğ‘–) considering bidirectional edge traversal and (ğ‘–ğ‘–) allowing users to select any score function for ranking CTP results. To cope with very large search spaces, we propose an efficient pruning technique and formally establish a large set of cases where our algorithm, <software ContextAttributes="created">MoLESP</software>, is complete even with pruning. Our experiments validate the performance of our CTP and EQL evaluation algorithms on a large set of synthetic and real-world workloads.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>Graph databases are increasingly adopted in a wide range of applications spanning from social network analysis to scientific data exploration, the financial industry, and many more. To query RDF graphs, one can use the W3C's standard <software ContextAttributes="created">SPARQL</software> <ref type="bibr" target="#b12">[13]</ref> query language; for property graphs, Cypher <ref type="bibr" target="#b34">[35]</ref> is among the best known. An interesting but challenging query language feature is reachability: a <software ContextAttributes="created">SPARQL</software> 1.1 query can check, e.g., if there are some paths along which Mr. Shady deposits funds into a given bank ABC. Such queries are important in investigative journalism applications <ref type="bibr" target="#b4">[5]</ref>, in the fight against money laundering, etc. <software ContextAttributes="created">SPARQL</software> allows checking for the existence of a path, but does not return the matching paths to users. In contrast, a Cypher query may also return the paths between two given sets of nodes.</p><p>Unfortunately, none of these languages support finding trees, connecting three (or more) sets of nodes, while the latter can be very useful. For instance, when investigating ill-acquired wealth, one may want to find "all connections between Mr. Shady, bank company ABC, and the tax office of the DEF republic": an answer to this query is a tree, connecting three nodes corresponding to the person, bank, and tax office, respectively.</p><p>Searching for connections among ğ‘š sets of nodes is closely related to the Group Steiner Tree Problem (GSTP), which asks for the least-cost, e.g., fewest-edges, tree; the problem is NP-hard. The database literature has studied many variants of this problem under the * Work done while at Ecole Polytechnique. name of keyword search in databases, for e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b43">44]</ref>. To cope with the high complexity, existing algorithms (ğ‘–) consider a fixed cost function and leverage its properties to limit the search, (ğ‘–ğ‘–) propose approximate solutions, within a known distance from the optimum, and/or (ğ‘–ğ‘–ğ‘–) implement heuristics without guarantees but which have performed well on some problems. Requirements Our recent collaborations with investigative journalists <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref> lead to identifying the following set of needs. First, (R1) graph query languages should allow returning trees that connect ğ‘š node sets, for some integer ğ‘š â‰¥ 2; (R2) it must be possible to search for connecting trees orthogonally to (or, in conjunction with any) score functions used to compare and rank the trees. This is because different graphs and applications are best served by different scores, and when exploring a graph, journalists need to experiment with several before they find interesting patterns. For instance, in the example above, if Mr. Shady is a citizen of DEF and ABC has offices there, the smallest solution connects them through the DEF country node; however, this is not interesting to journalists. Instead, a connection through three ABC accounts, sending money from DEF to Mr. Shady in country GHI, is likely much more interesting. An orthogonal requirement is (R3) to treat graphs as undirected when searching for trees. For instance, the graph may contain "Mr. Shady hasAccount ---------â†’ acct 1 ", or, just as likely, "acct 1 belongsTo --------â†’ Mr. Shady". We cannot afford to miss a connecting tree because we "expected" an edge in a direction and it happens to be in the opposite direction. Further, (R4) all answers need to be found (within a time and/or space budget) for several reasons: (ğ‘–) continuity with the semantics of standard graph query languages, that also return all results (unless users explicitly LIMIT the result size); (ğ‘–ğ‘–) to remain independent of, and thus orthogonal to, the cost function (recall (R2)); and, (ğ‘–ğ‘–ğ‘–) for practical reasons, given the problem complexity, which is further exacerbated by (R3), and renders complete search on large graphs unfeasible. Finally, (R5) the extended queries should be efficiently executed, even when graphs are highly heterogeneous, as in investigative journalism scenarios, where text, structured, and/or semistructured sources are integrated together. Contributions To address the above requirements, we make the following contributions:</p><p>(1) We formally define an Extended Query Language (EQL, in short), which combines together Basic Graph Pattern (or conjunctive) queries at the core of both <software>SPARQL</software> and Cypher, and Connecting Tree Patterns (CTPs, in short). A CTP allows searching for trees that connect ğ‘š groups of nodes, for ğ‘š â‰¥ 2. BGPs and CTPs can be freely joined. This addresses requirements (R1), (R2), and also (R3), since our CTP semantics returns trees regardless of the edge directions (Section 2).</p><p>(2) We provide a scalable EQL query evaluation strategy, which leverages existing algorithms for the well-studied problem of evaluating conjunctive queries, contributing to (R5) (Section 3).  (3) For CTP evaluation, we study a set of baseline algorithms, and explain that their performance suffers due to repeated (wasted) work and/or the need to minimize the trees they find; GAM <ref type="bibr" target="#b5">[6]</ref> algorithm is more efficient, but it does not scale in all cases. We introduce a powerful Edge Set Pruning (ESP) technique, which significantly speeds up the execution, but can lead to incompleteness. We then bring two orthogonal modifications which, combined, lead to our <software ContextAttributes="created">MoLESP</software> algorithm, for which we formally establish completeness for ğ‘š âˆˆ {2, 3}, which are most frequent, as well as for a large class of results for arbitrarily large ğ‘š. This addresses requirement (R4) and contributes to (R5) (Section 4).</p><p>(4) We experimentally show that: (ğ‘–) baseline algorithms inspired from breadth-first search are unfeasible even for small graphs; (ğ‘–ğ‘–) the optimizations we bring here over the GAM algorithm <ref type="bibr" target="#b5">[6]</ref> strongly reduce the search time; (ğ‘–ğ‘–ğ‘–) integrating our <software ContextAttributes="created">MoLESP</software> algorithm with a simple conjunctive graph query engine allows to efficiently evaluate queries in our extended language (Section 5).</p></div>
<div><head n="2">EXTENDED QUERY LANGUAGE (EQL)</head><p>Definition 2.1 (Graph). A graph G(N, E) consists of a set of nodes N and a set of edges E âŠ† N Ã— N. Each node ğ‘› âˆˆ N carries a label ğ‘™ (ğ‘›) from a label set L, which includes the empty label ğœ–. Similarly, each edge ğ‘’ âˆˆ E has a label ğ‘™ (ğ‘’) âˆˆ L.</p><p>The two main graph data models are RDF graphs, and property graphs (PGs). To illustrate, in the following, we will rely on RDF graphs; our work can be transposed with only surface changes to PGs. Figure <ref type="figure" target="#fig_0">1</ref> introduces a sample graph, assigning an integer ID and label to each node and edge. We will refer to nodes as ğ‘› 1 , ğ‘› 2 , etc., e.g., ğ‘› 1 is the node whose ID is 1 and label is OrgB, and similarly to edges as ğ‘’ 1 , ğ‘’ 2 , etc. Labels of literal nodes, e.g., ğ‘› 11 , are enclosed in quotes; the other nodes are URIs. Node and edge properties Graph nodes and edges may have other properties beyond labels; for instance, an RDF node may have 0 or more types. In our example, types are shown in parentheses under the nodes. In a PG, nodes and edges can have multiple properties. We denote by P the set of all properties that nodes and edges may have; each property ğ‘ âˆˆ P is a function ğ‘ that, given a node ğ‘› (or edge ğ‘’), returns ğ‘ (ğ‘›), the value of property ğ‘ on node ğ‘› (and similarly for ğ‘’). Without loss of generality, we consider that ğ‘™:Nâ†’L belongs to P, that is, the label is a node and/or edge property. Let V be a set of variable names, to be used in queries. Let Î© = {=, &lt;, â‰¤, âˆ¼} be a set of comparison operators, where âˆ¼ denotes pattern matching such as SQL's like operator. They are used to express predicates over nodes and/or edges, as follows: Definition 2.2 (Predicate). A condition over a variable ğ‘£ âˆˆ V is of the form ğ‘ (ğ‘£) ğ‘œğ‘ ğ‘ where ğ‘ âˆˆ P, ğ‘œğ‘ âˆˆ Î© and ğ‘ is a constant such that the operator ğ‘œğ‘ is well-defined on any value of property ğ‘ together with ğ‘. A predicate over ğ‘£ is a conjunction of conditions over ğ‘£. An empty predicate (no conditions) over ğ‘£ is simply ğ‘£.</p><p>A node ğ‘› âˆˆ N (or edge ğ‘’ âˆˆ E) satisfies the predicate if and only if, in every condition of the predicate, replacing ğ‘£ with ğ‘› (respectively, ğ‘’) and evaluating ğ‘œğ‘ yields true. For instance, ğ‘™ (ğ‘£)âˆ¼"*lice" âˆ§ ğœ (ğ‘£)=ğœ entrepreneur is a predicate consisting of two conditions, one on the label (which must end in the string "lice") and one on the type, which must be entrepreneur. This predicate is true on the node ğ‘› 3 in our example, and false on the other nodes and edges. Any node or edge satisfies the empty predicate. For readability, when a predicate consists of exactly an equality between a node or edge label and a constant, we simply use the constant to denote the predicate, thus, ğ‘™ (ğ‘£) = "Alice" can be simply written "Alice", when this is unambiguous. However, each predicate always involves exactly one variable (ğ‘£ in our example), even when the short syntax hides it. We will revert to the longer syntax when we need to make the variable explicit, e.g., use it several times in the query.</p></div>
<div><head>Definition 2.3 (Edge Pattern</head><p>). An edge pattern is a triple (ğ‘ 1 , ğ‘ 2 , ğ‘ 3 ) of three predicates: ğ‘ 1 holds over the source node of an edge, ğ‘ 2 over the edge itself, and ğ‘ 3 over the target node.</p><p>For instance, (ğ‘™ (ğ‘ )="Alice", ğ‘™ (ğ‘’)="citizenOf", ğ‘‘) states that the source node ğ‘  is labeled "Alice" and the edge ğ‘’ is labeled "citizenOf". The third predicate is a variable. With the above simplification, we can also write this pattern as ("Alice", "citizenOf", ğ‘‘).</p><p>A core construct of graph query languages is:</p><formula xml:id="formula_0">Definition 2.4 (Basic Graph Pattern). A Basic Graph Pattern (BGP)</formula><p>ğ‘ is a set of edge patterns that are connected in the following sense.</p><p>If the BGP contains at least 2 edge patterns, each pattern must have a common variable with another edge pattern. A sample BGP ğ‘ 1 is: {(ğ‘¥, "citizenOf", "USA"), (ğ‘¥, "founded", "OrgB")}. CTPs are used to find connections among nodes, as follows. When replacing each ğ‘” ğ‘– with a graph node, ğ‘£ ğ‘š+1 is bound to a subtree of G, having these nodes as leaves (we formalize this below). To visually distinguish BGPs from CTPs, we always underline the last variable of a CTP. Definition 2.6 (Core query). A core query ğ‘„ has a head and a body. The body is a set of ğ‘˜ BGPs, ğ‘˜ â‰¥ 0, and ğ‘™ CTPs, ğ‘™ â‰¥ 0, such that ğ‘˜ + ğ‘™ &gt; 0, and each underlined (last) variable from a CTP appears exactly once in ğ‘„. The head is a subset of the body variables.</p></div>
<div><head>Definition 2.5 (CT Pattern</head><p>An example core query, ğ‘„ 1 , consists of 3 BGPs and a CTP: (ğ‘¥, ğ‘¦, ğ‘§, ğ‘¤):-(ğœ (ğ‘¥) = ğœ entrepreneur , "citizenOf", "USA") ğ‘„ 1 (ğœ (ğ‘¦) = ğœ entrepreneur , "citizenOf", "France"), (ğœ (ğ‘§) = ğœ politician , "citizenOf", "France"), (ğ‘¥, ğ‘¦, ğ‘§, ğ‘¤) ğ‘„ 1 asks: "What are the connections ğ‘¤ between some American entrepreneur ğ‘¥, some French entrepreneur ğ‘¦, and some French politician ğ‘§?" We denote the CTP of this query by ğ‘” 1 . To define core query semantics, our first notion is: Definition 2.7 (BGP embedding). Given a BGP ğ‘ = {ğ‘¡ 1 , . . . , ğ‘¡ ğ‘˜ }, an embedding of ğ‘ into G is a function ğœ™, associating to each variable ğ‘£ in ğ‘, a node ğ‘› âˆˆ N or an edge ğ‘’ âˆˆ E, such that (ğ‘–) ğœ™ (ğ‘£) satisfies all the predicates on ğ‘£ in ğ‘; and (ğ‘–ğ‘–) for every edge pattern (ğ‘ , ğ‘’, ğ‘‘) in ğ‘, the edge ğœ™ (ğ‘’) âˆˆ E goes from ğœ™ (ğ‘ ) to ğœ™ (ğ‘‘).</p><p>A sample embedding ğœ™ for the first BGP of ğ‘„ 1 maps ğ‘¥ to ğ‘› 4 , "USA" to ğ‘› 10 , "citizenOf" to ğ‘’ 6 , etc.</p><p>Next, we define: The above definition allows arbitrary seed sets, in particular, an ğ‘† ğ‘– can be N, the set of all graph nodes. We adjust Def. 2.8 to allow a connecting tree to have any number of nodes from those seed sets equal to N (otherwise, only 1-node trees would appear in results).</p><formula xml:id="formula_1">Definition 2.</formula><p>Difference wrt path-based semantics Consider a simple CTP ğ‘” â€² = (ğ‘£ 1 , ğ‘£ 2 , ğ‘£ 3 ) and two seed sets ğ‘† 1 , ğ‘† 2 . ğ‘” â€² (ğ‘† 1 , ğ‘† 2 ) may differ from the set of all paths between an ğ‘† 1 node and an ğ‘† 2 node: for instance, a path going from ğ‘  1 âˆˆ ğ‘† 1 through ğ‘  â€² 1 âˆˆ ğ‘† 1 to ğ‘  2 âˆˆ ğ‘† 2 cannot appear in ğ‘” â€² (ğ‘† 1 , ğ‘† 2 ), because of our minimality condition (ğ‘–ğ‘–), requiring direct connections between seeds from different sets. Further, consider a CTP ğ‘” â€²â€² = (ğ‘£ 1 , ğ‘£ 2 , ğ‘£ 3 , ğ‘£ 4 ) and some seed sets ğ‘† 1 , ğ‘† 2 , ğ‘† 3 . One may try to compute ğ‘” â€²â€² (ğ‘† 1 , ğ‘† 2 , ğ‘† 3 ) by a three-way join of the paths from a common root node ğ‘Ÿ , to a node from ğ‘† 1 , one from ğ‘† 2 and one from ğ‘† 3 ; we call this approach path stitching. The results may differ even more: (ğ‘–) for each tree of ğ‘› nodes that appears in ğ‘” â€²â€² (ğ‘† 1 , ğ‘† 2 , ğ‘† 3 ), the three-way join produces ğ‘› results, that need deduplication; (ğ‘–ğ‘–) if a path from ğ‘Ÿ to ğ‘  1 has common nodes or even common edges with a path from ğ‘Ÿ to ğ‘  2 and/or the one from ğ‘Ÿ to ğ‘  3 , the join of these paths is not a tree, thus it cannot appear in a CTP result. This is why in this work, we compute CTP results directly (not via stitching).</p><p>Note that a CTP can have a very large number of results, as illustrated by the graph in Figure <ref type="figure" target="#fig_1">2</ref>. A CTP (1, ğ‘ + 1, ğ‘£ 3 ), asking for all the connections between the end nodes, has 2 ğ‘ solutions, or 2 |ğ¸ |/2 , which grows exponentially in |ğ¸|, the number of graph edges. This is why complete CTP result computation may be unfeasible in some cases, and we will include in our language CTP filters for limiting the CTP result computation effort. We call simple variable in a query a variable that does not occur in the last position in a CTP. For a core query ğ‘„, we define: Definition 2.9 (Simple embedding). A simple embedding of ğ‘„ in G is a function ğœ™ mapping each simple variable into a G node or edge, such that:</p><p>(  CTP filters A set of orthogonal language extensions, which allow to filter (restrict) set based CTP results, are also provided.</p><formula xml:id="formula_2">ğ‘„ (G) = ğœ‹ ğ‘¢ 1 ,...,ğ‘¢ ğ‘› (Î¦ âŠ²âŠ³ ğ‘” 1 (ğ‘†</formula><p>The keyword UNI after a CTP indicates that only unidirectional trees are sought, that is: a tree ğ‘¡, as in Def. 2.8, must have a root node, from which a directed path goes to each seed node in ğ‘¡.</p><p>Adding LABEL and a set of labels {ğ‘™ 1 , ğ‘™ 2 , . . . , ğ‘™ ğ‘˜ } after a CTP indicates that the edges in any result of that CTP must have labels from the given set.</p><p>Adding MAX ğ‘› after a CTP indicates that only trees of at most ğ‘› edges are sought.</p><p>A score function ğœ can be used to assign to each tree in a CTP result a real number ğœ (ğ‘¡) (the higher, the better). Specifying (for a given CTP or for the whole query) SCORE ğœ [TOP ğ‘˜] means that the results of each CTPs must be scored using ğœ, and the scores included in the query result. The optional TOP ğ‘˜ allows to restrict the CTP result to those having the ğ‘˜-highest ğœ scores.</p><p>Finally, a practical way to limit the evaluation of a CTP (recall the example on Figure <ref type="figure" target="#fig_1">2</ref>) is to specify a timeout ğ‘‡ (maximum allowed evaluation time); for simplicity, we consider the same ğ‘‡ is allotted to each CTP in a query. Definition 2.11 (Query). A query consists of a core query, together with 0 or more filters for each CTP.</p><p>The semantics of a query is easily derived from that of a core query (Def. 2.10), by filtering set-based CTP results accordingly.</p></div>
<div><head n="3">QUERY EVALUATION STRATEGY</head><p>An EQL query consists of a set of BGPs and a set of CTPs. Our evaluation strategy consists of the following steps: (A) Evaluate each BGP ğ‘ ğ‘– , that is, compute all embeddings of its variables, and materialize them in a (C) Compute the query result as a projection on the head variables, over the natural join of the ğµ ğ‘– and ğ¶ğ‘‡ ğ‘ƒ ğ‘— tables.</p><p>All the above steps but (B) can be implemented by leveraging an existing conjunctive graph query engine. Thus, in the sequel, we focus on efficiently computing set-based CTP results.</p></div>
<div><head n="4">COMPUTING SET-BASED CTP RESULTS</head><p>To compute ğ‘”(ğ‘† 1 , . . . , ğ‘† ğ‘š , ğ¹ ), we must find all the minimal subtrees of G = (N, E) containing exactly one node (or seed) from each ğ‘† ğ‘– , also taking into account the filters ğ¹ . Since ğ¹ is optional, we first discuss how to compute CTP results without any filter (Section 4.1 to 4.7), before discussing pushing filters (Section 4.8). Observation 1. Let us call leaf any node in a tree that is adjacent to exactly one edge. It is easy to see that in each CTP result, every leaf node is a seed. (Otherwise, the leaf could be removed while still preserving an answer, which contradicts the minimality of the result.) Clearly, the converse does not hold: in a result, some seeds may be internal nodes. We denote by sat(ğ‘¡) the node sets from which ğ‘¡ has a seed. Observation 2. As stated in Section 2, we may be only computing partial CTP results. In such cases, it is reasonable to return at least the smallest-size results, given that tree size (smaller is better) is an ingredient of many score functions (see Section 6), and small results are easy to understand. However, we do not assume "smaller is always better": that is for the score function ğœ to decide. Nor do we require users to specify a maximum result size, which may be hard for them to guess. Rather, we consider algorithms that find as many results as possible, as fast as possible, also taking into account the CTP filters, which may limit the search. Seed set size Most of our discussion assumes that no seed set is N, and that they all fit easily in memory. We briefly discuss how the contrary situations could be handled, in Section 4.9.</p></div>
<div><head n="4.1">Simple Breadth-First algorithm (BFT)</head><p>The first algorithm we consider finds the tree results in breadth-first fashion, thus we call it BFT. It starts by creating a first generation of trees ğ‘‡ 0 , containing a one-node tree, denoted Init (ğ‘›), for each seed node ğ‘› âˆˆ ğ‘† 1 âˆª . . . âˆª ğ‘† ğ‘š . Then, from each generation ğ‘‡ ğ‘– , it builds the trees ğ‘‡ ğ‘–+1 , by "growing" each tree ğ‘¡ in ğ‘‡ ğ‘– , successively, with every edge (ğ‘›, ğ‘› â€² ) adjacent to one of its nodes ğ‘› âˆˆ ğ‘¡, such that:</p><p>â€¢ (Grow1): ğ‘› â€² is not already in ğ‘¡, and â€¢ (Grow2): ğ‘› â€² is not a seed from a set ğ‘† ğ‘— âˆˆ sat(ğ‘¡). Condition (Grow1) ensures we only build trees. (Grow2) enforces the CTP result minimality condition (ğ‘–ğ‘–) (Def. 2.8). As trees grow from their original seed, they can include more seeds. When a tree has a seed from each set, it must be minimized, by removing all edges that do not lead to a seed, before reporting it in the result. For instance, with the seed sets {ğ‘› 2 } and {ğ‘› 4 } on the graph in Figure <ref type="figure" target="#fig_0">1</ref>, starting from ğ‘› 2 , BFT may build {ğ‘’ 5 , ğ‘’ 4 }, then {ğ‘’ 5 , ğ‘’ 4 , ğ‘’ 6 } before realizing that ğ‘’ 4 is useless, and removing it through minimization. Minimization slows BFT down, as we experimentally show in Section 5.4.1. BFT can build a tree in multiple ways; to avoid duplicate work, any tree built during the search must be stored, and each new tree is checked against this memory of the search.</p><p>It is easy to see that BFT is complete, i.e., given enough time and memory, it finds all CTP results.</p></div>
<div><head n="4.2">GAM algorithm</head><p>The GAM (Grow and Aggressive Merge) algorithm has been introduced recently <ref type="bibr" target="#b5">[6]</ref>, reusing some ideas from <ref type="bibr" target="#b15">[16]</ref>. Unlike BFT that views a tree as a set of edges, GAM distinguishes one root node in each tree it builds. The algorithm uses a priority queue where Grow opportunities are inserted, as (tree, edge) pairs such that the tree could grow from its root with that edge.</p><p>GAM also starts from the set of Init trees built from the seed sets. Next, it inserts in the priority queue all (ğ‘¡, ğ‘’) pairs for some Init tree ğ‘¡ and edge ğ‘’ adjacent to the root (only node) of ğ‘¡, satisfying the conditions (Grow1) and (Grow2) introduced in Section 4.1. GAM then repeats the following, until no new trees can be built, or a time-out is reached:</p><p>(1) (Grow): Pop a highest-priority (ğ‘¡, ğ‘’) pair from the priority queue, where ğ‘’ = (ğ‘¡ .ğ‘Ÿğ‘œğ‘œğ‘¡, ğ‘› â€² ), and build the tree ğ‘¡ ğ‘– having all edges of ğ‘¡ as well as ğ‘’, and rooted in ğ‘› â€² . (2) (Merge): For any tree ğ‘¡ ğ‘–ğ‘– already built, such that:</p><p>â€¢ (Merge1): ğ‘¡ ğ‘–ğ‘– has the same root as ğ‘¡ ğ‘– , and no other node in common with ğ‘¡ ğ‘– ; and â€¢ (Merge2): sat(ğ‘¡ ğ‘– ) âˆ© sat(ğ‘¡ ğ‘–ğ‘– )= âˆ…, take the following steps: (a) Create ğ‘¡ ğ‘–ğ‘–ğ‘– , a tree having the edges of ğ‘¡ ğ‘– and those of ğ‘¡ ğ‘–ğ‘– , and the same root as ğ‘¡ ğ‘– and ğ‘¡ ğ‘–ğ‘– ; (b) Immediately Merge ğ‘¡ ğ‘–ğ‘–ğ‘– with all qualifying trees (see conditions Merge1, Merge2), and again merge the resulting trees etc., until no more Merge are possible; (3) For each tree ğ‘¡ ğ‘–ğ‘£ created via Grow or Merge as above: (ğ‘–) if ğ‘¡ ğ‘–ğ‘£ has a seed from each set, report it as a result; (ğ‘–ğ‘–) otherwise, push in the priority queue all (ğ‘¡ ğ‘–ğ‘£ , ğ‘’ ğ‘–ğ‘£ ) pairs such that ğ‘’ ğ‘–ğ‘£ is adjacent to the (only) root node of ğ‘¡ ğ‘–ğ‘£ , satisfying the conditions (Grow1) and (Grow2).</p><p>Property 1 (GAM completeness). The GAM algorithm is complete.</p><p>Property 2 (GAM result minimality). By construction, each result tree built by GAM is minimal (in the sense of Def. 2.8). Thus, GAM does not need to minimize the results it finds.</p><p>Search space exploration order Unlike BFT, GAM does not build trees in the strictly increasing order of their size; Merge may build quite large trees before some other, smaller trees. The order in which GAM enumerates trees is determined, first, by the priority of the queue which holds (ğ‘¡, ğ‘’) entries, and second, by the available Merge opportunities. In this work, to remain compatible with any score function, we study search algorithms regardless of (orthogonally to) the search order.</p><p>Like BFT, GAM may also build a tree in multiple ways. Formally: Definition 4.1 (Tree with provenance). A tree with provenance (or provenance, in short) is a formula of one of the forms shown below, together with one node called the provenance root:</p><p>(1) Init (ğ‘›) where ğ‘› is a seed; the root of such a provenance is ğ‘› itself; (2) Grow (ğ‘¡, ğ‘’) where ğ‘¡ is a provenance, its root is ğ‘› 0 , ğ‘’ is an edge going from ğ‘› 0 to ğ‘› 1 and ğ‘› 1 does not appear in ğ‘¡; in this case, ğ‘› 1 is the root of the Grow provenance; (3) Merge (ğ‘¡ 1 , ğ‘¡ 2 ), where ğ‘¡ 1 and ğ‘¡ 2 are provenances, rooted in ğ‘› 1 =ğ‘› 2 ; in this case, ğ‘› 1 is the root of the Merge provenance.</p><p>We call rooted tree a set of edges that, together, form a tree, together with one distinguished root node. GAM may build several provenances for the same rooted tree, e.g., Merge (Merge (ğ‘¡ 1 , ğ‘¡ 2 ),ğ‘¡ 3 ) and Merge (ğ‘¡ 2 ,Merge (ğ‘¡ 1 , ğ‘¡ 3 )), for some trees ğ‘¡ 1 , ğ‘¡ 2 , ğ‘¡ 3 . The interest of a tree as part of a possible result does not depend on its provenance. Therefore, GAM discards all but the first provenance built for a given rooted tree.</p></div>
<div><head n="4.3">BFT variants with Merge</head><p>The Merge operation can also be injected in the BFT algorithm to allow it to build some larger trees before all the smaller trees have been enumerated. We study two variants: BFT-M merges each new tree resulting from Grow with all its compatible partners (Step (2a) in Section 4.2), but does not apply Merge on top of these Merge results; in contrast, BFT-AM applies both Step (2a) and Step (2b) to aggressively merge. BFT-M and BFT-AM are obviously complete. Like BFT, they still need to minimize a potential result before reporting it. This is because BFT algorithms grow trees from any of their nodes, thus may add edges on one side of one seed node, which later turn to be useless. GAM avoids this by growing only from the root.</p></div>
<div><head n="4.4">Edge set pruning and ESP algorithm</head><p>GAM may build several rooted trees for the same set of edges. For example, on the graph in Figure <ref type="figure" target="#fig_2">3</ref> with the seeds {ğµ}, {ğ¶}, denoting a rooted tree by its edges and underlining the root, successive Grow from B lead to B-3-C, successive Grow from C lead to B-3-C, and Merge of two Grow provenances yields B-3-C. However, the root is meaningless in a CTP result, which is simply a set of edges. We introduce: Definition 4.2 (Edge set). An edge set is a set of edges that, together, form a tree such that at most 1 leaf is not a seed. A result is a particular case of edge set, where all leaves are seeds (recall Observation 1).</p><p>As GAM builds several rooted trees for an edge set, it repeats some effort: we only need to find each result once. This leads to the following pruning idea: Definition 4.3 (Edge-set pruning (ESP)). The ESP pruning technique during GAM consists of discarding any provenance ğ‘¡ 1 whose edge set is non-empty, such that another provenance ğ‘¡ 0 , corresponding to the same edge set, had been created previously.</p><p>We will call ESP, in short, the GAM algorithm (Section 4.2) enhanced with ESP. As we will show, ESP significantly speeds up GAM execution. However, ESP compromises completeness for some graphs, seed sets, and execution orders. That is: depending on the order in which various trees are built, the first (and only, due to ESP) provenance for a given edge set may prevent the algorithm from finding some results.</p><p>For instance, consider the graph in Figure <ref type="figure" target="#fig_2">3</ref>, and the seed sets â€¢ By a similar reasoning, when B-3-C is built, it is discarded by ESP, preventing the construction of of A-1-2-B-3-C. Thus, no result is found. Note that with a favorable execution order, the CTP result would be found. For instance, from A, B, C, ESP could build:</p><formula xml:id="formula_3">ğ‘† 1 = {ğ´}, ğ‘† 2 = {ğµ}, ğ‘† 3 = {ğ¶}. A possible execution of GAM is: (1) Initial trees: A, B, C.<label>(2)</label></formula><p>(1) Through successive Grow:</p><formula xml:id="formula_4">A-1, A-1-2, A-1-2-B, C-3, C-3-B (2) Then, Merge (A-1-2-B, C-3-B</formula><p>) is a provenance for the result. This raises the question: can we pick a GAM execution order that would ensure completeness, even when using ESP? Intuitively, the order should ensure that for each result ğ‘Ÿ , there exists a provenance ğ‘ ğ‘Ÿ for ğ‘Ÿ which is certainly built, which requires that at every subexpression ğ‘’ of ğ‘ ğ‘Ÿ , over an edge set ğ‘’ğ‘ , the first provenance ğ‘ ğ‘’ğ‘  we find for ğ‘’ğ‘  happens to be rooted in a node that allows to build on ğ‘’ until ğ‘ ğ‘Ÿ . Thus, the decisions made up to building ğ‘ ğ‘’ğ‘  would need to have a "look-ahead" knowledge of the future of the search, which is clearly not possible. In the above example the "bad" order builds A-1-2-B first, whereas it would be more favorable to build A-1-2-B. However, when exploring these three edges, the future of the exploration is not known; thus, we cannot "pre-determine" the best provenance for ğ‘’ğ‘ . Recall also from Section 4.2 that different orders may be suited for partial exploration with different score functions. In a conservative way, we consider an algorithm incomplete when for some "bad" execution order it may miss results.</p><p>We show that ESP finds some answers for any execution order: Property 3 (2-seed sets ESP completeness). Let ğ‘¡ be a result of a CTP with 2 seed sets. Then, ğ‘¡ is guaranteed to be found by ESP.</p><p>Here and throughout this paper, guaranteed to be found, for a rooted tree or an edge set, means that at least one provenance for it is built; ESP cannot prune the one built first.</p><p>For 1 seed set, Property 3 is trivially shown, thus we focus on ğ‘š = 2 (two seed sets). In this case, any result is path of 0 or more edges. We introduce: Definition 4.4 ((ğ‘›, ğ‘ )-rooted path). Given a CTP and its seed sets ğ‘† 1 , ğ‘† 2 , . . . , ğ‘† ğ‘š , an (ğ‘›, ğ‘ )-rooted path is a rooted path from a seed ğ‘  to a root node ğ‘›, such that the only seed in the path is ğ‘ .</p><p>Lemma 4.1. Any (ğ‘›, ğ‘ )-rooted path is guaranteed to be found by GAM with ESP.</p><p>Proof. We prove this by exhibiting a provenance for it. First, for each seed ğ‘  âˆˆ ğ‘† 1 âˆª . . . âˆª ğ‘† ğ‘š , Init (ğ‘ ) is guaranteed to be built. ESP pruning does not apply. Then, any provenance applying only Grow steps on an Init provenance, is guaranteed to be built by GAM. Such a provenance is not pruned by ESP, because it is the only provenance that could lead to its edge set. Thus, successive Grow on top of any seed ğ‘  is guaranteed to build up to ğ‘›, leading to the (ğ‘›, ğ‘ )-rooted path. â–¡ Based on the above lemma, we prove Property 3:</p><p>Proof. If the result ğ‘¡ is a node (ğ‘  1 = ğ‘  2 ), the property is trivial. If the result is a path of 1 edge, there are two provenances of the form Grow (Init); the first is already a result. Now, assume ğ‘¡ has at least two edges. For any internal node ğ‘› in ğ‘¡, the (ğ‘›, ğ‘  ğ‘– )-rooted paths from both the (seed) leaves ğ‘  1 , ğ‘  2 of ğ‘¡ are guaranteed to be found, by Lemma 4.1. Then, one of two cases may occur: (1) For some internal node ğ‘› 0 , both rooted paths (ğ‘› 0 , ğ‘  1 ) and (ğ‘› 0 , ğ‘  2 ) are created before a sequence of Grow gets from Init (ğ‘  1 ) to ğ‘  2 , and before the opposite sequence of Grow is built from Init (ğ‘  2 ), to ğ‘  1 . Without loss of generality, let ğ‘› 0 denote the first internal node for which these two rooted paths are created. Immediately, Merge on these creates a provenance of ğ‘¡. By the way we chose ğ‘› 0 , this is the first provenance for this edge set, thus not pruned. (2) On the contrary, assume that successive Grow get from one end of the path to another, before two rooted paths meet in any internal node. Assume without loss of generality that Grow (Grow (. . . Init (ğ‘  1 ). . . )) is the first one to reach ğ‘  2 . Again, by design, this is the first provenance for ğ‘¡, thus not pruned. â–¡ CTP with two seed sets (path queries) are frequent in practice; on these, GAM <ref type="bibr" target="#b5">[6]</ref> and ESP are comparable, and we experimentally show the latter is much more efficient. Next, we add more algorithmic refinements to significantly extend our completeness guarantees.</p></div>
<div><head n="4.5">MoESP algorithm</head><p>We now introduce an algorithmic variant called Merge-oriented ESP, or <software>MoESP</software>, which finds many (but not all) CTP results for arbitrary numbers of seed sets.</p><p><software>MoESP</software> works like ESP, but it creates more trees. Specifically, whenever Grow or Merge produces a provenance ğ‘¡ having strictly more seeds than any of its (one or two) children, the algorithm builds from ğ‘¡ all the so-called <software ContextAttributes="used">MoESP</software> trees ğ‘¡ â€² such that:</p><p>â€¢ ğ‘¡ â€² has the same edges (and nodes) as ğ‘¡, but â€¢ ğ‘¡ â€² is rooted in a seed node, distinct from the root of ğ‘¡. The provenance of any such ğ‘¡ â€² is denoted Mo (ğ‘¡, ğ‘Ÿ ) where Mo is special symbol and ğ‘Ÿ is the root of ğ‘¡ â€² . Within <software>MoESP</software>, Merge is allowed on <software ContextAttributes="used">MoESP</software> trees, but not Grow. More generally, Grow is disabled on any tree whose provenance includes Mo.</p><p>Clearly, <software ContextAttributes="used">MoESP</software> builds a strict superset of the rooted trees created by ESP (thus, it finds all results of ESP). It also finds the result in Figure <ref type="figure" target="#fig_2">3</ref>. Namely, after creating A, B, C:</p><p>(1) Grow leads to the trees: A-1, B-2, B-3, C-3.</p><p>( 2) where each leaf is a seed and no internal (non-leaf) node is a seed. A simple edge set is ğ‘-simple, for some integer ğ‘, if its number of leaves is at most ğ‘.</p><p>For instance, consider the sample graph in Figure <ref type="figure" target="#fig_4">4</ref>, and the 6 seed sets {ğ´}, {ğµ}, {ğ¶}, {ğ· }, {ğ¸}, {ğ¹ }. The edge set A-4-D, shown in red, is 2-simple, and so are: A-1-2-B, shown in blue; B-8-F, etc. Definition 4.6 (Simple tree decomposition of a solution). Let ğ‘¡ be a CTP result. A simple tree decomposition of ğ‘¡, denoted ğœƒ (ğ‘¡), is a set of simple edge sets which (ğ‘–) are a partition of the edges of ğ‘¡ and (ğ‘–ğ‘–) may share (leaf) nodes with each other.</p><p>For instance, in Figure <ref type="figure" target="#fig_4">4</ref>, the red, blue, and violet edges, together, form a result for the 6-seed sets CTP. A simple tree decomposition of this solution is: {A-4-D, A-1-2-B, B-7-E, B-8-F, B-3-C}. It is easy to see that a tree ğ‘¡ has a unique simple tree decomposition ğœƒ (ğ‘¡). Definition 4.7 (ğ‘-piecewise simple solution). A result ğ‘¡ is ğ‘-piecewise simple (ğ‘ps, in short), for some integer ğ‘, if every edge set in the simple tree decomposition ğœƒ (ğ‘¡) is ğ‘-simple (Def. 4.5).</p><p>The sample result above in Figure <ref type="figure" target="#fig_4">4</ref> is 2ps, since its simple tree decomposition only contains 2-simple edge sets. The following important <software ContextAttributes="used">MoESP</software> property guarantees it is found: Property 4 (<software ContextAttributes="used">MoESP</software> finds 2-piecewise simple solutions). For any number of seed sets ğ‘š, <software ContextAttributes="used">MoESP</software> is guaranteed to find any 2-piecewise simple result.</p><p>Proof. Let ğ‘¡ be a 2-piecewise simple solution and ğœƒ (ğ‘¡) = {ğ‘¡ 1 , . . . , ğ‘¡ ğ‘Ÿ } be its simple tree decomposition. It is easy to see that each ğ‘¡ ğ‘– , 1 â‰¤ ğ‘– â‰¤ ğ‘Ÿ , is a path of the form ğ‘› ğ‘– 1 , . . . , ğ‘› ğ‘– ğ‘š such that ğ‘› ğ‘– 1 and ğ‘› ğ‘– ğ‘š are seeds, while no other intermediary node is a seed. Lemma 4.1, which still holds for <software>MoESP</software>, guarantees that rooted paths are built starting from both ğ‘› ğ‘– 1 and ğ‘› ğ‘– ğ‘š . As soon as these paths meet, a tree over the edges of ğ‘¡ ğ‘– is created, then thanks to <software ContextAttributes="used">MoESP</software>, one tree rooted in ğ‘› ğ‘– 1 and another rooted in ğ‘› ğ‘– ğ‘š , over the edge set of ğ‘¡ ğ‘– , are created. Because ğœƒ (ğ‘¡) is a simple tree decomposition of ğ‘¡, if ğ‘Ÿ = 1, the property is proved. If ğ‘Ÿ &gt; 1, each seed-rooted tree based on the edge set of a ğ‘¡ ğ‘– has its root in common with at least another seed-rooted tree over another edge set(s) from ğœƒ (ğ‘¡). Therefore, aggressive Merge ensures that they are eventually all merged, leading to one provenance for ğ‘¡. â–¡</p><p>For a CTP with any number ğ‘š of seed sets, a path result is one in which no node has more than two adjacent edges. In a path result, seed and non-seed nodes alternate, with the two ends of the paths being seeds. Thus, any path result is 2ps. It follows then, as a direct consequence of Property 4:</p><p>Property 5 (<software>MoESP</software> finds all path results). For any CTP, <software ContextAttributes="used">MoESP</software> finds all the path results.</p><p>However, outside 2ps results, <software ContextAttributes="used">MoESP</software> may still fail. For instance, consider the graph in Figure <ref type="figure" target="#fig_6">5</ref>, and the seed sets {ğ´}, {ğµ}, {ğ¶}. The only result here is 3-simple. A possible <software ContextAttributes="used">MoESP</software> execution order is:</p><p>(1) Starting from A, B, C, Grow produces A-1, B-2, C-3;</p><p>(2) B-2-x, followed by B-2-x-3, which merges with C-3 into B-2-x-3-C, leading also to B-2-x-3-C and B-2-x-3-C. (3) B-2-x-1 which merges with A-1, leading to B-2-x-1-A and similar trees rooted in B and A. (4) Grow produces A-1-x. ESP discards the Merge of A-1-x with B-2-x, due to the rooted tree built at step (3), over the same set of edges. (5) A-1-x-3 is built, then Merge with C-3 creates A-1-x-3-C, and similar trees rooted in A and C. ( <ref type="formula">6</ref>) Grow produces C-3-x. ESP discards the merges of C-3-x with A-1-x due to the 3-rooted tree built at step (5) and with B-2-x due to the 3-rooted tree built at step (2). ( <ref type="formula">7</ref>) At this point, we have trees with two seeds, rooted in 1, 3, A, B and C. Grow on any of them is impossible, because they already contain all the edges adjacent to their roots. There are no Merge possibilities on their roots, either. Thus, the search fails to find a result. At steps ( <ref type="formula">4</ref>) and ( <ref type="formula">6</ref>), ESP is "short-sighted": it prevents the construction of some trees, necessary for finding the result. Next, we present another optimization which prevents such errors.</p></div>
<div><head n="4.6">LESP algorithm</head><p>The Limited Edge-Set Pruning (LESP), in short, works like ESP (Section 4.4), but it limits edge-set pruning, as follows.</p><p>â€¢ We assign to each node ğ‘›, and maintain throughout LESP execution, a seed signature ğ‘ ğ‘  ğ‘› , indicating the seed sets ğ‘† ğ‘– , 1 â‰¤ ğ‘– â‰¤ ğ‘š, such that a (ğ‘›, ğ‘  ğ‘– )-rooted path (Def. 4.4) has been built from a seed ğ‘  ğ‘– âˆˆ ğ‘† ğ‘– , to ğ‘›, since execution started. For any seed ğ‘  âˆˆ ğ‘† ğ‘– , the signature ğ‘ ğ‘  ğ‘  is initialized to 0 . . . 1 . . . 0 (a single 1 in the ğ‘–-th position). For a non-seed ğ‘›, initially ğ‘ ğ‘  ğ‘› =0; the ğ‘–-th bit is set to 1 when node ğ‘› is reached by the first rooted path from a seed in ğ‘† ğ‘– . â€¢ Prevent ESP from discarding a Merge tree rooted in ğ‘› such that: (ğ‘–) (ğ‘ ğ‘  ğ‘› ) â‰¥ 3, that is, there are at least 3 bits set to 1 in the signature ğ‘ ğ‘  ğ‘› ; and (ğ‘–ğ‘–) ğ‘› has at least 3 adjacent edges in G. Intuitively, the condition on ğ‘ ğ‘  ğ‘› encourages merging on nodes already well-connected to seeds. We denote by ğ‘‘ ğ‘› the number of G edges adjacent to ğ‘›; it can be computed and stored before evaluating any query. The condition on ğ‘‘ ğ‘› focuses the "protection against ESP" to Merge trees rooted in nodes where such protection is likely to be most useful: specifically, those where 3 or more rooted paths can meet (see Lemma 4.2 below). Grow and Merge apply on trees "spared" in this way with no restriction.</p><p>Clearly, LESP creates all the trees built by ESP, and may create more. In particular, reconsider the graph in Figure <ref type="figure" target="#fig_6">5</ref>, the associated seed sets, and the execution steps we traced in Section 4.5. At step (2), ğ‘ ğ‘  ğ‘¥ is initialized with 010 (there is a path from B to x). At step (4), when A-1-x is built, ğ‘ ğ‘  ğ‘¥ becomes 110; since (ğ‘ ğ‘  ğ‘¥ ) = 2, the tree A-1-x-2-B is pruned. However, at step ( <ref type="formula">6</ref>), when C-3-x is built, ğ‘ ğ‘  ğ‘¥ becomes 111, which, together with ğ‘‘ ğ‘¥ = 3, spares its Merge result A-1-x-3-C (despite the presence of several trees with the same edges). In turn, this merges immediately with B-2-x into a result.</p><p>We formalize the guarantees of LESP as follows.</p><p>Definition 4.8 ((ğ‘¢, ğ‘›) rooted merge). For an integer ğ‘¢ â‰¥ 3 and nonseed node ğ‘›, the (ğ‘¢, ğ‘›) rooted merge is the rooted tree resulting from merging a set of ğ‘¢ (ğ‘›, ğ‘  ğ‘– ) rooted paths, for some seeds ğ‘  1 , . . . , ğ‘  ğ‘¢ .</p><p>It follows from the (Merge2) pre-condition (Section 4.2) that in an (ğ‘¢, ğ‘›) rooted merge, each ğ‘  ğ‘– belongs to a different seed set. Further, it follows from the definition of an (ğ‘›, ğ‘  ğ‘– )-rooted path, that in a (ğ‘¢, ğ‘›) rooted merge, all seeds are on leaves. In other words, a (ğ‘¢, ğ‘›) rooted merge is a ğ‘¢-simple edge set. Lemma 4.2. Any (3, ğ‘›) rooted merge is guaranteed to be found by LESP.</p><p>Proof. For any non-seed node ğ‘›, Lemma 4.1 (which also holds for LESP) ensures that any (ğ‘›, ğ‘  ğ‘– )-rooted path is found. As soon as the third one is built, (ğ‘ ğ‘  ğ‘› ) becomes 3. This, and the hypothesis ğ‘‘ ğ‘› â‰¥ 3, ensure that the Merge of the three is not pruned. â–¡ Property 6. For any integer ğ‘¢ â‰¥ 3 and non-seed node ğ‘›, any (ğ‘¢, ğ‘›) rooted merge is guaranteed to be found by LESP.</p><p>Proof. For ğ‘¢ = 3 this is established by Lemma 4.2. Once the first (3, ğ‘›) rooted merge has been built and kept, this ensures both that ğ‘‘ ğ‘› â‰¥ 3 and (ğ‘ ğ‘  ğ‘› ) â‰¥ 3. Then, whenever a new (ğ‘›, ğ‘  ğ‘– ) rooted path, satisfying the Merge pre-conditions, is built, it is aggressively merged with the first (3, ğ‘›) rooted path, and the result is protected from pruning by LESP's special provision. The same holds during all subsequent merges with other (ğ‘›, ğ‘  ğ‘— ) rooted paths. â–¡ For 4 or more seed sets, LESP may miss results that are not (ğ‘¢, ğ‘›) rooted merges. For instance, consider the following order of execution for ğ‘† = ({ğ´}, {ğµ}, {ğ¶}, {ğ· }) on the graph in Figure <ref type="figure">6</ref>:</p><p>(1) From A, B, C, D, Grow builds: A-1, B-2, C-3, D-4.</p><p>(2) Grow builds B-2-1 which merges with A-1 into A-1-2-B.  <ref type="formula">8</ref>) Progressing similarly, we can only merge at most 3 rooted paths, in nodes 2, x or 3. We cannot merge with a path leading to the 4th seed, because the trees with the edge sets A-1-2-B and C-3-4-D, built at (2), (3) above, are not rooted in 2 nor 3, respectively, and these are the only nodes satisfying the LESP condition that "spares" some Merge trees.</p></div>
<div><head n="4.7">MoLESP algorithm</head><p>Our last algorithm, called <software>MoLESP</software>, is a GAM variant with ESP and both the modifications of <software ContextAttributes="used">MoESP</software> (which injects more trees) and LESP (which avoids ESP pruning for some Merge trees). Clearly, <software ContextAttributes="used">MoLESP</software> finds all the trees found by <software ContextAttributes="used">MoESP</software> and LESP. Further:</p><p>Property 7 (<software>MoLESP</software> finds all 3ps results). <software ContextAttributes="used">MoLESP</software> is guaranteed to find all the 3-piecewise simple results.</p><p>Proof. Let ğ‘¡ be a 3ps result. If ğ‘¡ was 2ps, <software>MoESP</software> finds it (Property 4), thus <software ContextAttributes="used">MoLESP</software> also does. Now consider that ğœƒ (ğ‘¡) has some 3-simple edge sets that are not 2-simple (thus, ğ‘š â‰¥ 3). We show that for any 3-simple edge set in ğœƒ (ğ‘¡), one provenance is built. Let ğ‘¡ 3 be such an edge set: its three leaves, denoted ğ‘› 1 , ğ‘› 2 , ğ‘› 3 , are seeds, and no internal node is a seed. Let ğ‘ denote the central node in ğ‘¡ 3 (connected to ğ‘› 1 , ğ‘› 2 , ğ‘› 3 by pairwise disjoint paths). ğ‘¡ 3 is a (3, ğ‘) rooted merge (recall Def. 4.8) and one provenance for it is built (Lemma 4.2).</p><p>The rest of the proof follows the idea in the proof of Property 4. The <software>MoESP</software> aspect of <software ContextAttributes="used">MoLESP</software> guarantees that for each edge set in ğœƒ (ğ‘¡), one tree rooted in each seed is built and not pruned; eventually, aggressive Merge of these trees builds a provenance for ğ‘¡. â–¡</p><p>As an important consequence:</p><p>Property 8. <software>MoLESP</software> is complete for ğ‘š â‰¤ 3 seed sets. Proof. Consider the possible result shapes: (ğ‘–) a single node ğ‘  1 = ğ‘  2 = ğ‘  3 : no ESP applies, thus it is found; (ğ‘–ğ‘–) a path going from ğ‘  1 = ğ‘  2 to ğ‘  3 ; such a result is 2-simple; (ğ‘–ğ‘–ğ‘–) a path going from ğ‘  1 to ğ‘  2 and then to ğ‘  3 , for some pairwise distinct ğ‘  1 , ğ‘  2 , ğ‘  3 ; such a result is 2ps; (ğ‘–ğ‘£) a tree with three distinct leaves ğ‘  1 , ğ‘  2 , ğ‘  3 , which is 3-simple. In cases (ğ‘–ğ‘–), (ğ‘–ğ‘–ğ‘–), (ğ‘–ğ‘£), Property 7 ensures the result is found. â–¡ Our strongest completeness result is: Property 9 (Restricted <software ContextAttributes="used">MoLESP</software> completeness). For any CTP of ğ‘š â‰¥ 1 seeds, MoLESP finds any result ğ‘¡, such that: each edge set ğ‘’ğ‘  âˆˆ ğœƒ (ğ‘¡) is a (ğ‘¢, ğ‘›)-rooted merge (Def. 4.8), for some integer 1 â‰¤ ğ‘¢ â‰¤ ğ‘š and non-seed node ğ‘› in ğ‘’ğ‘ . Proof. Let ğ‘¡ be a result, and assume it is ğ‘£-piecewise simple, for some integer ğ‘£. If ğ‘£ âˆˆ {2, 3}, Property 7 ensures MoLESP finds it.</p><p>On the contrary, assume ğ‘£ â‰¥ 4 and let ğ‘¡ 4 âˆˆ ğœƒ (ğ‘¡) be a (ğ‘£, ğ‘›)-rooted merge for some non-seed node ğ‘›, thus, also ğ‘£-simple. Property 6, which also holds during <software>MoLESP</software>, guarantees that one provenance for ğ‘¡ 4 is built. The end of our proof leverages the <software ContextAttributes="used">MoESP</software> aspect of the algorithm: for each such edge set in ğœƒ (ğ‘¡), one tree rooted in each seed is built and not pruned; eventually, aggressive Merge of these trees builds a provenance for ğ‘¡.</p><p>â–¡ For example, in Figure <ref type="figure">7</ref>, with the six seeds ğ´ to ğ¹ , the result is guaranteed to be found by MoLESP. Depending on the exploration order, <software ContextAttributes="used">MoESP</software> and LESP may not find it.</p><p><software>MoLESP</software> algorithm Algorithms 1 to 5, together, implement <software ContextAttributes="used">MoLESP</software>. They share a set of global variables whose names start with an uppercase letter: Res, PrioQ, Hist (the search history), and <software ContextAttributes="used">TreesRootedIn</software> (to store the trees by their roots); the latter is needed to find Merge candidates fast. Variables with lowercase names are local to each algorithm. <software ContextAttributes="used">processTree</software> feeds the priority queue with (tree, edge) pairs at line 10. <software ContextAttributes="used">recordForMerging</software> injects the extra <software ContextAttributes="used">MoESP</software> trees (Section 4.5) at lines 2 to 4. <software ContextAttributes="used">isNew</software> implements limited edge-set pruning based on the history, and the two conditions that can "spare" a tree from pruning (Section 4.6). <software ContextAttributes="used">mergeAll</software> implements aggressive merging; by calling <software ContextAttributes="used">processTree</software> on each new Merge result, through <software ContextAttributes="used">recordForMerging</software>, the result is available in the future iterations of <software ContextAttributes="used">mergeAll</software>, thus ensuring all the desired Merge.</p></div>
<div><head n="4.8">CTP evaluation in the presence of filters</head><p>We now briefly explain how various CTP filters (Section 2) can be inserted within the above algorithms. UNI-directional search is enforced by adding pre-conditions to Grow and Merge, to ensure we only create the desired provenances. LABEL {ğ‘™ 1 , ğ‘™ 2 , . . . , ğ‘™ ğ‘˜ } is enforced by restricting the Grow edges to only those carrying one of these labels; in GAM and its variants, we only add in the queue (line 10 in <software>processTree</software>), (tree, edge) pairs where the edge has an allowed label. MAX ğ‘› prevents Grow and Merge from creating a tree of more than ğ‘› edges. timeout ğ‘‡ is checked after each newly found rooted tree and within each algorithm's main loop.</p><p>For SCORE ğœ [TOP ğ‘˜], the simplest implementation calls ğœ on each new result; a vast majority of the proposed score functions can score each result independently. If the score of a result can only be computed once all the results are found, e.g. <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref>, the results need to be accumulated. For any given score ğœ, a smarter implementation may favor (with guarantees, or just heuristically) the early production of higher-score results, by appropriately chosing the priority queue order; this allows search to finish faster. Any order can be chosen in conjunction with <software ContextAttributes="used">MoLESP</software>, since its completeness guarantees are independent of the exploration order.</p></div>
<div><head n="4.9">Handling very large seed sets</head><p>Our CTP evaluation algorithms build Init trees for each seed. This has two risks: (ğ‘–) when one or more seed sets are N (all graph nodes), exploring them all may be unfeasible; (ğ‘–ğ‘–) one or more seed sets may be subsets of N, yet still much larger, e.g., one or more orders of magnitude, than the other seed sets. To handle (ğ‘–), assuming other seed sets are smaller, we only start exploring (Init, Grow etc.) from the other seed sets, and simplify accordingly the algorithms, since any encountered node is acceptable as a match for the N seed set(s). To handle (ğ‘–ğ‘–), borrowing ideas from prior work <ref type="bibr" target="#b25">[26]</ref>, we use multiple priority queues, one for each subset of the seed sets, and Grow at any point from the queue having the fewest (tree, edge) pairs. Thus, exploration initially focuses on the neighborhood of the smaller seed sets, and hopefully encounters Init trees from the large seed sets, leading to results.</p></div>
<div><head n="5">EXPERIMENTAL EVALUATION</head><p>We compare CTP evaluation algorithms, then consider systems capable, to some extent, to evaluate the language we introduced.</p></div>
<div><head n="5.1">Software and hardware setup</head><p>We implemented a parser and a query compiler for our language (Section 2) as an extension of <software>SPARQL</software>, and all the CTP evaluation algorithms from Section 4, in Java 11. Our graphs are stored in a simple table graph(id,source, edgeLabel, target) within <software ContextAttributes="used">PostgreSQL</software> 12.4; unless otherwise specified, we delegate to <software ContextAttributes="used">Postgres</software> the BGP evaluation, and joining their results with CTP ones (Section 3). When comparing CTP evaluation algorithms with in-memory competitors, we load the graph in memory prior to evaluating CTPs.</p><p>We executed our experiments on a server equipped with 2x10core Intel Xeon E5-2640 CPUs @ 2.4GHz, with 128-GB DRAM. Every execution point is averaged over 3 executions.</p></div>
<div><head n="5.2">Baselines</head><p>CTP evaluation (keyword search) algorithms Our focus is on algorithms that search for connecting trees (ğ‘–) traversing edges in both directions, (ğ‘–ğ‘–) orthogonally wrt the score function, (ğ‘–ğ‘–ğ‘–) exhaustively, at least up to ğ‘š=3 seed sets, (ğ‘–ğ‘£) capable of returning as many solutions as requested, if given enough time and memory, and (ğ‘£) applicable to arbitrary graphs, i.e., not requiring a regular graph structure. In the literature, only the GAM algorithm <ref type="bibr" target="#b5">[6]</ref> (Section 4.2) fits the bill. The BFT, BFT-M, BFT-AM algorithms (Section 4.1 and 4.3) also satisfy these conditions, and are thus natural comparison baselines; like virtually all algorithms from the literature, they start from the seeds and move gradually away looking for results.</p><p>QGSTP <ref type="bibr" target="#b38">[39]</ref> and <software ContextAttributes="used">LANCET</software> <ref type="bibr" target="#b39">[40]</ref> are the most recent GSTP approximation algorithms, for specific cost functions based on node and edge (<software ContextAttributes="used">LANCET</software>) weights. <software ContextAttributes="used">LANCET</software> relies on DPBF <ref type="bibr" target="#b15">[16]</ref> to find an initial result, which it then improves. Since QGSTP has shown strong advantage over DPBF <ref type="bibr" target="#b38">[39]</ref>, we select QGSTP as a baseline. QGSTP runs in polynomial time in the size of the graph, and by design, returns only one result; we used the authors' code. Graph query engines Our first two baselines only support checking, but not returning unbounded-length, unidirectional paths whose edge labels match a regular expression that users must provide, that is: one cannot ask for "any path". Specifically, we use <software ContextAttributes="used">Virtuoso OpenSource</software> v7.2.6 to evaluate <software ContextAttributes="used">SPARQL</software> 1.1 queries that come as close as possible to the semantics of our language. Internally, <software ContextAttributes="used">Virtuoso</software> translates an incoming <software ContextAttributes="used">SPARQL</software> query into an SQL dialect<ref type="foot" target="#foot_0">1</ref>  before executing it. Our second baseline, named <software ContextAttributes="used">Virtuoso-SQL</software>, consists of editing these SQL-like queries to remove label constraints and thus query the graph for connectivity between nodes. However, <software ContextAttributes="used">Virtuoso</software>'s SQL dialect prevented us from returning the nodes and edge labels along the found paths (whereas standard recursive SQL allows it).</p><p>Our next three baselines support checking and returning paths. JEDI <ref type="bibr" target="#b1">[2]</ref> returns all the data paths matching a <software ContextAttributes="used">SPARQL</software> property path; we use the authors' code. Neo4j supports Cypher queries asking for all directed or undirected paths between two sets of nodes. Finally, we used recursive queries in <software ContextAttributes="used">Postgres</software> v12.4 to return the label on paths between node pairs.</p></div>
<div><head n="5.3">Datasets and queries</head><p>We experiment with both synthetic and real-world RDF graphs. To compare CTP evaluation algorithms, we generate three sets of parameterized graphs and associated CTPs (Figure <ref type="figure" target="#fig_10">8</ref>). The seeds are labeled ğ´, ğµ, . . . , ğ» , non-seed nodes are labeled 1, 2 etc.; each seed set is of size 1. Line(ğ‘š, ğ‘›ğ¿) contains ğ‘š seeds, each connected to the next/previous seed by ğ‘›ğ¿ intermediary nodes, using ğ‘ ğ¿=ğ‘›ğ¿+1 edges. Comb(ğ‘›ğ´, ğ‘›ğ‘†, ğ‘ ğ¿, ğ‘‘ğµğ´) consists of a line, from which a lateral segment (called bristle) exits each seed. There are ğ‘›ğ´ bristles, each made of ğ‘›ğ‘† segments (a segment ends in another seed); each bristle segment has ğ‘ ğ¿ triples, and there are ğ‘‘ğµğ´ nodes in the main line between two successive bristles. The number of seeds is ğ‘š=ğ‘›ğ´â€¢(ğ‘›ğ‘†+1). Star(ğ‘š, ğ‘ ğ¿) has a central node connected to each of the ğ‘š seeds by a line of ğ‘ ğ¿ edges.</p><p>On each Line, Comb, and Star graph, we run a CTP defined by the ğ‘š seeds, having 1 result. For instance, on the Star in Figure <ref type="figure" target="#fig_10">8</ref>, the seed sets are {ğ´}, {ğµ}, {ğ¶}, {ğ· }. On Line and Comb, the result is 2ps (Def. 4.7), while on Star, it is a (ğ‘¢, ğ‘›) rooted merge (Def. 4.8). Thus, by Property 9, <software ContextAttributes="used">MoLESP</software> is guaranteed to find them. The topology of Line graphs minimizes the number of subtrees for a given number of edges and seeds; specifically, there are ğ‘‚ ((ğ‘šâ€¢ğ‘›ğ¿) 2 ) subtrees, while the number of rooted trees is in ğ‘‚ ((ğ‘šâ€¢ğ‘›ğ¿) 3 ). On the contrary, the Star topology raises the number of subtrees to ğ‘‚ (2 ğ‘š â€¢ğ‘ ğ¿ 2 ), while its number of rooted trees is in ğ‘‚ (2 ğ‘š â€¢ğ‘ ğ¿ 3 ). In Comb and Line graphs, <software ContextAttributes="used">MoESP</software> trees (Section 4.5) are part of results.</p><p>To study the evaluation of our extended query language, we generate parameterized Connected Dense Forest (CDF) graphs (see Figure <ref type="figure" target="#fig_11">9</ref>). Each graph contains a top forest, and a bottom forest; each of these is a set of ğ‘ ğ‘‡ disjoint, complete binary trees of depth 3. Links connect leaves from the top and bottom forests. We generate CDFs for ğ‘šâˆˆ{2,3}: when ğ‘š=2, chains of triples connect a top leaf to a bottom one; when ğ‘š=3, a Y-shaped connection goes from a top-forest leaf, to two bottom-forest ones. A CDF graph contains ğ‘ ğ¿ links, each made of ğ‘† ğ¿ triples. Only top leaves that are targets of "c" edges can participate to links, and we concentrate the links on 50% of them (the others have no links). When ğ‘š=2, only 50% of the  On CDF graphs with ğ‘š=2, we run the query (ğ‘£,ğ‘¡ğ‘™,ğ‘™) :-(ğ‘¥,"c",ğ‘¡ğ‘™), (ğ‘£, "g",ğ‘ğ‘™), (ğ‘ğ‘™,ğ‘¡ğ‘™,ğ‘™) whose two BGPs bind ğ‘¡ğ‘™, respectively, ğ‘ğ‘™ to leaves from the top and bottom forest, while its CTP asks for all the paths between each pair of such leaves. On graphs with ğ‘š=3, we run (ğ‘£,ğ‘¡ğ‘™,ğ‘™):-(ğ‘¥, "c", ğ‘¡ğ‘™), (ğ‘£, "g",ğ‘ğ‘™ 1 ), (ğ‘£, "h",ğ‘ğ‘™ 2 ),(ğ‘¡ğ‘™, ğ‘ğ‘™ 1 , ğ‘ğ‘™ 2 , ğ‘™), requiring connecting trees between ğ‘¡ğ‘™, ğ‘ğ‘™ 1 and ğ‘ğ‘™ 2 . Each CDF query has ğ‘ ğ¿ answers, one for each link.</p><p>Real-world graphs To compare with JEDI <ref type="bibr" target="#b1">[2]</ref> and QGSTP <ref type="bibr" target="#b38">[39]</ref>, we reused their datasets (a 6M triples subset of YAGO3, and a 18M triples subset of DBPedia), as well as their queries.</p></div>
<div><head n="5.4">CTP evaluation algorithms</head><p>5.4.1 Complete (baseline) algorithms. We start by comparing the algorithms without any pruning: BFT (Section 4.1), GAM (Section 4.2), and the BFT variants BFT-M and BFT-AM (Section 4.2), on synthetic Line, Comb and Star graphs of increasing size. We used a timeout ğ‘‡ of 10 minutes. In all experiments with GAM and all its variants, our exploration order (queue priority) favors the smallest trees, and breaks ties arbitrarily. Figure <ref type="figure" target="#fig_0">10</ref> depicts the algorithm running time; the color indicates the number of seed sets (3, 5 or 10), while the line pattern indicates the algorithm. Missing points (or curves) denote algorithms that did not complete by the timeout. Note the logarithmic ğ‘¦ axes.</p><p>Across these plots, BFT-M performs worse than BFT-AM. On Line graphs, the difference is a factor 2Ã— for ğ‘š = 3 and up to 100Ã— for ğ‘š = 10. On the Comb and Star graphs, BFT-M times out on the larger graphs and queries. BFT-AM takes even more than BFT-M, by a factor of 15Ã—, thus more executions timed out. GAM is much faster and completes execution in all cases. The reason, as explained in Section 4.1, is that breadth-first algorithms waste effort by minimizing results, and may find a tree in even more different ways than GAM, since they grow from any node. Thus, we exclude breadth-first algorithms from the subsequent comparisons. 5.4.2 GAM algorithm variants. On the same graphs, we compare GAM (Section 4.2), ESP (Section 4.4), <software ContextAttributes="used">MoESP</software> (Section 4.5), LESP (Section 4.6) and <software ContextAttributes="used">MoLESP</software> (Section 4.7) with the same timeout. Figure <ref type="figure" target="#fig_0">11</ref> shows the algorithm running time as well as the number of provenances they built. In all graphs but Figure <ref type="figure" target="#fig_0">11a</ref>, the ğ‘¦ axis is Distance between the seeds, sL  The plots show, first, that edge set pruning significantly reduces the running time: <software ContextAttributes="used">MoLESP</software> is faster than GAM by a factor ranging from 1.3Ã— (Line graphs) to 15Ã— (Comb graphs, ğ‘›ğ´=6, ğ‘š=18). Second, on the Star graphs, where the limited edge-set pruning (Section 4.6) applies, the performance difference between <software ContextAttributes="used">MoESP</software> and <software ContextAttributes="used">MoLESP</software> is small. This shows that the extra cost incurred by LESP and <software ContextAttributes="used">MoLESP</software>, which limit or compensate for edgeset pruning (by injecting more trees), is worth paying for the completeness guarantees of <software ContextAttributes="used">MoLESP</software>. Overall, the algorithm running times closely track the numbers of built provenances, further highlighting the interest of controlling the latter through pruning.</p></div>
<div><head>5.4.3</head><p>Comparison with QGSTP on real-world data. We now compare the winner of the above comparisons, namely <software ContextAttributes="created">MoLESP</software>, with QGSTP <ref type="bibr" target="#b38">[39]</ref> on the 18M edges DBPedia dataset and 312 CTPs used in their evaluation. Among these, 83 CTPs (respectively, 98, 85, 38, 8) have 2 (respectively, 3, 4, 5, 6) seed sets. To align with QGSTP, we added a UNI filter (unidirectional exploration only), and LIMIT 1 to stop after the first result. Each QGSTP returned result is such that Property 9 ensures <software ContextAttributes="created">MoLESP</software> finds it. Figure <ref type="figure" target="#fig_1">12</ref> shows the average runtimes grouped by ğ‘š. GAM is faster than QGSTP for ğ‘šâ‰¤5, but timed-out for the 8 CTPs with ğ‘š=6. <software ContextAttributes="created">MoLESP</software> is about 6-7Ã— faster than QGSTP for all ğ‘š values, and scales well as ğ‘š increases. Thus, <software ContextAttributes="created">MoLESP</software> is competitive also on large real-world graphs and queries.</p><p>5.5 Extended query evaluation 5.5.1 Synthetic queries on CDF benchmark. We now compare our EQL query evaluation system with the graph query baselines, on our CDF graphs (Section 5.3) generated with ğ‘šâˆˆ{2,3}, ğ‘† ğ¿ âˆˆ{3,6}, 18K to 2.4M edges, leading to 2K up to 200K results (ğ‘ ğ¿ ), respectively. We used ğ‘‡ =15 minutes. As explained in Section 2, the paths returned by the baselines, which we "stitch" for ğ‘š=3, semantically differ from CTP results; the baselines' reported time do not include the time to minimize nor deduplicate their results.</p><p>For ğ‘š=2, Figure <ref type="figure" target="#fig_2">13</ref> shows that all systems scale linearly in the input size (note the logarithmic time axis). For each system, the lower curve is on graphs with ğ‘† ğ¿ =3, while the upper curve is on graphs with ğ‘† ğ¿ =6 (these graphs are larger, thus curves go farther at right). All missing points correspond to time-out. JEDI succeeded only on the smallest graph, Neo4j timed-out on all. <software ContextAttributes="created">Virtuoso</software>-<software ContextAttributes="created">SPARQL</software> is the fastest, closely followed by <software ContextAttributes="created">Virtuoso</software>-SQL; they are both unidirectional, require the edge labels, and do not return paths. Unidirectional <software ContextAttributes="created">MoLESP</software>, which we included to compare with unidirectional baselines, is slower by approximately 3Ã— only. JEDI is slower than <software ContextAttributes="created">MoLESP</software> by 10 2 Ã— on the smallest graph, and timed-out on the others. <software ContextAttributes="created">Postgres</software> is faster than JEDI, yet at least 10Ã— slower than <software ContextAttributes="created">MoLESP</software>. <software ContextAttributes="created">MoLESP</software> is the only feasible bidirectional algorithm; it runs in under 2 minutes on the largest graph with 2.4M edges.</p><p>Figure <ref type="figure" target="#fig_4">14</ref> shows similar results for ğ‘š=3. <software ContextAttributes="created">Postgres</software> timed-out in all cases. <software ContextAttributes="created">Virtuoso-SPARQL</software> is 7Ã— faster than <software ContextAttributes="created">Virtuoso-SQL</software>; both return non-minimal, duplicate results. UNI-<software ContextAttributes="created">MoLESP</software> outperforms every system, while also returning connecting trees. Note that the bidirectional <software ContextAttributes="created">MoLESP</software> found about 7Ã— more results than the ğ‘ ğ¿ expected ones, by also connecting bottom leaves without a common parent through their grandparent node; these results are filtered by the join between the BGPs and the CTP (Section 3). Despite the much larger search space due to bidirectionality, <software ContextAttributes="created">MoLESP</software> scales well with the size of the graph.</p></div>
<div><head>5.5.2</head><p>Comparison with JEDI on real-world data. JEDI <ref type="bibr" target="#b1">[2]</ref> used a set of (unidirectional, label-constrained) <software ContextAttributes="created">SPARQL</software> 1.1 queries over YAGO3. with JEDI, <software ContextAttributes="created">Virtuoso</software> and Neo4j (<software ContextAttributes="created">Postgres</software> timed-out on all). Query ğ½ 2 has one very large seed set, while query ğ½ 3 has a N seed set.</p><p>On queries ğ½ 2 and ğ½ 3 , <software>MoLESP</software> timed out. Thus, we applied the optimizations described in Section 4.9, which enabled it to perform as shown. <software ContextAttributes="created">Virtuoso</software>-<software ContextAttributes="created">SPARQL</software> completed query ğ½ 1 , then ran out of memory. Compared with JEDI, our query evaluation engine is 2Ã— faster on ğ½ 1 , close on ğ½ 2 , and around 3Ã— slower on ğ½ 3 . <software ContextAttributes="created">MoLESP</software> took around 30% of the total time, the rest being spent by <software ContextAttributes="created">Postgres</software> in the BGP evaluation and final joins. This shows that the optimizations described in Section 4.9 make <software ContextAttributes="created">MoLESP</software> robust also to large seed sets.</p></div>
<div><head n="6">RELATED WORK AND PERSPECTIVES</head><p>We focused on extending a graph query language, such as <software ContextAttributes="created">SPARQL</software> <ref type="bibr" target="#b12">[13]</ref>, Cypher <ref type="bibr" target="#b34">[35]</ref> or <software ContextAttributes="created">GraphQL</software> <ref type="bibr" target="#b17">[18]</ref>, with connecting tree patterns (CTPs) that they currently do not support (our requirement (R1) from Section 1). Specifically, <software ContextAttributes="created">SPARQL</software> 1.1 property paths (ğ‘–) allow to check that some paths connect two nodes, not to return the path(s); (ğ‘–ğ‘–) do not allow searching for arbitrary paths (users have to specify a regular expression); (ğ‘–ğ‘–ğ‘–) are restricted to unidirectional paths only. Some PG query languages such as Neo4j's Cypher lift these restrictions, however, its implementation does not scale (Section 5.5.1) <ref type="bibr" target="#b10">[11]</ref>. <software ContextAttributes="created">RPQProv</software> <ref type="bibr" target="#b14">[15]</ref> uses recursive SQL to return path labels; JEDI <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> builds over <software ContextAttributes="created">SPARQL</software> 1.1 by returning all unidirectional paths. Many works focus on finding label-constrained paths between nodes <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b44">45]</ref>, typically by using precomputed indexes or sketches. In our CTP evaluation algorithm, an index could be integrated by "reading from it" paths (or subtrees) on which to Grow and Merge. Our CTPs extend finding paths, to finding trees that connect an arbitrary number of seed sets (ğ‘šâ‰¥3), traversing edges in any direction by default; we guarantee completeness for ğ‘šâ‰¤3 and finding a large set of results for arbitrary ğ‘š. As we explained (Section 2), path stitching leads to different results, which may require deduplication and minimization.</p><p>The CTP evaluation problem is directly related to keyword search in (semi-)structured data, addressed in many algorithms, some of which are surveyed in <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b43">44]</ref>. These prior studies differ from ours as follows: (ğ‘–) <ref type="bibr">[4, 14, 21, 23-25, 27, 32, 33, 41]</ref> are schemadependent; (ğ‘–ğ‘–) <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b40">41]</ref> assume available a compact summary of the graph; (ğ‘–ğ‘–ğ‘–) <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b30">31]</ref> depend heavily on their score functions for pruning the search, particularly to approximate the best result <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b30">31]</ref> or return only top-ğ‘˜ results <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b45">46]</ref>; (ğ‘–ğ‘£) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24]</ref> are only unidirectional. For these reasons, they fail to meet our requirements (R2) to (R5) as outlined in Section 1.</p><p>The Java-based GAM algorithm used in this work <ref type="bibr" target="#b5">[6]</ref> was sped up by up to 100Ã— in a multi-threaded, C++ version <ref type="bibr" target="#b4">[5]</ref>. <software ContextAttributes="created">MoLESP</software> brings new, orthogonal, optimizations, and novel guarantees.</p><p>Our future work includes developing adaptive EQL optimization and execution strategies and applying it to graph exploration for investigative journalism.</p></div><figure xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Sample data graph.</figDesc></figure>
<figure xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Sample "chain" graph.</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>ESP incompleteness example.</figDesc></figure>
<figure xml:id="fig_3"><head /><label /><figDesc>A set of Grow lead to these trees: A-1, B-2, B-3, C-3. (3) B-3 and C-3 merge into B-3-C. (4) Grow on A-1 leads to A-1-2, which immediately merges with B-2, forming A-1-2-B. (5) After this point: â€¢ If the tree A-1-2-B is built, for instance by Grow on A-1-2, ESP discards it since A-1-2-B was found in step (4). Lacking A-1-2-B, we cannot Grow over it to build the result provenance A-1-2-B-3-C. Nor can we build the result provenance Merge (A-1-2-B, B-3-C).</figDesc></figure>
<figure xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Sample graph for MoESP discussion.</figDesc></figure>
<figure xml:id="fig_5"><head /><label /><figDesc>) B-3 and C-3 merge into B-3-C. MoESP trees are added at this point: B-3-C and B-3-C. (3) Grow on A-1 leads to A-1-2, which merges with B-2, forming A-1-2-B. Similarly, A-1-2-B and A-1-2-B are added. (4) A-1-2-B merges with B-3-C, leading to the result. We now generalize the example by establishing completeness guarantees for MoESP.Definition 4.5 (Simple and ğ‘-simple edge set). A simple edge set is an edge set (Def. 4.</figDesc></figure>
<figure xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>MoESP incompleteness example.</figDesc></figure>
<figure xml:id="fig_7"><head>Figure 6 :( 3 )</head><label>63</label><figDesc>Figure 6: LESP incompleteness example with 4 seed sets. (3) Grow builds C-3-4 which merges with D-4 into C-3-4-D. (4) Grow builds: A-1-2; B-2-x which cannot merge with B-2 as A-1-2-B exists, and (ğ‘ ğ‘  2 ) = 2; D-4-3 which cannot merge with C-3 as C-3-4-D exists, and (ğ‘ ğ‘  3 ) = 2. (5) C-3-x merges with B-2-x to build B-2-x-3-C. (6) C-3-x-2 merges with: A-1-2, leading to C-3-x-2-1-A; and B-2, leading to C-3-x-2-B. (7) Similarly, B-2-x-3, aggressively merges with C-3, leading to B-2-x-3-C, and D-4-3, leading to B-2-x-3-4-D. (8) Progressing similarly, we can only merge at most 3 rooted paths, in nodes 2, x or 3. We cannot merge with a path leading to the 4th seed, because the trees with the edge sets A-1-2-B and C-3-4-D, built at (2), (3) above, are not rooted in 2 nor 3, respectively, and these are the only nodes satisfying the LESP condition that "spares" some Merge trees.</figDesc></figure>
<figure xml:id="fig_8"><head>6 Figure 7 : 9 (Algorithm 2 : 8 if 3 : 3 Copy 4 Add</head><label>67928334</label><figDesc>MoLESP completeness example. Algorithm 1: MoLESP(graph G, seed sets (ğ‘† 1 . . . , ğ‘† ğ‘š )) Output: Set of results, Res 1 Priority queue PrioQ â† new priority queue; 2 History Hist â† new set of edge sets; 3 foreach ğ‘† ğ‘– , 1 â‰¤ ğ‘– â‰¤ ğ‘š do PrioQ is not empty do ğ‘¡, ğ‘’) â† ğ‘ğ‘œğ‘™ğ‘™ (PrioQ); ğ‘¡ â€² â† Grow (ğ‘¡, ğ‘’); 10 Update ğ‘ ğ‘  ğ‘Ÿğ‘œğ‘œğ‘¡ (ğ‘¡ â€² ) ; processTree(ğ‘¡ â€² ); 11 end Procedure processTree(provenance ğ‘¡) 1 if isNew(ğ‘¡) then 2 Add ğ‘¡ to Hist ; 3 if isResult(ğ‘¡) then 4 Add ğ‘¡ to Res; ğ‘¡ is not a MoESP tree then 9 for edge ğ‘’ âˆˆ adjacentEdges(ğ‘¡ .ğ‘Ÿğ‘œğ‘œğ‘¡) do 10 if â„ğ‘ğ‘ ğ‘ğ‘œğ‘¡ğµğ‘’ğ‘’ğ‘›ğ¼ğ‘›ğ‘„ğ‘¢ğ‘’ğ‘¢ğ‘’ (ğ‘¡, ğ‘’) then 11 Add (ğ‘¡, ğ‘’) to PrioQ; Procedure recordForMerging(tree ğ‘¡) 1 Add ğ‘¡ to TreesRootedIn[ğ‘¡ .ğ‘Ÿğ‘œğ‘œğ‘¡]; 2 for ğ‘› âˆˆ (ğ‘›ğ‘œğ‘‘ğ‘’ğ‘  (ğ‘¡) âˆ© âˆª ğ‘– (ğ‘† ğ‘– )) do ğ‘¡ into a new tree ğ‘¡ â€² , rooted at ğ‘›, with provenance Mo(ğ‘¡, ğ‘›); ğ‘¡ â€² to TreesRootedIn[ğ‘›]; 5 MergeAll(ğ‘¡ â€² ); 6 end</figDesc></figure>
<figure xml:id="fig_9"><head>Algorithm 4 :Algorithm 5 :</head><label>45</label><figDesc>Procedure isNew(tree ğ‘¡) 1 if ğ‘¡ âˆ‰ Hist then 2 return ğ‘¡ğ‘Ÿğ‘¢ğ‘’; 3 end 4 if Î£(ğ‘ ğ‘  ğ‘¡ .ğ‘Ÿğ‘œğ‘œğ‘¡ ) â‰¥ 3 and ğ‘‘ ğ‘¡ .ğ‘Ÿğ‘œğ‘œğ‘¡ â‰¥ 3 then 5 if ğ‘¡ âˆ‰ TreesRootedIn[ğ‘¡ .ğ‘Ÿğ‘œğ‘œğ‘¡] Procedure MergeAll(tree ğ‘¡) 1 toBeMerged â† {ğ‘¡ }; 2 while toBeMerged â‰  âˆ… do 3 currentTrees â† toBeMerged; toBeMerged â† âˆ…; 4 for ğ‘¡ â€² âˆˆ currentTrees do 5 mergePartners â† TreesRootedIn[ğ‘¡ â€² .ğ‘Ÿğ‘œğ‘œğ‘¡]; 6 for ğ‘¡ ğ‘ âˆˆ mergePartners do 7 if sat(ğ‘¡ â€² ) âˆ© sat(ğ‘¡ ğ‘ ) = âˆ… and ğ‘¡ â€² âˆ© ğ‘¡ ğ‘ = {ğ‘¡ â€² .ğ‘Ÿğ‘œğ‘œğ‘¡ } then 8 ğ‘¡ â€²â€² â† Merge (ğ‘¡ â€² , ğ‘¡ ğ‘ ); 9 if isNew(ğ‘¡ â€²â€² ) then 10 Add ğ‘¡ â€²â€² to toBeMerged; 11 processTree(ğ‘¡ â€²â€² );</figDesc></figure>
<figure xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Synthetic graphs: Comb(3, 1, 2, 3) at the top left, Star(4, 2) at the top right, and Line(3, 1) at the bottom.</figDesc></figure>
<figure xml:id="fig_11"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: CDF graphs generated with ğ‘š=2, ğ‘† ğ¿ =2 (left), and with ğ‘š=3, ğ‘† ğ¿ = 3 (right). bottom forest leaves that are targets of "g" edges can participate; when ğ‘š=3, 50% of all the bottom forest leaf can participate. The links are uniformly distributed across the eligible leaves. A CDF has 12â€¢ğ‘ ğ‘‡ +ğ‘ ğ¿ â€¢ğ‘† ğ¿ edges; it has 14â€¢ğ‘ ğ‘‡ +ğ‘ ğ¿ â€¢(ğ‘† ğ¿ -1) nodes if ğ‘š=2, and 14â€¢ğ‘ ğ‘‡ +ğ‘ ğ¿ â€¢ğ‘† ğ¿ if ğ‘š=3.On CDF graphs with ğ‘š=2, we run the query (ğ‘£,ğ‘¡ğ‘™,ğ‘™) :-(ğ‘¥,"c",ğ‘¡ğ‘™), (ğ‘£, "g",ğ‘ğ‘™), (ğ‘ğ‘™,ğ‘¡ğ‘™,ğ‘™) whose two BGPs bind ğ‘¡ğ‘™, respectively, ğ‘ğ‘™ to leaves from the top and bottom forest, while its CTP asks for all the paths between each pair of such leaves. On graphs with ğ‘š=3, we run (ğ‘£,ğ‘¡ğ‘™,ğ‘™):-(ğ‘¥, "c", ğ‘¡ğ‘™), (ğ‘£, "g",ğ‘ğ‘™ 1 ), (ğ‘£, "h",ğ‘ğ‘™ 2 ),(ğ‘¡ğ‘™, ğ‘ğ‘™ 1 , ğ‘ğ‘™ 2 , ğ‘™), requiring connecting trees between ğ‘¡ğ‘™, ğ‘ğ‘™ 1 and ğ‘ğ‘™ 2 . Each CDF query has ğ‘ ğ¿ answers, one for each link.</figDesc></figure>
<figure xml:id="fig_13"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>Figure 10: Comparison of complete CTP evaluation baselines.</figDesc></figure>
<figure xml:id="fig_14"><head>Figure 12 :Figure 13 :Figure 14 :</head><label>121314</label><figDesc>Figure12: GAM and MoLESP vs. QGSTP<ref type="bibr" target="#b38">[39]</ref> on DBPedia.</figDesc></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>8 (Set-based CTP result). Let ğ‘” = (ğ‘” 1 , . . . , ğ‘” ğ‘š , ğ‘£ ğ‘š+1 ) be a CTP pattern and ğ‘† 1 , . . . , ğ‘† ğ‘š be sets of G nodes, called seed sets, such that every node in ğ‘† ğ‘– satisfies ğ‘” ğ‘– , for 1â‰¤ğ‘–â‰¤ğ‘š. The result of ğ‘” based on ğ‘† 1 , . . . , ğ‘† ğ‘š , denoted ğ‘”(ğ‘† 1 , . . . , ğ‘† ğ‘š ), is the set of all (ğ‘  1 , . . . , ğ‘  ğ‘š , ğ‘¡) tuples such that ğ‘  1 âˆˆ ğ‘† 1 , . . ., ğ‘  ğ‘š âˆˆ ğ‘† ğ‘š and ğ‘¡ is a minimal subtree of G containing the nodes ğ‘  1 , . . . , ğ‘  ğ‘š . By minimal, we mean that (ğ‘–) removing any edge from ğ‘¡ disconnects it and/or removes some ğ‘  ğ‘– from ğ‘¡, and (ğ‘–ğ‘–) ğ‘¡ contains only one node from each ğ‘† ğ‘– . In our sample graph, let ğ‘† 1 = {ğ‘› 2 , ğ‘› 4 } (US entrepreneurs), ğ‘† 2 = {ğ‘› 3 , ğ‘› 6 } (French entrepreneurs), and ğ‘† 3 = {ğ‘› 9 } (French politicians). Then, ğ‘” 1 (ğ‘† 1 , ğ‘† 2 , ğ‘† 3 ) includes (ğ‘› 4 , ğ‘› 6 , ğ‘› 9 , ğ‘¡ ğ›¼ ) where the tree ğ‘¡ ğ›¼ consists of the edges ğ‘› 4 ğ‘› 9 , also denoted by {ğ‘’ 10 , ğ‘’ 9 , ğ‘’ 11 } for brevity. Another result of this CTP is (ğ‘› 2 , ğ‘› 3 , ğ‘› 9 , ğ‘¡ ğ›½ ), with ğ‘¡ ğ›½ = {ğ‘’ 1 , ğ‘’ 2 , ğ‘’ 17 , ğ‘’ 16 }. This result is only possible because Def. 2.8 allows trees to span over G edges regardless of the edge direction. Had it required directed trees, ğ‘¡ ğ›½ would not qualify, since none of its nodes can reach the others through unidirectional paths.</figDesc><table><row><cell>ğ‘’ 10 --â†’ ğ‘› 7</cell><cell>ğ‘’ 9 â† --ğ‘› 6</cell><cell>ğ‘’ 11 â† --</cell></row></table></figure>
<figure type="table" xml:id="tab_3"><head /><label /><figDesc>1) The restriction of ğœ™ to each BGP pattern ğ‘ of ğ‘„ is an embedding of ğ‘ into G (Def. 2.7); (2) For each query CTP of the form ğ‘” = (ğ‘” 1 , . . . , ğ‘” ğ‘š , ğ‘£ ğ‘š+1 ), such that the simple variable in the predicate ğ‘” ğ‘– , for 1â‰¤ğ‘–â‰¤ğ‘š, is ğ‘£ ğ‘– , ğœ™ maps each ğ‘£ ğ‘– into a G node satisfying ğ‘” ğ‘– . Definition 2.10 (Core query result). Let ğ‘„ be a core query having the head variables ğ‘¢ 1 , . . . , ğ‘¢ ğ‘› , and the simple variables ğ‘£ 1 , . . . , ğ‘£ ğ‘ . Let Î¦ be the set of all (ğœ™ (ğ‘£ 1 ), . . . , ğœ™ (ğ‘£ ğ‘ )) tuples for any simple embedding ğœ™ of ğ‘„ in G. For each CTP ğ‘” ğ‘— in ğ‘„ of the form (ğ‘” 1 , . . . , ğ‘” ğ‘š , ğ‘£ ğ‘š+1 ),</figDesc><table><row><cell>let ğ‘£</cell><cell cols="5">ğ‘— ğ‘– be the simple variable in ğ‘” ğ‘– , 1â‰¤ğ‘–â‰¤ğ‘š. We define the ğ‘–-th seed</cell></row><row><cell cols="2">set of ğ‘” ğ‘— , denoted ğ‘†</cell><cell>ğ‘— ğ‘– , as ğœ‹</cell><cell>ğ‘– ğ‘£ ğ‘—</cell><cell>(Î¦), that is: all the nodes to which ğ‘£</cell><cell>ğ‘— ğ‘– is</cell></row><row><cell cols="5">bound in Î¦. The result of ğ‘„ is:</cell></row></table></figure>
<figure type="table" xml:id="tab_4"><head /><label /><figDesc>1 1 , . . . , ğ‘† 1 ğ‘š 1 ) âŠ²âŠ³ . . . âŠ²âŠ³ ğ‘” ğ‘™ (ğ‘† ğ‘™ 1 , . . . , ğ‘† ğ‘™ ğ‘š ğ‘™ )) where ğ‘” 1 , . . . , ğ‘” ğ‘™ are the CTPs of ğ‘„, having respectively ğ‘š ğ‘— simple variables, 1â‰¤ ğ‘— â‰¤ğ‘™, ğ‘” ğ‘— (ğ‘†</figDesc><table><row><cell>ğ‘— 1 , . . . , ğ‘† ğ‘š ğ‘— ) is the set-based CTP result of ğ‘” ğ‘— ğ‘— (Def. 2.8) on its seed sets derived from Î¦, and âŠ²âŠ³ denotes the natural</cell></row><row><cell>join on all the simple variables.</cell></row></table></figure>
<figure type="table" xml:id="tab_5"><head /><label /><figDesc>table ğµ ğ‘– .(B) For each CTP ğ‘” ğ‘— of the query, of the form (ğ‘” For 1 â‰¤ ğ‘– â‰¤ ğ‘š ğ‘— , where ğ‘£ ğ‘— ğ‘– appears also in one of the ğµ ğ‘– , take ğ‘† Compute ğ¹ ğ‘— (ğ‘” ğ‘— (ğ‘† ğ‘— )), where ğ¹ ğ‘— (â€¢) applies all the CTP filters that may be attached to ğ‘” ğ‘— . In practice, we actually push the filters in the CTP evaluation. Thus, we use the notation ğ‘” ğ‘— (ğ‘† ğ‘— , ğ¹ ğ‘— ) to denote the set-based result of ğ‘” ğ‘— given its seed sets and filters, and store it in a table ğ¶ğ‘‡ ğ‘ƒ ğ‘— .</figDesc><table><row><cell /><cell /><cell /><cell cols="2">ğ‘— 1 , . . . , ğ‘” ğ‘š ğ‘— , ğ‘£ ğ‘—</cell><cell>ğ‘— ğ‘š ğ‘— +1 ):</cell></row><row><cell cols="5">(1) ğ‘— ğ‘– is the variable in ğ‘” ğ‘– , compute the ğ‘—</cell></row><row><cell>seed set ğ‘†</cell><cell>ğ‘— ğ‘– as follows.</cell><cell /><cell /></row><row><cell>â€¢ If ğ‘£</cell><cell /><cell /><cell /><cell>ğ‘— ğ‘– to be ğœ‹</cell><cell>ğ‘– ğ‘£ ğ‘—</cell><cell>(ğµ ğ‘– )</cell></row><row><cell cols="3">(all the nodes to which ğ‘£</cell><cell cols="2">ğ‘— ğ‘– has been bound). Further, if</cell></row><row><cell cols="4">ğ‘” ğ‘– is not an empty predicate, restrict ğ‘† ğ‘—</cell><cell>ğ‘— ğ‘– to only those</cell></row><row><cell cols="4">nodes that also satisfy ğ‘” ğ‘– . ğ‘—</cell></row><row><cell cols="2">â€¢ Otherwise, we obtain ğ‘†</cell><cell cols="3">ğ‘— ğ‘– by restricting N (the graph's</cell></row><row><cell cols="4">nodes set) to those that match ğ‘” ğ‘– . ğ‘—</cell></row><row><cell>(2)</cell><cell /><cell /><cell /></row></table><note><p>ğ‘— 1 , . . . , ğ‘† ğ‘— ğ‘š ğ‘— 1 , . . . , ğ‘† ğ‘— ğ‘š</p></note></figure>
<figure type="table" xml:id="tab_6"><head /><label /><figDesc>). bottom forest leaves that are targets of "g" edges can participate; when ğ‘š=3, 50% of all the bottom forest leaf can participate. The links are uniformly distributed across the eligible leaves. A CDF has 12â€¢ğ‘ ğ‘‡ +ğ‘ ğ¿ â€¢ğ‘† ğ¿ edges; it has 14â€¢ğ‘ ğ‘‡ +ğ‘ ğ¿ â€¢(ğ‘† ğ¿ -1) nodes if ğ‘š=2, and 14â€¢ğ‘ ğ‘‡ +ğ‘ ğ¿ â€¢ğ‘† ğ¿ if ğ‘š=3.</figDesc><table /></figure>
<figure type="table" xml:id="tab_8"><head>Table 1 :</head><label>1</label><figDesc>Table1shows the queries' characteristics. We compare MoLESP similarly constrained (UNI and LABEL), on these queries, Query evaluation times (seconds) on YAGO3 dataset.</figDesc><table><row><cell>Query</cell><cell cols="3">JEDI MoLESP Virtuoso</cell><cell>Neo4j</cell></row><row><cell>ğ½ 1 : 3 BGPs, 2 CTPs</cell><cell>3.9</cell><cell>1.9</cell><cell cols="2">0.2 TimeOut</cell></row><row><cell>ğ½ 2 : 2 BGPs, 1 CTP, large seed set</cell><cell>0.9</cell><cell>1</cell><cell cols="2">OOM TimeOut</cell></row><row><cell>ğ½ 3 : 1 CTP, N seed set</cell><cell>0.75</cell><cell>2.3</cell><cell>OOM</cell><cell>1.27</cell></row></table></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>Accessible using the built-in function sparql_to_sql_text().</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments. This work is funded by <rs type="projectName">AI Chair SourcesSay</rs> project (<rs type="grantNumber">ANR-20-CHIA-0015-01</rs>) grant.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_tsxEjUB">
					<idno type="grant-number">ANR-20-CHIA-0015-01</idno>
					<orgName type="project" subtype="full">AI Chair SourcesSay</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">BANKS: Browsing and Keyword Searching in Relational Databases</title>
		<author>
			<persName><forename type="first">B</forename><surname>Aditya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumen</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charuta</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Parag</surname></persName>
		</author>
		<author>
			<persName><surname>Sudarshan</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-155860869-6/50114-1</idno>
		<ptr target="https://doi.org/10.1016/B978-155860869-6/50114-1" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 28th International Conference on Very Large Data Bases, VLDB 2002</title>
		<meeting>28th International Conference on Very Large Data Bases, VLDB 2002<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-08-20">2002. August 20-23, 2002</date>
			<biblScope unit="page" from="1083" to="1086" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Discovering Diversified Paths in Knowledge Bases</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Aebeloe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriela</forename><surname>Montoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vinay</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katja</forename><surname>Hose</surname></persName>
		</author>
		<idno type="DOI">10.14778/3229863.3236245</idno>
		<ptr target="http://qweb.cs.aau.dk/jedi/" />
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="2002" to="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Top-K Diversification for Path Queries in Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Christian</forename><surname>Aebeloe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vinay</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriela</forename><surname>Montoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Katja</forename><surname>Hose</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-2180/paper-01.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ISWC 2018 Posters &amp; Demonstrations, Industry and Blue Sky Ideas Tracks co-located with 17th International Semantic Web Conference (ISWC 2018)</title>
		<editor>
			<persName><forename type="first">Medha</forename><surname>Marieke Van Erp</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vanessa</forename><surname>Atre</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kavitha</forename><surname>LÃ³pez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Carolina</forename><surname>Srinivas</surname></persName>
		</editor>
		<editor>
			<persName><surname>Fortuna</surname></persName>
		</editor>
		<meeting>the ISWC 2018 Posters &amp; Demonstrations, Industry and Blue Sky Ideas Tracks co-located with 17th International Semantic Web Conference (ISWC 2018)<address><addrLine>Monterey, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-10-08">2018. October 8th -to -12th, 2018</date>
			<biblScope unit="volume">2180</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings)</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">DBXplorer: A System for Keyword-Based Search over Relational Databases</title>
		<author>
			<persName><forename type="first">Sanjay</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Das</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2002.994693</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2002.994693" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Data Engineering</title>
		<editor>
			<persName><forename type="first">Rakesh</forename><surname>Agrawal</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Klaus</forename><forename type="middle">R</forename><surname>Dittrich</surname></persName>
		</editor>
		<meeting>the 18th International Conference on Data Engineering<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002-02-26">2002. February 26 -March 1, 2002</date>
			<biblScope unit="page" from="5" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Empowering Investigative Journalism with Graph-based Heterogeneous Data Management</title>
		<author>
			<persName><forename type="first">Angelos-Christos</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oana</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">ThÃ©o</forename><surname>Bouganim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Chimienti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helena</forename><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yamen</forename><surname>Mhd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">StÃ©phane</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Horel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Youssr</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><surname>Youssef</surname></persName>
		</author>
		<ptr target="https://hal.archives-ouvertes.fr/hal-03337650" />
		<imprint>
			<date type="published" when="2021-09">2021. Sept. 2021</date>
		</imprint>
	</monogr>
	<note type="report_type">Bulletin of the Technical Committee on Data Engineering</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Graph integration of structured, semistructured and unstructured data for data journalism</title>
		<author>
			<persName><forename type="first">Christos</forename><forename type="middle">G</forename><surname>Angelos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oana</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catarina</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helena</forename><surname>ConceiÃ§Ã£o</surname></persName>
		</author>
		<author>
			<persName><surname>Galhardas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yamen</forename><surname>Mhd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tayeb</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingmao</forename><surname>Merabti</surname></persName>
		</author>
		<author>
			<persName><surname>You</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.is.2021.101846</idno>
		<ptr target="https://doi.org/10.1016/j.is.2021.101846" />
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="page">101846</biblScope>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">SPARQ2L: towards support for subgraph extraction queries in rdf databases</title>
		<author>
			<persName><forename type="first">Kemafor</forename><surname>Anyanwu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angela</forename><surname>Maduko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amit</forename><forename type="middle">P</forename><surname>Sheth</surname></persName>
		</author>
		<idno type="DOI">10.1145/1242572.1242680</idno>
		<ptr target="https://doi.org/10.1145/1242572.1242680" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on World Wide Web, WWW 2007</title>
		<meeting>the 16th International Conference on World Wide Web, WWW 2007<address><addrLine>Banff, Alberta, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-05-08">2007. May 8-12, 2007</date>
			<biblScope unit="page" from="797" to="806" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Time-and Space-Efficient Regular Path Queries on Graphs</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Arroyuelo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gonzalo</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javiel</forename><surname>Rojas-Ledesma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Objec-tRank: Authority-Based Keyword Search in Databases</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Balmin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-012088469-8.50051-6</idno>
		<ptr target="https://doi.org/10.1016/B978-012088469-8.50051-6" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth International Conference on Very Large Data Bases, VLDB 2004</title>
		<meeting>the Thirtieth International Conference on Very Large Data Bases, VLDB 2004<address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-08-31">2004. August 31 -September 3 2004</date>
			<biblScope unit="page" from="564" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Keyword Searching and Browsing in Databases using BANKS</title>
		<author>
			<persName><forename type="first">Gaurav</forename><surname>Bhalotia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arvind</forename><surname>Hulgeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charuta</forename><surname>Nakhe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumen</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2002.994756</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2002.994756" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Data Engineering</title>
		<meeting>the 18th International Conference on Data Engineering<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-02-26">2002. February 26 -March 1, 2002</date>
			<biblScope unit="page" from="431" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Tuning Cypher queries by understanding cardinality</title>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Bowman</surname></persName>
		</author>
		<ptr target="https://neo4j.com/developer/kb/understanding-cypher-cardinality/#_distinct_nodes_from_variable_length_paths" />
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An Empirical Performance Evaluation of Relational Keyword Search Techniques</title>
		<author>
			<persName><forename type="first">Joel</forename><surname>Coffman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alfred</forename><forename type="middle">C</forename><surname>Weaver</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2012.228</idno>
		<ptr target="https://doi.org/10.1109/TKDE.2012.228" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">SPARQL 1</title>
		<idno>.1</idno>
		<ptr target="https://www.w3.org/TR/sparql11-overview/" />
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
		<respStmt>
			<orgName>WWW Consortium</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Match-Based Candidate Network Generation for Keyword Queries over Relational Databases</title>
		<author>
			<persName><forename type="first">Altigran</forename><forename type="middle">S</forename><surname>Pericles De Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edleno</forename><surname>Da Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rosiane</forename><surname>Silva De Moura</surname></persName>
		</author>
		<author>
			<persName><surname>Rodrigues</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2018.00146</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2018.00146" />
	</analytic>
	<monogr>
		<title level="m">34th IEEE International Conference on Data Engineering, ICDE 2018</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-04-16">2018. April 16-19, 2018</date>
			<biblScope unit="page" from="1344" to="1347" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">On implementing provenance-aware regular path queries with relational query engines</title>
		<author>
			<persName><forename type="first">C</forename><surname>Saumen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">VÃ­ctor</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Cuevas-VicenttÃ­n</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>KÃ¶hler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Gribkoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bertram</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><surname>LudÃ¤scher</surname></persName>
		</author>
		<idno type="DOI">10.1145/2457317.2457353</idno>
		<ptr target="https://doi.org/10.1145/2457317.2457353" />
	</analytic>
	<monogr>
		<title level="m">Joint 2013 EDBT/ICDT Conferences, EDBT/ICDT '13</title>
		<title level="s">Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">Giovanna</forename><surname>Guerrini</surname></persName>
		</editor>
		<meeting><address><addrLine>Genoa, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013-03-22">2013. March 22, 2013</date>
			<biblScope unit="page" from="214" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Finding Top-k Min-Cost Connected Trees in Databases</title>
		<author>
			<persName><forename type="first">Bolin</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2007.367929</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2007.367929" />
		<imprint>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="836" to="845" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient regular path query evaluation using path indexes</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeroen</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName><surname>Poulovassilis</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2016.67</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2016.67" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Extending Database Technology, EDBT 2016</title>
		<editor>
			<persName><forename type="first">Evaggelia</forename><surname>Pitoura</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sofian</forename><surname>Maabout</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Georgia</forename><surname>Koutrika</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">AmÃ©lie</forename><surname>Marian</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Letizia</forename><surname>Tanca</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kostas</forename><surname>Stefanidis</surname></persName>
		</editor>
		<meeting>the 19th International Conference on Extending Database Technology, EDBT 2016<address><addrLine>Bordeaux, France; Bordeaux, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-03-15">2016. March 15-16, 2016. March 15-16, 2016</date>
			<biblScope unit="page" from="636" to="639" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">GraphQL</title>
		<ptr target="https://graphql.org/" />
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
			<publisher>The GraphQL Foundation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sparqling kleene: fast property paths in RDF-3X</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srikanta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Bedathur</surname></persName>
		</author>
		<author>
			<persName><surname>Seufert</surname></persName>
		</author>
		<idno type="DOI">10.1145/2484425.2484443</idno>
		<ptr target="https://doi.org/10.1145/2484425.2484443" />
	</analytic>
	<monogr>
		<title level="m">First International Workshop on Graph Data Management Experiences and Systems, GRADES 2013, co-located with SIG-MOD/PODS 2013</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-06-24">2013. June 24, 2013. 14</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Path Query Processing on Very Large RDF Graphs</title>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Gubichev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Neumann</surname></persName>
		</author>
		<ptr target="http://webdb2011.rutgers.edu/papers/Paper21/pathwebdb.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Workshop on the Web and Databases 2011</title>
		<meeting>the 14th International Workshop on the Web and Databases 2011<address><addrLine>WebDB; Athens, Greece</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-06-12">2011. 2011. June 12, 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">XRANK: Ranked Keyword Search over XML Documents</title>
		<author>
			<persName><forename type="first">Lin</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chavdar</forename><surname>Botev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jayavel</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<idno type="DOI">10.1145/872757.872762</idno>
		<ptr target="https://doi.org/10.1145/872757.872762" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2003 ACM SIGMOD International Conference on Management of Data<address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-06-09">2003. June 9-12, 2003</date>
			<biblScope unit="page" from="16" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">BLINKS: ranked keyword searches on graphs</title>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Hao He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><surname>Yu</surname></persName>
		</author>
		<idno type="DOI">10.1145/1247480.1247516</idno>
		<ptr target="https://doi.org/10.1145/1247480.1247516" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06-12">2007. June 12-14, 2007</date>
			<biblScope unit="page" from="305" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient IR-Style Keyword Search over Relational Databases</title>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luis</forename><surname>Gravano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-012722442-8/50080-X</idno>
		<ptr target="https://doi.org/10.1016/B978-012722442-8/50080-X" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 29th International Conference on Very Large Data Bases, VLDB 2003</title>
		<meeting>29th International Conference on Very Large Data Bases, VLDB 2003<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-09-09">2003. September 9-12, 2003</date>
			<biblScope unit="page" from="850" to="861" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">DISCOVER: Keyword Search in Relational Databases</title>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/2002/S19P02.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Keyword Proximity Search on XML Graphs</title>
		<author>
			<persName><forename type="first">Vagelis</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrey</forename><surname>Balmin</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2003.1260806</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2003.1260806" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Data Engineering</title>
		<meeting>the 19th International Conference on Data Engineering<address><addrLine>Bangalore, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03-05">2003. March 5-8, 2003</date>
			<biblScope unit="page" from="367" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Bidirectional Expansion For Keyword Search on Graph Databases</title>
		<author>
			<persName><forename type="first">Varun</forename><surname>Kacholia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shashank</forename><surname>Pandit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soumen</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rushi</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hrishikesh</forename><surname>Karambelkar</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/archives/website/2005/program/paper/wed/p505-kacholia.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Very Large Data Bases</title>
		<meeting>the 31st International Conference on Very Large Data Bases<address><addrLine>Trondheim, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-08-30">2005. August 30 -September 2, 2005</date>
			<biblScope unit="page" from="505" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">STAR: Steiner-Tree Approximation in Relationship Graphs</title>
		<author>
			<persName><forename type="first">Gjergji</forename><surname>Kasneci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maya</forename><surname>Ramanath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauro</forename><surname>Sozio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2009.64</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2009.64" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Data Engineering, ICDE 2009</title>
		<meeting>the 25th International Conference on Data Engineering, ICDE 2009<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-03-29">2009. March 29 2009 -April 2 2009</date>
			<biblScope unit="page" from="868" to="879" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Path Indexing in the Cypher Query Pipeline</title>
		<author>
			<persName><forename type="first">Jochem</forename><surname>Kuijpers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Lindaaker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2021.68</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2021.68" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on Extending Database Technology, EDBT 2021</title>
		<meeting>the 24th International Conference on Extending Database Technology, EDBT 2021<address><addrLine>Nicosia, Cyprus</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021-03-23">2021. March 23 -26, 2021</date>
			<biblScope unit="page" from="582" to="587" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Scalable Keyword Search on Large RDF Data</title>
		<author>
			<persName><forename type="first">Wangchao</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feifei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Songyun</forename><surname>Duan</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2014.2302294</idno>
		<ptr target="https://doi.org/10.1109/TKDE.2014.2302294" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2774" to="2788" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">EASE: an effective 3-in-1 keyword search method for unstructured, semistructured and structured data</title>
		<author>
			<persName><forename type="first">Guoliang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Beng</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Chin</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianhua</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianyong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lizhu</forename><surname>Zhou</surname></persName>
		</author>
		<idno type="DOI">10.1145/1376616.1376706</idno>
		<ptr target="https://doi.org/10.1145/1376616.1376706" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2008</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data, SIGMOD 2008<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06-10">2008. June 10-12, 2008</date>
			<biblScope unit="page" from="903" to="914" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Efficient and Progressive Group Steiner Tree Search</title>
		<author>
			<persName><forename type="first">Rong-Hua</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rui</forename><surname>Mao</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2915217</idno>
		<ptr target="https://doi.org/10.1145/2882903.2915217" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, SIGMOD Conference 2016</title>
		<meeting>the 2016 International Conference on Management of Data, SIGMOD Conference 2016<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06-26">2016. June 26 -July 01, 2016</date>
			<biblScope unit="page" from="91" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Spark: top-k keyword query in relational databases</title>
		<author>
			<persName><forename type="first">Yi</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaofang</forename><surname>Zhou</surname></persName>
		</author>
		<idno type="DOI">10.1145/1247480.1247495</idno>
		<ptr target="https://doi.org/10.1145/1247480.1247495" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06-12">2007. June 12-14, 2007</date>
			<biblScope unit="page" from="115" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">SPARK2: Top-k Keyword Query in Relational Databases</title>
		<author>
			<persName><forename type="first">Yi</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaofang</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianmin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keqiu</forename><surname>Li</surname></persName>
		</author>
		<idno type="DOI">10.1109/TKDE.2011.60</idno>
		<ptr target="https://doi.org/10.1109/TKDE.2011.60" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1763" to="1780" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Regular Path Query Evaluation Sharing a Reduced Transitive Closure Based on Graph Reduction</title>
		<author>
			<persName><forename type="first">Inju</forename><surname>Na</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilyeop</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyu-Young</forename><surname>Whang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang-Sae</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soon</forename><forename type="middle">J</forename><surname>Hyun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Cypher Query Language</title>
		<author>
			<persName><surname>Inc</surname></persName>
		</author>
		<idno>. Neo4j</idno>
		<ptr target="https://neo4j.com/developer/cypher/" />
		<imprint>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Answering reachability and K-reach queries on large graphs with label constraints</title>
		<author>
			<persName><forename type="first">You</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xuemin</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ying</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenjie</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
		<idno type="DOI">10.1007/s00778-021-00695-0</idno>
		<ptr target="https://doi.org/10.1007/s00778-021-00695-0" />
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="101" to="127" />
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Root Rank: A Relational Operator for KWS Result Ranking</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Vinay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jayant</surname></persName>
		</author>
		<author>
			<persName><surname>Haritsa</surname></persName>
		</author>
		<idno type="DOI">10.1145/3297001.3297014</idno>
		<ptr target="https://doi.org/10.1145/3297001.3297014" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM India Joint International Conference on Data Science and Management of Data, COMAD/CODS 2019</title>
		<meeting>the ACM India Joint International Conference on Data Science and Management of Data, COMAD/CODS 2019<address><addrLine>Kolkata, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-01-03">2019. January 3-5, 2019</date>
			<biblScope unit="page" from="103" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Operator implementation of Result Set Dependent KWS scoring functions</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Vinay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jayant</surname></persName>
		</author>
		<author>
			<persName><surname>Haritsa</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.is.2019.101465</idno>
		<ptr target="https://doi.org/10.1016/j.is.2019.101465" />
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
			<biblScope unit="page">101465</biblScope>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Efficient Computation of Semantically Cohesive Subgraphs for Keyword-Based Knowledge Graph Exploration</title>
		<author>
			<persName><forename type="first">Yuxuan</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gong</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Trung-Kien</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evgeny</forename><surname>Kharlamov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yulin</forename><surname>Shen</surname></persName>
		</author>
		<idno type="DOI">10.1145/3442381.3449900</idno>
		<ptr target="https://github.com/nju-websoft/QGSTP" />
	</analytic>
	<monogr>
		<title level="m">WWW '21: The Web Conference 2021</title>
		<editor>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marko</forename><surname>Grobelnik</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marc</forename><surname>Najork</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jie</forename><surname>Tang</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Leila</forename><surname>Zia</surname></persName>
		</editor>
		<meeting><address><addrLine>Virtual Event / Ljubljana, Slovenia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021-04-19">2021. April 19-23, 2021</date>
			<biblScope unit="page" from="1410" to="1421" />
		</imprint>
	</monogr>
	<note>ACM / IW3C2</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Finding Group Steiner Trees in Graphs with both Vertex and Edge Weights</title>
		<author>
			<persName><forename type="first">Yahui</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaokui</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Saman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Theodoros</forename><surname>Halgamuge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Lappas</surname></persName>
		</author>
		<author>
			<persName><surname>Luo</surname></persName>
		</author>
		<idno type="DOI">10.14778/3450980.3450982</idno>
		<ptr target="https://doi.org/10.14778/3450980.3450982" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1137" to="1149" />
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Topk Exploration of Query Candidates for Efficient Keyword Search on Graph-Shaped (RDF) Data</title>
		<author>
			<persName><forename type="first">Thanh</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haofen</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Cimiano</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2009.119</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2009.119" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Data Engineering, ICDE 2009</title>
		<meeting>the 25th International Conference on Data Engineering, ICDE 2009<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-03-29">2009. March 29 2009 -April 2 2009</date>
			<biblScope unit="page" from="405" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Landmark Indexing for Evaluation of Label-Constrained Reachability Queries</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Lucien</surname></persName>
		</author>
		<author>
			<persName><surname>Valstar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuichi</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><surname>Yoshida</surname></persName>
		</author>
		<idno type="DOI">10.1145/3035918.3035955</idno>
		<ptr target="https://doi.org/10.1145/3035918.3035955" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data, SIGMOD Conference 2017</title>
		<meeting>the 2017 ACM International Conference on Management of Data, SIGMOD Conference 2017<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-05-14">2017. May 14-19, 2017</date>
			<biblScope unit="page" from="345" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Efficiently Answering Regular Simple Path Queries on Large Labeled Networks</title>
		<author>
			<persName><forename type="first">Sarisht</forename><surname>Wadhwa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anagh</forename><surname>Prasad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sayan</forename><surname>Ranu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amitabha</forename><surname>Bagchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srikanta</forename><surname>Bedathur</surname></persName>
		</author>
		<idno type="DOI">10.1145/3299869.3319882</idno>
		<ptr target="https://doi.org/10.1145/3299869.3319882" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data, SIGMOD Conference 2019</title>
		<meeting>the 2019 International Conference on Management of Data, SIGMOD Conference 2019<address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-06-30">2019. June 30 -July 5, 2019</date>
			<biblScope unit="page" from="1463" to="1480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A Survey of Algorithms for Keyword Search on Graph Data</title>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charu</forename><forename type="middle">C</forename><surname>Aggarwal</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4419-6045-0_8</idno>
		<ptr target="https://doi.org/10.1007/978-1-4419-6045-0_8" />
	</analytic>
	<monogr>
		<title level="m">Managing and Mining Graph Data</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Charu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Haixun</forename><surname>Aggarwal</surname></persName>
		</editor>
		<editor>
			<persName><surname>Wang</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="249" to="273" />
		</imprint>
	</monogr>
	<note>Advances in Database Systems</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Query Planning for Evaluating SPARQL Property Paths</title>
		<author>
			<persName><forename type="first">Nikolay</forename><surname>Yakovets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parke</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jarek</forename><surname>Gryz</surname></persName>
		</author>
		<idno type="DOI">10.1145/2882903.2882944</idno>
		<ptr target="https://doi.org/10.1145/2882903.2882944" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Management of Data, SIGMOD Conference 2016</title>
		<meeting>the 2016 International Conference on Management of Data, SIGMOD Conference 2016<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06-26">2016. June 26 -July 01, 2016</date>
			<biblScope unit="page" from="1875" to="1889" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">An Efficient Parallel Keyword Search Engine on Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Yueji</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divyakant</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Anthony</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shuang</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICDE.2019.00038</idno>
		<ptr target="https://doi.org/10.1109/ICDE.2019.00038" />
	</analytic>
	<monogr>
		<title level="m">35th IEEE International Conference on Data Engineering, ICDE 2019</title>
		<meeting><address><addrLine>Macao, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-04-08">2019. April 8-11, 2019</date>
			<biblScope unit="page" from="338" to="349" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>