<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TrieDF: Efficient In-memory Indexing for Metadata-augmented RDF</title>
				<funder>
					<orgName type="full">Poul Due Jensen Foundation</orgName>
				</funder>
				<funder ref="#_cgzy84F">
					<orgName type="full">Danish Council for Independent Research (DFF)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Pelgrin</surname></persName>
							<email>olivier@cs.aau.dk</email>
							<affiliation key="aff0">
								<orgName type="institution">Aalborg University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Luis</forename><surname>Gal√°rraga</surname></persName>
							<email>luis.galarraga@inria.fr</email>
							<affiliation key="aff1">
								<address>
									<settlement>Inria</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Katja</forename><surname>Hose</surname></persName>
							<email>khose@cs.aau.dk</email>
							<affiliation key="aff0">
								<orgName type="institution">Aalborg University</orgName>
								<address>
									<country key="DK">Denmark</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">TrieDF: Efficient In-memory Indexing for Metadata-augmented RDF</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">4F881987FACD23E492C67289440BBE27</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Metadata, such as provenance, versioning, temporal annotations, etc., is vital for the maintenance of RDF data. Despite its importance in the RDF ecosystem, support for metadata-augmented RDF remains limited. Some solutions focus on particular annotation types but no approach so far implements arbitrary levels of metadata in an application-agnostic way. We take a step to tackle this limitation and propose an in-memory tuple store architecture that can handle RDF data augmented with any type of metadata. Our approach, called <software>TrieDF</software>, builds upon the notion of tries to store the indexes and the dictionary of a metadataaugmented RDF dataset. Our experimental evaluation on three use cases shows that <software ContextAttributes="used">TrieDF</software> outperforms state-of-the-art in-memory solutions for RDF in terms of main memory usage and retrieval time, while remaining application-agnostic.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">Introduction</head><p>During the last 20 years, the Web has seen a proliferation of large collections of RDF data, i.e., triples subject, predicate, object describing real-world concepts ranging from common-sense to specialized domains. The triples are structured in what we call an RDF graph or knowledge graph (KG). KGs find applications in multiple AI-related tasks, such as question answering, information retrieval, smart assistants, etc.</p><p>Building and maintaining a large-scale KG is a titanic effort. It does not only require sophisticated RDF stores and collaborative tools, but also procedures and protocols to extract, cleanse, and integrate data from potentially heterogeneous sources. This is true regardless of whether the KG is manually or (semi-)automatically populated. A central aspect in KG construction is metadata management. RDF metadata includes, but is not limited to, provenance, validity intervals, spatial annotations, confidence statements, and versioning. As existing KGs grow and new initiatives come to existence, the need to manage statements about triples, i.e., RDF tuples, becomes more and more crucial.</p><p>There exist multiple solutions to represent metadata about RDF triples. Popular solutions are named graphs and reification. That said, these approaches are not free of limitations. A large number of fine-grained RDF graphs can be a challenge for quad stores <ref type="bibr" target="#b4">[5]</ref>. Reification, on the other hand, quintuples the number of statements in a dataset; not to mention the fact that it also complexifies the queries. For these reasons, RDF engines support at most one level of metadata in an out-of-the-box fashion. This means that current stores can model statements about triples, but not statements about quads, i.e., 5-tuples. They can neither model a versioned collection of graphs nor RDF statements originating from different sources with multiple validity intervals. Support for higher levels of metadata -equivalent to n-ary relationships -remains limited to very specific scenarios such as archiving <ref type="bibr" target="#b16">[17]</ref>.</p><p>This work takes a step to tackle the aforementioned limitations and proposes <software>TrieDF</software>, an in-memory RDF tuple store. <software ContextAttributes="used">TrieDF</software> stores tuples of arbitrary length in a trie, an inmemory prefix-based tree originally used for compact storage and efficient retrieval of strings. <software ContextAttributes="used">TrieDF</software> models everything as a trie, namely all indexes and the dictionary. Our evaluation shows that such an architecture yields a significant speed-up in retrieval with little penalty in memory consumption w.r.t. existing triple/quad stores. We also illustrate the utility of <software ContextAttributes="used">TrieDF</software> at handling 5-tuples in the context of provenance and version management.</p></div>
<div><head n="2">Preliminaries</head><p>RDF Graphs. An RDF graph ùê∫ ‚äÜ (I ‚à™ B) √ó I √ó T is a set of triples s, p, o , with subject ùë†, predicate ùëù, and object ùëú that model binary assertions about entities, for example, :Denmark, :locatedIn, :Europe . The sets I, B, and T are countably infinite sets of IRIs, blank nodes, and RDF terms respectively, with T = I ‚à™ B ‚à™ L and L the set of literals. IRIs are web-scoped identifiers for entities such as http:// dbpedia.org/resource/Denmark (abbreviated :Denmark for default prefix http:// dbpedia.org/resource/); blank nodes are anonymous file-scoped identifiers; literals are non-referenceable data such as strings, numbers, and dates. Metadata-augmented RDF Graphs. Given an RDF graph ùê∫, a metadata-augmented graph Œì : ùê∫ ‚Üí T ùëõ is an injective function that annotates each triple of the graph with a ùëò-tuple of RDF terms. We can also see Œì as a set of ùëõ-tuples ùëû = s, p, o, ... with ùëõ = ùëò + 3. Metadata-augmented RDF graphs can model ùëõ-ary relationships in contrast to standard RDF graphs that can only model binary relationships.</p></div>
<div><head n="3">Related Work</head><p>The need to store and manage metadata for RDF triples has given rise to a large literature body that we survey in two stages. First, we survey different techniques to encode metadata-augmented triples and store them in triple stores. In a second stage we discuss existing solutions to manage additional components in triples.</p></div>
<div><head n="3.1">Encoding Metadata-augmented Triples</head><p>Reification is the process of encoding an n-ary statement through a set of binary relationships. For instance, consider the versioned triple :Aalborg, :cityIn, :Denmark, 3 -that states that the triple is present in revision 3 of the graph. Under the standard reification, the triple is assigned a surrogate IRI (or blank node) ùë¢ that is linked to all the components of the quad, resulting in 4 new triples: u, :subject, :Aalborg , u, :predicate, :cityIn , u, :object, :Denmark , and u, :version, 3 . Since reification incurs a significant overhead both for storage and querying, other approaches have proposed more compact encoding strategies. The authors of <ref type="bibr" target="#b14">[15]</ref> propose singleton properties as unique keys for statements in a context. In our example, such a context could be the graph revision where a triple occurs, e.g., :Aalborg, cityIn#3, :Denmark . A more flexible scheme, called companion properties <ref type="bibr" target="#b9">[10]</ref>, proposes singleton properties per subject, for example, :Aalborg, cityIn#3.si, :Denmark , where si is a local identifier that can be used to model subject-level metadata.</p><p>Reification and single properties have been used to encode one level of metadata, e.g., versioning, probabilities, provenance, temporal validity, etc. However, porting these strategies to scenarios with arbitrary levels of statement-centered metadata, e.g., provenance plus versioning, requires a careful application-dependent combination of the different schemes. This need has motivated the development of RDF-star <ref type="bibr" target="#b8">[9]</ref>, a data model that treats triples as first-class citizens and allows for nested statements such as :Aalborg, :cityIn, :Denmark , :version, 3 . Support for RDF-star is gaining traction in current RDF engines. Some commercial solutions such as RDFox, GraphDB, and <software ContextAttributes="used">Stardog</software> can parse TriG, an RDF-star serialization text format. That said, none of those solutions can so far handle arbitrary levels of nestedness.</p></div>
<div><head n="3.2">Beyond RDF Triples</head><p>RDF Named Graphs. Even though the RDF graph data model can be used to store metadata for RDF statements "natively", it was rather conceived as an analogy to documents and database tables. A named RDF graph is associated to an IRI ùëî, and stores a presumably large collection of triples within a well-defined context, e.g., a particular data source. Nevertheless, named graphs have been used to store more finegrained metadata such as validity intervals, revision numbers, and changesets <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b16">17]</ref>. This can represent a challenge for classical RDF graph stores, such as <software ContextAttributes="used">Jena</software>, Virtuoso, RDF4J, etc., that are not optimized for a large number of small RDF graphs. Since RDF named graphs cannot model metadata for quads, a few approaches have proposed highly specific solutions in the context of RDF/S inference <ref type="bibr" target="#b15">[16]</ref>. Property Graphs. In this data model, both nodes (entities) and edges (relationships) can be assigned attributes, such as labels, timestamps, probabilities, sources, etc. Despite this flexibility, property graphs cannot store arbitrary levels of metadata for triples out of the box. Like named graphs, they rather provide a generic solution to store metadata about triples. This agnosticism has propelled adaptations of the graph model and existing engines (e.g., Neo4J, GraphDB) to particular applications, such as version and history management <ref type="bibr" target="#b6">[7]</ref> and workflow provenance <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b11">12]</ref>. As for named graphs, solutions are application-dependent and not trivially portable to arbitrary settings. Relational Databases. Notable designs to store RDF in tables are the three-column table and the entity-relationship model (a relation per class, a column per predicate). Storing metadata about RDF in a relational setting does not require any extension to the original data model, and standard engines provide efficient support for the most common metadata types such as temporal metadata <ref type="bibr" target="#b12">[13]</ref>, version control <ref type="bibr" target="#b10">[11]</ref>, and validity intervals. That said, the relational model is not optimized for the schema-free nature of RDF, which in the first place motivated the design of triple stores.</p></div>
<div><head n="4">TrieDF</head><p>We now elaborate on <software ContextAttributes="used">TrieDF</software>, our in-memory architecture to manage metadataaugmented RDF. <software ContextAttributes="used">TrieDF</software> stores RDF tuples of arbitrary length in different indexes. The indexes do not store actual RDF terms but rather references to those terms in a space efficient dictionary (Figure <ref type="figure">1b</ref>).</p><p><software>TrieDF</software> borrows inspiration from tries -prefix-based trees for string storage. Nodes in a trie store single characters and each string is associated to a path in the tree. Strings with the same prefix, e.g., web, weave, weasel, share common nodes. <software ContextAttributes="used">TrieDF</software> treats tuples as "strings" of items. Those items are either references to RDF terms (for indexes) or IRI chunks (for the dictionary). We elaborate on these use cases in the following sections.</p></div>
<div><head n="4.1">Trie-based Indexes</head><p>Consider a version annotated RDF graph with quads s, p, o, v such that ùë£ models the versions where the triple s, p, o is present. Figure <ref type="figure">1b</ref> depicts an SPOV index for the quads 1, 2, 3, 1 , 1, 2, 3, 2 , and 1, 5, 6, 2 -the triples are encoded using a dictionary. We can infer that the triple 1, 5, 6 was added in the second revision of the graph. We now describe the implementation of <software ContextAttributes="used">TrieDF</software> and the operations it supports. Implementation. Logically, each element of a tuple is associated to a node in the tree. Physically, nodes store only references to their children. Those references are organized in a red-black tree keyed by the value of the child node. If |ùëá | is the number of nodes in a trie ùëá, an index in <software ContextAttributes="used">TrieDF</software> has a space complexity of ùëÇ (|ùëá |ùëê max ), where ùëê max is the highest out-degree of a node in ùëá. This happens because red-black trees exhibit ùëÇ (ùëõ) space complexity in the number of keys.</p><p>Tries are optimized for tuple lookup and prefix-based retrieval. These operations, as well as additions and deletions, are implemented as in standard tries. Therefore, looking up a tuple ùëû incurs a time complexity of ùëÇ (|ùëû|log(ùëê max )).</p><p>Users of <software ContextAttributes="used">TrieDF</software> can define indexes of arbitrary depth for all permutations of the elements of a tuple. Moreover, <software ContextAttributes="used">TrieDF</software> can also operate as a standard triple store. In that case, the system stores triples in indexes SPO, POS, and OSP in line with standard engines. The nodes in the indexes store integers, precisely the memory addresses of the RDF terms in the dictionary <ref type="bibr" target="#b1">[2]</ref>, which is also implemented as a trie as explained next.</p></div>
<div><head n="4.2">Trie-based Dictionary Encoding</head><p>Dictionary encoding maps the terms of an RDF dataset to an integer space for the sake of efficient space consumption and query processing. Dictionary encoding is often implemented using two hash tables, i.e., one for encoding (string to integer) and one for decoding (integer to string).</p><p>Even though dictionary encoding reduces memory consumption drastically for RDF engines, it does not tackle the inherent redundancy of RDF terms. For instance, common prefixes in IRIs are still stored multiple times. Similarly to the work of Bazoobandi et al. <ref type="bibr" target="#b1">[2]</ref>, the dictionary for IRIs is stored in an trie. In <ref type="bibr" target="#b1">[2]</ref>, a node is usually associated to a single character, although multiple nodes can be compressed (fusioned) into a single node if they form a single branch subtree. A drawback of such an approach is that (a) A standard trie (b) Trie-based index and dictionary Fig. <ref type="figure">1</ref>: Example tries updates may cause fusioned nodes to split. In that case the tree must be rearranged, which increases update time. To make updates simpler -at the expense of some redundancy -<software ContextAttributes="used">TrieDF</software> compresses IRIs by automatically coalescing all the nodes that lie between occurrences of the "/" character <ref type="bibr" target="#b20">[21]</ref>. In other words, each node is logically associated to a chunk of an IRI as depicted in Figure <ref type="figure">1b</ref>. If a node marks the end of an IRI, the memory address of the node serves as the integer identifier used by the tuple indexes described in the previous section.</p><p>In practice dictionary tries are bidirectional. That is, nodes store references to their children and parent. That way, a dictionary can retrieve the identifier associated to an IRI (lookup) and vice versa (reverse lookup). (Figure <ref type="figure">1b</ref>). Because the benefit of a prefix-based representation is significantly less pronounced for literals <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b19">20]</ref>, they are currently stored in one-node tries.</p></div>
<div><head n="5">Experiments</head><p>We evaluate <software>TrieDF</software> along three dimensions: loading time, main-memory consumption, and retrieval time (i.e., the time to return all the tuples that match a prefix). For this purpose, we test it in three use cases and compare it to other relevant in-memory solutions. Our scenarios cover a standard RDF graph, a versioned RDF graph (requiring quads), and a collection of 5-tuples.</p><p><software>TrieDF</software> was written in C++. All experiments were run in a server with 256 GB of RAM, a 16-core CPU (AMD EPYC 7281), and an 8 TB HDD. The source <software ContextAttributes="used">code</software> and experimental data is available at https://relweb.cs.aau.dk/triedf.</p></div>
<div><head n="5.1">TrieDF for Triples</head><p>We first assess the performance of <software ContextAttributes="used">TrieDF</software> when used as a standard in-memory triple store on DBpedia 2016-10 [1], YAGO 3.1 <ref type="bibr" target="#b17">[18]</ref>, YAGO 4 <ref type="bibr" target="#b18">[19]</ref>, and Wikidata <ref type="bibr" target="#b2">[3]</ref>. For DBpedia we use the themes mapping-based objects and mapping-based literals. For YAGO 3.1 we consider the knowledge base's core, namely, the themes facts, meta facts, literal facts, date facts, and labels. For YAGO 4, we use the facts theme from the English only distribution. In regards to Wikidata we chose the simple-statements file of the 2016-08 RDF export . Details about the dataset sizes are available in the following table, in which we compare <software ContextAttributes="used">TrieDF</software> with <software ContextAttributes="used">Jena</software> and <software ContextAttributes="used">RDFLib</software> , two fully-fledged inmemory platforms for RDF/SPARQL management. They are widely used in production environments and offer mature and well-tested implementations. Loading time of the triples evaluation in seconds.</p></div>
<div><head>DBpedia</head><p>Retrieval time. We measure the average runtime of the different systems on single triple pattern queries of the following shapes: (i) s, p, ?o , (ii) ?s, p, o , (iii) s, ?p, ?o , (iv) ?s, ?p, o , and (v) ?s, p, ?o (? denotes a variable). For each query shape, we generated 200 queries by drawing the bound components randomly from the datasets, and then adding variables to the unbounded components as in <ref type="bibr" target="#b16">[17]</ref>. The queries are implemented as classical retrieval operations, e.g., :Denmark, :capital, ?o retrieves all tuples prefixed with :Denmark, :capital in the SPO trie index.</p><p>Figure <ref type="figure">2</ref> depicts the query runtime of the tested systems on the different datasets. The results show that <software ContextAttributes="used">TrieDF</software> is at least one order of magnitude faster than the competitors for queries with one variable. When there are two variables, <software ContextAttributes="used">TrieDF</software> still exhibits lower median runtimes, but its variance is large, specially for YAGO. This can be explained by the fact that those queries may sometimes have a large number of results. This phenomenon also affects <software ContextAttributes="used">Jena</software>. While <software ContextAttributes="used">RDFLib</software> is mostly insensitive to large result sets, it lags behind the other systems in terms of average retrieval time. Memory consumption. Figure <ref type="figure">3a</ref> shows the peek memory consumption of the different systems during loading and query execution. We observe that <software ContextAttributes="used">TrieDF</software> outperforms <software ContextAttributes="used">Jena</software> in all datasets, and all the competitors in YAGO 3. For the other datasets, our approach uses at most 13% more memory than <software ContextAttributes="used">RDFLib</software>. This happens for two reasons. First, <software ContextAttributes="used">RDFLib</software>'s indexes are of fixed depth, which allows for some space savings: leaves do not need to accommodate for an additional pointer to its potential children. Second, <software ContextAttributes="used">RDFLib</software> does not implement explicit dictionary encoding but rather relies on Python's internal variable handling (Python variables are actually keys pointing to their actual value in a hash table) to store references to RDF terms in the indexes. Relying on Python incurs important memory savings for <software ContextAttributes="used">RDFLib</software>, however, the system remains two orders of magnitude slower than <software ContextAttributes="used">TrieDF</software> at retrieval.</p></div>
<div><head n="5.2">TrieDF for Quads</head><p>In this section we evaluate <software ContextAttributes="used">TrieDF</software> at managing RDF quads s, p, o, v , that represent triples annotated with a revision number ùë£. Our evaluation is based on the BEAR <ref type="bibr" target="#b3">[4]</ref> benchmark datasets, and an archive consisting of the DBpedia versions from the 3.5 to the 2016-10 release, where one release is equivalent to one revision <ref type="bibr" target="#b16">[17]</ref>. For each release, we use the same DBpedia themes as in our experiments with triples. As for BEAR, we use both the BEAR-B and BEAR-C datasets. We omitted BEAR-A because our competitors could not parse the input files due to formatting issues.</p><p>In order to provide versioning capabilities to <software ContextAttributes="used">TrieDF</software>, we store RDF quads in SPOV, POSV, and OSPV indexes. We also compare <software ContextAttributes="used">TrieDF</software> with the <software ContextAttributes="used">Jena</software> in-memory models and <software ContextAttributes="used">RDFLib</software>. For both competitors, we use named graphs to store each revision. This storage strategy, called independent copies, optimizes for data retrieval <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>  Retrieval time. We measure the average runtime of the different systems on 100 single triple pattern queries of different types on versioned RDF graphs, namely version materialization (VM), delta materialization (DM), and version queries (VQ). The queries were randomly generated according to the experimental setup in <ref type="bibr" target="#b16">[17]</ref>.</p><p>BEAR--B BEAR--C DBpedia Figure <ref type="figure" target="#fig_1">4</ref> shows the runtime of the evaluated systems for each type of query. We observe that <software ContextAttributes="used">TrieDF</software> outperforms all the competitors by far, although the performance gap can vary drastically. In particular, <software ContextAttributes="used">TrieDF</software>'s indexes are optimized for VQ queries, for which they are 3 orders of magnitude faster than the competitors. Even though the independent copies approach used in <software ContextAttributes="used">Jena</software> and <software ContextAttributes="used">RDFLib</software> is optimal for VM queries (and to a lesser extent for DM queries), <software ContextAttributes="used">TrieDF</software> is still one order of magnitude faster than the competitors. Memory consumption. Figure <ref type="figure">3b</ref> shows the peek memory consumption of the different systems during loading and query execution. We first highlight that <software ContextAttributes="used">Jena</software> uses much more memory than the other systems. The reason is that <software ContextAttributes="used">Jena</software> implements a classical independent copies approach, where each revision is entirety stored in a different graph. This leads to a lot of duplicated data. In contrast, <software ContextAttributes="used">RDFLib</software> stores graphs (called contexts) in separate hash tables that map triples to graphs and graphs to triples. This mitigates redundancy. In the same vibe, <software ContextAttributes="used">TrieDF</software> stores version identifiers in the last component of each index, which reduces redundancy. While <software ContextAttributes="used">RDFLib</software> showcases the lowest memory consumption, <software ContextAttributes="used">TrieDF</software> strikes the best trade-off with at most 28% more peek memory usage than <software ContextAttributes="used">RDFLib</software> in exchange for a speed-up of 3 orders of magnitude for retrieval.</p></div>
<div><head n="5.3">TrieDF for 5-tuples</head><p>In this section we evaluate <software ContextAttributes="used">TrieDF</software> on a 5-tuples setup where triples are annotated with provenance and version identifiers ùëû, ùë£, i.e., we store tuples s, p, o, q, v . We use a dump of 27M tuples of the NELL <ref type="bibr" target="#b13">[14]</ref> dataset. The NELL extractors collect metadataaugmented knowledge iteratively from the Web. This metadata includes, among other fields, confidence scores for the extracted triples, extraction sources, extraction methods, and the iteration of promotion, i.e., the iteration at which a triple is considered true and "officially" added to the knowledge base. We use the two latter fields in this evaluation. Since RDF storage systems do not support 5-tuples, we compare <software ContextAttributes="used">TrieDF</software> against relational database systems with support for in-memory tables. After a comparison between <software ContextAttributes="used">SQLite</software> and <software ContextAttributes="used">MariaDB</software>, we chose the former due to its good performance in our setting. 5-tuples in <software ContextAttributes="used">TrieDF</software> are represented via SPOQV, POSQV, and OSPQV indexes. We test <software ContextAttributes="used">SQLite</software> with and without those indexes. Loading time. We report loading times of 36.55s, 16.98s, and 47.27s for <software ContextAttributes="used">TrieDF</software>, <software ContextAttributes="used">SQLite</software>, and <software ContextAttributes="used">SQLite</software> with indexes respectively. We observe that <software ContextAttributes="used">SQLite</software> loads data significantly faster when no indexes are built, however when indexing is enabled, <software ContextAttributes="used">TrieDF</software> is faster. Retrieval time. We tested both systems on 100 queries of the same types defined for the quads evaluation with randomly bounded ùëû and ùë£. As suggested by Figure <ref type="figure" target="#fig_1">4d</ref>, <software ContextAttributes="used">TrieDF</software> achieves similar retrieval performance than an indexed 5-column <software ContextAttributes="used">SQLite</software> in-memory table. The median runtime of <software ContextAttributes="used">TrieDF</software> is better for VM and VQ queries. Memory consumption. Figure <ref type="figure">3c</ref> shows the peak memory usage of both <software ContextAttributes="used">SQLite</software> and <software ContextAttributes="used">TrieDF</software> when loading and querying the NELL dataset. We observe that indexing multiplies memory consumption by a factor of 3 in <software ContextAttributes="used">SQLite</software>. <software ContextAttributes="used">TrieDF</software> still uses 26% more memory than indexed <software ContextAttributes="used">SQLite</software>, however <software ContextAttributes="used">TrieDF</software> cannot leverage its trie-based dictionary to its full capacity. This happens because NELL does not use prefixed IRIs. Despite this rather suboptimal setting, <software ContextAttributes="used">TrieDF</software> still shows comparable performance to <software ContextAttributes="used">SQLite</software>.</p></div>
<div><head n="6">Conclusion</head><p>We have presented an in-memory architecture based on tries to index and access annotated RDF triples efficiently. Our solution provides the user with a flexible architecture to manage arbitrary RDF metadata in main memory. Our experimental evaluation has shown that such as an approach strikes an interesting trade-off between retrieval time and memory footprint: it can yield a speed-up of up to 3 orders of magnitude in retrieval time in return to little (and sometimes no penalty) in memory usage. We believe that <software>TrieDF</software> is a first step towards a holistic solution to manage knowledge beyond RDF triples. As future work we envision to explore different strategies to reduce <software ContextAttributes="created">TrieDF</software>'s memory footprint. We also envision to couple our architecture with suitable in-disk storage and provide SPARQL query support.</p></div><figure xml:id="fig_0"><head>Fig. 2 :Fig. 3 :</head><label>23</label><figDesc>Fig. 2: Query runtime (microseconds) for triples queries (log scale)</figDesc></figure>
<figure xml:id="fig_1"><head>Fig. 4 :</head><label>4</label><figDesc>Fig. 4: Query runtime for quads and 5-tuples (log scale)</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>The following table shows the loading times of Jena, RDFLib, and TrieDF for the experimental datasets. Jena is consistently faster than the others systems, which can be explained by (i) a fast dictionary, (ii) a highly optimized RDF parser, and (iii) batching of insertions. Jena stores the dictionary in classical hash tables, which allows for constant time lookup and insertion of terms, in contrast to TrieDF that incurs a logarithmic lookup complexity. This, in contrast, optimizes for compactness (see paragraph on memory consumption). That said, TrieDF ranks second close to Jena, and outperforms RDFLib by a large margin.</figDesc><table><row><cell /><cell /><cell>YAGO 3.1</cell><cell>YAGO 4</cell><cell>Wikidata</cell></row><row><cell>Triples</cell><cell>38M</cell><cell>85M</cell><cell>22M</cell><cell>138M</cell></row><row><cell>Size</cell><cell>4.9GB</cell><cell>12GB</cell><cell>3.0GB</cell><cell>17GB</cell></row><row><cell>RDF terms</cell><cell>11M</cell><cell>59M</cell><cell>8.5M</cell><cell>54M</cell></row><row><cell cols="5">Details about the experimental datasets for the triples evaluation.</cell></row><row><cell cols="2">Loading time. DBpedia</cell><cell>YAGO 3.1</cell><cell>YAGO 4</cell><cell>Wikidata</cell></row><row><cell>Jena</cell><cell>587.14</cell><cell>1281.65</cell><cell>289.42</cell><cell>1665.48</cell></row><row><cell cols="2">RDFLib 2816.16</cell><cell>7102.30</cell><cell>1626.85</cell><cell>9587.51</cell></row><row><cell>TrieDF</cell><cell>727.20</cell><cell>2105.37</cell><cell>358.20</cell><cell>2800.77</cell></row></table></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>at the expense of high memory consumption. Loading time. The table below shows the loading times of the evaluated systems. No results are provided for Jena in DBpedia, since the system runs out of memory. RDFLib lags behind Jena and TrieDF, with TrieDF being the fastest at loading the bulky revisions of BEAR-C, and Jena being the fastest at loading the more granular revisions of BEAR-B.</figDesc><table><row><cell /><cell>DBpedia</cell><cell>BEAR-B</cell><cell>BEAR-C</cell></row><row><cell>Jena</cell><cell>-</cell><cell>1094.83</cell><cell>418.74</cell></row><row><cell>RDFLib</cell><cell>26433.76</cell><cell>4851.09</cell><cell>1663.40</cell></row><row><cell>TrieDF</cell><cell>16074.17</cell><cell>3743.55</cell><cell>387.68</cell></row><row><cell cols="4">Loading time of the quads evaluation in seconds.</cell></row></table></figure>
			<note place="foot" xml:id="foot_0"><p>http://tools.wmflabs.org/wikidata-exports/rdf/index.html https://jena.apache.org/ https://rdflib.readthedocs.org</p></note>
			<note place="foot" xml:id="foot_1"><p>http://rtw.ml.cmu.edu/rtw/resources</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements. This research was partially funded by the <rs type="funder">Danish Council for Independent Research (DFF)</rs> under grant agreement no. <rs type="grantNumber">DFF-8048-00051B</rs> and the <rs type="funder">Poul Due Jensen Foundation</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_cgzy84F">
					<idno type="grant-number">DFF-8048-00051B</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">DBpedia: A Nucleus for a Web of Open Data</title>
		<author>
			<persName><forename type="first">S</forename><surname>Auer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kobilarov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lehmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cyganiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC/ASWC</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="722" to="735" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Compact In-Memory Dictionary for RDF Data</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Bazoobandi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>De Rooƒ≥</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ten Teƒ≥e</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Van Harmelen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">E</forename><surname>Bal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Introducing Wikidata to the Linked Data Web</title>
		<author>
			<persName><forename type="first">F</forename><surname>Erxleben</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>G√ºnther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kr√∂tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mendez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vrandeƒçiƒá</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="50" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Evaluating query and storage strategies for RDF archives</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Fern√°ndez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Umbrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SEMANTICS</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Answering Provenance-Aware Queries on RDF Data Cubes Under Memory Budgets</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gal√°rraga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Jakobsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">QBOAirbase: The European Air Quality Database as an RDF Cube</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gal√°rraga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A M</forename><surname>Mathiassen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">ISWC (Posters, Demos &amp; Industry Tracks)</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">1963</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">ChronoGraph: A Versioned TinkerPop Graph Database</title>
		<author>
			<persName><forename type="first">M</forename><surname>Haeusler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Trojer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kessler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Farwick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Nowakowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Breu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DATA</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Transparent Integration and Sharing of Life Cycle Sustainability Data with Provenance</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lissandrini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ghose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>L√∏kke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Thomsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="378" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Foundations of RDF‚òÖ and SPARQL‚òÖ: An Alternative Approach to Statement-Level Metadata in RDF</title>
		<author>
			<persName><forename type="first">O</forename><surname>Hartig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AMW</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Querying Wikidata: Comparing SPARQL, Relational and Graph Databases</title>
		<author>
			<persName><forename type="first">D</forename><surname>Hern√°ndez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Riveros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rojas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Zerega</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">OrpheusDB: Bolt-on Versioning for Relational Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Elmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Parameswaran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1130" to="1141" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Storage and Querying of Large Provenance Graphs Using NoSQL DSE</title>
		<author>
			<persName><forename type="first">A</forename><surname>Kashliev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BigDataSecurity/HPSC/IDS</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="260" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Benchmarking Bitemporal Database Systems: Ready for the Future or Stuck in the Past?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>May</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Never-Ending Learning</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="2302" to="2310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<author>
			<persName><forename type="first">V</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Bodenreider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Sheth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Don't like RDF reification?: making statements about statements using singleton property</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">On Explicit Provenance Management in RDF/S Graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Pediaditis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Flouris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Fundulaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Christophides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>TAPP</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Towards Fully-fledged Archiving for RDF Datasets</title>
		<author>
			<persName><forename type="first">O</forename><surname>Pelgrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Gal√°rraga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web Journal</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">YAGO: A Large Ontology from Wikipedia and WordNet</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kasneci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="203" to="217" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">YAGO 4: A Reason-able Knowledge Base</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Tanon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weikum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="583" to="596" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Comparing data summaries for processing live queries over Linked Data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Umbrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Karnstedt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Harth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">World Wide Web</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="495" to="544" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">TripleBit: a Fast and Compact System for Large Scale RDF Data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="517" to="528" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>