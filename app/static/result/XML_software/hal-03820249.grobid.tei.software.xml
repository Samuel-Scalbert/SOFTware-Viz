<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Counting Queries over ELHI ⊥ Ontologies</title>
				<funder ref="#_w5VftY3">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
							<email>meghyn.bienvenu@u-bordeaux.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Bordeaux INP</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">University of Bordeaux</orgName>
								<orgName type="institution" key="instit3">LaBRI</orgName>
								<address>
									<settlement>Talence</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Quentin</forename><surname>Manière</surname></persName>
							<email>quentin.maniere@u-bordeaux.fr</email>
							<affiliation key="aff0">
								<orgName type="department">Bordeaux INP</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">University of Bordeaux</orgName>
								<orgName type="institution" key="instit3">LaBRI</orgName>
								<address>
									<settlement>Talence</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
							<email>michael.thomazo@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">ENS</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">University PSL</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Counting Queries over ELHI ⊥ Ontologies</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C8D8200E21096F224FAF6CAD99936B87</idno>
					<idno type="DOI">10.24963/kr.2022/6</idno>
					<note type="submission">Submitted on 18 Oct 2022</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Ontology-mediated query answering (OMQA) facilitates access to data through the use of ontologies, which provide a convenient vocabulary for query formulation and capture domain knowledge that can be exploited to obtain more complete query results. The OMQA approach has been extensively studied over the past fifteen years <ref type="bibr" target="#b18">(Poggi et al. 2008;</ref><ref type="bibr" target="#b2">Bienvenu and Ortiz 2015;</ref><ref type="bibr" target="#b21">Xiao et al. 2018)</ref>, leading to the identification of ontology languages that are well suited to OMQA due to their attractive computational properties. Particular attention has been paid to Horn description logics of the DL-Lite and EL families <ref type="bibr" target="#b6">(Calvanese et al. 2007;</ref><ref type="bibr" target="#b1">Baader, Brandt, and Lutz 2005)</ref>.</p><p>While most work on OMQA considers that the user query is a conjunctive query (CQ), there has been significant interest in exploring the possibility of adopting more expressive query languages for OMQA. In particular, several works have investigated ways of equipping CQs with some form of counting <ref type="bibr" target="#b7">(Calvanese et al. 2008;</ref><ref type="bibr" target="#b13">Kostylev and Reutter 2015;</ref><ref type="bibr" target="#b11">Feier, Lutz, and Przybylko 2021)</ref>. A recent approach, proposed in <ref type="bibr" target="#b4">(Bienvenu, Manière, and Thomazo 2020)</ref> as a generalization of <ref type="bibr" target="#b13">(Kostylev and Reutter 2015)</ref>, considers counting conjunctive queries (CCQs) that are syntactically defined like standard CQs except that some variables may be designated as counting variables. In each model of the knowledge base, we can count the number of possible assignments to the counting variables that make the query answer hold. As the count value may differ between models, the goal is to identify intervals that provide upper and lower bounds on the count values across all models.</p><p>The problem of answering CCQs is intractable, in both data and combined complexity, for common DL-Lite dialects such as DL-Lite core and DL-Lite H core <ref type="bibr" target="#b13">(Kostylev and Reutter 2015)</ref>. Recent works have shown that intractability arises even for simple forms of CCQs <ref type="bibr">(Calvanese et al. 2020a;</ref><ref type="bibr" target="#b5">Bienvenu, Manière, and Thomazo 2021)</ref>. However, some interesting tractable cases have also been identified, notably, rooted CCQs <ref type="bibr" target="#b4">(Bienvenu, Manière, and Thomazo 2020;</ref><ref type="bibr">Calvanese et al. 2020a;</ref><ref type="bibr" target="#b16">Nikolaou et al. 2019</ref>) and cardinality queries <ref type="bibr" target="#b5">(Bienvenu, Manière, and Thomazo 2021)</ref> coupled with DL-Lite core ontologies. Query rewriting techniques have also begun to be explored <ref type="bibr">(Calvanese et al. 2020b</ref>). However, despite these advances, we still have only a partial understanding of CCQ answering in common DL-Lite dialects, and the precise combined complexity has remained elusive: the current bounds for DL-Lite H core are between coNEXP and coN2EXP <ref type="bibr" target="#b13">(Kostylev and Reutter 2015)</ref>. Moreover, to the best of our knowledge, CCQ answering has not yet been studied for DLs outside the DL-Lite family.</p><p>In this paper, we extend the study of CCQ answering to other well-known Horn description logics, such as EL and the more expressive ELHI ⊥ . The techniques used in the DL-Lite context do not readily transfer to EL due to the presence of conjunction, and in any case, our results show that they do not achieve the optimal combined complexity even for DL-Lite. We therefore develop a new approach based upon the observation that there exists a model minimizing the count value that consists of an arbitrary structure I * containing all assignments for the counting variables, augmented with structures that are tree-shaped, provided we ignore edges to and from I * . Importantly, we can bound the size of the central component I * , which enables us to explore all possible options for I * . Checking whether a given I * can be extended to a model preserving the minimum count value can be done by specifying a set of patterns (intuitively representing a pair of adjacent elements), and testing via local consistency conditions whether they can be coherently assembled. This latter step takes inspiration from a CQ answering technique for existential rules : previously known upper / lower bound. <ref type="bibr" target="#b20">(Thomazo et al. 2012)</ref>, and is also similar in spirit to typeelimination style procedures, which have been employed for reasoning with expressive DLs, see e.g. <ref type="bibr" target="#b19">(Rudolph, Krötzsch, and Hitzler 2012;</ref><ref type="bibr" target="#b10">Eiter et al. 2009)</ref>.</p><p>Using this new approach, we are able to establish a 2EXP upper bound in combined complexity for ELHI ⊥ . A matching lower bound, which applies to both EL and DL-Lite H pos , is obtained by establishing a novel connection between CCQ answering and OMQA with closed predicates. This yields 2EXP-completeness for a wide range of Horn DLs and closes the combined complexity gap for CCQ answering in DL-Lite H core . We further prove a coNEXP lower bound for DL-Lite pos , which matches an existing coNEXP upper bound, yielding the precise combined complexity for DL-Lite core as well. We also explore how to shrink the size of the models implicitly generated by our procedure, producing models with bounded size which we use to show that CCQ answering is coNP-complete in data complexity for all logics between EL and ELHI ⊥ .</p><p>In addition to CCQs, we also investigate the special case of cardinality queries, which correspond to Boolean atomic CCQs and allow us to ask for (bounds on) the number of members of a given concept or role. We obtain a complete picture of data and combined complexity of answering cardinality queries in ELHI ⊥ and its various sublogics. While the data complexity is coNP-complete for all considered logics, the combined complexity ranges from NL or coNP in DL-Lite logics to EXP or coNEXP for EL and its extensions. We achieve these results using a variety of the techniques: refinements of our approach for general CCQs, adaptations of existing constructions, and further reductions involving closed predicates. Figure <ref type="figure">1</ref> summarizes the complexity results for both CCQs and cardinality queries.</p><p>Paper Organization Section 2 introduces the necessary preliminaries, in particular, the syntax and semantics of the considered DLs and the definition of CCQs. Sections 3 and 4 present our complexity results for CCQs and cardinality queries, respectively, and sketch the underlying techniques (an appendix with full proofs can be found in the long version of this paper, available on arXiv). Section 5 concludes with a discussion of future work. A TBox is a finite set of axioms. In ELHI ⊥ , TBoxes consist of concept inclusions B 1 B 2 , positive role inclusions R 1 R 2 , and negative role inclusions<ref type="foot" target="#foot_1">1</ref> R 1 R 2 ⊥, where the R i are roles drawn from N ± R = {P, P -| P ∈ N R } and the B i are (complex) concepts constructed as follows:</p><formula xml:id="formula_0">B := ⊥ | | A | B 1 B 2 | ∃R.B with A ∈ N C , R ∈ N ± R</formula><p>Various sublogics of ELHI ⊥ can be obtained by disallowing role inclusions, inverse roles, and/or the bottom construct. For example, EL is obtained by removing all three features, while ELI ⊥ corresponds to disallowing role inclusions (retaining inverse roles and ⊥). We shall also consider some DL-Lite dialects that are fragments of ELHI ⊥ . The most expressive, DL-Lite H core , allows positive and negative role inclusions, and restricted forms of concept inclusions:</p><formula xml:id="formula_1">D 1 D 2 D 1 D 2 ⊥ D i := A | ∃R. with A ∈ N C , R ∈ N ± R .</formula><p>The logics DL-Lite H pos , DL-Lite core , and DL-Lite pos are obtained respectively by dropping negative inclusions, role inclusions, or both features.</p><p>We shall use sig(T ) (resp. sig(K)) to denote the signature of a TBox T (resp. KB K), i.e. the set of concept and role names appearing in T (resp. K).</p><p>Semantics of KBs An interpretation takes the form I = (∆ I , • I ), where ∆ I is a non-empty set (called the domain) and • I is the interpretation function that maps each A ∈ N C to A I ⊆ ∆ I , each P ∈ N R to P I ⊆ ∆ I × ∆ I , and each a ∈ N I to a I . In this paper, we will make the Standard Names Assumption by setting a I = a. Note however that our results only rely upon the weaker Unique Names Assumption (UNA), which stipulates that a I = b I whenever a = b.</p><p>The function • I naturally extends to roles and complex concepts:</p><formula xml:id="formula_2">(P -) I = {(y, x) | (x, y) ∈ P I }, ⊥ I = ∅, I = ∆ I , (B 1 B 2 ) I = B I 1 ∩ B I 2 and (∃P.B) I = {d | (d, e) ∈ P I , e ∈ B I }. An inclusion G H is satisfied in I if G I ⊆ H I ; an assertion A(b) (resp. P(a, b)) is satisfied in I if b ∈ A I (resp. (a, b) ∈ P I ).</formula><p>An interpretation is a model of a TBox T (resp. KB K) if it satisfies all axioms in T (resp. axioms and assertions in K). A KB is satisfiable if it has at least one model. An inclusion (resp. assertion) Φ is entailed from T (resp. K), written T |= Φ (resp. K |= Φ), if Φ is satisfied in every model of T (resp. K).</p><p>Example 1. Consider the ABox A e := {A 1 (a), B(b)} and the ELHI ⊥ TBox T e :</p><formula xml:id="formula_3">A 1 ∃R.A 2 A 2 ∃R.A 1 B ∃R.B R R -⊥ A 2 ∃R.B B ∃R.C B C B B ⊥</formula><p>Our example KB is K e := (T e , A e ). Figures <ref type="figure">2a</ref> and<ref type="figure">2c</ref> depict models of K e .</p><p>We can view an interpretation I as a (possibly infinite) set of assertions A I = {A(e) | e ∈ A I , A ∈ N C } ∪ {P(e, e ) | (e, e ) ∈ P I , P ∈ N R }. We say that I is T -satisfiable if T ∪ A I has a model, and it is T -saturated if A I contains every assertion entailed by (T , A I ).</p><p>Counting Queries We consider counting queries as defined in <ref type="bibr" target="#b4">(Bienvenu, Manière, and Thomazo 2020</ref>) (which generalizes the queries considered in <ref type="bibr" target="#b13">(Kostylev and Reutter 2015;</ref><ref type="bibr">Calvanese et al. 2020a))</ref>. A counting conjunctive query (CCQ) takes the form q(x) = ∃y∃z ψ(x, y, z), where x, y, z are tuples of answer, existential, and counting variables, respectively, and ψ is a conjunction of concept and role atoms with terms from N I ∪ x ∪ y ∪ z. We use terms(q) for the set of all terms occurring in q, and we treat queries as sets of atoms when convenient. The usual notion of conjunctive query (CQ) is captured by CCQs without counting variables (i.e. z = ∅). A CCQ q is Boolean if x = ∅. Concept cardinality queries are Boolean CCQs of the form ∃z A(z) (A ∈ N C ), while role cardinality queries have the form</p><formula xml:id="formula_4">∃z 1 , z 2 R(z 1 , z 2 ) (R ∈ N R ).</formula><p>A match for a CCQ q in an interpretation I is a homomorphism from q into I, i.e. a function π that maps each term in q to an element of ∆ I such that π(t) = t when t ∈ N I , π(t) ∈ A I for every A(t) ∈ q, and (π(t), π(t )) ∈ P I for every P(t, t ) ∈ q. If a match π maps x to a, then the restriction of π to z is called a counting match (c-match) of q(a) in I. The set of answers to q in I, denoted q I , contains all pairs (a, [m, M ]), with m, M ∈ N ∪ {+∞}, such that the number of distinct c-matches of q(a) in I belongs to the interval <ref type="bibr">[m, M ]</ref>. A certain answer to q w.r.t. K is an answer in every model of K, that is a pair from I|=K q I . As usual, it is sufficient to consider the Boolean case: (a, [m, M ]) is a certain answer to a CCQ q(x) iff (∅, [m, M ]) is a certain answer to the Boolean CCQ q(a) obtained by replacing x with a. Thus, from now on, we focus on Boolean CCQs, and work with candidate answers</p><formula xml:id="formula_5">[m, M ] in place of (∅, [m, M ]).</formula><p>We further observe that since ELHI ⊥ cannot restrict the size of models, the least upper bound M in a certain answer [m, M ] is: 0 if the underlying CQ is unsatisfiable w.r.t. T , 1 if q has a match in every model but z = ∅; and +∞ otherwise. As the first two cases can be readily handled using existing techniques, we focus on identifying certain answers of the form [m, +∞]. Example 2. Let q e := ∃y ∃z R(y, z) ∧ C(z) be a Boolean CCQ. Intervals [0, +∞] and [1, +∞] are certain answers to q e over K e . Interval [4, +∞] is not as the models depicted on Figures 2a and 2c contain only 3 matches for q e .</p><p>To clarify how our notion of certain answer relates to standard OMQA semantics, we note that a Boolean CQ q is entailed from K iff [1, +∞] is a certain answer to q over K.</p><p>Complexity Given a ELHI ⊥ knowledge base K = (T , A), a Boolean CCQ q, and an integer m ≥ 0 (in binary), we are interested in the complexity of deciding whether [m, +∞] is a certain answer to q w.r.t. K. We will consider the two usual complexity measures: combined complexity which is in terms of the size of the whole input, and data complexity which is only in terms of the size of A and m (T and q are treated as fixed). If O is a TBox, ABox, KB, or CCQ, then the size of O, denoted |O|, is the number of occurrences of concept and role names in O.</p><p>Normal form As is standard (see e.g. <ref type="bibr" target="#b3">(Bienvenu et al. 2014</ref>)), we work with ELHI ⊥ TBoxes in a convenient normal form, where every concept inclusion has one of the following restricted shapes:</p><formula xml:id="formula_6">A ⊥ A A 1 A 2 A A 1 ∃R.A 2 ∃R.A 1 A 2 with A, A 1 , A 2 ∈ N C , R ∈ N ± R .</formula><p>Through the introduction of fresh concept names, we can transform in polynomial time any TBox T into a normal-form TBox T that is a modelconservative extension of T (hence, indistinguishable from T from the point of view of queries). We therefore assume w.l.o.g. that all considered TBoxes are in normal form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Closed Predicates</head><formula xml:id="formula_7">A KB with closed predicates consists of a KB (T , A) and a set Σ ⊆ N C ∪ N R of closed predicates. An interpretation I is a model of (T , A, Σ) if it is a model of (T , A) which interprets the closed predicates according to A, i.e. A I = {a | A(a) ∈ A} for every A ∈ Σ ∩ N C and P I = {(a, b) | P(a, b) ∈ A} for every P ∈ Σ ∩ N R .</formula><p>Query entailment is then defined as for classical KBs, but using this modified notion of model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">General Case of CCQs</head><p>This section presents our main contributions: a decision procedure and associated tight complexity bounds for CCQ answering in ELHI ⊥ and its sublogics.</p><p>To improve readability, we have split the section into several parts. Section 3.1 presents a double-exponential-time decision procedure, whose correctness proof is detailed in Section 3.2. We explain, in Section 3.3, how to shrink the size of the models implicitly generated by our procedure, which we use to show coNP data complexity. Finally, in Section 3.4, we prove the required lower bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Decision Procedure</head><p>In this subsection, we devise a procedure that computes in double-exponential time the minimum amount of c-matches, which immediately yields the following upper bound:</p><formula xml:id="formula_8">Theorem 1. CCQ answering in ELHI ⊥ is in 2EXP w.r.t. combined complexity.</formula><p>Let us fix a satisfiable KB K = (T , A) and a (Boolean) CCQ q. The next lemma provides an upper bound on the minimal number of c-matches.</p><p>Lemma 1. There exists a model of K with less than</p><formula xml:id="formula_9">M := (|Ind(A)| + 3 |T | 2 |T | ) |q| c-matches for q. • a A 1 , B, C • b B, C • γ B, C • A 2 • A 2 δ • A 1 • A 1 • B (a) A model Ie of Ke. P * , ∅ P 1 , R.A 2 P 2 , R.A 1 P 3 , R.A 2 P 2 , R.A 1 P 4 , R.B P 4 , R.B P 5 , R.C P 5 , R.C (b) Pattern tree Pe. • a A 1 , B, C • b B, C • γ B, C • A 2 • A 1 • A 2 • A 1 • B • B (c) Model I ♦ e built from P * e .</formula><p>Figure <ref type="figure">2</ref>: Interpretations and pattern tree used along our examples, labels for the only role R have been omitted for readability.</p><p>Proof sketch. We can exhibit a model having at most</p><formula xml:id="formula_10">|Ind(A)| + 3 |T | 2 |T | elements.</formula><p>It follows that in any model I having a minimum number of c-matches, the set ∆ * ⊆ ∆ I of elements appearing in the image of a c-match has size at most M • |q|. We can thus iterate over all such ∆ * , and even over all induced interpretations I * = I |∆ * , in double-exponential time w.r.t. combined complexity. The core task will then be to determine, given such a candidate I * , whether we can extend I * into a model of K without introducing new c-matches.</p><p>Let us fix our candidate I * and see how to check for a suitable extension. The challenging axioms to handle are those of the form A ∃R.B, as they might require us to introduce new elements. We define the set Ω := {R.B | A ∃R.B ∈ T } and call its members (existential) heads. Importantly, as our correctness proof will establish, it is sufficient to consider extensions of I * which are obtained by adding tree-shaped structures of new elements, plus some edges between the new elements and ∆ I * (we may need to use elements from ∆ I * as witnesses for existential heads to avoid new query matches). This property enables us to build such an extension by piecing together local interpretations corresponding to the addition of a single edge, using two distinguished symbols and as placeholders for fresh elements. We shall call these building blocks patterns, as they are inspired by a notion of the same name introduced for CQ answering with existential rules <ref type="bibr" target="#b20">(Thomazo et al. 2012)</ref>.</p><p>Patterns not only consist of a local interpretation, but also other information needed to ensure that assembled patterns do not violate any TBox axioms or introduce any new matches. In particular, we shall keep track of (partial) query matches involving the local elements using the notion of a coherent specification. Intuitively, such a specification tells us which matches should be realized in the constructed extension, and naturally contains at least the matches of subqueries of q already realized in the local interpretation. Definition 1. Let I be an interpretation.</p><p>• The specification M I induced by I is the set of pairs (r, π) such that r ⊆ q and π : r → I is a (full) match. • A coherent specification M over I is a set of pairs (r, π)</p><p>where r ⊆ q and π is a partial mapping from terms(r) to ∆ I such that M contains M I and if (r 1 , π 1 ), (r 2 , π 2 ) ∈ M with π 1 and π 2 defined and equal on var(r 1 ) ∩ var(r 2 ),</p><formula xml:id="formula_11">then (r 1 ∪ r 2 , π 1 ∪ π 2 ) ∈ M.</formula><p>To check the compatibility of different specifications, we will need to be able to restrict them to a subdomain: Definition 2. The restriction of a specification M over an interpretation I to a domain ∆ ⊆ ∆ I , denoted M |∆ , is the set of pairs (r, π ) such that π is the restriction of some π to π -1 (∆) for some (r, π) ∈ M. Remark 1. Induced specifications and restrictions of coherent specifications are both coherent specifications.</p><p>Patterns will contain a further kind of information called a prediction, defined next. The purpose will be explained in more detail once we introduce links between patterns, but roughly it serves to coordinate the successor patterns of a pattern to avoid violating negative role inclusions.</p><formula xml:id="formula_12">Definition 3. A prediction is a function next : Ω → ∆ I * ∪ Ω verifying that: for all R 1 .B 1 , R 2 .B 2 ∈ Ω, if T |= R 1 R 2 ⊥, then next(R 1 .B 1 ) = next(R 2 .B 2 ).</formula><p>We now formally define the central notion of pattern, relative to I * and a candidate specification M * over I * . Definition 4. A pattern P (w.r.t. I * and M * ) is a tuple (fr P , gen P , I P , M P , next P ) where:</p><p>• The frontier and generated domains fr P and gen P are disjoints sets of elements from ∆ I * ∪ { , }; • I P is a T -saturated and T -satisfiable interpretation with ∆ I P = ∆ I * ∪ fr P ∪ gen P and such that I P |∆ I * = I * ; • M P is a coherent specification of q over I P that preserves M * , that is</p><formula xml:id="formula_13">(M P ) |∆ I * = M * ; • next P is a prediction.</formula><p>We shall be interested in two types of patterns. The (unique) initial pattern P * := (∅, ∆ I * , I * , M * , Id) simply represents I * and M * . All other patterns of interest represent additions of a pair of adjacent elements, and fr P and gen P will be singletons (representing these two elements). e . Non-initial patterns will be illustrated later.</p><p>• a</p><formula xml:id="formula_14">A 1 , B, C • b B, C • γ B, C (a) Interp. I * e .</formula><p>• a</p><formula xml:id="formula_15">A 1 , B, C • b B, C • γ B, C • A 2 (b) Interp. of P e 1 . (I * e ) • A 2 • A 1 (c) Interp. of P e 2 .</formula><p>(I * e )</p><p>•</p><formula xml:id="formula_16">A 1 • A 2 (d) Interp. of P e 3 . (I * e ) • A 2 • B</formula><p>(e) Interp. of P e 4 .</p><p>• a</p><formula xml:id="formula_17">A 1 , B, C • b B, C • γ B, C • B (f) Interp. of P e 5 .</formula><p>Figure <ref type="figure" target="#fig_1">3</ref>: Interpretations of patterns from Example 4.</p><p>We now define how to combine patterns together, and first, when it is necessary to combine them. Definition 5. We say that R.B ∈ Ω is applicable to e in a pattern P if e ∈ gen P and there exists A ∃R.B ∈ T with e ∈ A I P but e / ∈ (∃R.B) I P . When a head is applicable to a pattern, we need to find another pattern that can realize the head. This is formalized by the following notion of link between patterns, which requires that the two patterns are compatible (Conditions 1, 2, 3), the second pattern realizes the head (Condition 4), and certain consistency conditions hold (Conditions 5, 6). Definition 6. Let R.B be an applicable head on e 1 in a pattern P 1 . There is a (R.B, e 1 )-link from P 1 to P 2 if:</p><p>1. fr P2 = {e 1 } and gen P2 is a singleton, say {e 2 };</p><p>2. For all concept name A, we have e 1 ∈ A I P 1 iff e 1 ∈ A I P 2 ; 3. We denote L R.B P1,e1 the set of patterns P 2 such that there is a (R.B, e 1 )-link from P 1 to P 2 . Remark 2. Predictions are used in Condition 6 to avoid problematic situations where two successor patterns merge back to the same element of ∆ I * . Specifically, if we have a R 1 .B 1 -link from P 0 to P 1 and a R 2 .B 2 -link from P 0 to P 2 , with</p><formula xml:id="formula_18">T |= R 1 R 2 ⊥, then next P0 (R 1 .B 1 ) = next P0 (R 2 .B</formula><p>2 ), preventing P 1 and P 2 from using the same element of ∆ I * as generated term (which would violate T ). Condition 5 is similar in spirit, handling the case of the pattern P 1 using the frontier element of P 0 as a generated term. Example 4. We consider patterns P e 1 , . . . , P e 5 whose interpretations are depicted in Figure <ref type="figure" target="#fig_1">3</ref>. Frontier terms are indicated by square-purple and generated terms by circle-green. Predictions are Id except for next P e 4 , which maps R.C to γ. Specifications M i are given by: M</p><formula xml:id="formula_19">1 = M * e ∪{(α R , (y, z) → (a, )), (α R , z → ), (α R , y → )}; M 5 = M * e ∪ {(q e , (y, z) → ( , γ)), (α R , (y, z) → ( , γ)), (α R , z → )}; M 4 = M 1 ∪ M 5 ∪ {(α R , (y, z) → ( , ))}; M 2 = M 4 \ {(α R , z → )}; M 3 = M 5 ∪ {(α R , (y, z) → (a, )), (α R , (y, z) → ( , )), (α R , y → )}, where α R denotes R(y, z).</formula><p>Observe that M i may include (partial) matches which are not present in P e i 's interpretation but are useful for linking patterns, e.g. (q e , (y, z) → ( , γ)) in M 4 enables a (R.C, )-link from P e 4 to P e 5 (see Example 5). We now characterize patterns that cannot be used to satisfy a head without introducing a new c-match. Definition 7. A pattern P is rejecting if one of the two following conditions holds: • There exists (q, π) ∈ M P with π(z) ∩ { , } = ∅; • There exists an existential head R.B that applies on e in P such that all patterns P ∈ L R.B P,e are rejecting. A pattern is accepting if it is not rejecting.</p><p>The acceptance of the initial pattern P * is a sufficient condition ensuring I * extends to a model having no more cmatches than encoded in M * , i.e. the pairs (q, π) ∈ M * such that π is defined for all counting variables. Lemma 2. If P * := (∅, ∆ * , I * , M * , Id) is accepting, then there exists a model I ♦ such that I * ⊆ I ♦ and if π : q → I ♦ is a c-match, then (q, π) ∈ M * . In particular, I ♦ has at most as many c-matches as those encoded in M * .</p><p>Furthermore, the minimum amount of c-matches is reached among initial patterns due to the following result: Lemma 3. If I is a model of K with m c-matches, then there exists an accepting initial pattern whose specification encodes exactly m c-matches.</p><p>Before proving Lemmas 2 and 3, let us recap the overall double-exponential procedure underlying Theorem 1:</p><p>Proof of Theorem 1. We consider all possible initial patterns P * with an interpretation domain ∆ * such that Ind(A) ⊆ ∆ * and |∆ * | ≤ M |q| (recall Lemma 1). Every such P * is of single-exponential size w.r.t. combined complexity (observe that its specification M * corresponds to a subset of 2 q × (∆ * ∪ {↑}) q , where ↑ is a fresh symbol witnessing the use of partial mappings), and thus are doubleexponential in number (up to isomorphism) and can be enumerated in double-exponential time. For each such P * , we construct in double-exponential time the set of all possible descendant patterns of P * (which are of single-exponential size, having at most |∆ * | + 2 elements). We then check whether each possible pattern (P * or candidate descendant) is in fact a well-defined pattern, in particular, its interpretation is T -satisfiable and T -saturated. These verifications can be done in double-exponential time, recalling that KB satisfiability and instance checking are in EXP for ELHI ⊥ (even the variant with negative role inclusions, see e.g. <ref type="bibr" target="#b3">(Bienvenu et al. 2014)</ref>). Acceptance of P * is tested (again in deterministic exponential time) by repeatedly iterating over the set of patterns and removing those that are rejecting either due to their specification, or due to the removal of all patterns that could provide a link for an applicable head. If P * is found to be accepting and M * encodes m c-matches, then Lemma 2 ensures the existence of a model with at most m c-matches. Conversely, Lemma 3 ensures that we can find the smallest such m among the accepting initial patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Proofs of Lemmas 2 and 3</head><p>We now prove the central lemmas of the correctness proof.</p><p>From Accepting Patterns to Models To prove Lemma 2, let us suppose we are given an initial pattern P * := (∅, ∆ * , I * , M * , Id) that is accepting. Our aim is to construct a model I ♦ that extends I * and is such that (q, π) ∈ M * for every c-match π : q → I ♦ .</p><p>We proceed as follows. For each accepting descendant pattern P (w.r.t. I * and M * ) and each head R.B applicable to e in P, we choose an accepting pattern ch R.B P,e from L R.B P,e . Then, starting from P * , we build a tree-shaped set of words, whose letters consist of an accepting pattern and existential head, and which witnesses the acceptance of P * . Definition 8. The pattern tree P is defined as the smallest set of words such that:</p><formula xml:id="formula_20">• (P * , ∅) ∈ P; • If w • (P, h) ∈ P and R.B is applicable to e in P, then w • (P, h) • (ch R.B</formula><p>P,e , R.B) ∈ P. It remains to 'glue' together the interpretations I P according to the structure of P. Since a pattern P may occur more than once, we create a copy of I P for each node in P of the form w • (P, h). We do not duplicate however elements from I * as they precisely are those we want to reuse. Hence only the frontier term and the generated term may be duplicated (provided they do not belong to ∆ * ). When a node w • (P 1 , h 1 ) • (P 2 , h 2 ) is encountered, we merge the frontier term of P 2 with the already-introduced copy of the generated element from P 1 on which h 2 is applied (which is the only element in fr P2 ). Therefore, when considering such a node w • (P 1 , h 1 ) • (P 2 , h 2 ), the only element we might have to introduce is a copy of the generated term e of P 2 (unless e ∈ ∆ * ), which we shall simply name w • (P 1 , h 1 ) • (P 2 , h 2 ). Formally, the copying and merging of elements is achieved by the following family of duplicating functions, defined inductively for each w • (P, h) ∈ P.</p><formula xml:id="formula_21">λ w•(P,h) : ∆ I P → ∆ I * ∪ {w, w • (P, h)} e →    e if e ∈ ∆ I * w if e ∈ fr P \ ∆ I * w • (P, h) if e ∈ gen P \ ∆ I * Note that if e ∈ fr P2 \ ∆ I * , then e ∈ gen P1 \ ∆ I * , hence λ w•(P1,h1)•(P2,h2) (e) = λ w•(P1,h1) (e) = w • (P 1 , h 1 ).</formula><p>The desired model I ♦ can then be defined as follows:</p><formula xml:id="formula_22">I ♦ := w•(P,h)∈P λ w•(P,h) (I P ).</formula><p>Example 5. The patterns introduced in Example 4 are sufficient to witness that P * e is accepting. The initial part of P e is depicted in Figure <ref type="figure">2b</ref>. The resulting I ♦ e is depicted in Fig- <ref type="figure">ure 2c</ref>. Notice how it inherits the tree-shaped structure of P e up to roles collapsing back in I * e . By definition, each λ w•(P,h) is a homomorphism from I P to I ♦ . Due to Condition 2, the shared element of linked patterns must belong to the same concepts, so concept membership in I ♦ transfers back to I P : Lemma 4. For all w • (P, h) ∈ P, for all e ∈ ∆ I P and for all A ∈ N C , if λ w•(P,h) (e) ∈ A I ♦ , then e ∈ A I P .</p><p>An analogous property fails however for roles, as two patterns P 1 = ch h1</p><p>P,e and P 2 = ch h2 P,e may reuse the same element from ∆ * , that is, gen P1 = gen P2 ∈ ∆ * . In that case, satisfied roles in I ♦ |∆ where ∆ := λ w•(P,h)•(P1,h1) (I P1 ) may not be satisfied in I P1 . Conditions 5 and 6 allow us to show the following weaker property, sufficient for our purposes: Lemma 5. For all w • (P, h) ∈ P, d, e ∈ ∆ I P , and P ∈ N R : if (λ w•(P,h) (d), λ w•(P,h) (e)) ∈ P I ♦ , then I P remains T -satisfiable if we add (d, e) to P I P .</p><p>A similar lemma (given in the appendix) allows us to lift query matches from I ♦ to patterns, yielding the following:</p><formula xml:id="formula_23">Proposition 1. I ♦ is a model of K whose c-matches are included in those encoded in M * .</formula><p>From a Model to an Accepting Initial Pattern We now turn to the proof of Lemma 3. We fix a model I of K, and our task is to construct an accepting initial pattern having the same number of c-matches as I.</p><p>Let ∆ * be the subset of ∆ I consisting of all individuals in A and all elements e such that e = π(z) for some π : q → I and counting variable z. Set I * := I |∆ * and M * := (M I ) |∆ * . Notice in particular that the number of c-matches for q encoded in M * is exactly the number of c-matches for q in I. We claim that P * := (∅, ∆ * , I * , M * , Id) is accepting.</p><p>To prove this, we shall build a set of patterns, whose every pattern P is not trivially rejecting, i.e. P does not satisfy the base-case condition of a rejecting pattern, and which is realized in I, meaning that I P homomorphically embeds into I. Observe that the initial pattern P * satisfies both conditions. To pursue the construction, given any pattern P satisfying the two conditions and a head h applicable to P, we show how to extract from I another Q which satisfies the conditions and which makes h hold for P. Since the number of patterns is finite, every sequence of patterns constructed in such a manner either leads to a trivially accepting pattern (i.e. one with no applicable heads) or loops back to an already explored pattern satisfying the conditions. It follows that all patterns in the set are accepting (in particular, P * ).</p><p>To formalize the construction, we shall introduce a function τ associating to each pattern P a homomorphism I P → I. Furthermore, we shall assume that, for every R.A ∈ Ω, we have chosen a function succ I R.A that maps every element e ∈ (∃R.A) I to an element e ∈ ∆ I such that (e, e ) ∈ R I and e ∈ A I . The construction begins with P * , for which we set τ (P * ) := Id I * →I . Next we take some already constructed pattern P 1 with its associated function τ (P 1 ), and consider a head R.B that is applicable to e 1 in P 1 . Since R.B applies to e, there must exist A ∈ N C such that e ∈ A I P 1 and T |= A ∃R.B. Set e 1 := τ (P 1 )(e 1 ). Since τ (P 1 ) is a homomorphism and I is a model of T , we obtain e 1 ∈ (∃R.B) I and can set e 2 := succ I R.B (e 1 ). If e 2 ∈ ∆ * , then we set e 2 := e 2 , otherwise we set e 2 to either or such that e 1 = e 2 .</p><p>We can now define the new pattern P 2 . Its frontier is e 1 and its generated term is e 2 . Its interpretation is given by:</p><formula xml:id="formula_24">C I P 2 := C I * ∪ {e k | e k ∈ C I , k = 1, 2} P I P 2 := P I * ∪ {(e 1 , e 2 ) | T |= R P} ∪ {(e 2 , e 1 ) | T |= R -P}</formula><p>Its specification is (M I ) |∆ * ∪{e 1 ,e 2 } in which e 1 (resp. e 2 ) has been replaced by e 1 (resp. e 2 ). Its prediction maps a head h to the value of succ I h (e 2 ) if it is defined, else to h. Finally, we let τ (P 2 ) be the function that maps elements of ∆ * to themselves, e 1 to e 1 and e 2 to e 2 . Recalling that I is a model, of K it is then straightforward to verify that P 2 is a well-defined not-trivially-rejecting pattern, satisfying P 2 ∈ L R.B P1,e1 , and such that τ (P 2 ) is indeed a homomorphism. Example 6. In the model I e , depicted in Figure <ref type="figure">2a</ref>, we can set succ Ie R.A2 (a) := δ (other choices of successors are unique), and then apply the preceding construction to obtain the accepting patterns from Example 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Obtaining Bounded-Size Optimal Models</head><p>To obtain optimal models of bounded size, we start from the pattern tree P and model I ♦ we constructed from an accepting initial pattern. It remains to merge elements of I ♦ to obtain a model of the required size. To identify similar elements, we consider their neighbourhoods. To characterize neighbourhoods in I ♦ (w.r.t. domain ∆ * ), we focus on the tree-like structure inherited from P. Recall that we kept a single pattern for each head R.B applicable to an element e of a pattern P, namely ch R.B P,e . We can thus consider the bijection σ mapping (P * , ∅) • (P 1 , h 1 ) • • • (P n , h n ) (with n ≥ 1) to ah 1 . . . h n , where a is such that fr P1 = {a}; we extend σ to ∆ * by letting σ(e) = e for e ∈ ∆ * . Inspired by the notion of interleaving used in the DL-Lite setting <ref type="bibr" target="#b13">(Kostylev and Reutter 2015)</ref>, we define the interlacing I := σ(I ♦ ), obtained by renaming elements of I ♦ using σ. Denote by ∆ • := ∆ * ∪ σ(P \ P * ) the forest-shaped domain that is to I what P is to I ♦ . We define an associated mapping f : ∆ • → I by setting f := σ • f • σ -1 where f maps each element of ∆ * to itself and each w • (P, h) ∈ P to λ w•(P,h) (e) where gen P = {e}.</p><p>The definition of I ensures that every c ∈ ∆ I \ ∆ * belongs to σ(P \ P * ) and thus c = aw for some a ∈ ∆ * and word w ∈ Ω * . The tree-shaped structure of ∆ • ensures that for all n, there exists a unique prefix r n,c of aw such that ). This leads us to characterize the n-neighbourhood of an element c ∈ I via the following function χ n,c , whose domain Ω n is the set of words over Ω with length ≤ 2n. Notice that, departing from <ref type="bibr" target="#b13">(Kostylev and Reutter 2015)</ref>, we keep track of sets of satisfied concepts, in order to handle conjunctions of concepts in the left-hand sides of axioms.</p><formula xml:id="formula_25">χ n,c : Ω n → ∆ * ∪ 2 sig(T ) ∪ {∅} w →    ∅ if f (r n,c w) undefined f (r n,c w) if f (r n,c w) ∈ ∆ * {A ∈ sig(T ) | f (r n,c w) ∈ A I } otherwise</formula><p>We can now introduce the equivalence relation we use to merge elements:</p><formula xml:id="formula_26">Definition 10. The equivalence relation ∼ n on ∆ I is de- fined as follows: an element e ∈ ∆ * is ∼ n -equivalent only to itself; elements c 1 , c 2 from ∆ I \ ∆ * are ∼ n -equivalent iff w c1 n,c1 = w c2 n,c2 , χ n,c1 = χ n,c2 , and |c 1 | = |c 2 | mod 2|q|+3.</formula><p>We obtain a finite model of the required size by merging elements with respect to ∼ |q|+1 .</p><p>Theorem 2. The interpretation J := I /∼ |q|+1 is a model of K that has at most as many c-matches for q as I ♦ . Its size is polynomial w.r.t. data complexity, double-exponential w.r.t. combined complexity, and single-exponential if the size of the CCQ q is fixed.</p><p>Proof sketch. The key to proving that the amount of cmatches does not increase through the quotient operation is to exhibit suitable local homomorphisms. Indeed, a match of q in J maps each connected component C of q into a |q|-neighbourhood N J ,∆ * n,c (∆ * ) ⊆ ∆ * , we can find a match of C in I . Such matches for q's connected components together form a match of the full q in I . It is mostly straightforward to show that J is a model, except for negative role inclusions, where the homomorphisms ρ c are needed to move violations of R 1 R 2 ⊥ in J back into I . The claimed upper bounds are obtained by analyzing the size of J (i.e. counting the equivalence classes in ∆ J ), keeping in mind that due to Lemma 1, we may assume that</p><formula xml:id="formula_27">|∆ * | ≤ |Ind(A)| + |q| (|Ind(A)| + 3 |T | 2 |T | ) |q| .</formula><p>From Theorem 2, it follows that there exists a model minimizing the amount of c-matches with polynomial size w.r.t. data complexity. One can therefore non-deterministically guess this interpretation before verifying it is indeed a model and comparing its amount of c-matches with the input integer. The two latter steps can be done in (deterministic) polynomial time w.r.t. data complexity, yielding an upper procedure, since satisfiability of ELHI ⊥ KBs with closed predicates is in EXP <ref type="bibr" target="#b15">(Ngo, Ortiz, and Šimkus 2016)</ref>.</p><p>Corollary 1. Role cardinality query answering in ELH ⊥ is in EXP w.r.t. combined complexity.</p><p>Proof sketch. We observe that a variant of the compact canonical model used in the combined approach <ref type="bibr" target="#b14">(Lutz, Toman, and Wolter 2009)</ref>, provides a model also for ELH ⊥ KBs with negative role inclusions.</p><p>Corollary 2. Role cardinality query answering in ELHI is in EXP w.r.t. combined complexity.</p><p>Proof. Existence of polynomial-sized models is trivial due to the absence of negative inclusions. For example, extending A with every possible fact constructed from Ind(A) and sig(K) yields a model of K = (T , A).</p><p>We conclude this subsection by providing matching lower bounds for concept cardinality queries in EL. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Results for DL-Lite</head><p>The data complexity picture being already known from the literature <ref type="bibr" target="#b5">(Bienvenu, Manière, and Thomazo 2021)</ref>, we focus on combined complexity.</p><p>We start by establishing tractabililty for DL-Lite (H) pos KBs. Theorem 13. Concept cardinality query answering in DL-Lite pos is NL-hard w.r.t. combined complexity.</p><p>Proof sketch. We proceed by reduction from the st-connectivity problem, known to be NL-complete <ref type="bibr" target="#b12">(Immerman 1999)</ref>.</p><p>Theorem 14. Concept cardinality query answering in DL-Lite H pos is in NL w.r.t. combined complexity.</p><p>Proof. Let q C = ∃z C(z) be a concept cardinality query.</p><p>Starting from the canonical model C K of a KB K = (T , A), the minimal number of matches can easily be computed.</p><p>• If there exists an individual a ∈ Ind(A) such that K |= C(a), then we can collapse all anonymous elements onto one such individual (the choice doesn't matter), obtaining a model in which matches are exactly such individuals a, which is clearly minimal (recall we make the UNA). We can check whether K |= C(a) in NL <ref type="bibr" target="#b0">(Artale et al. 2009)</ref> • Otherwise, if there exists an anonymous match in C K , then we collapse all anonymous elements onto a chosen ABox individual, obtaining a model with a single match for q C , which is clearly optimal. Existence of an anonymous match can be checked in NL <ref type="bibr" target="#b0">(Artale et al. 2009</ref>). • Otherwise, there are no matches in C K , hence 0 is the minimal number of matches.</p><p>Notice that we do not need to actually compute the model corresponding to the optimal number of matches, and we only need to compare that number to the input integer.</p><p>Theorem 15. Role cardinality query answering in DL-Lite pos is in NL w.r.t. combined complexity.</p><p>Proof sketch. The proof relies on the same principle as Theorem 14, with a more sophisticated case analysis.</p><p>Note that the preceding theorem concerns DL-Lite pos rather than DL-Lite H pos , as role cardinality query answering in DL-Lite H pos is coNP-hard even w.r.t. data complexity. The introduction of disjointness axioms also leads to intractability, even for concept cardinality queries. Theorem 16. Concept cardinality query answering in DL-Lite core is coNP-hard w.r.t. combined complexity.</p><p>Proof. Let G = (V, E) be an undirected graph, and consider</p><formula xml:id="formula_28">T G = v∈V {A ∃V, ∃V -C}∪ {v1,v2}∈E {∃V - 1 ¬∃V - 2 }.</formula><p>It is easily verified that G ∈ 3COL iff [4, +∞] / ∈ q K G for the KB K G := (T G , {A(a)}) and query q = ∃z C(z).</p><p>Theorem 17. Role cardinality query answering in DL-Lite H core is in coNP w.r.t. combined complexity. Proof sketch. One guesses a small counterexample to [m, +∞] being a certain answer, relying on the existence of small models, atomicity of the query, and Theorem 3 of <ref type="bibr" target="#b15">(Ngo, Ortiz, and Šimkus 2016)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Outlook</head><p>In this paper, we have extended the study of CCQ answering to Horn DLs outside the DL-Lite family, establishing a complete picture of the combined and data complexity of the problems of answering CCQs and cardinality queries in ELHI ⊥ and its various sublogics. Interestingly, the new techniques we devised also allowed us to close some open questions concerning the combined complexity of CCQ answering in DL-Lite. Going forward, the main challenge is to develop practical algorithms. A first direction is to look for restrictions on the query or ontology that ensure polynomial data complexity for logics of the EL family. Second, it would be desirable, for EL but also for DL-Lite, to develop more refined coNP procedures that are amenable to implementation using SAT solvers. We believe that our improved understanding of the structure of optimal models will prove helpful for both of these research directions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>assume mutually disjoint sets N C , N R , and N I of concept, role, and individual names. A knowledge base (KB) K = (T , A) consists of an ABox A and a TBox T . An ABox is a finite set of concept assertions A(b) (with A ∈ N C , b ∈ N I ) and role assertions P(a, b) (with P ∈ N R , a, b ∈ N I ). We denote by Ind(A) the set of individuals occurring in an ABox A.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 3 .</head><label>3</label><figDesc>In our running example, ∆ * e := {a, b, γ} (z maps to only these elements). The initial pattern P * e has frontier ∅, generated terms ∆ * e , interpretation I * e := (I e ) |∆ * e depicted in Figure 3a, and specification M * e := (M Ie ) |∆ *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>M P1 |∆ I * ∪{e1} = M P2 |∆ I * ∪{e1} ; 4. e 2 ∈ B I P 2 and for all P ∈ N R : P I P 2 = P I * ∪ {(e 1 , e 2 ) | T |= R P} ∪ {(e 2 , e 1 ) | T |= R -P} 5. If ever e 2 ∈ ∆ I * ∩ fr P1 , then I P1 ∪ I P2 is T -satisfiable. 6. If e 2 ∈ ∆ I * , then e 2 = next P1 (R.B).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Definition 9 .</head><label>9</label><figDesc>Consider an interpretation I and an element c ∈ ∆ I . Its n-neighbourhood N I,∆ n (c) w.r.t. a subdomain ∆ ⊆ ∆ I is defined inductively as: N I,∆ 0 (c) := {c} N I,∆ n+1 (c) := N I,∆ n (c) ∪ e ∃d ∈ N I,∆ n (c) \ ∆, ∃R ∈ N ± R , (d, e) ∈ R I Observe that we stop adding successors when we reach ∆.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>(i) f (r n,c ) ∈ N I ,∆ * n (c) and (ii) for any d ∈ N I ,∆ * n (c), there exists a unique word w d n,c such that d = f (r n,c • w d n,c</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>|q| (c), where c denotes the equivalence class of c w.r.t. ∼ |q|+1 and ∆ * stands for the set {e | e ∈ ∆ * }. By exhibiting a homomorphism ρ c : N J ,∆ * |q| (c) → N I ,∆ * |q| (c) such that ρ -1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Lite pos DL-Lite core DL-Lite H</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="4">Combined complexity</cell><cell></cell><cell></cell><cell>Data complexity</cell></row><row><cell></cell><cell cols="4">DL-pos</cell><cell cols="2">DL-Lite H core</cell><cell cols="2">EL(H ⊥ ), EL(HI) EL(H)I ⊥</cell><cell>EL(HI ⊥ )</cell></row><row><cell>Concept</cell><cell>NL</cell><cell>coNP</cell><cell>NL</cell><cell></cell><cell>coNP</cell><cell>†</cell><cell>EXP</cell><cell>coNEXP</cell><cell>coNP</cell></row><row><cell>Role</cell><cell>NL</cell><cell>coNP</cell><cell>coNP</cell><cell>†</cell><cell>coNP</cell><cell>†</cell><cell>EXP</cell><cell>coNEXP</cell><cell>coNP</cell></row><row><cell>CCQ</cell><cell>coNEXP  †</cell><cell>coNEXP  †</cell><cell cols="2">2EXP</cell><cell cols="2">2EXP</cell><cell>2EXP</cell><cell>2EXP</cell><cell>coNP</cell></row></table><note><p>Figure 1: Complexity results for CCQs and cardinality queries, all bounds are tight. † / †</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Theorem 11. Concept cardinality query answering in EL is EXP-hard w.r.t. combined complexity. Proof sketch. The proof is by reduction from the problem of deciding if an EL KB with closed predicates is satisfiable, proven EXP-hard in (Ngo, Ortiz, and Šimkus 2016). Concept cardinality query answering in EL is coNP-hard w.r.t. data complexity. Proof sketch. We reduce the complement of the graph 3colorability problem to answering the cardinality query ∃z B(z) w.r.t. the TBox T containing A ∃R.B and ∃R.C k ∃E.(∃R.C k ) B for k ∈ {1, 2, 3}.</figDesc><table><row><cell>Theorem 12.</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Proceedings of the 19th International Conference on Principles of Knowledge Representation and ReasoningMain Track</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>We follow e.g.(Bienvenu et al.  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>2014) by including negative role inclusions in ELHI ⊥ , so that it has DL-Lite H core as a sublogic. Proceedings of the 19th International Conference on Principles of Knowledge Representation and Reasoning Main Track</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>Partially supported by <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_w5VftY3">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>bound in data complexity for CCQ answering, matching the corresponding results in the DL-Lite setting <ref type="bibr" target="#b13">(Kostylev and Reutter 2015;</ref><ref type="bibr" target="#b4">Bienvenu, Manière, and Thomazo 2020)</ref>.</p><p>Theorem 3. CCQ answering in ELHI ⊥ is in coNP w.r.t. data complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Matching Lower Bounds</head><p>We now provide 2EXP lower bounds for EL and DL-Lite H pos , which together with Theorem 1, establish the 2EXPcompleteness of CCQ answering for ELHI and every sublogic that extends EL or DL-Lite H pos . The proofs are by reduction from the problem of answering Boolean union of conjunctive queries (BUCQs) over KBs with closed predicates, proven 2EXP-hard in <ref type="bibr" target="#b15">(Ngo, Ortiz, and Šimkus 2016)</ref>.</p><p>Theorem 4. CCQ answering in EL is 2EXP-hard w.r.t. combined complexity.</p><p>Proof sketch. Consider an EL KB K = (T , A, Σ) with closed predicates and a BUCQ q = l k=1 q k . Examining the 2EXP-hardness proof from <ref type="bibr" target="#b15">(Ngo, Ortiz, and Šimkus 2016)</ref>, we may assume that Σ consists only of concept names and each q k is connected and has only variables as terms.</p><p>Pick a fresh individual aux not used in A, and let A be obtained from A by adding A(aux) for every concept name A in K and P(aux, aux) for every role name P in K. Consider the KB K = (T , A ) and the CCQ q built as the conjunction of (i) all of the CQs q k in q (with all variables treated as counting variables), (ii) the query q A = ∃z A A(z A ) for each A ∈ Σ, and (iii) the queries q + P = ∃z + P P(z + P , aux) and q - P = ∃z - P P(aux, z - P ) for each role name P from K. For each A ∈ Σ, let n A be the number of individuals a such that A(a) ∈ A, and set N := A∈Σ (n A + 1). To complete the proof, one can show that N + 1 is a certain answer to q over K iff K entails q.</p><p>Theorem 5. CCQ answering in DL-Lite H pos is 2EXP-hard w.r.t. combined complexity.</p><p>Proof. As the 2EXP-hardness proof for DL-Lite H core from <ref type="bibr" target="#b15">(Ngo, Ortiz, and Šimkus 2016)</ref> does not involve negative inclusions, we can employ the same approach as for EL (the added aux assertions cannot lead to inconsistency).</p><p>We thus close the open question of the combined complexity of CCQ answering in DL-Lite H core . Note that our lower bound applies even to the subclass of CCQs whose every variable is a counting variable, as considered in <ref type="bibr" target="#b13">(Kostylev and Reutter 2015;</ref><ref type="bibr">Calvanese et al. 2020a)</ref>.</p><p>The preceding lower bound does not apply to DL-Lite pos , for which coNEXP membership has been shown <ref type="bibr" target="#b13">(Kostylev and Reutter 2015;</ref><ref type="bibr" target="#b4">Bienvenu, Manière, and Thomazo 2020)</ref>. We pinpoint the exact complexity by giving a matching lower bound, via a reduction from the exponential grid tiling problem. Here again the lower bound holds even when restricted to CCQs with only counting variables. Theorem 6. CCQ answering in DL-Lite pos is coNEXP-hard w.r.t. combined complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Cardinality Queries</head><p>In this section, we focus on the restricted class of cardinality queries, which allow one to count the number of elements belonging to a given concept or role name.</p><p>To reduce the number of cases to be studied, we first notice that role cardinality queries are always harder than concept cardinality queries for the logics we consider. Theorem 7. Let L be a sublogic of ELHI ⊥ that can express A ∃P. (A ∈ N C , P ∈ N R ). Then concept cardinality query answering over L KBs can be polynomially reduced to role cardinality query answering over L KBs.</p><p>Proof. Take a concept cardinality query q A = ∃zA(z) and a KB K = (T , A). We pick a fresh role name P ∈ sig(K), and consider the role cardinality query q P = ∃z 1 , z 2 P(z 1 , z 2 ) and modified TBox T := T ∪ {A ∃P. }.</p><p>Any model I of K can be extended to a model I of K = (T , A) by setting P I := {(e, e) | e ∈ A I }. Indeed, this ensures satisfaction of the additional axiom A ∃P. . Moreover, as no new domain elements were introduced, axioms B from T remain satisfied, and all other axioms are not affected since P / ∈ sig(T ). Notice that q A has exactly as many matches in I as q P has in I , hence an interval [m, +∞] is a certain answer to q A over K iff it is a certain answer to q P over K .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Results for EL and its Extensions</head><p>The next two results, together with Theorem 7, establish that cardinality query answering is coNEXP-complete w.r.t. combined complexity in ELHI ⊥ and ELI ⊥ . Theorem 8. Role cardinality query answering in ELHI ⊥ is in coNEXP w.r.t. combined complexity.</p><p>Proof. Theorem 2 proves that the minimal number of matches is reached with a model of exponential size.</p><p>Theorem 9. Concept cardinality query answering in ELI ⊥ is coNEXP-hard w.r.t. combined complexity.</p><p>Proof sketch. The proof proceeds by reduction from the complement of the Succinct-3COL problem, known to be NEXP-complete <ref type="bibr" target="#b17">(Papadimitriou and Yannakakis 1986)</ref>.</p><p>The coNEXP lower bound relies on KBs that only admit exponentially large models. For logics admitting polynomial-sized models, the complexity slightly decreases. Theorem 10. Let L be a sublogic of ELHI ⊥ for which every satisfiable KB admits a polynomial-sized model. Then role cardinality query answering over L KBs is in EXP.</p><p>Proof sketch. The key observation is that, for logics with polysize models and single-atom queries, the optimal number of matches is bounded polynomially in the size of the KB. We can thus iterate over all polynomial-sized ABoxes that could represent the restriction of an optimal model to the ABox and elements in matches. We test whether such an ABox extends to a model without new matches by performing a satisfiability check, taking the query role as closed predicate. This gives a deterministic single-exponential time</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The DL-Lite family and relations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Artale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research (JAIR)</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1" to="69" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Pushing the EL envelope</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international joint conference on Artificial intelligence (IJCAI)</title>
		<meeting>the 19th international joint conference on Artificial intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="364" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Ontology-mediated query answering with data-tractable description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tutorial Lectures of the 11th Reasoning Web International Summer School (RW)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="218" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Nested regular path queries in description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Simkus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Principles of Knowledge Representation and Reasoning (KR)</title>
		<meeting>the 14th International Conference on Principles of Knowledge Representation and Reasoning (KR)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="218" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Answering counting queries over DL-Lite ontologies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Manière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>the 29th International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1608" to="1614" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Cardinality queries over DL-Lite ontologies</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Manière</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>the 30th International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="1801" to="1807" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Tractable reasoning and efficient query answering in description logics: The DL-Lite family</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning (JAR)</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Aggregate queries over ontologies</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kharlamov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Nutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Thorne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Workshop on Ontologies and Information Systems for the Semantic Web (ONISW)</title>
		<meeting>the 2nd International Workshop on Ontologies and Information Systems for the Semantic Web (ONISW)</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="97" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Counting query answers over a DL-Lite knowledge base</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Corman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Razniewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>the 29th International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1658" to="1666" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Rewriting count queries over DL-Lite TBoxes with number restrictions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Corman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Razniewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd International Workshop on Description Logics (DL)</title>
		<meeting>the 33rd International Workshop on Description Logics (DL)</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Query answering in description logics: the knots approach</title>
		<author>
			<persName><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Simkus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Workshop on Logic, Language, Information and Computation (WoLLIC)</title>
		<meeting>the 16th International Workshop on Logic, Language, Information and Computation (WoLLIC)</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="26" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Answer counting under guarded TGDs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Feier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Przybylko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on Database Theory (ICDT)</title>
		<meeting>the 24th International Conference on Database Theory (ICDT)</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Descriptive complexity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Immerman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Complexity of answering counting aggregate queries over DL-Lite</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics (JWS)</title>
		<imprint>
			<biblScope unit="page" from="94" to="111" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Conjunctive query answering in the description logic EL using a relational database system</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>the 21st International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2009">2009. 2070-2075</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Closed predicates in description logics: results on combined complexity</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Šimkus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Conference on Principles of Knowledge Representation and Reasoning (KR)</title>
		<meeting>the 15th International Conference on Principles of Knowledge Representation and Reasoning (KR)</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="237" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Foundations of ontology-based data access under bag semantics</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nikolaou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence (AIJ)</title>
		<imprint>
			<biblScope unit="page" from="91" to="132" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A note on succinct representations of graphs</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Papadimitriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Yannakakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="181" to="185" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Linking data to ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Data Semantics (JoDS)</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="133" to="173" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Type-elimination-based reasoning for the description logic SHIQb s using decision diagrams and disjunctive datalog</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science (LMCS)</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A generic querying algorithm for greedy sets of existential rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR)</title>
		<meeting>the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Ontologybased data access: a survey</title>
		<author>
			<persName><forename type="first">G</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>the 27th International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="5511" to="5519" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
