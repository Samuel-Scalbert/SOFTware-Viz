<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exploring heterogeneous data graphs through their entity paths</title>
				<funder ref="#_G6zXE3Q #_CsSuDWG">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nelly</forename><surname>Barret</surname></persName>
							<email>nelly.barret@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Antoine</forename><surname>Gauquier</surname></persName>
							<email>antoine.gauquier@etu.imt-nord-europe.fr</email>
							<affiliation key="aff1">
								<orgName type="department">Institut Mines Télécom</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jia</forename><forename type="middle">Jean</forename><surname>Law</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Ecole Polytechnique</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
							<email>ioana.manolescu@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Exploring heterogeneous data graphs through their entity paths</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">DC4BF3D4BE1CA7EED876CEC479D09771</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Data graphs</term>
					<term>Graph exploration</term>
					<term>Information Extraction</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>Graphs, and notably RDF graphs, are a prominent way of sharing data. As data usage democratizes, users need help figuring out the useful content of a graph dataset. In particular, journalists with whom we collaborate [4] are interested in identifying, in a graph, the connections between entities, e.g., people, organizations, emails, etc. We present a novel, interactive method for exploring data graphs through their data paths connecting Named Entities (NEs, in short); each data path leads to a tabular-looking set of results. NEs are extracted from the data through dedicated Information Extraction modules. Our method builds upon the pre-existing <software ContextAttributes="used">ConnectionLens</software> platform <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> and follow-up work on dataset abstraction <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>. The contribution of the present work is in the interactive and efficient approach to enumerate and compute NE paths, based on an algorithm which automatically recommends subpaths to materialize, and rewrites the path queries using these subpaths. Our experiments demonstrate the interest of NE paths and the efficiency of our method for computing them.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">Motivation and Problem Statement</head><p>Data graphs, including RDF knowledge graphs, as well as Property Graphs (PGs), are often used to represent data. More broadly, any structured or semi-structured dataset can be viewed as a graph, having: (i) an internal node for each structural element of the original dataset, e.g., relational tuple, XML element or attribute, JSON map or array, URI in an RDF graph; (ii) a leaf node for each value in the dataset, e.g., attribute value in a relational tuple, text node or attribute value in XML, atomic (leaf) value in a JSON document, or literal in RDF. The connections between the data items in the original dataset lead to edges in the graph, e.g. parent-child relationships between XML or JSON nodes, edges connecting each relational tuple node with their attributes, etc. In a relational database, primary/foreign keys may lead to more edges, e.g., the node representing an Employee tuple "points to" the Company tuple representing their employer. This graph view of a dataset has been introduced to support unstructured (keyword-based) search on (semi)structured data, since <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b14">15]</ref> and through many follow-up works <ref type="bibr" target="#b19">[20]</ref>. Entity-rich graphs Building on this idea, the <software ContextAttributes="used">ConnectionLens</software> system <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> has been developed to facilitate, for non-IT users such as data journalists, the exploration of datasets of various models, including relational/CSV, XML, JSON, RDF, and PGs. <software ContextAttributes="used">ConnectionLens</software> turns any (set of) datasets into a single graph as outlined above. For instance, the data graph at the top of Fig. <ref type="figure" target="#fig_0">1</ref> features RDF triples about NASA spacecrafts (labeled edges), and an XML document describing presidents who attended spacecraft launches (tree with labeled nodes and unlabeled edges). <software ContextAttributes="used">ConnectionLens</software> also includes Information Extraction modules, which extract, from any leaf node in the data graph, Named Entities (People, Locations and Organizations) <ref type="bibr" target="#b4">[5]</ref>, as well as other types of entities that journalists find interesting: temporal moments (date, time), Website URIs, email addresses, and hashtags. We designate any of these pieces of information as entities, and we model them as extra nodes, e.g., in Fig. <ref type="figure" target="#fig_0">1</ref> (top), organizations appear on a pink background, people on yellow and locations on green, respectively. Each entity is extracted from a leaf text node, to which it is connected by a dashed edge. When an entity is extracted from more than one text node, the edges connecting it to those nodes increase the graph connectivity, e.g., "NASA" extracted from the nodes 15 and 17. Goal: efficient, interactive exploration of entity connections Journalists are interested in data paths ending in entity pairs of certain kinds in a given dataset, e.g. in Fig. <ref type="figure" target="#fig_0">1</ref>, "how people are connected to places?". When shown the set of corresponding labeled paths, users may pick one to further explore: how many pairs of entities are connected by each path?, which entities are most frequent?, etc. Note that it is important to consider paths irrespective of the edges directions in the data graph. This is because, depending on how the data is modeled, we may encounter x boughtProperty ----------→ y locatedIn ------→ c, or x hasOwner ← ------y locatedIn ------→ c; both paths are interesting. Challenges and contributions The analysis outlined above raises two challenges. First, it requires materializing the entity pairs connected by the paths, which may be very costly, if (i) the graph is large, and/or (ii) there are many paths (the latter is almost always true, if the data is complex/heterogeneous, and/or if we allow paths to traverse edges in both directions). Second, the large number of paths may overwhelm users. Non-expert users, or users which are not familiar with the dataset structure, cannot be expected to state "only the paths that they would like to see", since they lack technical expertise and/or dataset knowledge. However, if prompted by the system, they can give valuable input on whether certain links (or connections) are worth making, or whether they are just spurious links that would generate uninteresting paths. An example of uninteresting path is: in a dataset of French national assembly members, all addresses are in France, thus the France named entity enables connecting any two people.</p><p>Our contributions towards addressing these challenges is as follows. (i) From the data, we generate a small set of user questions, which help us leverage the domain knowledge that users may have, to generate interesting paths (Sec. 2 and 3). (ii) To speed up the materialization of interesting paths, we recommend a set of views (subpaths) to materialize, and rewrite each path query using these materialized views (Sec. 4). This allows to identify subpaths that appear in more than one path, and compute the corresponding data paths only once, greatly improving performance (Sec. 5).</p></div>
<div><head n="2">From datasets to data graphs</head><p>In order to propose a general approach that works on any data format (e.g. RDF, JSON, XML, etc.), we start by building a data graph out of each input dataset (Sec. 2.1). These graphs may be large, thus enumerating paths on them would be inefficient. Therefore, we leverage a more compact structure, namely a collection graph (Sec. 2.2). The graph representation and the collection graph are based on prior work <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>. Finally, we explain how we produce a single collection graph out of several datasets (Sec. 2.3), which journalists may need to exploit together in a particular investigation.</p></div>
<div><head n="2.1">From a dataset to a data graph</head><p>We transform any dataset as a directed graph G 0 = (N 0 , E 0 , λ 0 ) where N 0 is a set of nodes, E 0 is a set of vertices connecting N 0 nodes and λ 0 is a function assigning a label l to each node and edge (l may be empty). We map each data model on G 0 as follows. RDF graphs are naturally mapped on G 0 : each subject, respectively object, is turned into a node and an edge labelled with the property is connecting them. An XML document can be naturally viewed as a tree, with element nodes having element and attribute children. XML elements may carry #ID attributes whose values uniquely identify them; other XML elements may carry #IDREF attributes, whose values act as "foreign keys" referring to other elements by their #ID value. ID-IDREF information can be supplied in an optional Document Type Description (DTD) or XML Schema (XSD); when these are not available, ID-IDREF links can be found by profiling <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b0">1]</ref> techniques, which we also implemented. In the graph representation of an XML document, ID-IDREF links lead to more edges between elements (thus, the graph is no longer a tree). JSON documents are also modelled as trees, where each map, array, and leaf value is a node and parent-child edges are connecting them.</p><p>Named entities (NE) are extracted from each leaf of the data graph (RDF literal, XML text node or attribute value, or JSON value). For instance, in Fig. <ref type="figure" target="#fig_0">1</ref>, the NASA organization (pink background) is extracted from both the RDF and XML datasets. Each extracted NE is materialized by a new node in the graph, connected via an extraction edge (dashed arrows in Fig. <ref type="figure" target="#fig_0">1</ref>) to each leaf text node from which it has been extracted.</p></div>
<div><head n="2.2">From a data graph to a collection graph</head><p>The collection graph is a compact representation of the data graph. It is based on an equivalence relation between the data graph nodes: the collection graph has exactly one node for each equivalence class of data graph nodes; further, whenever n 1 → n 2 is an edge in the data graph, the collection graph comprises an edge C 1 → C 2 , where C 1 , C 2 are the equivalence classes (also called collections) to which n 1 , n 2 belong, respectively.</p><p>The most natural node equivalence relation differs across data models. Specifically, XML nodes we consider equivalent are elements with the same name; text nodes that are children of equivalent elements; and values of same-name attributes of equivalent elements. For instance, in Fig. <ref type="figure" target="#fig_0">1</ref>, the pilot nodes 7 and 8 are equivalent. In JSON, we consider equivalent nodes found on the same labeled path, from the JSON document root, to the node. A path is a concatenation of node and edge labels, separated by . (dots), where we assign special labels: µ to each map node, α to each array node, and to each empty node or edge label. For instance, in the JSON snippet [{"name": "Alice", "address": {"street": "Main", "city": "NY"}}] the path to "NY" is: α. .address.µ.city. In RDF, there are numerous ways to define node equivalence <ref type="bibr" target="#b9">[10]</ref>. RDF collection graphs are built through the <software ContextAttributes="used">TypedStrong</software> summarization method <ref type="bibr" target="#b11">[12]</ref>, working as follows. Whenever an RDF node has one or more types, all nodes with the same set of types are said equivalent (in RDF, a node can have several types, related or not, e.g. Student and Employee). For nodes without types, <software ContextAttributes="used">TypedStrong</software> summarization relies on the properties (labels of incoming and outgoing edges) that the nodes have, by introducing a notion of outgoing/incoming property cliques: (i) two properties that a node have, are in the same outgoing clique, e.g., agency and pilot are in the same outgoing clique because they are both property of node 10 in Fig. <ref type="figure" target="#fig_0">1</ref>, and also with descr because node 14 has agency and descr; incoming property cliques are symmetrically defined based on incoming properties; (ii) two nodes without types are equivalent if they have identical outgoing and incoming property cliques. For instance, nodes 10 and 14 (the two spacecrafts) are equivalent, since they have the same outgoing and incoming property cliques.</p><p>Fig. <ref type="figure" target="#fig_0">1</ref> (bottom) shows the collection graph corresponding to the data graph. We named the collections C 1 , C 2 , etc. Note that some data models have labeled edges, e.g., RDF, while others have (mostly) unlabeled edges, e.g., XML. For uniformity, we transform any labeled edge into a node and extend our summarization also to such nodes. In Fig. <ref type="figure" target="#fig_0">1</ref>, collection C 6 contains the nodes introduced instead of the pilot edges in the RDF dataset. Collection names in our figure are only for ease of explanation (they are not required in our method). Some collections, such as C 12 , C 13 , have nodes with identical names, in which case we use that name. For collections such as C 1 , with RDF nodes each with a different URI, we use an intuitive name, e.g., "Spacecraft". Entity collection profiles Each leaf collection in the collection graph corresponds to a set of literals (strings), out of which various NEs may have been extracted. These collections' names end with a # to help distinguish them (e.g. C 5 agency#). For each such collection C, we compute an entity profile storing how many entities of each type were extracted from its string nodes. In Fig. <ref type="figure" target="#fig_0">1</ref>, there are four such profiles, each shown as a box filled with the color of an entity type, e.g., the child of C 5 is pink reflecting the Organization entities extracted from agency values. In practice, long text nodes often lead to multiple NEs extracted, of several types. Knowledge of which leaf collections contain which kind of entities will be crucial to help users explore the graph (Sec. 3).</p></div>
<div><head n="2.3">From multiple datasets to a collection graph</head><p>Journalists often need to work with several datasets, e.g. a JSON collection of political tweets, the list of French mayors in XML, and an RDF graph of public investment in companies across France. Such datasets often have common values, e.g., the cities that mayors represent are also the places where companies are situated. Interesting data paths can be found across data sources.</p><p>To obtain a single collection graph from a set of datasets, we proceed as follows. First, we build a separated collection graph from each dataset (as in Sec. 2.2). Then, whenever two collections C 1 , C 2 from distinct datasets share values, we replace them by a new collection C 1,2 , which contains the values of C 1 and C 2 , and inherits all the incoming and outgoing edges of C 1 and C 2 in the collection graph they came from. Their original collection graphs are thus connected, and the entity profile of the new collection C 1,2 is built. In Fig. <ref type="figure" target="#fig_0">1</ref>, the collection graph reflects this unification: the pink filled node reflects organizations from both RDF and XML.</p></div>
<div><head n="3">Paths between entities</head><p>In this section, we discuss categories of paths that users might be interested in, and how to ask for their input.</p><p>An important first observation is: by the way we built the collection graph, to each dataset path corresponds a path in the collection graph. For instance, consider the data</p><formula xml:id="formula_0">path 13 ← 12 name ←---11 pilot ← ---10 agency -----→ 15 → 16 in Fig. 1. The collection graph features the corresponding path ← C 9 ← C 8 ← C 7 ← C 6 ← C 1 → C 4 → C 5 → .</formula><p>Further, some paths in the collection graph correspond to no paths in the data graph. For instance, the path C 6 ← C 1 → C 2 does not correspond to any path in the data, because no spacecraft (part of the collection C 1 ) has both the agency and descr properties. Such collection paths, with no support in the data, are introduced by summarization, which compresses the graph structure with some information loss. In our example, the fact that a spacecraft has agency and pilot, another has pilot and descr, and none has agency and descr is "simplified" into a collection C 1 that may have any combination of the three properties (represented by collections C 2 , C 4 , C 6 ). We consider this loss of information acceptable in exchange for the ability to work on a much smaller object (collection graph) instead of a potentially very large data graph.</p><p>Based on the above, our approach will be to (i) enumerate paths on the collection graph, then (ii) turn each path into a query, and (iii) evaluate this query on the data graph, and show users the resulting actual data connections (if any).</p></div>
<div><head n="3.1">Characterizing entity paths in the collection graph</head><p>Each path between two entities is first, characterized by a pair of entity types of the form (τ 1 , τ 2 ), where τ 1 , τ 2 ∈ E, with E being the set of supported entity types. E contains entity types such as Person, Location, Organization, Email, URI, Hashtag, Date, etc.</p><p>An entity path is also characterized by its length, i.e., the number of edges it contains. Depending on the application, interesting connections can be made by paths of different lengths; however, it appears likely that beyond a length such as 10 or 15, connections may become meaningless. Therefore, and also to control how many collection paths they want to inspect, users may specify a maximum path length L max , whose default value we set to 10. Path directionality By definition, each entity-to-entity collection path cp is of the form: </p><formula xml:id="formula_1">← C 1 C 2 → ,</formula><formula xml:id="formula_2">. A shared-root path is C 9 ← C 8 ← C 7 ← C 6 ← C 1 → C 4 → C 5 .</formula><p>-General, i.e., the edges may be in any direction.</p><p>Unidirectional paths are quite rare. This is because entity-connecting paths must have at each end a node from which an entity is extracted. Most of the time, these are two literal (string) nodes (as opposed to internal nodes structuring the dataset). Literals have incoming edges, but not outgoing ones (other than those towards extracted entities); thus, there is no unidirectional path from a literal to another. However, in some RDF datasets, NEs are extracted from URIs, e.g., the triple https://dbpedia.org/Facebook locatedIn ------→ http://dbpedia.org/California is a unidirectional data path from an Organization to a Location. Similarly, shared-sink paths only occur when nodes in C 1 and C 2 have outgoing edges, and NEs appear in their labels; this only happens in RDF URIs. Low-specificity connections Some edges in the data graph reflect connections that can be seen as weak, or non-specific. In details, let's first consider data edges with nonempty labels, e.g., RDF triples. Let e be the edge n 1 a -→ n 2 for some URIs n 1 , a, n 2 . The specificity of e, denoted e s , is computed as 2/(N 1,a + N 2,a ), where N 1,a , N 2,a are the numbers edges labeled a outgoing, resp. incoming n 1 , resp. n 2 <ref type="bibr" target="#b4">[5]</ref>. The highest N 1,a and/or N 2,a , the lowest e s . For instance, the specificity of each agency edge in Fig. <ref type="figure" target="#fig_0">1</ref> is 2/(1 + 2) = 2/3. For our purposes, we extend specificity to unlabeled edges as follows: the specificity of an edge n 1 -→ n 2 is 2/(1 + n 1,2 ) where n 1,2 is the number of (emptylabel) edges outgoing n 1 , towards nodes having the same label as n 2 . For instance, the specificity of the edge between nodes 6 and 7 is also 2/3.</p><p>In the collection graph, the edges with a non-empty label, connecting nodes from two equivalence classes lead to a collection, e.g., agency triples lead to C 4 . We attach to this collection, the average specificity of all the data edges it comes from, e.g., to C 4 we attach 2/3. Empty-label edges connecting graph nodes from two equivalence classes lead to an edge in the collection graph, e.g., C 11 → C 10 . We attach the average specificity of the original edges to this edge between two collections.</p></div>
<div><head n="3.2">Eliciting user input and collection path enumeration</head><p>First, we ask users which two entity types they want to connect (thus selecting τ 1 , τ 2 ). Next, we ask the maximum path length L max (with a default value, currently 10). Then, we ask how many types of data edges they are willing to review, in order to possibly decide to disallow paths to traverse such connections; the default value is 5. By type of data edge, we mean either an edge label, such as agency, or a pair of (parent name, child name), in case the edge is unlabeled, such as launch-pilot in Fig. <ref type="figure" target="#fig_0">1</ref>. Once the user chooses this value, say n spec , we show her successively the n spec collections (or collection graph edges) with the lowest average specificity, and ask if such a collection (or edge) should be excluded from the paths we search for, or not.</p><p>Finally, based on the collection graph, we enumerate all the paths connecting entities of types τ 1 , τ 2 , of maximum length L max , and respecting the exclusion constraints which users may have specified. We use a simple dynamic programming algorithm, running in memory, as the collection graph is typically much smaller than the data. We then inform the user: "There are N uni unidirectional paths, N sink shared-sink paths, N root shared-root paths, and N gen general paths between entities of type τ 1 and τ 2 ." The user can then either (i) chose to materialize one of these path sets, or (ii) change settings, e.g., L max , n spec , exclude more or less edge types, etc., until the user is satisfied with the predicted number of paths and decides to trigger materialization of a path set (Sec 4).</p></div>
<div><head n="4">Materializing data paths</head><p>At this point, we have a set of collection paths, which must be transformed into queries and evaluated on the data graph. Each such query matches similar-structure data paths, thus its results are shown to users as a table: the first and last attribute of such a table comprise entities of type τ 1 , τ 2 , while the intermediary attributes are the nodes and edges connecting these entities in the data graph. For instance, let τ 1 be Person, τ 2 be Organization: the light-yellow, respectively, light-pink background shapes in Fig. <ref type="figure" target="#fig_0">1</ref> materialize the two paths which, in this graph, connect the pink child of C 5 ( ) with the yellow children ( ) of C 9 , respectively, C 15 .</p></div>
<div><head n="4.1">From a collection path to a query over the data graph</head><p>Each collection path translates into a chain-shaped conjunctive query. For instance, the path on yellow background in Fig. <ref type="figure" target="#fig_0">1</ref>, going through C 5 and C 9 , becomes: q 1 ( x) :n(x 1 , τ Org , ), e(x 2 , x 1 , _), n(x 2 , _, C 5 ), e(x 3 , x 2 , agency), n(x 3 , _, C 1 ), e(x 3 , x 4 , pilot), n(x 4 , _, C 7 ), e(x 4 , x 5 , name), n(x 5 , _, C 9 ), e(x 5 , x 6 , _), n(x 6 , τ Person , ) This query refers to two relations: n(ID, type, equiv), describing nodes, with the last attribute denoting their equivalence class, and e(s, d, label), describing edges between nodes s and d and carrying a certain label. Each x i is a variable; x in the query head denotes all the x i variables, 1 ≤ i ≤ 6. We use _ to denote a variable which only appears once, in a single query body atom. Finally, τ Org and τ Person denote the node types of extracted Organization, respectively, extracted Person entity. Similarly, the pink-background collection path translates into: q 2 ( x) :n(x 1 , τ Org , ), e(x 2 , x 1 , _), n(x 2 , _, C 3 ), e(x 3 , x 2 , descr), n(x 3 , _, C 1 ), e(x 3 , x 4 , pilot), n(x 4 , _, C 7 ), e(x 5 , x 4 , _), n(x 5 , _, C 11 ), e(x 6 , x 5 , _), n(x 6 , _, C 12 ), e(x 6 , x 7 , _), n(x 7 , _, C 14 ), e(x 7 , x 8 , _), n(x 8 , _, C 15 ), e(x 8 , x 9 , _), n(x 9 , τ Person , ) Each of these queries can be evaluated through any standard graph database. However, evaluating dozens or hundreds of path queries on large graphs can get very costly. Further, since we do not know which paths may result from the user choices, we cannot establish path indexes beforehand.</p><p>View-based optimization To address this problem, we propose an optimization, based on the observation that queries resulting from collection paths may share some subpaths. For instance, the subquery s(x 3 , x 4 ) :n(x 3 , _, C 1 ), e(x 3 , x 4 , pilot), n(x 4 , _, C 7 ) is shared by q 1 ( x) and q 2 ( x). Therefore, we decide to (i) evaluate s and store its results; (ii) rewrite q 1 ( x) and q 2 ( x) by replacing these atoms in each query, by a single occurrence of the atom s(x 3 , x 4 ). The next sections formalize this for larger query sets, also showing how to handle different alternatives that may arise as to which shared subpaths to materialize.</p></div>
<div><head n="4.2">Enumerating candidate views</head><p>A first question we need to solve is enumerating, based on a set Q of path queries, the possible subqueries that we could materialize, and based on which we could rewrite some workload queries.</p><p>Let q ∈ Q be a path query: it is an alternating sequence of node (n) and edge (e) atoms. We denote by n q the number of edge atoms, then the number of node atoms is n q + 1. We denote by n Q the highest n q over all q ∈ Q.</p><p>Without loss of generality, our first heuristic (H1) is: we only consider connected subpaths of q as candidate subqueries. If q is of the form q( x) :n 1 , e 1 , . . . , e n q , n n q +1 , each connected subpath of q, denoted sq, is determined by two integers 1 ≤ i ≤ n q , i &lt; j ≤ n q + 1, such that sq(x i , x j ) :n i , e i , . . . , n j , e j , and x i , x j are the IDs of the nodes in the atoms n i , n j , respectively. We denote by q| i, j the subquery of q determined by the positions i, j. For instance, when q 1 is the sample query in Sec. 4.1, q 1 | 3,4 is the subquery s(x 3 , x 4 ) introduced there. Considering connected (cartesian-product free) candidate views is common in the literature, too (see Sec. 6).</p><p>Each query q ∈ Q has O(n 2 q ) connected subpaths, that can be easily enumerated from q's syntax. A second heuristic (H2) we adopt is: we only consider shared subpaths, that is, those subpaths s for which there exist q , q ∈ Q, q q , and integers i , j , i , j such that s = q | i , j = q | i , j , possibly after some variable renaming. For the queries q 1 , q 2 in Sec. 4.1, the subquery s 3,4 is q 1 | 3,4 and also q 2 | 3,4 . (H2) restricts the number of candidate views from |Q| × n 2 Q to a number that depends on the actual workload Q, and which decreases when Q paths look more like each other. Another interest of (H2) is: the benefit of using a view v to rewrite one query q is likely offset by the cost of materializing v; actual performance improvements start when v is used twice (or more), which is exactly the case for subqueries shared by several Q queries.</p></div>
<div><head>Algorithm 1: Selecting views to materialize and the respective view-based rewritings</head><p>Input : Queries Q, candidate materialized views V Output: Materialized views M and rewritings R for some Q queries</p><formula xml:id="formula_3">1 M ← ∅; R ← ∅ 2 while V ∅ do 3 for v ∈ V do 4 ben(v) ← 0; cost(v) ← cost</formula><p>to compute and store the view v 5 for q ∈ Q, q can be rewritten using v do 6 (ben(v, q), r q,v ) ← the cost of evaluating q based on v, through the rewriting r q,v , minus the cost of evaluating q directly on the graph</p><formula xml:id="formula_4">7 ben(v) ← ben(v) + ben(v, q) 8 (v max , b max ) ← a view v max maximizing ben(v) -cost(v)</formula><p>, and its benefit</p><formula xml:id="formula_5">9 if b max -cost(v max ) &lt; 0 then 10 exit 11</formula><p>Add v max to M 12 for q ∈ Q, q can be rewritten using v max do 13 if ben(v max , q) &gt; 0 then 14 Add r q,vmax to R</p><formula xml:id="formula_6">15 Remove q from Q 16 Remove v max from V</formula><p>Our third heuristic (H3) is: among the possible subqueries shared by two queries q , q , consider only the longest ones. That is, if s 1 , s 2 are two shared subqueries of q and q such that n s 1 &gt; n s 2 , do not consider the subquery s 2 .</p><p>Our heuristics (H1), (H2), (H3) lead to building the candidate view set V as follows. For each pair of distinct queries (q , q ) where q , q ∈ Q, add to V the longest, shared, connected subqueries of q and q . The complexity of this algorithm is</p><formula xml:id="formula_7">O(|Q| 2 × n 2 Q ), while |V| is in O(|Q| 2 ).</formula></div>
<div><head n="4.3">Selecting materialized views and rewriting path queries</head><p>Knowing the path queries Q and the candidate view set V, we need to determine: a set M ⊆ V of views which we actually materialize, in order to rewrite some Q queries. We collect the rewriting of each such queries in R. The decision to materialize a view incurs a cost, since the view data must be computed and stored. We denote cost(•) the cost of evaluating a view (or query), and assume it can be computed without actually computing it. Materializing a view is more attractive if (i) rewritings using it reduce significantly query evaluation costs, and (ii) its own materialization cost is small. In the most general case, a query could be rewritten based on any number of views, and also involving the base graph. For instance, query q 1 from Sec. 4.1 could be rewritten as:</p><formula xml:id="formula_8">q 1 | 1,3 q 1 | 3,4 q 1 | 4,6</formula><p>, where each denotes a natural join, on the variables x 3 , respectively, x 4 . However, enumerating all such alternatives makes the query rewriting problem NP-hard <ref type="bibr" target="#b13">[14]</ref>. Instead, we adopt another pragmatic heuristic (H4): rewrite each query using not more than one view. This simple choice keeps the view selection complexity under control, all the while providing good performance.</p><p>Algorithm 1 depicts our greedy method for finding M and V. It computes the benefit of each view v for each query that may be rewritten using v, as well as the cost of v. In a greedy fashion, it decides to materialize the view v max maximizing the overall benefit (for all Q queries), and uses it to rewrite all queries whose evaluation cost can be reduced thanks to v max , via the rewriting r q,v max . These queries are then removed from Q, the benefits of the remaining views are recomputed over the diminished Q, and the process repeats until no profitable view to materialize can be found.</p><p>Estimating costs Algorithm 1 needs to compute: (i) cost(•), the cost to evaluate a query q or materialize a view v; (ii) r q,v , the rewriting of q using a view v; and (iii) cost(r q,v ), the cost of such a rewriting. All these costs must be estimated before any query or view results are computed. We do this as follows. For (i), we use the cost estimation of the graph data management system (GDBM, in short) storing the graph. Our implementation relies on <software>PostgreSQL</software>, whose explain command returns both the estimated number of results of certain query (or view), denoted size(q), and the cost of computing those results. For (ii), recall (Sec. 4.2) that when v is used to rewrite q, v is a subpath of q, thus there exist i, j such that v = q| i, j . The rewriting r q,v is easily obtained by replacing, in the body of q, the atoms from the ith to the jth, with the head of v. Handling (iii) is more complex than (i). This is because the cost of a query (or view) is estimated based on statistics the GDBM has about the stored graph. In contrast, the GDBM cannot estimate cost of r q,v , because v has not been materialized yet, thus the GDBM cannot reason about v like it does about the graph. To compensate, we proceed as follows: we compute the cost of reading the hypothetical view v max from the database, by multiplying size(v max ), the estimation of the view size, with a constant (we used <software ContextAttributes="used">Postgres</software>' own CPU_TUPLE_COST); then, we estimate the cost of r q,v max as this reading cost plus the cost of estimating the parts of q not in v max plus the cost of joining v max with these (one or two) remaining query parts. We estimate the cost of each such join by adding their input sizes, which we then multiply with another (GDBM) constant. This reflects the fact that modern databases feature efficient join algorithms, such as memory-based hash joins, whose complexity is linear in the size of their inputs. Complexity Algorithm 1 makes at most O(|V| × |Q|) iterations, which can be simplified into O(|Q| 3 ). Forming a rewriting takes O(n Q ), bringing the total to O(|Q| 3 × n Q ). Impact of heuristics As previously discussed, (H1) is universally adopted in the literature: no candidate view features cartesian products. (H2), imposing that views benefit at least two queries, preserves result quality, i.e., cost savings, under every monotone cost model, ensuring that the cost of evaluating a query q is at least that of evaluating s, when s is a subquery of q. In contrast, (H3) and (H4) may each divert from the globally optimal solution. However, as our experiments show, our chosen rewritings perform well in practice, and the algorithm itself is very efficient.</p></div>
<div><head n="5">Experimental evaluation</head><p>Our approach is fully implemented in Java 11, on top of <software ContextAttributes="created">ConnectionLens</software> <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref> which builds the data graph (Sec. 2.1) and <software ContextAttributes="created">Abstra</software> <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref> which builds the collection graph (Sec. 2.2); these are stored in <software ContextAttributes="created">PostgreSQL</software>. We experimented on a <software ContextAttributes="created">Linux</software> server with an Intel Xeon Gold 5218 CPU @ 2.30 GHz and 196GB of RAM. We used <software ContextAttributes="created">PostgreSQL</software> v9.6. Our system is available at: https://team.inria.fr/cedar/projects/pathways/.</p><p>Our evaluation seeks to answer the two following questions: (i) how are entities connected in each dataset? (Section 5.2) and (ii) does Algorithm 1 help to evaluate paths queries over the data graph? (Section 5.3).</p></div>
<div><head n="5.1">Datasets and settings</head><p>We present experiments on an XML, an RDF and a JSON dataset. They all come from real-life applications (as opposed to synthetic) to stay close to application needs, and to ensure realistic Named Entities (NEs). Indeed, synthetic datasets are often generated with an interest on structure, while the leaf (text) values lack interesting information.</p><p>We used an XML PubMed subset describing scientific articles from PubMed, a database of biomedical publications. Each article is described by its title, journal, link, year, DOI, keywords list and authors list. Authors are identified by their name and their affiliation; they may declare their conflicts of interest in the &lt;COIStatement&gt; tag. We used the RDF Nasa dataset, describing NASA flights, spacecrafts involved in launches, related space missions and the participating agencies. Finally, we used the JSON Yelp-Business dataset where each business has an id, a name, an address, a city, a state, a postal code and coordinates (latitude and longitude). It also has a set of categories (e.g. bakery, shoe store, etc.) and a set of attributes (e.g. acceptCreditCards), the latter may be deeply nested. They also received reviews from customers modeled as a number of stars (from 0 to 5) and the number of reviews. YelpBusiness4, 4 times larger than YelpBusiness, allows studying the scalability of our algorithm. Tab. 1 shows for each dataset: its number of nodes |N|, edges |E|, numbers of extracted NEs |τ P |, |τ L |, |τ O | and the minimum edge specificity min(e s ). Without loss of generality, we experiment with the NE types Person, Location, Organization, whose types are denoted τ P , τ L , τ O , respectively. We set L max to 10, and avoided connections whose assigned specificity (Sec. 3) was less than 5% of the average specificity over all node/edge collections.</p></div>
<div><head n="5.2">Path enumeration</head><p>For each dataset and pair of entity types, Fig. <ref type="figure">2</ref> and<ref type="figure">3</ref> report the number of paths of each directionality (Sec. 3.1), the minimum and maximum length L p of each path, and the minimum and maximum data path support (number of results when evaluated on the data), this is denoted S p . For the PubMed (XML) and YelpBusiness (JSON) datasets, we obtained only shared-root paths: this is because of the tree structure of these datasets, where text values (leaves) are only connected by going through a common ancestor node. In the RDF Nasa dataset, we also found general-directionality paths. The JSON datasets are more irregular, leading to more paths. In almost every case, a few collection paths had 0 support, due to dataset summarization (Sec. 3). The maximum support may be high, e.g.  These results show that numerous interesting entity paths exist in our datasets, of significant length (up to 9), and some with high support, bringing the need for an efficient evaluation method.</p><formula xml:id="formula_9">L p ) = 5. (τ 1 , τ 2 ) T 0 |Q T O | |Q NV | |V| |M| T R T Q NV T = T R + T Q NV s = T 0 /T PubMed (τ P , τ O ) 250.36<label>5</label></formula></div>
<div><head n="5.3">Efficiency of path evaluation</head><p>We now study the efficiency of data path computations over the graph. Tab. 2 and Tab. 3 show, for each dataset and entity type pair, T 0 is the time to evaluate the corresponding path queries without the view-based optimization of Sec. 4.2 and 4.3, referred to as VBO from now on. |Q T O | is the number of queries whose execution we stopped (timeout of 30s) without VBO. |Q NV | is the number of queries for which Algo. 1 did not recommend a view. T R is the time to evaluate the rewritten queries on the data graph,  while T Q NV is the time to evaluate the non-rewritten queries Q NV ; T = T R + T Q NV is the (total) execution time to evaluate queries using VBO. Finally, s = T 0 /T is the speed-up due to VBO. We do not report times to materialize views because they were all very short (less than 0.01s). All times are in seconds.</p><p>The evaluation time T 0 without VBO ranges from 100s to 2000s; these path queries require 5 to 9 joins, on graphs of up to more than 200,000 edges (Tab. 1). |Q NV |, the number of queries that could not make use of any views, is rather small, which is good. The number of candidate views, respectively, materialized views depend on the complexity of the dataset, and thus on the complexity of the paths. The total path evaluation time T is reasonable. Finally, the VBO speed-up is at least 2× and at most 137×, showing that our view-based algorithm allows to evaluate path queries much more efficiently.</p></div>
<div><head n="5.4">Experiment conclusion</head><p>On graph leading to entity paths of various lengths and support, the view-based rewriting significantly reduces the path query evaluation time over the data graph.</p></div>
<div><head n="6">Related work and conclusion</head><p>Many graph exploration methods exist, see, e.g., <ref type="bibr" target="#b17">[18]</ref>. Modern graph query languages such as GPML <ref type="bibr" target="#b10">[11]</ref> (no implementation so far) or the JEDI <ref type="bibr" target="#b1">[2]</ref> SPARQL extension allow checking for paths between query variables, if users can specify a regular expression that the path labels match. Other systems interact with users to incrementally build SPARQL queries, In keyword-based search (KBS, in short) <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b19">20]</ref>, one asks for connections between two or more nodes matching specific keywords. KBS is handy when users know keywords (entities) to search for. In <ref type="bibr" target="#b5">[6]</ref>, graph queries are extended with a KBS primitive. The algorithms proposed there work directly on the graph; finding such trees in general is NP-hard, since it is related to the Group Steiner Tree problem. Complementary to these, we focus on identifying, and efficiently computing, all paths between certain extracted entities, to give a first global look at the dataset content, for graphs obtained from multiple data models.</p><p>Our view selection problem is a restriction (to path-only queries) of those considered, e.g., in <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref>. This allows for its low complexity, while being very effective. Our algorithms rely on collection graphs built by <software ContextAttributes="created">Abstra</software> <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9]</ref>, the interactive path enumeration approach, including VBO, is novel; it has been demonstrated in <ref type="bibr" target="#b6">[7]</ref>.</p></div><figure xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Sample data graph (top), and corresponding collection graph (bottom) on which paths linking entities are explored (highlighted areas).</figDesc><graphic coords="3,176.87,115.83,259.37,202.24" type="bitmap" /></figure>
<figure xml:id="fig_1"><head>(τ 1 ,</head><label>1</label><figDesc>τ 2 ) T 0 |Q T O | |Q NV | |V| |M| T R T Q NV T = T R + T Q NV s = T 0 /T YelpBusiness</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>where , are two entity profiles, such that the first, respectively, the second, contains some entities of types τ 1 , respectively, τ 2 , and C 1 , C 2 are value collections such as C 5 and C 9 in the example at the beginning of Sec. 3. The directions of the leftmost and rightmost edges are by convention always towards , , which represent entities. Let cp 0 denote the path C 1 C</figDesc><table /><note><p><p><p><p><p><ref type="bibr" target="#b1">2</ref> </p>. This path may be:</p>-Unidirectional, i.e., all cp 0 edges go from C 1 towards C 2 , or the opposite; -Shared-sink, i.e., cp 0 may contain a (collection) node C such that all edges between C 1 and C (if any) go from C 1 towards C, and all edges between C 2 and C (if any)</p>go from C 2 towards C. A shared-sink path is C 1 → C 6 → C 7 ← C 10 ← C 11 . -Shared-root, i.e.,</p>cp 0 may contain a (collection) node C such that all edges between C and C 1 (if any) go from C towards C 1 , and all edges between C and C 2 (if any) go from C towards C 2</p></note></figure>
<figure type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Dataset overview.</figDesc><table><row><cell>Dataset name</cell><cell>|N|</cell><cell>|E| |τ P | |τ L | |τ O | min(e s )</cell></row><row><cell>PubMed</cell><cell cols="2">63,052 89,710 5,993 2,151 5,096 0.001</cell></row><row><cell>Nasa</cell><cell cols="2">59,408 128,068 634 690 4,530 0.0002</cell></row><row><cell cols="3">YelpBusiness 57,963 61,627 322 427 1,437 0.001</cell></row><row><cell cols="3">YelpBusiness4 229,949 247,074 1,099 1,230 4,199 0.0002</cell></row></table></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc><ref type="bibr" target="#b14">15</ref>,181 in the PubMed dataset.(τ 1 , τ 2 ) N root min(S p ) max(S p ) (τ P , τ</figDesc><table><row><cell /><cell /><cell /><cell /><cell cols="4">(τ 1 , τ 2 ) N root N gen min(S p ) max(S p )</cell></row><row><cell>O ) 21</cell><cell cols="2">0 13,988</cell><cell /><cell>(τ P , τ O ) 99</cell><cell>1</cell><cell>0</cell><cell>629</cell></row><row><cell>(τ P , τ L ) 21</cell><cell cols="2">0 15,181</cell><cell /><cell>(τ P , τ L ) 95</cell><cell>5</cell><cell>0</cell><cell>137</cell></row><row><cell>(τ L , τ O ) 21</cell><cell>0</cell><cell>5,054</cell><cell /><cell>(τ L , τ O ) 97</cell><cell>3</cell><cell>0</cell><cell>603</cell></row><row><cell>(τ P , τ P ) 21</cell><cell>0</cell><cell>389</cell><cell /><cell>(τ P , τ P ) 97</cell><cell>3</cell><cell>0</cell><cell>89</cell></row><row><cell>(τ L , τ L ) 21</cell><cell>0</cell><cell>1,214</cell><cell /><cell>(τ L , τ L ) 97</cell><cell>3</cell><cell>0</cell><cell>3,050</cell></row><row><cell>(τ O , τ O ) 21</cell><cell>3</cell><cell>3,090</cell><cell /><cell>(τ O , τ O ) 97</cell><cell>3</cell><cell>0</cell><cell>8,960</cell></row><row><cell cols="8">Fig. 2. Entity paths in PubMed (left) and Nasa (right). PubMed: min(L p ) = 5; max(L p ) = 8. Nasa:</cell></row><row><cell cols="2">min(L p ) = 5; max(L p ) = 9.</cell><cell /><cell /><cell /><cell /><cell /><cell /></row><row><cell cols="4">(τ 1 , τ 2 ) N root max(L p ) min(S p ) max(S p )</cell><cell cols="4">(τ 1 , τ 2 ) N root max(L p ) min(S p ) max(S p )</cell></row><row><cell>(τ P , τ O ) 41</cell><cell>7</cell><cell>0</cell><cell>651</cell><cell>(τ P , τ O ) 48</cell><cell>7</cell><cell>0</cell><cell>2,593</cell></row><row><cell>(τ P , τ L ) 33</cell><cell>7</cell><cell>0</cell><cell>193</cell><cell>(τ P , τ L ) 39</cell><cell>7</cell><cell>0</cell><cell>760</cell></row><row><cell>(τ L , τ O ) 21</cell><cell>5</cell><cell>0</cell><cell>1,412</cell><cell>(τ L , τ O ) 39</cell><cell>5</cell><cell>0</cell><cell>258</cell></row><row><cell>(τ P , τ P ) 28</cell><cell>7</cell><cell>0</cell><cell>35</cell><cell>(τ P , τ P ) 36</cell><cell>7</cell><cell>0</cell><cell>207</cell></row><row><cell>(τ L , τ L ) 15</cell><cell>5</cell><cell>2</cell><cell>158</cell><cell>(τ L , τ L ) 15</cell><cell>5</cell><cell>0</cell><cell>674</cell></row><row><cell>(τ O , τ O ) 21</cell><cell>5</cell><cell>0</cell><cell>1,232</cell><cell>(τ O , τ O ) 21</cell><cell>5</cell><cell>0</cell><cell>4,889</cell></row><row><cell cols="8">Fig. 3. Entity paths in the YelpBusiness (left) and YelpBusiness4 (right) datasets. YelpBusiness</cell></row><row><cell cols="2">and YelpBusiness4: min(</cell><cell /><cell /><cell /><cell /><cell /><cell /></row></table></figure>
<figure type="table" xml:id="tab_3"><head>Table 2 .</head><label>2</label><figDesc>Data paths evaluation on the PubMed and Nasa datasets.</figDesc><table><row><cell /><cell /><cell>1 16 5 3.78 0.32</cell><cell>4.10</cell><cell>61×</cell></row><row><cell>(τ P , τ L ) 37.29</cell><cell>0</cell><cell>1 16 5 19.06 0.32</cell><cell>19.38</cell><cell>2×</cell></row><row><cell>(τ L , τ O ) 151.29</cell><cell>2</cell><cell>2 16 5 11.88 8.59</cell><cell>20.47</cell><cell>7×</cell></row><row><cell>(τ P , τ P ) 152.59</cell><cell>3</cell><cell>1 16 5 44.19 0.08</cell><cell>44.27</cell><cell>3×</cell></row><row><cell>(τ L , τ L ) 169.64</cell><cell>2</cell><cell>1 16 5 71.32 0.31</cell><cell>71.63</cell><cell>2×</cell></row><row><cell>(τ O , τ O ) 317.92</cell><cell>5</cell><cell>1 16 5 22.99 0.25</cell><cell>23.24</cell><cell>13×</cell></row><row><cell /><cell /><cell>Nasa</cell><cell /><cell /></row><row><cell>(τ P , τ O ) 195.47</cell><cell>1</cell><cell>0 80 10 54.14 N/A</cell><cell>54.14</cell><cell>3×</cell></row><row><cell>(τ P , τ L ) 254.26</cell><cell>3</cell><cell>0 68 10 44.57 N/A</cell><cell>44.57</cell><cell>5×</cell></row><row><cell cols="2">(τ L , τ O ) 1073.55 32</cell><cell>0 77 9 131.58 N/A</cell><cell>131.58</cell><cell>8×</cell></row><row><cell>(τ P , τ P ) 278.95</cell><cell>4</cell><cell>0 76 10 92.01 N/A</cell><cell>92.01</cell><cell>3×</cell></row><row><cell cols="2">(τ L , τ L ) 1103.48 30</cell><cell>0 77 9 101.35 N/A</cell><cell>101.35</cell><cell>10×</cell></row><row><cell cols="2">(τ O , τ O ) 1318.78 37</cell><cell>0 77 9 247.43 N/A</cell><cell>247.43</cell><cell>5×</cell></row></table></figure>
<figure type="table" xml:id="tab_4"><head>Table 3 .</head><label>3</label><figDesc>Data path evaluation on the YelpBusiness datasets.</figDesc><table><row><cell>(τ P , τ O ) 205.95</cell><cell>2</cell><cell cols="2">0 22 6 4.20 N/A</cell><cell>4.20</cell><cell>49×</cell></row><row><cell>(τ P , τ L ) 410.87</cell><cell>7</cell><cell cols="2">1 19 5 40.87 1.27</cell><cell>42.12</cell><cell>9×</cell></row><row><cell>(τ L , τ O ) 239.90</cell><cell>0</cell><cell>1 20 10 1.15</cell><cell>0.6</cell><cell>1.75</cell><cell>137×</cell></row><row><cell>(τ P , τ P ) 466.58</cell><cell>9</cell><cell cols="2">2 23 5 15.33 12.02</cell><cell>27.35</cell><cell>17×</cell></row><row><cell cols="2">(τ L , τ L ) 450.00 15</cell><cell cols="2">1 8 4 9.89 &lt; 0.01</cell><cell>9.89</cell><cell>45×</cell></row><row><cell>(τ O , τ O ) 334.22</cell><cell>4</cell><cell cols="2">1 10 5 2.83 &lt; 0.01</cell><cell>2.83</cell><cell>118×</cell></row><row><cell /><cell /><cell>YelpBusiness4</cell><cell /><cell /><cell /></row><row><cell cols="2">(τ P , τ O ) 804.70 26</cell><cell cols="2">0 23 6 62.52 N/A</cell><cell>62.52</cell><cell>12×</cell></row><row><cell cols="2">(τ P , τ L ) 454.19 10</cell><cell cols="2">1 20 5 92.50 &lt; 0.01</cell><cell>92.50</cell><cell>5×</cell></row><row><cell>(τ L , τ O ) 242.57</cell><cell>5</cell><cell cols="2">1 10 5 62.74 6.61</cell><cell>69.35</cell><cell>3×</cell></row><row><cell>(τ P , τ P ) 317.00</cell><cell>7</cell><cell cols="2">1 27 7 14.35 1.08</cell><cell>15.43</cell><cell>20×</cell></row><row><cell cols="2">(τ L , τ L ) 395.49 10</cell><cell cols="2">1 8 4 2.62 18.15</cell><cell>20.77</cell><cell>19×</cell></row><row><cell>(τ O , τ O ) 347.23</cell><cell>8</cell><cell cols="2">1 10 5 42.93 2.34</cell><cell>45.27</cell><cell>7×</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments This work has been funded by the <rs type="grantNumber">DIM RFSI PHD 2020-01</rs> project and the <rs type="projectName">AI Chair SourcesSay</rs> (<rs type="grantNumber">ANR-20-CHIA-0015-01</rs>) chair.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_G6zXE3Q">
					<idno type="grant-number">DIM RFSI PHD 2020-01</idno>
					<orgName type="project" subtype="full">AI Chair SourcesSay</orgName>
				</org>
				<org type="funding" xml:id="_CsSuDWG">
					<idno type="grant-number">ANR-20-CHIA-0015-01</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Data Profiling</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Abedjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Golab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Papenbrock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Synthesis Lectures on Data Management</title>
		<imprint>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Top-K Diversification for Path Queries in Knowledge Graphs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Aebeloe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Montoya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISWC Workshops</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">DBXplorer: A system for keyword-based search over relational databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Empowering investigative journalism with graph-based heterogeneous data management</title>
		<author>
			<persName><forename type="first">A</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Bouganim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE DEBull</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Graph integration of structured, semistructured and unstructured data for data journalism</title>
		<author>
			<persName><forename type="first">A</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Balalau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Conceicao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Systems</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Integrating Connection Search in Graph Queries</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Anadiotis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mohanty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2023-04">Apr 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Pathways: entity-focused exploration of heterogeneous data graphs (demonstration)</title>
		<author>
			<persName><forename type="first">N</forename><surname>Barret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gauquier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESWC</title>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Abstra: toward generic abstractions for data of any model (demonstration)</title>
		<author>
			<persName><forename type="first">N</forename><surname>Barret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Upadhyay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Computing generic abstractions from application datasets</title>
		<author>
			<persName><forename type="first">N</forename><surname>Barret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Upadhyay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2024">2024</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Summarizing Semantic Graphs: A Survey</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cebiric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Kondylakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kotzinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Troullinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zneika</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2019-06">Jun 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Graph pattern matching in GQL and SQL/PGQ</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022</date>
			<publisher>SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">RDF graph summarization for first-sight structure discovery</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guzewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2020-04">Apr 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">View selection in semantic web databases</title>
		<author>
			<persName><forename type="first">F</forename><surname>Goasdoué</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Karanasos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Leblay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Manolescu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Answering queries using views: A survey</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">Y</forename><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB J</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Keyword proximity search on XML graphs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Balmin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Holistic primary key and foreign key detection</title>
		<author>
			<persName><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Naumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Intell. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Scalable multi-query optimization for SPARQL</title>
		<author>
			<persName><forename type="first">W</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kementsietsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Duan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Knowledge graph exploration systems: are we lost?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lissandrini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mottin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Pedersen</surname></persName>
		</author>
		<ptr target="www.cidrdb.org" />
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Materialized view selection and maintenance using multi-query optimization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Mistry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sudarshan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramamritham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="307" to="318" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Keyword search on large graphs: A survey</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Sci. Eng</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>