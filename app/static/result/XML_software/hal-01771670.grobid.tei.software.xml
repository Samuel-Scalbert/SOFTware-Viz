<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">O n IS AN n-MCFL</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Kilian</forename><surname>Gebhardt</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Frédéric</forename><surname>Meunier</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sylvain</forename><surname>Salvati</surname></persName>
						</author>
						<title level="a" type="main">O n IS AN n-MCFL</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">3A15DF1848853F71C0C99B21523F2B6B</idno>
					<idno type="DOI">10.1016/j.jcss.2022.02.003</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Commutative properties in formal languages pose problems at the frontier of computer science, computational linguistics and computational group theory. A prominent problem of this kind is the position of the language O n , the language that contains the same number of letters a i and āi with 1 i n, in the known classes of formal languages. It has recently been shown that O n is a Multiple Context-Free Language (MCFL). However the more precise conjecture of Nederhof that O n is an MCFL of dimension n was left open. We present two proofs of this conjecture, both relying on tools from algebraic topology. On our way, we prove a variant of the necklace splitting theorem.</p><p>It is usual to present derivations as trees where nodes have the following form:</p><p>G A(s 1 , . . . , s n ) when from the derivations of the G B i (s i,1 , . . . , s i,l i ) we can derive G A(s 1 , . . . , s n ) using a rule of G. When p equals 0, there is no derivation above the bar. This means that rules with no right-hand part form the leaves of these trees.</p><p>Using this notation we can show as follows that a 1 a 1 ā2 ā1 ā1 a 2 is in the language of G 2 . We use colors to identify each letter and allow one to infer the rules used in the derivation:</p><p>G 2 I(a 1 , a 1 ā2 ā1 ā1 a 2 ) G 2 S(a 1 a 1 ā2 ā1 ā1 a 2 ) 3. Main result</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The language O n is the language built on the alphabet Σ n = {a i , āi | i ∈ [n]} and that contains exactly all words w which, for every i in [n], have the same number of occurrences of a i and āi . Writing |w| c the number of occurrences of the letter c in w, this condition becomes |w| a i = |w| āi for all i in <ref type="bibr">[n]</ref>. The problem of situating the languages O n within known classes of languages has been raised at least in two different communities.</p><p>The first one is that of computational linguistics. This problem has attracted attention with a language called M IX (also called the Bach language as it was introduced by Bach [Bac81, <ref type="bibr" target="#b3">Bac88,</ref><ref type="bibr" target="#b18">Pul83]</ref>) that is rationally equivalent to O 2 . It was related to the research program of Joshi <ref type="bibr" target="#b10">[Jos85]</ref> which consists in formally describing the class of languages corresponding to Natural Languages. According to Joshi's terminology, this is the class of Mildly Context Sensitive Languages. This program tries to give abstract properties of this class while describing possible candidates <ref type="bibr" target="#b23">[Wei88,</ref><ref type="bibr" target="#b11">JSW91]</ref>. Among such candidates, a powerful one is formed by Multiple Context Free Languages (MCFL) <ref type="bibr" target="#b21">[SMFK91]</ref>. According to Joshi et al. <ref type="bibr" target="#b11">[JSW91]</ref> the language "M IX can be regarded as the extreme case of free word order" and Mildly Context Sensitive Languages should "perhaps" not contain M IX (and thus O 2 ). This paper also mentions that the position of M IX in classes of languages, such as Tree Adjoining Languages, is not known and difficult to establish. In particular, it stresses that it is not known whether M IX is an Indexed Language.</p><p>The second community that has also shown interest for the problem is that of computational group theory which tries to identify properties of groups by means of properties of their word problem. The word problem for a group consists in describing the language of words that are equal to zero for a given presentation (all presentations giving rise to rationally equivalent languages). For example, Muller and Schuppe have characterized virtually free groups as exactly those groups whose word problems are solved by context free grammars <ref type="bibr" target="#b13">[MS83]</ref>. A question that has been raised by that community is whether O 2 -which coincides with the language corresponding to the word problem for the additive group (Z 2 , +)-is an Indexed Language <ref type="bibr" target="#b7">[Gil05]</ref>. This question remains open. MCFL form a natural generalization of "copyless" Macro-Languages (see <ref type="bibr" target="#b20">[SK08]</ref> for a discussion) and Macro-Languages are equivalent to Indexed Languages. This makes the question of whether O 2 belongs to MCFL relevant.</p><p>A first important result in that line of research is that O 2 is not a well-nested MCFL of dimension 2 <ref type="bibr" target="#b12">[KS12]</ref>, which solves a long-standing open problem raised by Joshi <ref type="bibr" target="#b10">[Jos85]</ref>. Subsequently it has been shown that it is actually an MCFL <ref type="bibr" target="#b19">[Sal15]</ref> and more precisely an MCFL of dimension 2 (a 2-MCFL). Nederhof <ref type="bibr" target="#b14">[Ned16]</ref> has given a similar proof of the same result. Later he conjectured that O n is an n-MCFL <ref type="bibr" target="#b15">[Ned17]</ref>. As pointed in this work, a simple pumping argument shows that O n cannot be an MCFL of dimension strictly smaller than n. More recently, a breakthrough has been achieved by Ho <ref type="bibr" target="#b8">[Ho18]</ref> who proved that O n is an MCFL for every n. However the MCFL constructed in the proof is of dimension larger than n, namely 8 n+1 2 -2. All proofs related to these results are based on algebraic topology. While the proofs of <ref type="bibr" target="#b19">[Sal15]</ref> and <ref type="bibr" target="#b14">[Ned16]</ref> strongly rely on topological properties of the plane (existence of winding numbers of curves around points), the aforementioned proof by Ho is based on the well-known Borsuk-Ulam theorem, a powerful theorem from algebraic topology which holds in any dimension. More specifically, it uses a combinatorial application of this theorem, due to Alon and West <ref type="bibr" target="#b1">[AW86]</ref>: the necklace splitting theorem. In this paper, we also rely on related tools to prove Nederhof's conjecture, namely that O n is an n-MCFL. Nederhof actually conjectures that a particular Multiple Context-Free Grammar (MCFG) of dimension n defines O n . We prove a slightly stronger result by showing that a grammar that uses a more restricted kind of rules is sufficient to define O n .</p><p>The article is structured as follows: In Section 2, we introduce notation regarding formal languages and MCFG as well as the grammar G n , which is an MCFG of dimension n. Section 3 establishes the main result namely that the language of G n is O n using a decomposition lemma. The decomposition lemma can on the one hand be derived from a variant of the necklace splitting theorem that we prove in Section 4. Alternatively, it can be obtained via purely combinatorial proofs presented in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background on Multiple Context Free Grammars</head><p>We write [n] for the set {1, . . . , n}. For a given finite set Σ, also called alphabet, we write Σ * for the monoid freely generated by Σ, and Σ + for the free semigroup generated by Σ. The elements of Σ are called letters while the elements of Σ * and Σ + are called strings or words and we write ε for the empty word. Given a word w, we write |w| for its length, and |w| c for the number of occurrences of the letter c in w. A language is a subset of Σ * .</p><p>We define the language</p><formula xml:id="formula_0">O n as {w ∈ Σ * n | |w| a i = |w| āi for i ∈ [n]} where Σ n is the alphabet {a i , āi | i ∈ [n]}. For α in Σ n , writing ᾱ exchanges a i and āi : if α is a i , then ᾱ is āi ; if α is āi , then ᾱ is a i .</formula><p>Two letters α and β of Σ n are compatible when α = β. We extend the (•) operation to words in Σ * n as follows: the word w is obtained from w by applying (•) to each of its letters.</p><p>A ranked alphabet Ω is a pair (A, ρ) where A is a finite set and ρ is a function from A to N. For a in A, the integer ρ(a) is the rank of a. We shall write Ω (n) for the set {a ∈ A | ρ(a) = n}. The dimension of a ranked alphabet is the maximal rank of its elements.</p><p>A Multiple Context Free Grammar (MCFG) G is a tuple (Ω, Σ, R, S) where Ω is a ranked alphabet of non-terminals, Σ is a finite set of letters, R is a set of rules and S is an element of Ω (1) called initial non-terminal. The rules in R are of the form (1)</p><p>A(w 1 , . . . , w n ) ⇒ B 1 (x 1,1 , . . . , x 1,l 1 ), . . . , B p (x p,1 , . . . , x p,lp )</p><p>where A is in Ω (n) , B k is in Ω (l k ) , the x k,j are pairwise distinct variables and the w j are elements of (Σ ∪ X) * with X = {x k,j | k ∈ [p] ∧ j ∈ [l k ]} and with the restriction that each x k,j may have at most one occurrence in the string w 1 • • • w n . Note that p may be equal to 0, in which case the right part of the rule (the one on the right of the ⇒ symbol) is empty.</p><p>Then we may write the rule by omitting the symbol ⇒. The dimension of an MCFG is that of its ranked alphabet of non-terminals. An MCFG of dimension at most n is an n-MCFG.</p><p>An MCFG such as G defines judgments of the form G A(s 1 , . . . , s n ) where A is in Ω (n) and the s j belong to Σ * . The notion of derivable judgments is defined inductively: suppose we are given p derivable judgments G B k (s k,1 , . . . , s k,l k ) where B k ∈ Ω (l k ) for k in [p]. For each rule of the form (1), the judgment G A(s 1 , . . . , s n ) is derivable when each s j is obtained from w j by replacing each occurrence of the variable x k,j by s k,j . The language defined by G, denoted by L(G), is the set {w ∈ Σ * | G S(w) is derivable}. The class of languages that are definable by MCFGs is the class of Multiple Context-Free Languages (MCFL). Likewise, the class of languages definable by n-MCFGs is the class of n-Multiple Context-Free Languages (n-MCFL).</p><p>We define now G n , the central n-MCFG for which we prove that it generates O n . It uses two non-terminals S and I that are respectively of rank 1 and n. The non-terminal S is the initial one. The alphabet of G n is Σ n . The rules of the grammar G n are the following:</p><p>(1) S(</p><formula xml:id="formula_1">x 1 • • • x n ) ⇒ I(x 1 , . . . , x n ).</formula><p>(2) I(w 1 , . . . , w n ) ⇒ I(x 1 , . . . , x n ), I(y 1 , . . . , y n ) for all w 1 , . . . , w n ∈ {x 1 , . . . , x n , y 1 , . . . , y n } * such that</p><formula xml:id="formula_2">w 1 • • • w n = x 1 y 1 • • • x n y n .</formula><p>(3) I(w 1 , . . . , w n ) ⇒ I(x 1 , . . . , x n ) for all w 1 , . . . , w n and all α ∈ Σ n , k, ∈ [n] such that w j = x j for j = k, and • k = implies w k ∈ {αx k , x k α} and w ∈ {ᾱx , x ᾱ}.</p><p>• k = implies w k = αx k ᾱ. (4) I(ε, . . . , ε). Items numbered (2) and (3) describe finite sets of rules. The rules (2) are parametrized by a particular factorization (w 1 , . . . , w n ) of x 1 y 1 • • • x n y n . For example, when n = 3 letting w 1 = x 1 y 1 x 2 , w 2 = y 2 x 3 and w 3 = y 3 is such a factorization; we have w 1 w 2 w 3 = x 1 y 1 x 2 y 2 x 3 y 3 . A rule of the form (3) adds a compatible pair of letters at distinct endpoints of the words. For example, I(a 1 x 1 , x 2 , ā1 x 3 , x 4 ) ⇒ I(x 1 , x 2 , x 3 , x 4 ) is such a rule for n = 4.</p><p>Example 1. The grammar G 2 contains the following rules:</p><formula xml:id="formula_3">S(x 1 x 2 ) ⇒ I(x 1 , x 2 ) I(x 1 y 1 x 2 y 2 , ε) ⇒ I(x 1 , x 2 ), I(y 1 , y 2 ) I(x 1 y 1 x 2 , y 2 ) ⇒ I(x 1 , x 2 ), I(y 1 , y 2 ) I(x 1 y 1 , x 2 y 2 ) ⇒ I(x 1 , x 2 ), I(y 1 , y 2 ) I(x 1 , y 1 x 2 y 2 ) ⇒ I(x 1 , x 2 ), I(y 1 , y 2 ) I(ε, x 1 y 1 x 2 y 2 ) ⇒ I(x 1 , x 2 ), I(y 1 , y 2 ) I(αx 1 ᾱ, x 2 ) ⇒ I(x 1 , x 2 ) α ∈ Σ 2 I(αx 1 , ᾱx 2 ) ⇒ I(x 1 , x 2 ) α ∈ Σ 2</formula><p>Our main theorem is that the language of G n is O n . The inclusion of L(G n ) into O n is obvious and the challenge consists in proving the converse inclusion. We prove actually a stronger statement:</p><formula xml:id="formula_4">Gn I(s 1 , . . . , s n ) is derivable for every s 1 • • • s n in O n .</formula><p>With this statement, the desired inclusion is immediate: for w ∈ O n , set s 1 = w and s j = ε for all j 2 and apply rule (1).</p><p>A tuple (s 1 , . . . , s n ) is reducible if there are at least two compatible letters among the endpoints of the s j 's; otherwise the tuple is irreducible. Repeated applications of rules of the form (3) allow to derive reducible tuples from irreducible ones. Irreducible tuples are dealt with the following "decomposition lemma," which shows how a rule of the form (2) is applied to derive an irreducible tuple from smaller elements in O n . While rule (4) provides the base case for the induction, this lemma is the main technical result towards the proof of Theorem 1. It relies on Theorem 2, a result stated and proved in Section 4, and formulated with the terminology of the necklace splitting theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1 (Decomposition lemma). Consider an irreducible tuple</head><formula xml:id="formula_5">(s 1 , . . . , s n ) in (Σ + n ) n , where each s j is of length at least 2. If s 1 • • • s n belongs to O n , then there exist two tuples (u 1 , u 3 , . . . , u 2n-1 ) and (u 2 , u 4 , . . . , u 2n ) in (Σ * n ) n and integers 0 = k 0 k 1 • • • k n = 2n such that (I) u 1 u 3 • • • u 2n-1 and u 2 u 4 • • • u 2n are both nonempty elements of O n , and (II) s j = u k j-1 +1 u k j-1 +2 • • • u k j for each j ∈ [n]. In particular, s 1 • • • s n = u 1 u 2 • • • u 2n .</formula><p>Proof. We distinguish the cases n = 1 and n 2.</p><p>We deal first with the case n = 1. In that case, Σ n = {a 1 , ā1 }. As s 1 is irreducible, without loss of generality, we may assume that s 1 = a 1 wa 1 . We consider prefixes u of w of increasing length, from |u | = 0 to |u | = |w|. Since s 1 belongs to O 1 , the quantity |a 1 u | a 1 -|a 1 u | ā1 starts with the value 1 and finishes with the value -1, and changes by steps of one unit. There is therefore a prefix u of w such that a 1 u belongs to O 1 . Setting u 1 = a 1 u and u 2 ∈ Σ + 1 such that s 1 = u 1 u 2 makes the job. We deal now with the case n 2. The proof of Theorem 2 builds explicitly u 's satisfying the desired properties: property (I) is a consequence of the fact that each of A and B are balanced; property (II) is a consequence of the fact that the endpoints of the s j 's form cuts.</p><p>From this the inclusion follows easily.</p><formula xml:id="formula_6">Proposition 1. The judgment Gn I(s 1 , . . . , s n ) is derivable for every s 1 • • • s n in O n . In particular, we have O n ⊆ L(G n ).</formula><p>Proof. As mentioned above, the second part of the statement is a direct consequence of the first part. We proceed by induction on the pairs (|s 1 • • • s n |, e) ordered lexicographically, where e is the number of s j equal to ε.</p><p>Suppose first that (s 1 , . . . , s n ) is reducible. A rule of the form (3) shows that we can derive the judgment from another judgment Gn I(s 1 , . . . , s n ), with</p><formula xml:id="formula_7">|s 1 • • • s n | &lt; |s 1 • • • s n |.</formula><p>The induction hypothesis provides the conclusion.</p><p>Suppose now that (s 1 , . . . , s n ) is irreducible. Four cases are in order, distinguished according to the possible lengths of the s j 's.</p><p>The first case is when at least one s j is of length 1. Without loss of generality we may assume that s j = a 1 . As</p><formula xml:id="formula_8">s 1 • • • s n is in O n , there is a k such that s k = v 1 ā1 v 2 for some v 1 and v 2 in Σ * n .</formula><p>The other case being similar, we suppose that j &lt; k. Define t j = a 1 , t k = ā1 , and t = ε for = j, k; define also (u 1 , . . . , u n ) = (s 1 , . . . , s j-1 , s j+1 , . . . , s k-1 , v 1 , v 2 , s k+1 , . . . , s n ). Using rule (4) and a rule of the form (3), we get that Gn I(t 1 , . . . , t n ) is derivable. The judgment Gn I(u 1 , . . . , u n ) is derivable by induction. Then using a rule of the form (2) shows that Gn I(s 1 , . . . , s n ) is derivable. More precisely, we instantiate each variable x with t and each variable y with u in the following rule</p><formula xml:id="formula_9">I(x 1 y 1 , . . . , x j-1 y j-1 , x j , y j , . . . , x k-2 y k-2 x k-1 , y k-1 x k y k , . . . , x n y n ) ⇒ I(x 1 , . . . , x n ), I(y 1 , . . . , y n ) .</formula><p>The second case is when all s j are equal to ε. The conclusion follows from an application of rule (4).</p><p>The third case is when some s j but not all are equal to ε and no s j is of length 1. There is then an j ∈ [n -1] such that either s j = ε and |s j+1 | &gt; 1, or |s j | &gt; 1 and s j+1 = ε. By symmetry, we suppose that s j = ε and</p><formula xml:id="formula_10">|s j+1 | &gt; 1. As |s j+1 | &gt; 1, we have that s j+1 = v 1 v 2 with v 1 and v 2 in Σ + . Define (s 1 , . . . , s n ) = (s 1 , . . . , s j-1 , v 1 , v 2 , s j+2 , . . . , s n ).</formula><p>The judgment Gn I(s 1 , . . . , s n ) is derivable by induction (we have a smaller e). The judgment Gn I(ε, . . . , ε) is derivable from an application of rule (4). Then using a rule of the form (2) shows that Gn I(s 1 , . . . , s n ) is derivable. More precisely, we instantiate each variable x with s and each variable y with ε in the following rule: I(x 1 y 1 , . . . , x j-1 y j-1 , ε, x i y j x j+1 y j+1 , . . . , x n y n ) ⇒ I(x 1 , . . . , x n ), I(y 1 , . . . , y n ) .</p><p>The fourth case satisfies the conditions of Lemma 1 ("decomposition lemma"), which shows that Gn I(s 1 , . . . , s n ) is derivable by an application of a rule of the form (2) and by induction.</p><p>From this we can derive our main theorem.</p><p>Theorem 1. The language O n is an n-MCFL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark.</head><p>Theorem 2 actually implies a version of Lemma 1 that also holds for reducible tuples albeit only if n is at least 2 and if we permit to decompose (s 1 , . . . , s n ) in more versatile tuples. This corresponds to a slightly more liberal definition of the rules (2). More precisely, we may add to the rules (2) for each j ∈ [n] the rule:</p><p>( * ) I(x 1 y 1 , . . . , x j-1 y j-1 , y j x j , x j+1 y j+1 , . . . , x n y n ) ⇒ I(x 1 , . . . , x n ), I(y 1 , . . . , y n ) .</p><p>We have chosen to exclude rules ( * ) to emphasize the surprising simplicity of the rules (2) which allow to decompose every irreducible tuple. Moreover, we want to contrast the grammar we obtain with the one that Nederhof <ref type="bibr" target="#b15">[Ned17]</ref> conjectures to capture O n . Nederhof proposes binary rules of the following form:</p><formula xml:id="formula_11">A(w 1 , . . . , w n ) ⇒ A(x 1 , . . . , x n ), A(y 1 , . . . , y n ) where w 1 • • • w n is obtained by shuffling the words x 1 • • • x n and y 1 • • • y n , i.e., |w 1 • • • w n | = 2n, removing all occurrences of y j 's from w 1 • • • w n yields x 1 • • • x n and, analogously, removing all occurrences of x j 's from w 1 • • • w n yields y 1 • • • y n .</formula><p>Furthermore, a w k may not contain an occurrence of x j x j+1 or of y j y j+1 for some j ∈ [n -1]. The rules (2) may be obtained from Nederhof's by forbidding the occurrence of x j x j+1 and of y j y j+1 not only in the w k 's but rather in the combined word w 1 • • • w n . Note however that this additional restriction implies that rules (3) need to allow the removal of compatible letters at arbitrary endpoints of the words of a tuple. The corresponding rules of Nederhof's grammar are less liberal. Were we to remove rules (3) and treat the elimination of compatible letters as in <ref type="bibr" target="#b15">[Ned17]</ref>, then we would need to add the rules ( * ). Clearly, these rules form a strict subset of those proposed by Nederhof as w k 's are of length 2 and at most one occurrence of x j x j+1 is allowed in w 1 • • • w n . In this sense, our grammar is simpler than Nederhof's. Notably, also Nederhof [Ned17, Sec. 5.3] conjectures for O 3 that some of the rules of his grammar are redundant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Necklace splitting and proof of the decomposition lemma</head><p>In this section, we prove a combinatorial theorem in the tradition of the necklace splitting problem. The theorem almost implies Lemma 1, but while it does not require irreducibility, it misses the property (II). Its proof however gives the construction for the case n &gt; 1 of Lemma 1.</p><p>This combinatorial theorem is formulated without the terminology of languages and grammars so as to make it understandable easily without background in this area. For readers who are more familiar to manipulating words, the vocabulary of the necklace problem translates easily to that of words: necklaces become words and beads become letters.</p><p>In the traditional version of the necklace splitting theorem, there is an open necklace with beads of n different types, and an even number of beads of each type. The necklace splitting theorem ensures that such a necklace can always be split between two thieves with no more than n cuts so that each thief gets the same amount of each type. The cuts have to leave the beads untouched. Here, we keep the same setting, except that a bead can be either "positive" or "negative." The amount of a type in a necklace or in a collection of necklaces is the number of positive beads of this type minus the number of negative beads of this type. A necklace or a collection of necklaces is balanced if the amount of each type is zero.</p><p>Theorem 2. Consider a collection of n open necklaces with positive and negative beads. Suppose that there are n 2 types of beads and that each of the necklaces has at least two beads. If the collection is balanced, then there is a way to cut the necklaces using at most n cuts in total and partition the subnecklaces into two parts so that each part is balanced, gets at least one bead (and thus at least two), and is formed by at most n subnecklaces.</p><p>The connection to Lemma 1 is as follows:</p><p>• The n types of beads are the numbers 1, . . . , n, the letter a i representing a positive bead of type i and the letter āi representing a negative bead of type i.</p><p>• The n open necklaces correspond to the words s 1 , . . . , s n .</p><p>• The two parts of the at most n subnecklaces are the tuples (u 1 , . . . , u 2n-1 ) and (u 2 , . . . , u 2n ) in the lemma, which, as in the theorem, are required to be balanced and to contain at least one letter each. The proof of Theorem 2 relies on the following proposition, which is actually the traditional necklace splitting theorem extended to negative beads (the relaxation of the parity condition of the number of beads is standard; see, e.g., [AMS06, Section 5.1]).</p><p>Proposition 2. Consider a necklace with positive and negative beads. Suppose that there are n 1 types of beads. Then the necklace can be split between two thieves with no more than n cuts so that the amount of beads received by the thieves differ by at most one unit for each type. It is moreover possible to choose which thief receives an extra bead for each type which requires so.</p><p>The types requiring that one of the thieves receives an extra bead are precisely those whose total amount of beads is an odd number.</p><p>Proof of Proposition 2. We proceed in two steps. In a first step, we prove a continuous version, in which we are allowed momentarily to locate cuts on beads themselves. In a second step, we show how to move the cuts so as to get a splitting with cuts leaving the beads untouched. <ref type="foot" target="#foot_3">1</ref>We identify the necklace with [0, 1] and the beads with intervals included in [0, 1], all of same length (this length is the inverse of the total number of beads in the necklace), and with disjoint interiors. Assume that these small intervals are all open. (This assumption is made to ease the proof, but actually whether these small intervals contain or not their boundaries does not matter.) Define</p><formula xml:id="formula_12">g i (x) -→    +1 if</formula><p>x is in a interval corresponding to a positive bead of type i.</p><p>-1 if x is in a interval corresponding to a negative bead of type i. 0 otherwise.</p><p>According to the Hobby-Rice theorem <ref type="bibr" target="#b9">[HR65]</ref>, there are points 0 =</p><formula xml:id="formula_13">x 0 &lt; x 1 &lt; • • • &lt; x r &lt; x r+1 = 1 with r n such that for all i ∈ [n] r+1 j=1 (-1) j x j x j-1 g i (u) d u = 0 .</formula><p>(Here, we take the formulation given by Pinkus <ref type="bibr" target="#b17">[Pin76]</ref>.) The r points x 1 , . . . , x r can be interpreted as cuts. The intervals (x j-1 , x j ) with j odd are given to one thief, and the intervals (x j-1 , x j ) with j even are given to the other thief. Each thief gets the same amount of each type. The only problem is that some cuts may be located on beads. The second step of the proof consists in explaining how to move these cuts so that none of them touch the beads anymore, without creating a difference of more than one unit between the amounts received by the thieves for each type. We can make that each bead is cut at most twice since moving two cuts inside a bead in the same direction and by the same distance does not change the amounts received by the thieves. If a bead is cut twice, we can similarly move the two cuts until one of them is located between two beads. (Doing this, we can have several cuts located at the same position between two beads, but this is not an issue.) So, we can assume that each bead is cut at most once and that the two parts of a cut bead go to distinct thieves. If a type has two beads or more touched by a cut, then we can move two cuts so that one at least reaches a position between two beads, without changing the amounts received by each thief. Thus, we can assume that each type is cut at most once. We finish the proof by noting that if a type has a bead that is cut, it means that each thief received a non-integral amount of the corresponding type, i.e., a half-integer, and moving the cut arbitrarily leads to the desired splitting.</p><p>Proof of Theorem 2. Denote by s 1 , . . . , s n the n necklaces. We assume that there are no two beads located at the endpoints of some necklaces and that are of the same type but of opposite signs, for otherwise there would be an easy solution: cut these two beads from the necklaces, form a balanced part with them, and leave the rest of the remaining beads for the second balanced part. The number of cuts would then be 2 n (or, if these two beads formed a necklace of their own, the solution would need no cut), and the number of subnecklaces in the parts would be 2 and n (or 1 and n -1). Making this assumption corresponds to considering only the irreducible case in the terminology of Theorem 1.</p><p>A natural idea would be to apply a result like Proposition 2 to the "big" necklace s = s 1 • • • s n obtained by appending the necklaces in their index order. The first issue with this idea is that one thief might get nothing. This can easily be dealt with as done below. The second issue is that, even though there are 2n subnecklaces in total, one thief might get more than n subnecklaces.<ref type="foot" target="#foot_4">2</ref> Instead we consider another big necklace, which we will denote by s and which we define now.</p><p>We start by defining s 1 to be s 1 from which the left-most bead has been removed, and s n to be s n from which the right-most bead has been removed. Note that without loss of generality, we can assume that the left-most bead of s 1 is a positive bead of type 1 and that the right-most bead of s n is a positive bead of type 1 or n. We thus consider two cases:</p><p>(i) The left-most bead of s 1 and the right-most bead of s n are both positive beads of type 1.</p><p>where δ (i) ∈ {0, 1} and takes the value 1 only if we are in Case (i), and where δ i=n (ii) ∈ {0, 1} and takes the value 1 only if we are in Case (ii) and i = n.</p><p>For the beads of type 1, we have</p><formula xml:id="formula_14">q A 1 -q B 1 = 1 -δ (i) + n+1 k=1 j odd (-1) k+1 µ 1 (s j ∩ t k ) + n+1 k=1 j even (-1) k+1 µ 1 (s j ∩ t k ) = 1 -δ (i) + n+1 k=1 (-1) k+1 µ 1 (t k ) = 0 ,</formula><p>where the last equality is a consequence of Equation (2) in Case (i) and of Equation (3) in Case (ii). For the beads of type i = 1, we have</p><formula xml:id="formula_15">q A i -q B i = -δ i=n (ii) + n+1 k=1 j odd (-1) k+1 µ i (s j ∩ t k ) + n+1 k=1 j even (-1) k+1 µ i (s j ∩ t k ) = -δ i=n (ii) + n+1 k=1 (-1) k+1 µ i (t k ) = 0 ,</formula><p>where the last equality is a consequence of Equation (2), except when i = n and we are in Case (ii), where we use of Equation (4) instead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Alternate combinatorial proofs of Proposition 2 and Lemma 1</head><p>All statements deal with discrete objects and properties. It is thus desirable from a logical point of view that all proofs stay in the "discrete world" if possible. Similarly to the traditional proof of the necklace splitting theorem, the proof of Proposition 2 we gave in Section 4 is relying on some "continuous" notions. Pálvőlgyi <ref type="bibr" target="#b16">[Pál09]</ref> showed how such proofs are amenable to the discrete world by using a combinatorial counterpart of the Borsuk-Ulam theorem.</p><p>We adapt here the approach proposed by Pálvőlgyi to provide a purely combinatorial proof of Proposition 2, also relying on Tucker's lemma. Moreover, we show how the more general Ky Fan lemma can actually provide a direct combinatorial proof of Lemma 1 itself. 5.1. Combinatorial tools. We start by introducing some notation. Let B = {-1, 1}. For brevity, we may write + instead of +1 and -instead of -1. Let O = {-1, 0, 1}. We define the partial order ≺ on O where 0 ≺ 1 and 0</p><formula xml:id="formula_16">≺ -1, or, equivalently, b b if b = 0 or b = b .</formula><p>For every m ∈ N, we lift ≺ to O m where for x, y ∈ O m we have x y if for all i ∈ [m], x(i) y (i). Given a string x, we denote by x(i) the i-th letter of x. We also denote by -x the string obtained from x by replacing 1's by -1's and -1's by 1's (and the 0's are left unchanged). Now the Ky Fan lemma can be stated as follows:</p><p>Lemma 2 (Octahedral Ky Fan lemma, [Che11, Lemma 2]). Let λ : O m \ 0 m → {±1, . . . , ±q} such that (i) λ(-x) = -λ(x) for every x.</p><p>(ii) λ(x) + λ(y) = 0 for every x y.</p><p>Then there is at least one positively alternating m-chain, i.e., there are x 1 , . . . , x m ∈ O m \ 0 m and j 1 , . . . , j m ∈ [q] such that x 1 • • • x m , 1 j 1 &lt; j 2 &lt; • • • &lt; j m , and λ({x 1 , . . . , x m }) = {j 1 , -j 2 , j 3 , . . . , (-1) m-1 j m }. In particular, q m.</p><p>(The statement we provide here is actually a special case of the original Ky Fan lemma <ref type="bibr" target="#b6">[Fan52]</ref> when the simplicial complex is the first barycentric subdivision of the octahedron.) The octahedral Tucker lemma <ref type="bibr" target="#b22">[Tuc46]</ref> is actually the same statement without the existence of the chain, but still with the inequality q m.</p><p>We explain now how strings in O m relate to decompositions of strings in Σ m n . We consider here all decompositions of a string w ∈ Σ m n into two tuples (u 1 , u 3 , . . . ), (u 2 , u 4 , . . . ) of strings in Σ + n such that w = u 1 u 2 • • • . Such a decomposition is described as a string x ∈ B m where each maximal segment of consecutive -1's, as well as each maximal segment of consecutive +1's, corresponds to one u j . Each sign change in x corresponds thus to a cut in w and to a transition from a u j to u j+1 . A string x ∈ O m , containing some 0's, can be interpreted as an underspecified decomposition, which can be completed into different decompositions by replacing the 0's with -1's or +1's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Combinatorial proof of Proposition 2.</head><p>We prove Proposition 2 in a way that is similar to <ref type="bibr" target="#b16">[Pál09]</ref>.</p><p>For x in B * we let alt(x) be the number of sign alternations in x. We extend the function alt to O * \ 0 * as follows: alt(x) = max{alt(y) | y ∈ B * , x y}. Notice that:</p><p>• alt(-x) = alt(x) for every x.</p><p>• alt(x) alt(y) for every x y. For x in O * \ 0 * , we define sign(x) ∈ {-1, 1} as the first letter of some y in B * so that x y and alt(x) = alt(y). The function sign(x) is well defined as when x is of the form 0 k κx , with κ ∈ B, the only way to replace the first k zeroes so as to maximize alt consists in changing the sign at each position.</p><p>From now on we fix the necklace w and assume it is of length m (i.e., w is in Σ m n ). We let E κ,i (x) for x in O m \ 0 m and κ ∈ {-1, 1} be the amount of beads of type i in w that are aligned with the symbol κ in x. We say that x is κi-unbalanced if E κ,i (y) &gt; E -κ,i (y) for every y such that x y. We define unb(x) to be κi where i is the smallest i so that x is κi-unbalanced. When no such i exists, we let unb(x) = 0. We have</p><p>• unb(-x) = -unb(x) for every x. Because of the properties of alt, sign and unb, had it no zero, the function λ would satisfy the properties (i) and (ii) of the octahedral Tucker lemma. However, then the conclusion is not satisfied, thus λ must have a zero. Take x so that λ(x) = 0. We must have that alt(x) n.</p><p>As unb(x) = 0, it is possible, for each type i, to replace 0's in x with 1's or -1's so that we eventually obtain y verifying E 1,i (y) = E -1,i (y) for every i, and such that the remaining 0's in y are aligned with at most one unassigned bead of type i. We can then choose to replace these 0's with either 1 or -1 depending on how we wish to treat the extra bead of a given type. As alt(x) is smaller than n, then no matter how we have conducted the previous changes, we have obtained a way to split the necklace with at most n cuts so that each part contains the same amount of each type, with the extra beads (when the amount is odd) being distributed in any possible way.</p><p>Remark. The definition of unb is where the proof departs from the one of <ref type="bibr" target="#b16">[Pál09]</ref>. Indeed Pálvőlgyi's proof only considers positive beads and it is then enough to consider that x is unbalanced when one of the thief receives more than half of the beads of some type. In that case the split remains unbalanced for every y so that x y. This property is no longer true with negative beads. Our definition of unb is taking this into account by imposing that being unbalanced is closed under . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Combinatorial proof of</head><formula xml:id="formula_17">x = κ 1 1 κ 2 2 • • • κ k k with κ 1 , .</formula><p>. . , κ k ∈ B, κ p = -κ p+1 and p ∈ N be such that for each j ∈ [n], there is q j ∈ {0, . . . , k} with p∈[j] |s p | = p∈[q j ] p , and k is minimal. Now, if k = 2n, then x describes a decomposition of (s 1 , . . . , s n ) in two tuples each of size n. Precisely, these tuples are (u 1 , u 3 , . . . , u 2n-1 ) and (u 2 , u 4 , . . . , u 2n ) where the length of u j is j for each j ∈ [2n] and s j = u q i-1 +1 u q i-1 +2 • • • u q j for each j ∈ [n]. If k &lt; 2n, we may add κ q 's with q = 0 to increase k to 2n and proceed similarly. We call the value k -1 the number of sign alternations of x and write alt(x) = k -1. Hence, in the following we will search for x with alt(x) 2n -1. Crucially, we assume mandatory sign alternations between the neighboring endpoints of s j and s j+1 : if the last position of s j and the first position of s j+1 are signed equally in x, then some κ p with p = 0 occurs in our factorization of x. In this case 2 sign alternations are accounted for the transition between neighboring endpoints. In order to maximize alt, we may choose x to be strictly a 1 a 2 ā2 a 3 ā2 ā3 a 1 ā1 ā1 ā2 k by first setting each unsigned position of C(p + 1) to b , then p tob , and then the remaining position of C(p -1) to b , if it exists. Thus, h(x b k ) = h(x b k-1 ), contradicting (c). There are n -1 pairs of neighboring endpoints, i.e., in total 2n -2 internal endpoints.</p><p>x + m-n and x - m-n each have n unsigned positions, of which, by Property 1, at least n -1 are internal endpoints. Property 2 implies that the only unsigned position that is not an internal endpoint, if one exists, is 1 or m. Thus, U consists solely of endpoints of the s j 's. However, all symbols of Σ n are distributed at the positions in U . Hence, (s 1 , . . . , s n ) is such that every pair of compatible letters of Σ n can be reduced. This concludes the proof of Proposition 3.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>• |unb(x)| |unb(y)| &gt; 0 for every x y if unb(x) = 0. Notice that |unb(x)| = |unb(y)| implies unb(x) = unb(y) for every x y. Finally we define λ as the function from O m to {-m + 1, . . . , 0, . . . , m -1}: λ(x) = ß sign(x) alt(x) when alt(x) &gt; n . unb(x) when alt(x) n .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure1. A word s 1 s 2 s 3 , a decomposition x with the corresponding alignment of s j 's to u p 's (in particular, u 3 = ε), and the calculation of alt(x).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Lemma 1. Lastly, we present a direct combinatorial proof of Lemma 1 that avoids Theorem 2. The method is again inspired by Pálvőlgyi<ref type="bibr" target="#b16">[Pál09]</ref>, but instead of constructing a function λ that contradicts the Tucker lemma, if it has no zero, we construct a pair of functions λ + and λ -, for which the chains guaranteed by the Ky Fan lemma cannot exist for irreducible tuples.In contrast to Section 5.2, we do not consider x ∈ B m to represent the decomposition of a single string but instead x shall represent the decomposition of an irreducible tuple (s 1 , . . . , s n ) in (Σ + n ) n where the word s 1 • • • s n is in O n and each s j is of length at least 2. To account for the arity of the tuple, we need to generalize the notion of alt. Denote the word s 1 • • • s n by s and the length of s by m. Factorize x such that</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Technische Universität Dresden, Germany, kilian@gebhardt.xyz.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>CERMICS, École des Ponts ParisTech, France, frederic.meunier@enpc.fr.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Université de Lille, INRIA, CRIStAL, France, sylvain.salvati@univ-lille.fr. 1</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_3"><p>An alternative purely combinatorial proof is presented in Section 5.2.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_4"><p>In essence, this is the reason why Ho<ref type="bibr" target="#b8">[Ho18]</ref> could only show that O n is an 8 n+1 2 -2 -MCFL.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(ii) The left-most bead of s 1 is a positive bead of type 1 and the right-most bead of s n is a positive bead of type n. The condition of the theorem ensures that neither s 1 nor s n are empty. Consider the "big" necklace s = s 1 s2 s 3 s4 • • • . If n is even, the big necklace s ends with s n , and if n is odd, it ends with s n . (Given a sequence t of beads, the notation t means t where all positive beads become negative and conversely, without changing their types.) According to Proposition 2, there is a splitting of s into n + 1 subnecklaces t 1 , . . . , t n+1 (completing with zero-length subnecklaces if necessary) such that we have for i ∈ [n] in Case (i) and for i ∈ {2, . . . , n -1} in Case (ii)</p><p>and such that in Case (ii)</p><p>Here, we denote by µ i (t) the amount of beads of type i in the subnecklace t. We remind the reader that the amount of beads is the number of positive beads minus the number of negative beads of this type.</p><p>We interpret now the endpoints of the subnecklaces t k as cuts of the "big" necklace s (the one formed by the original necklaces s j ). Together with the endpoints of the s j , we get a splitting of s into 2n subnecklaces u 1 , . . . , u 2n (in this order). Some u can be zero-length subnecklaces. We make two parts: a part A formed by the u with an odd , and a part B formed by the u with an even . Remark two things:</p><p>• Since the left-most bead of s 1 belongs to u 1 and the right-most bead of s n belongs to u 2n , each part contains at least one bead. • The number of subnecklaces u is the same in each part, and thus equal to n. We finish the proof by checking that both A and B are balanced. We denote by q A i and q B i the amount of beads of type i in A and B, respectively. Since the original collection is balanced, we have q A i + q B i = 0. The end of the proof consists simply in checking that we have also q A i -q B i = 0, which implies then immediately that q A i = q B i = 0, as desired. Each bead x belongs to exactly one s j . Moreover, apart from the two beads at the endpoints of s, any bead x (resp. x) belongs also to exactly one t k when j is odd (resp. even). It is immediate to check that j + k -1 and the index of the u to which x belongs have the same parity. Thus if j + k -1 is odd, then x belongs to A, and if it is even, then x belongs to B. We have</p><p>and for i = 1, we have</p><p>alternating except for the n -1 transitions between neighboring endpoints. In consequence alt(x) m -(n -1) + 2(n -1) -1 = m + n -2. Figure <ref type="figure">1</ref> gives an example: Note that alt(x) &lt; 2 • 3 and that the subwords in +labeled and --labeled positions are both in O 3 . Thus, x describes the decomposition of (a 1 a 2 ā2 a 3 , ā2 ā3 a 1 , ā1 ā1 ā2 ) to two strictly smaller 3-tuples (a 1 , ε, ā1 ) and (a 2 ā2 a 3 , ā2 ā3 a 1 , ā1 ā2 ), for each of which the word obtained by concatenating the tuple's components is in O 3 .</p><p>Again, we consider words in O m \ 0 m which may have unsigned positions, i.e., positions labeled with 0. In this case the decomposition is only partially determined. We define the function h :</p><p>Denote by H(x) the set arg max y∈B m : x y alt(y). All elements of H(x) may be obtained with the following algorithm:</p><p>(i) Choose a signed position p in x with an unsigned neighbor p ∈ {p -1, p + 1}.</p><p>(ii) If p and p are neighboring endpoints (in this case we call p and p internal endpoints), set x (p ) = x(p); otherwise set x (p ) = -x(p). For each q = p , set x (q) = x(q). (iii) If x ∈ B m we are done, otherwise, recursively apply the algorithm to x . This algorithm may yield words y, y where y(p) = y (p) if p is an unsigned position between two signed positions of x. However, for all position p smaller than the smallest signed position of x, the signs y(p ) and y (p ) are equal for all words y, y in H(x). Hence, we may define a function sign : O m \ 0 m → B to assign to x the first symbol of some y ∈ H(x). Moreover, for each x ∈ O m \ 0 m : sign(x) = -sign(-x).</p><p>To prove Lemma 1, we need to show that there is x ∈ B m with alt(x) &lt; 2n and that both words u 1 u 3 • • • and u 2 u 4 • • • described by x are in O n and non-empty. To assure non-emptiness, we just need that both signs occur in x. To ensure that the words are in O n , we rephrase the notions E κ,i and unb from Section 5.2 in terms of tuples of words instead of necklaces. Now E κ,i (x) is formulated as the difference of the amount of a i 's and āi 's aligned with κ in x. Formally:</p><p>Observe that E +,i (x) + E -,i (x) = 0 for s ∈ O n and x ∈ B m . We define two functions λ + and λ -, where for each b ∈ B,</p><p>If there are x ∈ O m \ 0 m and b ∈ B such that λ b (x) = 0, then Lemma 1 holds: Note that case C3 of λ b applies. Thus, for each i ∈ [n] there is y ∈ B m such that E +,i (y) = E -,i (y) = 0. The positions relevant to balance a i and a j where i = j are distinct. Hence, we choose ŷ ∈ B m with x ŷ such that all symbols are balanced. Since ŷ x we have that alt(ŷ) h(x) &lt; 2n, |ŷ| + &gt; 0, and |ŷ| -&gt; 0. Thus, ŷ encodes a decomposition with the desired properties. Otherwise, if λ + and λ -have no zero, we want to apply the Ky Fan lemma. Clearly, λ b satisfies property (i) of the octahedral Ky Fan lemma if cases C1 and C3 apply. For case C2, note that |x| Proposition 3. If λ + and λ -have no zero, then every pair of compatible symbols a i , āi ∈ Σ n can be reduced from (s 1 , . . . , s n ).</p><p>Lemma 1 follows directly, as whenever (s 1 , . . . , s n ) is irreducible, λ + and λ -have a zero.</p><p>To show Proposition 3 assume that for either b ∈ B there is no x ∈ O m \ 0 m such that λ b (x) = 0. By Lemma 2, for each b ∈ B, there is a positively alternating m-chain, i.e., there are </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Algorithmic construction of sets for k-restrictions</title>
		<author>
			<persName><forename type="first">Noga</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><surname>Moshkovitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shmuel</forename><surname>Safra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Algorithms (TALG)</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="153" to="177" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Borsuk-Ulam theorem and bisection of necklaces</title>
		<author>
			<persName><forename type="first">Noga</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Douglas</forename><forename type="middle">B</forename><surname>West</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="623" to="628" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Discontinuous constituents in generalized categorial grammars</title>
		<author>
			<persName><forename type="first">Emmon</forename><surname>Bach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Annual Meeting of the Northeastern Linguistics Society</title>
		<editor>
			<persName><forename type="first">Victoria</forename><surname>Burke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">James</forename><surname>Pustejovsky</surname></persName>
		</editor>
		<meeting>the 11th Annual Meeting of the Northeastern Linguistics Society</meeting>
		<imprint>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Categorial grammars as theories of language</title>
		<author>
			<persName><forename type="first">Emmon</forename><surname>Bach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Categorial Grammars and Natural Language Structures</title>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Oehrle</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Emmon</forename><surname>Bach</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Deirdre</forename><surname>Wheeler</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="17" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Reidel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A new coloring theorem of Kneser graphs</title>
		<author>
			<persName><forename type="first">Peng-An</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Combinatorial Theory, Series A</title>
		<imprint>
			<biblScope unit="volume">118</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1062" to="1071" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A generalization of Tucker&apos;s combinatorial lemma with topological applications</title>
		<author>
			<persName><forename type="first">Fan</forename><surname>Ky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="431" to="437" />
			<date type="published" when="1952">1952</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Formal languages and their application to combinatorial group theory</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Gilman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Groups, Languages, Algorithms</title>
		<title level="s">Contemporary Mathematics</title>
		<imprint>
			<publisher>Amer. Math. Soc</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">378</biblScope>
			<biblScope unit="page" from="1" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The word problem of Z n is a multiple context-free language</title>
		<author>
			<persName><forename type="first">Meng-Che</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Groups Complexity Cryptology</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="15" />
			<date type="published" when="2018-05-01">01 May. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A moment problem in l 1 approximation</title>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">R</forename><surname>Hobby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">R</forename><surname>Rice</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="665" to="670" />
			<date type="published" when="1965">1965</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Tree-adjoining grammars: How much context sensitivity is required to provide reasonable structural descriptions</title>
		<author>
			<persName><forename type="first">K</forename><surname>Aravind</surname></persName>
		</author>
		<author>
			<persName><surname>Joshi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Natural Language Parsing</title>
		<editor>
			<persName><forename type="first">David</forename><surname>Dowty</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lauri</forename><surname>Karttunen</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Arnold</forename><forename type="middle">M</forename><surname>Zwicky</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="206" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The converence of mildly context-sensitive grammar formalisms</title>
		<author>
			<persName><forename type="first">K</forename><surname>Aravind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><forename type="middle">K</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Shanker</surname></persName>
		</author>
		<author>
			<persName><surname>Weir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundational Issues in Natural Language Processing</title>
		<editor>
			<persName><forename type="first">Peter</forename><surname>Sells</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stuart</forename><forename type="middle">M</forename><surname>Shieber</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Wasow</surname></persName>
		</editor>
		<imprint>
			<publisher>The MIT Press</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="31" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">MIX is not a tree-adjoining language</title>
		<author>
			<persName><forename type="first">Makoto</forename><surname>Kanazawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sylvain</forename><surname>Salvati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 50th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="666" to="674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Groups, the theory of ends, and context-free languages</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">E</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">E</forename><surname>Schupp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="295" to="310" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A short proof that O 2 is an MCFL</title>
		<author>
			<persName><forename type="first">Mark-Jan</forename><surname>Nederhof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Free word order and MCFLs</title>
		<author>
			<persName><forename type="first">Mark-Jan</forename><surname>Nederhof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">From Semantics to Dialectometry: Festschrift for John Nerbonne</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Wieling</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Kroon</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Van Noord</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Bouma</surname></persName>
		</editor>
		<imprint>
			<publisher>College Publications</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="273" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Combinatorial necklace splitting</title>
		<author>
			<persName><forename type="first">Dömötör</forename><surname>Pálvölgyi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Electronic Journal of Combinatorics</title>
		<imprint>
			<biblScope unit="page" from="79" to="R79" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A simple proof of the Hobby-Rice theorem</title>
		<author>
			<persName><forename type="first">Allan</forename><surname>Pinkus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="82" to="84" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Context-freeness and the computer processing of human languages</title>
		<author>
			<persName><forename type="first">Geoffrey</forename><forename type="middle">K</forename><surname>Pullum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 21st Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">MIX is a 2-MCFL and the word problem in is captured by the IO and the OI hierarchies</title>
		<author>
			<persName><forename type="first">Sylvain</forename><surname>Salvati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1252" to="1277" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the generative power of multiple context-free grammars and macro grammars</title>
		<author>
			<persName><forename type="first">Hiroyuki</forename><surname>Seki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuki</forename><surname>Kato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Transactions</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="209" to="221" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On multiple context free grammars</title>
		<author>
			<persName><forename type="first">Hiroyuki</forename><surname>Seki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takashi</forename><surname>Matsumura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mamoru</forename><surname>Fujii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tadao</forename><surname>Kasami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="191" to="229" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Some topological properties of disk and sphere</title>
		<author>
			<persName><forename type="first">Albert</forename><forename type="middle">W</forename><surname>Tucker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. First Canadian Math. Congress 1945</title>
		<meeting>First Canadian Math. Congress 1945<address><addrLine>Montreal</addrLine></address></meeting>
		<imprint>
			<publisher>University of Toronto Press</publisher>
			<date type="published" when="1946">1946</date>
			<biblScope unit="page" from="285" to="309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Characterizing mildly context-sensitive grammar formalisms</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">J</forename><surname>Weir</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>Philadephia, PA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
