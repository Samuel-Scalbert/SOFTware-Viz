<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Normalisations of Existential Rules: Not so Innocuous!</title>
				<funder ref="#_HYnYZWb">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<email>david.carral@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lucas</forename><surname>Larroque</surname></persName>
							<email>lucas.larroque@ens.psl.eu</email>
							<affiliation key="aff1">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<email>mugnier@lirmm.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
							<email>michael.thomazo@inria.fr</email>
							<affiliation key="aff2">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">ENS</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">PSL University</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Normalisations of Existential Rules: Not so Innocuous!</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">88035124412E65F73DAC88251847A202</idno>
					<idno type="DOI">10.24963/kr.2022/11</idno>
					<note type="submission">Submitted on 28 Aug 2022</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Existential rules are an expressive knowledge representation language mainly developed to query data <ref type="bibr" target="#b0">(Baget et al. 2009;</ref><ref type="bibr" target="#b6">Calì, Gottlob, and Lukasiewicz 2009)</ref>. Such rules are an extension of first-order function-free Horn rules (like those of Datalog) with existentially quantified variables in the rule heads, which allows to infer the existence of unknown individuals.</p><p>Querying a knowledge base (KB) K = R, F , where R is a set of existential rules and F a set of facts, consists in computing all the answers to queries that are logically entailed from K. Two main techniques have been developed, particularly in the context of the fundamental (Boolean) conjunctive queries. The chase is a bottom-up process that expands F by rule applications from R towards a fixpoint. It produces a universal model of K, i.e., a model of K that homomorphically maps to all models of K, which is therefore sufficient to decide query entailment. Query rewriting is a dual technique, which consists in rewriting a query q with the rules in R into a query q such that q is entailed by K if and only if q is entailed by F solely.</p><p>Conjunctive query answering being undecidable for existential rules <ref type="bibr" target="#b2">(Beeri and Vardi 1981)</ref>, both the chase and query rewriting may not terminate. There is however a wide range of rule subclasses defined by syntactic restrictions that ensure chase termination on any set of facts (see, e.g., various acyclicity notions in <ref type="bibr" target="#b15">(Grau et al. 2013</ref>)) or the existence, * Our work started when Lucas was intern at LIRMM-Inria.</p><p>for any conjunctive query, of a (finite) rewriting into a firstorder query, a property referred to as <ref type="bibr">FO-rewritability (Calvanese et al. 2007</ref>).</p><p>In the literature, existential rules are often supposed to be in some normal form that simplifies technical developments. For instance, a common assumption is that rule heads are atomic, i.e., restricted to a single atom. On the one hand, the use of single-head rules greatly simplifies the presentation of theoretical arguments (e.g., <ref type="bibr" target="#b7">(Calì, Gottlob, and Pieris 2012)</ref>). On the other hand, this restriction may also simplify implementations; e.g., the optimisation procedure presented in <ref type="bibr" target="#b22">(Tsamoura et al. 2021</ref>) exploits single-head rules to clearly establish the provenance of each fact computed during the chase. Moreover, after normalisation, we can apply existing methods to effectively determine if the chase terminates for an input single-head existential rule set if this set is linear <ref type="bibr" target="#b18">(Leclère et al. 2019)</ref> or guarded <ref type="bibr" target="#b12">(Gogacz, Marcinkowski, and Pieris 2020)</ref>. Normal form assumptions are often made without loss of generality as long as all sets of rules can be normalised while preserving all interesting entailments. However, an important question is whether the properties that ensure the decidability of reasoning are preserved as well. In particular, what is the impact of common normalisation procedures on fundamental properties like chase termination or FO-rewritability?</p><p>In fact, the chase is a family of algorithms, which differ from each other in their termination properties. Here, we consider the four main chase variants, namely: the oblivious chase <ref type="bibr">(Calì, Gottlob, and Kifer 2008a)</ref>, the semi-oblivious (aka skolem) chase <ref type="bibr" target="#b19">(Marnette 2009)</ref>, the restricted (aka standard) chase <ref type="bibr" target="#b11">(Fagin et al. 2003</ref>) and the core chase <ref type="bibr" target="#b10">(Deutsch, Nash, and Remmel 2008)</ref>. As the core chase has the inconvenience of being non-monotonic (i.e., the produced set of facts does not grow monotonically), we actually study a monotonic variant that behaves similarly regarding termination, namely the equivalent chase <ref type="bibr" target="#b20">(Rocher 2016)</ref>. The ability of a chase variant to halt on a given KB is directly related to its power of reducing logical redundancies introduced by rules. The oblivious chase blindly performs all possible rule applications, while the equivalent chase terminates exactly when the KB admits a finite universal model. The other variants lie between these two extremes. For practical efficiency reasons, the most implemented variant is the restricted chase. However, it is the only variant sensitive to the order of rule applications: for a given KB, there may be sequences of rule applications that terminate, while others do not. We study a natural strategy, called Datalog-first restricted chase, which prioritises Datalog rules (whose head does not include existential quantifiers) thus achieving termination in many real-world cases <ref type="bibr" target="#b9">(Carral, Dragoste, and Krötzsch 2017)</ref>. Moreover, experiments have shown that it is indeed a very efficient strategy <ref type="bibr" target="#b23">(Urbani et al. 2018</ref>).</p><formula xml:id="formula_0">O SO ∃-R ∀-R ∃-DF-R ∀-DF-R E Single-Piece = + = = = = = One-Way = = -- - - - Two-Way = = + - = = =</formula><p>On the other hand, we consider two well-known normalisation procedures of a set of rules: single-piecedecomposition, which breaks rule heads into subsets called pieces and outputs a logically equivalent rule set <ref type="bibr" target="#b1">(Baget et al. 2011;</ref><ref type="bibr" target="#b16">König et al. 2013)</ref>; and atomic-decomposition, which requires to introduce fresh predicates and outputs a set of atomic-head rules that form a conservative extension of the original set, hence preserve entailment <ref type="bibr">(Calì, Gottlob, and Kifer 2008b;</ref><ref type="bibr" target="#b7">Calì, Gottlob, and Pieris 2012)</ref>.</p><p>Contributions. We provide a systematic study of the impact of these procedures on the different chase variants with respect to chase (non-)termination and FO-rewritability. This also leads us to solve some open problems related to chase termination, which are of independent interest.</p><p>Although the relationships between most chase variants with respect to chase termination are well understood <ref type="bibr" target="#b14">(Grahne and Onet 2018)</ref>, the question remained open regarding the restricted chase and its Datalog-first version. Unexpectedly, we found that Datalog-first strategies are not always optimal: we exhibit a rule set R such that the restricted chase has a terminating sequence on any KB R, F but there is a KB R, F on which no Datalog-first strategy terminates (Section 3).</p><p>While it appears that none of the considered decompositions influences FO-rewritability, the situation is very different concerning chase termination, as summarized in Table 1. Note that we distinguish between two behaviors for restricted chases: ∃ means that at least one chase sequence terminates on any KB ("sometimes-termination") and ∀ that all sequences terminate on any KB ("termination"). Single-piece-decomposition (Section 4) has no impact on the oblivious and equivalent chases (noted =), a positive impact on the semi-oblivious chase (noted +), and an erratic impact on (Datalog-first-)restricted chase (noted =). The standard atomic-decomposition (Section 5), called oneway in the table, has a negative impact on all chase variants, except for the (semi-)oblivious ones. Looking for a wellbehaved atomic-decomposition procedure, we study a new one, named two-way (Section 6). A salient property of this decomposition is that it preserves the existence of a finite universal model. As shown in the table, two-way behaves better than one-way: it preserves (sometimes-)termination of the Datalog-first restricted chase and may even improve the sometimes-termination of the restricted chase. However, the negative impact on the termination of the restricted chase remains. These findings led us to an intriguing question: does a computable normalisation procedure exist that produces atomic-head rules and exactly preserves the termination of the restricted chase? We show that the answer is negative by a complexity argument (Section 7). More specifically, we study the decidability status of the following problem: Given a KB K = R, F , does the restricted chase terminate on K? We show that the associated membership problem is at least at the second level of the arithmetical hierarchy (precisely Π 0 2 -hard) when there is no restriction on R, while it is recursively enumerable (in Σ 0 1 ) when R is a set of atomic-head rules. Since Σ 0 1 Π 0 2 , we obtain the negative answer to our question.</p><p>The complete proofs for all of the results in this paper can be found on an arXiv submission with the same name.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>First-Order Logic (FOL) We define Preds, Cons, and Vars to be mutually disjoint, countably infinite sets of predicates, constants, and variables, respectively. Every P ∈ Preds has an arity ar(P ) ≥ 0. Let Terms = Cons ∪ Vars be the set of terms. We write lists t 1 , . . . , t n of terms as t and often treat them as sets. For a formula or set thereof U , let Preds(U ), Cons(U ), Vars(U ), and Terms(U ) be the sets of all predicates, constants, variables, and terms that occur in U , respectively.</p><p>An atom is a FOL formula P ( t) with P a | t|-ary predicate and t ∈ Terms. For a formula U , we write U [ x] to indicate that x is the set of all free variables that occur in U . Definition 1. An (existential) rule R is a FOL formula</p><formula xml:id="formula_1">∀ x∀ y. B[ x, y] → ∃ z.H[ x, z]<label>(1)</label></formula><p>where x, y, and z are pairwise disjoint lists of variables; and B and H are (finite) non-empty conjunctions of atoms, called the body and the head of R, respectively. The set x is the frontier of R. If z is empty, then R is a Datalog rule. Next, we often denote a rule such as R above by B → H or B → ∃ z.H, omitting all or some quantifiers.</p><p>A factbase F is an existentially closed (finite) conjunction of atoms. A Boolean conjunctive query (BCQ) has the same form as a factbase, and we often identify both notions.A knowledge base (KB) K is a tuple R, F with R a rule set and F a factbase. We often identify rule bodies, rule heads, and factbases with (finite) sets of atoms.</p><p>Given atom sets F and F , a homomorphism π from F to F is a function with domain Vars(F ) such that π(F ) ⊆ F ; π is an isomorphism from F to F if additionally, π is injective and π -1 is a homomorphism from F to F . A homomorphism π from F to F is a retraction if π is the identity over Vars(F ) ∩ Vars(F ) (next, we often use this notion with F ⊆ F ).</p><p>We identify logical interpretations with atom sets. An atom set F satisfies a rule R = B → H if, for every homomorphism π from B to F , there is an extension π of π with π(H) ⊆ F ; equivalently, F is a model of R. An atom set M is a model of a factbase F if there is a homomorphism from F to M, and it is a model of a KB R, F if it is a model of F and satisfies all rules in R. Given KBs or atom sets A and B, A entails B, written A |= B, if every model of A is a model of B; A and B are equivalent if A |= B and B |= A. Given atom sets F and F , it is known that F |= F iff there is a homomorphism from F to F . Definition 2. A model M of a KB K is universal if there is a homomorphism from M to every model of K.</p><p>Every KB K admits some (possibly infinite) universal model. Hence, K |= Q for any BCQ Q iff there is a homomorphism from a universal model of K to Q. The BCQ entailment problem takes as input a KB K and a BCQ Q and asks if K |= Q; it is undecidable <ref type="bibr" target="#b2">(Beeri and Vardi 1981)</ref>.</p><p>Next, we will consider transformations of rule sets that introduce fresh predicates. To specify the relationships between a rule set and its decomposition, we will rely on the notion of conservative extension: <ref type="figure"></ref>and<ref type="figure"></ref> (2) any model M of R can be extended to a model M of R that has the same domain (i.e., Terms(M) = Terms(M )) and agrees with M on the interpretation of the predicates in Preds(R) (i.e., they have the same atoms with predicates in Preds(R)).</p><formula xml:id="formula_2">Definition 3 (Conservative extension). Let R and R be two rule sets such that Preds(R) ⊆ Preds(R ). The set R is a conservative extension of the set R if (1) the restriction of any model of R to the predicates in Preds(R) is a model of R,</formula><p>When R is a conservative extension of R, for any factbase F the KBs R, F and R , F entail the same (closed) formulas on Preds(R), in particular BCQs.</p><p>The chase The chase is a family of procedures that repeatedly apply rules to a factbase until a fixpoint is reached. We formally define such procedures before stating their correctness with respect to factbase entailment in Proposition 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4 (Triggers and derivations</head><formula xml:id="formula_3">). Given a fact set F , a trigger t on F is a tuple R, π with R = B → ∃ z.H a rule and π a homomorphism from B to F . Let support(t) = π(B) and output(t) = π R (H)</formula><p>, where π R is the extension of π that maps every variable z ∈ z to the fresh variable z t that is unique for z and t.</p><formula xml:id="formula_4">A derivation from a KB K = R, F is a sequence D = (∅, F 0 ), (t 1 , F 1 ), . . . such that: 1. Every F i in D is a factbase; moreover, F 0 = F . 2. Every t i in D is a trigger R, π on F i-1 such that R ∈ R, output(t i ) ⊆ F i-1 , and F i = F i-1 ∪ output(t i ).</formula><p>The result of D, written res(D), is the union of all the factbases in D. Let triggers(D) be the set of all triggers in D and length(D) = |triggers(D)| be the length of D.</p><p>Different chase variants build specific derivations according to different criteria of trigger applicability. Below, the letters O, SO, R, and E respectively refer to so-called oblivious, semi-oblivious, restricted, and equivalent<ref type="foot" target="#foot_0">1</ref> variants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5 (Applicability). A trigger</head><formula xml:id="formula_5">t = R, π on a fact- base F is (i) O-applicable on F if output(t) ⊆ F , (ii) SO-applicable on F if output(t ) ⊆ F for every trigger t = (R, π ) with π(x) = π (x) for all x ∈ fr(R), (iii) R- applicable on F if there is no retraction from F ∪ output(t)</formula><p>to F , and (iv) E-applicable on F if there is no homomorphism from F ∪ output(t) to F . Example 1. Consider the KB K = R, F with R = {R = P (x, y) → ∃z.P (y, z) ∧ P (z, y)} and F = {P (a, b)} with a and b some constants. The trigger t 1 = (R, π 1 ) with π 1 = {x → a, y → b} is X-applicable on F 0 = F (for any X), and output(t 1 ) = {P (b, z t1 ), P (z t1 , b)}. There are two new triggers on</p><formula xml:id="formula_6">F 1 = F ∪ output(t 1 ), both O-and SO- applicable, but neither R-nor E-applicable. For instance, consider t 2 = (R, π 2 ) with π 2 = {x → b, y → z t1 } and output(t 2 ) = {P (z t1 , z t2 ), P (z t2 , z t1 )}: there is a retrac- tion from F 1 ∪ output(t 2 ) to F 1 , which maps z t2 to b. Definition 6 ((DF-)X-Chase). For an X ∈ {O, SO, R, E}, an X-derivation from a KB K = R, F is a derivation D such that every trigger t i ∈ triggers(D) is X-applicable on F i ; D is a DF-X-derivation if it gives priority to Datalog rules: for any t i = R, π ∈ triggers(D), if R is a non- Datalog rule, then F i-1 satisfies every Datalog rule in R. A (DF-)X-derivation D is fair if for every F i occurring in D and trigger t X-applicable on F i , there is some j &gt; i such that t is not X-applicable on F j . A (DF-)X-derivation is terminating if it is fair and finite.</formula><p>The result of any fair X-derivation is a universal model of the KB, for X ∈ {O, SO, R}, and has a retraction to a universal model for X = E. Therefore, we obtain: Proposition 7. Consider a BCQ Q, a KB K, and some fair X-derivation D from K where X ∈ {Y, DF-Y} and Y ∈ {O, SO, R, E}. Then, K |= Q iff res(D) |= Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Decidable Classes of Rule Sets</head><p>We now define classes of rule sets that ensure the decidability of BCQ entailment, based either on chase termination or on query rewritability. Definition 8 (Chase-Terminating Sets). For a Y ∈ {O, SO, R, E} and an X ∈ {Y, DF-Y}, let CT X ∀∀ (resp. CT X ∀∃ ) be the set of all rule sets R such that every (resp. some) fair X-derivation from every KB R, F is finite.</p><formula xml:id="formula_7">When R ∈ CT X ∀∀ (resp. CT X ∀∃ ), R ensures the termina- tion (resp. sometimes termination) of the X-chase. Example 2. Consider the KB K = R, F from Example 1. All fair O-or SO-derivations from K are infinite. The only one fair R-derivation (resp. E-derivation) from K is D = (∅, F 0 ), (t 1 , F 1 ). Any fair R-derivation from a KB with R is finite and hence, R ∈ CT R ∀∀ (and R ∈ CT E ∀∀ ). Definition 9 (FO-rewritability). A rule set R is FO- rewritable if for any BCQ Q, there is a (finite) BCQ set {Q 1 , . . . , Q n } such that, for every factbase F , R, F |= Q iff F |= Q i for some 1 ≤ i ≤ n.</formula><p>In our proofs, we rely on a property equivalent to FOrewritability: the bounded derivation depth property, which has the advantage of being based on (a breadth-first version of) the chase <ref type="bibr" target="#b6">(Calì, Gottlob, and Lukasiewicz 2009)</ref>. See <ref type="bibr" target="#b13">(Gottlob et al. 2014</ref>) about the equivalence between both properties. Definition 10 (BDDP). For a rule R and a factbase F , let R(F ) ⊇ F be the minimal factbase that includes output(t) for every trigger t with R. For a rule set R, let</p><formula xml:id="formula_8">R(F ) = R∈R R(F ). For a KB K = R, F , let Ch 0 (K) = F and Ch i (K) = R(Ch i-1 (K)) for every i ≥ 1.</formula><p>A rule set R has the bounded derivation depth property (BDDP) if, for any BCQ Q, there is some k ≥ 0 such that, for every factbase</p><formula xml:id="formula_9">F , R, F |= Q iff Ch k ( R, F ) |= Q.</formula><p>Normalisation Procedures Finally, we formally define normalisation procedures and their impact on the above properties. A normalisation procedure is a function f that maps rule sets to rule sets (complying with a certain shape) such that for any rule set R, R,</p><formula xml:id="formula_10">F |= Q iff f (R), F |= Q for any factbase F and BCQ Q on Preds(R). Definition 11. Consider some X ∈ {O, SO, R, DF-R, E}. Then, a normalisation procedure f : • Preserves termination of the X-chase if f (CT X ∀∀ ) ⊆ CT X ∀∀ ; it preserves sometimes-termination of the X-chase if f (CT X ∀∃ ) ⊆ CT X ∀∃ . • Preserves non-termination of the X-chase if f (CT X ∀∀ ) ⊆ CT X</formula><p>∀∀ . Otherwise, f may gain termination. • Preserves rewritability if it maps FO-rewritable rule sets to FO-rewritable rule sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Generality of Chase-Terminating Rule Sets</head><p>One of our goals is to study normalisation procedures that preserve membership over the sets of chase-terminating rule sets from Definition 8. To be systematic, we clarify the equality and strict-subset relations between these sets in Theorems 12 and 13, respectively. Grahne and Onet already proved most of the claims in these theorems (see Theorem 4.5, Propositions 4.6 and 4.7, and Corollary 4.8 in (Grahne and Onet 2018)); we reprove some of them again to be self-contained. However, note that all results regarding Datalog-first chase variants are our own contribution. Theorem 12. For every X ∈ {O, SO, E}, we have that</p><formula xml:id="formula_11">CT X ∀∀ = CT X ∀∃ = CT DF-X ∀∀ = CT DF-X ∀∃ Sketch.</formula><p>To show that the theorem holds if X = O (resp. X = SO), it suffices to prove that all fair X-derivations from an input KB K produce the same result (resp. same result up to isomorphism); see forthcoming Lemma 16.</p><p>All fair E-derivations from an input KB K are finite iff K admits a finite universal model <ref type="bibr" target="#b20">(Rocher 2016)</ref>. Hence, the theorem holds if X = E. The equalities in Theorem 12 simplify our work: for instance, if a function preserves termination of the oblivious chase, then we know that it also preserves sometimestermination of this variant. Alas, the remaining sets of chase-terminating rule sets are not equal: Theorem 13. The following hold:</p><formula xml:id="formula_12">a : A A A A R, S R, S R, S R, S S S S</formula><formula xml:id="formula_13">CT O ∀∀ ⊂ CT SO ∀∀ ⊂ CT R ∀∀ ⊂ CT DF-R ∀∀ ⊂ CT DF-R ∀∃ ⊂ CT R ∀∃ ⊂ CT E ∀∀ Sketch.</formula><p>The subset inclusions follow by definition; we present some rule sets to show that these are strict:</p><formula xml:id="formula_14">{P (x, y) → ∃z.P (x, z)} ∈ CT SO ∀∀ \ CT O ∀∀ {P (x, y) → ∃z.P (y, z) ∧ P (z, y)} ∈ CT R ∀∀ \ CT SO ∀∀ {P (x, y) → ∃z.P (y, z), P (x, y) → P (y, x)} ∈ CT DF-R ∀∀ \ CT R ∀∀ {P (x, y) → ∃z.P (y, z) ∧ P (z, y), P (x, y) → ∃z.P (y, z)} ∈ CT DF-R ∀∃ \ CT DF-R ∀∀ {P (x, y) → ∃z.P (y, z), P (x, y) ∧ P (y, z) → P (y, x)} ∈ CT E ∀∀ \ CT R ∀∃ Moreover, the rule set R = {(2-6)} is in CT R ∀∃ \ CT DF-R ∀∃ : A(x) → R(x, x) (2) R(x, y) ∧ S(y, z) → S(x, x) (3) A(x) ∧ S(x, y) → A(y) (4) A(x) → ∃z.R(x, z) (5) R(x, y) → ∃z.S(y, z)<label>(6)</label></formula><p>To show that R / ∈ CT DF-R ∀∃ we prove that the KB K = R, {A(a)} does not admit terminating DF-R-derivations. Specifically, all fair DF-R-derivations from K yield the same result, which is depicted in Figure <ref type="figure" target="#fig_0">1</ref>. Rule (2) is applied first, then the following pattern is repeated: apply rule (6) followed by Datalog rules (3), ( <ref type="formula">4</ref>) and (2). Rule ( <ref type="formula">5</ref>) is never applicable since priority is given to rule (2). To show that R ∈ CT R ∀∃ we verify that every KB of the form R, F admits a terminating R-derivation. We can produce such a derivation by exhaustively applying the rules in R in the following order:<ref type="foot" target="#foot_1">2</ref> first, apply rules (4), ( <ref type="formula">5</ref>) and (6); then, apply (3); finally, apply (2).</p><p>Our main achievement is showing that CT R ∀∃ \ CT DF-R ∀∃ is non-empty; thus proving that Datalog-first strategies are not necessarily the most terminating for the restricted chase.</p><p>The single-piece decomposition (piece-decomposition in short) is a procedure that splits a rule R = B → ∃z.H into several rules R 1 , . . . , R n that have the same body as R, and whose head is a subset of H that (directly or indirectly) shares some existential variable in H. Definition 14. The piece graph of a rule R = B → ∃ z.H is the graph whose vertices are the atoms in H, and with an edge between a and a if z ∩ Vars(a) ∩ Vars(a ) is nonempty. A (rule) piece of R is the conjunction of atoms corresponding to a (connected) component of its piece graph.</p><p>The piece-decomposition of a rule</p><formula xml:id="formula_15">R = B → ∃ z.H is the rule set sp(R) = {B → ∃ v.H | H is a piece of R}. For a rule set R, let sp(R) = R∈R sp(R).</formula><p>Example 3. Consider the rule (7) and its single-piece decomposition sp(( <ref type="formula">7</ref>)) = {(8-10)}:</p><formula xml:id="formula_16">R(x, y) → ∃z, u.P (x, z) ∧ A(z) ∧ A(u) ∧ P (x, y) (7) R(x, y) → ∃z.P (x, z) ∧ A(z) (8) R(x, y) → ∃u.A(u) (9) R(x, y) → P (x, y)<label>(10)</label></formula><p>Piece-decomposition is indeed a normalisation procedure, since it preserves logical equivalence:</p><formula xml:id="formula_17">Proposition 15. A rule set R is equivalent to the set sp(R).</formula><p>The following lemma is later applied to show that the piece-decomposition preserves termination of the oblivious and semi-oblivious chase in Theorem 18: Definition 17. Given some X ∈ {O, SO} and a KB K, let Ch X (K) be some (arbitrarily chosen) atom set that is isomorphic to the result of all fair X-derivations from K.</p><p>Theorem 18. The piece-decomposition preserves the termination of the O-chase and SO-chase.</p><p>Sketch. Consider some X ∈ {O, SO} and some Xderivation D from a KB K = R, F . We can show via induction on D that there is an injective homomorphism from Ch X ( sp(R), F ) to Ch X (K). Therefore, finiteness of Ch X (K) implies finiteness of Ch X ( sp(R), F ).</p><p>The piece-decomposition does not preserve the termination of any restricted chase variant. The reason is that it allows for intertwining the application of split rules that come from different original rules, resulting in new application strategies that may lead to non-termination.</p><p>Theorem 19. The piece-decomposition does not preserve termination of the R-or the DF-R-chase.</p><p>Sketch. Consider the rule set R = {(11), (12)} and its piece-decomposition sp(R) = {(12-14)}: P (x, y) → P (y, y)∧A(y) (11)</p><p>A(x) → ∃z.P (x, z)</p><p>P (x, y) → P (y, y) (13) P (x, y) → A(y)</p><p>The set R is in CT R ∀∀ because triggers with (12) are not R-applicable to the output of triggers with (11). The set sp(R) is not in CT R ∀∀ because the KB sp(R), {A(a)} admits the following non-terminating Rderivation (∅, F 0 ), (t 1 , F 1 ), . . .:</p><formula xml:id="formula_20">F 0 = {A(a)}, F 1 = {P (a, z 1 )} ∪ F 0 , F 2 = {A(z 1 )} ∪ F 1 , F 3 = {P (z 1 , z 2 )} ∪ F 2 , F 4 = {P (z 1 , z 1 )} ∪ F 3 , F 5 = {A(z 2 )} ∪ F 4 , F 6 = {P (z 2 , z 3 )} ∪ F 5 , . . .</formula><p>This derivation is built by first applying rule (12) (leading to F 1 ), then indefinitely repeating the sequence of rule applications ( <ref type="formula" target="#formula_19">14</ref>), ( <ref type="formula" target="#formula_18">12</ref>), and (13). In contrast, the only fair Rderivation with R would apply ( <ref type="formula" target="#formula_18">12</ref>) then ( <ref type="formula">11</ref>), leading to {A(a), P (a, z 1 ), P (z 1 , z 1 ), A(z 1 )}.</p><p>To get a similar behavior with the DF-R chase, we introduce "dummy" existential variables in rules ( <ref type="formula">11</ref>) and ( <ref type="formula" target="#formula_18">12</ref>), so that their piece-decomposition has no Datalog rules:</p><formula xml:id="formula_21">P (x, y, v) → ∃u, w.P (y, y, u) ∧ A(y, w) (15) A(x, v) → ∃z, u.P (x, z, u)<label>(16)</label></formula><p>Applying analogous arguments we can show that R = {( <ref type="formula">15</ref>), (16)} is in CT DF-R ∀∀ and that sp(R ) is not.</p><p>Initially, we believed that the piece-decomposition would preserve sometimes-termination of the R-chase. Our intuition was that, given a terminating R-derivation from a KB K = R, F , we could replicate this derivation from sp(R), F by applying the split rules in sp(R) piece by piece. Surprisingly, this is not always possible: Theorem 20. The piece-decomposition does not preserve the sometimes-termination of the R-chase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sketch.</head><p>The following set R = {(17-22)} is in CT R ∀∃ and its piece-decomposition sp(R) = {(18-24)} is not. The set R is adapted from {(2-6)} (proof of Th. 13). Note that ( <ref type="formula">17</ref>) is split into two equivalent rules ( <ref type="formula">23</ref>) and (24). To show that sp(R) ∈ CT R ∀∃ , we start again from {A(a)}. Again, some R-atom is created and leads to apply other rules. With R, applying (17) then ( <ref type="formula">18</ref>) creates an atom of form R(y 1 , z 1 ), while with sp(R), applying (23) then ( <ref type="formula">18</ref>) creates an atom R(y 1 , y 1 ). This loop leads to non-termination.</p><formula xml:id="formula_22">A(x) → ∃y, z.U (x, y)∧H(y, x)∧U (x, z)∧H(z, x) (17) U (x, y) ∧ U (x, z) → R(y, z) (18) U (x, z) ∧ R(y, z) → ∃v.R(z, v) (19) R(x, y) ∧ R(y, z) → ∃v.S(z, v) (20) R(x, y) ∧ S(y, z) → S(x, x) (21) A(x) ∧ U (x, y) ∧ S(y, z) → ∃v.H(z, v) ∧ A(v) (22) A(x) → ∃y.U (x, y)∧H(y, x) (23) A(x) → ∃z.U (x, z)∧H(z, x)<label>(24)</label></formula><p>Theorem 21. The piece-decomposition does not preserve the sometimes-termination of the DF-R-chase.</p><p>Sketch. The set R = {(25-29)} is in CT DF-R ∀∃ while sp(R) = {(26-31)} is not. Note that the only difference with {(2-6)} is the atom H(x, y) in the first rule, making it non-Datalog, which prevents its early application.</p><formula xml:id="formula_23">A(x) → ∃y.R(x, x) ∧ H(x, y) (25) R(x, y) ∧ S(y, z) → S(x, x) (26) A(x) ∧ S(x, y) → A(y)<label>(27)</label></formula><p>A(x) → ∃y.R(x, y) (28) R(x, y) → ∃z.S(y, z) (29)</p><formula xml:id="formula_24">A(x) → R(x, x) (30) A(x) → ∃y.H(x, y) (31)</formula><p>Since piece-decomposition preserves logical equivalence (Proposition 15), one directly obtains that it preserves termination of the equivalent chase. Indeed, R, F admits a finite universal model iff sp(R), F admits one:</p><p>Theorem 22. The piece-decomposition preserves the termination of the E-chase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The piece-decomposition may gain termination:</head><p>Theorem 23. The piece-decomposition may gain termination (and sometimes-termination) of the SO-, the R-, and the DF-R-chase but not of the O-and E-chase. To show that the piece-decomposition preserves FOrewritability we show that it preserves the BDDP property.</p><formula xml:id="formula_25">Sketch. Consider the set R = {P (x, y) → ∃z.P (x, z) ∧ R(x, y)}, which is not in CT SO ∀∀ , CT R ∀∃ , CT R ∀∀ , CT DF-R ∀∃ , or CT DF-R ∀∀ . However, sp(R)</formula><formula xml:id="formula_26">Theorem 24. A rule set R is BDDP iff sp(R) is BDDP.</formula><p>Sketch. We can prove by induction that, for any KBs R, F and any i ≥ 1, the factbases Ch i ( R, F ) and Ch i ( sp(R), F ) are isomorphic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">One-Way Atomic Decomposition</head><p>Piece-decomposition may not produce atomic-head rules; a useful restriction considered in many contexts. The following procedure is classically used to produce such rules:</p><p>Definition 25. The one-way atomic decomposition of a rule R = B[ x, y] → ∃ z.H[ x, z] is the rule set 1ad(R) that contains the rule B → ∃ z.X R ( x, z) and, for each atom P ( t) ∈ H, the rule X R ( x, z) → P ( t), where X R is a fresh predicate unique for R, of arity</p><formula xml:id="formula_27">| x| + | z|. Given a rule set R, let 1ad(R) = R∈R 1ad(R).</formula><p>Example 4. Consider the rule (32) and its one-way atomic decomposition 1ad((32)) = {(33-35)}: R(x, y) → ∃z.P (x, z) ∧ S(x, y, z) (32) R(x, y) → ∃z.X (32) (x, y, z) (33) X (32) (x, y, z) → P (x, z) (34) X (32) (x, y, z) → S(x, y, z) (35)</p><p>Note that piece-decomposition would not decompose rule (32), i.e., sp(( <ref type="formula">32</ref>)) = {(32)}</p><p>Strictly speaking, R and 1ad(R) cannot be logically equivalent because they are built on different sets of predicates; however, it is straighforward to check that 1ad(R) is a conservative extension of R. Therefore, one-way atomic decomposition is indeed a normalisation procedure.</p><p>The following is a corollary of forthcoming Theorem 34: Theorem 26. The one-way atomic decomposition preserves termination of the O-and SO-chase.</p><p>An interesting phenomenon occurs with the one-way atomic decomposition: the notions of SO-applicability on R and R-applicability on 1ad(R) coincide:</p><p>Lemma 27. Consider a KB R, F and a finite derivation D = (∅, F 0 ), (t 1 , F 1 ), . . . , (t n , F n ) from 1ad(R), F . Then, a trigger t with a rule in 1ad</p><formula xml:id="formula_28">(R) is R-applicable on F n iff it is SO-applicable on F n . Proof. (⇒): from Definition 5. (⇐): Let t = (R, π) with R ∈ 1ad(R). If R is Datalog, the notions of SO-and R- applicability coincide for every factbase. Otherwise, R is of the form B[ x, y] → ∃ z.X R ( x, z) where X R ∈ Preds(R) and R ∈ R is of the form B[ x, y] → ∃ z.H[ x, z]. If t is SO- applicable on F n ,</formula><p>then, for every trigger t = (R, π ) with π( x) = π ( x), it holds that output(t ) ⊆ F n . By Definition 25, R is the only rule in 1ad(R) with X R in its head, hence π (X R ( x, z)) / ∈ F n for every extension π of π. Hence, t is R-applicable on F n .</p><p>Intuitively, Lemma 27 implies that, after applying the one-way atomic decomposition, R-applicability becomes as loose and unrestrictive as SO-applicability. Therefore: Theorem 28. The one-way atomic decomposition does not preserve termination nor sometimes-termination of the Ror the DF-R-chase.</p><p>Proof. By Theorem 13, there is a rule</p><formula xml:id="formula_29">set R / ∈ CT SO ∀∀ that is in CT R ∀∀ , CT DF-R ∀∀ , CT DF-R ∀∃ , and CT R ∀∃ . 3 By Theorem 26, 1ad(R) is not in CT SO ∀∀ ;</formula><p>that is, there is some KB K of the form 1ad(R), F that does not admit any terminating SOderivation. By Lemma 27, every terminating R-derivation from K is also a terminating SO-derivation from K. Therefore, K does not admit any terminating R-derivation, hence</p><formula xml:id="formula_30">1ad(R) is not in CT R ∀∀ , CT DF-R ∀∀ , CT DF-R ∀∃ , or CT R ∀∃ .</formula><p>Theorem 29. The one-way atomic decomposition does not preserve the termination of the E-chase.</p><p>Proof. Consider the rule set R = {(36)} (see also Example 1) and its decomposition 1ad(R) = {(37-39)}:</p><formula xml:id="formula_31">P (x, y) → ∃z. P (y, z) ∧ P (z, y) (36) P (x, y) → ∃z.X (36) (y, z) (37) X (36) (y, z) → P (y, z) (38) X (36) (y, z) → P (z, y)<label>(39)</label></formula><p>The rule set R is in CT E ∀∀ since every E-derivation from a KB R, F yields a finite result, which is a subset of F ∪ {P (a, z a ), P (z a , a) | a ∈ Terms(F ), z a ∈ Terms(F )}.</p><p>The rule set 1ad(R) is not in CT E ∀∀ since the KB K = 1ad(R), {P (a, b)} has no terminating E-derivation. In fact, all fair E-derivations from K yield the same result:</p><formula xml:id="formula_32">{P (a, b), X (36) (b, z 1 ), P (b, z 1 ), P (z 1 , b)} ∪ {X (36) (z i , z i+1 ), P (z i , z i+1 ), P (z i+1 , z i ) | i ≥ 1}</formula><p>Again, to show that the one-way decomposition preserves FO-rewritability, we show that it preserves BDDP.</p><formula xml:id="formula_33">Theorem 30. A rule set R is BDDP iff 1ad(R) is BDDP. Sketch. (⇒): For factbases F restricted to the original vo- cabulary Σ, we prove that Ch i (F, R) = Ch 2i (F, 1ad(R)) |Σ .</formula><p>Dealing with arbitrary factbases is tackled by a weakening of this correspondence.</p><formula xml:id="formula_34">(⇐): If R is not BDDP, there are Q and {F i } i∈N such that for all i, F i , R |= Q and Ch i (F i , R) |= Q. Since for all F i on Σ, Ch i (F i , R) = Ch 2i (F i , 1ad(R)) |Σ , it holds that Ch 2i (F i , 1ad(R)) |= Q, hence 1ad(R) is not BDDP.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Two-Way Atomic Decomposition</head><p>Despite the fact that it produces a conservative extension of the original rule set, the one-way atomic decomposition does not preserve the existence of a finite universal model; hence, it does not preserve equivalent chase termination. Example 5. As in the proof of Theorem 29, consider R = {(36)}, its decomposition 1ad(R) = {(37-39)}, and the factbase F = {P (a, b)}.</p><p>Then, U = {P (a, b), P (b, z 1 ), P (z 1 , b)} is a finite universal model for R, F that cannot be extended (keeping the same domain) into is a universal model of 1ad(R), F . Indeed, the set</p><formula xml:id="formula_35">{P (a, b), P (b, z 1 ), P (z 1 , b), X (36) (b, z 1 ), X (36) (z 1 , b)} is the smallest extension of U that is a model for 1ad(R), F , but it is not universal.</formula><p>Hence, we define a notion similar to that of conservative extension, but whose purpose is to guarantee the preservation of the equivalent chase termination. Definition 31. Let R and R be two rule sets such that Preds(R) ⊆ Preds(R ). The set R is a universalconservative extension of the set R if, for any factbase F with Preds(F ) ⊆ Preds(R), 1. The restriction of any universal model of R , F to the predicates in Preds(R) is a universal model of R, F .</p><p>2. Any universal model M of R, F can be extended to a universal model of R , F that has the same domain and agrees with M on the interpretation of Preds(R).</p><p>We now introduce a normalisation procedure that produces universal-conservative extensions: Definition 32. The two-way atomic decomposition of a rule</p><formula xml:id="formula_36">R = B[ x, y] → ∃ z.H[ x, z] is the rule set 2ad(R) = 1ad(R) ∪ {H[ x, z] → X R ( x, z)}, with X R the fresh pred- icate in 1ad(R). For a rule set R, we let 2ad(R) = R∈R 2ad(R).</formula><p>Example 6. Consider again the rule (32) from Example 4. Then its two-way atomic decomposition is 2ad((32)) = 1ad((32)) ∪ {(40)}:</p><formula xml:id="formula_37">P (x, z) ∧ S(x, y, z) → X (32) (x, y, z)<label>(40)</label></formula><p>We establish that this new decomposition is indeed a normalisation procedure that has the desired property. Proposition 33. The rule set 2ad(R) is a conservative extension and a universal-conservative extension of R.</p><p>We can now focus our interest again on chase termination. Both atomic decompositions behave like the single-piece decomposition (Theorem 18) regarding the oblivious and the semi-oblivious chase: Theorem 34. Both atomic decompositions preserve the termination of the O-chase and the SO-chase.</p><p>Sketch. Consider X ∈ {O, SO} and K = R, F a KB. First note that for these X-chases, applying a rule cannot prevent the application of another rule. Hence, since 1ad(R) ⊆ 2ad(R), it is sufficient to prove the result for 2ad(R). The proof is similar to that of Theorem 18: we show by induction on an arbitrary derivation D from K that there is an injective homomorphism from Ch X ( 2ad(R), F ) restricted to the predicates in Preds(R) to Ch X (K), which leads to a similar conclusion.</p><p>The behavior of the restricted chase is again less easily characterized, as we will see in the next results. Theorem 35. The two-way atomic decomposition preserves sometimes-termination of the R-chase; it may also gain termination of this chase variant. Sketch. To prove preservation, consider a KB K = R, F such that R ∈ CT R ∀∃ . Then, there is a terminating Rderivation D from K. We can then show by induction that if a trigger t = (R, π) with R = B → H is applied at some step, the trigger t = (B → X R , π) is applicable at the same step, then the triggers t i = (X R → H i , π R ) also are, and that applying t and all the t i successively yields the same result (when restricted to the predicates in R) as applying t. This shows that we can replicate a terminating derivation, and thus that the sometimes-termination is preserved. We now present an example where we gain termination. Consider the rule set R = {(41-45)}:</p><formula xml:id="formula_38">A(x) → ∃y, z R(x, x, x) ∧ R(x, y, z) (41) R(x, y, z) → ∃t.R(x, x, t)<label>(42)</label></formula><p>R(x, x, y) → ∃z.S(x, y, z)</p><p>(43) R(x, x, y) ∧ S(x, y, z) → S(x, x, x) (44) A(x) ∧ S(x, x, y) → A(y) (45) There is no terminating R-derivation on the KB R, {A(a)} but there is one on 2ad(R), F for any F .</p><p>Theorem 36. The two-way atomic decomposition does not preserve the termination of the R-chase.</p><p>Proof. Consider the rule set R = {(36)} introduced in the proof of Theorem 29 and 2ad(R) = {(37-39), (46)}: P (x, y) → ∃z. P (y, z) ∧ P (z, y) (36) P (x, y) → ∃z.X (36) (y, z) (37) X (36) (y, z) → P (y, z)</p><p>(38) X (36) (y, z) → P (z, y) (39) P (y, z) ∧ P (z, y) → X (36) (y, z)</p><p>(46) The R-chase yields the same result as the E-chase on R, so R ∈ CT R ∀∀ . We then construct an infinite derivation from 2ad, P (a, b) . First, apply (37), and (38). Then, repeat the following pattern: (37), (38) (on the new variable), then ( <ref type="formula" target="#formula_31">39</ref>) and ( <ref type="formula">46</ref>) (on the variables of the previous loop). Applying (37) again before applying (46) yields an infinite chain.</p><p>Again, the R-chase is not well-behaved with respect to atomic decomposition. However, the DF-R-chase behaves exactly as desired regarding the two-way atomic decomposition. In fact, we can show an even stronger result: any DF-R-derivation from a KB R, F can be replicated by a DF-R-derivation from 2ad(R), F , and conversely. The single-piece decomposition may gain termination for some chase variants (Theorem 23); we are interested to know if the same can happen with atomic decompositions. Unfortunately, there is no way for a non-terminating rule set to gain termination, as stated next: Proposition 39. If a chase variant does not terminate on a rule set R, it does not terminate on 1ad(R) and 2ad(R).</p><p>Sketch. For each trigger with a rule R in the original infinite fair derivation, one can consider the corresponding triggers with 1ad(R) or 2ad(R), and thus produce an infinite fair derivation.</p><p>Regarding FO-rewritability, the two-way atomic decomposition behaves similarily to the one-way atomic decomposition (which can be proven similarly, see Theorem 30). Theorem 40. A rule set R is BDDP iff 2ad(R) is BDDP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">No Normalisation for the Restricted Chase</head><p>Normalisation procedures studied so far do not maintain the status of the termination of the R-chase. This raises the question of the existence of such a procedure. We show here that no computable function can map rule sets to sets of rules having atomic head while preserving termination and non-termination of the R-chase. To do that, we show that with atomic-head rules, the class of rule sets CT R F ∀ for which every fair R-derivation from R, F is finite is a recursively enumerable set. With arbitrary rules, we show it is hard for Π 0 2 , the second level of the arithmetic hierarchy <ref type="bibr" target="#b21">(Rogers 1987)</ref>. A complete problem for Π 0 2 is to decide whether a given Turing machine halts on every input word; it remains complete when inputs are restricted to words on a unary alphabet.</p><p>Proposition 41. For any factbase F , the subset of CT R F ∀ composed of sets of atomic-head rules is recognizable.</p><p>Sketch. With atomic-head rules, it is known that the existence of an infinite fair restricted derivation is equivalent to the existence of an infinite restricted derivation <ref type="bibr" target="#b12">(Gogacz, Marcinkowski, and Pieris 2020)</ref>. Using König's lemma, one can show that the chase terminates iff there exists a k such that any fair R-derivation is of length at most k.</p><p>Proposition 42. There exists a factbase F such that CT R F ∀ is Π 0 2 -hard.<ref type="foot" target="#foot_3">4</ref> Sketch. Given a Turing machine (TM) M whose input alphabet is unary, we build a KB K = R w ∪ R M , F s.t. every fair R-derivation from K is finite iff M halts on every input. Regardless the chase variant, simulating a TM with a rule set such that the chase terminates whenever the TM halts is classical; we reuse the rule set R M provided in <ref type="bibr" target="#b3">(Bourgaux et al. 2021</ref>), which we recall in Figure <ref type="figure" target="#fig_7">4</ref> for self-containment. We show that we can assume wlog that all the rules of R M are applied after all the rules of R w (listed in Figure <ref type="figure" target="#fig_6">3</ref>). The set R w is used to generate from F arbitrarily large input tape representations in a terminating way. To ensure that any fair R-derivation from R w , F terminates, we reuse the emergency brake technique from <ref type="bibr" target="#b17">(Krötzsch, Marx, and Rudolph 2019)</ref>, which allows one to stop the derivation at any desired length. The representation of an input word of length j is a set of atoms of the shape {Nxt(c j i , c j i+1 ), S 1 (c j i ) | 0 ≤ i &lt; j} ∪ {S (c j j ), Frst(c j 0 ), End(c j j )}. As detailed below, the factbase F contains the representation of the input words of length 0 and 1 (Item 1), atoms used as seeds to build larger words (Item 2) and atoms that initialize the emergency brake (Items 3 and 4):   The chase works as follows: after generating a non-final (NF) chain with Rule (47), the brake (B) is made real (R) by Rule (48), which prevents any extension of the non-final chain through restricted rule applications. A final (F) element is added after each non-final element by Rule (49), and from each final element a tape is created, by traversing the chain, marking as done (D) processed elements, thanks to Rules (50)-(53). Figure <ref type="figure" target="#fig_5">2</ref> depicts the result of any R-chase derivation from R w , F in which R(b) has been derived after exactly one application of Rule (47). Rule (54) sets the initial state on the first cell.</p><formula xml:id="formula_39">1. Frst(c 1 0 ), S 1 (c 1 0 ), Nxt(c 1 0 , c 1 1 ), End(c 1 1 ), S (c 1 1 ), Frst(c 0 0 ), End(c 0 0 ), S (c 0 0 ) 2. Int(a), NF(a, nf 1 ), R(nf 1 ), NF(nf 1 , b), D(nf 1 , b) a : Int nf 1 : R nf 2 : R b : B, {S a }, {Hd q }, Frst, End, (R) f 2 f 3 c 2 2 : S , End c 2 1 : S 1 c 2 0 : S 1 ,</formula><p>As it is known recursively enumerable sets are a strict subsets of Π 0 2 <ref type="bibr" target="#b21">(Rogers 1987)</ref>, the following theorem follows. Theorem 43. No computable function f exists that maps rule sets to rule sets having atomic-head rules such that R ∈ CT R ∀∀ if and only if f (R) ∈ CT R ∀∀ .</p><p>Nxt(x, y) → Nxt + (x, y)</p><p>Nxt + (x, y) ∧ Nxt + (y, z) → Nxt + (x, z) Nxt(x, y) ∧ Stp(x, z) ∧ Stp(y, w) → Nxt(z, w) End(x) ∧ Stp(x, z) → ∃v.Nxt(z, v) ∧ S (v) ∧ End(v) Hd q (x) ∧ Nxt + (x, y) ∧ S c (y) → ∃z.Stp(y, z) ∧ S c (z) Hd q (x) ∧ Nxt + (y, x) ∧ S c (y) → ∃z.Stp(y, z) ∧ S c (z)</p><p>Hd q (x) ∧ S a (x) → ∃z.Stp(x, z) ∧ S b (z) Hd q (x) ∧ S a (x) ∧ Stp(x, z) ∧ Nxt(z, w) → Hd r (w) Hd q (x) ∧ S a (x) ∧ Stp(x, z) ∧ Nxt(w, z) → Hd r (w) This applies in particular to normalisation procedures producing rule sets with atomic-head rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>As shown in this paper, normalisation procedures do have an impact, sometimes unexpected, on chase termination. This is particularly true regarding the restricted chase, which is the most relevant in practice but also the most difficult to control. We extend the understanding of its behavior by three results. We show that the Datatog-first strategy is in fact not always the most terminating, which goes against a common belief. We introduce a new atomic-decomposition (two-way), which behaves nicely, in particular regarding the Datalog-first restricted chase, but still has a negative impact on the restricted chase termination. This leads to us to show a more fundamental decidability result, which implies that no computable atomic-decomposition exists that exactly preserves the termination of the restricted chase (i.e., termination and non-termination). Note however that our result does not rule out the existence of a computable normalisation procedure into atomic-head rules that would improve the termination of the restricted chase, although this seems unlikely. Future work includes investigating normalisation procedures for first-order logical formulas, to translate these into the existential rule framework.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The only result of the DF-R-chase from the KB K = R, {A(a)} introduced in the proof of Theorem 13</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 16 .</head><label>16</label><figDesc>Consider some fair X-derivations D and D from a KB K. If X = O, then res(D) = res(D ). If X = SO, then res(D) is isomorphic to res(D ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>is in all of these sets. Concerning the O-chase, we show via induction that Ch O ( R, F ) and Ch O ( sp(R), F ) are isomorphic for any rule set R and factbase F (where Ch O (•) is the function from Definition 17, which maps a KB to its only O-chase result). Hence, all O-derivations from R, F are terminating iff all O-derivations from sp(R), F are terminating. Concerning the E-chase, we rely again on Proposition 15.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Theorem 37. The 2-way atomic decomposition has no impact on the (sometimes-)termination of the DF-R-chase; i.e., CT DF-R ∀∀ = 2ad(CT DF-R ∀∀ ) and CT DF-R ∀∃ = 2ad(CT DF-R ∀∃ ). Sketch. One can prove that any fair DF-R-derivation D from R, F with R ∈ CT DF-R ∀∀ can be replicated to yield a fair DF-R-derivation D from 2ad(R), F such that D is finite if and only if D is. The reciprocal is also true. The following result follows from Proposition 33 Theorem 38. : The two-way atomic decomposition preserves the termination of the E-chase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>, Nxt, Nxt + , Stp</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The effect of Rw on F : Dashed atoms are D, F or NF atoms generated by the chase; Nxt atoms used by RM are dotted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Rules Rw to create the initial tapes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Rules RM for the Turing Machine simulation: the last three rules are instantiated w.r.t.the transition function of M .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table /><note><p>Impact on chase termination. Chase variants are denoted as follows: O: Oblivious; SO: semi-oblivious; (DF-)R: (Datalogfirst) restricted; E: equivalent.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>The equivalent chase behaves as the better-known core chase regarding termination: it halts exactly when the KB has a finite universal model. The difference lies in the fact that the core chase computes a minimal universal model (i.e., a core). The equivalent chase has the advantage of being monotonic (∀i, Fi ⊆ Fi+1).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>To understand why this strategy results in a terminating Rderivation, we suggest to first try it on F = {A(a)}, which yields {A(a), R(a, z1), S(z1, z2), S(a, a), R(a, a)}.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>Such rule set in given in the proof of Theorem 13; see also {(36)} in the proof of Theorem 29.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Note that this contradicts the first item of Theorem</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_4"><p>5.1 in<ref type="bibr" target="#b14">(Grahne and Onet 2018)</ref>. However, no proof is given for that statement, which is uncorrectly attributed to<ref type="bibr" target="#b10">(Deutsch, Nash, and Remmel 2008)</ref>.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>This work was partly supported by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_HYnYZWb">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Extending decidable cases for rules with existential variables</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="677" to="682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The implication problem for data dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Colloquium on Automata, Languages, and Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="73" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Capturing homomorphism-closed decidable queries with existential rules</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Lakemeyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Erdem</surname></persName>
		</editor>
		<meeting>the 18th International Conference on Principles of Knowledge Representation and Reasoning<address><addrLine>KR; Online event</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021-11-03">2021. 2021. November 3-12, 2021</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Taming the infinite chase: Query answering under expressive relational constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning, KR&apos;08</title>
		<meeting>the Eleventh International Conference on Principles of Knowledge Representation and Reasoning, KR&apos;08</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Taming the infinite chase: Query answering under expressive relational constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Knowledge Representation and Reasoning: Proc. of the Eleventh International Conference</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</editor>
		<meeting><address><addrLine>KR; Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008-09-16">2008. 2008. September 16-19, 2008</date>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A general datalog-based framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="77" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Towards more expressive ontology languages: The query answering problem</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">193</biblScope>
			<biblScope unit="page" from="87" to="128" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Tractable reasoning and efficient query answering in description logics: The DL-Lite family</title>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>De Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rosati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning (JAR)</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Restricted chase (non)termination for existential rules with disjunctions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJ-CAI 2017</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Sierra</surname></persName>
		</editor>
		<meeting>the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJ-CAI 2017<address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-08-19">2017. August 19-25, 2017</date>
			<biblScope unit="page" from="922" to="928" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The chase revisited</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 27th ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</editor>
		<meeting>of the 27th ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems<address><addrLine>PODS</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Data exchange: Semantics and query answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Database Theory -ICDT 2003, 9th International Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Motwani</surname></persName>
		</editor>
		<meeting><address><addrLine>Siena, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003-01-08">2003. January 8-10, 2003</date>
			<biblScope unit="volume">2572</biblScope>
			<biblScope unit="page" from="207" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Allinstances restricted chase termination</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gogacz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marcinkowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2020</title>
		<editor>
			<persName><forename type="first">D</forename><surname>Suciu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Z</forename><surname>Wei</surname></persName>
		</editor>
		<meeting>the 39th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2020<address><addrLine>Portland, OR, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020-06-14">2020. June 14-19, 2020</date>
			<biblScope unit="page" from="245" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The price of query rewriting in ontology-based data access</title>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kikot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">V</forename><surname>Podolskii</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schwentick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zakharyaschev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">213</biblScope>
			<biblScope unit="page" from="42" to="59" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Anatomy of the chase</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Onet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundam. Informaticae</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Acyclicity notions for existential rules and their application to query answering in ontologies</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kupke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Magka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="741" to="808" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Sound, complete and minimal ucq-rewriting for existential rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>König</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
		<idno>CoRR abs/1311.3198</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The power of the terminating chase (invited talk)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd International Conference on Database Theory, ICDT 2019</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Calautti</surname></persName>
		</editor>
		<meeting><address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2019-03-26">2019. March 26-28, 2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="3" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A single approach to decide chase termination on linear existential rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ulliana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Database Theory, ICDT 2019</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Calautti</surname></persName>
		</editor>
		<meeting>the 22nd International Conference on Database Theory, ICDT 2019<address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Generalized schema-mappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">B</forename><surname>Marnette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems, PODS 2009</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</editor>
		<meeting>of the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symp. on Principles of Database Systems, PODS 2009<address><addrLine>Providence, Rhode Island, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009-06-19">2009. June 19 -July 1, 2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Querying Existential Rule Knowledge Bases: Decidability and Complexity</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rocher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<pubPlace>France</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of Montpellier</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">H</forename><surname>Rogers</surname></persName>
		</author>
		<title level="m">Theory of Recursive Functions and Effective Computability</title>
		<meeting><address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Materializing knowledge bases via trigger graphs</title>
		<author>
			<persName><forename type="first">E</forename><surname>Tsamoura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Malizia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Urbani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="943" to="956" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient model construction for horn logic with vlog -system description</title>
		<author>
			<persName><forename type="first">J</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J H</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAR</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">10900</biblScope>
			<biblScope unit="page" from="680" to="688" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
