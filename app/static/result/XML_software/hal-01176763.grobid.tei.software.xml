<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Logics for Unordered Trees with Data Constraints $</title>
				<funder ref="#_c4NVTUH">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2018-12-19">19 th December, 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Adrien</forename><surname>Boiret</surname></persName>
							<email>adrien.boiret@umons.ac.be</email>
							<affiliation key="aff0">
								<orgName type="laboratory">ManySynth project</orgName>
								<orgName type="institution">Université de Mons</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vincent</forename><surname>Hugot</surname></persName>
							<email>vincent.hugot@insa-cvl.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory" key="lab1">SDS team</orgName>
								<orgName type="laboratory" key="lab2">LIFO (EA 4022Val de Loire c Links team</orgName>
								<orgName type="laboratory" key="lab3">Cristal lab (Cnrs Umr 9189</orgName>
								<orgName type="institution" key="instit1">INSA Centre</orgName>
								<orgName type="institution" key="instit2">Inria Lille</orgName>
								<orgName type="institution" key="instit3">Université de Lille</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Joachim</forename><surname>Niehren</surname></persName>
							<email>joachim.niehren@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Ralf</forename><surname>Treinen</surname></persName>
							<email>treinen@irif.fr</email>
							<affiliation key="aff2">
								<orgName type="laboratory" key="lab1">IRIF</orgName>
								<orgName type="laboratory" key="lab2">UMR 8243</orgName>
								<orgName type="institution" key="instit1">Univ Paris Diderot</orgName>
								<orgName type="institution" key="instit2">Sorbonne Paris Cité</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<postCode>F-75205</postCode>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Logics for Unordered Trees with Data Constraints $</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2018-12-19">19 th December, 2018</date>
						</imprint>
					</monogr>
					<idno type="MD5">CD2DBA05B975945B103BF957BC641C6F</idno>
					<note type="submission">Draft version Wednesday</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Counting Mso</term>
					<term>data trees</term>
					<term>string comparisons</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study monadic second-order logics with counting constraints (CMso) for unordered data trees. Our objective is to enhance this logic with data constraints for comparing string data values. Comparisons between data values at arbitrary positions of a data tree quickly lead to undecidability. Therefore, we restrict ourselves to comparing sibling data values of unordered trees. But even in this case CMso remains undecidable when allowing for data comparisons that can check the equality of string factors. However, for more restricted data constraints that can only check the equality of string prefixes, it becomes decidable. This decidability result is obtained by reduction to WSkS. Furthermore, we exhibit a restricted class of constraints which can be used in transitions of tree automata, resulting in a model with tractable complexity, which can be extended with structural equality tests between siblings. This efficient restriction is relevant to applications such as checking well-formedness properties of file system trees.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Monadic second-order order logic (Mso) is one of the yardstick logics for expressiveness in computer science <ref type="bibr" target="#b1">[2]</ref>. It is well-known that Mso for tree-like structures is decidable, basically by reduction to tree automata, while Mso for more general graphs or structures is undecidable. In this paper, we will consider Mso over unordered data trees. This means that we annotate the elements of the data tree with strings or other data values from an infinite alphabet. Depending on which relations on data values are supported, unordered data trees subsume graphs, so that Mso becomes undecidable again.</p><p>Unordered data trees are a versatile data structure that is of interest in various domains of computer science. More recently, they were used as data models of semi-structured databases, such as for NoSql databases <ref type="bibr" target="#b2">[3]</ref> or for Xml databases <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref>. Here, Mso can be used both as a query language and as a schema language. Unordered data trees also have a long history for modeling syntactic structures in computational linguistics <ref type="bibr" target="#b6">[7]</ref> and records in programming languages <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10]</ref>. The unordered data trees in this context were called feature trees and the corresponding logics feature logics <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12]</ref>. Our own motivation is to model file systems, i.e. trees representing directories, files names, their contents etc. Yet, so far, Mso for unordered trees has been studied without data, that is over finite alphabets. The two main variants of Mso for unordered trees that were proposed are Presburger Mso and Counting Mso <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref>. Both logics were proven decidable by reduction to corresponding notions of automata for unranked trees. The weaker logic, Counting Mso or CMso for short, is considered a canonical language for characterising recognizable sets, and is actually equivalent to Mso in the case of ordered trees or words <ref type="bibr" target="#b12">[13]</ref>. In this present paper, we generalize CMso to unordered data trees with arbitrary ranks, and study the expressiveness of the resulting logics.</p><p>The most general extension of CMso would enable comparisons of data values between arbitrary locations, but this immediately leads to undecidability. Indeed even Mso on data words with equality tests between the data values of arbitrary positions is undecidable <ref type="bibr" target="#b13">[14]</ref> since it can be reduced to Mso on grids, for which undecidability is folklore <ref type="bibr" target="#b14">[15]</ref>. The situation is even worse, in that even the first-order logic of data words with equality tests is undecidable <ref type="bibr" target="#b15">[16]</ref>. One therefore needs to find suitable restrictions, avoiding the case of data words. The most important restrictions for decidability are:</p><p>( ) Limiting comparisons of data values to sibling positions only. With this, each level of the tree can be seen as a multiset of data values, so that the nub of the problem becomes handling CMso for such multisets.</p><p>( ) Disallowing for string comparisons that deal with factors of strings, or equivalently, suffixes and prefixes at the same time.</p><p>We shall see that CMso for multisets of strings remains decidable even when allowing for equality tests of data values up to constant suffixes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions. Our contributions are as follows:</head><p>We introduce the logic CMso(Θ) for unordered data trees by extending Counting Mso on unordered trees with comparisons of sibling data values.</p><p>Which specific comparisons are allowed for is defined by a set Θ of relations between data values, which is a parameter of the logic. In particular, we can choose Θ such that it provides only equality tests on data values.</p><p>We show that satisfiability of CMso(Θ suffix ) is decidable, where Θ suffix only deals with relations between suffixes. This includes the special case of data equality tests. (The same applies symmetrically to CMso(Θ prefix ), dealing only with prefixes.) In fact, we show more generally that CMso(Θ WSkS ) is decidable, where Θ WSkS is the set of all relations definable in weak monadic second-order logic of k successors.</p><p>To find out whether it is possible to loosen the limitation to data comparisons between siblings, we extend CMso(Θ id ) -testing only data equality between siblings -with equality of data values between uncles and nephews. However, we show that satisfiability for this logic becomes undecidable. The same applies with equality of data between cousin positions.</p><p>We next show that satisfiability of CMso(Θ prefix+suffix ) is undecidable, where Θ prefix+suffix provides functions that add or remove letters at the beginning or the end of data words. More generally, comparison of both prefixes and suffixes, and similarly, comparisons of factors of data values, lead to undecidability.</p><p>We show that, if the relations Θ only transform one suffix into another (e.g. ".tex" to ".pdf"), for a fixed finite set of suffixes none of which is another's suffix, then we can use counting constraints with data tests between siblings in the transitions of an appropriate model of bottom-up automata, and get an implementation with tractable complexities for emptiness: PSpace in the case of deterministic automata -and NExpTime in general. Furthermore, the method is extended to support structural equality and disequality constraints between siblings, still in NExpTime.</p><p>Those results are a net positive for our targeted applications. For example, an important property which we need to model is whether source files have been compiled, e.g. "mybook.tex" to "mybook.pdf". Of course any other PDF file is irrelevant wrt. "mybook.tex", so this is an instance of checking equality of data values, up to suffixes. Such properties are expressible in CMso(Θ suffix ) -and thus decidableso long as compilation is done in the same directory as the source, and all but a few artificial counterexamples fall in the special case that can be handled efficiently. We now clarify the ways in which counting constraints serve our applications.</p><p>Counting in Data Trees: Intuitions. Using unordered trees means expressing and evaluating properties on sets -or multisets -of elements, e.g. the data values of the children at the current position. Naturally, this amounts to counting: for instance in a file tree "there are at least 2 values that match *.txt" (where * matches any string), or in a bibliographical database "there are fewer values of type inproceedings than there are books". Where the existing approaches differ is in the expressive power available for that counting; for instance, it may be possible to compare two variable quantities -as in the second example -or just one variable quantity and a constant -as in the first. This is the main difference of expressivity between Presburger constraints and the simpler counting constraints. In all cases, however, each element is considered alone, in isolation from its brothers.</p><p>We previously studied the complexity of decision problems for automata using various such formalisms as guards for their bottom-up transitions in <ref type="bibr" target="#b16">[17]</ref>. The focus was on devising good notions of deterministic machines capable of executing such counting operations, sufficiently expressive while allowing for efficient algorithms. Our present focus, in contrast, is to extend the expressive power of the counting formalisms, while preserving decidability. Since the yardsticks of expressive power for counting tests are logics, this paper mostly deals directly with second-order logics rather than automata.</p><p>Our main goal in this paper is to extend existing formalisms with the ability to express data constraints on unordered data trees, so that each data value may be considered not only in isolation, but also along with sibling values to which it is related. Such constraints arise naturally in various circumstances, and we shall see that considering only sibling values is a practical restriction, in the sense that it makes it easier to obtain decidable logics.</p><p>By way of example, consider a directory containing L A T E X resources, which may be represented by an edge-labelled tree in the style of Figure <ref type="figure" target="#fig_1">1</ref>, given in Json (JavaScript Object Notation) syntax, where each data value corresponds to a file name or, in the case of leaves, file contents.  Suppose that we want to specify that the contents of a L A T E X repository has been properly compiled, which is to say that for every main L A T E X file -i.e. a file whose name has suffix ".tex", and whose contents begin with "\documentclass" -there exists a corresponding pdf file whose contents starts with a header declaring adherence to version 1.5 of the PDF standard. To express this property, sibling data values -here representing files in the same directory -are put in relation by θ tex2pdf = { (w".tex", w".pdf") | w is a word }. In other words, the constraint which is expressed is of the form "any value d whose subtree satisfies some property P has a brother d = θ tex2pdf (d) whose subtree satisfies another property P ".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>file.tex dir</head><p>We need to integrate this kind of data constraints in existing formalisms for unordered trees; the two yardsticks of expressive power that have emerged in the</p><formula xml:id="formula_0">• • • • d 1 d 2 • • d 3 d 1 d 1 • • • • d 2 d 1 • • d 3 d 1 d 1 • • • d 3 • • • d 1 d 2 d 1 d 1 • • • d 3 • • • d 2 d 1 d 1 d 1 Figure 2: Drawings of {| d 1 : {| d 3 : {| | } | }, d 1 : {| d 1 : {| | }, d 2 : {| | } | } | } with all edge orders.</formula><p>literature are the extensions of monadic second-order logic (Mso) by horizontal Presburger constraints <ref type="bibr" target="#b3">[4]</ref>, and by the weaker, but more tractable, counting constraints <ref type="bibr" target="#b17">[18]</ref>. The latter is capable of expressing that the cardinality of a set variable is less than m or equal to m modulo n, but not of comparing the cardinalities of two set variables directly, unlike Presburger logic.</p><p>We choose Mso with counting constraints as our starting point, and add the capability to express data relations.</p><p>Related work. This paper combines work on unordered trees and the associated automata and logics, as in <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b5">6]</ref>, with questions about data values that are closely related to problems studied in the databases community for register automata, first-order logic, and XPath, <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19]</ref>, among others. The upshot of the existing work is that, in the ordered case, even the mere ability to express equality between data values renders very simple logics intractable or undecidable. For instance, on data words, Mso with equality tests is undecidable, and even the very simple logic F O 2 (∼, +1, &lt;), i.e. first-order logic with two variables and successor and linear order relations, with data equality tests, while still decidable, is not known to be primitive recursive, and is at least as hard as reachability for Petri nets <ref type="bibr" target="#b15">[16]</ref>. As it turns out in this paper, the unorderedness of our data trees actually simplifies the handling of the data values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Data trees and CMso(Θ)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Data Trees</head><p>A data alphabet is a finite set For our convenience, we also define the "sibling-or-self" relation:</p><formula xml:id="formula_1">v t v ⇔ v = v ∨ ∃v . v ↓ t v ∧ v ↓ t v . (<label>1</label></formula><formula xml:id="formula_2">)</formula><p>By extension of the language of terms and ranked trees, we use the word arity to refer to the set of children of a node v in a tree t, which we denote by ar(t, v).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">CMso(Θ)</head><p>Mso(Ψ). Let A be a data alphabet and X a countable set of variables of two types, node variables and set variables. A variable assignment I into some tree t will map any node variable x ∈ X to a node I(x) ∈ V t and any set variable X ∈ X to a set of nodes I(X) ⊆ V t .</p><p>As a parameter of our logic we assume a set Ψ of formulae called node selectors, which may contain letters from A and variables from X . The only assumption we make is that any node selector ψ ∈ Ψ defines for any tree t and variable assignment I into t a set of nodes ψ t,I ⊆ V t . For instance, we could choose formulae ψ ::= π | _ ↓ x, for regular expressions π and node variable x, such that π t,I = {v | t (v) matches π} is set of all nodes whose incoming edge is labeled by a word in A * that matches regular expression π, and _ ↓ x t,I = {v | v ↓ t I(x)} is the set of nodes of which I(x) is a child. The formulae of MSO over Ψ are:</p><formula xml:id="formula_3">ξ ∈ Mso(Ψ) ::= x ∈ ψ | x ∈ X | ∃x . ξ | ∃X . ξ | ξ ∧ξ | ¬ξ ,<label>(2)</label></formula><p>where ψ ∈ Ψ. Whether a formula is true for a given tree t and variables assignment I into t is defined in Figure <ref type="figure" target="#fig_2">3</ref>. As syntactic sugar, we shall freely use the usual additional logical connectives and set comparisons that can be easily encoded, i.e. formulae ∀x.ξ, ∀X.ξ, ξ ⇔ ξ , ξ ⇒ ξ , as well as X ⊆ X , X = ψ, and ψ = ∅.</p><formula xml:id="formula_4">t, I |= x ∈ ψ ⇔ I(x) ∈ ψ t,I , t, I |= x ∈ X ⇔ I(x) ∈ I(X) , t, I |= ∃x . ξ ⇔ t, I[x → v] |= ξ for some v ∈ V t , t, I |= ∃X . ξ ⇔ t, I[X → V ] |= ξ for some V ⊆ V t , t, I |= ξ ∧ ξ ⇔ t, I |= ξ ∧ t, I |= ξ , t, I |= ¬ξ ⇔ t, I |= ξ .</formula><p>Children Counting Constraints: CC(Φ). Here we define node selectors given other node selectors Φ. A children counting constraint selects a node of a tree by testing the number of its children satisfying some property. Which properties can be tested is defined by the parameter Φ. As before, we use as parameter a set of node selectors Φ such that φ t,I ⊆ V t is defined for all φ ∈ Φ.</p><p>A counting constraint over Φ is a formula with the following syntax, where φ ∈ Φ and n, m ∈ N:</p><formula xml:id="formula_5">γ ∈ CC(Φ) ::= #φ n | #φ ≡ m n | γ ∧ γ | ¬γ . (<label>3</label></formula><formula xml:id="formula_6">)</formula><p>The first two kinds of formulae can test whether the number of children satisfying φ is less or equal to n or equal to n modulo m. Note that we cannot write #φ #φ , though this is possible in the richer class of Presburger formulae.</p><p>Any counting constraint γ defines a set of nodes γ t,I for any variable assignment I to t, so counting constraints themselves can be used as node selectors:</p><formula xml:id="formula_7">#φ n t,I = { v ∈ V t | Card({ v | v ↓ t v ∧ v ∈ φ t,I }) n }, #φ ≡ m n t,I = { v ∈ V t | Card({ v | v ↓ t v ∧ v ∈ φ t,I }) ≡ m n }, γ ∧ γ t,I = γ t,l ∩ γ t,l , ¬γ t,I = V t \ γ t,l .<label>(4)</label></formula><p>Note that we can define #φ n as syntactic sugar for ¬(#φ n -1), and #φ = n as syntactic sugar for #φ n ∧ #φ n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Counting MSO with comparisons of sibling data values: CMso(Θ).</head><p>We can now define the logic we are interested in. As before we assume a set of variables X and a data alphabet A. In addition, we fix a set Θ of binary relations on A * that are called string comparisons. We then define a set of node selectors with regular expressions for matching data values and comparisons of sibling data values from Θ. Such a node selector has the following syntax where θ ∈ Θ, π is a regular expression over A, and x, X ∈ X : The sets of selected nodes are defined as follows for formula φ ∈ Φ rel , any tree t and variable assignment I into t:</p><formula xml:id="formula_8">π t,I = {v | t (v) matches π} x t,I = {I(x)} X t,I = I(X) θ.φ t,I = {v | ∃v . v t v ∧ ( t (v), t (v )) ∈ θ ∧ v ∈ φ t,I } φ ∧ φ t,I = φ t,I ∩ φ t,I ¬φ t,I = V t \ φ t,I</formula><p>Definition 1. We define the children counting contraints for data trees with comparisons of data values CC(Θ) by CC(Φ rel (Θ)) and the counting MSO for data trees with comparison of sibling data values CMso(Θ) by Mso(CC(Θ)).</p><p>Note that the childhood relation x ↓ x can be defined in CMso(Θ) by x ∈ (#x = 1) independently of the choice of Θ. Hence, sibling-or-self contraints x x can also be defined by x = x ∨ ∃x . (x ↓ x ∧ x ↓ x ) for any Θ. The elements of Θ intervene only if one wants to compare the data values of sibling nodes.</p><p>It is relevant to note that this is not the only way a CMso logic can be defined: as explored in previous literature <ref type="bibr" target="#b4">[5]</ref>, Mso can be enriched with counting constraints on individual arities or, equivalently, on the whole tree. This equivalence does not hold true for all Mso enrichment: for example, PMso is defined with Presburger constraints on arities. We choose to parametrize the counting constraints as test in the arities. One of the advantage of this choice is that it ties into one of our previous publications <ref type="bibr" target="#b16">[17]</ref> where we create automata classes parametrized by their arity constraints.</p><p>Example 1. Recall now the earlier motivating example, given the representation of file trees illustrated by Figure <ref type="figure" target="#fig_1">1</ref> [p4] : specify that the contents of a L A T E X repository has been properly compiled, which is to say that for every main L A T E X file -i.e. a file whose name has suffix ".tex", and whose contents begins with "\documentclass" -there exists a corresponding pdf file whose contents begins with a pdf 1.5 header.</p><p>As mentioned before, the requirements regarding the contents of the files are properties of subtrees or, equivalently, of nodes. Let us briefly assume that those nodes are captured by the set variables X doc and X pdf15 , containing the nodes satisfying the "main T E X file" and "valid pdf" properties, respectively.</p><p>A T E X main document (resp. a valid pdf version 1.5) is represented by a node with a single outgoing edge, whose label is prefixed by "\documentclass" (resp. "%PDF-1.5"), leading to a leaf. For instance, we would expect the following annotations:</p><formula xml:id="formula_9">• • ∈ X pdf15 • ∈ X leaf "%PDF-1.5..." • ∈ X doc • ∈ X leaf "\documentclass..." • • ∈ X leaf "Blah blah" "chapter.tex" "Book.tex" "Book.pdf" .<label>(5)</label></formula><p>Then we can write</p><formula xml:id="formula_10">∀x . x ∈ (#[ * ".tex" ∧ X doc ∧ ¬θ tex2pdf .X pdf15 ] = 0) . (<label>6</label></formula><formula xml:id="formula_11">)</formula><p>There now remains to complete the formula by defining X doc and X pdf15 formally: this yields the following CMso({ θ tex2pdf }) sentence, capturing the desired specification:</p><formula xml:id="formula_12">∃X leaf . ∃X doc . ∃X pdf15 . X leaf = #[ * ] = 0 ∧ X doc = #[ * ] = 1 ∧ #["\documentclass" * ∧ X leaf ] = 1 ∧ X pdf15 = #[ * ] = 1 ∧ #["%PDF-1.5" * ∧ X leaf ] = 1 ∧ ∀x . x ∈ (#[ * ".tex" ∧ X doc ∧ ¬θ tex2pdf .X pdf15 ] = 0) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Satisfiability of CMso(Θ WSkS ) is Decidable</head><p>We shall now see that Θ can be made rather large and useful without endangering decidability (so long as the pitfalls studied in the next sections are avoided). Indeed, the most frequent operation in applications, illustrated in particular by the running T E X compilation example, is suffix replacement. The property that we really need is thus decidability of satisfiability for CMso(Θ suffix ), where the relations of Θ suffix are of the form</p><formula xml:id="formula_13">θ u,u = { (wu, wu ) | w ∈ A * }, for u, u ∈ A * .</formula><p>We show decidability for a class which is actually more general: WSkS-definable relations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Preliminaries: WSkS</head><p>The well-known logic Weak Monadic Second-Order Logic with k Successors (WSkS) <ref type="bibr" target="#b19">[20]</ref>, for any k 1, is the weak Mso on the signature containing the constant symbol ε and the unary function symbols 1, 2, . . . , k, written in postfix notation. That is to say, the terms are given by</p><formula xml:id="formula_14">τ ::= | z | τ i where 1 i k . (<label>7</label></formula><formula xml:id="formula_15">)</formula><p>For instance ε41234 is a term of WSkS, for k 4. The domain of interpretation is the set of words of { 1, . . . , k } * , in the straightforward way: the constant denotes the empty word, and each of the functions i, written in postfix notation, denotes appending the symbol i at the end of a word. The term ε41234 is thus interpreted as the word 41234. The logic is called "weak" because it is restricted to quantification over finite sets.</p><p>Since we shall handle both WSkS and CMso(Θ) at the same time -in fact encoding one into the other -we shall suppose that they use different variables, and take the convention that WSkS first-order variables are written z or some variant thereof, and second-order variables Z -the set of all variables is likewise written Z.</p><p>Validity and satisfiability of formulae in WSkS are decidable <ref type="bibr" target="#b20">[21]</ref>, albeit with a non-elementary complexity <ref type="bibr" target="#b21">[22]</ref>. WSkS has previously been shown equivalent in expressive power to Mso and ordering constraints over feature trees <ref type="bibr" target="#b22">[23]</ref>. Some useful relations expressible in WSkS are z pref z (prefix partial order on words), z lex z (lexicographic total order on words), z ∈ π for any regular expression</p><formula xml:id="formula_16">π, Z ⊆ Z , Z = Z ∪ Z , Z = Z ∩ Z , Z = Z (complement), Z = ∅, |Z| ≡ n m</formula><p>for any constants n, m. Most of those are shown in <ref type="bibr">[24, p88]</ref>.</p><p>The unary predicates on words definable in WSkS are precisely the regular sets <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref></p><formula xml:id="formula_17">. A binary relation R ⊆ { 1, . . . , k } * × { 1, . . . , k } * is called special if it is of the form { (ab, ac) | a ∈ L, b ∈ M, c ∈ N }</formula><p>for some regular sets L, M , and N . A binary relation on words is definable in WSkS iff it is a finite union of special relations <ref type="bibr" target="#b25">[26]</ref>. Some relations which are known not to be expressible in WSkS are z = z z , z = iz , z is a suffix of z , z and z have the same length, Z and Z have the same cardinality. Let us note that what is definable largely includes the kinds of specifications about suffixes which we need for applications and, conversely, that the dangerous properties highlighted in the next section are not expressible: one cannot handle suffixes and prefixes at the same time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Showing Decidability of CMso(Θ WSkS )</head><p>Let Θ WSkS be the set of WSkS-definable relations on strings on the alphabet A, with the letters of A taken as successor functions, along with fresh letters $ and /, not in A; we show the decidability of CMso(Θ WSkS ) by encoding this logic into WSkS itself. This is an indirect way to encode it into automata, as WSkS's own decidability is obtained by such an encoding.</p><p>We adopt a convention to encode nodes and edge labels as strings handled by WSkS. For that purpose, / acts as a separator and $ as an additional symbol to distinguish multiple instances of the same label within an arity; recall that we have multisets of labels, yet need to deal with them in a logic -WSkSacting on sets. Following this convention, a tree is encoded by a set of strings, as illustrated on an example by Figure <ref type="figure" target="#fig_4">4</ref>. Formally, the encoding t of a tree t = {| d 1 : t 1 , . . . , d n : t n | } is defined as follows:</p><formula xml:id="formula_18">t = • • • • • b b c • • a • f f g t = { ε, f /, f $/, f $/a/, g/, g/b/, g/b$/, g/c/ } (8)</formula><formula xml:id="formula_19">t = {ε} ∪ d i $ mult(t,i,di) /e i ∈ 1, n , e ∈ t i ,<label>(9)</label></formula><p>where the mult function counts how many identical data values have previously been encountered:</p><formula xml:id="formula_20">mult(t, i, d) = |{ k ∈ 1, i -1 | d k = d }|.</formula><p>The encoding of the tree t also establishes, in the obvious way, the encoding v of the nodes v ∈ V t , and the encoding of a set of nodes -it is the set of the encodings.</p><p>At this point, let us note that a given tree t might have several equivalent alternative encodings, depending on the order in which the children sharing a label are distinguished by additional $s. All of those describe the same structure and would be equally valid. Those variations in encoding are of no consequence for the satisfiability of the formulae which we develop, as every predicate that follows will ignore the number of $. To avoid any confusion as to the nature of the object t, we fix an arbitrary total order on trees (and pairs of data values and trees) so that the decomposition t = {| d 1 : t 1 , . . . , d n : t n | } is unique, and use specifically the encoding (9) defined above to assign $s. Thus t refers to that one encoding among the other possibles.</p><p>We now encode the father/child relation, getting the arity of a node, and checking that a given set of strings describes a valid tree structure. The child relation is expressible in WSkS: take the special relation</p><formula xml:id="formula_21">↓ ≡ { (a, ab) | a ∈ ((A * $ * )/) * , b ∈ A * $ * / }. Note that ((A * $ * )/)</formula><p>* matches the possible path prefixes, and A * $ * / the last data value, if available, along with the distinguishing $s and separator / which we can expect to find along with it if the strings are well-formed node encodings. Then we have the encoding for the child relation:</p><formula xml:id="formula_22">v ↓ t v ⇔ v ↓ v ,</formula><p>and from there, we can test whether a given set variable Z describes a correct tree structure, by making sure that every node coded into that set has a father there, except for the root node, which does not:</p><formula xml:id="formula_23">istree(Z) ≡ ∀z . z ∈ Z =⇒ ( z = ε ∨ ∃z . z ∈ Z ∧ z ↓ z ) .</formula><p>Of course, we are now able to extract the arity of a node -here defined as the set of its children nodes -for the purposes of evaluating counting constraints. </p><formula xml:id="formula_24">S ≡ { (ab, ac) | a ∈ ((A * $ * )/) * L, b ∈ M $ * /, c ∈ N $ * / }.</formula><p>The encoding θ of θ is the union of the encodings of the special relations composing θ. Using this, the encoding of filters becomes trivial.</p><p>We move on to handling counting constraints ψ, which is simply a matter of showing that WSkS can encode the primitives |Z| m -which is easy -and |Z| ≡ n m -which rests on a total order such as the lexicographic one, and on the idea of affecting each element in turn to a second-order variable corresponding to the value of the modulo. Those methods are folklore.</p><p>There remains to encode the Mso layer, with Z t being the free variable standing for a tree encoding; the only non-trivial case is x ∈ ψ ≡ ∀z, Z . z = x ∧ ar(Z t , z, Z) ⇒ ψ. Through this encoding, ξ is satisfiable if and only if istree(Z t ) ∧ ξ is.</p><p>Theorem 1. Satisfiability of CMso(Θ WSkS ) is decidable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">The Frontiers of Decidability</head><p>As mentioned before, our decidability results for CMso(Θ WSkS ) are dependent on two kinds of limitations: restrictions of the scope of data comparisons to siblings, and of the expressive power of the string comparisons themselves, disallowing for joint manipulations of suffixes and prefixes. In this section, we shall see that attempts to relax those constraints, even slightly, quickly yield undecidable logics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Data tests beyond siblings: uncles/nephews &amp; cousins</head><p>We will show that data equality tests between uncles and nephews lead to a Mso logic where satisfiability is undecidable.</p><p>Equality tests between uncles and nephews. We define the logic Mso uncle (CC(Θ id )) -abbreviated into CMso uncle (Θ id ), where Θ id = {θ id }, θ id being the equality relation over A * , and add a new atom at the level of Mso statements, which is to say that statements ξ are as given before, with the following addition to the syntax:</p><formula xml:id="formula_25">ξ ∈ Mso uncle (Ψ) ::= . . . | x ∼ uncle y .</formula><p>Intuitively, x ∼ uncle y tests two things: ( ) the node x is an uncle of y, and ( ) the data values of x and y are equal. Formally, the semantics is defined as:</p><formula xml:id="formula_26">t, I |= x ∼ uncle y ⇔ t (I(x)) = t (I(y)) ∧ ∃z . (x t z)∧(z = x)∧(z ↓ t y) .</formula><p>Note that this is less general than having a general data equality test x ∼ y, since the positional uncle/nephew relation can be expressed inside the logic itself. However, this is still a comparison of data values in different arities. Even that restricted power leads CMso uncle (Θ id ) to have undecidable satisfiability.</p><p>x qini Theorem 2. Satisfiability is undecidable for CMso uncle (Θ id ).</p><formula xml:id="formula_27">x q ∈ X q ∅ x x q ∈ X q z y X q ∅ x q fin ∼ uncle ∼ uncle ∼ uncle ∼ uncle ∼ uncle ∼ uncle a in a i1 # b j1 b jm b jm+1 a in a in+1 a i1 # b j1 b jm ... ... ... ...</formula><p>Proof. We proceed by reduction of the accessibility problem for a Minsky machine M with a set of states Q and two non-negative counters c 1 , c 2 . Rules of a Minsky machine go from one state to another, and can increment/decrement c 1 or c 2 , test if the current value of c 1 or c 2 is 0, or any combination of these actions. For example, q</p><formula xml:id="formula_28">c1++,c2-- -------→ c1=0</formula><p>q is a rule that executes if c 1 = 0, going from a state q to another state q , incrementing c 1 , and decrementing c 2 . To simplify our proof, we make some basic assumptions about M . The starting configuration is q ini (c 1 = 0, c 2 = 0), and q ini cannot be visited again. We want to know if a state q fin is accessible.</p><p>We give an intuition on how to build the formula of CMso uncle (Θ id ) satisfied by trees describing runs of the Minsky machines, terminating in q fin . The tree which we describe follows the schema of Figure <ref type="figure" target="#fig_5">5</ref>. The set variables X q store the "spine" nodes of the tree. Each spine node belongs to exactly one set X q , corresponding to a state q of our Minsky machine. It has three types of children: ones labeled by different words of a + , ones labeled by different words of b + , and the following spine node, labeled #. The value of the first counter c 1 is encoded by the number of distinct a + -children a node has. Similarily, the value of c 2 is encoded by the number of b + -children a node has. To ensure that all words of a + and b + are distinct, we can say that all nodes of any X q should satisfy (#[x ∧ θ id .¬x] 1) = ∅.</p><p>The root node is x qini , the only element of X qini , and has only the next spine node as a child since c 1 and c 2 start at 0. We stop the run as soon as x q fin , the only node of X q fin , is reached. Going one level down in the tree is the same as using a rule in M . To ensure that we keep track of the counter's values, we use ∼ uncle . For example, imagine two consecutive nodes of the spine: x q ∈ X q , its child x q ∈ X q , and q c1++,c2---------→ q , a rule of M . We must ensure that x q has exactly one fewer a + -child than x q , and exactly one more b + -child. To this end, we ensure that if x is an a + -child of x q , which can be expressed as x q ∈ #[a + ∧ x] = 1 , then it has a nephew y of same label. Conversely, every a + -child of x q has an uncle of same label except for a unique z.</p><formula xml:id="formula_29">∀ x . x q ∈ #[a + ∧ x] = 1 ⇒ (∃ y . x ∼ uncle y) ∧ ∃ z . x q ∈ #[a + ∧ z] = 1 ∧ ¬∃ z . z ∼ uncle z ∧ ∀ y . z = y ∧ x q ∈ #[a + ∧ y ] = 1 ⇒ ∃ x . x ∼ uncle y</formula><p>Symmetrically, we can ensure that x q has one more b + -child than x q . Should a transition of M have a guard c 1 = 0, one can easily check that a node has no a + -child.</p><p>To model a run, we say that each node of the spine leads to the next one using a rule of M , until q fin is reached, which is to say that X q fin is not empty. Such a tree exists if and only if there exists a run from q ini (c 1 = 0, c 2 = 0) that reaches q fin in M . Note that there may appear, in the solution trees, nodes not represented in Figure <ref type="figure" target="#fig_5">5</ref>; they simply have no role to play in the construction and do not affect the formula's satisfiability.</p><p>As has been noted before, this also entails the undecidability of a logic CMso ∼ (Θ id ) equipped with a data equality test x ∼ y between arbitrary positions, as this is a strictly more powerful logic. The construction above can also straightforwardly be adapted to show undecidability of extensions with variants of x ∼ uncle y, such as data equality with great-uncles etc. The factors which make the argument work are, in general terms, the ability to regroup the X u and X v into arities to modify them simultaneously, and to move the resulting information from arity to arity. root Equality tests between cousins. To illustrate this fact, another variant that is also undecidable is CMso cousins (Θ id ), defined as CMso uncle (Θ id ) but this time, with a data equality test ∼ cous between cousins instead of uncles and nephews. The proof -again, an encoding of a Minsky machine -is extremely similar to the previous one, and we shall present it more briefly.</p><formula xml:id="formula_30">x qini x q ∈ X q z x q ∈ X q z x q fin . . . . . . . . . . . . . . . . . . . . . . . . # c kini # c k a in b jm+1 c k # a in+1 c k b jm c k # c k fin ∼ cous ∼ cous ∼ cous ∼ cous ∼ cous c 1 + +, c 2 --</formula><p>As illustrated in Figure <ref type="figure" target="#fig_6">6</ref>, the idea is again to use accessibility in a Minsky machine M with two counters c 1 , c 2 , under the same assumption as previously, plus a new constraint: there are no two reverse rules. For example, if q c1++,c2---------→ q is a rule of M , then q c1--,c2++ -------→ q is not a rule of M .</p><p>The tree we consider is of height two. The set variables X q cover the children of the root, labelled by #. Each of these nodes represent a step of the Minsky machine. Just like previously, each node of X q has a number of a + -children representing c 1 , and a number of b + -children representing c 2 . The trick to this proof is to ensure that these configurations can be sequenced into a run. While ∼ uncle made this possible thanks to the spine being read from the root to the leaves, it is not as easy in the case of unordered cousins. To this end, we place identifiers in the form of nodes labeled by words of c + . If two nodes x q ∈ X q and x q ∈ X q represent consecutive steps in a run of M , then they share cousins of same label c k , that never appears elsewhere. Each step is linked to both its previous and next neighbour, meaning each node of any X q has two c + -children, except for the first element (of X qini ) and the last element (of X q fin ), that only have one.</p><p>The following formula ensures that any c + -child z can only be matched to one other cousin of same label.</p><formula xml:id="formula_31">∀ z . ∃x ∈ #[c + ∧ z] = 1 ⇒ ∃ z . z ∼ cous z ∧ ¬∃ z = z . z ∼ cous z</formula><p>From there it is easy to see if x q and x q are consecutive:</p><formula xml:id="formula_32">∃ z, z . x q ∈ #[c + ∧ z] = 1 ∧ x q ↓ z ∧ z ∼ cous z</formula><p>The encoding of two successive configurations is the same as above. Note that forbidding reverse rules implies that no confusion is possible as to which configuration comes before which.</p><p>Note that, perhaps counter-intuitively, these proofs would not work by the combination of our usual data tests between siblings and a new data equality test between father and son, which we could define as follows:</p><formula xml:id="formula_33">t, I |= x ∼ father y ⇔ t (I(x)) = t (I(y)) ∧ x ↓ t y . (<label>10</label></formula><formula xml:id="formula_34">)</formula><p>The reason this could not work is that we need several equality tests between one level of Figure <ref type="figure" target="#fig_5">5</ref> and the next. The father can use its label to propagate an equality test for one of these elements, but not for all at the same time. For that reason, the constructions above do not in themselves preclude the decidability of an extension like CMso father (Θ id ). Determining whether it is decidable, and if so, if it would remain decidable with larger Θ, is an open problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Expressive power of data tests</head><p>In this section, we exhibit conditions on the expressive power of the class of data constraints Θ sufficient to render satisfiability for CC(Θ), and therefore for CMso(Θ), undecidable. As we shall see, not much is needed. Even merely allowing Θ to express the addition or removal of a single letter at the beginning or end of a word is enough; the argument developed in the next theorem is that even this is sufficient to encode the solution of the Post Correspondence Problem.</p><p>Theorem 3. Let Θ prefix+suffix be the set of string relations of the forms w → wa, w → aw, wa → w, or aw → w, with a ∈ A, w ∈ A * . Then CMso(Θ prefix+suffix ) is undecidable.</p><p>Proof. We reduce the Post Correspondence Problem, with input dominoes [ u1 v1 ], . . . , [ un vn ]. Let us write the relations in Θ prefix+suffix as θ +a , θ a+ , θ -a , and θ a-, respectively. Given a word w = a 1 . . . a m , by abuse of notation we abbreviate θ +a1 . . . . θ +am .φ into θ +w .φ. Although Θ prefix+suffix is not closed by composition, this construction enables us to pretend that it is -the difference is that it requires the existence of siblings for each intermediate step, which does not affect us. θ w-.φ is defined likewise. θ am+ . . . . θ a1+ .φ is written θ w+ .φ, and likewise again for θ -w .φ.</p><p>Let $ 1 , $ 2 ∈ A be fresh symbols not appearing in any domino, serving as markers for the first and the second phase of the construction. Informally, in the first phase, we place dominoes so that each u mirrors the corresponding v; in the second phase, we consume the result letter by letter, from both ends simultaneously, until everything is read (in which case we have read a solution), or it becomes impossible to read the same letter at beginning and end (in which case what we are reading is not a solution).</p><p>The mirror of a string u is written u. The operation for "placing domino i around previous dominoes" is defined as θ i .φ ≡ θ $1-.θ ui+ .θ +vi .θ $1+ .φ, "accepting dominoes" is θ acc .φ ≡ θ $1-.( * 1 ∧ θ $2+ .φ), where * 1 matches any string of length 1, to avoid the empty sequence as a trivial solution; "reading a on both ends" is</p><formula xml:id="formula_35">θ a .φ ≡ θ $2-.θ a-.θ -a .θ $2+ .φ. Abbreviating θ. * or θ. into simply θ, consider now the formula γ ∈ CC(Θ prefix+suffix ) = #[$ 1 ] = 1 ∧ #[$ 2 ] = 1 ∧ #[$ 1 * ∧¬(θ 1 ∨ • • • ∨ θ n ∨ θ acc )] = 0 ∧ #[$ 2 * ∧¬( a =$1,$2 θ a )] = 1 .</formula><p>It is satisfiable iff there is a tree whose arity contains $ 1 , $ 2 , and such that every label beginning with $ 1 (i.e. phase one) has a sibling (along with the intermediate siblings) obtained either by placing some domino so that u i mirrors v i , staying in phase one, or by moving to phase two. At this point, a label is of the form $ 2 u i k . . . u i1 v i1 . . . v i k . Furthermore, all but one label beginning with $ 2 (i.e. all but $ 2 ) have a sibling obtained by removing the same letter at the beginning and the end; all letters must be read until only $ 2 remains. Thus, γ is satisfiable iff there are i 1 , . . . , i k such that u i1 . . . u i k = v i1 . . . v i k . This shows that CC(Θ prefix+suffix ) is undecidable. This carries over to CMso(Θ prefix+suffix ): consider the formula ∃x . x ∈ γ.  Note that we could similarly argue that merely being able to replace factors inside words yields undecidability. This can be done either by reduction to the previous case, or directly by reduction to termination of a Turing machine. Indeed, as illustrated in Figure <ref type="figure" target="#fig_8">7</ref>, the transitions of Turing machines are straightforwardly seen as factor replacements -the factors being in fact of size at most 3.</p><p>The message from this section is therefore: as soon as Θ is capable of dealing with factors, or with prefixes and suffixes, decidability is in jeopardy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">A More Efficient Restriction</head><p>In Section 3, we showed that CMso(Θ WSkS ) has decidable satisfiability, by reduction to a WSkS formula. However in the absence of a bound on quantifier alternations in the WSkS encoding, a direct implementation may not, a priori, do better than a non-elementary complexity. To have well-defined complexity bounds, it is usually more advisable to work with tree automata rather than in tree logics. In a previous publication <ref type="bibr" target="#b16">[17]</ref>, we explored the comparative complexities of Mso logic and automata on unordered trees, both enriched with various types of arity constraints. Notably, in Proposition 43, it is shown how the complexity of the emptiness problem for such automata is linked to the satisfiability problem for an arity constraint.</p><p>Unfortunately, the classes considered in <ref type="bibr" target="#b16">[17]</ref> do not permit data comparisons between siblings. At the other end of the spectrum, CC(Θ WSkS ) has no known complexity results that an class of automata could benefit from. Fortunately, in many cases we do not need the full power of Θ WSkS , and it is possible to find restrictions with known complexity and expressive enough for our applications. The present section deals with such a restriction.</p><p>Recall that our primary motivation is to handle the string relations Θ suffix , of the form θ u,u = { (wu, wu ) | w ∈ A * }. In practice, one does not need to deal with transformations from and to all possible suffixes; instead, there are a few small groups of related suffixes in play at a time, such as ".tex", ".dvi", and ".pdf", or maybe ".cpp" and ".exe", so that at any point we only need to deal with a few specific suffix transformations. Oftentimes, the suffixes in question are disjoint in the sense that none of them is a suffix of another suffix in the same group: ".tex" is not a suffix of ".pdf", and vice-versa. Thus no word can admit both ".tex" and ".pdf" as a suffix. For short, we say that the suffixes are mutually exclusive. For our applications, the traditional dot in file extensions makes this an almost universal case. We will see that these restrictions yield an easier satisfiability test than in the general case.</p><p>Let L = { w 1 , . . . , w n } be a set of mutually exclusive suffixes: there are no i = j such that w i is a suffix of w j . Let Θ L be the set of string relations θ wi,wj linking uw i to uw j . The corresponding class of counting constraints is, as usual, CC(Θ L ). However we shall need an additional restriction: recall that CC(Θ L ) is shorthand for CC(Φ regexp + siblings (Θ L )), and that filters of Φ regexp + siblings (Θ L ) can use any regular expression to test edge labels. So far, this has made no difference, but in this section, regular expressions testing labels may only be of the form A * w, for some w ∈ L. That is to say, they must be coherent with the choice of suffixes we are dealing with. We denote by CC sufL the class of counting formulae of CC(Θ L ) restricted this way.</p><p>To efficiently decide satisfiability of a formula of CC sufL , we use a small-model argument, then we nondeterministically guess a solution. We shall later use this logic in a class of bottom-up automata named aut(Θ L ) (see <ref type="bibr" target="#b16">[17]</ref>). Intuitively, they are bottom-up automata on data trees, with rules of the form γ → q; to evaluate a tree in q, they test a counting constraint γ, in this case of CC sufL , on the children of the tree's root. That constraint has access to the states in which the children trees have been evaluated in the same way as the counting constraints used within Mso had access to the Mso variables. Before we define those automata, we need a few further observations on annotations by variables.</p><p>Assume that our arities are already annotated by finite sets X ⊆ X of secondorder variables. An arity is therefore of the form</p><formula xml:id="formula_36">M = {| d 1 : X 1 , . . . , d n : X n | } . (<label>11</label></formula><formula xml:id="formula_37">)</formula><p>Note that this is not exactly a tree; however, to define what it means that M is a solution of ψ, we see it as a flat tree, i.e. a tree of height 1, t M :</p><formula xml:id="formula_38">t M = root v n v i v 2 v 1 d 1 d 2 d i d n , (<label>12</label></formula><formula xml:id="formula_39">)</formula><p>with a corresponding variable assignment</p><formula xml:id="formula_40">I M . It is such that v i ∈ I M (X) iff X ∈ X i .</formula><p>We say directly that an arity M satisfies the constraint ψ, written</p><formula xml:id="formula_41">M |= ψ, if root ∈ ψ t M ,I M .</formula><p>For filters, we write M, d i :</p><formula xml:id="formula_42">X i |= φ iff v i ∈ φ t M ,I M .</formula><p>These set variables X correspond to state labellings of an automaton of aut(Θ L ), which is standard procedure when using Mso in automata. Indeed, a state q during the run of an automaton can be seen as the set of nodes which are evaluated in q, and thus corresponds naturally to a set variable. If we consider vertically deterministic automata of aut(Θ L ) <ref type="bibr" target="#b16">[17]</ref>, where each tree is evaluated in at most one state, the variables X are mutually exclusive, which is to say each X i has at most a single element.</p><p>We now define the class of automata aut(Θ L ). As is often done in the literature (see <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b16">17]</ref>), we create a bottom-up automata class where the rules are the formulae of interest, in this case constraints of CC sufL .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 (aut(Θ L )</head><p>). An alternating bottom-up automaton (aut(Θ L )) for unordered unranked trees on data values A * is a tuple A = A, Q, Q fin , R where Q is the finite set of (vertical) states,</p><formula xml:id="formula_43">Q fin ⊆ Q the subset of final states,</formula><p>and R ⊆ CC sufL × Q is the finite set of (vertical) transition rules; the variables in the formula of CC sufL are the states of Q.</p><p>We shall write ψ → q for a rule (ψ, q) ∈ R. Any automaton A evaluates any tree with data values A * to a set of states. This set is defined by induction on the structure of trees such that for all n ≥ 0, data values d 1 , . . . , d n ∈ A * and trees t 1 , . . . , t n :</p><formula xml:id="formula_44">{| d 1 : t 1 , . . . , d n : t n | } A = { q | {| d 1 : t 1 A , . . . , d n : t n A | } |= ψ, ψ → q ∈ R } .</formula><p>Note that this formalism is alternating: it considers all states assigned to subtrees when applying a transition rule, and not only one of them nondeterministically.</p><p>An automaton is said to be deterministic if for every tree t, t A has at most one element. The language accepted by A is defined as</p><formula xml:id="formula_45">L(A) = { t | t A ∩ Q fin = ∅ } .<label>(13)</label></formula><p>Following <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b16">17]</ref>, classical problems such as emptiness or membership on automata of this form are generally only as hard as the same problem for the logic used in the rules. We shall see in Thm. <ref type="bibr">4 [p22]</ref> that this applies in our case as well. This means that to decide emptiness for automata of aut(Θ L ), we shall study the satisfiability problem for CC sufL . We propose to solve this problem by nondeterministically guessing a solution.</p><p>As we shall see in the first lemma, having restricted ourselves to mutually exclusive suffixes, we can "cut" an arity in independent parts. For instance, if L = { ".tex", ".pdf" }, then given a child, say, "foo.tex", only itself and an hypothetical "foo.pdf" are relevant to any given filter. The remainder of the arity can be ignored. In this way, by restricting ourselves to a fixed set of suffixes, we have also bounded the reach of filters within arities.</p><p>More generally, to see if an element labelled uw i satisfies a filter φ, we do not need to consider the whole arity M , but only the part of it where the edges are labelled in uL. We call that the orbit of uw i under the action of all θ wi,wj , and write it M u . We have</p><formula xml:id="formula_46">M u = {| d : X | (d : X) ∈ M, d ∈ uL | } . (<label>14</label></formula><formula xml:id="formula_47">) Lemma 1. Let M = {| d 1 : X 1 , . . . , d n : X n | }. Let d : X ∈ M such that d = uw i . For any filter φ, we have M, d : X |= φ if and only if M u , d : X |= φ.</formula><p>Proof. Examining the semantics of φ, it is immediate that the only operator to consider another part of the arity is θ.φ . That is to say that whether d : X is selected by φ or not only depends on sibling elements d k : X k accessible from d with operators θ.φ . Since our θ can only express links of the form uw i to uw j , these accessible elements of M are exactly those of data in uL, i.e. the orbit M u .</p><p>Thus we do not need to consider an arity as a whole, but orbit by orbit. This means that to solve satisfiability, we can guess a solution orbit by orbit. The next lemma will show that the size and number of orbits required to guess a valid arity is limited by this small-model theorem:</p><p>Lemma 2. If ψ is satisfiable, then we can find a solution using an exponential number of orbits of exponential size.</p><p>Proof. If #φ n appears in a formula ψ, we need to keep track of how many elements are selected by φ in a counter; it is sufficient for it to range over 0, n + 1 . Likewise, if #φ ≡ m n appears in ψ, it is sufficient for the corresponding counter to range over 0, m -1 . The total number of configuration for these counters is the product of the configurations of each counter. This leads to an exponential number of configurations N O(2 |ψ| ).</p><p>Consider M , a solution of ψ. In one of its orbits M u , whether an element is selected by φ depends only on the existence of the other elements, not their multiplicity. Hence, we can remove an element d : X without disturbing the filter as long as we do not erase "the last element" (multiplicity 1).</p><p>This enables us to use a classic small-model or pumping argument for constraints ψ, if we see their evaluation as an automation reading the arity element by element -and element being of the form d : X here. For each orbit M u , if the multiplicity of an element d : X is at least N + 1, then necessarily a configuration must be encountered twice. By removing extraneous elements -which can be done without affecting filters, as we have said -we can thus obtain M , another solution of ψ whose multiplicity for each element d : X is smaller than N + 1.</p><p>Any orbit M u has at most an exponential number of different elements, as |uL| is bounded, and if we consider only the variables of X that appears in ψ, there are fewer than 2 |ψ| possible X. Therefore, all orbits within M are of exponential size at most. Furthermore, since orbits are independent (see Lemma 1), we can remove one from M without disturbing the others. Again, by a classic small-model argument, if there are more than N orbits in M , then there exists M , another solution of ψ with at most N orbits. In the end, M has at most an exponential number of orbits, each of size at most exponential.</p><p>We now combine these lemmas to obtain a way to guess a solution for a formula of CC sufL orbit by orbit. We know a bound on the size and number of orbits needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.</head><p>The satisfiability problem for an arity formula of CC sufL is decidable in NExpTime. Furthermore, if the variables X are mutually exclusive, the satisfiability problem for an arity formula of CC sufL is decidable in PSpace.</p><p>Proof. Lemma 1 tells us we can guess a solution orbit by orbit. Lemma 2 tells us we can use only orbits whose cardinality is smaller than 2 |ψ| . First, we need counters to remember the orbits we already read. As argued before, we need a counter capped at n for #φ n, and a counter modulo m for #φ ≡ m n. All these counters start at 0, and take a space smaller than |ψ|. Then, we guess an orbit. To guess an orbit of prefix u, we need to know how many uw i annotated by X i are in the orbit, for each w i in our suffix and X i set of variables. Guessing an orbit is picking a number between 0 and 2 |ψ| (size ≤ |ψ|) for each pair w i , X i . Each orbit is guessed and stored in exponential time. We then evaluate each pair w i , X i of the orbit for each filter φ that appears in ψ. This is done in polynomial time for the size of the orbit and formula ψ. Each counter is updated accordingly.</p><p>If the new counter configuration satisfies ψ, we found a solution.</p><p>In all cases, the time needed is exponential: this algorithm is in NExpTime. However, if variables X are mutually exclusive, then an orbit can only have a polynomial number of different elements (data in uL, X with one or zero elements). Therefore, the orbits can be stored in a polynomial amount of memory. Since a given configuration of the counters can also be stored in a polynomial amount of memory, this algorithm is in PSpace.</p><p>We can then use techniques similar to those of <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b16">17]</ref> to extend our results to the class aut(Θ L ) of bottom-up automata with rules ψ → q, where ψ are formulae of CC sufL .</p><p>Theorem 4. The emptiness problem for automata in aut(Θ L ) is decidable in NExpTime. Furthermore, for deterministic automata of aut(Θ L ), the emptiness problem is decidable in PSpace.</p><p>Proof. To decide the emptiness of the language of an automaton A = A, Q, Q fin , R , we use a variant of classical reachability algorithms to find all possible annotations for a subtree.</p><p>For each state q ∈ Q, we note ψ q = ψ→q∈R ψ. We note that an arity is annotated by q if and only if it satisfies ψ q . We can also build, for any part Q ∈ ℘(Q), a constraint ψ Q such that an arity is annotated by Q if and only if it satisfies ψ Q :</p><formula xml:id="formula_48">ψ Q = q∈ Q ψ q ∧ q ∈ Q ¬ψ q . (<label>15</label></formula><formula xml:id="formula_49">)</formula><p>Note that |ψ Q | is polynomial in the size of A.</p><p>We try to build all possible annotations. This computation will be recursive:</p><p>If the empty arity satisfies ψ Q , then Q is a possible annotation.</p><formula xml:id="formula_50">If M = {| d 1 : Q 1 , . . . , d n : Q n |</formula><p>} is an arity where each Q i is known to be a possible annotation, then Q is a possible annotation.</p><p>This translates as an algorithm as follows: We have a variable S ⊆ ℘(Q) to store all possible annotations. It starts as { Q 0 }, where is Q 0 is the set of states such that {| | } |= ψ q -thus it is the annotation for leaves.</p><p>We then have the following loop: while there exists Q ∈ S such that there exists M = {| d 1 : Q 1 , ...d n : Q n | } where each Q i ∈ S, and M satisfies ψ Q , or in other words, whenever Q becomes reachable from S, we add Q to S for the next iteration: S := S ∪ { Q}.</p><p>In the end, S is the set of all possible annotations. L(A) is empty if and only if there is no</p><formula xml:id="formula_51">Q ∈ S such that Q ∩ Q fin = ∅.</formula><p>Concerning the complexity of the algorithm: for an alternating automaton, each passage in the loop proves the accessibility of an annotation Q. In the worst case scenario, every annotation is needed to prove the non-emptiness of A. This loop stops as soon as it cannot add a new element to S, so it occurs at most an exponential number of times: this algorithm is in NExpTime.</p><p>In a deterministic automaton, however, the possible annotations are either singletons {q}, or empty. Thus there are only |Q| + 1 different annotations to consider. Each passage in the loop can test the satisfiability with mutually exclusive variables (in PSpace) of a linear number of ψ {q} to find a new element for S. This loop stops as soon as it cannot add a new element to S, ans thus occurs at most a linear number of times: this algorithm is in PSpace.</p><p>Note that these results are only as good as CC(Θ L ) is a good approximation of the expressivity needed on arity constraints. Should a tighter restriction have a satisfiability decidable in better complexities, it would generate a better automaton class. As discussed in <ref type="bibr" target="#b16">[17]</ref>, Propositions 42 and 43, should one find a class of arity constraints where satisfiability is in PTime, then the resulting deterministic automaton class would have membership and emptiness problem decidable in PTime as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">A Decidable Extension to Subtree Equality Tests Between Brothers</head><p>We can extend the methods of Section 5 to a wider logic: we consider automata of aut(Θ L ) with additional tests for structural equality of subtrees between brothers (as seen in <ref type="bibr" target="#b27">[28]</ref>). We prove that our small model theorem still applies, and continues to yield a NExpTime result for the emptiness problem. It is important to note that the method presented here does not preserve the PSpace results for deterministic automata.</p><p>We start by defining our class, as an extention of aut(Θ L ) where Θ L can also test equality or inequality of subtrees. To this end, in our logic CC sufL , each θ is replaced by two versions: θ = and θ = . We get the new definition of filters: The semantics of θ = and θ = uses subtrees under the node we examine. We note t|v the subtree under node v in a tree t. We give the following definition, which is identical to that of θ.φ, with the addition of the subtree (dis)equality tests:</p><formula xml:id="formula_52">θ = .φ t,I = v ∃v . v t v ∧ ( t (v), t (v )) ∈ θ ∧ v ∈ φ t,I ∧ t|v = t|v θ = .φ t,I = v ∃v . v t v ∧ ( t (v), t (v )) ∈ θ ∧ v ∈ φ t,I ∧ t|v = t|v</formula><p>We call CC =, = sufL the counting constraints on this logic, with the same restriction on regular expressions as CC sufL in the previous section. Since this logic needs information on the annotations and subtrees of an arity, it will be evaluated on an arity of the form M = {| d 1 : (t 1 , X 1 ), . . . , d n : (t n , X n ) | }. Just like we did in Section 5, we define aut(Θ =, = L ) as automata where each rule is a formula of CC =, = sufL . An important note to make is that since we want to test satisfiability of a formula of CC =, = sufL in order to solve the emptiness problem in aut(Θ =, = L ), we have to consider a slightly modified satisfiability problem. Indeed, we now must check that when an orbit is presented, it represents a feasible configuration. This can be a problem for two different reasons. The first one is that when a certain annotation is used for several different subtrees, we must check that enough trees with this annotation exist. To solve this, we are reminded that the only tests we have are of the form A * w. This means that if a word satisfies a test, then an infinite number of words satisfy this test, which means that if an annotation can be reached by a nonempty tree, then it is reached by an infinite number of trees. The second problem is that in an alternating automaton, two nodes with identical subtrees are annotated by the same set of states. To reflect that, we study the satisfiability problem with consistent annotations, which is to say that for M = {| d 1 : (t 1 , X 1 ), . . . , d n : (t n , X n ) | } to be a proper solution, we want that if t i = t j , then X i = X j .</p><p>As an example, consider the following arity, with 3 elements: To prove that the emptiness problem in aut(Θ =, = L ) is decidable in NExpTime, we follow the same pattern as in Section 5. First, we prove a small model theorem on CC =, = sufL . Then, we prove that satisfiability problem with consistent annotations in CC =, = sufL is decidable in NExpTime. Finally, we use the same method as in Theorem 4 to prove that the emptiness problem in aut(Θ =, = L ) is decidable in NExpTime.</p><formula xml:id="formula_53">M = {| uw i : ({| d 1 : ∅, d 2 : ∅ | }, {X, X }) ,</formula><p>Our first remark is that a variant of Lemma 1 still holds: for an element labelled uw i , θ = wi,wj and θ = wi,wj only consider elements of M u . Our second remark is that part of Lemma 2 still holds: the number of configurations for the counters is still exponential. This means that if a formula ψ of CC =, = sufL is satisfiable, then it has a solution with fewer than N O(2 |ψ| ) orbits. However, to ensure that each orbit can be of exponential size, we must see what part of a very large orbit can be removed without changing which elements satisfy filters φ.</p><p>To this end, we will further cut an orbit into its equivalence classes with the same subtree. Given an arity M = {| d 1 : (t 1 , X 1 ), . . . , d n : (t n , X n ) | }, we define its sub-orbit M u,t as the multiset of all elements d : (t, X) in M such that d ∈ uL. We will show that if a formula ψ is satisfiable, it has a solution where each orbit has an exponential number of sub-orbits.</p><p>In order to keep a small model theorem, we try and eliminate sub-orbits from a solution of ψ without changing which elements are selected by a filter φ. As before, a filter only concerns itself with existence or non-existence, therefore multiplicity has no impact on whether an element is selected by φ or not. We capture that using a notion of similarity: Definition 3. Two sub-orbits M u,t1 and M u,t2 are similar if t 1 and t 2 are annotated by the same X ∈ ℘(X ), and for every d ∈ uL, we have d :</p><formula xml:id="formula_54">(t 1 , X) ∈ M u,t1 if and only if d : (t 2 , X) ∈ M u,t2 .</formula><p>The equivalence class for similarity of a sub-orbit M u,t is entirely characterized by the labelling of t and by set of d ∈ uL occurring in the sub-orbit. Hence for a fixed prefix u, there are at most 2 |L|+|ψ| different equivalence classes for similarity (as in Part 5, there are fewer than 2 |ψ| possible X to consider).</p><p>We will see in the next lemma the expected property that two similar sub-orbits are indistinguishable from the point of view of a filter. Proof. The existence of d : (t 2 , X) ∈ M u,t2 for every element d : (t 1 , X) ∈ M u,t1 is a direct consequence of the definition of similarity. One can prove that it satisfies all the same φ as d : (t 1 , X) by induction on φ. This is trivially true for π or X (as both have same data and annotations). The induction is immediate for the ∧ or ¬ operators.</p><p>For θ = wi,wj , we know that d : (t 1 , X) satisfies θ = wi,wj .φ if d = uw i and there is in M u,t1 an element uw j : (t 1 , X) that satisfies φ. This means that there is in M u,t2 an element uw j : (t 2 , X) that, by induction, satisfies φ. We then have that d : (t 2 , X) satisfies θ = wi,wj .φ.</p><p>For θ = wi,wj , we know that d : (t 1 , X) satisfies θ = wi,wj .φ if d = uw i and there is in another sub-orbit an element uw j : (t 3 , X) that satisfies φ. If uw j : (t 3 , X) is not in M u,t2 , then d : (t 2 , X) satisfies θ = wi,wj .φ as well. If uw j : (t 3 , X) is in M u,t2 , then there exists uw j : (t 1 , X) in M u,t1 that satisfies φ by induction. Therefore, either way, d : (t 2 , X) satisfies θ = wi,wj .φ.</p><p>The last argument we need to get a small model theorem for CC =, = sufL is that if an orbit contains three or more similar sub-orbits, we can delete one without changing which filters select which element. Lemma 5. Let M u = {| d 1 : X 1 , . . . , d n : X n | } be an orbit. Let M u,t1 , M u,t2 , M u,t3 be three similar sub-orbits. Let d : (t, X) ∈ M u \M u,t3 . We have M u , d : (t, X) |= φ if and only if M u \M u,t3 , d : (t, X) |= φ.</p><p>Proof. Looking at the semantics of φ, the only operator to consider an element outside of the sub-orbit is θ = . We recall that M u , d : (t, X) |= θ = wi,wj .φ if there is an element d : (t , X ) ∈ M u such that d = uw i , d = uw j , M u , d : X |= φ and t = t .</p><p>We now consider several cases: if d : (t , X ) is not in M u,t3 , then removing M u,t3 does not change the fact that d : (t, X) is selected by θ = wi,wj .φ. Conversely, if d : (t , X ) is in M u,t3 , since M u,t1 , M u,t2 , M u,t3 are three similar sub-orbits annotated by the same X , there <ref type="bibr">Lemma</ref>  Hence, even if we remove d : (t , X ) from M u , there will be an element to "replace" it to ensure that M u , d : (t, X) |= θ = wi,wj .φ. If d : (t, X) is in M u,t1 , we choose d : (t 2 , X ) to "replace" d : (t , X ). Otherwise, we chose d : (t 1 , X ) to "replace" d : (t , X ).</p><p>We now have all the elements for our small model theorem: from a solution of ψ with consistent annotations, we can remove orbits until there is an exponential number of orbits, in each orbit we can remove similar sub-orbits until there is an exponential number of sub-orbits, and in each sub-orbit we can remove elements until their multiplicity is exponential. We then get the small model result we wanted: Lemma 6. If ψ is satisfiable with consistent annotations, then we can find a solution using an exponential number of orbits of exponential size.</p><p>From there, the reasoning is identical to what we can find in Section 5 for the NExpTime results: we can decide satisfiability of CC =, = sufL by guessing a solution orbit by orbit, and each orbit has an exponential size. Lemma 7. The satisfiability problem with consistent annotations for an arity formula of CC =, = sufL is decidable in NExpTime. We can use this result to obtain the complexity of the emptiness problem for aut(Θ =, = L ), as in the previous section. Theorem 5. The emptiness problem for automata in aut(Θ =, = L ) is decidable in NExpTime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions and Future Work</head><p>We have introduced the logic CMso(Θ WSkS ) on unordered data trees. It is an extension of CMso to data trees, where tests on a given node may include enforcing the existence of a sibling whose label is in relation with that node's own label, the relation being WSkS-definable. That logic's expressive power is largely sufficient for our targeted concrete applications, such as the verification of common constraints on file trees, which usually involve suffix manipulations, largely captured by WSkS. We have shown that satisfiability for CMso(Θ WSkS ) is decidable. However, we have also shown that any attempt to allow additional data relations for both prefix and suffix manipulations, even of the simplest kind, would render the logic undecidable, as would any extension allowing two or more independent data tests to be performed between data values present at different levels of a tree (such as uncle/nephew tests). We have also studied the complexity of the emptiness tests for automata where horizontal counting constraints are restricted to relations that only involve disjoint suffixes, and shown that the test is then NExpTime for alternating automata, and only PSpace for deterministic automata. Furthermore, under the disjoint suffix restriction, tests of structural equality or disequality of sibling subtrees can be added while preserving the NExpTime complexity result.</p><p>There are two main dimensions in which this work can be extended. One is to find more expressive string relations for which the logic remains decidable; our undecidability results indicate that such an extension may not be very natural. Another is to extend the reach of the string relation from merely the set of siblings to something larger. The result on (dis)equality constraints between brother subtrees is a first step towards such extensions.</p><p>A promising direction is the use of Monadic Datalog on data trees <ref type="bibr" target="#b28">[29]</ref>, which is capable of expressing relations not only with siblings but also with parents, cousins etc., and for which efficient algorithms are known. However, regardless of the chosen method, the search space for potential decidable extensions is much reduced by our undecidability result concerning the uncle/nephew extension and variants. Possibilities which remain open include father/child data relations, and new restrictions on the applicability of data tests.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>{</head><label></label><figDesc>"file.tex" : {"\documentclass...":{}},</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Unordered trees in Json format, describing a typical file tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Semantics of Mso(Ψ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>φ</head><label></label><figDesc>∈ Φ rel (Θ) ::= π incoming edge label matches π, | x | X equal to x or member of X, | θ.φ ∃ sibling satisfying φ with labels related by θ, | φ ∧ φ | ¬φ conjunction and negation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Encoding a tree as a set of WSkS strings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Using uncle/nephew data equality tests to encode accessibility in a Minsky machine. The dotted lines indicate constraints between data values. The dashed lines indicate omitted steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Using cousin data equality tests to encode a Minsky machine run. The dashed curve "c 1 + +, c 2 --" indicates that the relation between a + and b + children in the two linked arities is the same as in Figure 5, encoding the same incrementation/decrementation rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>s</head><label></label><figDesc>This configuration is represented by the word • • • xsyz • • •. Moving left and right, the factor xsyz becomes s xy z and xy s z, respectively. Thus transitions are coded by (at most) three-letter substitutions on factors like xsy.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Turing machine configurations and three-letter substitutions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>φ</head><label></label><figDesc>::= π incoming edge label matches π, | x | X node is x / a member of X, | θ = .φ ∃ sibling satisfying φ with labels related by θ with identical subtrees, | θ = .φ ∃ sibling satisfying φ with labels related by θ with different subtrees, | φ ∧ φ | ¬φ conjunction and negation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>uw j : ({| d 3 : ∅ | }, {X }) , uw k : ({| d 1 : ∅, d 2 : ∅ | }, {X, X }) | } The first and third element have the same annotations, since they have the same subtree. The filter θ = wj ,wi .X selects the second element, since uw i : ({| d 1 : ∅, d 2 : ∅ | }, {X, X }) has a different subtree, is annotated by X, and their data values are related via θ wj ,wi . The filter θ = wi,w k . * select the first element, since uw k : ({| d 1 : ∅, d 2 : ∅ | }, {X, X }) has the same subtree, and their data are related via θ wi,w k . However, θ = wi,w k . * does not select the first element.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Lemma 4 .</head><label>4</label><figDesc>Let M u be an orbit and M u,t1 , M u,t2 two similar sub-orbits. Let d : (t 1 , X) ∈ M u,t1 . Then d : (t 2 , X) ∈ M u,t2 , and for any filter φ ∈ CC =, = sufL , M u , d : (t 1 , X) |= φ if and only if M u , d : (t 2 , X) |= φ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>and t 1 , . . . , t n are trees. The data value d i is the label of the edge leading into the subtree t i . We generally take a Json-like record notation {| d 1 : t 1 , . . . , d n : t n | }. Thus we represent t by a structure V t , t , ↓ t , where V t is the set of nodes of t, t (v) is the data value labeling the edge leading into the node v -undefined for the root node, -and v ↓ t v holds if v is a child of v.</figDesc><table><row><cell>formalisation, we shall not consider edges as distinct objects, but instead see an</cell></row><row><cell>edge label as a property of the node into which the edge leads. Furthermore,</cell></row><row><cell>though the tree itself is defined as a multiset, its nodes form a set (through any</cell></row><row><cell>arbitrary ordering).</cell></row><row><cell>Those trees can be represented by the usual graphs,</cell></row><row><cell>discounting order: see Figure 2. The tree representing the Json document</cell></row><row><cell>of Fig 1 is therefore {| ("file.tex", {| ("\doc...", {| | }) | }), ("dir", . . . ) | }. To simplify the</cell></row></table><note><p>A. A data value over A is a string in A * . The trees under consideration are finite, unordered, unranked trees whose edges are labelled by data values in A * . Formally, a tree t is a multiset {| (d 1 , t 1 ), . . . , (d n , t n ) | } where d 1 , . . . , d n ∈ A *</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>V , . . . . We can now begin by encoding any child-selector φ as a WSkS formula φ with free variables z, Z (standing for the current node and its arity), such that for any tree t, interpretation I, and nodesv ↓ t v: t, I, v |= φ ⇐⇒ I[z → v, Z → ar(t, v )] |= φ. Recall that π ⊆ A * ,and that all regular expressions are expressible in WSkS; we have π ≡ ((A</figDesc><table /><note><p><p><p>The predicate ar(t, z, Z) tests that Z is the arity of node z in the tree encoding t: ar(t, z, Z) ≡ ∀z . z ∈ Z ⇔ (z ↓ z ∧ z ∈ t). Note that it relates to the arity function on trees in the following way, given a tree t, a node v ∈ V t and a variable assignment I: ar(t, v, Z) ⇐⇒ ar(t, v) = I(Z). Variable assignments are encoded in the obvious way, given that to each variable x or X we associate a WSkS variable x or X:</p>{ . . . , x → v, X → V, . . . } ≡ . . . , x → v, X → * $ * )/) * π$ * /.</p>Likewise for relations θ; since they are WSkS-definable, they are finite unions of special relations, which are of the form S = { (ab, ac) | a ∈ L, b ∈ M, c ∈ N }, where L, M, N ⊆ A * are regular languages. The encoding of such a special relation is</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>4 gives us d : (t 1 , X ) ∈ M u,t1 and d : (t 2 , X ) ∈ M u,t2 such that M u , d : (t , X ) |= φ if and only if M u , d : (t 1 , X ) |= φ if and only if M , d : (t 2 , X ) |= φ.</figDesc><table /></figure>
		</body>
		<back>

			<div type="funding">
<div><p>$ Extended version of [1]. This work has been partially supported by the the project <rs type="funder">ANR</rs> <rs type="projectName">CoLiS</rs> (contract <rs type="grantNumber">ANR-15-CE25-0001</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_c4NVTUH">
					<idno type="grant-number">ANR-15-CE25-0001</idno>
					<orgName type="project" subtype="full">CoLiS</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Logics for unordered trees with data constraints on siblings</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boiret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hugot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Treinen</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-15579-1_13</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-319-15579-1_13" />
	</analytic>
	<monogr>
		<title level="m">Language and Automata Theory and Applications -9th International Conference, LATA 2015</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">H</forename><surname>Dediu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Formenti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">C</forename><surname>Martín-Vide</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>Truthe</surname></persName>
		</editor>
		<meeting><address><addrLine>Nice, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">March 2-6, 2015. 2015</date>
			<biblScope unit="volume">8977</biblScope>
			<biblScope unit="page" from="175" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Engelfriet</surname></persName>
		</author>
		<ptr target="http://www.cambridge.org/fr/knowledge/isbn/item5758776/?site_locale=fr_FR" />
		<title level="m">Graph Structure and Monadic Second-Order Logic -A Language-Theoretic Approach</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">138</biblScope>
		</imprint>
	</monogr>
	<note>Encyclopedia of mathematics and its applications</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Static and dynamic semantics of NoSQL languages</title>
		<author>
			<persName><forename type="first">V</forename><surname>Benzaken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Castagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Siméon</surname></persName>
		</author>
		<idno type="DOI">10.1145/2429069.2429083</idno>
	</analytic>
	<monogr>
		<title level="m">POPL, ACM</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="101" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Numerical document queries</title>
		<author>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schwentick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Muscholl</surname></persName>
		</author>
		<idno type="DOI">10.1145/773153.773169</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Principles Of Database Systems</title>
		<meeting>the Symposium on Principles Of Database Systems</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="155" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automata and logics for unranked and unordered trees</title>
		<author>
			<persName><forename type="first">I</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-M</forename><surname>Talbot</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-32033-3_36</idno>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">3467</biblScope>
			<biblScope unit="page" from="500" to="515" />
			<date type="published" when="2005">2005</date>
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
	<note>RTA</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">XML schema, tree logic and sheaves automata</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Zilio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-44881-0_18</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of RTA</title>
		<meeting>of RTA</meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">2706</biblScope>
			<biblScope unit="page" from="246" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Feature constraint logics for unification grammars</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
		<idno type="DOI">10.1016/0743-1066(92)90039-6</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="51" to="87" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Records for logic programming</title>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Treinen</surname></persName>
		</author>
		<idno type="DOI">10.1016/0743-1066(94)90044-2</idno>
	</analytic>
	<monogr>
		<title level="j">J. Log. Program</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="229" to="258" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The First-Order theory of ordering constraints over feature trees</title>
		<author>
			<persName><forename type="first">M</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Treinen</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS.1998.705677</idno>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<publisher>IEEE Comp. Soc. Press</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="432" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Feature automata and recognizable sets of feature trees</title>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podelski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TAPSOFT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">668</biblScope>
			<biblScope unit="page" from="356" to="375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A complete and recursive feature theory</title>
		<author>
			<persName><forename type="first">R</forename><surname>Backofen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Smolka</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(94)00188-O</idno>
		<ptr target="http://dx.doi.org/10.1016/0304-3975(94)00188-O" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">146</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="243" to="268" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Structures, languages and translations: the structural approach to feature logic</title>
		<author>
			<persName><forename type="first">P</forename><surname>Blackburn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constraints, Language and Computation</title>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="1" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Algebraic recognizability of languages</title>
		<author>
			<persName><forename type="first">P</forename><surname>Weil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Foundations of Computer Science</title>
		<imprint>
			<biblScope unit="page" from="149" to="175" />
			<date type="published" when="2004">2004. 2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Model checking languages of data words</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cyriac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gastin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">N</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computational Structures</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="391" to="405" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Monadic second order definable relations on the binary tree</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lauchli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Savioz</surname></persName>
		</author>
		<idno type="DOI">10.2307/2273878</idno>
		<ptr target="http://dx.doi.org/10.2307/2273878" />
	</analytic>
	<monogr>
		<title level="j">J. Symb. Log</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="219" to="226" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Twovariable logic on data words</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bojanczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Muscholl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schwentick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Log</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">27</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automata for unordered trees</title>
		<author>
			<persName><forename type="first">A</forename><surname>Boiret</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hugot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Treinen</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ic.2016.07.012</idno>
		<ptr target="http://dx.doi.org/10.1016/j.ic.2016.07.012" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">253</biblScope>
			<biblScope unit="page" from="304" to="335" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The monadic second-order logic of graphs. i. recognizable sets of finite graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Courcelle</surname></persName>
		</author>
		<idno type="DOI">10.1016/0890-5401(90)90043-H</idno>
	</analytic>
	<monogr>
		<title level="j">Information and computation</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="12" to="75" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">On XPath with transitive axes and data tests</title>
		<author>
			<persName><forename type="first">D</forename><surname>Figueira</surname></persName>
		</author>
		<editor>R. Hull, W. Fan</editor>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="249" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Weak second-order arithmetic and finite automata</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Büchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Logic Quarterly</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1-6</biblScope>
			<biblScope unit="page" from="66" to="92" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Generalized finite automata theory with an application to a decision problem of second-order logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Thatcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MST</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="81" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Word problems requiring exponential time</title>
		<author>
			<persName><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on the Theory of Computing</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Ordering constraints over feature trees expressed in second-order monadic logic</title>
		<author>
			<persName><forename type="first">M</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Niehren</surname></persName>
		</author>
		<idno type="DOI">10.1006/inco.2000.2878</idno>
		<ptr target="http://dx.doi.org/10.1006/inco.2000.2878" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="22" to="58" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Tree automata techniques and applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://www.grappa.univ-lille3.fr/tata" />
		<imprint>
			<date type="published" when="2007-10-12">October, 12th 2007 (2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Automata on Infinite Objects and Church&apos;s Problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">CBMS Regional Conference Series in Mathematics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<date type="published" when="1972">1972</date>
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Monadic second order definable relations on the binary tree</title>
		<author>
			<persName><forename type="first">H</forename><surname>Läuchli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Savioz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbol Logic</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="219" to="226" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Counting in trees</title>
		<author>
			<persName><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Schwentick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Muscholl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Texts in Logic and Games</title>
		<imprint>
			<publisher>Amsterdam University Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="575" to="612" />
		</imprint>
	</monogr>
	<note>Logic and Automata</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Equality and disequality constraints on direct subterms in tree automata</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bogaert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tison</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=646508.694491" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual Symposium on Theoretical Aspects of Computer Science, STACS &apos;92</title>
		<meeting>the 9th Annual Symposium on Theoretical Aspects of Computer Science, STACS &apos;92<address><addrLine>London, UK, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="161" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Recursive queries on trees and data trees</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Muscholl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="93" to="104" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
