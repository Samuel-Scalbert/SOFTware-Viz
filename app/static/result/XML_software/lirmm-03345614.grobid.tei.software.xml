<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Capturing Homomorphism-Closed Decidable Queries with Existential Rules</title>
				<funder>
					<orgName type="full">BMBF in the Center for Scalable Data Analytics and Artificial Intelligence</orgName>
				</funder>
				<funder ref="#_EXQ6gG3">
					<orgName type="full">Center for Perspicuous Systems)</orgName>
				</funder>
				<funder>
					<orgName type="full">Center for Advancing Electronics Dresden</orgName>
				</funder>
				<funder ref="#_p2bqYEv">
					<orgName type="full">DFG</orgName>
				</funder>
				<funder ref="#_XkNTWjK">
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
				<funder ref="#_72FApdp">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
							<email>camille.bourgaux@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<email>david.carral@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Markus</forename><surname>Krötzsch</surname></persName>
							<email>markus.kroetzsch@tu-dresden.de</email>
							<affiliation key="aff2">
								<orgName type="institution">Technische Universität Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
							<email>sebastian.rudolph@tu-dresden.de</email>
							<affiliation key="aff2">
								<orgName type="institution">Technische Universität Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michaël</forename><surname>Thomazo</surname></persName>
							<email>michael.thomazo@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">DI ENS</orgName>
								<orgName type="institution" key="instit1">ENS</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">PSL University &amp; Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Capturing Homomorphism-Closed Decidable Queries with Existential Rules</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A0F09B44565DBBFF1135F26119DB6F38</idno>
					<idno type="DOI">10.24963/kr.2021/14</idno>
					<note type="submission">Submitted on 15 Sep 2021</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>At the core of contemporary logic-based knowledge representation is the concept of querying data sources, often using elaborate query formalisms that allow for taking background knowledge into account. The classical decision problem related to such knowledge-aware querying is Boolean query entailment. From an abstract point of view, a Boolean query identifies a class of databases D -those that satisfy the query, i.e., to which the query "matches". This view allows us to define and investigate properties of (abstract) queries independently from the syntax used to specify them. Such properties can be structural (morphisms, closure properties) or computational <ref type="bibr">(decidability, complexity)</ref>.</p><p>A very popular querying formalism are existential rules, also referred to as tuple-generating dependencies. It is straightforward that the class of databases satisfying some existential rule query is closed under homomorphisms and recursively enumerable. Conversely, it was established that every homomorphism-closed query that is recursively enumerable can be expressed using existential rules <ref type="bibr" target="#b20">(Rudolph and Thomazo 2015)</ref>. That is, plain existential rules already realize their full potential; further syntactic extensions within these boundaries do not enhance expressivity.</p><p>For questions related to automated deduction, however, a more restricted requirement than recursive enumerability is of central interest: decidability. Therefore, the crucial question we tackle in this paper is: Can we characterize an existential rules fragment capable of expressing every decidable homomorphism-closed query?</p><p>The generic computational paradigm for existential rules, the chase <ref type="bibr" target="#b9">(Beeri and Vardi 1984)</ref>, is based on repetitive, for-ward-chaining rule application, starting from the database. As this may cause the iterated introduction of new domain elements, this procedure is not guaranteed to terminate -yet, termination is a crucial criterion for decidability. The chase comes in several variants, mainly differing in their (increasingly thorough) mechanisms to prevent unnecessary rule applications: While the Skolem chase <ref type="bibr" target="#b19">(Marnette 2009)</ref> essentially just avoids duplicate rule applications, the standard <ref type="bibr" target="#b14">(Fagin et al. 2005</ref>) and the core chase <ref type="bibr" target="#b13">(Deutsch, Nash, and Remmel 2008</ref>) check for redundancy on a local and global level, respectively.</p><p>The class of existential rule sets with terminating<ref type="foot" target="#foot_0">1</ref> Skolem chase has already been weighed and found wanting: it only comprises those queries that are already expressible in plain Datalog -and hence can be evaluated in polynomial time <ref type="bibr" target="#b19">(Marnette 2009;</ref><ref type="bibr" target="#b16">Krötzsch and Rudolph 2011;</ref><ref type="bibr" target="#b22">Zhang, Zhang, and You 2015)</ref>. For the standard-chase-terminating and the core-chase-terminating existential rules classes, on the other hand, we only know that the former is contained in the latter <ref type="bibr" target="#b15">(Grahne and Onet 2018)</ref>, but little more than that <ref type="bibr" target="#b18">(Krötzsch, Marx, and Rudolph 2019)</ref>. In this paper, we clarify the situation significantly by showing the following: Standard-chase-terminating existential rules capture the class of all decidable homomorphism-closed queries.</p><p>Notably, this implies that standard-chase-terminating and core-chase-terminating existential rule queries are equally expressive and no decidable enhancement of this formalism that preserves homomorphism-closedness (e.g. by allowing disjunction in rule heads) can be strictly more expressive.</p><p>As a downside, the existential rules fragment thus identified is not even semi-decidable, but we show via a diagonalisation argument that this downside is, in fact, unavoidable.</p><p>Additional proofs and details are given in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>Rules We consider first-order formulas over countably infinite sets Vars of variables and Preds of predicates, where each p ∈ Preds has an arity Ar (p) ≥ 0. Lists of variables are denoted x = x 1 , . . . , x k and will be treated like sets when order is not relevant. An atom is an expression p( x) with p ∈ Preds and | x| = Ar (p).</p><p>The fragment of disjunctive existential rules consists of formulae of the form:</p><formula xml:id="formula_0">∀ x. β[ x] → k i=1 ∃ y i .η i [ x i , y i ] ,</formula><p>(1)</p><p>where β[ x] and η i [ x i , y i ] (i = 1, . . . , k) are conjunctions of atoms with variables x and x i ∪ y i , respectively. We call β body and k i=1 ∃ y i .η i head. Bodies can be empty (we then omit →), but heads must be non-empty. We require that x and y i (i = 1, . . . , k) are mutually disjoint and that x i ⊆ x for all i = 1, . . . , k. We single out the fragment of existential rules by disallowing disjunction, i.e. requiring k = 1, and Datalog rules by disallowing existential quantifiers. We often omit the universal quantifiers from rules and treat conjunctions of atoms as sets of atoms.</p><p>Databases, Interpretations, and Entailment The semantics of formulas is based on logical interpretations, which we define as relational structures over a countably infinite set Nulls of nulls. A schema S is a finite set of predicates. An interpretation I over schema S is a set of expressions p( n) with p ∈ S and n a list of nulls of length Ar (p). We write Nulls(I) for the set of nulls in I. A database is a finite interpretation. See also the remarks on this notation below.</p><p>A homomorphism h : I 1 → I 2 between interpretations I 1 and I 2 is a mapping h from the nulls in I 1 to the nulls in I 2 , such that p( n) ∈ I 1 implies p(h( n)) ∈ I 2 , where h( n) denotes the list of h-values over n. We also write h(I) for {p(h( n)) | p( n) ∈ I}.</p><p>A substitution σ is a mapping from variables to nulls, which we extend to lists of variables and formulas as usual. A rule ρ as in (1) is satisfied by interpretation I if every substitution σ : x → Nulls with σ(β) ⊆ I can be extended to a substitution σ : x ∪ y i → Nulls for some i ∈ {1, . . . , k} such that σ (η i ) ⊆ I. Otherwise, if σ(β) ⊆ I but no extension σ of σ verifies σ (η i ) ⊆ I for some i ∈ {1, . . . , k}, then ρ, σ is applicable to I.</p><p>I satisfies a set Σ of rules if it satisfies every rule in Σ. An interpretation J is satisfied by an interpretation I if there is a homomorphism h : J → I. I is a model of a rule/rule set/interpretation/database X if X is satisfied by I, written I |= X . As usual, we also write X |= Y ("X entails Y") if every model of X is a model of Y, where X and Y might be rules, rule sets, databases, or lists of several such elements. Note that the semantics of a database D in this context corresponds to the semantics of a Boolean conjunctive query ∃ x. {p(x n1 , . . . , x n ) | p(n 1 , . . . , n ) ∈ D}we will therefore not introduce such queries as a separate notion. Also note that entailment and satisfaction between interpretations/databases coincide.</p><p>Abstract Queries, Expressivity, and Decidability An (abstract) query Q over a schema S is a set of databases over S that is closed under isomorphism, i.e., such that whenever D ∈ Q and D is obtained from D by bijective renaming of nulls, then D ∈ Q. Q is further closed under homomorphisms if, for all D ∈ Q and homomorphisms h : D → D , we have D ∈ Q.</p><p>Definition 1. Let Goal be a nullary predicate. A query Q over S is expressed by a set Σ of rules if, for every database D over S, we have D ∈ Q if and only if Σ, D |= Goal.</p><p>To discuss decidability of queries, we need to conceive databases as Turing machine inputs over a fixed alphabet. A serialisation for a schema S is a word s ∈ ({0, 1, } ∪ S) * of the form e 1 • • • e n where n ≥ 0 and e i = p i w i1 • • • w iAr (pi) for w ij ∈ {0, 1} + and p i ∈ S. Given s of this form and an injection η : {0, 1} + → Nulls, let η(s) denote the database {p i (η(w i1 ), . . . , η(w iAr (pi) )) | 1 ≤ i ≤ n}. Then s corresponds to a database D if η(s) is isomorphic to D; note that this does not depend on the choice of η.</p><p>A query Q with schema S is decidable if the set of all serialisations for S that correspond to some D ∈ Q is a decidable language.</p><p>Remarks on our Notation Many works consider constants to appear in databases (not just nulls), but complexity and expressivity is usually studied for queries that are closed under isomorphisms, a.k.a. generic <ref type="bibr">(Abiteboul, Hull, and Vianu 1995, Ch. 16)</ref>, and nulls are more natural there. One can admit finitely many exceptions (elements that must not be renamed), but such "constants" can be simulated by marking them with dedicated unary predicates.</p><p>Specifying logical interpretations as sets of "atoms" that may use nulls is a notational convenience with some side effects: our interpretations cannot contain elements that do not stand in any relation, but they can have an empty domain. Both aspects do not change the notion of logical entailment on the formulas we consider.</p><p>Universal Models and the Chase Entailment of databases (corresponding to Boolean conjunctive queries) can be decided by considering only a subset of all models. Given sets I and K of interpretations, I is universal for K if, for all K ∈ K, there is I ∈ I and a homomorphism I → K. Universal model sets can be computed with the chase algorithm. Here, we consider a variation of the standard (or restricted) chase for rules with disjunction, introduced by <ref type="bibr" target="#b12">(Carral, Dragoste, and Krötzsch 2017)</ref>. Definition 2. A chase tree for a rule set Σ and database D is a (finite or infinite) tree where each node is labelled by a database, such that:</p><p>1. The root is labelled with D. 2. For every node with label E that has children labelled C 1 , . . . , C , there is a rule ρ ∈ Σ of the form (1) and a substitution σ : x → Nulls such that (i) ρ, σ is applicable to E, (ii) ρ has k = head disjuncts, and (iii)</p><formula xml:id="formula_1">C i = E ∪σ i (η i )</formula><p>where σ i extends σ by mapping each variable y ∈ y i to a fresh null.</p><p>3. For each rule ρ ∈ Σ and each substitution σ, there is i ≥ 1 such that ρ, σ is not applicable to the label of any node of depth ≥ i. The result that corresponds to a chase tree is the set of all interpretations that can be obtained as the union of all interpretations along a path in the tree.</p><p>Condition (3) ensures fair, exhaustive rule application, but different orders of application can lead to different chase trees, which can also have different results. Nevertheless, every result is semantically correct in the following sense: Fact 2. Every result of a chase on a rule set Σ and database D is a universal model set for Σ and D.</p><p>The pair Σ, D is chase-terminating if all its chase trees are finite -by König's Lemma, this is equivalent to all chase results for Σ, D containing only finite interpretations; this corresponds to all-strategy termination. Σ is chase-terminating if Σ, D is chase-terminating for every database D; this corresponds to universal termination.</p><p>Turing Machines We will use (deterministic) Turing machines (TM), denoted as a tuple M = Q, Γ, δ , with states Q, tape alphabet Γ with blank ∈ Γ, and transition function δ. M has a distinguished initial state q S ∈ Q, and accepting and rejecting halting states q A , q R ∈ Q. For all states q ∈ Q \ {q A , q R } and tape symbols a ∈ Γ, there is exactly one transition (q, a) → (r, b, D) ∈ δ. We assume that TM tapes are unbounded to the right but bounded to the left, and that TMs will never attempt to move left on the first position of the tape (this is w.l.o.g., since one can modify any TM to insert a marker at the tape start to recognise this case).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">On the Expressivity of Disjunctive Rules</head><p>In this section, we show how to express a homomorphismclosed, decidable query with a disjunctive rule set. This construction will be the basis for finding a chase-terminating set of (deterministic) existential rules. Throughout this section, Q is a fixed but arbitrary homomorphism-closed query over signature S, and M = Q, Γ, δ is a TM that decides Q.</p><p>To express Q, we specify five rule sets <ref type="figure">1</ref><ref type="figure">2</ref><ref type="figure">3</ref><ref type="figure">4</ref><ref type="figure" target="#fig_1">5</ref><ref type="figure">6</ref>), which will be explained later. We want to show the following result: Theorem 3. The set R 5 of disjunctive existential rules expresses the query Q.</p><formula xml:id="formula_2">R 1 ⊆ R 2 ⊆ R 3 ⊆ R 4 ⊆ R 5 (see Figures</formula><p>To show this, we fix an arbitrary database D over S. Theorem 3 then follows from Fact 1 and the next lemma: Lemma 4. There is a universal model set M of R 5 and D such that D ∈ Q iff Goal ∈ I for every I ∈ M.</p><p>The universal model set M is a complicated structure that we describe step by step, by specifying five sets of interpretations -I 1 , I 2 , I 3 , I 4 , and I 5 -, such that (1) <ref type="figure"></ref>and<ref type="figure"></ref> (3) for each 1 ≤ i &lt; j ≤ 5 and each I ∈ I i , there is exactly one J ∈ I j with I ⊆ J . Lemma 4 can then be shown using M = I 5 .</p><formula xml:id="formula_3">I i is a universal model set of R i , D for each 1 ≤ i ≤ 5, (2) |I 1 | = |I 2 | = |I 3 | = |I 4 | = |I 5 |,</formula><p>Before dwelling into the details of each rule set and universal model, we give an overview of the construction: R 1 → ∃y.First(y) ∧ DbDom(y) (2) → ∃z.Last(z) ∧ DbDom(z)</p><p>(3) p( x) → In p ( x) ∧ x∈ x DbDom(x) (4) DbDom(x) → Eq(x, x)</p><p>(5) Eq(x, y) → Eq(y, x) (6) NEq(x, y) → NEq(y, x)</p><formula xml:id="formula_4">(7) R( x) ∧ Eq(x i , y) → R( x xi →y ) (8) DbDom(x) ∧ DbDom(y) → Eq(x, y) ∨ NEq(x, y) (9) LT(x, y) ∧ LT(y, z) → LT(x, z) (10) First(x) ∧ NEq(x, y) → LT(x, y) (11) NEq(x, y) ∧ Last(y) → LT(x, y) (12) NEq(x, y) → LT(x, y) ∨ LT(y, x) (13) x∈ x DbDom(x) → In p ( x) ∨ NIn p ( x)<label>(14)</label></formula><p>Figure <ref type="figure">1</ref>: The rule set R1, where rules (4) and ( <ref type="formula" target="#formula_4">14</ref>) are instantiated for each p ∈ S, and rules (8) are instantiated for each R ∈ {First, Last, Eq, NEq, LT} ∪ {Inp, NInp | p ∈ S} and 1 ≤ i ≤ Ar (R), and xx i →y denotes x with xi replaced by y.</p><formula xml:id="formula_5">First(x) → ∃u.Root(u) ∧ Rep(x, u) (15) Rep(x, v) ∧ LT(x, z) → ∃w.Chi(v, w) ∧ Rep(z, w) (16) Last(x) ∧ Rep(x, u) → Leaf(u) (17) Rep(x, u) ∧ Eq(x, y) → Rep(y, u)<label>(18)</label></formula><formula xml:id="formula_6">In p ( x) ∧ | x| i=1 Rep(x i , u i ) → In p ( u)<label>(19)</label></formula><formula xml:id="formula_7">NIn p ( x) ∧ | x| i=1 Rep(x i , u i ) → NIn p ( u)<label>(20)</label></formula><p>Figure <ref type="figure">2</ref>: The rule set R2 contains R1 (see Figure <ref type="figure">1</ref>) and all above rules, where ( <ref type="formula" target="#formula_6">19</ref>) and ( <ref type="formula" target="#formula_7">20</ref>) are instantiated for each p ∈ S. constructs all possible linear orders over the nulls in D, as well as all possible completions of D with facts built using these nulls; R 2 \ R 1 extracts successor relations from the linear orders; R 3 \ R 2 associates to nulls representations of their positions in successor relations; R 4 \ R 3 encodes all initial TM configurations corresponding to some linear order and completion, and R 5 \ R 4 simulates the run of the TM on these configurations.</p><p>R 1 : Linear Order and Database Completion R 1 serves two distinct purposes: (1) predicates First, Last, Eq ("="), NEq (" ="), and LT ("&lt;") encode representations of possible linear orders over nulls in D (collected in predicate DbDom); and (2) predicates In p and NIn p for each p ∈ S explicitly encode positive and negative (absent) facts in D. Both purposes require disjunctive reasoning. Possible models include representations of strict, total linear orders (1) and the exact database completion (2), but also models for collapsed orders and inconsistent completions. The latter is not problematic since we consider homomorphism-closed queries. We define the interpretation set I 1 on the set ∆ = Nulls(D) ∪ {u α , u ω }, for fresh nulls u α , u ω / ∈ Nulls(D). A (partially collapsed) linear order can be represented by Figure <ref type="figure">3</ref>: The rule set R3 contains R2 (Figure <ref type="figure">2</ref>) and all of the above rules, where ( <ref type="formula">27</ref>) and ( <ref type="formula">28</ref>) are instantiated for each * ∈ {0, 1}.</p><p>an ordered partition T = T 1 , . . . , T k (k ≥ 1) of ∆ where u α ∈ T 1 and u ω ∈ T k . Let Ords be the set of all such T , and let Compls( T ) be the set of all interpretations with nulls ∆ that are set-minimal among the models of R 1 and D, and that contain the database</p><formula xml:id="formula_8">{First(u) | u ∈ T 1 } ∪ {Last(u) | u ∈ T k } ∪ {Eq(t, u) | 1 ≤ i ≤ k; t, u ∈ T i } ∪ {LT(t,u), NEq(t,u), NEq(u,t) | 1 ≤ i &lt; j ≤ k; t ∈ T i ; u ∈ T j }.</formula><p>By minimality, each I ∈ Compls( T ) contains exactly one of {In p ( t), NIn p ( t)} for every t ⊆ ∆ with | t| = Ar (p). Proof Sketch. We can construct a chase tree for R 1 and D that prioritises the application of rules in the order of their appearance in Figure <ref type="figure">1</ref>. The result of that chase K is a finite universal model set (Fact 2) and we can show that every K ∈ K is isomorphic to a unique I ∈ I 1 .</p><p>Each set I i for some 2 ≤ i ≤ 5 is obtained as I i = {Int i (I) | I ∈ I i-1 } for a function Int i as defined below. Every I ∈ I i with 1 ≤ i ≤ 5 contains a unique interpretation Seed (I) ∈ I 1 , and there is a unique ordered partition Order (I) ∈ Ords such that Seed (I) ∈ Compls(Order (I)).</p><p>R 2 : Representative Tree The purpose of R 2 is to extract successor relations from the transitive linear order LT. Given an ordered partition Order (I) = T 1 , . . . , T k of some model I of R 1 , R 2 constructs a finite tree structure -defined using predicates Root, Chi ("child"), and Leaf -where each path represents a sub-sequence T z1 , . . . , T zp of T 1 , . . . , T k with z 1 = 1 and z p = k. Unavoidably, some paths will skip some T i , but it suffices for our purposes if one path is complete. The elements of any set T j are related to the tree nodes that represent T j by a predicate Rep. Moreover, nodes are related via predicates In p and NIn p that reflect the relations for In p and NIn p that hold between the represented elements (in the database completion of the considered model I of R 1 ).</p><p>Given I with |Order (I)| = k as above, let Z be the set of all words z 1 • • • z p ∈ {1, . . . , k} * such that z 1 = 1 and z i &lt; z i+1 for all i ∈ {1, . . . , p -1}. Moreover, let</p><formula xml:id="formula_9">end (z 1 • • • z p ) := z p . Using fresh nulls {u w | w ∈ Z}, we define Tree(I) to be the interpretation {Root(u 1 )} ∪ {Chi(u w , u wz ) | wz ∈ Z, 2 ≤ z ≤ k} ∪ {Leaf(u w ) | w ∈ Z; end (w) = k} ∪ {Rep(x, u w ) | w ∈ Z; x ∈ T end(w) }.</formula><p>Now Int 2 (I) is the least interpretation that contains I and Tree(I), and that further satisfies rules ( <ref type="formula" target="#formula_6">19</ref>) and ( <ref type="formula" target="#formula_7">20</ref>). We can extend Lemma 5 as follows. The required universal model set is obtained by any chase that prioritises rule (18). Lemma 6.</p><formula xml:id="formula_10">I 2 = {Int 2 (I) | I ∈ I 1 } is a universal model set of R 2 and D.</formula><p>R 3 : Position Binary Encodings The purpose of R 3 is to associate each node in the tree of R 2 with a binary encoding of its distance from the root (the root starts with "distance" 2 for technical reasons). Encodings start at the least significant bit and always end in 1 (i.e., have no leading 0s). To simplify upcoming steps, encodings take the form of little TM tapes, represented by a Nxt-connected chain of nulls with unary predicates S 0 and S 1 encoding the symbol at each position. Nodes u relate to the first and last null t s and t e of their "tape" through facts Enc(u, t s , t e ). Facts Cpy(a s , a e , b s , b e ) are used to create a tape between b s and b e that contains a copy of the information on the tape between a s and a e . Predicate Cpy +1 is analogous, but creates a representation of the successor of the number that is copied.</p><p>Consider a model I of R 2 and define the set of sequences Z as before. For w ∈ Z of length |w|, and b</p><formula xml:id="formula_11">1 • • • b the binary representation of |w| + 1, let EncPos(w) be the database {Enc(u w , e 1 w , e w )} ∪ {S bi (e i w ) | 1 ≤ i ≤ } ∪ {Nxt(e i-1</formula><p>w , e i w ) | 2 ≤ i ≤ }. Let J = I ∪ w∈Z EncPos(w). We define Int 3 (I) as the smallest superset of J that satisfies all rules in R 3 while including only the nulls in J . Int 3 (I) extends J only by missing Cpy and Cpy +1 relations, which can be inferred by slightly rewritten rules. For example, rule ( <ref type="formula">22</ref>) is satisfied when applying the following rule to J :</p><formula xml:id="formula_12">Enc(u, y 1 , y ) ∧ Chi(u, v) ∧ Enc(v, z 1 , z ) → Cpy +1 (y 1 , y , z 1 , z ). Ld p (u, t, v) ∧ In p ( v) → ∃ x, y.S p (t) ∧ Nxt(t, x 1 ) ∧ | v| i=1 LdE(v i , x i , x i+1 ) ∧ Nxt(x | v|+1 , y) ∧ Rdy p (u, y, v) (29) LdE(v, x s , x e ) ∧ Enc(v, y 1 , y ) → ∃z 1 , z .S (x s ) ∧ Nxt(x s , z 1 ) ∧ Cpy(y 1 , y , z 1 , z ) ∧ Nxt(z , x e ) ∧ S (x e )<label>(30)</label></formula><p>Figure <ref type="figure">4</ref>: The rule set R4 contains R3 (see Figure <ref type="figure">3</ref>), the rules from Figure <ref type="figure" target="#fig_1">5</ref>, and the above rules instantiated for all p ∈ S.</p><formula xml:id="formula_13">Leaf(u) → ∃t.Ld 1 (u,t, u) ∧ Hd q S (t) (31) Ld (u, t, v) → Ld p 1 (u, t, v)<label>(32)</label></formula><formula xml:id="formula_14">Rdy p j (u, t, v) → Ld p j+1 (u, t, v)<label>(33)</label></formula><formula xml:id="formula_15">Rdy p n (u, t, v) → Rdy (u, t, v)<label>(34)</label></formula><formula xml:id="formula_16">Rdy (u, t, v) ∧ i=k+1 Root(v i ) ∧ Chi(w, v k ) → Ld (u, t,v 1 , •••, v k-1 , w, u, •••, u) (35) Rdy (u, t, v) ∧ i=1 Root(v i ) → Ld +1 (u, t, u, •••, u) (36) Rdy m(u, t, v) ∧ m i=1 Root(v i ) → S (t) ∧ End(t) (37) Ld p (u, t, v) ∧ NIn p ( v) → Rdy p (u, t, v)<label>(38)</label></formula><p>Figure <ref type="figure" target="#fig_1">5</ref>: Some rules of R4, to be instantiated for all</p><formula xml:id="formula_17">1 ≤ j ≤ n-1, 1 ≤ k ≤ ≤ m, and p ∈ S.</formula><p>All other rules can be rewritten analogously, since every existentially quantified variable is used in unique ways with predicates other than Cpy and Cpy +1 .</p><p>For every I ∈ I 2 , we show that Int 3 (I) is isomorphic to a result of the chase on R 3 and I. The next result then follows from Lemma 6. Lemma 7.</p><formula xml:id="formula_18">I 3 = {Int 3 (I) | I ∈ I 2 } is a universal model set of R 3 and D.</formula><p>R 4 : Initial TM Configuration For each leaf in the tree of completions, R 4 creates the representation of an initial TM configuration. The tape is again represented by a Nxt-chain, using further unary predicates S , S , and S p (for all p ∈ S) for additional tape symbols. Hd q S marks the TM's starting position and initial state q S , and End the end of the tape.</p><p>Let m be the maximal arity of predicates in S. We require that there is some n &gt; 0 such that S contains exactly n predicates p i 1 , . . . , p i n of arity i, for every 1 ≤ i ≤ m. This is without loss of generality, except for the exclusion of nullary predicates. Our results do not depend on this restriction, but it helps to simplify the presentation of our main ideas.</p><p>To serialise the data as a tape, we iterate over all predicate arities = 1, . . . , m and over all lists v of tree nodes with length . In this process, Ld (u, t, v) expresses that, while encoding the leaf u, after constructing the tape until position t, we continue serialising -ary predicate data for arguments v. Analogously, Rdy (u, t, v) means that this was completed at tape position t. Similar predicates Ld p and Rdy p are used to consider a specific predicate p ∈ S during this process. The rules in Figure <ref type="figure" target="#fig_1">5</ref> start the serialisation (31), proceed over all predicates (32)-( <ref type="formula" target="#formula_15">34</ref>), iterate over parameter vectors <ref type="bibr">(35)</ref> and arities (36), and finally end the tape (37).</p><p>Absent facts do not need to be serialised (38), while present facts can be treated by copying the encodings for each of their parameters ( <ref type="formula">29</ref>) and (30). In the latter, LdE states that a specific argument is serialised between two given tape positions.</p><p>The resulting TM tapes serialise facts In p ( u) as introduced by R 2 , i.e., where u are nodes in the representative tree. Given a model I ∈ I 3 with some Leaf(u w ) ∈ I, let branch(u w ) be the set of all nodes u w on the branch of u w , i.e. all nulls u w where w is a prefix of w. Elements of branch(u w ) are totally ordered by setting</p><formula xml:id="formula_19">u w1 ≺ u w2 if |w 1 | &gt; |w 2 |.</formula><p>Predicates are totally ordered by setting p a i ≺ p b j if either a &lt; b, or both a = b and i &lt; j. We can then order facts as p( u) ≺ q( v) if u, v ⊆ branch(u w ) and p, u is lexicographically before q, v . Now let branchDb(I, u w ) = {p( u) | In p ( u) ∈ I, u ⊆ branch(u w )} denote the set of all facts on the branch with leaf u w , and let branchTape(I, u w ) denote the TM tape serialisation (as defined in Section 2) of branchDb(I, u w ) according to the total order ≺ and representing each node u w by the binary representation of |w| + 1 as before. Given S = branchTape(I, u w ), let startConf (I, u w ) be the following interpretation:</p><formula xml:id="formula_20">{Ld 1 (u w , t 1 w , u w ), Hd q S (t 1 w ), End(t |S|+1 w )} ∪ {Nxt(t j-1 w , t j w ) | 2 ≤ j ≤ |S| + 1} ∪ {S a (t j w ) | 1 ≤ j ≤ |S|, a = S[j]} ∪ {S (t |S|+1 w )}.</formula><p>Let J be the extension of I with startConf (I, u w ) for every Leaf(u w ) ∈ I. We define Int 4 (I) to be the smallest superset of J that satisfies all rules in R 4 while including only the nulls in J . As in the case of Int 3 , the missing relations can easily be inferred using the original rules or, for (29) and ( <ref type="formula" target="#formula_12">30</ref>), with simple rewritings thereof. Lemma 8.</p><formula xml:id="formula_21">I 4 = {Int 4 (I) | I ∈ I 3 } is a universal model set of R 4 and D.</formula><p>R 5 : TM Run The purpose of R 5 is to simulate the run of the deterministic TM Q, Γ, δ on each of the initial tapes created by R 4 . We continue to use predicate Nxt for neighbouring tape cells (augmented with its transitive closure Nxt + ), S b to encode tape symbols b ∈ Γ, and Hd q to encode head position and current state q ∈ Q. Predicate Stp connects tape cells in each configuration to the corresponding tape cells in the next configuration (provided the TM performs another step). The rules in Figure <ref type="figure">6</ref> are a standard TM encoding, with the slight exception of rule (43), which adds a new blank tape cell in each step (even if not used by the TM). Our rules use the assumptions on TMs in Section 2. Consider some I ∈ I 4 . It is easy and only mildly laborious to define interpretations Run(u w ) that represent all successor configurations of the starting configuration startConf (I, u w ), appropriately connected with Stp and</p><formula xml:id="formula_22">Hd q A (x) → Goal (39) Nxt(x, y) → Nxt + (x, y) (40) Nxt + (x, y) ∧ Nxt + (y, z) → Nxt + (x, z) (41) Nxt(x, y) ∧ Stp(x, z) ∧ Stp(y, w) → Nxt(z, w) (42) End(x) ∧ Stp(x, z) → ∃v.Nxt(z, v) ∧ S (v) ∧ End(v) (43) Hd q (x) ∧ S a (x) → ∃z.Stp(x, z) ∧ S b (z) (44) Hd q (x) ∧ Nxt + (x, y) ∧ S c (y) → ∃z.Stp(y, z) ∧ S c (z) (45) Hd q (x) ∧ Nxt + (y, x) ∧ S c (y) → ∃z.Stp(y, z) ∧ S c (z) (46) Hd q (x) ∧ S a (x) ∧ Stp(x, z) ∧ Nxt(z, w) → Hd r (w) (47) Hd q (x) ∧ S a (x) ∧ Stp(x, z) ∧ Nxt(w, z) → Hd r (w) (48)</formula><p>Figure <ref type="figure">6</ref>: The rule set R5 contains R4 (see Figure <ref type="figure">4</ref>) and the above rules, where we instantiate rules ( <ref type="formula">44</ref>)-( <ref type="formula">46</ref>) for all transitions (q, a) → (r, b, X) ∈ δ and c ∈ Γ; rule (47) for all (q, a) → (r, b, +1) ∈ δ; and rule (48) for all (q, a) → (r, b, -1) ∈ δ.</p><p>the transitive closure Nxt + . Moreover, let J be the extension of I with all Nxt + required to satisfy ( <ref type="formula">40</ref>) and ( <ref type="formula">41</ref>) (note that Nxt also occurs in encodings from R 3 ). We define Int 5 (I) as the union of J with the interpretations Run(u w ) for all u w with Leaf(u w ) ∈ I. By the correctness of our TM simulation, Goal is not derived from this maximal branch. Moreover, for all other leaf nodes u v with Leaf(u v ) ∈ I, there is a homomorphism branchDb(I, u v ) → branchDb(I, u w ). Since Q is closed under homomorphisms, the TM does not accept any such branchDb(I, u v ), so Goal / ∈ I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Ensuring Chase Termination</head><p>While the rules in Section 3 are semantically correct, the disjunctive chase may not terminate on them. Many known fragments of existential rules can guarantee chase termination, including for expressive cases where termination might be exponential <ref type="bibr" target="#b11">(Carral et al. 2019</ref>), but they are not applicable to our case, since the runtime of TMs that decide a query can in general not be bounded by any elementary function. Indeed, we rely on the TM to stop "naturally", by virtue of being a decider. Nevertheless, our rules lead to infinite chase trees, e.g., if the disjunctive guessing of LT leads to a cycle, which enables rule ( <ref type="formula">16</ref>) to create an infinite path in the representation tree. We will now show that this can be avoided: Theorem 12. Every homomorphism-closed decidable query is expressed by a set of disjunctive rules that is chaseterminating for all databases over the schema of the query.</p><p>To show this, we refine and generalise the "emergency brake" technique of <ref type="bibr" target="#b18">Krötzsch, Marx, and Rudolph (2019)</ref>, and re-formulate it as a general rule set transformation. This not only yields a generic method that is of independent interest, but it also allows us to address potential termination problems in our prior modelling. Definition 3. Consider a rule set Σ and a nullary predicate Halt that does not occur in Σ. For every predicate p in Σ, let p be a fresh predicate of the same arity, and, for any formula ψ, let ψ be ψ with all predicates p replaced by p. Now the set brake(Σ, Halt) consists of the following rules:</p><formula xml:id="formula_23">→ ∃v.Brake(v) (49) Halt ∧ Brake(x) → Real(x) (50) p( x) ∧ x∈ x Real(x) → p( x)</formula><p>for all p in Σ (51)</p><p>For every rule ρ :</p><formula xml:id="formula_24">β[ x] → k i=1 ∃ y i .η i [ x i , y i ]: β[ x] ∧ Brake(v) → k i=1 B i ρ ( x i ) ∧ ηi [ x i , y i → v] ∧ x∈ xi Real(x)<label>(52)</label></formula><formula xml:id="formula_25">B i ρ ( x i ) → ∃ y i .η i [ x i , y i ] ∧ y∈ yi Real(y) (53)</formula><p>where ηi [ x i , y i → v] is ηi with each variable y ∈ y i replaced by v, and Brake, Real, and all B i ρ are fresh predicates with arities as indicated.</p><p>Note that brake(Σ, Halt) does not define rules to derive Halt, and indeed the transformation largely preserves the models of Σ in the following sense: Lemma 13. Consider a rule set Σ and database D over predicates that occur in Σ. For every model I of brake(Σ, Halt) and D, the set I -= {p( n) | p( n) ∈ I, p occurs in Σ} is a model of Σ and D, and every model J of Σ and D is of this form.</p><p>Proof. Consider a rule ρ ∈ Σ as in Definition 3, and let σ be a substitution such that σ(β) ⊆ I -. Then we can apply rules ( <ref type="formula" target="#formula_24">52</ref>), ( <ref type="formula">53</ref>), and finally (51) to derive σ (η i ) ⊆ I -for a suitable extension σ of σ. Hence I -|= Σ.</p><p>Conversely, let J |= Σ. A model I of brake(Σ, Halt) can be found by adding, for each matching body σ(β) ⊆ J of rule ρ, an atom σ(B i ρ ( x i )) for some i such that σ (η i ) ⊆ J for an extension σ of σ. To obtain the required model I of brake(Σ, Halt), it remains to add facts Brake(b) for a fresh null b, σ(η i [ x i , y i → b]) as in (52) for every σ(B i ρ ( x i )) ∈ I, and Real(n) for every p( n) ∈ J and n ∈ n.</p><p>For brake(Σ, Halt) to be useful, we need to add rules that can "pull the brake" by deriving Halt. Doing so stops the chase in the following sense: Lemma 14. Consider a rule set Σ, a database D over predicates that occur in Σ, and a set Π of rules of the form β → Halt where β only uses predicates in Σ. If I is the label of a node in a chase tree for Σ ∪ Π and D such that Halt ∈ I, then the tree starting at the node of I is finite.</p><p>Proof. Since Halt ∈ I, there is a substitution σ such that ρ (50) , σ is applicable (for ρ (50) in ( <ref type="formula">50</ref>)). By fairness, Real(σ(x)) will be derived at some depth of the tree. From this depth on, no rule of form ( <ref type="formula">53</ref>) is applicable: given Real(σ(x)), the head of rules of form (52) already satisfies the head of the rule (53) that could be applied to a newly derived atom for B i ρ . Rules other than (53) do not contain existential quantifiers thus can only be applied a finite number of times before the chase on this part of the tree terminates.</p><p>If Halt is derived, the semantic correspondence of Lemma 13 is weakened, but suffices to preserve entailments: Lemma 15. Consider Σ, D, and Π as in Lemma 14. For every model I of brake(Σ, Halt) ∪ Π and D, I -(as in Lemma 13) is a model of Σ and D.</p><p>Proof. This is immediate from Lemma 13 and the fact that every model of brake(Σ, Halt) ∪ Π and D is also a model of brake(Σ, Halt) and D.</p><p>Having established the key properties of the emergency brake construction, we can now apply it to show Theorem 12. Given the rule set R 5 as defined for a query Q in Section 3, let R 6 denote the extension of brake(R 5 , Halt) with the following rules: Lemma 17. R 6 is chase-terminating for all databases over the schema S of the query Q.</p><formula xml:id="formula_26">In p ( x) ∧ NIn p ( x) → Halt (54) LT(x, x) → Halt (55) Last(x) ∧ LT(x, y) → Halt (56) LT(x, y) ∧ First(y) → Halt<label>(</label></formula><p>Proof. Consider a chase over R 6 and input database D. Chase branches where Halt is eventually part of a node label terminate by Lemma 14. Let b denote any branch of the chase where Halt is not derived, and let I be the union of all node labels on that branch. We want to show that I (and hence b) is finite.</p><p>By Lemma 13, I |= R 1 . Moreover, since Halt / ∈ I, rules (54)-( <ref type="formula">57</ref>) are not applicable to I. Both properties together suffice to show that the set</p><formula xml:id="formula_27">I R1 = {p( n) ∈ I | p is a predi- cate in R 1 } is an element of I 1 defined in Section 3.</formula><p>Since the predicates in rule bodies of R 1 do not occur in any rule head in R 5 \ R 1 , we can assume without loss of generality (and without affecting chase termination), that the corresponding rules of brake(R 1 , Halt) ⊆ R 6 have been applied first. This shows that I is equal to the result of a chase with non-disjunctive rules R 6 \ brake(R 1 , Halt) on a database I R1 ∈ I 1 . The claim follows by noting that any such chase must terminate: this was shown in Section 3, where we described a deterministic process of defining the elements in the universal model set I 5 from those in I 1 . Each steps in this construction is fully determined and introduces isomorphic sets of nulls irrespectively of the order of rule applications. The only exception are application of rules ( <ref type="formula">15</ref>), ( <ref type="formula">16</ref>), and (18). For example, given facts First(n 1 ), First(n 2 ), and Eq(n 1 , n 2 ), the standard model of Section 3 contains one fact Root(u 1 ) with Rep(n 1 , u 1 ) and Rep(n 2 , u 1 ), which can be obtained using (15) (on n 1 ) and ( <ref type="formula" target="#formula_5">18</ref>). If we apply (15) to both n 1 and n 2 before applying (18), we obtain two distinct Root(u 1 ) and Root(u 1 ). Similar variations can occur with other tree nodes if ( <ref type="formula">16</ref>) is applied before (18). If is easy to see that this does not endanger termination, but merely leads to several isomorphic paths in the representation tree.</p><p>Together, Lemmas 16 and 17 show Theorem 12.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Removing Disjunctions</head><p>Our main result is that any decidable homomorphism-closed query is expressible by a chase-terminating existential rule set. To conclude the proof of this statement, we remove the disjunction from the rule set R 6 of Section 4. We present this as a general technique of expressing disjunctive Datalog using existential rules, which is also of independent interest.</p><p>For a rule set Σ, the input schema S in (Σ) is the set of all predicates in Σ that do not occur in any rule head. We focus on rule sets that can be split into a disjunctive part and an existential part, such that it is admissible to completely apply the disjunctive rules first, and the existential ones afterwards: Definition 4. A split of a set Σ of disjunctive existential rules consists of a set Σ 1 of disjunctive Datalog rules and a set Σ 2 of existential rules, such that Σ = Σ 1 ∪ Σ 2 and: For every database D over S in (Σ), and for every chase result M over Σ, D , there is a chase result M 1 over Σ 1 , D , such that M = {C I | I ∈ M 1 } where each C I is the (unique) interpretation resulting from some chase over Σ 2 , I .</p><p>→ ∃w.Init(w) ∧ Done(w) ∧ Empty(w) (58) Done(w) ∧ Init(w) ∧ p( x) → ∃w .Ins p ( x, w, w ) ∧ Subs(w , w ) ∧ Init(w ) (59) Done(w) ∧ p( x)∈β Ins p ( x, w, w) → ∃w 1 .Ins p1 ( x 1 , w, w 1 ) ∧ Subs(w 1 , w 1 ) (60) Done(w) ∧ p( x)∈β Ins p ( x, w, w) → ∃w 2 .Ins p2 ( x 2 , w, w 2 ) ∧ Subs(w 2 , w 2 ) (61)</p><p>Ins p ( x, w 0 , w 1 ) ∧ Subs(w 1 , w 2 ) → Ins p ( x, w 2 , w 2 ) ∧ p ( x, w 2 ) ∧ Subs(w 0 , w 2 ) (62)</p><formula xml:id="formula_28">Empty(w) ∧ Subs(w, w ) → Done(w )<label>(63)</label></formula><p>Figure <ref type="figure">7</ref>: The rule set Σ 1 , where we instantiate ( <ref type="formula">59</ref>) and ( <ref type="formula">62</ref>) for all p ∈ Preds in Σ1∪Σ2, and ( <ref type="formula">60</ref>) and ( <ref type="formula">61</ref>) for all β → p1( x1)∨p2( x2) ∈ Σ1.</p><p>Done(w) ∧ p( x)∈β p ( x, w) → ∃ z. q( y)∈η q ( y, w)</p><p>Figure <ref type="figure" target="#fig_4">8</ref>: The rule set Σ 2 , where we instantiate (64) for all β → ∃ z.η ∈ Σ2.</p><p>Goal (w) → Acc(w) (65)</p><formula xml:id="formula_30">Ins p1 ( x 1 , w, w 1 ) ∧ Acc(w 1 ) ∧ Ins p2 ( x 2 , w, w 2 ) ∧ Acc(w 2 ) ∧ p( x)∈β Ins p ( x, w, w) → Acc(w)<label>(66)</label></formula><p>Init(w) ∧ Acc(w) → Goal (67)</p><p>Figure <ref type="figure">9</ref>: The rule set Σ 3 , where (66) is instantiated for all rules</p><formula xml:id="formula_31">β → p1( x1) ∨ p2( x2) ∈ Σ1</formula><p>Lemma 18. Consider a rule set Σ with split Σ 1 , Σ 2 . There is a set Σ of existential rules, such that, for every database D over S in (Σ), we have: 1. D, Σ |= Goal iff D, Σ |= Goal, and 2. if Σ 2 , D 2 is chase-terminating for every database D 2 over S in (Σ 2 ), then Σ , D is also chase-terminating.</p><p>To construct this set Σ , we assume w.l.o.g. that all disjunctive rules have exactly two disjuncts in the head. We define Σ as the union of sets Σ 1 , Σ 2 and Σ 3 as shown in Figures <ref type="figure">7,</ref><ref type="figure" target="#fig_4">8</ref> and 9, which we explain below.</p><p>Σ 1 uses a technique for modelling sets with chaseterminating existential rules <ref type="bibr">(Krötzsch, Marx, and Rudolph 2019, Fig. 2</ref>). We adapt this to sets of ground atoms, called worlds and denoted by variables w in the figures. Facts Ins p ( t, w, w ) express that world w is obtained by adding p( t) to world w. In particular, Ins p ( t, w, w) states that p( t) is in w, and we define world(w) = {p( a) | Ins p ( a, w, w) ∈ I} for any interpretation I. Worlds are created by adding database facts (59) or by applying rules to existing worlds (60)-(61). Worlds containing only database facts are marked with Init. Predicate Subs defines the subset relation on worlds. Rules (62)-( <ref type="formula" target="#formula_28">63</ref>) copy all prior facts to a new world before marking it Done. Proposition 19. Σ 1 is chase-terminating and for every D over S in (Σ), the (unique) interpretation I resulting from some chase over Σ 1 and D is such that:</p><p>• if p( a) ∈ D and Done(w) ∈ I, there exists w such that Ins p ( a, w, w ) ∈ I and world(w ) = world(w) ∪ {p( a)};</p><p>• if ρ ∈ Σ 1 is applicable to world(w), creating p 1 ( a) or p 2 ( b), there exists w 1 and w 2 such that {Ins p1 ( a, w, w 1 ), Ins p2 ( b, w, w 2 )} ⊆ I, world(w 1 ) = world(w)∪{p 1 ( a)} and world(w 2 ) = world(w)∪{p 2 ( b)}.</p><p>Note that we cannot distinguish worlds that are not containing all database facts, and that some worlds may contain more facts than needed to satisfy all disjunctive heads.</p><p>Σ 2 now simulates the application of rules from Σ 2 in any of the worlds. Computations relative to different worlds are independent from each other. Finally, Σ 3 aggregates results from all worlds: a world is accepting (Acc) if either Goal was derived locally (65) or it has two successor worlds for a disjunctive rule that are both accepting (66). Goal is a consequence if any initial world is accepting (67). This finishes the construction of Σ as the main ingredient for proving Lemma 18.</p><p>Finally, we can apply Lemma 18 to R 6 = brake(R 5 , Halt) ∪ Π from Section 4, where Π denotes rules ( <ref type="formula">54</ref>)-(57). Intuitively, a possible split is brake(R 1 , Halt) and brake(R 5 \ R 1 , Halt) ∪ Π. Formally, however, brake(R 1 , Halt) is not disjunctive Datalog due to existential rules (2), (3), and (49). However, our result easily extends to such rules with empty body: we can just add them to Σ 1 and treat their inferences like facts from the initial database. The other properties of Definition 4 are easy to verify. The fact that both rule sets have some common rules, such as (50), is no concern. Finally, it remains to argue termination for Σ 2 as required for item (2) in Lemma 18. This is slightly stronger than Lemma 17 since we must also consider databases that use some inferred predicates of R 1 . However, the proof of Lemma 17 and the emergency brake technique in general served the main purpose of safeguarding against problematic structures among the inferred predicates of R 1 , and it is not hard to see that this already showed what we require here. Combining all of our insights, we finally obtain: Theorem 20. Chase-terminating existential rules capture the class of all decidable homomorphism-closed queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Limitations of Semi-Decidable Languages</head><p>A query language F over a schema S is a function from a set L to 2 D S , where D S is the set of all databases over schema S. We say that F is semi-decidable if membership to L is semi-decidable, and that its query answering problem is decidable if there exists a TM M F that takes as input some (l, D) ∈ (L × D S ) and decides whether D ∈ F(l).</p><p>The set of chase-terminating existential rule sets is a query language that is not semi-decidable <ref type="bibr" target="#b15">(Grahne and Onet 2018)</ref> and for which the query answering problem is decidable (by running the chase). In fact, we show that one cannot find a semi-decidable query language with similar properties. Theorem 21. There are no semi-decidable query languages that (i) express all decidable, homomorphism-closed queries and (ii) for which query answering is decidable.</p><p>To show this result, we define a set M of TMs (cf. Definition 5), show that M can be enumerated up to equivalence if there is a semi-decidable language that satisfies (i) and (ii) above (cf. Lemma 22), and finally prove that the consequence of this implication does not hold (cf. Lemma 23). Definition 5. Consider the set M of all TMs M such that: (i) The TM M halts on all inputs. (ii) If M accepts some word w, then w corresponds to a database over schema {ed}. (iii) Consider some words w and v that correspond to some D and E in D {ed} , respectively. If M accepts w and there is a homomorphism h : D → E, then M accepts v.</p><p>Intuitively, M is the set of all deciders that solve homomorphism-closed queries over databases in D {ed} . Lemma 22. If there is a semi-decidable query language F that satisfies (i) and (ii) in Theorem 21, then M is enumerable up to equivalence.</p><p>Proof. If there is a language such as F, then there is an enumerator P for L that prints out a sequence l 1 , l 2 , . . . and a decider M F that can be used to check if D ∈ F(l) for each (l, D) ∈ (L×D {ed} ). For each i ≥ 1, let M i be the TM that, on input w, performs the following computation: if w corresponds to a database D ∈ D {ed} and M F accepts (l i , D), then accept; otherwise, reject. By modifying P we can define an enumerator that prints out the sequence M 1 , M 2 , . . ., which contains M up to equivalence.</p><p>Lemma 23. The set M is not enumerable up to equivalence.</p><p>Proof Sketch. Assume that there is an enumerator that outputs a sequence M 1 , M 2 , . . . that includes M up to equivalence. We obtain a contradiction by defining a sequence D 1 , D 2 , . . . of databases and a TM M d ∈ M that diagonalises over M 1 , M 2 , . . . and D 1 , D 2 , . . . Namely, for each i ≥ 1, let D i = {ed(u 1 , u 2 ), . . . , ed(u pi+1 , u 1 )} where p i+1 is the (i+1)-th prime. Moreover, M d is the TM that, on input w, performs the computation: (1) Reject if w does not correspond to some D ∈ D {ed} . (2) Reject if D can be homembedded into a path over ed. (3) Accept if ed(u, u) ∈ D for some null u. (4) If there is some i ≥ 1 such that there are less nulls in D i than in D, the TM M i accepts some serialisation that corresponds to D i , and there is a homomorphism h : D → D i ; then reject. Otherwise, accept.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion and Conclusion</head><p>In this paper, we have established a characterization of all decidable homomorphism-closed Boolean queries. We showed that these are exactly the chase-terminating existential rule queries, that is, queries that can be expressed by a set of (non-disjunctive) existential rules for which the standard chase universally terminates irrespective of the order of rule applications (as long as it is fair).</p><p>By its nature, our result immediately shows that various extensions of our framework do not increase its expressivity:</p><p>Theorem 24. Chase-terminating existential rule queries have the same expressivity as 1. existential rule queries with guaranteed existence of some finite chase tree (for every database), 2. existential rule queries for which the chase terminates according to some fair strategy (such as datalog-first), 3. core-chase-terminating existential rule queries, 4. disjunctive chase-terminating existential rule queries.</p><p>Proof. (3) Standard-chase termination implies core-chase termination. On the other hand, core chase termination implies decidability and thus our result applies. ( <ref type="formula">1</ref>) and ( <ref type="formula">2</ref>) Standard-chase termination implies these weaker form of guarantees, which themselve imply core chase termination. (4) Obviously, every (non-disjunctive) existential rule set is a special case of a disjunctive one and for this special case, disjunctive chase termination coincides with termination of the (non-disjunctive) standard chase. On the other hand, disjunctive existential rule queries are also closed under homomorphisms, and disjunctive universal chase termination obviously implies decidability. So our result applies.</p><p>However, the applicability of our result does not stop at (syntactic) extensions of our framework, as it applies to arbitrary query languages and querying formalisms of different types. In particular we would like to stress the relationship to the very comprehensive existential rules fragment of bounded treewidth sets (bts) of rules <ref type="bibr">(Baget et al. 2011a</ref>) that is not chase-terminating and encompasses a plethora of wellknown existential rule fragments with decidable query entailment, including guarded <ref type="bibr" target="#b10">(Calì, Gottlob, and Kifer 2008)</ref>, frontier-guarded <ref type="bibr">(Baget et al. 2011a)</ref>, and glut-guarded existential rules <ref type="bibr" target="#b16">(Krötzsch and Rudolph 2011)</ref>, as well as greedy bts <ref type="bibr">(Baget et al. 2011b</ref>):</p><p>Theorem 25. Let Σ be a bounded-treewidth set of rules and Q a conjunctive query. There is a chase-terminating set</p><formula xml:id="formula_32">Σ Q of existential rules such that D, Σ |= Q iff D, Σ Q |= Goal.</formula><p>While possibly surprising, this is a straightforward consequence of decidability of conjunctive query entailment from bts and of homomorphism-closedness of existential rule queries in general. Note, however, that every Q would give rise to a different Σ Q . In fact, asking for a "uniform" chaseterminating existential rules set Σ satisfying D, Σ |= Q iff D, Σ |= Q would change the game <ref type="bibr" target="#b22">(Zhang, Zhang, and You 2015)</ref>. Such a set will not exist in all cases.</p><p>While our result addresses many of the open questions regarding expressivity of the terminating chase <ref type="bibr" target="#b18">(Krötzsch, Marx, and Rudolph 2019)</ref> an important avenue for future work is to investigate potential differences when it comes to the corresponding computational complexities. We deem it likely that not all of the discussed chase variants give rise to worst-case optimal computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proofs for Section 3</head><p>In this section, we prove the claims made in Section 3. In particular, besides proving Lemmas 5, 6, 7, 8, 9, 10, and 11, we show Lemma 26 from which the next claims (given in the order they occur in the section) follow.</p><formula xml:id="formula_33">1. |I 1 | = |I 2 | = |I 3 | = |I 4 | = |I 5 |.</formula><p>2. For each 1 ≤ i &lt; j ≤ 5 and each I ∈ I i , there is exactly one J ∈ I j with I ⊆ J .</p><p>3. Every I ∈ I i with 1 ≤ i ≤ 5 contains a unique interpretation Seed (I) ∈ I 1 , and there is a unique ordered partition Order (I) ∈ Ords such that Seed (I) ∈ Compls(Order (I)).</p><p>Recall that ∆ = Nulls(D) ∪ {u α , u ω }. We will call a D-order a database over schema {First, Last, LT, Eq, NEq} and nulls from ∆, and a D-completion a database over schema {In p , NIn p | p ∈ S} and nulls from ∆. We say that a D-completion is complete if (i) it includes {In p ( t) | p( t) ∈ D} and (ii) for every p ∈ S and tuple t ⊆ ∆ of matching arity, it contains exactly one of {In p ( t), NIn p ( t)}. Lemma 26. There is a one-to-one correspondence between the interpretations in I i (1 ≤ i ≤ 5) and the pairs of the form ( T , F D ), where T = T 1 , . . . , T k ∈ Ords is an ordered partition of ∆ with u α ∈ T 1 and u ω ∈ T k , and F D is a complete D-completion. More precisely:</p><p>• An interpretation I ∈ I 1 corresponds to a pair ( T , F D ) iff I is the union of the following databases:</p><p>-</p><formula xml:id="formula_34">D ∪ {DbDom(t) | t ∈ ∆}, -the D-order corresponding to T : {First(t) | t ∈ T 1 } ∪ {Last(t) | t ∈ T k } ∪ {Eq(t, u) | 1 ≤ i ≤ k; t, u ∈ T i } ∪ {LT(t, u), NEq(t, u), NEq(u, t) | 1 ≤ i &lt; j ≤ k, t ∈ T i , u ∈ T j }, and -F D . • An interpretation I ∈ I i (2 ≤ i ≤ 5) corresponds to ( T , F D ) iff it includes some I 1 ∈ I 1 that corresponds to ( T , F D ).</formula><p>In particular, it follows that every I ∈ I i with 1 ≤ i ≤ 5 contains a unique interpretation Seed (I) ∈ I 1 , and there is a unique ordered partition Order (I) ∈ Ords such that Seed (I) ∈ Compls(Order (I)).</p><p>Proof. The correspondence between interpretations in I 1 and pairs of the form ( T , F D ) is well defined because I 1 = T ∈Ords Compls( T ) where Compls( T ) is the set of all minimal models of R 1 and D that contain the D-order corresponding to T . In particular, every I ∈ I 1 must include a complete D-completion to satisfy ( <ref type="formula" target="#formula_4">14</ref>) and ( <ref type="formula">4</ref>), and by minimality I does not include any set of the form {In p ( t), NIn p ( t)}. Moreover, by minimality, I does not contain any other atom over predicates {First, Last, LT, Eq, NEq}.</p><p>Each I i (2 ≤ i ≤ 5) is obtained from I i-1 by applying the function Int i to each of its elements and by construction of Int i , I ⊆ Int i (I) and Int i (I) \ I does not contain any atoms on predicates from S ∪ {DbDom, First, Last, LT, Eq, NEq} ∪ {In p , NIn p | p ∈ S}. Hence the one-to-one correspondence between elements of I 1 and pairs of the form ( T , F D ) is preserved when applying Int i to elements of I i-1 to obtain the elements of I i for each 2 ≤ i ≤ 5.</p><p>Lemma 5. I 1 = T ∈Ords Compls( T ) is a universal model set of R 1 and D.</p><p>Proof. Let K be the result of some chase tree for R 1 and D that prioritises the application of rules in the order of their appearance in Figure <ref type="figure">1</ref>. By Fact 2, K is a universal model set for R 1 and D and we show that each K ∈ K is isomorphic to a unique I ∈ I 1 .</p><p>We use the one-to-one correspondence between the interpretations in I 1 and the pairs of the form ( T , F D ) described in Lemma 26. Since K is a result of the chase on R 1 and D, the domain of every K ∈ K contains all nulls in Nulls(D) and exactly two fresh nulls introduced to satisfy rules (2) and (3), respectively. We name them u α and u ω respectively, so that ∆ is the domain of K, and define a one-toone correspondence between the interpretations in K and the pairs of the form ( T , F D ) as in Lemma 26. This can be done because of the following points:</p><p>• Every K ∈ K includes D and does not contain any other atom on predicates from S because such predicates do not occur in rule heads. • Every K ∈ K includes {DbDom(t) | t ∈ ∆} and does not contain any other atom on predicate DbDom (since there are no more nulls). • Every K ∈ K includes a D-order corresponding to some T ∈ Ords and does not contain any other atom on predicates from {First, Last, LT, Eq, NEq}:</p><p>-Let ∼ be the relation over ∆ defined by t ∼ t iff Eq(t, t ) ∈ K. This is an equivalence relation because (i) {DbDom(t) | t ∈ ∆} ⊆ K and K satisfies (5) (reflexivity); (ii) K satisfies (6) (symmetry); and (iii) K satisfies (8) instantiated for R = Eq (transitivity). The equivalence classes form a partition</p><formula xml:id="formula_35">T 1 , . . . , T k of ∆ such that {Eq(t, u) | 1 ≤ i ≤ k; t, u ∈ T i } ⊆ K.</formula><p>-For every u, t ∈ ∆, K contains at least one of {Eq(u, t), NEq(u, t)} because it satisfies (9). Moreover, K cannot contain both Eq(u, t) and NEq(u, t) because the rules ( <ref type="formula">5</ref>), ( <ref type="formula">6</ref>) and ( <ref type="formula">8</ref>) have a higher priority than (9). Hence {NEq(t, u), -For every u, t ∈ ∆ such that NEq(u, t) ∈ K, K contains at least one of {LT(u, t), LT(t, u)} because it satisfies (13). -For every u, t ∈ ∆, if First(u) ∈ K (i.e. u ∼ u α ) and First(t) / ∈ K (i.e. t ∼ u α ) then LT(u, t) ∈ K because of ( <ref type="formula">11</ref>).</p><formula xml:id="formula_36">NEq(u, t) | 1 ≤ i &lt; j ≤ k, t ∈ T i , u ∈ T j } ⊆ K. -K includes {First(u) | u ∼ u α } and {Last(u) | u ∼ u ω }</formula><p>-For every u, t ∈ ∆, if Last(u) ∈ K (i.e. u ∼ u ω ) and Last(t) / ∈ K (i.e. t ∼ u ω ) then LT(t, u) ∈ K because of ( <ref type="formula">12</ref>).</p><p>-If LT(u, t) ∈ K then LT(u , t ) ∈ K for all u ∼ u and t ∼ t because K satisfies (8).</p><p>-K contains the transitive closure of LT because it satisfies (10).</p><p>-Since the rules (11), ( <ref type="formula">12</ref>), ( <ref type="formula">5</ref>), ( <ref type="formula">6</ref>), (8), and (10) have a higher priority than (13), then K cannot contain both LT(u, t) and LT(t, u). -Hence T 1 , . . . , T k can be ordered in a way such that {LT(t, u) | 1 ≤ i &lt; j ≤ k, t ∈ T i , u ∈ T j } ⊆ K and the ordered partition corresponds to some T ∈ Ords as required. • Every K ∈ K contains a complete D-completion F D and does not contain any other atom on predicates from {In p , NIn p | p ∈ S}:</p><p>-K includes {In p ( t) | p( t) ∈ D} because it satisfies (4).</p><p>-For every p ∈ S and tuple t ⊆ ∆ of matching arity, K contains at least one of {In p ( t), NIn p ( t)} because it satisfies ( <ref type="formula" target="#formula_4">14</ref>). We show that it does not contain both. The rules of the form ( <ref type="formula" target="#formula_4">14</ref>) have the lowest priority and applying such a rule can only trigger the application of some rules of the form (8), which themselves cannot trigger the application of any rules but (8). Hence, (i) the application of these rules in the chase tree happens after the construction of the D-order in K, and (ii) when a rule of the form ( <ref type="formula" target="#formula_4">14</ref>) is applied and adds some In p ( t) (resp. NIn p ( t)), the exhaustive application of rules (8) adds all In p ( t ) (resp. NIn p ( t )) such that t ∼ t, where t ∼ t iff t i ∼ t i for every i. Suppose for a contradiction that there exists u such that In p ( u) ∈ K and NIn p ( u) ∈ K. Since the rules ( <ref type="formula" target="#formula_4">14</ref>) and ( <ref type="formula">8</ref>) are the only ones that have predicates from {In p , NIn p | p ∈ S} in the head, it follows that there exist In p ( u 1 ) ∈ K and NIn p ( u 2 ) ∈ K that have both been added by some application of ( <ref type="formula" target="#formula_4">14</ref>) and are such that u 1 ∼ u and u 2 ∼ u. Assume that In p ( u 1 ) was added first. Then by (ii) In p ( u 2 ) has been added before any new application of ( <ref type="formula" target="#formula_4">14</ref>), and the rule x∈ x DbDom(x) → In p ( x) ∨ NIn p ( x) with the substitution that maps x to u 2 was already satisfied, contradicting the introduction of NIn p ( u 2 ).</p><p>• For every ( T , F D ), there exists K ∈ K that corresponds to ( T , F D ). The existence of K is witnessed by the path of the chase tree such that for every vertex labelled with E where a disjunctive rule ( <ref type="formula">9</ref>), (13), or ( <ref type="formula" target="#formula_4">14</ref>) is applied, the path chooses the child labelled with C i = E ∪ σ i (η i ) where σ i (η i ) is included in F D or in the D-order corresponding to T .</p><p>Hence, we can define a one-to-one correspondence between interpretations in K and interpretations in I 1 using the corresponding pairs of the form ( T , F D ). By construction, every K ∈ K and I ∈ I 1 that are in correspondence are isomorphic (note that since we choose to name the two fresh nulls u α and u ω , they are actually identical).</p><p>Lemma 27. Given some I ∈ I 1 , Int 2 (I) is isomorphic to the unique interpretation in a result of the chase over R 2 and I.</p><p>Proof. We will let Order (F) = T 1 , . . . , T k . The interpretation Int 2 (I) is equal to:</p><formula xml:id="formula_37">I ∪ {Root(u 1 )} ∪ {Chi(u w , u wz ) | wz ∈ Z, 2 ≤ z ≤ k} ∪ {Leaf(u w ) | w ∈ Z; end (w) = k} ∪ {Rep(x, u w ) | w ∈ Z; x ∈ T end(w) } ∪ {In p (u w1 , . . . , u w Ar (p) ) | In p (t 1 , . . . , t Ar (p) ) ∈ I; w i ∈ Z; t i ∈ T end(wi) ; 1 ≤ i ≤ Ar (p)} ∪ {NIn p (u w1 , . . . , u w Ar (p) ) | NIn p (t 1 , . . . , t Ar (p) ) ∈ I; w i ∈ Z; t i ∈ T end(wi) ; 1 ≤ i ≤ Ar (p)}.</formula><p>We describe a chase over R 2 and I that prioritises rule (18) step by step (note that if we do not prioritise (18), we could get a result which is not isomorphic to Int 2 (I)). Instead of constructing an isomorphism by giving for each fresh null introduced during the chase its counterpart in Int 2 (I), we directly set the the names of the fresh nulls so that the chase result coincides with Int 2 (I). Note that no rule in Figure <ref type="figure">1</ref> is applicable to I and that applying a rule in Figure <ref type="figure">2</ref> cannot make a rule in Figure <ref type="figure">1</ref> applicable.</p><p>• Apply ρ, σ with ρ = (15) and σ the substitution that maps x to some t ∈ T 1 (recall that {First(t) | t ∈ T 1 } ⊆ I). This introduces a fresh null that we call u 1 , and adds Root(u 1 ) and Rep(t, u 1 ). • Apply exhaustively (18): add Rep(t, u 1 ) for all t ∈ T 1 .</p><p>• For 2 ≤ i ≤ k:</p><p>-Choose one t 1 ∈ T 1 and one t i ∈ T i and apply ρ, σ with ρ = (16) and σ the substitution that maps x to t 1 , v to u 1 , and z to t i (recall that the atoms on predicate LT in I are {LT(t, u) | 1 ≤ j &lt; j ≤ k, t ∈ T j , u ∈ T j }). This introduces a fresh null that we call u 1 i and adds Chi(u 1 , u 1 i ), Rep(t i , u 1 i ) (note that this is the first fact of the form Rep(t i , x) with t i ∈ T i that we introduce). -Apply exhaustively (18): add Rep(t, u 1 i ) for all t ∈ T i .</p><p>• Continue applying ( <ref type="formula">16</ref>) and ( <ref type="formula" target="#formula_5">18</ref> ).</p><p>-Apply exhaustively rules ( <ref type="formula">27</ref>) and ( <ref type="formula">28</ref>). This process introduces nulls t j+3 , . . . , t j+ i and adds the following atoms (cf. proof of Lemma 28): ).</p><formula xml:id="formula_38">* S b i 1 (t j+2 w ), . . . , S b i i (t j+ i+1 w ), * Nxt(t j+2 w , t<label>j+3</label></formula><p>At this point, for every null u w such that Leaf(u w ) ∈ I, we have added startConf (I, u w ) and loadS (I, u w ) and no rule is applicable. Proof. Similar to the proof of Lemma 7, using Lemmas 7 and 29.</p><p>Before proving Lemma 9, we introduce some notation about TM runs. A configuration for a TM M = Q, Γ, δ is a finite sequence C = C 1 , . . . , C k where C i = {q, a} for some i ≤ k, q ∈ Q, and a ∈ Γ, while for each j = i, C j = {a j } for some a j ∈ Γ. The successor configuration of C under M , denoted M ( C), is the configuration C = C 1 , . . . , C k+1 satisfying, assuming δ(q, a) = (q , a , l),</p><formula xml:id="formula_39">C j ∩ Γ = {a } if j = i, { } if j = k + 1, C j ∩ Γ otherwise, while C j ∩ Q = {q } if j = max(1, i + l), otherwise ∅. For a word γ = γ 1 , . . . , γ k , let StConf (M, γ) denote the sequence {q S , γ 1 }, {γ 2 }, . . . , {γ k }, { }. Let Comp(M, γ) = C 1 , C 2 , .</formula><p>. . be the (possibly finite) configuration sequence satisfying C 1 = StConf (M, γ) as well as C i+1 = M ( C i ), whenever defined (otherwise -and only then -the sequence ends at i). Note that M halts on γ if Comp(M, γ) is finite, and accepts γ if the last configuration in Comp(M, γ) features q A . Lemma 30. Given some I ∈ I 4 , Int 5 (I) is isomorphic to the unique interpretation in a result of the chase over R 5 and I. {Nxt</p><formula xml:id="formula_40">+ (t i w , t j w ) | 1 ≤ i &lt; j ≤ |S| + 1} ∪ {End(t i,|S|+i w ) | 2 ≤ i ≤ } ∪ {Nxt(t i,j-1 w , t i,j w ) | 2 ≤ i ≤ , 2 ≤ j ≤ |S| + i} ∪ {Nxt + (t i,j w , t i,j w ) | 1 ≤ i ≤ , 1 ≤ j &lt; j ≤ |S| + i} ∪ {Stp(t i-1,j w , t i,j w ) | 3 ≤ i ≤ , 1 ≤ j ≤ |S| + i -1} ∪ {S a (t i,j w ) | 2 ≤ i ≤ , 1 ≤ j ≤ |S| + i, a ∈ C i,j ∩ Γ} ∪ {Hd q (t i,j w ) | 2 ≤ i ≤ , 1 ≤ j ≤ |S| + i, q ∈ C i,j ∩ Q} ∪ {Goal | 1 ≤ j ≤ |S| + , q A ∈ C ,j };</formula><p>We describe a (Datalog-first) chase over R 5 and I step by step. We directly set the the names of the fresh nulls so that the chase result coincides with Int 5 (I). Note that no rule in Figures 1, 2, 3, 4, or 5 is applicable to I and that applying a rule in Figure <ref type="figure">6</ref> cannot make a rule in Figures <ref type="figure">1,</ref><ref type="figure">2</ref>, 3, 4, or 5 applicable.</p><p>We first apply exhaustively (40) and ( <ref type="formula">41</ref>) which compute a transitive closure on the atoms of the form Nxt(e i w , e j w ) and Nxt(t i w , t j w ) in I. This adds the atoms {Nxt + (e i w , e j w ) | 1 ≤ i &lt; j ≤ } described in point (2) and {Nxt + (t i w , t j w ) | 1 ≤ i &lt; j ≤ |S| + 1} of the first line in point (3). For every null u w such that Leaf(u w ) ∈ I, S = branchTape(I, u w ) and Comp(M, S) = C 1 , . . . , C , we show by induction that for every 2 ≤ i ≤ the following atoms belong to the chase result:</p><p>• End(t i,|S|+i w</p><p>),</p><p>• Nxt(t i,j-1 w , t i,j w ) for 2 ≤ j ≤ |S| + i, • Nxt + (t i,j w , t i,j w ) for 1 ≤ j &lt; j ≤ |S| + i, • Stp(t i-1,j w , t i,j w ) for 1 ≤ j ≤ |S| + i -1, • S a (t i,j w ) for 1 ≤ j ≤ |S| + i, a ∈ C i,j ∩ Γ, • Hd q (t i,j w ) for 1 ≤ j ≤ |S| + i, q ∈ C i,j ∩ Q. Base case i = 2. Recall that for every Leaf(u w ) ∈ I with serialisation S = branchTape(I, u w ), I includes: {Ld 1 (u w , t 1 w , u w ), Hd q S (t 1 w ), End(t |S|+1 • For every 1 &lt; j ≤ |S| + 1, let a ∈ C 1,j ∩ Γ = C 2,j ∩ Γ.</p><p>-Apply ρ, σ with ρ the instantiation of (45) for transition (q S , S[1]) → (r, b, +1) and tape symbol S[j], and σ(x) = t 1 w , σ(y) = t j w . This introduces a fresh null u ρ,σ,z = t 2,j w and adds Stp(t j w , t 2,j w ) and S S[j] (t 2,j w ).</p><p>• Apply ρ, σ with ρ the instantiation of ( <ref type="formula">44</ref>) for (q S , S[1]) → (r, b, +X) and σ(x) = t 1 w . This introduces a fresh null u ρ,σ,z = t 2,1 w and adds Stp(t 1 w , t 2,1 w ) and S b (t 2,1 w ). ).</p><p>• Apply exhaustively (42), adding all atoms Nxt(t 2,j-1 w , t 2,j w ) for 2 ≤ j ≤ |S| + 2. • Apply exhaustively ( <ref type="formula">40</ref>) and ( <ref type="formula">41</ref>), adding all atoms Nxt + (t 2,j w , t 2,j w ) for 1 ≤ j &lt; j ≤ |S| + 2. • Apply (47) and add Hd r (t 2,2 w ).</p><p>Induction step: Assume the property is true for some 2 ≤ i &lt; and let j 0 be the unique C i,j0 such that C i,j0 ∩ Q = ∅, {q 0 } = C i,j0 ∩ Q, {a 0 } = C i,j0 ∩ Γ, and (q 0 , a 0 ) → (r, b, +X) ∈ δ. By definition, we have C i+1,j0 ∩ Γ = {b}, C i+1,j ∩ Γ = C i,j ∩ Γ for every j = j 0 , and C i+1,j0+X ∩ Q = {r}.</p><p>• For every j &gt; j 0 (resp. j &lt; j 0 ), let a ∈ C i,j ∩ Γ = C i+1,j ∩ Γ.</p><p>-Apply ρ, σ with ρ the instantiation of (45) (resp. ( <ref type="formula">46</ref>)) for transition (q 0 , a 0 ) → (r, b, +X) and tape symbol a, and σ(x) = t i,j0 w , σ(y) = t i,j w . This introduces a fresh null u ρ,σ,z = t i+1,j w and adds Stp(t i,j w , t i+1,j w</p><p>) and S a (t i+1,j w</p><p>). • Apply ρ, σ with ρ the instantiation of ( <ref type="formula">44</ref>) for (q 0 , a 0 ) → (r, b, +X) and σ(x) = t i,j0 w . This introduces a fresh null u ρ,σ,z = t i+1,j0 w and adds Stp(t i,j0 w , t i+1,j0 w</p><p>) and S b (t i+1,j0 w</p><p>).</p><p>• Apply ρ, σ with ρ = (43) with σ(x) = t ).</p><p>• Apply exhaustively (42), adding all atoms Nxt(t i+1,j-1 w , t i+1,j w ) for 2 ≤ j ≤ |S| + i + 1.</p><p>• Apply exhaustively ( <ref type="formula">40</ref>) and ( <ref type="formula">41</ref>), adding all atoms Nxt + (t i+1,j w , t i+1,j w ) for 1 ≤ j &lt; j ≤ |S| + i + 1.</p><p>• If X = +1, apply (47) and add Hd r (t i+1,j0+X w ).</p><p>• If X = -1, then j 0 &gt; 1 (since the TM never attempts to move left on the first position of the tape): apply (48) and add Hd r (t i+1,j0+X</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Consider a rule set Σ and database D, and let M be the set of all models of Σ, D. Then I is a universal model set for Σ and D if I ⊆ M and I is universal for M. Fact 1. If I is a universal model set for Σ and D then, for every database C, we have Σ, D |= C iff I |= C for all I ∈ I.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Lemma 5 .</head><label>5</label><figDesc>I 1 = T ∈Ords Compls( T ) is a universal model set of R 1 and D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Lemma 9. I 5 = {Int 5 (I) | I ∈ I 4 } is a universal model set of R 5 and D. Proving Lemma 4 To complete the proof of Lemma 4, we set M = I 5 . For I ∈ M, let Db(I) = {p( t) | In p ( t) ∈ I} denote the completed database created by R 1 . Due to rule (4) in Figure 1, there is a homomorphism D → Db(I). Moreover, the representation tree constructed for I by R 2 has a branch that is maximal, i.e., has |Order (I)| nodes; this branch has a leaf u w with |w| = |Order (I)|. We obtain a homomorphism Db(I) → branchDb(I, u w ). Lemma 4 now follows from Lemma 9 and Lemmas 11 and 10 below. Lemma 10. If D ∈ Q, then Goal ∈ I for each I ∈ M. Proof. As shown above, there is a homomorphism D → branchDb(I, u w ) for the node u w where |w| = |Order (I)|. Since Q is closed under homomorphisms, D ∈ Q implies branchDb(I, u w ) ∈ Q. By the correctness of our TM simulation, we obtain Goal ∈ I. Lemma 11. If D / ∈ Q, then Goal / ∈ I for some I ∈ M. Proof. Consider some I ∈ M such that Db(I) = D and NEq(t, u) ∈ I for each t, u ∈ Nulls(D) with t = u. Let u w denote the leaf node with |w| = |Order (I)| as before. Then branchDb(I, u w ) is isomorphic to Db(I) = D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>57) Lemma 16. R 6 expresses the query Q. Proof. For a database D over S, let M be the universal model set constructed in Section 3. If D ∈ Q, then R 5 , D |= Goal by Theorem 3. Then R 6 , D |= Goal since any model of R 6 and D must contain Goal by Lemma 15.Conversely, if D / ∈ Q, then there is U ∈ M with Goal / ∈ U. By Lemma 13, there is a model I of brake(R 5 , Halt) with I -= U, and hence Goal / ∈ I. By construction of M, none of the rules (54)-(57) applies to U, and hence I is also a model of R 6 , i.e., R 6 , D |= Goal.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Lemma 8 .</head><label>8</label><figDesc>I 4 = {Int 4 (I) | I ∈ I 3 } is a universal model set of R 4 and D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Proof.</head><label></label><figDesc>The interpretation Int 5 (I) is equal to the union of the following interpretations:1. I ; 2. For each w ∈ Z with b 1 • • • b the binary representation of |w| + 1: {Nxt + (e iw , e j w ) | 1 ≤ i &lt; j ≤ }. 3. For each u w ∈ Nulls(I) with S = branchTape(I, u w ), Comp(M, S) = C 1 , . . . , C , and C i = C i,1 , . . . , C i,|S|+i for each 1 ≤ i ≤ , the database Run(u w ) defined as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>{Nxt(t j-1 w , t j w ) | 2 ≤ j ≤ |S| + 1} ∪ {S a (t j w ) | 1 ≤ j ≤ |S|, a = S[j]}. Moreover C 1 = StConf (M, S) = {q S , S[1]}, {S[2]}, . . . , {S[|S|]}, { }. Let (q S , S[1]) → (r, b, +1) ∈ δ (recallthat we assume that the TM will never attempt to move left on the first position of the tape). By definition, we haveC 2,1 ∩ Γ = {b}, C 2,j ∩ Γ = C 1,j ∩ Γ = {S[j]} for every 1 &lt; j ≤ |S| + 1, and C 2,2 ∩ Q = {r}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>by definition of u α , u ω and because it satisfies (8). Assuming w.l.o.g. that T 1 is the equivalence class of u α and T k that of u ω :{First(t) | t ∈ T 1 } ∪ {Last(t) | t ∈ T k } ⊆ K.-K does not include any other atom over First or Last because rules (2) and (3) are applied only once.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>) exhaustively as done in the previous step, introducing all nulls of the form u w with w ∈ Z, and adding facts {Chi(u w , u wz )| wz ∈ Z, 2 ≤ z ≤ k} and {Rep(x, u w ) | w ∈ Z; x ∈ T end(w) }. • Apply exhaustively (17) and add {Leaf(u w ) | w ∈ Z; end (w) = k} (recall that {Last(t) | t ∈ T k } ⊆ I).• Apply exhaustively (19): for all In p (t 1 , . . . , t Ar (p) ) ∈ I, add all In p (u w1 , . . . , u w Ar (p) ) where t i ∈ T end(wi) . • Apply exhaustively (20): for all NIn p (t 1 , . . . , t Ar (p) ) ∈ I, add all NIn p (u w1 , . . . , u w Ar (p) ) where t i ∈T end(wi) .-Ld x (u w , t j w , u w1 , . . . , u wx ) where j = j s S (p x 1 , u w1 , . . . , u wx ); -Rdy x (u w , t j w , u w1 , . . . , u wx ) where j = j e S (p x n, u w1 , . . . , u wx ); for 1 ≤ g ≤ n: We have obtained an atom Rdy m(u w , t j w , u 1 , . . . , u 1 ) with j = j e S ( m, u 1 , . . . , u 1 ) = |S| + 1. Apply (37) and add S (t For all u wi ∈ branch(u w ) and atoms of the form LdE(u wi , t j+1 w , t j+ i+2 Apply ρ, σ with ρ = (30) and σ(v) = u wi , σ(x s ) = t j+1 w , σ(x e ) = t j+ i+2 This introduces two fresh nulls u ρ,σ,z1 = t j+2 w and u ρ,σ,z = t j+ i+1</figDesc><table><row><cell cols="5">* Ld p x g (u w , t j w , u w1 , . . . , u wx ) where j = j s S (p x g , u w1 , . . . , u wx );</cell></row><row><cell cols="5">* Rdy p x g (u w , t j w , u w1 , . . . , u wx ) where j = j e S (p x g , u w1 , . . . , u wx );</cell></row><row><cell cols="5">* for In p x g (u w1 , . . . , u wx ) ∈ I and j = j s S (p x g , u w1 , . . . , u wx ):</cell></row><row><cell>• S p x g (t j w ),</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">• Nxt(t j w , t j+1 w ), . . . , Nxt(t</cell><cell>j+Σ x l=1 l +x+1 w</cell><cell>, t j+Σ x l=1 l +x+2 w</cell><cell>),</cell></row><row><cell cols="2">• LdE(u w1 , t j+1 w , t j+ 1+2 w</cell><cell cols="3">), . . . , LdE(u wx , t j+Σ x-1 l=1 l +x w</cell><cell>, t j+Σ x l=1 l +x+1 w</cell><cell>).</cell></row><row><cell>• |S|+1 w</cell><cell cols="4">) and End(t</cell><cell>|S|+1 w</cell><cell>).</cell></row><row><cell cols="5">• w</cell><cell>and adds the atoms: S (t j+1 w ), Nxt(t j+1 w , t j+2 w ),</cell></row><row><cell cols="3">Cpy(e 1 wi , e i wi , t j+2 w , t j+ i+1 w</cell><cell cols="2">), Nxt(t j+ i+1 w</cell><cell>, t j+ i+2</cell></row></table><note><p><p><p>w ): w , σ(y 1 ) = e 1 wi and σ(y ) = e i wi where b i 1 • • • b i i is the binary representation of |w i | + 1.</p>w</p>) and S (t j+ i+2 w</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>• Apply ρ, σ with ρ = (43) with σ(x) = t</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell cols="2">|S|+1 w</cell><cell cols="3">and σ(z) = t</cell><cell>2,|S|+1 w</cell><cell>. This introduces a fresh null</cell></row><row><cell>u ρ,σ,v = t 2,|S|+2 w</cell><cell>and adds Nxt(t</cell><cell>2,|S|+1 w</cell><cell>, t 2,|S|+2 w</cell><cell cols="2">), S (t</cell><cell>2,|S|+2 w</cell><cell cols="2">) and End(t</cell><cell>2,|S|+2 w</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>We always mean universal termination, i.e., for every database.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgements This work is partly supported by <rs type="funder">DFG</rs> in project number <rs type="grantNumber">389792660</rs> (<rs type="grantNumber">TRR 248</rs>, <rs type="funder">Center for Perspicuous Systems)</rs>, by <rs type="funder">BMBF in the Center for Scalable Data Analytics and Artificial Intelligence</rs> (ScaDS.AI), by the <rs type="funder">Center for Advancing Electronics Dresden</rs> (cfaed), by the <rs type="funder">ERC</rs> <rs type="grantName">Consolidator Grant</rs> <rs type="projectName">DeciGUT</rs> (project number <rs type="grantNumber">771779</rs>), and by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_p2bqYEv">
					<idno type="grant-number">389792660</idno>
				</org>
				<org type="funding" xml:id="_EXQ6gG3">
					<idno type="grant-number">TRR 248</idno>
				</org>
				<org type="funded-project" xml:id="_XkNTWjK">
					<idno type="grant-number">771779</idno>
					<orgName type="grant-name">Consolidator Grant</orgName>
					<orgName type="project" subtype="full">DeciGUT</orgName>
				</org>
				<org type="funded-project" xml:id="_72FApdp">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Lemma 6. I 2 = {Int 2 (I) | I ∈ I 1 } is a universal model set of R 2 and D.</p><p>Proof. By Lemmas 5 and 27, I 2 only contains models of R 2 and D. We show that for every model M of R 2 and D, there exists I 2 ∈ I 2 and a homomorphism h 2 : I 2 → M.</p><p>1. Let M be a model of R 2 and D. 2. By Lemma 5: since M is a model of R 2 ⊇ R 1 and D, there exist I 1 ∈ I 1 and a homomorphism h 1 : I 1 → M. 3. By Lemma 27: since I 1 ∈ I 1 , there exists a chase over R 2 and I 1 such that the unique interpretation J in its result is such that there exists an isomorphism g 2 : Int 2 (I 1 ) → J . 4. By definition of J , and since no rule from R 1 is applied in the chase of over R 2 and I 1 (see proof of <ref type="bibr">Lemma 27)</ref> and R 2 \ R 1 contains no disjunctive rules, it follows that J is a universal model of R 2 \ R 1 and I 1 . 5. By (1), ( <ref type="formula">2</ref>) and ( <ref type="formula">4</ref>), there exists a homomorphism g 1 : J → M that extends h 1 . 6. Let I 2 = Int 2 (I 1 ) ∈ I 2 . By (3) and ( <ref type="formula">5</ref>), there is an homomorphism h 2 = g 2 • g 1 : I 2 → M.</p><p>In the next proofs, we will use the following notation. Given a chase tree node labelled C i = E ∪σ i (η i ) and obtained by applying some ρ, σ to its parent node labelled by E, then for each variable y of ρ not in the domain of σ, we denote by u σ,ρ,y the fresh null such that σ i (y) = u σ,ρ,y where σ i is as introduced in Definition 2. Lemma 28. Given some I ∈ I 2 , Int 3 (I) is well-defined and Int 3 (I) is isomorphic to the unique interpretation in a result of the chase over R 3 and I.</p><p>Proof. We will let Order (I) = T 1 , . . . , T k . The interpretation Int 3 (I) is equal to the union of the following databases: </p><p>We describe a (Datalog-first) chase over R 3 and I step by step. We directly set the the names of the fresh nulls so that the chase result coincides with Int 3 (I). Note that no rule in Figures 1 or 2 is applicable to I and that applying a rule in Figure <ref type="figure">3</ref> cannot make a rule in Figures 1 or 2 applicable.</p><p>• Apply ρ, σ with ρ = (21) and σ(u) = u 1 . This introduces two fresh nulls, u σ,ρ,y1 = e 1 1 and u σ,ρ,y2 = e 2 1 and adds Enc(u 1 , e 1 1 , e 2 1 ), S 0 (e 1 1 ), Nxt(e 1 1 , e 2 1 ) and S 1 (e 2 1 ). We show by induction on p that for every w ∈ Z of length |w| = p and z ∈ {1, . . . , k} such that wz ∈ Z, our chase sequence adds EncPos(wz), and CpyPlusOne(w, wz). Case p = 1. In this case, w = 1 and z ∈ {2, . . . , k}.</p><p>• For 2 ≤ i ≤ k:</p><p>-Apply ρ, σ with ρ = (22) and σ(u) = u 1 , σ(y 1 ) = e 1 1 , σ(y ) = e 2 1 , σ(v) = u 1 i . This introduces two fresh nulls, u σ,ρ,z1 = e 1 1 i and u σ,ρ,z = e 2 1 i and adds Enc(u 1 i , e 1 1 i , e 2 1 i ) and Cpy +1 (e 1 1 , e 2 1 , e 1 1 i , e 2 1 i ). -Apply (23): add S 1 (e 1 1 i ), Nxt(e 1 1 i , e 2 1 i ), S 1 (e 2 1 i ). • By induction hypothesis, Enc(u w , e 1</p><p>w , e w ) was added by the chase sequence. Apply ρ, σ with ρ = (22) and σ(u) = u w , σ(y 1 ) = e 1 w , σ(y ) = e w , σ(v) = u wz . This introduces two fresh nulls, u σ,ρ,z1 = e 1 wz and u σ,ρ,z = e wz and adds Enc(u wz , e 1 wz , e wz ) and Cpy +1 (e 1 w , e w , e 1 wz , e wz ). • By induction hypothesis, the chase sequence added S b i (e i w ), 1 ≤ i ≤ , and Nxt(e i-1 w , e i w ), 2 ≤ i ≤ . We distinguish two cases, depending on the value of b 1 .</p><p>(1) In the case where b 1 = 0, we have = and b</p><p>-Apply ρ, σ with ρ = (25) and σ(y 1 ) = e 1 w , σ(y ) = e w , σ(y 2 ) = e 2 w , σ(y 3 ) = e 3 w , σ(z 1 ) = e 1 wz , σ(z ) = e wz . This introduces a fresh null, u σ,ρ,z2 = e 2 wz , and adds the atoms Cpy(e 2 w , e w , e 2 wz , e wz ), S 1 (e 1 wz ), and Nxt(e 1 wz , e 2 wz ). -While Cpy(e -1</p><p>w , e w , e -1 wz , e wz ) has not been introduced, apply (28), introducing fresh nulls e i wz for 2 &lt; i &lt; and adding atoms Cpy(e i w , e w , e i wz , e wz ), S bi-1 (e i-1 wz ), and Nxt(e i-1 wz , e i wz ). -Apply ( <ref type="formula">27</ref>) and add S b -1 (e -1 wz ), Nxt(e -1 wz , e wz ), S 1 (e wz ). -While no atom of the form Cpy(e j w , e w , e j wz , e wz ) or Cpy +1 (e -1 w , e w , e -1 wz , e wz ) have been introduced, and for i starting from 2 and growing by one at each cycle, apply the applicable ρ, σ among: * ρ = (25) and σ(y 1 ) = e i-1 w , σ(y ) = e w , σ(y 2 ) = e i w , σ(y 3 ) = e i+1 w , σ(z 1 ) = e i-1 wz , σ(z ) = e wz . This introduces a fresh null, u σ,ρ,z2 = e i wz , and adds the atoms Cpy(e i w , e w , e i wz , e wz ), S 1 (e i-1 wz ) = S bi-1 (e i-1 wz ), and Nxt(e i-1 wz , e i wz ). * ρ = (26) and σ as above. This introduces a fresh null, u σ,ρ,z2 = e i wz , and adds the atoms Cpy +1 (e i w , e w , e i wz , e wz ), S 0 (e i-1 wz ) = S bi-1 (e i-1 wz ), and Nxt(e i-1 wz , e i wz ).</p><p>-If an atom of the form Cpy(e j w , e w , e j wz , e wz ) is introduced at some point (i.e. the applicable ρ, σ in the previous step is such that ρ = (25)), we use a sequence of chase steps similar to the case b 1 = 0, and obtain the required atoms.</p><p>-Otherwise, Cpy +1 (e -1 w , e w , e -1 wz , e wz ) is introduced at the end of the loop. Apply the applicable ρ, σ among:</p><p>wz , σ(z ) = e wz with = . This adds S 1 (e -1 wz ), Nxt(e -1 wz , e wz ), and S 1 (e wz ). * ρ = (24) and σ is as above but = +1 so that σ(z 1 ) = e -1 wz = e -2 wz . This introduces a new null u σ,ρ,z2 = e -1 wz and adds S 0 (e -2 wz ), Nxt(e -2 wz , e -1 wz ), S 0 (e -1 wz ), Nxt(e -1 wz , e wz ) and S 1 (e wz ). Lemma 7.</p><p>Proof. Similar to the proof of Lemma 6, using Lemmas 6 and 28.</p><p>Lemma 29. Given some I ∈ I 3 , Int 4 (I) is well-defined and Int 4 (I) is isomorphic to the unique interpretation in a result of the chase over R 4 and I.</p><p>Proof. Before giving the extension of Int 4 (I), we introduce some notation. Consider some fact of the form Leaf(u w ) ∈ I and let S = branchTape(I, u w ). By construction, S = e 1 • • • e |branchDb(I,uw)| where each e i corresponds to the serialisation of some p x g (u w1 , . . . , u wx ) ∈ branchDb(I, u w ) and is of the form p</p><p>For every p x g ∈ S and u w1 , . . . , u wx ⊆ branch(u w ), let j s S (p x g , u w1 , . . . , u wx ) and j e S (p x g , u w1 , . . . , u wx )-1 be the indexes where the serialisation of p x g (u w1 , . . . , u wx ) starts and ends respectively if p x g (u w1 , . . . , u wx ) ∈ branchDb(I, u w ), and otherwise j s S (p x g , u w1 , . . . , u wx ) = j e S (p x g , u w1 , . . . , u wx ) be the index where starts the serialisation of the first fact of branchDb(I, u w ) that follows p x g (u w1 , . . . , u wx ) according to ≺ (and |S| + 1 if there is no such fact). (Recall that ≺ is defined before Lemma 8.) It is easy to verify that: , where u w 1 , . . . , u w x comes right after u w1 , . . . , u wx in the lexicographic order according to ≺.</p><p>Note that j e S (p m n , u 1 , . . . , u 1 ) = |S| + 1 and that for every p x g (u w1 , . . . , u wx ) ∈ branchDb(I,</p><p>Finally, let J S (u w ) be the set of indexes of S where starts the sequence b</p><p>The interpretation Int 4 (I) is equal to the union of the following databases:</p><p>1. I ; 2. For every Leaf(u w ) ∈ I with serialisation S = branchTape(I, u w ), the database startConf (I, u w ):</p><p>3. For every Leaf(u w ) ∈ I with serialisation S = branchTape(I, u w ), the database loadS (I, u w ) defined as follows:</p><p>We describe a (Datalog-first) chase over R 4 and I step by step. We directly set the the names of the fresh nulls so that the chase result coincides with Int 4 (I). Note that no rule in Figures <ref type="figure">1,</ref><ref type="figure">2</ref>, or 3 is applicable to I but that applying rule (30) may trigger the application of the "copy" rules ( <ref type="formula">27</ref>) and ( <ref type="formula">28</ref>) in Figure3.</p><p>For every Leaf(u w ) ∈ I with serialisation S = branchTape(I, u w ):</p><p>• Apply ρ, σ with ρ = (31) and σ that maps u to u w . This introduces a fresh null that we call t 1 w and adds atoms Ld 1 (u w , t 1 w , u w ) and Hd q S (t 1 w ). Note that j s S (p 1 1 , u w ) = 1 so that we have indeed added Ld 1 (u w , t</p><p>-Apply (32) to Ld 1 (u w , t <ref type="formula">38</ref>) and add Rdy p 1 g (u w , t j w , u wi ). Note that j = j s S (p 1 g , u wi ) = j e S (p 1 g , u wi ). * Else, In p 1 g (u wi ) ∈ I: apply ρ, σ with ρ the instantiation of (29) for p 1 g , and σ(u) = u w , σ(t) = t j w and σ(v) = u wi . This introduces three fresh nulls u ρ,σ,x1 </p><p>otherwise. Note that j = j e S (p 1 g , u wi ) = j s S (p 1 g+1 , u wi ), independently of whether In p 1 g (u wi ) is in I.</p><p>-Apply (34) and add Rdy 1 (u w , t</p><p>and add Ld 1 (u w , t j w , u wi+1 ) with j = j e S (p 1 n, u wi ) = j s S (p 1 1 , u wi+1 ). Recall that u wi+1 comes right after u wi in the lexicographic order according to ≺.</p><p>• At the end of the above loop, we obtain an atom Rdy 1 (u w , t j e S (p 1 n ,u1) w , u 1 ). Apply the instantiation of (36) Rdy 1 (u, t, v) ∧ Root(v) → Ld 2 (u, t, u, u) and add Ld 2 (u w , t j e S (p 1 n ,u1) , u w , u w ). Note that j e S (p 1 n, u 1 ) = j s S (p 2 1 , u w , u w ). • Repeat the process, so that we obtain the atoms of the following form for 2 ≤ x ≤ m and u w1 , . . . , u wx ∈ branch(u w ):</p><p>w</p><p>).</p><p>We have shown that all atoms of Run(u w ) but Goal belong to the chase result. Finally, for every null u w such that Leaf(u w ) ∈ I, S = branchTape(I, u w ) and Comp(M, S) = C 1 , . . . , C , if there exists j such that Hd q A (t ,j w ) ∈ Run(u w ), apply (39) and add Goal. Proof. Similar to the proof of Lemma 8, using Lemmas 8 and 30.</p><p>Lemma 10.</p><p>Proof. Let I ∈ M. We have shown that there is a homomorphism D → branchDb(I, u w ) for the node u w where</p><p>. . , C be the computation of M on the serialisation S = branchTape(I, u w ) of the database branchDb(I, u w ). Since branchDb(I, u w ) ∈ Q and M decides Q, C 1 , . . . , C is such that C features q A . By construction of Run(u w ) (see proof of Lemma 30), it follows that Goal ∈ Run(u w ). Hence Goal ∈ I. ∈ Q and M decides Q, C 1 , . . . , C is such that C does not feature q A . By construction of Run(u w ) (see proof of Lemma 30), it follows that Goal / ∈ Run(u w ). Moreover, for all other leaf nodes u v with Leaf(u v ) ∈ I, there is a homomorphism branchDb(I, u v ) → branchDb(I, u w ). Since Q is closed under homomorphisms, M does not accept any such branchDb(I, u v ), and Goal / ∈ Run(u v ). By construction of M, Goal occurs in I iff it occur in some Run(u v ), so Goal / ∈ I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Proofs for Section 5</head><p>We fix for this whole appendix part a split (Σ 1 , Σ 2 ) of Σ fulfilling the condition of Item 2 of Lemma 18, and Σ 1 , Σ 2 , Σ 3 built from Σ 1 , Σ 2 as described in the body of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Proposition 19</head><p>Definition 6 (World Structure). Let I be an interpretation of Σ 1 . The world structure of I is the graph (V, E) where:</p><p>For every D over S in (Σ), the world structure of a model I of D and Σ 1 generated by a chase sequence is a finite tree, such that:</p><p>• its root is the unique element w such that Empty(w) ∈ I;</p><p>• if (w, w ) ∈ E, then world(w ) = world(w) ∪ {p( x)} for some atom p( x), and p( x) ∈ world(w);</p><p>• if Init(w) ∈ I and p( a) ∈ D \ world(w), there exists w such that Ins p ( a, w, w ) ∈ I.</p><p>Proof. Let us first notice that Rule (58) is applicable exactly once, as its frontier is empty. The null it creates, say w ∅ , is then the only one such that Empty(w ∅ ) ∈ I. Moreover, there is no edge incoming in w ∅ in the world structure, as the only rules Rules (59), ( <ref type="formula">60</ref>) and ( <ref type="formula">61</ref>) that introduce an atom of the shape Ins p ( x, w, w ) with w = w are such that w is existentially quantified. For the same reason, note that there is at most one edge incoming in any vertex in the world structure.</p><p>Next notice that no new null is created unless Rules (59), ( <ref type="formula">60</ref>) or (61) are applied, and they all must be applied by mapping w to an element of the world structure, as Done(w) is in the body of each of these rules. Hence the world structure is connected, and is thus a tree of root w ∅ . Now let us notice that in any interpretation I generated by a sequence of rule applications, if Done(w) ∈ I, then world I (w) = world I (w) for any I obtained by extending the sequence of rule applications that generated I. Indeed, the only way to derive Done(w) is to apply Rule (63), which requires the atoms Empty(w ∅ ) and Subs(w ∅ , w), as w ∅ is the only element for which Empty holds. The only way to create an atom of the shape Subs(w 0 , w 2 ) with w 0 = w 2 is by applying an instantiation of Rule (62), which can be applied if w 0 is a parent of w 1 in the world structure, and w 1 is such that Subs(w 1 , w 2 ) holds. Hence Done(w) is entailed only when Rule (62) as been applied by mapping w 0 to every ancestor of w and w 2 to w, which has a effect to ensure that world I (w) contains all the atoms possibly present in world I (w).</p><p>If (w, w ) ∈ E, then w has been created by the application of Rule ( <ref type="formula">59</ref>), ( <ref type="formula">60</ref>) or ( <ref type="formula">61</ref>). In all cases, Done(w) must hold at the time of the rule application. If it is by Rule (59) and substitution σ, then p(σ( x)) cannot belong to world(w), as this would make Rule (59) not applicable with σ. By the sequence of rule applications described before, world(w ) = world(w)∪{p(σ( x))}. Rules (60) and ( <ref type="formula">61</ref>) are treated in a similar way.</p><p>Both the depth and the arity of the world structure is thus upper bounded by the number of atoms using a predicate appearing in Σ 1 ∪ Σ 2 and nulls from D.</p><p>For the last item, let us notice that if Init(w) ∈ I, and p( a) ∈ D \ world(w), then Rule (59) instantiated for p is applicable by mapping x to a. Applying that rule will create a fresh null w which will fulfill the conditions stated in the lemma.</p><p>Lemma 32. Let D be a database over S in (Σ), and let I be a model of D and Σ 1 generated by a chase sequence. Let v ∈ Nulls(I) such that Done(v) ∈ I. If a disjunctive rule ρ is applicable to world(v) by σ, then there exist in I two elements w 1 and w 2 such that Ins p1 ( u 1 , v, w 1 ) and Ins p2 ( u 2 , v, w 2 ) such that p 1 ( u 1 ) and p 2 ( u 2 ) are the two atoms created by the application of ρ, σ .</p><p>Proof. Let us first notice that σ, extended by mapping w to v, is a substitution that maps the bodies of Rules ( <ref type="formula">60</ref>) and ( <ref type="formula">61</ref>) to I, by definition of world(v) and since Done(v) ∈ I. As I is a model of Σ 1 , the head of these two rules should be also mappable in I, hence there exists w 1 and w 2 fulfilling the conditions of the lemma.</p><p>Note that Proposition 19 is a direct consequence of Lemmas 31 and 32.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Lemma 18</head><p>Definition 7 (Saturated World of a Null in an Interpretation). Let w be a null in an interpretation I such that Subs(w, w) ∈ I. The saturated world of w is defined by saturatedWorld I (w) = {p( x) | p ( x, w) ∈ I}.</p><p>Lemma 33. If there is a chase tree w.r.t. (Σ 1 ∪ Σ 2 ) and D whose unique leaf I is such that there exists w * ∈ Nulls(I) s.t. Goal ∈ saturatedWorld I (w * ) and Done(w * ) ∈ I, then there exists a chase tree w.r.t Σ 2 and world(w * ) whose unique leaf contains Goal.</p><p>Proof. Let us consider a chase tree T w.r.t. (Σ 1 ∪ Σ 2 ) and D, and let w * be such that Done(w * ) is in the result I of T . We show that there exists a chase tree T w.r.t Σ 2 and world(w * ) such that saturatedWorld I (w * ) is mapped to the label of the (unique) leaf of T by a homomorphism ψ.</p><p>For every label J of a node in T such that Done(w * ) ∈ J , we show that there exists a prefix of a chase tree w.r.t. Σ 2 and world(w * ) such that saturatedWorld J (w * ) is mapped to the label of the leaf of that prefix by a homomorphism ψ. We do this by induction on the number of rule applications ρ, h with ρ of the form Rule (64) and h(w) = w * that are done in T before the node labelled by J .</p><p>• If no rule application of the shape ρ, h with h(w) = w * is performed in T before J , then saturatedWorld J (w * ) = world(w * ). We thus define ψ as the identity, and the chase tree prefix consisting of the root labelled by world(w * ) fulfills the property. • Assume that the property is true for every J obtained in T after at most i-1 applications of the shape ρ , h with ρ of the form Rule (64) and h(w) = w * . Let J i be obtained in T after i such applications and let ρ , h be the last one, with ρ being the instantiation of Rule (64) for ρ ∈ Σ 2 . Let J i-1 be the label of the node in T on which ρ , h is applied. By induction assumption, there exist ψ and a prefix of a chase tree for Σ 2 and D, resulting in</p><p>, where B ρ is the body of ρ, is applicable on S i-1 , creating a new leaf, labeled by S i , and we extend ψ by mapping every null created by the instantiation of z i ∈ z in the application of ρ , h to the null created by the instantiation of z i ∈ z in the application of ρ, ψ • h |Terms(Bρ) . We obtain ψ(saturatedWorld Ji (w * )) ⊆ S i .</p><p>Lemma 34. Any restricted chase w.r.t Σ 1 ∪ Σ 2 ∪ Σ 3 can be transformed into an equivalent restricted chase in which rules from Σ 1 are applied before rules from Σ 2 , which are applied before rules from Σ 3 .</p><p>Proof. Notice that head predicates of Σ 3 do not appear in do not appear in Σ j with j &lt; 3. Hence rules of Σ 3 can be applied last. Note that head predicates of Σ 2 do not appear as body predicates of Σ 1 . Moroever, a rule of Σ 2 is applicable by mapping w to w * only if Done(w * ) as been derived. Further applications of rules of Σ 1 cannot add an atom of the shape p ( x, w * ), and thus applying them before do not prevent the application of a rule of Σ 2 .</p><p>Proposition 35. For every database</p><p>Proof. Let us consider a finite a chase tree T proving that Σ 1 ∪ Σ 2 , D |= Goal and such that rules of Σ 1 are applied before rules of Σ 2 (this is possible by definition of Σ 1 and Σ 2 that form a split of Σ).</p><p>We build a chase tree proving that Σ 1 ∪ Σ 2 ∪ Σ 3 , D |= Goal (we actually describe a sequence of rule applications, as Σ 1 ∪ Σ 2 ∪ Σ 3 contains only deterministic rules).</p><p>• Apply Rule (58), creating a fresh null w ∅ and facts Init(w ∅ ), Done(w ∅ ) and Empty(w ∅ ).</p><p>• Until creation of w D , perform the following:</p><p>let w D be the last introduced null; -Consider the case where n is a node of T labelled by N such that ψ(n) = w N and n has 2 children c 1 and c 2 labelled by N 1 and N 2 respectively, which correspond to the application of ρ, σ with ρ ∈ Σ 1 of the form p( x)∈β p( x) → p 1 ( x 1 ) ∨ p 2 ( x 2 ). We have N 1 = N ∪ {p 1 ( a 1 )} and N 2 = N ∪ {p 2 ( a 2 )} where a 1 = σ( x 1 ) and a 2 = σ( x 2 ). The instantiations of ( <ref type="formula">60</ref>) and ( <ref type="formula">61</ref>) corresponding to ρ are applicable through σ , which maps w to w N and x to σ( x).</p><p>* Apply Rule (60), introducing a fresh null that we call w N1 and adding in particular Ins p1 ( a 1 , w N1 , w N1 ). Then apply Rule (62) as many times as necessary, then Rule (63) so that Done(w N1 ) is created. Define ψ(c 1 ) = w N1 . * If Rule (61) is not applicable, it implies that p 1 = p 2 and a 1 = a 2 , so that N 1 = N 2 . Set N = (N ∪ {c 1 }) \ {n}, and set ψ(c 2 ) = w N1 . * Otherwise apply Rule (61), introducing a fresh null that we call w N2 and adding in particular Ins p2 ( a 2 , w N2 , w N2 ).Then apply Rule (62) as many times as necessary, then Rule (63) so that</p><p>At this point, for every n ∈ L, ψ(n) = w N and if I denotes the current set of facts built by our derivation, saturatedWorld I (ψ(n)) = N by construction.</p><p>For all n ∈ L, the next rule applied on n is a rule from Σ 2 , hence no more rule of Σ 1 are applied on a descendant of n in T (by assumption on T ). All rule applications below n are thus deterministic, and we "copy" that derivation. Let ψ n be the identity mapping from the label N of n to saturatedWorld I (ψ(n)).</p><p>By construction, ψ n is a homomorphism. While we extend I by applying new rules, we will extend ψ n into a homomorphism from the label of any descendant n of n in T to saturatedWorld I (ψ(n)).</p><p>• For n = n, this is already done.</p><p>• Assume that we have built a derivation such that ψ n is a homomorphism from the label N of some descendant n of n in T to saturatedWorld I (ψ(n)). Let n be the child of n in T , labelled by N , and let ρ, σ be the rule application creating n , where ρ ∈ Σ 2 . Then ρ, ψ n • σ can be applied to saturatedWorld I (ψ(n)), and thus Rule (64), instantiated for ρ is applicable in I by extending ψ n • σ by mapping w to ψ(n). We then define ψ(n ) = ψ(n), and extend ψ n by mapping each null created in the label of n by a variable z i to the null created by variable z i in the application of Rule (64).</p><p>Let T be the tree structure having ψ(r) = w D as root and where w p is parent of w c if w c has been created by an application of Rule (60) or Rule (61), that mapped w to w p . Note that all the w n in this tree structure are exactly the nulls of I such that there exists a node n in T with ψ</p><p>Let be a leaf of T . By assumption, Goal belongs to the label of . Let n be the unique node in L such that is a descendant of n. Since ψ n is a homomorphism from the label of to saturatedWorld I (ψ(n)), it holds that saturatedWorld I (ψ(n)) contains Goal. By definition of saturatedWorld I , it follows that Goal (ψ(n)) ∈ I. Since any leaf w n of T has an antecedent n by ψ which has a descendant leaf in T , then Goal (w) holds for each leaf w of T . Extend the derivation as follows:</p><p>• Apply Rule (65) to each w leaf of T .</p><p>• If Acc(w) has already been derived for the children w of a node ψ(n) in T , let ρ be the rule that has been applied by σ on n to create its children. Apply Rule (66) instantiated for ρ by mapping w 1 and w 2 to ψ(c 1 ) and ψ(c 2 ), where c 1 and c 2 are the children of n corresponding to the application of ρ. Acc(ψ(n)) is thus derived. • By induction on the depth, one derives Acc(w D ). As Init(w D ) holds, one can apply Rule (67) and obtain Goal.</p><p>We did not apply every possible rule: hence, to build a chase tree, we must ensure fairness (point 3. of the definition of chase tree), by applying all possible remaining rule applications, which concludes the proof.</p><p>To ease that proof, we will actually replace Rule (66) by the following rule:</p><p>which has an additional ternary fresh predicate describing the rule ρ ∈ Σ 1 (and the worlds generated by the corresponding rule application) allowing to derive Acc(w). Note that since Acc ρ not being appearing anywhere else, all the properties shown so far are still valid. Proposition 36. For every database</p><p>Proof. Let I be a model of D and Σ 1 ∪ Σ 2 ∪ Σ 3 obtained through a restricted chase sequence such that Goal ∈ I. We build a chase tree T for Σ 1 ∪ Σ 2 and D for some D ⊆ D such that Goal is in the label of every leaf of T . Let w D ∈ Nulls(I) be such that Rule ( <ref type="formula">67</ref>) is applied on it, with world(w D ) = D . Set W = {w D }, and perform the following until W = ∅.</p><p>• Otherwise, there must be some Acc ρ (w, w 1 , w 2 ) ∈ I, as the only way to derive Acc(w) if Goal (w)</p><p>does not hold is to apply some instantiation for some ρ of Rule (68) by some mapping σ. Moreover, there must be such an atom for which w 1 and w 2 are different from w. Consider ρ, σ Terms(ρ) : it is applicable, as σ maps the body of ρ to world(w), and none of the two atoms in the head are present in world(w) (otherwise, w would be equal to w 1 or to w 2 ). Performing this rule application adds two children to the node of T labelled by world(w), of respective labels world(w 1 ) and world(w 2 ). Set W = (W \ w) ∪ {w 1 , w 2 }.</p><p>As the tree structure of I is finite, and that at each step, either the size of W is decreasing, or the null w considered is replaced by two nulls w 1 and w 2 such that world(w 1 ) and world(w 2 ) are labels of nodes of strictly greater depth than world(w) in that tree, the above process terminates. Moreover, for each leaf of the considered prefix of T , it holds that its label and Σ 2 entail Goal, by Lemma 33 and the fact that each leaf is labelled by some world(w) such that Goal (w) ∈ I (so that Goal ∈ saturatedWorld I (w)).</p><p>Hence, one can expand T in such a way that all its leaves are labeled by sets containing Goal, which concludes the proof.</p><p>Lemma 37. For every database D over S in (Σ), Σ 1 ∪ Σ 2 ∪ Σ 3 , D is chase-terminating.</p><p>Proof. By Lemma 34, chase sequences can be reordered without changing the number of rule applications such that rules from Σ 1 are applied first, then rules from Σ 2 , then rules from Σ 3 . Lemma 31 implies that rules from Σ 1 cannot be triggered indefinitely. As the tree structure is finite, if there are infinitely many rule applications performed with a rule from Σ 2 , there must be one world null w * such that there are infinitely many rules of Σ 2 that are performed mapping w to w * . By the construction of Proposition 36, it implies that there exists a database over S in (Σ 2 ) for which Σ 2 does not terminate, which is against our assumptions on Σ 2 . Finally, Σ 3 does not contain any existentially quantified variable, hence only finitely many rules can be triggered.</p><p>Lemma 18 is a direct consequence of Propositions 35, 36 and Lemma 37.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Proofs of Section 6</head><p>Lemma 23. The set M is not enumerable up to equivalence.</p><p>Proof by Contradiction.</p><p>1. Suppose for a contradiction that the lemma does not hold. Then, there is an enumerator P that outputs a sequence of TMs that includes M up to equivalence. That is, the enumerator P outputs an infinite sequence M 1 , M 2 , . . . of TMs such that:</p><p>• For each i ≥ 1, we have that M i ∈ M.</p><p>• For each M ∈ M, there is some i ≥ 1 such that M and M i are equivalent. Two TM M and M are equivalent if, for each word w, we have that M accepts w iff M accepts w. 2. Consider the sequence p 1 , p 2 , . . . of natural numbers such that p 1 = 1 and p i is the smallest prime with p i &gt; p i-1 for each i ≥ 2. Note that this sequence is infinite by Euclid's theorem. 3. By (2): there is an infinite sequence D 1 , D 2 , . . . of databases such that D i = {ed(u 1 , u 2 ), . . . , ed(u pi+1 , u 1 )} for each i ≥ 1. 4. Consider the TM M d that, on input w, performs the computation:</p><p>(a) Check if w corresponds to a database D that only contains facts defined over ed. If this is not the case, then reject. (b) If D can be homomorphically embedded into a database such as {ed(u 1 , u 2 ), . . . , ed(u k-1 , u k )}</p><p>where k is smaller or equal than the number of nulls in D, then reject. (c) If ed(u, u) ∈ D for some null u, then accept.</p><p>(d) If there is some i ≥ 1 such that (i) there are less or the same number of nulls in D i than in D, (ii) M i accepts some serialisation that corresponds to D i , and (iii) there is a homomorphism h : D → D i ; then reject. Otherwise, accept. 5. By (4): the TM M d halts on all inputs. Note the following remarks about instruction (4.d):</p><p>• The TM M i accepts some serialisation that corresponds to D i if M i accepts any such serialisation. Therefore, for each instantiation of i, the TM M d only needs to check one (arbitrarily chosen) serialisation of D i when executing (4.d). • When executing (4.d), the TM M d only needs to check a finite amount of instantiations of i ≥ 1 before rejecting with confidence due to condition (4.d.i). 6. After this enumeration, we prove that M d does satisfy (iii) in Definition 5 by contradiction. 7. By (4.a), ( <ref type="formula">5</ref>), and ( <ref type="formula">6</ref> • If M i rejects D i , then M d accepts D i in (4.d). Note that, if we assume that M d rejects D i in this case we obtain a contradiction; namely, we can conclude that p evenly divides q for some prime numbers p, q &gt; 1 with p = q. 9. Contradiction by ( <ref type="formula">1</ref>), (7), and (8): the enumerator P is incomplete since it fails to print out a TM that is equivalent to M d , which is in M.</p><p>Suppose for a contradiction that there are some words w and v that correspond to some databases D and E such that D and E only contain facts defined over ed, M d accepts D, M d rejects E, and there is some homomorphism h : D → E. We conduct a case-by-case analysis to show that this assumption results in a contradiction:</p><p>• Assume that D is accepted due to instruction (4.c). Then, ed(u, u) ∈ D for some null u and hence, ed(t, t) ∈ E for some null t since h : D → E. Therefore, M d accepts E due to (4.c) ( ). • Assume that D is accepted due instruction (4.d). Two possible cases arise:</p><p>-By definition E is a database that only contains facts defined over the predicate ed. Hence, E cannot be rejected due to (4.a).</p><p>-If E is rejected due to (4.b), then E can be hom-embedded into a path over ed. Therefore, D can also be hom-embedded into the same path since h : D → E and M d rejects D due to (4.b) ( ). -Assume that E is rejected due to instruction (4.d). 1. There is some i ≥ 1 and a homomorphism g such that (i) the number of nulls in i is smaller than the number of nulls in E, (ii) g : E → D i , and (iii) the TM M i accepts the database D i . 2. By (1): g • h : D → D i . 3. If we assume that p i+1 is smaller or equal than the number of nulls in D, then M d rejects D due to (4.d) ( ). Therefore, we conclude that p i+1 is strictly greater than the number of nulls in D. 4. If we assume that D can be homomorphically embedded into a path over ed, then M d rejects D due to (4.b). Hence, we assume that this is not the case. 5. We obtain a contradiction from (2), (3), and (4).</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">y 2 .Enc(u, y 1 , y 2 ) ∧ S 0 (y 1 ) ∧ Nxt(y 1 , y 2 )</title>
	</analytic>
	<monogr>
		<title level="j">∧ S</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Enc(, y 1 , y ) ∧ Chi(u, v) → ∃z 1 , z .Enc(v, z 1 , z ) ∧ Cpy +1 (y 1</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Cpy +1 (y 1 , y 2 , z 1 , z ) ∧ S 0 (y 1 ) ∧ Nxt(y 1 , y 2 ) → S 1 (z 1 ) ∧ Nxt(z 1 , z ) ∧ S 1 (z )</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Cpy +1 (y 1 , y 2 , z 1 , z ) ∧ S 1 (y 1 ) ∧ Nxt(y 1 , y 2 ) → ∃z 2 .S 0 (z 1 ) ∧ Nxt(z 1 , z 2 ) ∧ S 0 (z 2 ) ∧ Nxt(z 2 , z ) ∧ S 1 (z ) (24) Cpy +1 (y 1 , y , z 1 , z ) ∧ S 0 (y 1 ) ∧ Nxt(y 1 , y 2 ) ∧ Nxt(y 2 , y 3 ) → ∃z 2 .Cpy(y 2 , y , z 2 , z ) ∧ S 1 (z 1 ) ∧ Nxt(z 1 , z 2 ) (25) Cpy +1 (y 1 , y , z 1 , z ) ∧ S 1 (y 1 ) ∧ Nxt(y 1 , y 2 ) ∧ Nxt(y 2 , y 3 ) → ∃z 2 .Cpy +1 (y 2 , y , z 2 , z ) ∧ S 0 (z 1 ) ∧ Nxt(z 1</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Cpy(y 1 , y 2 , z 1 , z 2 ) ∧ S * (y 1 ) ∧ Nxt(y 1 , y 2 ) → S * (z 1 ) ∧ Nxt(z 1 , z 2 )</title>
	</analytic>
	<monogr>
		<title level="j">∧ S</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Cpy(y 1 , y , z 1 , z ) ∧ S * (y 1 ) ∧ Nxt(y 1 , y 2 ) ∧ Nxt(y 2 , y 3 ) → ∃z 2 .Cpy(y 2 , y , z 2 , z ) ∧ S * (z 1 ) ∧ Nxt</title>
		<imprint/>
	</monogr>
	<note>28) References</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Salvat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Walking the complexity lines for generalized guarded existential rules</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;11)</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>22nd Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;11)</meeting>
		<imprint>
			<publisher>AAAI Press/IJCAI</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A proof procedure for data dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="718" to="741" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Taming the infinite chase: Query answering under expressive relational constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int. Conf. on Knowledge Representation and Reasoning (KR&apos;08)</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Brewka</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Lang</surname></persName>
		</editor>
		<meeting>11th Int. Conf. on Knowledge Representation and Reasoning (KR&apos;08)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Chasing sets: How to use existential rules for expressive reasoning</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Lewe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th Int. Joint Conf. on Artificial Intelligence, IJCAI&apos;19</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Kraus</surname></persName>
		</editor>
		<meeting>28th Int. Joint Conf. on Artificial Intelligence, IJCAI&apos;19</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1624" to="1631" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Restricted chase (non)termination for existential rules with disjunctions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 26th Int. Joint Conf. on Artificial Intelligence, IJCAI&apos;17</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Sierra</surname></persName>
		</editor>
		<meeting>26th Int. Joint Conf. on Artificial Intelligence, IJCAI&apos;17</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="922" to="928" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The chase revisited</title>
		<author>
			<persName><forename type="first">A</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th Symposium on Principles of Database Systems (PODS&apos;08)</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Lembo</surname></persName>
		</editor>
		<meeting>27th Symposium on Principles of Database Systems (PODS&apos;08)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Anatomy of the chase</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Onet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Fundam. Informaticae</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Extending decidable existential rules by joining acyclicity and guardedness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</author>
		<title level="m">Proc. 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;11)</title>
		<meeting>22nd Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;11)</meeting>
		<imprint>
			<publisher>AAAI Press/IJCAI</publisher>
			<biblScope unit="page" from="963" to="968" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The power of the terminating chase</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22nd Int. Conf. on Database Theory, ICDT&apos;19</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Calautti</surname></persName>
		</editor>
		<meeting>22nd Int. Conf. on Database Theory, ICDT&apos;19</meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="3" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Generalized schema-mappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">B</forename><surname>Marnette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th Symposium on Principles of Database Systems (PODS&apos;09)</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</editor>
		<meeting>28th Symposium on Principles of Database Systems (PODS&apos;09)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Characterization of the expressivity of existential rule queries</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
		<editor>Yang, Q.</editor>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m">Proc. 24th Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;15)</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Wooldridge</surname></persName>
		</editor>
		<meeting>24th Int. Joint Conf. on Artificial Intelligence (IJCAI&apos;15)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<biblScope unit="page" from="3193" to="3199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Existential rule languages with finite chase: Complexity and expressiveness</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>You</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m">Proc. 29th AAAI Conf. on Artificial Intelligence (AAAI&apos;15)</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Bonet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Koenig</surname></persName>
		</editor>
		<meeting>29th AAAI Conf. on Artificial Intelligence (AAAI&apos;15)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
