<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">LKSA : un algorithme de sélection de clés de liage dans des données RDF guidée par des paires de classes</title>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nacira</forename><surname>Abbas</surname></persName>
							<email>nacira.abbas@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="department">de Lorraine</orgName>
								<orgName type="institution" key="instit1">Université</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<addrLine>Loria Nancy</addrLine>
									<postCode>F-54000</postCode>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">de Grenoble Alpes</orgName>
								<orgName type="institution" key="instit1">Université</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Grenoble INP</orgName>
								<orgName type="institution" key="instit5">LIG Grenoble</orgName>
								<address>
									<postCode>F-38000</postCode>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jérôme</forename><surname>David</surname></persName>
							<email>jerome.david@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="department">de Lorraine</orgName>
								<orgName type="institution" key="instit1">Université</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<addrLine>Loria Nancy</addrLine>
									<postCode>F-54000</postCode>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">de Grenoble Alpes</orgName>
								<orgName type="institution" key="instit1">Université</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Grenoble INP</orgName>
								<orgName type="institution" key="instit5">LIG Grenoble</orgName>
								<address>
									<postCode>F-38000</postCode>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Amedeo</forename><surname>Napoli</surname></persName>
							<email>amedeo.napoli@loria.fr</email>
							<affiliation key="aff0">
								<orgName type="department">de Lorraine</orgName>
								<orgName type="institution" key="instit1">Université</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Inria</orgName>
								<address>
									<addrLine>Loria Nancy</addrLine>
									<postCode>F-54000</postCode>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">de Grenoble Alpes</orgName>
								<orgName type="institution" key="instit1">Université</orgName>
								<orgName type="institution" key="instit2">Inria</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Grenoble INP</orgName>
								<orgName type="institution" key="instit5">LIG Grenoble</orgName>
								<address>
									<postCode>F-38000</postCode>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">LKSA : un algorithme de sélection de clés de liage dans des données RDF guidée par des paires de classes</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">880EA687FEE545991877F7B3666EAA3C</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Dans cet article, nous nous intéressons à la sélection de clés de liage dans des jeux de données RDF. Une clé de liage permet d'établir des liens d'identité entre deux entités dans le web des données. Le couple d'entités liées détermine à son tour un couple de classes qui peut guider la recherche et la sélection de clés de liage de meilleure qualité. Pour ce faire, nous proposons un algorithme de sélection de clés de liage s'appuyant sur des mesures de qualité adaptées. Une série d'expérimentations sur des jeux de données RDF diversifiés montre le potentiel et l'efficacité de l'approche.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div><head n="1">Introduction</head><p>Nous nous intéressons à la découverte de liens d'identité entre les ressources de deux jeux de données RDF (Resource Description Framework). Cette tâche est cruciale pour le web des données car les liens d'identité autorisent une meilleure interopérabilité entre différentes applications ainsi que l'amélioration de la qualité les données (recherche de "doublons"). Plusieurs approches existent pour trouver les liens d'identité parmi lesquelles l'approche "logique" qui s'appuie sur des axiomes exprimant des conditions suffisantes pour que deux ressources soient identiques <ref type="bibr" target="#b11">(Saïs et al., 2007;</ref><ref type="bibr" target="#b1">Al-Bakri et al., 2015</ref><ref type="bibr" target="#b0">, 2016)</ref>. Suivant cette ligne, cet article se concentre sur les clés de liage qui généralisent la notion de clé sur deux jeux de données <ref type="bibr">(Atencia et al., 2014a)</ref>. Un exemple de clé de liage est : k = ({ designation,titre }, { designation,titre , author,auteur }, Book,Livre ) qui signifie que si une instance a 1 de la classe Book et une instance b 1 de la classe Livre, possèdent les mêmes valeurs pour la propriété designation et pour la propriété titre, et que a 1 et b 1 partagent au moins une valeur pour les propriétés author et auteur, alors a 1 et b 1 désignent la même entité. En particulier la clé de liage k instancie la paire de classes Book, Livre et génère un lien d'identité ("same-as") entre a 1 et b 1 .</p><p>Les clés de liage ne sont généralement pas fournies avec les jeux de données. De fait, un algorithme de découverte de clés de liage dites "candidates" est proposé dans <ref type="bibr">(Atencia et al., 2014a)</ref>. Le problème de la découverte de clés de liage candidates peut se formuler de façon formelle dans le cadre de l'Analyse Formelle de Concepts (AFC) <ref type="bibr" target="#b9">(Ganter et Wille, 1999</ref>) car une clé de liage candidate s'avère être un "fermé" pour un opérateur de fermeture spécifique. Afin d'exploiter le cadre formel bien défini de l'AFC ainsi que les algorithmes d'extraction de fermés offerts par ce formalisme, <ref type="bibr">(Atencia et al., 2014b</ref><ref type="bibr" target="#b5">(Atencia et al., , 2020) )</ref> proposent une méthode qui s'appuie sur l'AFC pour extraire des clés de liage candidates. Les algorithmes proposés dans <ref type="bibr">(Atencia et al., 2014a</ref><ref type="bibr" target="#b5">(Atencia et al., , 2020) )</ref> peuvent être appliqués avec ou sans alignement des classes et des propriétés issues des jeux de donnés en entrée. En l'absence d'un alignement des classes, les clés de liage candidates découvertes sont dites clés candidates générales dans le sens où elles s'appliquent sur tout le jeu de données sans être spécifiques à une paire de classes particulière.</p><p>Dans <ref type="bibr">(Abbas et al., 2020)</ref>, les auteurs partent de l'hypothèse que les clés candidates générales, même les meilleures, peuvent générer des liens d'identité pour une paire de classes particulière et ne générer aucun lien pour les autres paires de classes. Il faut donc distinguer les paires de classes. En s'appuyant sur le formalisme des "pattern structures" <ref type="bibr" target="#b8">(Ganter et Kuznetsov, 2001)</ref>, une extension de l'AFC pour traiter des données complexes, les auteurs proposent un algorithme appelé SLKPS qui extrait des clés de liage candidates instanciant des paires de classes spécifiques. L'algorithme SLKPS ne nécessite pas d'alignement de classes en entrée.</p><p>Des mesures de qualité ont été proposées dans <ref type="bibr">(Atencia et al., 2014a)</ref> pour évaluer les clés de liage candidates et sélectionner celles qui seront utilisées pour générer les liens d'identité. Les meilleures clés de liage candidates selon ces mesures ne permettent pas toujours de générer tous les liens d'identité possibles. De plus elles peuvent générer des liens erronés c.-à-d. des liens entre des instances qui ne sont pas identiques. L'objectif de ce travail de recherche est de proposer un algorithme qui sélectionne un ensemble de clés de liage candidates qui génèrent à la fois le maximum de liens d'identité corrects (rappel) et le minimum de liens erronés (précision). Cet algorithme s'appuie sur une sélection guidée par les paires de classes instanciées par les clés de liage candidates.</p><p>Dans suite de cet article, nous commençons par un état de l'art des approches de liage de données (Section 2). Ensuite nous présentons les notations et les définitions nécessaires (Section 3). Puis nous détaillons un algorithme qui sélectionne un ensemble de clés de liage candidates qui maximisent le nombre de liens d'identité corrects et qui minimisent le nombre de liens erronés (Section 4). Enfin, nous évaluons l'efficacité de l'algorithme à l'aide d'expérimentations sur différents jeux de données (Section 5).</p></div>
<div><head n="2">État de l'art</head><p>Le liage de données est la tâche qui consiste à trouver, entre deux jeux de données RDF différents, des couples d'IRI (Internationalized Resource Identifier) représentant la même entité. Le résultat est un ensemble de liens d'identité entre ces IRIs. Pour effectuer cette tâche, des systèmes de liage de données, tels que LIMES <ref type="bibr" target="#b10">(Ngomo et Auer, 2011)</ref> et SILK <ref type="bibr" target="#b13">(Volz et al., 2009)</ref>, s'appuient sur des spécifications de liens qui peuvent être numériques ou logiques, indiquant les conditions pour lesquelles deux IRI sont considérées comme identiques. Une spécification logique est un axiome dont les liens d'identité sont des conséquences logiques. Ces spécifications, contrairement aux spécifications numériques, peuvent être combinées avec des éléments de connaissances provenant d'ontologies ou d'alignements entre ontologies, pour déduire des liens en utilisant un raisonneur.</p><p>Les spécifications à base de clés entrent dans cette dernière catégorie. Les clés ne sont généralement pas fournies avec les jeux de données, et pour cette raison, plusieurs algorithmes ont été proposés pour les découvrir automatiquement <ref type="bibr" target="#b2">(Assi et al., 2020)</ref>. Les clés sont utilisées pour trouver les instances identiques entre deux jeux de données, mais cela nécessite un alignement de propriétés et de classes ou un vocabulaire commun aux jeux de données en question. Ces clés sont découvertes pour chaque jeu de données indépendamment, ce qui implique qu'un ensemble de propriétés peut constituer une clé sur un jeu de données mais pas sur l'autre. Dans ce cas, les clés peuvent ne pas générer des liens d'identité. Partant de ce constat, deux solutions ont été étudiées : (i) utiliser des algorithmes et des mesures de sélection de clés adaptées au liage de données <ref type="bibr">(Achichi et al., 2016;</ref><ref type="bibr" target="#b7">Farah et al., 2017)</ref>, (ii) généraliser la notion clé par celle de clé de liage <ref type="bibr">(Atencia et al., 2014a)</ref>  Une clé de liage k entre deux jeux de donnés D 1 et D 2 est une expression de la forme :</p><formula xml:id="formula_0">k = (Eq, In, C 1 ,C 2 )</formula><p>où Eq et In sont des ensembles de paires de propriétés dans P 1 × P 2 , Eq ⊆ In = / 0, C 1 (resp. C 2 ) est une classe atomique ou une expression de classes dans Cl 1 (resp. Cl 2 ). La clé de liage k = (Eq, In, C 1 ,C 2 ) instancie la paire de classes C 1 ,C 2 . On dit que k est une clé de liage générale si elle instancie la paire de classes owl:Thing,owl:Thing . Rappelons que la classe owl:Thing <ref type="bibr" target="#b12">(Smith et al., 2004)</ref> contient toutes les instances du jeu de données.</p><p>L'ensemble des liens d'identité générés par k est dénoté par L(k) et vérifie :</p><formula xml:id="formula_1">L(k) = { s 1 , s 2 |s 1 ∈ I C 1 , s 2 ∈ I C 2 , ∀ p 1 , p 2 ∈ Eq, p 1 (s 1 ) = p 2 (s 2 ), ∀ p 1 , p 2 ∈ In, p 1 (s 1 ) ∩ p 2 (s 2 ) = / 0}</formula><p>Par exemple la clé de liage k, k = ( designation,désign , pubCity,villeEdit designation,désign , pubCity,villeEdit , Newspaper,Journal ) génère l'ensemble de liens</p><formula xml:id="formula_2">L(k) = { a 1 , b 1 , a 2 , b 2 , a 3 , b 3 , a 4 , b 4 , a 5 , b 5 , a 6 , b 5 }.</formula><p>Dans la suite, pour faciliter la lecture et sans nuire à la généralité de la démarche, nous ne considérons que l'ensemble In dans une clé de liage qui s'écrit alors k = (In, C 1 ,C 2 ), sachant que nous avons toujours Eq ⊆ In. De plus, le terme "classe" désigne aussi bien une classe atomique qu'une expression de classes.</p><p>Une clé de liage est "candidate" si elle génère au moins un lien et si elle est maximale<ref type="foot" target="#foot_0">1</ref> sur l'ensemble de liens qu'elle génère.</p><p>Par exemple, soit l'ensemble de clés de liage</p><formula xml:id="formula_3">K = {k 1 , k 2 , k 3 } qui génèrent le même en- semble de liens L(k 1 ) = L(k 2 ) = L(k 3 ) = { a 1 , b 1 , a 2 , b 2 , a 3 , b 3 , a 4 , b 4 , a 5 , b 5 , a 6 , b 5 } tels que : k 1 =({ designation,désign , pubCity,villeEdit }, Newspaper,Journal ) k 2 =({ designation,désign }, Newspaper,Journal ) k 3 =({ pubCity,villeEdit }, Newspaper,Journal )</formula><p>La clé de liage k 1 génère au moins un lien et elle est maximale sur K. Ainsi k 1 est une clé de liage candidate tandis que k 2 et k 3 ne le sont pas.</p><p>Une clé de liage peut générer des liens qui peuvent être corrects ou erronés selon l'avis d'un expert du domaine. De fait, les algorithmes de découverte de clés de liage recherchent des clés de liage candidates puis sélectionnent celles qui permettent de maximiser le nombre de liens corrects et de minimiser le nombre de liens erronés. Dans ce qui suit, nous discutons de la qualité des clés de liage retournées.</p></div>
<div><head n="3.2">Évaluation des clés de liage candidates</head><p>La qualité d'une clé de liage dépend du nombre de liens corrects et du nombre de liens erronés qu'elle génère. Ainsi plus une clé de liage candidate génère de liens corrects et moins elle génère de liens erronés, plus elle est considérée de meilleure qualité pour le liage de données.</p><p>Cependant, lorsqu'un expert n'est pas présent -et c'est souvent le cas -pour vérifier qu'un lien est correct ou pas, la qualité d'une clé de liage candidate peut être évaluée en utilisant les mesures de couverture et de discriminabilité qui sont introduites dans <ref type="bibr">(Atencia et al., 2014a)</ref>.</p><p>La couverture d'une clé de liage k = (In, C 1 ,C 2 ), notée cov(k), mesure le degré de généralité d'une clé de liage candidate. Plus la couverture d'une clé de liage candidate est élevée, plus grande est la probabilité que celle ci génère des liens corrects. La couverture de k se définit comme suit. Soit L ⊆</p><formula xml:id="formula_4">(I C 1 × I C 2 ) et π 1 (L) = {s 1 ∈ I C 1 | s 1 , s 2 ∈ L}, π 2 (L) = {s 2 ∈ I C 2 | s 1 , s 2 ∈ L}. π 1 (L) est l'ensemble des instances de C 1 apparaissant dans L et π 2 (L) est l'ensemble des instances de C 2 apparaissant dans L. cov(k) = |π 1 (L(k)) ∪ π 2 (L(k))| |I C 1 ∪ I C 2 |</formula><p>Lorsque cov(k) est égal à 1, cela signifie que toutes les instances de C 1 et de C 2 sont identifiées par k. La mesure de discriminabilité évalue la capacité d'une clé de liage candidate à discriminer les instances. La discriminabilité fait l'hypothèse que les instances ayant des IRIs différentes au sein d'un même jeu de données sont distinctes (Unique Name Assumption UNA). Ainsi, si cette hypothèse est respectée, il ne devrait pas y avoir plus d'un lien impliquant une instance. Plus une clé de liage est discriminante, plus grande est la probabilité que les liens qu'elle génère soient corrects.</p><p>La discriminabilité d'une clé de liage candidate k se définit comme suit : </p><formula xml:id="formula_5">dis(k) = min(|π 1 (L(k))|, |π 2 (L(k))|) |L(k)| La couverture</formula><formula xml:id="formula_6">hm cd (k) = 2×cov(k)×dis(k) cov(k)+dis(k)</formula><p>La clé de liage candidate qui possède la meilleure moyenne harmonique hm cd est considérée comme étant celle de meilleure qualité. Cependant une seule clé de liage candidate, même la meilleure, ne permet pas toujours d'identifier tous les liens d'identité. Pour cette raison plusieurs clés de liage candidates peuvent être sélectionnées pour le liage de données. Les questions qui se posent alors sont "comment sélectionner ces clés de liage ?" et "comment détecter les clés qui sont les meilleures ?".</p><p>Le problème de sélection d'un sous-ensemble de clés de liage candidates peut s'énoncer comme suit. Soient D 1 , D 2 deux jeux de données RDF et K = {k|k = (In, C 1 ,C 2 )} l'ensemble de clés de liage candidates entre D 1 et D 2 . Il faut alors sélectionner un ensemble de clés de liage KV ⊆ K -où V signifie "valide" -qui génèrent le maximum de liens corrects et le minimum de liens erronés entre D 1 et D 2 .</p><p>Par exemple, soit K = {k 1 , k 2 , k 3 , k 4 , k 5 , k 6 } l'ensemble des clés de liage candidates entre les jeux de données D 1 et D 2 de la Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>k 1 =({ designation,désign , pubCity,villeEdit }, Newspaper,Journal ) k 2 =({ designation,désign , pubCity,villeEdit , fYear,dateF }, Newspaper,Journal ) k 3 =({ pubCity,prénom }, Newspaper,Personne ) k 4 =({ firstName,villeEdit }, Person,Journal ) k 5 =({ name,nom , firstName,prénom }, Person,Personne ) k 6 =({ name,nom , firstName,prénom , anneeN,birthY }, Person,Personne ) Comment alors sélectionner un ensemble de clés de liage qui génèrent tous les liens d'identité corrects entre D 1 et D 2 ? Une première proposition est de sélectionner les "Top M" clés de liage de K, c.-à-d. un sous-ensemble de clés de liage candidates composé des M meilleures candidates en termes de hm cd . Néanmoins, ce sous-ensemble ne parvient pas toujours à maximiser le nombre de liens corrects.</p><p>Dans l'exemple, nous calculons hm cd pour chaque clé de liage candidate (voir la Table <ref type="table">1</ref>). Nous sélectionnons par exemple les Top 2 de K c.-à-d. k 1 et k 2 qui sont les deux meilleures clés de liage selon hm cd . Cependant, ces clés de liage ne génèrent pas tous les liens d'identité entre les jeux de données D 1 et D 2 . Cela s'explique par le fait que k 1 et k 2 n'instancient pas la paire de classes Person,Personne . Par conséquent, les liens d'identité entre ces deux classes ne sont pas générés. Une solution intuitive consiste à sélectionner la meilleure clé de liage pour chaque paire de classes, c.-à-d. k 1 , k 3 , k 4 et k 5 . Néanmoins, ces clés de liage génèrent des liens erronés. En effet, les instances Le Monde et Paris Hilton sont jugées identiques, ce qui n'est pas acceptable. Cela s'explique par le fait que k 3 instancie la paire de classes Newspaper,Personne dont les classes sont "incompatibles", ce qui signifie qu'aucune entité ne peut être représentée par ces deux classes en même temps.</p><p>En nous appuyant sur ces constats, nous proposons ci-après un algorithme de sélection d'un sous-ensemble de clés de liage candidates, où la sélection, guidée par les paires de classes, maximise le nombre de liens corrects et minimise le nombre de liens erronés.</p></div>
<div><head n="4">Sélection de clés de liage guidée par les classes</head><p>Les algorithmes ci-dessous s'appuient sur la méthode SLKPS détaillée dans (Abbas et al., 2020) pour extraire les clés de liage candidates. Contrairement aux algorithmes qui retournent des clés de liage candidates générales, la méthode SLKPS a la particularité de retourner des clés de liage candidates en spécifiant les paires de classes qui sont instanciées. En outre, SLKPS peut générer des clés de liage candidates qui instancient des paires d'expressions de classes.</p><p>L'algorithme LKSA sélectionne un sous-ensemble de clés de liage KV qui maximise le nombre de liens corrects et minimise le nombre de liens erronés. LKSA s'appuie sur deux opérations principales, <software>TopLkClass</software> et RelevantClassForLk, qui sont détaillées juste après. KTop ← / 0 3:</p></div>
<div><head>Algorithm 1 Sélection des clés de liage candidates</head><formula xml:id="formula_7">for each C 1 ,C 2 ∈ pcc(K) do 4: KTop [ C 1 ,C 2 ] ← N argmax k hm cd (k) tel que k = (In, C 1 ,C 2 ) ∈ K 5:</formula><p>end for 6:</p><p>return KTop 7: end function <software>TopLkClass</software> : cette fonction sélectionne un sous-ensemble de clés de liage candidates KTop qui vise à maximiser le nombre de liens corrects générés.</p><p>Algorithm 3 Sélection des clés de liage instanciant les paires de classes pertinentes pour le liage</p><formula xml:id="formula_8">Input KTop, pcc(K) Output KV 1: function RELEVANTCLASSFORLK(KTop,pcc(K)) 2: Class1 ← {C 1 | C 1 ,C 2 ∈ pcc(K)} 3: Class2 ← / 0; KV ← / 0 4: for each C 1 ∈ Class1 do 5: bestC2 ← argmax C 2 hm cd (KTop [ C 1 ,C 2 ]) 6: Class2 ← Class2 ∪ {bestC2} 7:</formula><p>end for 8:</p><p>for each C 2 ∈ Class2 do</p><formula xml:id="formula_9">9: bestC1 ← argmax C 1 hm cd (KTop [ C 1 ,C 2 ]) 10: KV ← KV ∪ KTop [ bestC1,C 2 ] 11:</formula><p>end for 12:</p><p>return KV 13: end function L'ensemble des paires de classes qui sont instanciées par les clés de liage candidates de Dans la suite, nous dirons qu'une paire de classes est "pertinente pour le liage (de données)" s'il existe au moins un lien d'identité correct entre ces deux classes. Par exemple, la paire de classes Newspaper,Journal est pertinente pour le liage tandis que la paire Newspaper,Personne ne l'est pas.</p><formula xml:id="formula_10">K est dénoté pcc(K) = { C 1 ,C 2 |∃k ∈ K tel que k = (In, C 1 ,C 2 }.</formula><p>Nous avons vu au dessus que KTop génère des liens erronés parce que certaines clés de liage instancient des paires de classes non pertinentes pour le liage de données. La fonction RelevantClassForLk est justement conçue pour sélectionner un ensemble KV ⊆ KTop comportant des clés qui instancient uniquement des paires de classes qui ont plus de chances d'être pertinentes pour le liage de données.</p><p>RelevantClassForLk : cette fonction vise à minimiser le nombre de liens erronés générés par KTop. Lorsque il n'y a pas d'expert pour juger de la validité des liens générés, la fonction RelevantClassForLk retourne un sous-ensemble de paires de classes qui ont le plus de chances d'être pertinentes pour le liage de données.</p><p>Nous faisons l'hypothèse que plus le nombre d'entités partagées par deux classes est élevé, plus grande est la probabilité que cette paire de classes soit pertinente pour le liage de données. Pour cela, nous calculons le degré de recouvrement de chaque paire de classes instanciées par les clés de liage de KTop.</p><p>Le recouvrement d'une paire de classes C 1 ,C 2 instanciées par l'ensemble des clés de liage Dans la suite, nous testons les hypothèses avancées, les algorithmes présentés ainsi que leur efficacité.</p><formula xml:id="formula_11">KTop [ C 1 ,C 2 ] = {k|k = (In, C 1 ,C 2 )} peut se mesurer par hm cd (KTop [ C 1 ,C 2 ]). Lorsque hm cd (KTop [ C 1 ,C 2 ]) = 1 cela signifie que KTop [ C 1 ,C 2 ] identifie</formula></div>
<div><head n="5">Expérimentations</head><p>L'objectif de ces expérimentations est de vérifier empiriquement l'efficacité de l'algorithme LKSA pour sélectionner un sous-ensemble de clés de liage candidates qui maximise le nombre de liens corrects et minimise le nombre de liens erronés. Toutes nos expérimentations<ref type="foot" target="#foot_1">2</ref> ont été réalisées en utilisant un MacBook Pro Intel Core i7, 2,6 GHz avec 16 Go de RAM alloués à la machine virtuelle Java.</p></div>
<div><head n="5.1">Jeux de données et protocole expérimental</head><p>Nous avons considéré les jeux de données décrits dans la Pour chaque jeu de données, nous avons généré les clés de liage candidates avec la méthode SLKPS. Nous avons ensuite sélectionné un sous-ensemble de clés de liage candidates KV avec l'algorithme LKSA. Les résultats de LKSA sont comparés avec les M meilleures clés de liage générales (Top M) en termes de hm cd en s'assurant que M = |KV |. La performance des deux méthodes est calculée en terme de précision, rappel et F-mesure.</p></div>
<div><head n="5.2">Résultats et discussion</head><p>Les résultats de ces expérimentations sont donnés dans la Table <ref type="table">3</ref> Pour les jeux de données Person1 et pr, les M meilleures clés de liage n'instancient pas toutes les paires de classes possibles, ce qui explique un rappel inférieur. L'algorithme LKSA quant à lui donne un meilleur rappel car il sélectionne les clés de liage qui instancient plus de paires de classes que les M meilleures clés de liage.</p><p>Pour les jeux de données Db-Yago et SPIMBench, nous améliorons la précision car LKSA sélectionne plus de clés de liage instanciant des paires de classes pertinentes comparant à Top M, d'où la génération de moins de liens erronés.</p><p>Nous avons démontré le potentiel de l'algorithme LKSA en expérimentant sur plusieurs jeux de données. Ici, nous constatons l'importance de distinguer les paires de classes qui sont instanciées par les clés de liage, ce qui est justement l'objectif de la méthode SLKPS <ref type="bibr">(Abbas et al., 2020)</ref>.</p></div>
<div><head n="6">Conclusion</head><p>Dans ce travail, nous avons traité le problème de la sélection de clés de liage candidates en exploitant les paires de classes qu'elles instancient. Nous avons proposé l'algorithme LKSA qui repose à la fois sur la sélection des meilleures clés de liage pour chaque paire de classes ainsi que sur la sélection des paires de classes dites pertinentes. Les résultats expérimentaux montrent que l'algorithme LKSA obtient de meilleurs résultats qu'une sélection uniquement basée sur les mesures de discriminabilité et couverture <ref type="bibr">(Atencia et al., 2014a)</ref>.</p><p>Par la suite, nous comptons adapter l'algorithme LKSA pour sélectionner des clés de liage interdépendantes, comme celles qui sont introduites dans <ref type="bibr" target="#b5">(Atencia et al., 2020)</ref>.</p></div>
<div><head>Références</head><p>Abbas, N., J. <ref type="bibr" target="#b5">David, et A. Napoli (2020)</ref>. Discovery of link keys in RDF data based on pattern structures : Preliminary steps. In Proceedings of <ref type="bibr">CLA, pp. 235-246. Achichi, M., M. B. Ellefi, D. Symeonidou, et K. Todorov (2016)</ref>. Automatic key selection for data linking. In EKAW, pp. 3-18. Springer.</p></div><figure xml:id="fig_0"><head>FIG. 1 :</head><label>1</label><figDesc>FIG. 1: Exemple de deux jeux de données D 1 et D 2 Soit un jeu de données D, les ensembles S = {s| s, p, o ∈ D} et P = {p| s, p, o ∈ D} dénotent respectivement l'ensemble des sujets et l'ensemble des propriétés du jeu de données D. On dit que c est une classe atomique sur D si ∃s ∈ S tel que s, rdf :type, c ∈ D. La propriété rdf:type est utilisée pour indiquer qu'un sujet appartient à une classe. Par exemple, le triplet b 1 , rdf:type,Journal déclare que b 1 est une instance de la classe Journal. L'ensemble des instances d'une classe atomique c dans D est dénotée I c = {s | s,rdf:type, c ∈ D}.</figDesc></figure>
<figure xml:id="fig_1"><head /><label /><figDesc>Input K : ensemble de clés de liage candidates retournées par SLKPS pour D 1 et D 2 N : entier, nombre de meilleures clés de liage par paire de classes à sélectionner Output KV : ensemble de clés de liage sélectionnées pour le liage de données entre D 1 et D 2 . 1: function LKSA(K, N) Sélection des N meilleures clés de liage par paire de classes candidate Input k,pcc(K), N Output KTop : les N meilleures clés de liage par paire de classes en terme de hm cd 1: function TOPLKCLASS(K, pcc(K), N) 2:</figDesc></figure>
<figure xml:id="fig_2"><head /><label /><figDesc>La fonction TopLkClass part d'un ensemble de clés de liage candidates K et sélectionne pour chaque paire de classes candidates C 1 ,C 2 ∈ pcc(K) les N meilleures clés de liage candidates en terme de hm cd , où N est un nombre fixé à l'avance par l'utilisateur.Sur l'exemple en cours, l'ensemble des paires de classes candidates est :pcc(K) = { Newspaper,Journal , Newspaper,Personne , Person,Journal , Person,Personne }. Nous appliquons TopLkClass avec N = 1. Pour chaque paire de classes de pcc(K) est sélectionnée la meilleure clé de liage candidate qui l'instancie. Ainsi, la paire Newspaper,Journal est instanciée par les clés de liage candidates k 1 et k 2 , et k 1 est sélectionnée car hm cd (k 1 ) &gt; hm cd (k 2 ). La procédure est itérée pour chacune des paires de classes de pcc(K) et le calcul de KTop retourne l'ensemble de clés de liage {k 1 , k 3 , k 4 , k 5 }. Cet ensemble KTop permet d'identifier tous les liens d'identité corrects entre les jeux de données D 1 et D 2 de l'exemple. Cependant, certaines clés de liage de KTop génèrent aussi des liens erronés. En effet, les instances Le Monde et Paris Hilton sont toujours jugées identiques par k 3 qui instancie Newspaper,Personne .</figDesc></figure>
<figure xml:id="fig_3"><head /><label /><figDesc>toutes les entités de C 1 et toutes les entités de C 2 , tout en garantissant que chaque entité est représentée par une seule instance dans C 1 et un seule instance dans C 2 . Plus le recouvrement d'une paire de classes est élevé, plus grande est la probabilité que les classes soient pertinentes pour le liage de données.La fonction RelevantClassForLk permet de sélectionner dans KTop les clés de liage candidates qui instancient les paires de classes qui ont plus de chances d'être pertinentes pour le liage. Ainsi dans l'algorithme 3, pour chaque classeC 1 de Class1 = {C 1 | C 1 ,C 2 ∈ pcc(K)}, RelevantClassForLk sélectionne la classe C 2 quidonne le meilleur recouvrement pour C 1 . Cette classe C 2 est alors ajoutée à l'ensemble Class2. Ensuite, pour chaque classe C 2 ∈ Class2, l'algorithme sélectionne la classe C 1 qui donne le meilleur recouvrement pour C 2 . L'ensemble des clés de liage KTop [ C 1 ,C 2 ] est alors ajouté à KV . Dans l'exemple, Class1 = {Newspaper,Person} et la classe Newspaper possède un meilleur recouvrement avec la classe Journal que la classe Personne car hm cd ({k 1 }) qui instancie la paire Newspaper,Journal est supérieure à hm cd ({k 3 }) qui instancie la paire Newspaper,Personne . La procédure est réitérée pour la classe Person et c'est la classe Personne qui est sélectionnée, et Class2 = {Journal,Personne}. Le processus est réitéré avec les classes de Class2. Pour la classe Journal, la classe Newspaper qui donne le meilleur recouvrement est sélectionnée et {k 1 } est ajouté à KV . Pour la classe Personne, la classe Person est sélectionnée et {k 5 } est ajouté à KV . Ainsi, la sortie de l'algorithme est l'ensemble KV = {k 1 , k 5 } qui identifie tous les liens d'identité corrects et uniquement ceux-là entre les jeux de données D 1 et D 2 , c.-à-d. l'ensemble des liens { a 1 , b 1 , a 2 , b 2 , a 3 , b 3 , a 4 , b 4 , a 5 , b 5 , a 6 , b 5 , a 7 , b 7 , a 8 , b 8 , a 9 , b 9 }.</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>. Cette seconde solution est celle qui nous intéresse directement et c'est dans cette direction que cet article apporte une contribution.Un jeu de données RDF est un ensemble de triplets sujet,propriété,objet ∈ (U ∪ B) ×U × (U ∪ B ∪ L), où U est un ensemble d'IRI, B un ensemble de noeuds vides représentant des ressources anonymes, L un ensemble de littéraux pouvant être du type chaîne de caractères, entier, etc.</figDesc><table><row><cell cols="2">3 Préliminaires et notations</cell><cell /><cell /><cell /></row><row><cell cols="2">3.1 Clé de liage</cell><cell /><cell /><cell /></row><row><cell /><cell>D 1</cell><cell /><cell>D 2</cell><cell /></row><row><cell>s a 1 a 2 a 3 a 4 a 5 a 6</cell><cell>Newspaper designation pubCity fYear Le Monde Paris 1944 Est R Nancy The NYT New York 1851 The WP Washington 1877 USA T McLean 1982 USA T McLean 1982</cell><cell>s b 1 b 2 b 3 b 4 b 5</cell><cell cols="2">Journal désign villeEdit dateF Le Monde Paris 1944 Est R Nancy The NYT New York 1851 The WP Washington 1877 USA T McLean 1982</cell></row><row><cell>s a 7 a 8 a 9 a 10 a 11</cell><cell>Person firstName name birthY Nancy Reagan 1921 Jane Austen Albert Camus Victor Hugo Emily Brontë</cell><cell>s b 7 b 8 b 9 b 10 b 11</cell><cell>Personne prénom nom Nancy Reagan Jane Austen Albert Camus Paris Hilton Assia Djebar</cell><cell>annéeN 1921</cell></row></table></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>et la discriminabilité peuvent être agrégées par la moyenne harmonique, notée hm cd (k), qui est définie ci-après :</figDesc><table><row><cell>candidate k 1 k 2 k 3 k 4 k 5 k 6</cell><cell>cov 1 0.81 0.80 0.80 disc hm cd 0.83 0.90 0.36 1 0.53 0.20 1 0.33 0.60 1 0.75 0.20 1 0.33</cell></row><row><cell cols="2">TAB. 1: Évaluation des clés de liage candidates de l'exemple</cell></row></table></figure>
<figure type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>-Pour les jeux de données Restaurants et Person1 de l'OAEI 2010 3 , des liens d'identité ont été fournis entre : -Les instances de la classe Restaurant pour les jeux de données Restaurant1 et Restaurant2. -Les instances de la classe Person pour les jeux de données Person11 et Person12. Comme notre travail porte sur les clés de liage instanciant différentes paires de classes, nous avons également considéré la découverte de liens d'identité entre les instances de la classe Adress présentes dans ces jeux de données. De plus nous avons considéré les jeux de données pr1 qui est la fusion de Restaurant1 et de Person1, et pr2 qui est la fusion de Restaurant2 et Person2. -Pour les jeux de données Abox1 et Abox2 de SPIMBench Sandbox de l'OAEI 2018 4 , nous avons considéré les classes Programme, BlogPost et NewsItem. -Le jeu de données Db-Yago 5 , est composé de 10 classes de DBpedia et de 10 classes de Yago qui sont : Actor, Album, Book, City, Film, Montain, Organisation, Scientist, Museum et University.</figDesc><table><row><cell>Tâche Restaurants 1 Person1 1 pr</cell><cell>Jeux de données Restaurant1 Restaurant2 Person11 Person12 pr1 pr2</cell><cell>#class. 3 3 4 2 7 5</cell><cell>#inst. 339 2 256 2000 1000 2 339 3 256</cell><cell>#prop. 6 6 13 12 19 18</cell><cell>#triples 1 130 7 520 9 000 7000 10 130 14 520</cell><cell>#lk 6 80 90</cell></row><row><cell>SPIMBench 2 Db-Yago 3</cell><cell>Abox1 Abox2 Db Yago</cell><cell>10 17 10 10</cell><cell>1 126 1 130 442 403 1 064 548</cell><cell>46 66 47 49</cell><cell>10 001 10 022 8 618 591 10 988 374</cell><cell>7 401 16 299</cell></row><row><cell cols="7">TAB. 2: Description des jeux de données utilisés dans les expérimentations</cell></row></table></figure>
<figure type="table" xml:id="tab_3"><head /><label /><figDesc>. Nous remarquons que dans tous les cas, nous obtenons avec LKSA une F-mesure supérieure ou égale à celle des M meilleures clés de liage candidates. LKSA obtient une meilleure F-mesure que Top M pour les jeux de données Person1, pr, SPIMBench et Db-Yago. Le rappel est amélioré pour Person1 et pr. La précision est améliorée pour pr, SPIMBench et Db-Yago. Les résultats de la sélection La F-mesure n'est pas modifiée pour le jeu données Restaurants car les M meilleures clés de liage correspondent exactement aux clés de liage sélectionnées par LKSA.</figDesc><table><row><cell>Tâche</cell><cell>sélection</cell><cell>#lk</cell><cell>rap.</cell><cell>F-mesure</cell><cell>prec.</cell><cell>temps</cell></row><row><cell>Restaurants</cell><cell>Top M LKSA, N = 1</cell><cell>2 2</cell><cell>0.634 0.634</cell><cell>0.719 0.719</cell><cell>0.83 0.83</cell><cell>&lt; 1</cell></row><row><cell>Person1 pr SPIMBench</cell><cell>Top M LKSA, N = 1 Top M LKSA, N = 1 Top M LKSA, N = 1</cell><cell>2 2 4 4 7 7</cell><cell>0.649 0.954 0.772 0.882 0.772 0.772</cell><cell>0.787 0.866 0.681 0.838 0.788 0.792</cell><cell>1 0.793 0.61 0.799 0.804 0.813</cell><cell>&lt; 1 &lt; 1 &lt; 8</cell></row><row><cell>Db-Yago</cell><cell>Top M LKSA, N = 1</cell><cell>22 22</cell><cell>0.736 0.630</cell><cell>0.089 0.504</cell><cell>0.047 0.420</cell><cell>&lt; 17 &lt; 4min</cell></row><row><cell /><cell>TAB. 3:</cell><cell /><cell /><cell /><cell /><cell /></row></table></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>La définition de maximalité d'une clé de liage candidate est donnée dans<ref type="bibr" target="#b5">(Atencia et al., 2020;</ref> Abbas et al.,  2020).</p></note>
			<note place="foot" n="2" xml:id="foot_1"><p>Les détails des expérimentations sont donnés dans https ://gitlab.inria.fr/nabbas/lksa.</p></note>
			<note place="foot" n="3" xml:id="foot_2"><p>http ://oaei.ontologymatching.org/2010/im/index.html</p></note>
			<note place="foot" n="4" xml:id="foot_3"><p>http ://oaei.ontologymatching.org/2018/spimbench.html</p></note>
			<note place="foot" n="5" xml:id="foot_4"><p>https ://github.com/lgalarra/vickey</p></note>
		</body>
		<back>
			<div type="annex">
<div><head>Summary</head><p>In this paper we are interested in link key selection in RDF datasets. A link key is used to find identity links between two entities in the web of data. Such pair of entities determines a pair of classes which in turn can guide the selection link key of better quality. For this purpose, we propose an algorithm for selecting link keys based on adapted quality measures. Finally, experiments on different data sets show the potential and the effectiveness of the algorithm.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Uncertainty-sensitive reasoning for inferring same as facts in linked data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Al-Bakri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lalande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ECAI</title>
		<meeting>ECAI</meeting>
		<imprint>
			<publisher>IOS press</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="698" to="706" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Inferring same-as facts from linked data : an iterative import-by-query approach</title>
		<author>
			<persName><forename type="first">M</forename><surname>Al-Bakri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lalande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-Ninth AAAI Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Data linking over rdf knowledge graphs : A survey</title>
		<author>
			<persName><forename type="first">A</forename><surname>Assi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mcheick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Dhifli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency and Computation : Practice and Experience</title>
		<imprint>
			<biblScope unit="page">5746</biblScope>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Data interlinking through robust linkkey extraction</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECAI</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="15" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">What can fca do for database linkkey extraction ? In 3rd ECAI workshop on What can FCA do for Artificial Intelligence ?</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FCA4AI)</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="85" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Link key candidate extraction with relational concept analysis</title>
		<author>
			<persName><forename type="first">M</forename><surname>Atencia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Euzenat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Napoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vizzini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">273</biblScope>
			<biblScope unit="page" from="2" to="20" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The description logic handbook : Theory, implementation and applications</title>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mcguinness</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Patel-Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Nardi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Cambridge university press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Keyranker : Automatic rdf key ranking for data linking</title>
		<author>
			<persName><forename type="first">H</forename><surname>Farah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Symeonidou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Todorov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of K-CAP</title>
		<meeting>K-CAP</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Pattern structures and their projections</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">O</forename><surname>Kuznetsov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Formal concept analysis : mathematical foundations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Ganter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Wille</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Limes-a time-efficient approach for large-scale link discovery on the web of data</title>
		<author>
			<persName><forename type="first">A.-C</forename><forename type="middle">N</forename><surname>Ngomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Auer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">L2r : A logical method for reference reconciliation</title>
		<author>
			<persName><forename type="first">F</forename><surname>Saïs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pernelle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-C</forename><surname>Rousset</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI</title>
		<meeting>AAAI</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="329" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">OWL web ontology language guide</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Welty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Mcguinness</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/owl-guide/" />
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>Recommendation, W3C</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Silk-a link discovery framework for the web of data</title>
		<author>
			<persName><forename type="first">J</forename><surname>Volz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gaedke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kobilarov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LDOW</title>
		<imprint>
			<biblScope unit="volume">538</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>