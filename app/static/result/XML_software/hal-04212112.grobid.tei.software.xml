<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">General Acyclicity and Cyclicity Notions for the Disjunctive Skolem Chase (Extended Technical Report)</title>
				<funder>
					<orgName type="full">Center for Advancing Electronics Dresden (cfaed)</orgName>
				</funder>
				<funder ref="#_5F4cYRk">
					<orgName type="full">Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)</orgName>
				</funder>
				<funder ref="#_P3Rypmw">
					<orgName type="full">DAAD (German Academic Exchange Service)</orgName>
				</funder>
				<funder ref="#_NQVpSBM">
					<orgName type="full">European ITEA</orgName>
				</funder>
				<funder ref="#_YHS4bmT">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_XA2sGev">
					<orgName type="full">Center for Perspicuous Systems)</orgName>
				</funder>
				<funder>
					<orgName type="full">Bundesministerium für Bildung und Forschung (BMBF, Federal Ministry of Education and Research)</orgName>
				</funder>
				<funder ref="#_78ENBdY">
					<orgName type="full">BMBF</orgName>
				</funder>
				<funder ref="#_BE68ttN">
					<orgName type="full">and Composite AI)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Lukas</forename><surname>Gerlach</surname></persName>
							<email>lukas.gerlach@tu-dresden.de</email>
							<affiliation key="aff0">
								<orgName type="department">Knowledge-Based Systems Group</orgName>
								<orgName type="institution">TU Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<email>david.carral@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">General Acyclicity and Cyclicity Notions for the Disjunctive Skolem Chase (Extended Technical Report)</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">F437D46DD03E034C4FFBB4EEAC396F06</idno>
					<idno type="DOI">10.1609/aaai.v37i5.25784</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The disjunctive skolem chase is a sound, complete, and potentially non-terminating procedure for solving boolean conjunctive query entailment over knowledge bases of disjunctive existential rules. We develop novel acyclicity and cyclicity notions for this procedure; that is, we develop sufficient conditions to determine chase termination and nontermination. Our empirical evaluation shows that our novel notions are significantly more general than existing criteria.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Solving query entailment over knowledge bases (KBs) of disjunctive existential rules is a relevant decision problem, which is readily defined as follows:</p><p>• Input: a set R of disjunctive existential rules, a set F of facts, and a boolean conjunctive query (BCQ) γ. • Output: yes iff γ is a logical consequence of the KB ⟨R, F⟩ under standard first-order semantics. <ref type="bibr">1</ref> One approach to solve BCQ entailment in practice is to apply the disjunctive skolem chase (?), which is a materialization procedure that aims to compute a finite universal model set for an input KB. If fully computed, this model set can then be used to solve query entailment: a BCQ γ is a logical consequence of a KB K iff γ is satisfied by every model in a universal model set of K iff γ is satisfied by every model in the output of the chase on input K.</p><p>Because the chase is sound and complete for BCQ entailment, and this problem is undecidable (?); the chase does not terminate on all inputs. Even worse, we cannot decide if this procedure terminates on a given input (??). Hence, the best one can do is to study acyclicity notions; that is, sufficient conditions that confirm chase termination. In our context, acyclicity notions are sufficient conditions that characterize terminating rule sets: A rule set R is terminating if the chase terminates on every KB of the form ⟨R, F⟩. To know if our acyclicity notions are as general as they can be, we also study cyclicity notions; that is, sufficient conditions for non-termination. In this paper, we focus on the skolem chase variant (?), which makes use of skolem terms that are used to satisfy existential restrictions when computing a universal model set.</p><p>While acyclicity notions for rule sets without disjunctions have been around for a while (??????), the first acyclicity notions for disjunctive rule sets were proposed fairly recently (?). In their work, ? extended model-faithful acyclicity (MFA) <ref type="bibr" target="#b31">2</ref> for the disjunctive setting and developed the first cyclicity notion for the (disjunctive) skolem chase, named model-faithful cyclicity (MFC). To the best of our knowledge, these are the only existing (a)cyclicity notions for nondeterministic rule sets.</p><p>We have empirically verified that MFA and MFC are quite effective at determining (non-)termination of rule sets without disjunctions: Using both notions, we are able to establish (non-)termination of around 99% of the deterministic rule sets in our evaluation; see Section C.1. However, in the presence of disjunctions, we could only establish the termination status of around 67% of the considered rule sets using MFA and MFC; see Section 5.</p><p>Our main goal is thus clear: We aim to develop general (a)cyclicity notions that can be used to determine chase (non-)termination of most real-world rule sets with disjunctions. More precisely, our contributions are as follows:</p><p>• In Sections 3 and 4, we present our novel (a)cyclicity notions, respectively. Moreover, we study the complexity of checking if a rule set is (a)cyclic and the complexity of solving BCQ entailment over KBs with acyclic rule sets. • In Section 5, we empirically show that MFA and MFC are significantly less general than our novel conditions, which allow us to establish (non-)termination of many of the (non-deterministic) rule sets in our test suite. • In Sections 6 and 7, we discuss related research and elaborate on possible follow-up work, respectively. This extended report features complete proofs (Sections A and B) and additional empirical results (Section C), which we do not include in the 7-page submission.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We define Cons, Vars, Funs, and Preds to be mutually disjoint, finite (albeit large enough) sets of constants, variables, function symbols, and predicates, respectively, such that every s ∈ Funs ∪ Preds has an arity ar(s) ≥ 1. For every i ≥ 1, let Funs i = {f | ar(f ) = i} and Preds i = {P | ar(P ) = i}. The set Terms of terms includes Cons ∪ Vars and contains f (t 1 , . . . , t n ) for every n ≥ 1, f ∈ Funs n , and t 1 , . . . , t n ∈ Terms. A term t is functional if t / ∈ Cons ∪ Vars. Given a first-order formula or a term υ, and a set X ∈ {Cons, Vars, Funs (i) , Terms, Preds (i) | i ≥ 1}; let X(υ) be the set of all elements in X that occur in υ.</p><p>We write lists t 1 , . . . , t n of terms as ⃗ t, which we often treat as sets. For a term t, let depth(t) = 1 if t is not functional and depth(t) = 1 + max(depth(s 1 ), . . . , depth(s n )) if t is of the form f (s 1 , . . . , s n ). A term s is a subterm of another term t if t = s, or t is of the form f (⃗ s) and s is a subterm of some term in ⃗ s. For a term t, let subterms(t) be the set of all subterms of t. A term is cyclic if it has a subterm of the form f (⃗ s) such that f ∈ Funs(⃗ s).</p><p>An atom is a first-order formula of the form P ( ⃗ t) where P is a | ⃗ t|-ary predicate and ⃗ t is a term list. A fact is a variablefree atom. For a first-order formula υ, we write υ[⃗ x] to indicate that ⃗ x is the set of all free variables that occur in υ; that is, those variables that are not explicitly quantified in υ. Definition 1. A (disjunctive existential) rule is a constantand function-free first-order formula of the form</p><formula xml:id="formula_0">∀ ⃗ w, ⃗ x. β[ ⃗ w, ⃗ x] → n i=1 ∃⃗ y i .η i [⃗ x i , ⃗ y i ]<label>(1)</label></formula><p>where n ≥ 1; ⃗ w, ⃗ x, ⃗ y 1 , . . . , ⃗ y n are pairwise disjoint lists of variables; n i=1 ⃗ x i = ⃗ x; ⃗ x 1 , . . . , ⃗ x n are non-empty; and β, η 1 , . . . , η n are non-empty conjunctions of atoms.</p><p>A rule ρ as in ( <ref type="formula" target="#formula_0">1</ref>) is deterministic if n = 1, generating if it features at least one existential variable, and datalog if it is deterministic and not generating. We call ⃗ x the frontier of ρ and denote it as frontier(ρ). Moreover, let body(ρ) = β and head i (ρ) = η i for every 1 ≤ i ≤ n. Often, we omit universal quantifiers when writing rules and treat conjunctions of atoms, such as body(ρ), as sets.</p><p>A (boolean conjunctive) query γ is a first-order formula of the form ∃⃗ y.β[⃗ y] with β a non-empty atom conjunction. A knowledge base (KB) K is a pair ⟨R, I⟩ with R a rule set and I an instance; that is, a function-free fact set. We write K |= γ to denote that (the first-order formula) ρ∈R ρ ∧ φ∈I φ entails γ under standard first-order semantics. In the following, we provide a procedural definition of query entailment via the chase algorithm; see Proposition 1. Without loss of generality, we assume that ( †) y / ∈ Vars(R \ {ρ}) for every rule set R, every rule ρ = β → n i=1 ∃⃗ y i .η i in R, and every y ∈ n i=1 ⃗ y i ; that is, existentially quantified variables do not reoccur across different rules in the same rule set.</p><p>A (ground) substitution σ is a partial function that maps variables to terms without occurrences of variables. We use [x 1 /t 1 , . . . , x n /t n ] to denote the substitution that maps the variable x i to the term t i for every 1 ≤ i ≤ n. For a firstorder formula υ, let υσ be the formula that results from replacing every occurrence of every variable x in the domain of σ in υ with σ(x).</p><p>Consider a rule ρ as in (1) in a rule set R. For every y ∈ n i=1 ⃗ y i , let f y ∈ Funs be a fresh |⃗ x|-ary function symbol, which is unique for ρ within R due to ( †). For every 1 ≤ i ≤ n, let sk(η i ) be the conjunction obtained by replacing every occurrence of every variable</p><formula xml:id="formula_1">y ∈ ⃗ y i in η i by f y (⃗ x). Let sk(ρ) = β → n i=1 sk(η i ) and sk(R) = {sk(ρ) | ρ ∈ R}.</formula><p>A trigger λ is a pair ⟨ρ, σ⟩ with ρ a rule as in (1) and σ a substitution with domain ⃗ w ∪ ⃗ x. The trigger λ is loaded for a fact set</p><formula xml:id="formula_2">F if βσ ⊆ F; it is active for F if sk(η i )σ ⊈ F for all 1 ≤ i ≤ n. Let out i (λ) = sk(η i )σ for 1 ≤ i ≤ n; out(λ) = {out i (λ) | 1 ≤ i ≤ n}. A fact set F is closed under a rule ρ if no</formula><p>trigger with ρ is loaded and active for F.</p><p>Consider a rule set R. An R-term is a term defined using the function symbols that occur in sk(R), some constants, and some variables. A substitution is an R-substitution if its range is a set of R-terms. An R-trigger is a trigger with a rule from R and an R-substitution. Definition 2. A (skolem) chase tree of a KB ⟨R, I⟩ is a directed tree T = ⟨V, E, fct, trg⟩ such that:</p><p>1. Let V be a set of vertices, E a set of edges, fct a labeling function that maps the vertices in V to fact sets (fact labels), and trg a labeling function that maps the vertices in V to R-triggers (trigger labels) or ϵ. 2. For the root r of T , we have fct(r) = I and trg(r) = ϵ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Consider some non</head><formula xml:id="formula_3">-leaf vertex v ∈ V with children U = {u | ⟨v, u⟩ ∈ E}.</formula><p>There is an R-trigger λ that is loaded and active for fct</p><formula xml:id="formula_4">(v), {fct(u) | u ∈ U } = {F ∪ fct(v) | F ∈ out(λ)}, |U | = |out(λ)|, and trg(u) = λ for each u ∈ U . Moreover, if ρ is not datalog, then fct(v) is closed under every datalog rule in R (that is, datalog-first). 4.</formula><p>Every leaf fact label is closed under all rules in R. Moreover, for every R-trigger λ, there is some k ≥ 1 such that λ is not loaded or not active for fct(v) for every v ∈ V of depth at least k (that is, fairness).</p><p>Consider a chase tree T = ⟨V, E, fct, trg⟩ for a KB ⟨R, I⟩. A branch B of a chase tree T is a sequence v 1 , v 2 , . . . ∈ V such that v 1 is the root of T , ⟨v i , v i+1 ⟩ ∈ E for every 1 ≤ i &lt; |B|, and if B is finite then its last element is a leaf in T . That is, a branch is a maximal path in T .</p><p>A KB terminates if it only admits finite chase trees. A rule set R terminates if every KB of the form ⟨R, I⟩ terminates. It is undecidable to determine if R terminates already for deterministic rule sets (?).</p><p>The result of a chase tree T is the set of all fact sets that can be constructed by taking the union of all fact labels in a branch of T . Hence, the result of a finite chase tree T is the set of fact labels of its leaves. In the presence of disjunctions, chase trees for the same KB may yield different results: Finite chase results can be used to solve query entailment: Proposition 1. Consider the result R of some (arbitrarily chosen) chase tree of a K. Then, K entails a query γ = ∃⃗ y.β iff F |= γ for every F ∈ R iff for every F ∈ R there is a substitution σ with βσ ⊆ F.</p><p>In Section 3.1, we recall MFA (?). In Section 3.2, we present disjunctive model-faithful acyclity, based on ideas from (?).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Model-Faithful Acyclicity (MFA)</head><p>To determine if a deterministic rule set R is MFA we check the fact set MFA(R), which contains all facts that may occur in a chase tree of a KB with R modulo replacement of constants with ⋆; we formalize this intuition in Lemma 1.</p><p>Definition 3. The critical instance I ⋆ is the set of all facts with any predicate in (the finite set) Preds and the special constant ⋆; that is, I ⋆ = {P (⋆, . . . , ⋆) | P ∈ Preds}.</p><p>For a deterministic rule set R, let MFA(R) ⊇ I ⋆ be the minimal fact set that includes out 1 (λ) for every (deterministic) R-trigger λ that is loaded for MFA(R). Definition 4. A constant mapping g is a partial function from Cons to Terms. For a term t, let g(t) be the term that results from replacing every occurrence of every c in the domain of g in t with g(c).</p><p>We can prove the following via induction on a chase tree: Lemma 1. For a fact label F in a chase tree of a KB with a deterministic rule set R, we have g ⋆ (F) ⊆ MFA(R) where g ⋆ is the constant mapping that maps every constant to ⋆.</p><p>Consider a chase tree T for a KB ⟨R, I⟩. By Lemma 1, the depth of the terms that occur in T is bounded by the depth of the terms in MFA(R) since depth(t) = depth(g ⋆ (t)) for every term t. Since only a finite number of terms of bounded depth can be defined with the constants that occur in I, finiteness of MFA(R) implies finiteness of T . Therefore: Lemma 2. If MFA(R) is finite for some deterministic rule set R, then R terminates.</p><p>Consider a deterministic rule set R. Then, MFA(R) is finite iff ⟨R, I ⋆ ⟩ terminates. ? have shown that we cannot decide the latter; hence, we cannot decide if MFA(R) is finite either. However, we can compute this set up to the occurrence of a cyclic term.</p><formula xml:id="formula_5">Definition 5. A deterministic rule set R is MFA if no cyclic term occurs in MFA(R).</formula><p>The occurrence of a cyclic term indicates that a rule ρ is applied in a chase tree to produce a descendant of a term introduced to satisfy ρ. In many real-world cases, this implies that infinitely many applications of ρ may follow.</p><p>The following theorem is a corollary of Lemma 2 and the fact that, for a deterministic rule set R, the fact set MFA(R) is finite if it does not feature cyclic terms: Theorem 3. Deterministic MFA rule sets terminate.</p><p>MFA was originally defined for rule sets without disjunctions (?). ? came up with a straightforward way to extend this acyclicity notion for the disjunctive setting; see Theorem 4. Definition 6. For a rule ρ as in (1) and a rule set R, let</p><formula xml:id="formula_6">ρ ∧ = β → ∃⃗ y 1 , . . . , ⃗ y n . n i=1 η i and R ∧ = {ρ ∧ | ρ ∈ R}. Theorem 4. A rule set R terminates if R ∧ terminates.</formula><p>Applying Theorems 3 and 4, we can extend MFA (and any other deterministic skolem acyclicity notion) so it can be applied rule sets with disjunctions: Definition 7. A rule set R is MFA if R ∧ is MFA. Corollary 5. MFA rule sets terminate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Disjunctive MFA (DMFA)</head><p>To determine if a (possibly non-deterministic) rule set R is DMFA, we look for cyclic terms in the fact set DMFA(R), which has the same property as MFA(R ∧ ). Namely, this fact set contains all facts that may occur in a chase tree of a KB with R modulo replacement of all constants with ⋆; see Lemma 9. However, DMFA(R) is a tighter overapproximation than MFA(R ∧ ); in fact, later on we show that DMFA(R) is a subset of MFA(R ∧ ) for every rule set R; see the proof of Theorem 11.</p><p>In order to minimize DMFA(R), we adjust the notion of blockedness, <ref type="bibr">3</ref> which we use to characterize harmless triggers that are never applied in any chase tree: Example 2. Consider R = {(2-5)}, which is a slightly simplified subset of rule set 00007.owl in the Oxford Ontology Repository (see Section 5):</p><formula xml:id="formula_7">evidence(x) → ∃w.Confidence(x, w) (2) Confidence(x, y) → confidence(y) (3) Confidence(x, y) → ∃z.XRef(y, z) (4) XRef(x, y) → evidence(x) ∨ confidence(x) (5)</formula><p>Consider a chase tree T = ⟨V, E, fct, trg⟩ for a KB of the form ⟨R, I⟩ and suppose for a contradiction that trg(v) = ⟨(5), [x/f w (t), y/f z (f w (t))]⟩ for some v ∈ V and a term t. Then, Confidence(t, f w (t)) ∈ fct(p) with p the parent of v since f w (t) may only be introduced in T via the application of (2). Moreover, confidence(f w (t)) ∈ fct(p) since fct(p) is closed under (3); see Item 3 in Definition 2. But then, the trigger trg(v) is not active for fct(p)! In fact, we can use blockedness to show that triggers such as trg(v) may never occur as a trigger labels in a chase tree of a KB with R.</p><p>To define blockedness, we introduce the fact set U(R, λ) for a given rule set R and a trigger λ. Intuitively, this fact set can be "homomorphically embedded" into the fact label of a vertex v in a chase tree T of a KB with R if λ is applied to v in T ; see Lemma 6. Definition 8. Let R be a rule set and t an R-term.</p><formula xml:id="formula_8">• If t is not functional, then U(R, t) = ∅.</formula><p>• Otherwise, t is of the form f y (⃗ s) and there is exactly one rule</p><formula xml:id="formula_9">ρ = β[ ⃗ w, ⃗ x] → n i=1 ∃⃗ y i .η i [⃗ x i , ⃗ y i ] ∈ R and exactly one 1 ≤ ℓ ≤ n with y ∈ ⃗ y ℓ . Then, U(R, t) = βσ ∪ out ℓ (⟨ρ, σ⟩) ∪ s∈⃗ s U(R, s)</formula><p>where σ is a substitution with ⃗ xσ = ⃗ s and ⃗ wσ = ⃗ c for fresh constants ⃗ c. Consider an R-trigger λ = ⟨ρ, σ⟩. Then, let U(R, λ) be the minimal fact set that includes body(ρ)σ and U(R, t) for every t in the range of σ, and that is closed under every datalog rule in R if ρ is not datalog.</p><p>An R-trigger λ is blocked for a rule set R if its rule is not datalog and λ is not active for U(R, λ). Lemma 6. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩. Then, for every v ∈ V , there is a constant mapping g that is the identity on Cons(fct(v)) such that A. g(U(R, t)) ⊆ fct(v) for every t ∈ Terms(fct(v)) and B. g(U(R, trg(u))) ⊆ fct(v) for every ⟨v, u⟩ ∈ E.</p><p>Consider some trigger λ (with a non-datalog rule) that is blocked for R and suppose for a contradiction that λ is the trigger label of a vertex u in a chase tree T of a KB with R. Then, λ is not active for the fact label of the parent v of u in T by Lemma 6, which contradicts Definition 2. Therefore: Lemma 7. If a trigger λ is blocked for R, then λ does not occur as a trigger label in any chase tree of a KB with R.</p><p>Relying on blockedness, we can safely ignore many facts when we define the over-approximation DMFA(R): Definition 9. For a rule set R, let DMFA(R) ⊇ I ⋆ be the fact set that includes all sets in out(⟨ρ, σ⟩) for every Rtrigger ⟨ρ, σ⟩ such that (i) ⟨ρ, σ⟩ is loaded for DMFA(R) and (ii) ⟨ρ, σ r ⟩ is not blocked for R.</p><p>In the above, let σ r be a substitution such that, for every x ∈ domain(σ), the term σ r (x) is obtained by replacing every occurrence of a constant in σ(x) with a fresh constant. <ref type="bibr">4</ref> We need σ r to generalize over all possible KBs with R.</p><p>All "less general" triggers will also be blocked: Lemma 8. For a trigger ⟨ρ, σ⟩, a rule set R, and a constant mapping g; if ⟨ρ, σ r ⟩ is blocked for R, then so is ⟨ρ, g • σ r ⟩.</p><p>Armed with Lemmas 7 and 8, we can readily show the following result via induction on the structure of a chase tree: Lemma 9. For a fact label F in a chase tree of a KB ⟨R, I⟩, we have that g ⋆ (F) ⊆ DMFA(R) where g ⋆ is the constant mapping that maps every constant to ⋆.</p><p>As for MFA, we simply compute DMFA(R) up to the occurrence of a cyclic term to check if a rule set R is DMFA: <ref type="table" target="#tab_4">by Definitions 3</ref> and<ref type="table">9</ref>. Furthermore, the rule set in Example 2 is DMFA but not MFA. Therefore: Theorem 11. If a rule set R is MFA, then it is DMFA. Moreover, the converse of this implication does not hold.</p><formula xml:id="formula_10">Definition 10. A rule set R is DMFA if no cyclic term oc- curs in DMFA(R). Theorem 10. DMFA rule sets terminate. A rule set R is DMFA if it is MFA since DMFA(R) is a subset of MFA(R)</formula><p>The number of acyclic terms that one can define with the functions in Funs(sk(R)) and ⋆ is double-exponential in R; hence, so is |DMFA(R)|. Moreover, for an instance I, we have that |Terms(DMFA(R))| • |Cons(I)| is an upper bound for the number of terms in any chase tree of ⟨R, I⟩. Once we realise these claims, we can readily show that: Theorem 12. DMFA-membership is 2EXPTIME-complete.</p><p>Theorem 13. Deciding query entailment for a KB with an DMFA rule set is coN2EXPTIME-complete. <ref type="bibr">4</ref> For example, σr =</p><formula xml:id="formula_11">[x/f (b, c), y/d] if σ = [x/f (a, a), y/a].</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Cyclicity Notions</head><p>Cyclicity notions are sufficient conditions that characterize non-terminating rule sets. In fact, the conditions we consider in this section imply a stronger form of non-termination: Definition 11. A rule set R never terminates if there is a KB ⟨R, I⟩ that does not admit any finite chase tree.</p><p>In Section 4.1, we recall MFC (?). In Section 4.2, we present disjunctive model-faithful cyclicity (DMFC), which is based on ideas from the same authors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Model Faithful Cyclicity (MFC)</head><p>Intuitively speaking, the idea behind MFC (?) is to check if a generating rule is reapplied when starting on a minimal instance that mimics a fact label where the rule has just been applied. If the rule is indeed reapplied and yields a cyclic term, then it can be applied infinitely many times; see Theorem 14. Definition 12. For a rule ρ as in (1) and some</p><formula xml:id="formula_12">1 ≤ k ≤ n, let I ρ,k = body(ρ)σ uc ∪ out k (⟨ρ, σ uc ⟩)</formula><p>where σ uc is a substitution that maps every variable x to a fresh constant c x . If ρ is deterministic, we define</p><formula xml:id="formula_13">I ρ = I ρ,1 .</formula><p>Given a rule set R and a deterministic rule ρ ∈ R, we first define the fact set MFC(R, ρ), which consists of facts that appear on all branches of all chase trees of ⟨R, body(ρ)σ uc ⟩. Note that we use body(ρ)σ uc instead I ρ in the previous KB because the latter may feature function symbols and hence, it may not be an instance. Definition 13. For a rule set R and a deterministic rule ρ ∈ R, let MFC(R, ρ) ⊇ I ρ be the minimal fact set that includes out 1 (λ) for every R-trigger λ such that (i) λ is loaded for MFC(R, ρ), (ii) the rule in λ is deterministic, and (iii) the substitution in λ does not feature cyclic terms in its range.</p><formula xml:id="formula_14">Condition (iii) ensures that MFC(R, ρ) is always finite. Definition 14. A rule set R is MFC if a ρ-cyclic term occurs in MFC(R, ρ) for a deterministic rule ρ ∈ R. That is, a term of the form f (⃗ s) with f ∈ Funs(sk(ρ)) and f ∈ Funs(⃗ s).</formula><p>If R is MFC, then ⟨R, body(ρ)σ uc ⟩ does not terminate: Theorem 14. MFC rule sets are never terminating.</p><p>Sketch. If a rule set R is MFC, then MFC(R, ρ) features a ρ-cyclic term t for a deterministic rule ρ ∈ R. Hence, there is a list of R-triggers applied during the construction of MFC(R, ρ) that leads to t. More precisely, there is a list λ 1 , . . . , λ n such that, for every cyclic term, and (vi)   n-1 j=1 out 1 (λ j ) does not. This list can be extended into an infinite sequence: For every 1 ≤ i ≤ n and j ≥ 1, let λ j i be the R-trigger ⟨ρ i , g •j-1 • σ i ⟩ where g is the constant mapping with σ n = g • σ uc . <ref type="bibr">5</ref> Consider a chase tree T = ⟨V, E, fct, trg⟩ of the KB K = ⟨R, body(ρ)σ uc ⟩. Then, for every branch v 1 , v 2 , . . . ∈ V of T , we can show via structural induction that the following holds: For every 1 ≤ i ≤ n and j ≥ 1, the trigger λ j i is loaded for fct(v k ) for some k ≥ 1 and out 1 (λ j i ) ⊆ fct(v ℓ ) for some ℓ ≥ k. Hence, every branch of T is infinite by (v) and (vi) and hence, K does not admit finite chase trees.</p><formula xml:id="formula_15">1 ≤ i ≤ n: (i) λ i = ⟨ρ i , σ i ⟩, (ii) out 1 (λ i ) ⊆ MFC(R, ρ), (iii) ρ i is deterministic, (iv) λ i is loaded for I ρ ∪ i-1 j=1 out 1 (λ j ), (v) out 1 (λ n ) features a ρ-</formula><p>The induction step at the end of the previous sketch is easy to show once one realizes that: Lemma 15. Consider a vertex v in a branch B of a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩, and an R-trigger λ. If λ features a deterministic rule and is loaded for fct(v), then fct(v) ∪ out 1 (λ) ⊆ fct(u) for some u ∈ B.</p><p>Intuitively, this means that, once a deterministic trigger is loaded for a vertex v in a chase tree, every branch with v includes the output of this trigger. Note that such a result does not hold for non-deterministic triggers; see Example 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Disjunctive Model-Faithful Cyclicity (DMFC)</head><p>We ignore non-deterministic rules when deciding MFC membership (see Definition 13). Hence, this notion fails to characterise non-terminating rule sets such as: Example 3. Consider the rule set R = {R(x, y) → A(y) ∨ B(y), A(x) → ∃y.R(x, y)}, which never terminates since every chase tree for ⟨R, {A(c)}⟩ features (exactly) one infinite branch. However, R is not MFC; to establish never termination we need to take the disjunctive rule into account.</p><p>We consider head-choices to deal with disjunctive rules:</p><formula xml:id="formula_16">Definition 15. A head-choice is a function hc that maps ev- ery rule β → n i=1 ∃⃗ y i .η i to some 1 ≤ j ≤ n. For a trigger λ = ⟨ρ, σ⟩, let out hc (λ) = out hc(ρ) (λ).</formula><p>Later on, we show that some rule sets are not terminating by focusing on the branch in a tree induced by a head-choice: Definition 16. For a chase tree T = ⟨V, E, fct, trg⟩ and a head-choice hc, let branch(T, hc) = v 1 , v 2 , . . . be the branch of T such that fct(v i+1 ) = out hc (trg(v i+1 ))∪fct(v i ) for every 1 ≤ i &lt; |branch(T, hc)|.</p><p>To use disjunctive rules to witness non-termination, we identify triggers that need to be applied once they are loaded. To do so, we define unblockable triggers<ref type="foot" target="#foot_3">6</ref> ⟨ρ, σ⟩ for a rule set R and a head-choice hc, which satisfy the following: I. Consider a chase tree T of a KB with R. If λ becomes loaded in branch(T, hc), then out hc (λ) is eventually included in branch(T, hc); that is, Lemma 16. II. Unblockability propagates across an infinite family of triggers. Namely, if a constant mapping g is reversible (see Definition 18), then the trigger ⟨ρ, g • σ⟩ is also unblockable; that is Lemma 17. Definition 17. Let R be a rule set and t an R-term.</p><formula xml:id="formula_17">• If t is not functional, then H(R, t) = ∅.</formula><p>• Otherwise, t is of the form f y (⃗ s) and there is exactly one rule</p><formula xml:id="formula_18">ρ = β[ ⃗ w, ⃗ x] → n i=1 ∃⃗ y i .η i [⃗ x i , ⃗ y i ] ∈ R and ex- actly one 1 ≤ ℓ ≤ n with y ∈ ⃗ y ℓ . Then, H(R, t) = out ℓ (⟨ρ, σ⟩) ∪ s∈⃗ s H(R, s) where σ is a substitution with ⃗ xσ = ⃗ s.</formula><p>Consider an R-trigger λ = ⟨ρ, σ⟩. Then, let H(R, λ) be the minimal fact set that includes H(R, t) for every t in the range of σ restricted to variables in frontier(ρ). Additionally, let the term-skeleton of λ be skeleton R</p><formula xml:id="formula_19">(λ) = Terms(H(R, λ)) ∪ Cons({σ(x) | x ∈ frontier(ρ)}).</formula><p>For a rule ρ = β → n i=1 ∃⃗ y i .η i , let star(ρ) = β → n i=1 η ′ i be the (non-generating) rule where η ′ i is the conjunction that results from replacing every occurrence of every y ∈ ⃗ y i in η i with ⋆.</p><p>For a rule set R, a head-choice hc, and an R-trigger λ, let O(R, hc, λ) be the minimal fact set that includes:</p><p>• The set H(R, λ).</p><p>• The set of all facts that can be defined using any predicate and constants in Cons(skeleton R (λ)) ∪ {⋆}. • The set out hc (⟨star(ρ), σ⟩) for every R-trigger ⟨ρ, σ⟩ loaded for O(R, hc, λ) with out hc (λ) ̸ = out hc (⟨ρ, σ⟩).</p><p>The trigger λ is unblockable for R and hc if it features a deterministic rule or if it is active for O(R, hc, λ). Lemma 16. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩, a head-choice hc, some v ∈ branch(T, hc), and an R-trigger λ. If λ is loaded for fct(v), and it is unblockable for R and hc; then fct(v) ∪ out hc (λ) ⊆ fct(u) for some u ∈ branch(T, hc).</p><formula xml:id="formula_20">Sketch. For a term t, let h λ (t) = t if t ∈ skeleton R (λ) and h λ (t) = ⋆ otherwise. We have that, if out hc (λ) ⊈ fct(w) for some w ∈ branch(T, hc), then h λ (fct(w)) ⊆ O(R, hc, λ) (see Lemma 21). That is, O(R, hc, λ) "over-approximates" fact labels in branch(T, hc) that do not include out hc (λ).</formula><p>Assume that the premise of the lemma holds. If ρ is deterministic, the claim holds by Lemma 15. Otherwise, λ is active for the "over-approximation" O(R, hc, λ). Hence, λ remains active for the fact labels in branch(T, hc) up until its output is included in the branch by Lemma 21.</p><p>Definition 18. Consider a set T of terms that includes subterms(t) for every t ∈ T . A constant mapping g is reversible for T if (i) the domain of g is Cons(T ), (ii) t ̸ = s implies g(t) ̸ = g(s) for every t, s ∈ T , and (iii) for every c ∈ Cons(T ) and every s ∈ subterms(g(c)), there is no functional term u ∈ T with g(u) = s. Lemma 17. Consider a rule set R, a head-choice hc, an R-trigger ⟨ρ, σ⟩, and a constant mapping g that is reversible for skeleton R (⟨ρ, σ⟩). If ⟨ρ, g • σ⟩ is an R-trigger and ⟨ρ, σ⟩ is unblockable for R and hc, then so is ⟨ρ, g • σ⟩.</p><p>Sketch. Assume that the premise of the lemma holds. If ρ is deterministic, the claim holds by Definition 17. Otherwise, ⟨ρ, σ⟩ is active for O(R, hc, ⟨ρ, σ⟩). Hence, ⟨ρ, g • σ⟩ is also active for O(R, hc, ⟨ρ, g • σ⟩) since h(O(R, hc, ⟨ρ, g • σ⟩)) ⊆ O(R, hc, ⟨ρ, σ⟩) with h the function defined as follows: For a term t, let h(t) = s if there is a term s that occurs in skeleton R (⟨ρ, σ⟩) with g(s) = t, and h(t) = ⋆ otherwise. Note that h is well-defined because g is reversible (see (ii) in Definition 18), and the inclusion holds because O(R, hc, ⟨ρ, σ⟩) contains all facts that can be defined with constants in skeleton R (⟨ρ, σ⟩) and ⋆.</p><p>We are ready to define DMFC and prove it sound:</p><p>Definition 19. Consider a rule set R, a head-choice hc, and a rule ρ ∈ R. Then, let DMFC(R, hc, ρ) ⊇ I ρ,hc(ρ) be the fact set that includes out hc (λ) for every R-trigger λ = ⟨ψ, σ⟩ such that (i) λ is loaded for DMFC(R, hc, ρ), (ii) λ is unblockable for R and hc, (iii) there are no cyclic terms in the range of σ, (iv) there is a frontier variable x ∈ frontier(ψ) with σ(x) being functional if ψ is nondatalog, and (v) σ is injective if ψ = ρ. Definition 20. A rule set R is DMFC if DMFC(R, hc, ρ) features a ρ-cyclic term for a ρ ∈ R and a head-choice hc. Theorem 18. DMFC rule sets are never terminating.</p><p>Sketch. If a rule set R is DMFC, then DMFC(R, hc, ρ) features a ρ-cyclic term t for some head-choice hc and some ρ ∈ R. Then, there is a list λ 1 , . . . , λ n of unblockable Rtriggers applied during the construction of DMFC(R, hc, ρ) that yields t. More precisely; for every 1 ≤ i ≤ n; let λ i = ⟨ρ i , σ i ⟩; out hc (λ i ) ⊆ DMFC(R, hc, ρ); the trigger λ i is unblockable for R and hc, and is loaded for</p><formula xml:id="formula_21">I ρ ∪ i-1</formula><p>j=1 out hc (λ j ); the function σ n is injective; and out hc (λ n ) features a ρ-cyclic term and n-1 j=1 out hc (λ j ) does not. As in Theorem 14, we extend this list into an infinite sequence: For every 1 ≤ i ≤ n and every j ≥ 1, let λ j i = ⟨ρ i , g •j-1 • σ i ⟩ where g is the constant mapping with σ n = g • σ uc .</p><p>Let F = I ρ,hc(ρ) ∪ j≥1 n i=1 out hc (λ j i ) and assume (for now) that g is reversible for Terms(F). We show that branch(T, hc) is infinite for every tree T of ⟨R, body(ρ)σ uc ⟩. First, I ρ,hc(ρ) occurs in some fact label in branch(T, hc); otherwise, λ n would not be unblockable. Then, by induction, for every 1 ≤ i ≤ n and j ≥ 1, the trigger λ j i is loaded for some fact label in branch(T, hc) and hence, some fact label in the branch includes out hc (λ j i ) by Lemma 16. We can apply this lemma here because g is reversible and hence, λ j i is unblockable by Lemma 17. It remains to show that g is reversible for Terms(F) to complete our proof. First, we show the claims below: a. There are no ρ-cyclic terms in n-1 j=1 out hc (λ j ). Therefore, for every constant c in F, the term g(c) does not feature nested function symbols from sk(ρ). 7 b. By (iv) in Definition 19: For every functional term t occurring in DMFC(R, hc, ρ), there is some subterm s of t that is also functional and that occurs in I ρ,hc(ρ) ; that is, s is of the form f (⃗ c) with f ∈ Funs(sk(ρ)) and ⃗ c a list containing every constant in σ uc (frontier(ρ)). We can extend this claim to all functional terms in F via induction. c. There is some constant c ∈ σ uc (frontier(ρ)) such that g(c) features a function symbol from sk(ρ). Otherwise out hc (λ n ) would not feature a ρ-cyclic term. d. By (b) and (c): For every functional term t in F, the term g(t) features nested function symbols from sk(ρ).</p><p>To verify that g is reversible for the terms in F we separately prove (i), (ii), and (iii) from Definition 18. The first one holds since the domain of g is Cons(I ρ,hc(ρ) ). <ref type="bibr">7</ref> The term fy(fz(c)) features nested function symbols from sk(A(x) → ∃y, z.R(x, y, z)) while fw(fy(c), fz(d)) does not.</p><p>To show (ii), we check that g(t) ̸ = g(s) for every t, s ∈ Terms(F) with t ̸ = s via structural induction on t. Regarding the base case, we consider two cases: If t and s are constants, then g(t) ̸ = g(s) since (σ n and) g are injections. If t is a constant and s is functional, then g(s) features nested function symbols from sk(ρ) by (d) and g(t) does not by (a). Regarding the induction step, we again consider two cases: If t and s are functional terms of the form f ( ⃗ t) and h(⃗ s), respectively, with f ̸ = h; then g(t) ̸ = g(s) since g(t) = f (g( ⃗ t)) and g(s) = h(g(⃗ s)). If t and s are functional terms of the form f (t 1 , . . . , t n ) and f (s 1 , . . . , s n ), respectively; then t i ̸ = s i for some 1 ≤ i ≤ n since t ̸ = s, g(t i ) ̸ = g(s i ) by induction hypothesis, and g(t) ̸ = g(s).</p><p>Finally, we show that (iii) holds by contradiction. Consider a functional term t ∈ Terms(F) with g(c) = t for some constant c and assume that there is a functional term u and a subterm s of t such that g(u) = s. By (a), the term t does not feature nested function symbols from sk(ρ); hence, s does not feature them either. However, s features nested functional symbols from sk(ρ) by (d)! Because of (iv) and (v) in Definition 19, DMFC is not more general than MFC. However, in our experiments, we did not find a single rule set that is MFC but not DMFC.</p><p>Regarding complexity, checking MFC and DMFC is dominated by the number of acyclic terms, which is doubleexponential in the size of the given rule set (??).</p><p>Theorem 19. (D)MFC-membership is 2EXPTIME-comp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>We present experiments to show the generality of our notions in practice. We describe our implementation, the rule sets we use, and the results of our experiments. The tools, rule sets, and results of the evaluation are available online. <ref type="bibr" target="#b35">8</ref> Further information on the concrete steps to reproduce the evaluation steps is also provided there.</p><p>To avoid an exponential number of checks, we consider a simplified version of DMFC in our implementation:</p><formula xml:id="formula_22">Definition 21. For a rule ρ = β → n j=1 ∃⃗ z j .η j and some i ≥ 1, let hc i (ρ) = n if i &gt; n and hc i (ρ) = i if i ≤ n. A rule set R is DMFC s if, for some ρ ∈ R and some i ≥ 1, the fact set DMFC(R, ρ, hc i ) features a ρ-cyclic term.</formula><p>By definition, DMFC s implies DMFC so it ensures never termination. We consider an improvement of DMFA in our implementation, which guarantees termination by Lemma 9:</p><formula xml:id="formula_23">Definition 22. A rule set R is DMFA k for some k ≥ 1 if DMFA (R)</formula><p>does not feature any k-cyclic term; that is, a term with k + 1 nested occurrences of the same function symbol.</p><p>We obtain the rule sets in the evaluation from OWL ontologies via normalization and translation into rules; see Section 6 in (?). We drop OWL axioms with "at-most restrictions" and "nominals" because their translation requires the use of equality; one can incorporate this feature via axiomatisation (?). The ontologies come from the Oxford We count the number of rule sets that are MFA, DMFA <ref type="bibr" target="#b31">(2)</ref> , MFC, and DMFC s and present our results in Table <ref type="table" target="#tab_0">1</ref>. We set a timeout of 30 minutes for each check and only consider rule sets for which all checks finished; we indicate the number of attempted vs finished rule sets by # tot. and # fin., respectively. We group results by the number of generating rules, indicated by #∃. For instance, in the second row in Table <ref type="table" target="#tab_0">1</ref> we indicate: There are 18 rule sets in the OXFD corpus with at least 20 but at most 99 generating rules; all checks finished for 17 of these; 3 of these are MFA; etc.</p><p>If we use MFA and MFC, the percentage of finished rule sets that are fully classified (i.e., sets that are MFA or MFC) for OXFD, ORE15, and MOWL are 70%, 58%, and 60%, respectively. Our improved notions are significantly more general; if we apply them, we can now classify 97%, 99%, and 97% of the finished rule sets in these repositories. Moreover, the use of DMFA 2 allows us to detect that many (hitherto unclassified) rule sets terminate for the skolem chase! 6 Related Work ? and ? showed that checking chase termination for linear and guarded deterministic rule sets, respectively, is decidable.</p><p>Definition 23. A rule ρ is linear if it features a single atom in its body; it is guarded if it features an atom in its body that contains all of the universally quantified variables in ρ.</p><p>Note that all linear rules are guarded, and that over half of the rule sets in Table <ref type="table" target="#tab_0">1</ref> are not guarded since they contain rules of the form</p><formula xml:id="formula_24">n i=1 R i (x i-1 , x i ) → R(x 0 , x n ) with</formula><p>9 https://www.cs.ox.ac.uk/isg/ontologies/ 10 https://doi.org/10.5281/zenodo.18578 ? 11 https://doi.org/10.5281/zenodo.16708 ? n ≥ 2. In Section C.2, we present separate results for nonguarded rule sets; these are rather similar percentage-wise to those presented in Table <ref type="table" target="#tab_0">1</ref>.</p><p>Theorem 4 allows us to extend any deterministic skolem acyclicity notions for non-deterministic rule sets. Instead of MFA, we could consider the following:</p><p>Definition 24. For a computable function δ over the naturals, a rule set R is δ-bounded if the depth of terms in MFA(R) is bounded by δ(|R|).</p><p>For a computable function δ over the naturals, we can decide δ-bounded membership and this property implies termination (?). Alternatively, instead of considering δboundedness, one can simply increase the number k in Definition 22 to achieve a similar effect. In fact, we ran some tests and only found 2 rule sets that are DMFA 5 but not DMFA 2 . Hence, we have decided to not publish results for k &gt; 2 and believe that using δ-boundedness would not result in a big increase in performance in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Future Work</head><p>We present novel (a)cyclicity notions that allow us to establish the termination status of most rule sets in our test suite.</p><p>As for immediate future work, we plan to extend our notions to the restricted chase and investigate why some rule sets are not classified as (non)-terminating. Potentially, we fail to capture these because they are "sometimes" nonterminating; that is, they may occur in KBs that admit finite and infinite chase trees. We would also like to develop a normalisation procedure that preserves both query entailment and chase termination.</p><p>As a long term goal, we would like to adapt our notions so they can be applied in other areas of knowledge representation and reasoning. For instance, we believe that we can use our ideas to (i) show if an ASP program with function symbols does or does not admit a finite solution or (ii) determine if DPLL(T) algorithms used in automated theorem proving will terminate or not for many real-world inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proofs for Section 3</head><p>Since many of the proofs regarding our newly defined notions rely heavily on existing ideas from (?), we prove again all previous results again to be self-contained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Model-Faithful Acyclicity</head><p>Lemma 1. For a fact label F in a chase tree of a KB with a deterministic rule set R, we have g ⋆ (F) ⊆ MFA(R) where g ⋆ is the constant mapping that maps every constant to ⋆.</p><p>Proof. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩ with a deterministic rule set. We verify via structural induction on T that g ⋆ (fct(v)) ⊆ MFA(R) for every v ∈ V .</p><p>• We have that g ⋆ (fct(r)) ⊆ I ⋆ with r the root vertex of T since fct(r) is an instance. Therefore, the base case holds since I ⋆ ⊆ MFA(R). • Regarding the induction step, consider some non-root vertex c and its parent p in T . 1. By induction hypothesis: g ⋆ (fct(p)) ⊆ MFA(R).</p><p>2. Since ⟨p, c⟩ ∈ E: the trigger trg(c) = ⟨ρ, σ⟩ is loaded for fct(p) and fct(c) = fct(p)∪out 1 (trg(c)). Note that ρ is a deterministic rule. 3. By ( <ref type="formula" target="#formula_0">1</ref>) and ( <ref type="formula">2</ref>): ⟨ρ, g ⋆ • σ⟩ is loaded for MFA (R). 4. By (3): out 1 (⟨ρ, g ⋆ • σ⟩) ⊆ MFA(R). 5. By ( <ref type="formula" target="#formula_0">1</ref>), ( <ref type="formula">2</ref>), and ( <ref type="formula">4</ref>): g ⋆ (fct(c)) ⊆ MFA(R) and the induction step holds.</p><p>Lemma 2. If MFA(R) is finite for some deterministic rule set R, then R terminates.</p><p>Proof. We show the contrapositive of the lemma.</p><p>1. Assume that R is not terminating. 2. By ( <ref type="formula" target="#formula_0">1</ref>): there is a KB of the form ⟨R, I⟩ that admits an infinite chase tree T = ⟨V, E, fct, trg⟩. Hence, there is a branch B of T that is infinite. 3. By (2): the fact set F = v∈B fct(v) is infinite. Therefore, the set Terms(F) is also infinite. 4. By ( <ref type="formula">2</ref>) and ( <ref type="formula">3</ref>): Cons(F) = Cons(I) and Funs(F) ⊆ Funs(sk(R)). Hence, these sets are finite. 5. By ( <ref type="formula">3</ref>) and ( <ref type="formula">4</ref>): the depth of the terms in Terms(F) is unbounded. That it, for every i ≥ 1, there is a term t ∈ Terms(F) with depth(t) ≥ i. 6. By (3) and Lemma 1: g ⋆ (F) ⊆ MFA(R). 7. By ( <ref type="formula">5</ref>) and ( <ref type="formula">6</ref>): Terms(MFA(R)) is infinite since g ⋆ preserves the depth of the terms. Hence, MFA(R) is infinite.</p><p>Theorem 3. Deterministic MFA rule sets terminate.</p><p>Proof. If a deterministic rule set R is MFA, then MFA(R) does not feature cyclic terms. Hence, MFA(R) is finite since there is only a finite number of non-cyclic terms that can be defined using a single constant (that is, ⋆) and finitely many function symbols (that is, Funs(sk(R))). By Lemma 2, the rule set R terminates.</p><formula xml:id="formula_25">Theorem 4. A rule set R terminates if R ∧ terminates.</formula><p>Proof. For an instance I, there is exactly one fact set F in chase(⟨R ∧ , I⟩) since R ∧ is deterministic. To show the theorem, we verify the following claim via induction: Given some chase tree T = ⟨V, E, fct, trg⟩ for ⟨R, I⟩, we have that fct(v) ⊆ F for every v ∈ V . The base case holds since the fact label of the root vertex of T is I, which is a subset of F. Regarding the induction step, consider a non-root vertex c and its parent p in T :</p><p>1. By induction hypothesis: fct(p) ⊆ F.</p><p>2. Since ⟨p, c⟩ ∈ E: trg(c) = ⟨ρ, σ⟩ is loaded for fct(p) and fct(c) = out ℓ (⟨ρ, σ⟩) ∪ fct(p) for some ℓ ≥ 1. 3. By ( <ref type="formula" target="#formula_0">1</ref>) and ( <ref type="formula">2</ref>): ⟨ρ ∧ , σ⟩ is loaded for F. 4. By ( <ref type="formula">3</ref>) and since F is in the result of a (fair) chase tree of ⟨R ∧ , I⟩: out 1 (⟨ρ ∧ , σ⟩) ⊆ F. 5. By the definition of ρ ∧ : out 1 (⟨ρ ∧ , σ⟩) includes all fact sets in out(⟨ρ, σ⟩). In particular, note that out 1 (⟨ρ ∧ , σ⟩) includes out ℓ (⟨ρ, σ⟩). 6. By ( <ref type="formula" target="#formula_0">1</ref>), ( <ref type="formula">2</ref>), ( <ref type="formula">4</ref>), and ( <ref type="formula">5</ref>): the fact set F includes fct(c) and the induction step holds.</p><p>Corollary 5. MFA rule sets terminate.</p><p>Proof. This follows directly from Theorems 3 and 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Disjunctive Model-Faithful Acyclicity</head><p>We first introduce an auxiliary result, which we later use in the proof of Lemma 7:</p><p>Lemma 6. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩. Then, for every v ∈ V , there is a constant mapping g that is the identity on Cons(fct(v)) such that A. g(U(R, t)) ⊆ fct(v) for every t ∈ Terms(fct(v)) and B. g(U(R, trg(u))) ⊆ fct(v) for every ⟨v, u⟩ ∈ E.</p><p>Proof. We first focus on Claim A. Namely, we define the constant mapping g via induction on the structure of the terms that occur in fct(v) and at the same time show that it satisfies Claim A. Regarding the base case, we set g(c) = c for every c ∈ Cons(fct(v)). Note that Claim A holds since U(R, c) = ∅ for every c ∈ Cons. Regarding the induction step, we describe how to define g(t) when t is an R-term of the form f y (⃗ s):</p><p>The proof of the following result is similar to that of Lemma 1. The main difference is the application of Lemmas 7 and 8 to verify that, for every trigger label in a chase tree of a KB ⟨R, I⟩, we have a corresponding trigger in the DMFA(R) construction that is not blocked.</p><p>Lemma 9. For a fact label F in a chase tree of a KB ⟨R, I⟩, we have that g ⋆ (F) ⊆ DMFA(R) where g ⋆ is the constant mapping that maps every constant to ⋆.</p><p>Proof. Consider some chase tree T = ⟨V, E, fct, trg⟩ for the KB ⟨R, I⟩. We verify via structural induction on T that g ⋆ (fct(v)) ⊆ DMFA(R) for every vertex v ∈ V .</p><p>• For r the root vertex of T , we have that g ⋆ (fct(r)) ⊆ I ⋆ since fct(r) is an instance. Therefore, the base case holds since I ⋆ ⊆ DMFA(R). • Regarding the induction step, consider some non-root vertex c and its parent p in T . 1. By induction hypothesis: g ⋆ (fct(p)) ⊆ MFA(R).</p><p>2. Since ⟨p, c⟩ ∈ E: trg(c) = ⟨ρ, σ⟩ is loaded for fct(p) and fct(c) = out ℓ (⟨ρ, σ⟩) ∪ fct(p) for some ℓ ≥ 1. 3. By ( <ref type="formula" target="#formula_0">1</ref>) and ( <ref type="formula">2</ref>): ⟨ρ, g ⋆ • σ⟩ is loaded for DMFA(R). 4. By (2) and the contrapositive of Lemma 7: ⟨ρ, σ⟩ is not blocked. 5. Since all constants are renamed apart in (g ⋆ •σ) r , there exists a constant mapping h with σ = h • (g ⋆ • σ) r . 6. By ( <ref type="formula">4</ref>), ( <ref type="formula">5</ref>), and the contrapositive of Lemma 8:</p><p>⟨ρ, (g ⋆ • σ) r ⟩ is not blocked. 7. By ( <ref type="formula">3</ref>), ( <ref type="formula">6</ref>), and Definition 9: the set DMFA (R) contains out ℓ (⟨ρ, g ⋆ • σ⟩). 8. By ( <ref type="formula" target="#formula_0">1</ref>), (2), and ( <ref type="formula">7</ref></p><formula xml:id="formula_26">): g ⋆ (fct(c)) ⊆ DMFA(R). Note that g ⋆ (out ℓ (⟨ρ, σ⟩)) = out ℓ (⟨ρ, g ⋆ • σ⟩).</formula><p>The proof of the following lemma is analogous to that of Lemma 2; simply plug in Lemma 9 instead of Lemma 1.</p><p>Lemma 20. If DMFA(R) is finite for some deterministic rule set R, then R terminates.</p><p>Proof. We show the contrapositive of the claim. If R is not terminating, then there is a KB of the form ⟨R, I⟩ that admits an infinite skolem chase tree T = ⟨V, E, fct, trg⟩. Since T is infinite and since there is only a finite number of constants in I, the set {g</p><formula xml:id="formula_27">⋆ (fct(v)) | v ∈ V } is infinite. By Lemma 9, DMFA (R) is infinite as well.</formula><p>The proof of the following theorem is analogous to that of Theorem 3; simply plug in Lemma 20 instead of Lemma 2.</p><p>Theorem 10. DMFA rule sets terminate.</p><p>Proof. If a rule set R is DMFA, DMFA(R) does not feature cyclic terms. Hence, DMFA(R) is finite since there is only a finite number of non-cyclic terms that one can construct using a single constant and finitely many function symbols. By Lemma 20, R terminates.</p><p>We only include sketches for Theorems 12 and 13 because their proofs are extremely similar to those of Theorem 5 and  7, respectively, in (?).</p><p>Theorem 12. DMFA-membership is 2EXPTIME-complete.</p><p>Sketch. Membership. The number of terms and facts in DMFA(R) is double-exponentially bounded in the size of R. Hence, for the construction of DMFA(R) at most doubleexponentially many steps are necessary of which each one takes at most double-exponential time.</p><p>Hardness. A deterministic rule set R is MFA iff it is DMFA, since MFA(R) = DMFA(R) because triggers with deterministic rules are never blocked. Therefore, DMFA membership is as hard as MFA membership, which is 2EXP-TIME-hard (?).</p><p>Theorem 13. Deciding query entailment for a KB with an DMFA rule set is coN2EXPTIME-complete. Sketch. Membership. Non-entailment of a query can be decided by non-deterministically guissing a branch in a chase tree that yields a model that does not entail the query. Since the rule set in question is DMFA, there are at most doubly exponentially many terms and facts and hence, query entailment can be decided in coN2EXPTIME.</p><p>Hardness. Hardness is established based on the simulation of a 2EXPTIME Turing machine with weakly acyclic rules by ? (?). We can modify the construction so that nondeterminism is simulated by disjunctive rules. Note that weakly acylic rule sets are DMFA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Proofs for Section 4</head><p>In Section B.1, we show that MFC implies never termination (Theorem 14). This result was originally shown by (?); we show it here again to be self-contained. Then, in Section B.2, we show that DMFC also implies never termination (Theorem 18).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1 Model-Faithful Cyclicity</head><p>Lemma 15. Consider a vertex v in a branch B of a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩, and an R-trigger λ. If λ features a deterministic rule and is loaded for fct(v), then fct(v) ∪ out 1 (λ) ⊆ fct(u) for some u ∈ B.</p><p>Proof. 1. Assume that λ = ⟨ρ, σ⟩ features a deterministic rule and that it is loaded for fct(v). 2. We can show via induction on B that fct(v) ⊆ fct(u) for every vertex u that comes after v in B. 3. By (2): the trigger λ is loaded for the fact label of every vertex that comes after v in B. 4. By Definition 2: the trigger λ is not active for the fact label of some vertex that comes after v in B. 5. By ( <ref type="formula">3</ref>) and ( <ref type="formula">4</ref>): fct(v) ∪ out 1 (λ) ⊆ fct(u) for some u that comes after v in B.</p><p>Theorem 14. MFC rule sets are never terminating.</p><p>Proof. Consider a rule set R that is MFC.</p><p>1. There is some deterministic rule ρ ∈ R such that MFC(R, ρ) features a ρ-cyclic term. Therefore, the rule ρ is generating. 2. By (1): there is a sequence ⟨ρ 1 , σ 1 ⟩, . . . , ⟨ρ n , σ n ⟩ of Rtriggers such that: a. For every 1 ≤ i ≤ n; we have that out 1 (⟨ρ i , σ i ⟩) ⊆ MFC(R), the rule ρ i is a deterministic, and ⟨ρ i , σ i ⟩ is loaded for</p><formula xml:id="formula_28">I ρ ∪ i-1 j=1 out 1 (⟨ρ j , σ j ⟩). b. A ρ-cyclic term occurs in out 1 (⟨ρ n , σ n ⟩). c. No ρ-cyclic term occurs in n-1 j=1 out 1 (⟨ρ j , σ j ⟩). 3. Consider the constant mapping g with g • σ uc = σ n ,</formula><p>where σ uc is the substitution that maps every variable x to a fresh constant c x ; that is, the substitution such that I ρ = body(ρ)σ uc ∪ out 1 (⟨ρ, σ uc ⟩). 4. Let ⟨ρ 1 , σ 1 1 ⟩, . . . , ⟨ρ n , σ 1 n ⟩, ⟨ρ 1 , σ 2 1 ⟩, . . . , ⟨ρ n , σ 2 n ⟩, . . . be the (infinite) sequence of triggers such that σ 1 i = σ i and</p><formula xml:id="formula_29">σ j i = g • σ j-1 i</formula><p>for every 1 ≤ i ≤ n and every j ≥ 2. 5. Let F 1 1 , . . . , F 1 n , F 2 1 , . . . , F 2 n , . . . be the sequence of fact sets such that</p><formula xml:id="formula_30">F 1 1 = I ρ , F j i = out 1 (⟨ρ i-1 , σ j i-1 ⟩)∪F j i-1</formula><p>for every 2 ≤ i ≤ n and every j ≥ 1, and</p><formula xml:id="formula_31">F j 1 = out 1 (⟨ρ n , σ j-1 n ⟩) ∪ F j-1 n</formula><p>for every j ≥ 2. 6. We show that ⟨ρ i , σ j i ⟩ is loaded for F j i for every 1 ≤ i ≤ n and every j ≥ 1 via induction over j. a. By ( <ref type="formula">2</ref>) and ( <ref type="formula">4</ref>): the trigger ⟨ρ i , σ 1 i ⟩ is loaded for F 1 i for every 1 ≤ i ≤ n. Hence, the base case holds. b. Regarding the induction step, assume that ⟨ρ i , σ j-1 i ⟩ is loaded for F j-1 i for some 1 ≤ i ≤ n and some j ≥ 2. Hence, ⟨ρ i , σ j i ⟩ is loaded for F j i since σ j i = g • σ j-1 i by ( <ref type="formula">4</ref>) and g(F j-1 i ) ⊆ F j i by ( <ref type="formula">5</ref>). 7. Consider a branch B in a chase tree T = ⟨V, E, fct, trg⟩ of the KB ⟨R, body(ρ)σ uc ⟩. We show via structural induction on B that, for every 1 ≤ i ≤ n and every j ≥ 1, there is some v ∈ B with F j i ⊆ fct(v). a. For the root vertex r of T (i.e., the first element of B), we have that fct(r) = body(ρ)σ uc and ⟨ρ, σ uc ⟩ is loaded for fct(r). Since ρ is deterministic, there is some v ∈ B such that fct(r)∪out 1 (⟨ρ, σ uc ⟩) ⊆ fct(v) by Lemma 15. Therefore, the base case holds. b. Assume that there is some u ∈ B such that F j i ⊆ fct(u) for some 1 ≤ i ≤ n and some j ≥ 1. Then, ⟨ρ i , σ j i ⟩ is loaded for F j i by ( <ref type="formula">6</ref>) and hence, there is some v ∈ B such that fct(u)∪out 1 (⟨ρ i , σ j i ⟩) ⊆ fct(v) by Lemma 15. Therefore, the induction step holds. 8. Every branch of every chase tree T of the KB ⟨R, body(ρ)σ uc ⟩ features an infinite number of terms by ( <ref type="formula">2</ref>), ( <ref type="formula">4</ref>), (5), and (7). Note that, for every j ≥ 1, we have that |Terms(F j 1 )| &lt; |Terms(F j+1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1</head><p>)| by (2.b) and (2.c). 9. By (8), the rule set R never terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2 Disjunctive Model-Faithful Cyclicity</head><p>Definition 25. For a rule set R, an R-trigger λ, and a term t; let h λ (t) be the R-term defined as follows:</p><formula xml:id="formula_32">• If t occurs in skeleton R (λ), then h λ (t) = t. • Otherwise, h λ (t) = ⋆.</formula><p>Lemma 21. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩, a head-choice hc, an R-trigger λ = ⟨ρ, σ⟩, and some vertex v ∈ branch(T, hc). If out hc (λ) ⊈ fct(v), then h λ (fct(v)) ⊆ O(R, hc, λ).</p><p>Proof. Consider the branch branch(T, hc) = u 1 , u 2 , . . . and the number n ≥ 1 with u n = v. We show the lemma by proving the following claim via induction: If out hc (λ) ̸ ⊆ fct(v), then h λ (fct(u i )) ⊆ O(R, hc, λ) for every 1 ≤ i ≤ n. We first verify the base case:  , hc, λ). e. Consider some fact φ that is in h λ (out hc (⟨ψ, τ ⟩)) but not in out hc (⟨star(ψ), h λ • τ ⟩). Then, there is a functional term f y (⃗ s) in φ with y ∈ head j (ψ) for some j ≥ 1 such that h λ (f y (⃗ s)) = f y (⃗ s). f. By (e): f y (⃗ s) ∈ skeleton R (λ). Therefore, φ is in H(R, λ) and hence in O(R, hc, λ) by Definition 17. g. By (a), (d), (e), and (f): h λ (fct(u i )) ⊆ O(R, hc, λ) and the induction step holds.</p><formula xml:id="formula_33">out hc (⟨star(ψ), h λ • τ ⟩) is a subset of O(R</formula><p>Lemma 16. Consider a chase tree T = ⟨V, E, fct, trg⟩ of a KB ⟨R, I⟩, a head-choice hc, some v ∈ branch(T, hc), and an R-trigger λ. If λ is loaded for fct(v), and it is unblockable for R and hc; then fct(v) ∪ out hc (λ) ⊆ fct(u) for some u ∈ branch(T, hc).</p><p>Proof. 1. Assume that λ = ⟨ρ, σ⟩ is loaded for fct(v), and unblockable for R and hc. 2. Without loss of generality, we assume that ρ is nondeterministic. Note that, if ρ is deterministic, then the lemma follows from Lemma 15. 3. Suppose for a contradiction that out hc (λ) ⊈ fct(u) for every u ∈ branch(T, hc). 4. By (1): the trigger λ is loaded for the fact label of every vertex that comes after v in branch(T, hc). 5. By (4) and Definition 2: there is some vertex w that comes after v in branch(T, hc) such that λ is not active for fct(w). Therefore, out ℓ (λ) ⊆ fct(w) for some ℓ ≥ 1. 6. By (3), (5), and Lemma 21: h λ (fct(w)) ⊆ O(R, hc, λ).</p><p>Hence, h λ (out ℓ (λ)) ⊆ O(R, hc, λ). 7. We show that h λ (out ℓ (λ)) = out ℓ (λ); that is, that head ℓ (ρ) does not feature existential variables: a. Suppose for a contradiction that there is a term t in out ℓ (λ) with h λ (t) ̸ = t.</p><p>b. By Definition 25: h λ (s) = s for every term s that occurs in skeleton R (λ). c. By (a) and (b): there is a term of the form f y (⃗ s) in Terms(out ℓ (λ)) such that y ∈ Vars(head ℓ (ρ)) and h λ (f y (⃗ s)) ̸ = f y (⃗ s). d. By (c) and ( †): ρ is the only rule in R that features y and ℓ = hc(ρ). e. By ( <ref type="formula">5</ref>) and (d): out hc (λ) ⊆ fct(w). f. By (3) and (e): we obtain the desired contradiction. 8. By ( <ref type="formula">6</ref>) and ( <ref type="formula">7</ref>): out ℓ (λ) ⊆ O(R, hc, λ). 9. By ( <ref type="formula">2</ref>) and ( <ref type="formula">8</ref>): λ is not active for O(R, hc, λ) and hence, λ is not unblockable for R and hc, which contradicts (1). 10. By ( <ref type="formula" target="#formula_0">1</ref>), ( <ref type="formula">3</ref>) and ( <ref type="formula">9</ref>): there is a vertex u in branch(T, hc)</p><p>with fct(v) ∪ out hc (λ) ⊆ fct(u).</p><p>Lemma 17. Consider a rule set R, a head-choice hc, an R-trigger ⟨ρ, σ⟩, and a constant mapping g that is reversible for skeleton R (⟨ρ, σ⟩). If ⟨ρ, g • σ⟩ is an R-trigger and ⟨ρ, σ⟩ is unblockable for R and hc, then so is ⟨ρ, g • σ⟩.</p><p>Proof. 1. Assume that ⟨ρ, g • σ⟩ is an R-trigger and λ = ⟨ρ, σ⟩ is unblockable for R and hc. 2. For a term t, let h(t) = s if there is a term s that occurs in skeleton R (λ) with g(s) = t, and h(t) = ⋆ otherwise. The function h is well-defined because g is reversible for the set of all terms in skeleton R (λ). 3. Consider the sets F ′ and G ′ of all facts that can be defined using any predicate and the constants occurring in Cons(skeleton R (λ)) ∪ {⋆} and Cons(skeleton R (⟨ρ, g • σ⟩)) ∪ {⋆}, respectively. Moreover, consider the following fact sets:</p><formula xml:id="formula_34">F = H(R, λ) ∪ F ′ G = H(R, ⟨ρ, g • σ⟩) ∪ G ′</formula><p>4. We proceed to verify that h(G) ⊆ F. First, note that h(G ′ ) ⊆ F since h(c) ∈ Cons(skeleton R (λ)) ∪ {⋆} for every constant c . To show that h(H(R, ⟨ρ, g • σ⟩)) ⊆ F we prove that h(H(R, t)) ⊆ F for every t ∈ Terms(G) via induction over the structure of terms. If t is a constant, then h(H(R, t)) = ∅; hence, the base case trivially holds. Regarding the induction step, consider an R-term t that is of the form f y (⃗ s): a. By ind.-hypothesis: h(H(R, s)) ⊆ F for every s ∈ ⃗ s. b. By ( †): there is a unique rule ψ ∈ R and a unique number ℓ such that y occurs in head ℓ (ψ). Let ⃗ z be the list of existentially quantified variables in head ℓ (ψ). c. Let τ be some substitution with frontier(ψ)τ = ⃗ s.</p><p>Moreover, let H = head ℓ (ψ)τ . d. By Definition 17: H(R, t) = H ∪ s∈⃗ s H(R, s). e. By (a) and (d): we only need to show that h(H) ⊆ F to verify the induction step. In fact, h(H) ⊆ F follows from (g), (h), (i), and (j), which amount to a comprehensive case-by-case analysis. Hence, the proof is complete after showing these.</p><p>e. We have that head ℓ (ρ) does not feature existentially quantified variables. Otherwise, we would necessarily obtain hc(ρ) = ℓ since existentially quantified variables are unique per rule and head-disjunct by ( †). Then, we would obtain a contradiction since we would get out hc (⟨ρ, σ uc ⟩) ⊈ fct(u) and out hc (⟨ρ, σ uc ⟩) ⊆ fct(u) at the same time. (Also see (7) in the proof of Lemma 16). f. By (e): We have that h By (d) </p><formula xml:id="formula_35">λ (out ℓ (⟨ρ, h λ • g • σ uc ⟩)) = out ℓ (⟨ρ, h λ • g • σ uc ⟩). g. By h λ (g(σ uc (frontier(ρ)))) = g(σ uc (frontier(ρ))), we get out ℓ (⟨ρ, h λ • g • σ uc ⟩) = out ℓ (⟨ρ, g • σ uc ⟩). h.</formula><formula xml:id="formula_36">i , h λ • σ i ⟩ is loaded for h λ (I ρ,hc(ρ) ) ∪ i-1 j=1 h λ (out hc (⟨ρ j , h λ • σ j ⟩)) for ev- ery 1 ≤ i ≤ n. c. By (2.b) and (2.c), out hc (⟨ρ i , h λ • σ i ⟩) ̸ = out hc (λ) for every 1 ≤ i ≤ n -1. d. We have out hc (⟨star(ρ i ), h λ • σ i ⟩) ⊆ O(R, hc, λ)</formula><p>for every 1 ≤ i ≤ n -1 by (a), (b), (c), and Definition 17. e. For every</p><formula xml:id="formula_37">1 ≤ i ≤ n -1, every fact φ that occurs in h λ (out hc (⟨ρ i , h λ • σ i ⟩)) \ out hc (⟨star(ρ i ), h λ • σ i ⟩)</formula><p>features a functional term t in skeleton R (λ) that does not occur in the range of h λ • σ i . But then, φ ∈ H(R, t) ⊆ H(R, λ) ⊆ O(R, hc, λ). f. By (d) and (e), for every 1 ≤ i ≤ n -1, we obtain:</p><formula xml:id="formula_38">h λ (out hc (⟨ρ i , h λ • σ i ⟩)) ⊆ O(R, hc, λ) g. Recall that the trigger λ = ⟨ρ n , h λ • σ n ⟩ is loaded for h λ (I ρ,hc(ρ) ) ∪ n-1 j=1 h λ (out hc (⟨ρ j , h λ • σ j ⟩)) by (b). By (f), we conclude that body(ρ n )(h λ • σ n ) = h λ (body(ρ)(g • σ uc )) ⊆ O(R, hc, λ).</formula><p>• Regarding the induction step, we assume that there is some u ∈ V such that F j i ⊆ fct(u) for some 1 ≤ i ≤ n and some j ≥ 1 by induction hypothesis. Then, ⟨ρ i , σ j i ⟩ is loaded for F j i by ( <ref type="formula">6</ref>), and it is unblockable for R and hc by (8). Hence, there is some v ∈ branch(T, hc) such that fct(u)∪out hc (⟨ρ i , σ j i ⟩) ⊆ fct(v) by Lemma 16 and the induction step holds. Note that the element in F 1 1 , . . . , F 1 n , F 2 1 , . . . , F 2 n , . . . right after F j i is the set F j i ∪ out hc (⟨ρ i , σ j i ⟩) by ( <ref type="formula">5</ref>). 10. By (2-5): the sequence F  <ref type="formula">9</ref>) and ( <ref type="formula">10</ref>): any given chase tree ⟨V, E, fct, trg⟩ of the KB ⟨R, body(ρ)σ uc ⟩ features an infinite number of terms. More precisely, the set of all terms in v∈branch(T,hc) fct(v) is infinite. Therefore, the KB ⟨R, body(ρ)σ uc ⟩ does not admit finite chase trees and hence, the rule set R never terminates.</p><p>Theorem 19. (D)MFC-membership is 2EXPTIME-comp.</p><p>Sketch. Membership. The number of terms and facts in DMFC(R, hc, ρ) is double-exponentially bounded in the size of R. Hence, for the construction of DMFC(R) at most double-exponentially many steps are necessary of which each one takes at most double-exponential time (including the unblockability check).</p><p>Hardness. Following the hardness result for MFA (?, Theorem 8), we use a reduction from the problem of conjunctive query entailment over weakly acyclic rule set R (which is called Σ in the original proof). Let R ′ be the weaklyacyclic rule set that results from R such that R ′′ = R ′ ∪ {ρ = R(w, x) ∧ B(x) → ∃y.R(x, y) ∧ A(y)} is MFA iff ⟨R ′ , {A(a)}⟩ ̸ |= B(a) according to the construction by ? In the original proof R ′ corresponds to Σ 3 (?, Theorem 8). In turn, the rule set R ′′ corresponds to Ω (?, Lemma 7). Note that R ′ is weakly-acyclic and thus also MFA and that no atom with R occurs in R ′ .</p><p>For the MFC check, consider MFC(R ′′ , ρ). In MFC(R ′′ , ρ), I ρ already includes R(c x , f y (c x )) and A(f y (c x )). Since R ′ is MFA, there are no cyclic terms in MFC(R ′′ , ρ) that are not ρ-cyclic. Therefore, if ⟨R ′ , {A(a)}⟩ |= B(a), then B(f y (c x )) ∈ MFC(R ′′ , ρ) by Definiton 14. Hence, ⟨ρ, [w/c x , x/f y (c x )]⟩ yields a ρ-cyclic term in A(f y (f y (c x ))) and thus, R ′′ is MFC. Otherwise, if ⟨R ′ , {A(a)}⟩ ̸ |= B(a), then no other trigger for ρ is loaded and thus, MFC(R ′′ , ρ) contains no ρ-cyclic term. For any other rule ψ ∈ R ′ , MFC(R ′′ , ψ) does not contain a ψ-cyclic term because R ′ is MFA and ρ can never be applied during the contruction of MFC(R ′′ , ψ) because the predicate R only occurs in ρ. Hence, R ′′ is not MFC.</p><p>For the DMFC check, the proof is almost the same as for MFC. If ⟨R ′ , {A(a)}⟩ ̸ |= B(a), then R ′′ is not DMFC by the same argument as for MFC. If ⟨R ′ , {A(a)}⟩ |= B(a), we show that all triggers that are applied in the construction of MFC(R ′′ , ρ) can also be applied in the construction of DMFC(R ′′ , hc, ρ) with the head-choice that maps every rule to 1 (since R ′′ is deterministic). That is, we show that conditions (ii), (iv), and (v) from Definition 19 hold. (Condition (iii) has already been shown for MFC.) Since all rules in R ′′ are deterministic, every R ′′ -trigger is unblockable (i.e. (ii)). Since R does not occur in R ′ and B only occurs in a rule head in R ′ , A(f y (c x )) is the only usable fact when starting to compute MFC(R ′′ , hc, ρ). Thus, every trigger used to build MFC(R ′′ , hc, ρ) necessarily features a functional term (that includes f y (c x )) for a frontier variable (i.e. (iv)). By that, we already obtain, if ⟨R ′ , {A(a)}⟩ |= B(a), then B(f y (c x )) ∈ DMFC(R ′′ , hc, ρ). The trigger ⟨ρ, [w/c x , x/f y (c x )]⟩ has an injective substitution (i.e. (v)). Therefore we obtain a ρ-cyclic term in A(f y (f y (c x ))) and thus, R ′′ is DMFC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Additional Evaluation Results</head><p>We include some tables with additional evaluation results. See Section 5 to understand how to read these tables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1 Deterministic Rule Sets</head><p>We present results to verify one of our empirical claims from the introduction. Namely, we aim to show that, using MFA and MFC, one can establish the termination status of most deterministic rule sets. We include the results of our experiments in Table <ref type="table" target="#tab_3">2</ref>. Note the following:</p><p>• Around 99% of the considered rule sets were classified as terminating or non-terminating using MFA and MFC. • Table <ref type="table" target="#tab_3">2</ref>   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 1 .</head><label>1</label><figDesc>Consider the KB ⟨{P (x, y) → ∃z.H(y) ∧ S(y, z), P (x, y) → H(y) ∨ ∃w.P (y, w)}, {P (a, b)}⟩. We can produce a finite chase tree by prioritizing the application of the first rule and an infinite one by delaying it. The former results in: {{P (a, b), H(b), S(b, f z (b))}}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>a. Every term in fct(u 1 ) is a constant since fct(u 1 ) = I. b. By (a) and Definition 25: h λ (t) ∈ Cons(skeleton R (λ))∪ {⋆} for every t ∈ Terms(fct(u 1 )). c. By Definition 17: the set O(R, hc, λ) contains every fact that can be defined using any predicate and constants in Cons(skeleton R (λ)) ∪ {⋆}. d. By (b) and (c): h λ (fct(u 1 )) ⊆ O(R, hc, λ) and the base case holds. Regarding the induction step, consider some i ≥ 2: a. By induction hypothesis: h λ (fct(u i-1 )) ⊆ O(R, hc, λ). b. By (a): ⟨star(ψ), h λ • τ ⟩ is loaded for O(R, hc, λ) where trg(u i ) = ⟨ψ, τ ⟩. c. Since out hc (λ) ⊈ fct(v): out hc (trg(u i )) ̸ = out hc (λ). d. By (b), (c), and Definition 17:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Skolem Chase Termination: Non-Deterministic Rule Sets Ontology Repository (OXFD), 9 the dataset of the OWL Reasoner Evaluation 2015 (ORE15), 10 and the Manchester OWL Corpus (MOWL). 11 Here, we only consider rule sets with at least one disjunctive and one generating rule. Deterministic rule sets are covered largely by MFA and MFC already; see Section C for results about these rule sets.</figDesc><table><row><cell></cell><cell>#∃</cell><cell cols="2"># tot. # fin.</cell><cell>MFA</cell><cell>DMFA</cell><cell>DMFA 2</cell><cell>MFC</cell><cell>DMFC s</cell></row><row><cell>OXFD</cell><cell>1-19 20-99 100+ 1+</cell><cell>37 18 82 137</cell><cell>36 17 26 79</cell><cell>21 3 4 28 (35%)</cell><cell>28 3 6 37 (46%)</cell><cell>28 3 6 37 (46%)</cell><cell>4 10 14 28 (35%)</cell><cell>8 14 19 41 (51%)</cell></row><row><cell>ORE15</cell><cell cols="2">1-19 20-99 100-999 278 103 119 1-999 500</cell><cell>98 105 219 422</cell><cell cols="5">51 32 5 88 (20%) 105 (24%) 220 (52%) 161 (38%) 200 (47%) 66 66 18 31 33 35 54 69 6 119 89 100</cell></row><row><cell>MOWL</cell><cell cols="8">1-19 20-99 100-299 448 1361 1283 894 740 254 1-299 2703 2277 805 (35%) 864 (37%) 964 (42%) 577 (25%) 1268 (55%) 676 725 732 173 515 104 114 121 301 610 25 25 111 103 143</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>, (f), and (g), out ℓ (⟨ρ, g • σ uc ⟩) ⊆ O(R, hc, λ), i.e. λ is not active for O(R, hc, λ) and thus λ is not unblockable for R and hc. It remains to show ( ‡), i.e. that h λ (body(ρ)(g•σ uc )) ⊆ O(R, hc, λ). For this, we use the triggers from (2): a. By Definition 17, we have that h λ (I ρ,hc(ρ) ) ⊆ O(R, hc, λ). More precicely, h λ (out hc (⟨ρ, σ uc ⟩)) ⊆ H(R, λ) and h λ (body(ρ)σ uc ) is contained in the set of all facts that can be defined using any predicate and constants from Cons(skeleton R (λ)) ∪ {⋆}. b.By (2.a), the trigger ⟨ρ</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 2 :</head><label>2</label><figDesc>only features results for deterministic rule sets. • We include separate results for MFC and DMFC s because this notions do not coincide in theory. However, for every rule set R considered in this evaluation, we have that R is MFC if and only if it is DMFC s .C.2 Non-Guarded Rule SetsAs stated in Section 6, we can decide termination for guarded deterministic rule sets (?). It is possible that this results also extends to guarded rule sets with disjunctions. Therefore, we include separate results for non-guarded rule sets in Table3and observe that these results are rather similar percentage-wise to those from Table1. Skolem Chase Termination: Deterministic Rule Sets</figDesc><table><row><cell></cell><cell></cell><cell>#∃</cell><cell></cell><cell cols="4"># tot. # fin. MFA/DMFA</cell><cell cols="2">DMFA 2</cell><cell>MFC</cell><cell>DMFC s</cell></row><row><cell></cell><cell>OXFD</cell><cell cols="2">1-19 20-99 100+ 1+</cell><cell>58 27 251 336</cell><cell>58 27 89 174</cell><cell cols="2">51 23 73 147 (84%)</cell><cell cols="2">51 23 73 147 (84%)</cell><cell>3 4 16 23 (13%)</cell><cell>3 4 16 23 (13%)</cell></row><row><cell></cell><cell>ORE15</cell><cell cols="3">1-19 20-99 100-999 230 86 109 1-999 425</cell><cell>86 109 176 371</cell><cell cols="2">80 88 143 311 (83%)</cell><cell cols="2">80 88 143 311 (83%)</cell><cell>6 21 33 60 (16%)</cell><cell>6 21 33 60 (16%)</cell></row><row><cell></cell><cell>MOWL</cell><cell cols="4">1-19 20-99 100-299 185 1139 1125 269 266 149 1-299 1593 1540</cell><cell cols="4">790 216 114 1120 (72%) 1125 (73%) 414 (26%) 414 (26%) 794 330 330 217 49 49 114 35 35</cell></row><row><cell></cell><cell></cell><cell>#∃</cell><cell cols="2"># tot. # fin.</cell><cell></cell><cell>MFA</cell><cell cols="2">DMFA</cell><cell>DMFA 2</cell><cell>MFC</cell><cell>DMFC s</cell></row><row><cell>OXFD</cell><cell cols="2">1-19 20-99 100+ 1+</cell><cell>12 13 70 95</cell><cell>12 12 19 43</cell><cell cols="2">4 2 4 10 (23%)</cell><cell cols="2">6 2 4 12 (27%)</cell><cell>6 2 4 12 (27%)</cell><cell>4 8 10 22 (51%)</cell><cell>6 10 15 31 (72%)</cell></row><row><cell>ORE15</cell><cell cols="3">1-19 20-99 100-999 261 62 71 1-999 394</cell><cell>59 63 209 331</cell><cell cols="2">32 22 4 58 (17%)</cell><cell cols="3">40 23 4 67 (20%) 182 (54%) 127 (38%) 148 (44%) 40 10 18 25 34 38 117 83 92</cell></row><row><cell>MOWL</cell><cell cols="9">1-19 20-99 100-299 389 592 584 1-299 1565 1265 374 (29%) 416 (32%) 510 (40%) 381 (30%) 744 (58%) 546 306 343 345 87 192 498 57 62 68 206 428 221 11 11 97 88 124</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 :</head><label>3</label><figDesc>Skolem Chase Termination: Non-Guarded Non-Deterministic Rule Sets</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>MFA was originally introduced in (?) as a very general skolem acyclicity notion for deterministic rule sets.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>(?) have introduced a very similar notion for the restricted chase.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>Note that g •0 = idTerms, g •1 = g, g •2 = g • g, and so on.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p>Again, (?) introduced a very similar notion for the restricted chase.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>https://doi.org/10.5281/zenodo.7375461 ?</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>Lukas is funded by <rs type="funder">Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)</rs> in project <rs type="grantNumber">389792660</rs> (<rs type="grantNumber">TRR 248</rs>, <rs type="funder">Center for Perspicuous Systems)</rs>, by the <rs type="funder">Bundesministerium für Bildung und Forschung (BMBF, Federal Ministry of Education and Research)</rs> under <rs type="funder">European ITEA</rs> project <rs type="grantNumber">01IS21084</rs> (<rs type="projectName">InnoSale</rs>, <rs type="projectName">Innovating Sales and Planning of Complex Industrial Products Exploiting Artificial Intelligence</rs>), by <rs type="funder">BMBF</rs> and <rs type="funder">DAAD (German Academic Exchange Service)</rs> in project <rs type="grantNumber">57616814</rs> (<rs type="projectName">SECAI</rs>, <rs type="projectName">School of Embedded</rs> <rs type="funder">and Composite AI)</rs>, and by the <rs type="funder">Center for Advancing Electronics Dresden (cfaed)</rs>.</p><p>David is funded by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_5F4cYRk">
					<idno type="grant-number">389792660</idno>
				</org>
				<org type="funding" xml:id="_XA2sGev">
					<idno type="grant-number">TRR 248</idno>
				</org>
				<org type="funded-project" xml:id="_NQVpSBM">
					<idno type="grant-number">01IS21084</idno>
					<orgName type="project" subtype="full">InnoSale</orgName>
				</org>
				<org type="funded-project" xml:id="_78ENBdY">
					<orgName type="project" subtype="full">Innovating Sales and Planning of Complex Industrial Products Exploiting Artificial Intelligence</orgName>
				</org>
				<org type="funded-project" xml:id="_P3Rypmw">
					<idno type="grant-number">57616814</idno>
					<orgName type="project" subtype="full">SECAI</orgName>
				</org>
				<org type="funded-project" xml:id="_BE68ttN">
					<orgName type="project" subtype="full">School of Embedded</orgName>
				</org>
				<org type="funded-project" xml:id="_YHS4bmT">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>f. We observe that, if h(f z (⃗ s)) is functional for some z ∈ ⃗ z, then h(f z (⃗ s)) = f z (h(⃗ s)) by (2). Thus, for every z ′ ∈ ⃗ z, the term f z ′ (h(⃗ s)) occurs in head ℓ (ψ)(h • τ ) which is contained in H(R, λ). Therefore, we find g(f z ′ (h(⃗ s))) = f z ′ (⃗ s) and, by (2), h(f z ′ (⃗ s)) = f z ′ (h(⃗ s ′ )).</p><p>In short: If h(f z (⃗ s)) is a functional term for some z ∈ ⃗ z, then h(f z ′ (⃗ s)) = f z ′ (h(⃗ s)) for every z ′ ∈ ⃗ z. g. We show that h(H) ⊆ F if h(t) is a functional term.</p><p>In this case, h(H) = h(head ℓ (ψ)τ ) = head ℓ (ψ)(h • τ ) ⊆ F follows directly from (f). h. We show that h(H) ⊆ F if h(t) ∈ Cons \ {⋆}.</p><p>• If h(t) ∈ Cons \ {⋆}, then h(f z (⃗ s)) is a constant for every z ∈ ⃗ z. Note that otherwise h(t) would be functional by (f). • Furthermore, h(s) is also a constant (possibly ⋆) for every s ∈ ⃗ s by the definition of h and since g is reversible for skeleton R (λ). • Then, h(H) ⊆ F ′ and hence h(H) ⊆ F. Note that</p><p>would be a functional term. Summing up, t ′ ̸ = t is a subterm of t such that h(t ′ ) is functional. • At the same time, for t to occur in skeleton R (⟨ρ, g • σ⟩), there needs to be a constant c that occurs in the range of σ restricted to frontier variables of ρ such that t occurs in Terms(H(R, g(c))). • Suppose for a contradiction that no such constant exists, i.e. there exists a functional term u that occurs in the range of σ restricted to frontier variables of ρ such that t occurs in Terms(H(R, g(u))) but t does not occur in Terms(H(R, g(u ′ ))) for any subterm u ′ of u with u ′ ̸ = u. • Since h(t) is not functional, t must occur in Terms(H(R, q)) for a subterm q of g(u) with q ̸ = g(u) by (f). • But then, there exists a subterm u ′ of u with u ′ ̸ = u that occurs in the range of σ restricted to frontier variables of ρ with g(u ′ ) = q since u is functional. Since t occurs in Terms(H(R, g(u ′ ))), we obtain the desired contradiction. • Let g(c) be of the form f x ( ⃗ w). We have that ⃗ s is contained in the subterms of ⃗ w. But then, t ′ occurs in ⃗ w, which contradicts the reversibility of g. 5. We show that h(O(R, hc, ⟨ρ, g • σ⟩)) ⊆ O(R, hc, λ).</p><p>Consider a list ⟨ψ 1 , τ 1 ⟩, . . . , ⟨ψ m , τ m ⟩ of triggers such that all of the following hold:</p><p>follows immediately from (4). Assume for the induction hypothesis that h(G ∪ i j=1 out hc (⟨star(ψ j ), τ j ⟩)) is a subset of O(R, hc, λ) for some i ≥ 1. To verify the induction step we only need to show that h(out hc (⟨star(ψ i+1 ),</p><p>out hc (λ) results in a contradiction. In fact, if this were the case, then:</p><p>Note that the last equality statement above contradicts the definition of the list ⟨ψ 1 , τ 1 ⟩, . . . , ⟨ψ m , τ m ⟩. Moreover, g • h can be regarded as the identity mapping in the last step since ⋆ does not occur in out hc (⟨ψ i+1 , h • τ i+1 ⟩). d. By (a), (b), and (c): the induction step holds. 6. If ρ is deterministic; then ⟨ρ, g • σ⟩ is unblockable for R and hc by Definition 17 and the lemma holds. Henceforth, we assume that ρ is of the form β → n i=1 ∃⃗ y i .η i with n ≥ 2. 7. Suppose for a contradiction that ⟨ρ, g • σ⟩ is not unblockable for R and hc. 8. By ( <ref type="formula">6</ref>) and ( <ref type="formula">7</ref>): the trigger ⟨ρ, g • σ⟩ is not active for O(R, hc, ⟨ρ, g • σ⟩). That is, there is some 1 ≤ ℓ ≤ n such that out ℓ (⟨ρ, g • σ⟩) ⊆ O(R, hc, ⟨ρ, g • σ⟩). 9. By ( <ref type="formula">5</ref>) and ( <ref type="formula">8</ref>): we have that h(out ℓ (⟨ρ, g • σ⟩)) ⊆ O(R, hc, λ). Therefore, out ℓ (⟨ρ, σ⟩) ⊆ O(R, hc, λ) by ( <ref type="formula">2</ref>) and ⟨ρ, σ⟩ is not active for O(R, hc, λ). 10. By (9): ⟨ρ, σ⟩ is not unblockable for R and hc. 11. We obtain a contradiction from ( <ref type="formula">1</ref>) and (10) so our supposition in (7) does not hold and ⟨ρ, g • σ⟩ is unblockable.</p><p>Theorem 18. DMFC rule sets are never terminating.</p><p>Proof. Consider a rule set R that is DMFC.</p><p>1. There is some ρ ∈ R, some head-choice hc, and some ρ-cyclic term t such that t ∈ Terms(DMFC(R, hc, ρ)). 2. By (1) and Definitions 19: there is a (finite) list ⟨ρ 1 , σ 1 ⟩, . . . , ⟨ρ n , σ n ⟩ of triggers such that: a. For every</p><p>j=1 out(⟨ρ j , σ j ⟩), ⟨ρ i , σ i ⟩ is unblockable for R and hc, and σ i (x) is functional for some x ∈ frontier(ρ i ). b. A ρ-cyclic term occurs in out hc (⟨ρ n , σ n ⟩). Hence, σ n is injective (since</p><p>3. Consider the constant mapping g such that g • σ uc = σ n , where σ uc is the substitution introduced in Definition 12 which maps every variable x to a fresh constant c x . By (2.b) and Definition 19, the mapping g is injective. 4. Let ⟨ρ 1 , σ 1 1 ⟩, . . . , ⟨ρ n , σ 1 n ⟩, ⟨ρ 1 , σ 2 1 ⟩, . . . , ⟨ρ n , σ 2 n ⟩, . . . be the sequence of triggers such that σ 1 i = σ i and σ j i = g • σ j-1 i for every 1 ≤ i ≤ n and every j ≥ 2. 5. Let F 1 1 , . . . , F 1 n , F 2 1 , . . . , F 2 n , . . . be the sequence of fact sets such that F 1 1 = I ρ,hc(ρ) , F j i = out hc (⟨ρ i-1 , σ j i-1 ⟩)∪ F j i-1 for every 2 ≤ i ≤ n and every j ≥ 1, and</p><p>for every j ≥ 2. 6. One can show that ⟨ρ i , σ j i ⟩ is loaded for F j i for every 1 ≤ i ≤ n and every j ≥ 1 with an analogous argument to the one used to prove (6) in the proof of Theorem 14. 7. By (7.c) and ( <ref type="formula">7</ref>.d): we show that the mapping g is reversible for Terms( j≥1 F j n ). Hence, g is reversible for skeleton R (⟨ρ i , σ j i ⟩) for every 1 ≤ i ≤ n and j ≥ 1. a. By (2.c): for every constant c that occurs in j≥1 F j n , the term g(c) does not feature nested function symbols from sk(ρ). 12 b. We show that, for any functional term t occurring in j≥1 F j n , the term g(t) features nested function symbols from sk(ρ). i. By (iv) in Definition 19, one can show that every functional term t occurring in j≥1 F j n has a subterm of the form f (⃗ c) such that f occurs in sk(ρ) and ⃗ c = σ uc (frontier(ρ)). In fact, one can prove this claim via induction on the sequence By (2.b): g(c) features a function symbol from sk(ρ)</p><p>for some c ∈ σ uc (frontier(ρ)). Otherwise, there would not be a ρ-cyclic term in out hc (⟨ρ n , σ n ⟩). iii. By (i) and (ii): for every functional term t occurring in j≥1 F j n , there is a term of the form f (g(⃗ c)) ∈ subterms(g(t)) with f ∈ sk(ρ) and ⃗ c = σ uc (frontier(ρ)). Note that f (g(⃗ c)) features nested function symbols from sk(ρ). c. We show that g(t) ̸ = g(s) for every t, s ∈ Terms(F) with t ̸ = s via structural induction on t. • Regarding the base case, we consider two cases: If t and s are constants, then g(t) ̸ = g(s) since g is injective by ( <ref type="formula">3</ref>). If t is a constant and s is functional, then g(s) features nested function symbols from sk(ρ) by (b) and g(t) does not by (a). • Regarding the induction step, if s is a constant, the argument is analogous to the second base case. We distinguish two remaining cases: If t and s are functional terms of the form f ( ⃗ t) and h(⃗ s), respectively, with f ̸ = h; then g(t) ̸ = g(s) since g(t) = f (g( ⃗ t)) and g(s) = h(g(⃗ s)). If t and s are functional terms of the form f (t 1 , . . . , t n ) and f (s 1 , . . . , s n ), respectively; then t i ̸ = s i for some 1 ≤ i ≤ n since 12 Consider a rule ρ = A(x) → ∃y, z.R(x, y) ∧ S(x, z). Then, the term fy(fz(c)) features nested function symbols from sk(ρ) while fw(fy(d), fz(c)) does not. t ̸ = s, g(t i ) ̸ = g(s i ) by induction hypothesis, and g(t) ̸ = g(s) since g(t) = f (g(t 1 ), . . . , g(t n )) and g(s) = f (g(s 1 ), . . . , g(s n )). d. Consider a constant c occurring in j≥1 F j n and some s ∈ subterms(g(c)). We show that there is no functional term u occurring in j≥1 F j n with g(u) = s. i. Suppose for a contradiction that there is a functional term u in j≥1 F j n with g(u) = s. ii. By (a): g(c) does not feature nested function symbols from sk(ρ). Hence, s does not feature them either since s ∈ subterms(g(c)). iii. By (i) and (b): the term g(u) features nested function symbols from sk(ρ). iv. By (i-iii): contradiction! 8. We show that ⟨ρ i , σ j i ⟩ is unblockable for R and hc for every 1 ≤ i ≤ n and every j ≥ 1 via induction over j.</p><p>• By ( <ref type="formula">2</ref>) and ( <ref type="formula">4</ref>): ⟨ρ i , σ 1 i ⟩ is unblockable for R and hc for every 1 ≤ i ≤ n. Hence, the base case holds.</p><p>• Regarding the induction step, consider some 1 ≤ i ≤ n, some j ≥ 2, and the trigger ⟨ρ i , σ j i ⟩. By induction hypothesis, the trigger ⟨ρ i , σ j-1 i ⟩ is unblockable for R and hc. Hence, ⟨ρ i , g • σ j-1 i ⟩ is also unblockable by (7) and Lemma 17, and the induction step holds since ⟨ρ i , g • σ j-1 i ⟩ = ⟨ρ i , σ j i ⟩ by ( <ref type="formula">4</ref>). 9. Consider some chase tree T = ⟨V, E, fct, trg⟩ of the KB ⟨R, body(ρ)σ uc ⟩. We show via induction on the structure of T that, for every 1 ≤ i ≤ n and every j ≥ 1, there is some v ∈ branch(T, hc) with F j i ⊆ fct(v). • For the root vertex r of T , we have that fct(r) = body(ρ)σ uc and ⟨ρ, σ uc ⟩ is loaded for fct(r). We show that fct(r) ∪ out hc (⟨ρ, σ uc ⟩) ⊆ fct(u) for some vertex u in branch(T, hc) by a similar argument as for Lemmas 16 and 21. Suppose for a contradiction that there is a vertex u in branch(T, hc) such that out hc (⟨ρ, σ uc ⟩) ⊈ fct(u) and ⟨ρ, σ uc ⟩ is not active for fct(u). That is, out ℓ (⟨ρ, σ uc ⟩) ⊆ fct(u) for some ℓ (such that out hc (⟨ρ, σ uc ⟩) ⊈ out ℓ (⟨ρ, σ uc ⟩)). Consider the trigger λ = ⟨ρ, g • σ uc ⟩ = ⟨ρ n , σ n ⟩. Assume for now that h λ (body(ρ)(g • σ uc )) ⊆ O(R, hc, λ) ( ‡). We show out ℓ (⟨ρ, g • σ uc ⟩) ⊆ O(R, hc, λ), i.e. that λ = ⟨ρ, g • σ uc ⟩ is not unblockable; contradicting (2): a. Consider the path w 0 , . . . , w m in T with w 0 = r and w m = u. We have that out hc (⟨ψ i , τ i ⟩) ̸ = out hc (⟨ρ, σ uc ⟩) where ⟨ψ i , τ i ⟩ = trg(w i ) for every 1 ≤ i ≤ m. b. Consider the triggers ⟨ψ i , h λ • g • τ i ⟩ for all 1 ≤ i ≤ m. By (a): For each 1 ≤ i ≤ m, ⟨ψ i , h λ • g • τ i ⟩ is loaded for h λ (body(ρ)(g • σ uc )) ∪ </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Extending Acyclicity Notions for Existential Rules</title>
		<author>
			<persName><forename type="first">J</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Garreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Czech Republic -Including Prestigious Applications of Intelligent Systems</title>
		<title level="s">Frontiers in Artificial Intelligence and Applications</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Schaub</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Friedrich</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">B</forename><surname>O'sullivan</surname></persName>
		</editor>
		<meeting><address><addrLine>PAIS</addrLine></address></meeting>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="2014">2014. 2014. 2014</date>
			<biblScope unit="volume">263</biblScope>
			<biblScope unit="page" from="39" to="44" />
		</imprint>
	</monogr>
	<note>ECAI 2014 -21st European Conference on Artificial Intelligence</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Implication Problem for Data Dependencies</title>
		<author>
			<persName><forename type="first">C</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming, 8th Colloquium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">S</forename><surname>Even</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">O</forename><surname>Kariv</surname></persName>
		</editor>
		<meeting><address><addrLine>Israel</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1981">1981. 1981</date>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="73" to="85" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Guarded-Based Disjunctive Tuple-Generating Dependencies</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Manna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Morak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Chase Termination for Guarded Existential Rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Calautti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th ACM Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Milo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Calvanese</surname></persName>
		</editor>
		<meeting>the 34th ACM Symposium on Principles of Database Systems<address><addrLine>PODS; Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015. 2015. 2015</date>
			<biblScope unit="page" from="91" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Query Answering under Non-guarded Rules in Datalog+</title>
		<author>
			<persName><forename type="first">A</forename><surname>Calì</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pieris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Web Reasoning and Rule Systems -4th International Conference</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Hitzler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Lukasiewicz</surname></persName>
		</editor>
		<meeting><address><addrLine>RR; Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">2010. 2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
	</analytic>
	<monogr>
		<title level="m">Proceedings</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting>null</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">6333</biblScope>
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Restricted Chase (Non)Termination for Existential Rules with Disjunctions</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Joint Conference on Artificial Intelligence, IJCAI 2017</title>
		<editor>
			<persName><forename type="first">C</forename><surname>Sierra</surname></persName>
		</editor>
		<meeting>the 26th International Joint Conference on Artificial Intelligence, IJCAI 2017<address><addrLine>Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
			<biblScope unit="page" from="922" to="928" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Checking Chase Termination over Ontologies of Existential Rules with Equality</title>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Urbani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 34th AAAI Conference on Artificial Intelligence, AAAI 2020, The Thirty-Second Innovative Applications of Artificial Intelligence Conference, IAAI 2020, The Tenth AAAI Symposium on Educational Advances in Artificial Intelligence, EAAI 2020</title>
		<meeting><address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="page" from="2758" to="2765" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Acyclicity No-tions for Existential Rules and Their Application to Query Answering in Ontologies</title>
		<author>
			<persName><forename type="first">Cuenca</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kupke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Magka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="741" to="808" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">General Acyclicity and Cyclicity Notions for the Disjunctive Skolem Chase -Evaluation Material</title>
		<author>
			<persName><forename type="first">L</forename><surname>Gerlach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carral</surname></persName>
		</author>
		<idno type="DOI">10.5281/zenodo.7375461</idno>
		<ptr target="https://doi.org/10.5281/zenodo.7375461" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">All-Instances Termination of Chase is Undecidable</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gogacz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Marcinkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Fraigniaud</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">T</forename><surname>Husfeldt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Koutsoupias</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>41st Int</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<author>
			<persName><surname>Colloquium</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP 2014</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>Denmark</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8573</biblScope>
			<biblScope unit="page" from="293" to="304" />
		</imprint>
	</monogr>
	<note>Proc., Part II</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Anatomy of the Chase. Fundam</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Onet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Informaticae</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Restricted Chase Termination for Existential Rules: A Hierarchical Approach and Experimentation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Karimi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>You</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Th. Pract. Log. Program</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="4" to="50" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Extending Decidable Existential Rules by Joining Acyclicity and Guardedness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting><address><addrLine>Spain</addrLine></address></meeting>
		<imprint>
			<publisher>IJCAI/AAAI</publisher>
			<date type="published" when="2011">2011. 2011</date>
			<biblScope unit="page" from="963" to="968" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Single Approach to Decide Chase Termination on Linear Existential Rules</title>
		<author>
			<persName><forename type="first">M</forename><surname>Leclère</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Thomazo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ulliana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd International Conference on Database Theory, ICDT 2019</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Calautti</surname></persName>
		</editor>
		<meeting><address><addrLine>Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Generalized schema-mappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">B</forename><surname>Marnette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</editor>
		<meeting>the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems<address><addrLine>PODS; USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009. 2009. 2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The Manchester OWL Repository: System Description</title>
		<author>
			<persName><forename type="first">N</forename><surname>Matentzoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Sattler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<ptr target="CEUR-WS.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ISWC 2014 Posters &amp; Demonstrations Track a track within the 13th International Semantic Web Conference, ISWC 2014</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Horridge</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Rospocher</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Ossenbruggen</surname></persName>
		</editor>
		<meeting>the ISWC 2014 Posters &amp; Demonstrations Track a track within the 13th International Semantic Web Conference, ISWC 2014<address><addrLine>Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">1272</biblScope>
			<biblScope unit="page" from="285" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The OWL Reasoner Evaluation (ORE) 2015 Resources</title>
		<author>
			<persName><forename type="first">B</forename><surname>Parsia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Matentzoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Gonc ¸alves</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Glimm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Steigmiller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Semantic Web -ISWC 2016 -15th International Semantic Web Conference</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Groth</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">E</forename><surname>Simperl</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">J G</forename><surname>Gray</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Sabou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Krötzsch</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Lécué</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Flöck</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Y</forename><surname>Gil</surname></persName>
		</editor>
		<meeting><address><addrLine>Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016. 2016. 9982</date>
			<biblScope unit="page" from="159" to="167" />
		</imprint>
	</monogr>
	<note>Proc, Part II</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Existential Rule Languages with Finite Chase: Complexity and Expressiveness</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>You</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Bonet</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Koenig</surname></persName>
		</editor>
		<meeting>the Twenty-Ninth AAAI Conference on Artificial Intelligence<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="1678" to="1685" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m">By induction hypothesis: we have that g(U(R, s)) ⊆ fct(v) for every R-term s ∈ ⃗ s</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m">Consider the rule ρ = β</title>
		<imprint/>
	</monogr>
	<note>⃗ x</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">and Assumption ( †) in Section 2, this is the only rule in R that features the variable</title>
		<author>
			<persName><forename type="first">R</forename><surname>By</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">More precisely, y ∈ ⃗ y ℓ and y / ∈ ⃗ y i for every i ∈ {1</title>
		<imprint>
			<date>2</date>
		</imprint>
	</monogr>
	<note>n} \ {ℓ}</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">By</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
		</imprint>
	</monogr>
	<note>σ(⃗ x) = ⃗ s</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m">Consider the substitution τ such that U(R, t) = βτ ∪ out ℓ (⟨ρ, τ ⟩) ∪ s∈⃗ s U(R, s) and the list ⃗ c of (fresh) constants such that τ ( ⃗ w) = ⃗ c. We extend g so that g(⃗ c) = σ( ⃗ w). Note that we can extend the function g in this manner without breaking its</title>
		<imprint/>
	</monogr>
	<note>functionality&quot; because the constants in ⃗ c are fresh</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">By (2), (4), and (5): g(βτ ) = βσ, g(</title>
		<imprint/>
	</monogr>
	<note>out ℓ (⟨ρ, τ ⟩)) = out ℓ (⟨ρ, σ⟩), and βσ ∪ out ℓ (⟨ρ, σ⟩) ⊆ fct(u)</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">2.a): βσ ∪ out ℓ (⟨ρ, σ⟩) ⊆ fct</title>
		<author>
			<persName><surname>By</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">If a trigger λ is blocked for R, then λ does not occur as a trigger label in any chase tree of a KB with R</title>
		<imprint/>
	</monogr>
	<note>trg⟩ be a tree of a KB ⟨R, I⟩</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Assume that λ is blocked for R</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Suppose for a contradiction that there is some (non-root) vertex c ∈ V with trg(c) = λ. Furthermore, let</title>
		<imprint/>
	</monogr>
	<note>p be the parent of c in T . 3. By (2): λ is active for fct(p)</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m">Lemma 6: there is a constant mapping g such that g(U(R, λ)) is a subset of fct(p) and g is the identity over Cons</title>
		<imprint/>
	</monogr>
	<note>By (2. fct(p</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">By (1) and Definition 8: λ is not active for U(R, λ). 6. By (4) and (5): λ is not active for g(U(R, λ)) and hence, it is not active for fct</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">contradiction! Lemma</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">For a trigger ⟨ρ, σ⟩, a rule set R, and a constant mapping g; if ⟨ρ, σ r ⟩ is blocked for R, then so is ⟨ρ</title>
		<imprint/>
	</monogr>
	<note>σ r ⟩. Proof</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Assume that ⟨ρ, σ r ⟩ is blocked for R. 2. By (1) and Definition 8: ⟨ρ, σ r ⟩ is not active for U(R, ⟨ρ, σ r ⟩)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">By (2): ⟨ρ, g • σ r ⟩ is not active for g(U(R, ⟨ρ, σ r ⟩)). 4. By Definition 8: g(U(R, ⟨ρ, σ r ⟩)) ⊆ U(R, ⟨ρ, g • σ r ⟩). 5. By (3) and</title>
	</analytic>
	<monogr>
		<title level="m">is not active for U(R, ⟨ρ, g • σ r ⟩) and hence it is blocked for R</title>
		<imprint/>
	</monogr>
	<note>(4): ⟨ρ, g • σ r ⟩</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
