<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Generalized Bundled Fragments for First-Order Modal Logic</title>
				<funder ref="#_mYUPv5S">
					<orgName type="full">NSSF</orgName>
				</funder>
				<funder ref="#_QctyRKj">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder>
					<orgName type="full">French government</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Mo</forename><surname>Liu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Anantha</forename><surname>Padmanabha</surname></persName>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>Ramanujam</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Yanjing</forename><surname>Wang</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">LORIA</orgName>
								<orgName type="institution">Unviersity of Lorraine</orgName>
								<address>
									<settlement>Nancy</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">DI ENS</orgName>
								<orgName type="institution" key="instit1">École Normale Supérieure</orgName>
								<orgName type="institution" key="instit2">Université PSL</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<orgName type="institution" key="instit4">Inria</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Institute of Mathematical Sciences</orgName>
								<orgName type="institution">HBNI</orgName>
								<address>
									<settlement>Chennai</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Retired) Azim Premji University</orgName>
								<address>
									<settlement>Bengaluru (Visiting)</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">Department of Philosophy</orgName>
								<orgName type="institution">Peking University</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="department" key="dep1">für Informatik</orgName>
								<orgName type="department" key="dep2">Dagstuhl Publishing</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Generalized Bundled Fragments for First-Order Modal Logic</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C92BD3B820BC5CF4E7F55FFAF4E076E9</idno>
					<idno type="DOI">10.4230/LIPIcs.MFCS.2022.70</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:48+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>2012 ACM Subject Classification Theory of computation → Modal and temporal logics; Theory of computation → Logic bundled fragments</term>
					<term>first-order modal logic</term>
					<term>decidability</term>
					<term>tableaux Digital Object Identifier 10.4230/LIPIcs.MFCS.2022.70</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>When we bundle quantifiers and modalities together (as in ∃x□, ♢∀x etc.) in first-order modal logic (FOML), we get new logical operators whose combinations produce interesting bundled fragments of FOML. It is well-known that finding decidable fragments of FOML is hard, but existing work shows that certain bundled fragments are decidable [14], without any restriction on the arity of predicates, the number of variables, or the modal scope. In this paper, we explore generalized bundles such as ∀x∀y□, ∀x∃y♢ etc., and map the terrain with regard to decidability, presenting both decidability and undecidability results. In particular, we propose the loosely bundled fragment, which is decidable over increasing domains and encompasses all known decidable bundled fragments.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>While propositional modal logic (ML) has had extensive applications in system verification and artificial intelligence, and first-order logic (FOL) in finite model theory and database theory, first-order modal logic (FOML) has been studied much less, as it seems to combine the worst of both computationally, leading to undecidability. FOML is a natural specification language for state transition systems where states are given by first-order descriptions of computational domains, with applicability in the realm of database updates, in the control of infinite-state systems, networks with unbounded parallelism and cryptographic protocols. This motivates the study of decidable fragments of FOML. This is a challenge, since even the two-variable fragment of FOML with one unary predicate is undecidable over almost all useful model classes <ref type="bibr" target="#b14">[15]</ref>. This situation is to be contrasted against the robust decidability of propositional modal logics ( <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b6">7]</ref>), and the many decidable fragments of first-order logic ( <ref type="bibr" target="#b3">[4]</ref>).</p><p>Despite such discouragement, there have been a few successful attempts: for instance, the monodic restriction, mandating only one free variable in the scope of any modal subformula, yields decidability when combined with a decidable fragment of FOL ( <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b18">19]</ref>). This idea, arising originally from description logics (cf. <ref type="bibr" target="#b8">[9]</ref>) has led to applications in temporal and epistemic logics ( <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b9">[10]</ref>, <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>).</p><p>Rather than placing a restriction on variables, or on quantification scope as in the case of guarded fragments <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr">Wang ([17]</ref>) suggested a fragment in which the existential quantifier and the box modality were always bundled together to appear as a single quantifier-modality pair (∃x□). The resulting fragment of FOML enjoys many attractive properties: finite tree model property, PSpace decision procedure and a simple axiom system, without any restriction on predicates or the occurrences of variables. The new operator ∃x□ captures the logical structure of various knowing-wh expressions such as knowing what, knowing how, knowing why, and so on (cf. <ref type="bibr" target="#b17">[18]</ref>), e.g., knowing how to achieve φ can be rendered as there is a plan x such that the agent knows that x can be executed and will guarantee φ.</p><p>In <ref type="bibr" target="#b13">[14]</ref>, we took the next step by considering not only the combination ∃x□ but also its companion ∀x□: the logic with both of these combinations continued to be decidable (over increasing domain models). Such modal-quantifier combinations were thus called bundled fragments of FOML. Over models where the domain remains the same in all states, the fragment with both ∃x□ and ∀x□ is undecidable, while the ∃x□-fragment is still decidable.</p><p>Clearly, we can define more bundles such as □∀x, □∃x, etc., and indeed further combinations such as ∀x∀y□, and combinations thereof. These (generalized) bundled fragments offer us many interesting possibilities for system specification: ¬∃x□ (x &lt; c): No element is guaranteed to be bounded by constant c (after update).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>∃x□ □∃y (x &gt; y):</head><p>There is an element that dominates some element after every update. □∃x □∀y (x ≤ y): All updates admit a local minimum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>∃x□ (∃y□ (x &gt; y) ∧ ∃y□ (x &lt; y)):</head><p>There is an element that dominates another no matter the update and is dominated by another no matter the update.</p><p>Computationally this raises the natural question of what is the most general bundled fragment that is decidable. This is the project taken up in this paper. We consider all possible combinations of the bundled formulas and classify their decidability status. The classification is described in Table <ref type="table">1</ref>. We provide a trichotomy: decidable fragments, undecidable fragments and fragments that do not have a finite model property (but where decidability is open).</p><p>Towards proving the trichotomy, we first define the notion of loosely bundled fragment which subsumes many decidable bundled fragments of FOML and prove its decidability via a tableau method. We also prove the decidability of another combination of bundled operators where we allow only formulas of the form ∀x□ + □∀x + □∃x (but is not included in the loosely bundled fragment). This requires us to introduce a new proof technique that helps us switch quantifiers in a specific context.</p><p>Due to space restrictions, we present only the main ideas and proof techniques of the decidable fragments over increasing domain models in the paper. The proof details, as well as undecidability and lack of finite model property for the other fragments can be found in the detailed technical report in the arXiv <ref type="bibr" target="#b12">[13]</ref>.</p><p>Table <ref type="table">1</ref> Satisfiability problem classification for combinations of bundled fragments over increasing domain models. A " * " means no matter the corresponding bundle is included or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>∀□ ∃□ □∀ □∃</head><p>Decidability</p><formula xml:id="formula_0">✓ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✗ Subsumed by the ✗ ✗ ✗ ✓ Loosely Bundled Fragment ✓ ✓ ✗ ✗ ✗ ✗ ✓ ✓ * ✓ ✓ * Undecidable ✗ ✓ ✗ ✓ No Finite Model Property ✓ ✓ ✗ ✓ Undecidable ✓ ✗ ✓ ✓ ExpSpace</formula><p>Loosely Bundled Fragment ExpSpace</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Syntax and Semantics</head><p>The syntax of first-order modal logic is given by extending the first-order logic with modal operators. Note that we exclude equality, constants and function symbols from the syntax.</p><p>▶ Definition 1 (FOML syntax). Given a countable set of predicates P and a countable set of variables Var, the syntax of FOML is given by:</p><formula xml:id="formula_1">α ::= P (x 1 , . . . , x n ) | ¬α | α ∧ α | ∃xα | □α</formula><p>where P ∈ P has arity n and x, x 1 , . . . , x n ∈ Var.</p><p>The boolean connectives ∨, →, ↔, and the modal operator ♢ which is the dual of □, and the quantifier ∀ are all defined in the standard way. The notion of free variables, denoted by FV(α) is similar to what we have for first-order logic with FV(□α) = FV(α). We write α(x) to mean that x occurs as a free variable of α. Also, α[y/x] denotes the formula obtained from α by replacing every free occurrence of x by y. The monotonicity condition requiring δ(w) ⊆ δ(v) for (w, v) ∈ R is required for evaluating the free variables present in the formula <ref type="bibr" target="#b10">[11]</ref>. Because of this, the models are called increasing domain models.</p><formula xml:id="formula_2">▶</formula><p>For a given model M we denote W M , R M etc to indicate the corresponding components. We simply use W, R, δ etc when M is clear from the context.</p><p>To evaluate formulas, we need an assignment function for variables. For a given model M, an assignment function σ : Var → D is relevant at w ∈ W if σ(x) ∈ δ(w) for all x ∈ Var.</p><p>▶ Definition 3 (FOML semantics). Given an FOML model M = (W, D, δ, R, ρ) and w ∈ W, and σ relevant at w, for all FOML formulas α define M, w, σ |= α inductively as follows:</p><formula xml:id="formula_3">M, w, σ |= P (x1, . . . , xn) ⇔ (σ(x1), . . . , σ(xn)) ∈ ρ(w, P ) M, w, σ |= ¬α ⇔ M, w, σ ̸ |= α M, w, σ |= α ∧ β ⇔ M, w, σ |= α and M, w, σ |= β M, w, σ |= ∃xα ⇔ there is some d ∈ δ(w) such that M, w, σ [x →d] |= α M, w, σ |= □α ⇔ for every u ∈ W if (w, u) ∈ R then M, u, σ |= α We sometimes write M, w |= α(a) to mean M, w, [x → a] |= α(x).</formula><p>A formula α is satisfiable if there is some FOML structure M and w ∈ W and some assignment σ relevant at w such that M, w, σ |= α. In the sequel, we will only talk about the relevant σ for a given pointed model. Also, while evaluating α, it is enough to consider σ to be a partial function that gives an interpretation for the free variables of α. A formula α is valid if ¬α is not satisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Bundled fragments</head><p>The motivation for "bundling" is to restrict the occurrences of quantifiers using modalities. For instance, allowing only formulas of the form ∀x□α is one such bundling. We could also have ♢∃yα. Thus, there are many ways to "bundle" the quantifiers and modalities. We call these the "bundled operators/modalities". The following syntax defines all possible bundled operators of one quantifier and one modality:</p><p>▶ Definition 4 (Bundled-FOML syntax). The bundled fragment of FOML is the set of all formulas constructed by the following syntax:</p><formula xml:id="formula_4">α ::= P (x1, . . . , xn) | ¬α | α ∧ α | □α | ∃x□α | ∀x□α | □∃xα | □∀xα</formula><p>where P ∈ P has arity n and x, x 1 , . . . , x n ∈ Var.</p><p>Note that the duals of the bundled operators give us the formulas of the form ∀x♢α, ∃x♢α, ♢∀xα, ♢∃xα. Also, note that □α can be defined using any one of the bundled operators where the quantifier is applied to a variable that does not occur in α. However, we retain □α in the syntax for technical convenience.</p><p>The following constant domain models may help to get familiar with bundles.</p><formula xml:id="formula_5">w 1 / / ) ) v 1 : P a w 2 / / ) ) v 2 : P c w 3 / / v 3 : P c u 1 : P b u 2 M 1 M 2 M 3 Let D M1 = {a, b}, D M2 = D M3 = {c}.</formula><p>□∃xP x holds at w 1 and w 3 but not at w 2 ; ∃x□P x holds only at w 3 ; ¬∀x□P x holds at w 1 and w 2 ; ¬□∀x¬P x holds at all the w i .</p><p>We denote ∀□-fragment to be the language that allows only atomic formulas, negation, conjunction, □α and ∀x□α (dually ∃x♢α) formulas, similarly for ∃□-fragment and so on. In general, these fragments are not equally expressive, e.g., as shown by <ref type="bibr" target="#b16">[17]</ref>, the ∃□-fragment cannot express □∃, ∀□ and □∀ bundles over models with increasing (or constant) domains.</p><p>In <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b11">12]</ref> we proved that the ∀□+∃□ and □∀+□∃ fragments are decidable over increasing domain models, while ∀□-fragment and □∀-fragment are undecidable over constant domain models. Since simple bundles become undecidable over constant domain models, in this paper we focus on generalized bundles over increasing domain models.</p><p>Note that we can have more general bundled operators of the form ∀x∀y□α etc. This naturally raises the question of what is the most general fragment of this form that is decidable. Towards this, we define a general fragment that subsumes all known decidable bundled fragments so far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The Loosely Bundled Fragment</head><p>Note that a bundled formula of the form ∃x□α imposes a restriction that there is exactly one modal formula in the scope of ∃x. But this is a strong requirement. We weaken this condition to allow formulas of the form ∃xβ where β is a boolean combination of atomic formulas and modal formulas. Moreover, we can allow a quantifier alternation of the form</p><formula xml:id="formula_6">∃x 1 • • • ∃x n ∀y 1 • • • ∀y m β.</formula><p>As we will see, the fact that the existential quantifiers are outside the scope of universal quantifiers can help us to obtain decidability results over increasing domain models.</p><p>▶ Definition 5 (LBF syntax). The loosely bundled fragment of FOML is the set of all formulas constructed by the following syntax:</p><formula xml:id="formula_7">ψ ::=P (z 1 , . . . z n ) | ¬P (z 1 , . . . z n ) | ψ ∧ ψ | ψ ∨ ψ | □α | ♢α α ::=ψ | α ∧ α | α ∨ α | ∃x 1 . . . ∃x k ∀y 1 . . . ∀y l ψ</formula><p>where k, l, n ≥ 0 and P ∈ P has arity n and x 1 , . . . x k , y 1 , . . . y l , z 1 , . . . , z n ∈ Var.</p><p>Let LBF be the set of all formulas that can be obtained from the grammar of α above. Note that the syntax does not allow a quantifier alternation of the form ∀x∃y α. Also, inside the scope of quantifier prefix ∃ * ∀ * , we can only have boolean combinations of atomic and modal formulas. The ∃ * ∀ * fragment in FO, (Bernays-Schönfinkel-Ramsey class) has a similar quantifier prefix structure but is different in spirit since there is no modality.</p><p>The loosely bundled fragment subsumes some of the combinations of bundled fragments. Hence proving the decidability for LBF implies the decidability for these combinations as well.</p><p>▶ Proposition 6. The fragments ∀□ + ∃□ and □∀ + □∃ are subfragments of LBF.</p><p>Note that many combinations of bundled operators (for instance □∀ + ∃□) do not form a subfragment of LBF.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Tableau Procedure</head><p>Note that the formulas of LBF are in negation normal form (where ¬ appears only in front of atomic formulas). We first define some useful terms and notations.</p><formula xml:id="formula_8">▶ Definition 7. For any FOML formula φ: φ is a literal if φ is of the form P (x 1 , . . . x n ) or of the form ¬P (x 1 , . . . x n ) φ is a module if φ is a literal or φ is of the form ∆α where ∆ ∈ {□, ♢} The component of φ is defined inductively as follows: If φ is a module then C(φ) = {φ} If φ is of the form φ 1 ∧ φ 2 or φ 1 ∨ φ 2 then C(φ) = C(φ 1 ) ∪ C(φ 2 ) If φ is of the form ∀x φ 1 or ∃x φ 1 then C(φ) = {φ} ∪ C(φ 1 ) A formula φ is called Existential-safe if every ψ ∈ C(φ) is a module or of the form ∀x ψ ′ . A finite set of formulas Γ is Existential-safe if every φ ∈ Γ is Existential-safe.</formula><p>Intuitively, C(φ) is the set of all subformulas of φ that are "to be evaluated" at the current world. An Existential-safe formula φ does not need any witness from the current local domain in order to make the formula true. The notions of components and existential-safeness will play a role in the tableau-based decision procedure to be introduced below.</p><p>Before going into the specific tableau rules, we first explain the general method. A tableau is a tree-like structure generated from a single formula α by repeatedly applying a few rules with some auxiliary information as the root of the tree. Intuitively, a tableau for α is a pseudo model which can be transformed into a real model of α under some simple consistency conditions. We can then decide the satisfiability of a formula by trying to find a proper tableau. As in <ref type="bibr" target="#b16">[17]</ref>, a tableau T in our setting is a tree structure such that each node is a triple (w, Γ, σ) where w is a symbol or a finite sequence of symbols intended as the name of a possible world in the real model, Γ is a finite set of FOML-formulas, and σ is an assignment function for variables. Since we intend to use the set of variables as the domain in the tableau-induced real model, σ is simply a partial identity function on Var, i.e., σ(x) = x for all x ∈ Dom(σ) ⊆ Var, where the domain of σ, Dom(σ), is intended to be the local domain of the real model. The intended meaning of the node (w, Γ, σ) is that all the formulas in Γ are satisfied on w with the assignment σ, thus we also write (w : Γ, σ) for the triple.</p><p>A tableau rule specifies how the node in the premise of the rule is transformed to or connected with one or more new nodes given by the conclusion of the rule. Applying the rules can generate a tree-like structure, a tableau, which is saturated if every leaf node contains only literals. For any formula α, we refer to a saturated tableau of α simply as a tableau of α. Further, a saturated tableau is open if in every node (w : Γ, σ) of the tableau, Γ does not contain both β and ¬β for any formula β. <ref type="foot" target="#foot_2">2</ref>We call a formula clean if no variable occurs both bound and free in it and every use of a quantifier quantifies a distinct variable. A finite set of formulas Γ is clean if Γ, the conjunction of all formulas in Γ, is clean. Note that every FOML-formula can be rewritten into an equivalent clean formula. For instance, the formulas ∃x□P x∨∀x♢Qx and P x∧□∃xQx are not clean, whereas ∃x□P x ∨ ∀y♢Qy and P x ∧ □∃yQy are their clean equivalents respectively. Clean formulas help in handling the witnesses for existential formulas in the tableau in a syntactic way.</p><p>Consider a finite set of formulas Γ that is clean. Suppose we want to expand Γ to Γ ∪ {α 1 , . . . α k }, then even if each of α i is clean, it is possible that a bound variable of α i also occurs in some φ ∈ Γ or another α j . To avoid this, first, we rewrite the bound variables in each α i one by one by using the fresh variables that do not occur in Γ and other previously rewritten α j .</p><p>Such a rewriting can be fixed by always using the first fresh variable in a fixed enumeration of all the variables. When Γ and {α 1 , . . . α k } are clear from the context, we denote α * i to be such a fixed rewriting of α i into a clean formula. It is not hard to see that the resulting finite set Γ ∪ {α * 1 , . . . α * k } is clean.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Tableaux for LBF</head><p>The tableau rules for the LBF fragment are described in Fig. <ref type="figure">1</ref>. The (∧) and (∨) rules are standard, where we make a non-deterministic choice of one of the branches for (∨). The rule (END) says that if we are left with only modules and there are no ♢ formulas, then the branch does not need to be explored further. The (♢) rule creates one successor world for every ♢ formula at the current node and includes all the □ formulas that need to be</p><formula xml:id="formula_9">w : φ1 ∨ φ2, Γ, σ w : φ1, Γ, σ || w : φ2, Γ, σ (∨) w : φ1 ∧ φ2, Γ, σ w : φ1, φ2, Γ, σ (∧) w : ∃xφ, Γ, σ w : φ, Γ, σ ′ (∃) where σ ′ = σ ∪ {(x, x)} w : ∀yφ, Γ, σ w : {φ * [z/y] | z ∈ Dom(σ)}, Γ, σ (∀)</formula><p>where satisfied along with the ♢ formula and σ is inherited in the successor worlds to preserve the increasing domain property. The (∃) rule picks x itself as the witness to satisfy ∃xφ and (∀) rule expands the set of formulas to include a clean version of φ[z/y] for every variable z in the current local domain.</p><p>Note that only the (♢) rule can change (the name of) the possible world, thus creating a new successor. It simply extends the name w by new symbols v i for each successor. Therefore there can be many nodes in the tableau sharing the same world name but such nodes form a path. Given w we use t w to denote the last node sharing the first component w. Given a node t = (w : Γ, σ) in a tableau, we use Dom(t) to denote the domain of σ.</p><p>Also, there is an implicit ordering on how the rules are applied: (♢) rule can be applied at a node (w, Γ, σ) only if all formulas of Γ are modules and hence may be applied only after the (∧, ∨, ∀, ∃) rules have been applied as many times as necessary at w. Similarly (∀) rule can be applied only when Γ is Existential-safe which means that the (∃) rule cannot be applied anymore at the current node.</p><p>▶ Proposition 8. For every tableau T and every node v = (w, Γ, σ) in T , if v is a leaf then either Γ contains only literals or there is some rule that can be applied at v.</p><p>The proposition is true since the LBF ensures that if Γ is not Existential-safe and the (∧, ∨, ♢, END) rules cannot be applied, then it has to be the case that there is some ∃xφ ∈ Γ, for which we can apply the (∃) rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>▶ Theorem 9. For any clean LBF formula θ, let σ r be an identity mapping over FV(θ) ∪ {z} where z does not occur in θ.</head><p>There is an open tableau T with root (r : {θ}, σ r ) iff θ is satisfiable in an increasing domain model.</p><p>Proof. First, we claim that the rules preserve the cleanliness of the formulas. To see this, we verify that for every rule, if Γ in the antecedent of the rule is clean, then the Γ ′ obtained after the application of the rules is also clean. This is obvious for (∧), (∨), (♢) and (END) rules. The (∃) rule preserves cleanliness because it frees variable x which is not bound by any other quantifier in the antecedent. The (∀) rule preserves cleanliness by rewriting. Claim. For every node (w : Γ, σ) in T and for every</p><formula xml:id="formula_10">LBF formula φ, if φ ∈ Γ then M, w, σ |= φ.</formula><p>The claim is proved using a standard argument by induction on the height of the nodes of T from the leaves to the root (details in <ref type="bibr" target="#b12">[13]</ref>). Thus, from the claim it follows that M, r, σ r |= θ since the label of the root of T is (r : {θ}, σ r ).</p><p>(⇐) From Proposition 8 it follows that we can always apply some rule until every leaf node (w : Γ, σ) is such that Γ contains only literals. Thus every (partial) tableau can be extended to a saturated tableau. To prove that such a tableau is open, it suffices to show that all rules preserve satisfiability (details in <ref type="bibr" target="#b12">[13]</ref>). ◀</p><p>Note that the depth of the tableau is linear in the size of the formula. However, as we have to rewrite formulas using new variables when applying (∀) rule, the size of the domain is exponential in the size of the formula. Hence, the tableau procedure can be implemented in ExpSpace. ▶ Corollary 10. LBF is decidable in ExpSpace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4</head><p>The (Un)decidability Border</p><p>Note that the fragment LBF cannot express formulas of the form ∀x∃y□ α and also ∀x□∀y□∀zα. There are many combinations of the bundled fragments that can express thesse formulas (like ∃□ + □∀ and ∀□ + ∃□ + □∃ fragments). In fact, we can prove that a bundled fragment is undecidable if we can assert both ∀x∃y□α and ∀x□∀y□∀z α in the fragment.</p><p>To prove this, we can use tiling encoding where ∀x∃y□α can be used to assert that every "grid point" x has a horizontal/vertical successor y. In this case, it is important that both quantifiers are applicable over the same local domain and □α in ∀x∃y□α ensures that the witness y acts uniformly across all the descendants. The second formula ∀x□∀y□∀z α is used to verify the "diagonal property" of the grid. In the companion technical report of this paper <ref type="bibr" target="#b12">[13]</ref> we prove these results formally. Also, note that there are fragments like ∃□ + □∃ where ∀x∃y□α is expressible but not ∀x□∀y□∀z α. In these cases, we can prove that such fragments do not have a finite model property. This is also proved in the companion technical report <ref type="bibr" target="#b12">[13]</ref> where we show that this fragment gives a formula that can induce a linear order on the local domain of some world in the model and assert that this linear order does not have a maximal element. This leaves us with the fragments that cannot express ∀x∃y□α formulas and LBF is one such fragment which we proved to be decidable. The fragments ∀□ + ∃□ and □∀ + □∃ also fall in this category and since they are subfragments of LBF, decidability follows. So we only need to consider the fragment ∀□ + ∃□ + □∀ to complete the terrain (cf. Table . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1). The ∀□ + □∀ + □∃ Fragment</head><p>In this fragment, we are allowed to express ∀x□α, □∀xα and □∃xα and their duals. Note that this fragment is not closed under subformulas. For instance, φ := ∀x ∃y♢α ∨ ∀z□β is a subformula of φ ′ := ♢∀x ∃y♢α ∨ ∀z□β . But φ ′ is in the fragment and φ is not in the fragment. We say that φ is a subformula of ∀□ + □∀ + □∃ if there is some formula φ ′ ∈ ∀□ + □∀ + □∃ such that φ is a subformula of φ ′ .</p><p>Note that even though we cannot express formulas of the form ∀x∃y□φ in the fragment, ∀x∃y♢φ is still allowed. For instance, the formula ♢∀x ∃y♢α is in the fragment. Thus, we can have ∀x∃y♢φ but not ∀x∃y□φ. Intuitively this means that the different witnesses y for each x can work on different successor worlds. The fragment cannot enforce the interaction between x and y at all successors. This property can be used to prove that we can reuse the witnesses by creating new successor subtrees as required.</p><p>To get the decidability for ∀□ + □∀ + □∃ fragment, the main idea is to prove that the formulas of the form ∀x∃y♢φ can be satisfied by picking some boundedly many witnesses y that will work for all x. This is the same as proving that if ∀x∃y♢φ is satisfiable then ∃y 1 , . . . ∃y l ∀x ♢φ[y/y i ] is satisfiable (where l is bounded). We illustrate the proof idea with an example. ▶ Example 11. Consider the formula α := ∀x □¬P xx ∧ ∃y♢P xy which is a subformula of the fragment. Let T , r |= α where T is a tree model rooted at r. Now we will modify T to obtain M which is also a tree model rooted at r such that M, r |= ∃y</p><formula xml:id="formula_11">1 ∃y 2 ∀x □¬P xx ∧ ♢P xy 1 ∨ ♢P xy 2 .</formula><p>The model M is obtained by extending T in the following way. Let δ T (r) = D r . To obtain M, first we extend the local domain of r by adding a fresh element a. The idea is that for every d ∈ D r (when assigned to x) we will ensure that the new element a can be picked as the y-witness. To achieve this, we do the following: For every d ∈ D r let d ′ ∈ D r and (r, s d ) ∈ R T such that T , s d |= P dd ′ . Let T d be the subtree of T rooted at s d . We will create a new copy of T d and call its root u d . Now, in the new subtree rooted at u d , we make the new element a "behave" like d ′ and we add an edge from r to u d . So, in particular, M will have (r, u d ) ∈ R M such that M, u d |= P da. Since we do this construction for every d ∈ D r we obtain that for all d ∈ D r we have M, r |= ♢P da. Now note that while evaluating α at (M, r) the ∀x quantification will now also apply to a (since a is added to the local domain at r in M). But then, we cannot use a itself as the witness for a since we also need to ensure that M, r |= ∀x□¬P xx. Hence we will add another element b that acts as a witness for a. Further, b also needs a witness. But now we can choose a to be the witness for b since that does not violate the formula ∀x□¬P xx.</p><p>So to complete the construction, we pick some arbitrary d ∈ D r for which we have some d ′ ∈ D r and (r, s d ) ∈ R T such that T , s d |= P dd ′ . We create two copies of T d (subtree rooted at s d ) and call their roots as v d and w d respectively. In the subtree rooted at v d we ensure that a and b "behave" like d, d ′ respectively and in the subtree rooted at w d we ensure that a and b "behave" like d ′ , d respectively. In particular, we have M, v d |= P ab and M, w d |= P ba. Finally we add edges from r to v d and from r to w d in M. Note that in principle, it is possible for an ∃ quantified formula to occur in the scope of a ∀ quantifier as a boolean combination with other ∃ quantified formulas and modules. Moreover, these additional formulas can assert some "type" information that may force us to pick additional witnesses. For example, if the formula is ∀x □(¬P xx∧Rx)∨□(¬P xx∧¬Rx) ∧∃y♢ Rx → (P xy ∧¬Ry) ∧ ¬Rx → (P xy ∧Ry) then we need two initial y-witnesses a 1 , a 2 where one is used for witness whose "type" is □(¬P yy ∧ Ry) and other for witness whose "type" is □(¬P yy ∧ ¬Ry) and we also need the corresponding additional witnesses b 1 , b 2 . In general, the formula can force us to pick witnesses of a particular "1-type" which means we might need exponentially many witnesses.</p><p>Thus, we need to replace one ∃ inside the scope of ∀ by 2l many ∃ quantifiers outside the scope of ∀ where l is bounded exponentially in the size of the given formulas. We now prove this formally.</p><p>For any formula φ if α ∈ C(φ) we denote this by φ[α]. This means that α does not occur inside the scope of any modality in φ. Further, for every α ∈ C(φ) and a formula β, we denote φ[β/α] obtained by rewriting φ where every occurrence of α in φ is replaced by β.</p><p>In particular, we are interested in the case where α is of the form ∃y♢ψ. Thus we always consider φ <ref type="bibr">[∃y♢ψ]</ref>.</p><p>For every l ≥ 0 if y = y 1 , y Note that the ∃y quantifier is pulled outside the scope of the ∀x quantifier and replaced with a bounded number of witnesses y 1 , y ′ 1 , y ′ 2 , y ′ 2 . . . y l , y ′ l . Consequently ♢ ψ is replaced with a disjunction each replacing y with one of y i or y ′ i for every i ≤ l. To prove the lemma first we formally define the tree editing operation described in the example. Given a tree model T rooted at r, let d ̸ ∈ D T . To add the new domain element d to a local domain of r, we also need to specify the "type" of the new element d at r and its descendants. Towards this, we pick some domain element c that is already present in δ(r) and assign the type of d to the type of c at every world. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, we have studied the decidability of bundled fragments of FOML, where we have no restrictions on the use of variables or arity of relations. Specifically, we proved the decidability of the loosely bundled fragment LBF and the ∀□ + □∀ + □∃ fragment. The decidability of these fragments hinges on the observation that ∀x∃y□α is not expressible. A NexpTime lower bound follows for ∀□ + ∃□ and □∀ + □∃ (via encoding the corresponding version of the tiling problem <ref type="bibr" target="#b12">[13]</ref>), which implies the same lower bound for LBF and ∀□ + □∀ + □∃. There is a significant gap between the upper and lower complexity bounds and we need sharper technical tools for investigating lower bounds for bundled fragments. Note that the quantifier prefix in LBF is of the form ∃ * ∀ * and hence any extension of this quantifier prefix or extending LBF with negation closure will result in a fragment that will be able to express ∀x∃y□ α (and hence will not have the finite model property, <ref type="bibr" target="#b12">[13]</ref>). In this sense, LBF is the largest fragment in which ∀x∃y□α is not (syntactically) expressible. For the fragment ∀□ + □∀ + □∃ we introduced a technique to pull out ∃ quantifiers outside the immediate scope of ∀ and obtain a finite model property. This technique may be useful in studying other fragments of first-order modal logic.</p><p>The results in the paper, along with those in <ref type="bibr" target="#b12">[13]</ref>, provide a trichotomy classification of combinations of bundled operators over increasing domain models (Table <ref type="table">1</ref>). The fragments in which we can express both ∀x∃y□α and ∀x□∀y□∀zβ are undecidable, fragments in which we can express the former but not the latter lack finite model property (but decidability is open) and fragments where we cannot express the former are decidable. Similar trichotomy can also be proved for satisfiability over constant domain models <ref type="bibr" target="#b12">[13]</ref>.</p><p>We have considered only the "pure" fragments, without constants, function symbols, or equality. The addition of constants is by itself simple, but equality complicates things considerably. Since equality is extensively used in specifications, mapping fragments with equality is an important direction. The study of bundles over models with various frame conditions is also relevant for applications. Unfortunately, while it is clear that equivalence frames lead to undecidability <ref type="bibr" target="#b16">[17]</ref>, even with transitive frames the situation is unclear. Obtaining good decidable fragments over linear frames is an important challenge.</p><p>In the context of verification of infinite-state systems, we are often more interested in the model checking problem than in satisfiability. If the domain is finite, the problem is no different from model checking of first-order modal logic. However, we are usually interested in the specification being checked against a finitely specified (potentially infinite) model, e.g., when the domain elements form a regular infinite set. This is a direction to be pursued in the context of bundled fragments.</p><p>We have presented tableau-based decision procedures that are easily implementable, but inference systems for reasoning in these logics require further study.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>: Let T be an open tableau rooted at (r : {θ}, σ r ). Define a model M = (W, D, δ, R, ρ) as follows:W = {w | (w : Γ, σ) is a node in T } D = Var R = {(w, v) | v is of the form wv ′ for some v ′ }For every w ∈ W, define δ(w) = Dom(t w ) where t w is the last node of w in T For every w ∈ W and p ∈ P, define ρ(w, P ) = {x | P x ∈ Γ where t w = (w, Γ, σ)}Clearly, M is an increasing domain model, and since z ∈ Dom(σ r ), there is no empty local domain. As T is an open tableau, ρ is well-defined.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Thus, we have: δ M (r) = δ T (r) ∪ {a, b} and M, r |= ∃y 1 ∃y 2 ∀x □¬P xx ∧ ♢P xy 1 ∨ ♢P xy 2 . With the above construction, this assertion can be verified by assigning y 1 and y 2 to a and b respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>▶ Definition 13 .</head><label>13</label><figDesc>Given a tree model T = (W, D, R, δ, ρ) rooted at r, let d ̸ ∈ D and c ∈ δ(r). Define the operation of "adding d to δ(r) by mimicking c", denoted by T d →c = (W, D ′ , R, δ ′ , ρ ′ ) where: D ′ = D ∪ {d} for all w ∈ W we have δ ′ (w) = δ(w) ∪ {d}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Definition 2 (FOML structure). An increasing domain model for FOML is</head><label></label><figDesc></figDesc><table><row><cell></cell><cell>a tuple M =</cell></row><row><cell cols="2">(W, D, δ, R, ρ) where W is a non-empty countable set called worlds; 1 D is a non-empty</cell></row><row><cell cols="2">countable set called domain; R ⊆ (W × W) is the accessibility relation. The map δ : W → 2 D</cell></row><row><cell cols="2">assigns to each w ∈ W a non-empty local domain set such that whenever (w, v) ∈ R we</cell></row><row><cell>have δ(w) ⊆ δ(v) and ρ : (W × P) →</cell><cell>2 D n is the valuation function, which specifies the</cell></row><row><cell>n</cell><cell></cell></row><row><cell cols="2">interpretation of predicates at every world over the local domain with appropriate arity. The</cell></row><row><cell cols="2">model M is said to be a constant domain model if for all w ∈ W we have δ(w) = D.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Let Γ ′ be a clean finite set of formulas such that every α ∈ Γ is a subformula of ∀□ + □∀ + □∃ whereΓ ′ = Γ ∪ {∀xφ[∃y♢ψ]}. If Γ ∧ ∀xφ[∃y♢ψ] is satisfiable then there exists l ≤ 2 |Γ ′ | such that Γ ∧ ∃y 1 ∃y ′ 1 ∃y 2 ∃y ′ 2 .. . ∃y l ∃y ′</figDesc><table /><note><p>′ 1 . . . y l , y ′ l are fresh variables, we denote y♢ψ to be the formula i≤l ♢ψ[y i /y] ∨ ♢ψ[y ′ i /y] which is a big disjunction where each disjunct replaces y in ψ with one of y i or y ′ i . Further, we denote φ[y♢ψ/∃y♢ψ] as simply φ[y♢ψ]. For instance, for the formula φ := P x ∨ ∃y♢Qxy where ψ := ∃y♢Qxy, for l = 2 and y = y 1 , y ′ 1 , y 2 , y ′ 2 being fresh variables, φ[y♢ψ] is given by: P x ∨ ♢Qxy 1 ∨ ♢Qxy ′ 1 ∨ ♢Qxy 2 ∨ ♢Qxy ′ 2 . The size of a formula, denoted by |φ|, is the number of symbols occurring in φ and for a finite set of formulas Γ, let |Γ| = φ∈Γ |φ|. ▶ Lemma 12. l ∀x φ[y♢ψ] is satisfiable, where y = y 1 , y ′ 1 , . . . y l , y ′ l are fresh variables.</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that FOML can be translated into two-sorted FOL, and due to the Löwenheim-Skolem theorem for countable languages, every model has an equivalent countable model, cf.<ref type="bibr" target="#b4">[5]</ref>.M F C S</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>0 2 2</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p>Refer<ref type="bibr" target="#b16">[17]</ref> for an illustration of a similar tableau construction.</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>Funding This work is supported by <rs type="funder">NSSF</rs> grant <rs type="grantNumber">19BZX135</rs>. <rs type="person">Anantha Padmanabha</rs>: The author is funded by the <rs type="funder">French government</rs> under management of <rs type="funder">Agence Nationale de la Recherche</rs> as part of the "<rs type="programName">Investissements d'avenir" program</rs>, reference <rs type="grantNumber">ANR-19-P3IA-0001</rs> (<rs type="projectName">PRAIRIE 3IA Institute</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_mYUPv5S">
					<idno type="grant-number">19BZX135</idno>
				</org>
				<org type="funded-project" xml:id="_QctyRKj">
					<idno type="grant-number">ANR-19-P3IA-0001</idno>
					<orgName type="project" subtype="full">PRAIRIE 3IA Institute</orgName>
					<orgName type="program" subtype="full">Investissements d&apos;avenir&quot; program</orgName>
				</org>
			</listOrg>

			<div type="availability">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>https://arxiv.org/abs/2202.01581</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>For every w ∈ W and predicate P define ρ ′ (w, P ) = {e ′ | there is some e ∈ ρ(w, P ) and e ′ is obtained from e by replacing zero or more occurrences of c in e by d}.</p><p>Suppose that we want to extend the domain with d = d 1 • • • d n which are fresh. Let ω : d → D ′ where D ′ ⊆ δ T (r) and we want each d i to mimic ω(d i ). Then we denote T ω to be the tree obtained by T d1 →ω(d1) d2 →ω(d2)... dn →ω <ref type="bibr">(dn)</ref> .</p><p>▶ Proposition 14. Let T = (W, D, R, δ, ρ) be a tree model rooted at r with T d →c being an extended tree where d ̸ ∈ D and c ∈ δ(r). Then for all interpretations σ and for all FOML formulas φ and for all w ∈ W we have:</p><p>The proposition holds since there is no equality in the syntax and at every world in the extended model, the new element d "behaves" like c and the old elements "behave" like themselves (details in <ref type="bibr" target="#b12">[13]</ref>). Now we are ready to prove Lemma 12.</p><p>Proof of Lemma 12. Let T be a tree model rooted at r such that T , r, σ |= Γ∧∀xφ[∃y♢ψ].</p><p>For every domain element a ∈ δ T (r) define:</p><p>Note that Π(r, a) formalizes the notion of "type" of a at the world r. This includes the information of all subformulas that are true at the current world, when a universal variable is instantiated with a. Also, since the size of |C(α)| is at most the size of Γ ′ , the set Π </p><p>Let M 0 = T ω be the new tree model rooted at r obtained by adding d 1 , d ′ 1 , . . . , d l , d ′ l to δ T (r) where each d i and d ′ i mimics a i . Now M is obtained by extending M 0 as follows:</p><p>where ω 1 and ω 2 are defined as follows:</p><p>and w i be the root of T i 1 and T i 2 respectively. Add the edges from r to v i and from r to w i in M. The two copies of subtrees are intended to provide witnesses for ∃y♢ψ for d j and d ′ j respectively. We need the two copies to ensure that ω 1 and ω 2 are well defined in the case when i = j and a j ̸ = b.</p><p>We now explain the idea behind the construction. Note that T c 0 rooted at u c is created for every c ∈ δ T (r) such that T , r, σ to be the witness for d i and d j to be the witness for d ′ i . Consequently if s i is the world such that a → s i ∈ R T and T , s i , [xy → a i b] |= ψ then we create two new copies of subtree T i rooted at s i and call it T i 1 and T i 2 . By construction, in particular, the new element d i mimics a i and d ′ j mimics b in T i 1 . Similarly d ′ i mimics a i and d j mimics b in T i 2 . Thus, we can pick d ′ j to be the witness for d i (and consider T i 1 ) and pick d j to be the witness for d ′ i (and consider T i 2 ). Also, it is important to note that for every r → v ∈ R M , if d i mimics c and d ′ i mimics c ′ at v then we will always have Π(r, c) = Π(r, c ′ ) = Λ i = Π(r, a i ). Now it can be verified that M, r, σ |= Γ ∧ ∃y To see why the corollary is true, by Lemma 12 we get some l ≤ 2 |Γ ′ | , and we can pad sufficiently many dummy variables to get a strict equality. This gives us a useful tableau rule which we call (∀∃♢) rule for ∀□ + □∀ + □∃ fragment, described in Fig. <ref type="figure">2</ref>. The full tableau rules for ∀□ + □∀ + □∃ is given by the tableau rules of LBF (Fig. <ref type="figure">1</ref>) along with the (∀∃♢)-rule. ▶ Theorem 16. For any clean ∀□ + □∀ + □∃ formula θ, let σ r be an identity mapping over FV(θ) ∪ {z} where z does not occur in θ.</p><p>There is an open tableau with (r : {θ}, σ r ) as the root iff θ is satisfiable in an increasing domain model.</p><p>The proof follows along the lines of Theorem 9. The only interesting part of the proof is to show that the (∀∃♢) rule preserves satisfiability and this is by Lemma 12(details in <ref type="bibr" target="#b12">[13]</ref>).</p><p>Note that at if we start with a formula of length n then the application of (∀∃♢) rule will blow up the formula to size 2 n . So we have a tableau procedure that can be implemented as an algorithm in ExpSpace.</p><p>▶ Corollary 17. The fragment ∀□ + □∀ + □∃ is decidable in ExpSpace.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Modal languages and bounded fragments of predicate logic</title>
		<author>
			<persName><forename type="first">Hajnal</forename><surname>Andréka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">István</forename><surname>Németi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johan</forename><surname>Van Benthem</surname></persName>
		</author>
		<idno type="DOI">10.1023/A:1004275029985</idno>
	</analytic>
	<monogr>
		<title level="j">J. Philos. Log</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="217" to="274" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Quantified epistemic logics for reasoning about knowledge in multi-agent systems</title>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Belardinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessio</forename><surname>Lomuscio</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2009.02.003</idno>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">173</biblScope>
			<biblScope unit="issue">9-10</biblScope>
			<biblScope unit="page" from="982" to="1013" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interactions between knowledge and time in a first-order logic for multi-agent systems: Completeness results</title>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Belardinelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alessio</forename><surname>Lomuscio</surname></persName>
		</author>
		<idno type="DOI">10.1613/jair.3547</idno>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="1" to="45" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The classical decision problem</title>
		<author>
			<persName><forename type="first">Egon</forename><surname>Börger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Erich</forename><surname>Grädel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuri</forename><surname>Gurevich</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">First-order modal logic</title>
		<author>
			<persName><forename type="first">Torben</forename><surname>Braüner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Silvio</forename><surname>Ghilardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Modal Logic</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Blackburn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Benthem</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">F</forename><surname>Wolter</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="549" to="620" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Practical first-order temporal reasoning</title>
		<author>
			<persName><forename type="first">Clare</forename><surname>Dixon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Konev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexei</forename><surname>Lisitsa</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIME.2008.15</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TIME 2008</title>
		<meeting>TIME 2008</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="156" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The two-variable guarded fragment with transitive relations</title>
		<author>
			<persName><forename type="first">Harald</forename><surname>Ganzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Margus</forename><surname>Veanes</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS.1999.782582</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LICS &apos;99</title>
		<meeting>LICS &apos;99</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="24" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Decidable fragment of first-order temporal logics</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Hodkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0168-0072(00)00018-X</idno>
	</analytic>
	<monogr>
		<title level="j">Ann. Pure Appl. Log</title>
		<imprint>
			<biblScope unit="volume">106</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="85" to="134" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Monodic fragments of first-order temporal logics: 2000-2001</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Hodkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-45653-8_1</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LPAR &apos;01</title>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>In</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Robert</forename><surname>Nieuwenhuis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andrei</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting>LPAR &apos;01</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2250. 2001</date>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Decidable and undecidable fragments of first-order branching temporal logics</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Hodkinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS.2002.1029847</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings LICS 2002</title>
		<meeting>LICS 2002</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="393" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Cresswell</surname></persName>
		</author>
		<title level="m">A New Introduction to Modal Logic</title>
		<imprint>
			<publisher>Routledge</publisher>
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">On the decision problems of some bundled fragments of first-order modal logic</title>
		<author>
			<persName><forename type="first">Mo</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2201.02336" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
		<respStmt>
			<orgName>Peking University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Are bundles good deals for FOML?</title>
		<author>
			<persName><forename type="first">Mo</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anantha</forename><surname>Padmanabha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramaswamy</forename><surname>Ramanujam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanjing</forename><surname>Wang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2202.01581</idno>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Bundled Fragments of First-Order Modal Logic: (Un)Decidability</title>
		<author>
			<persName><forename type="first">Anantha</forename><surname>Padmanabha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanjing</forename><surname>Ramanujam</surname></persName>
		</author>
		<author>
			<persName><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.FSTTCS.2018.43</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of FSTTCS 2018</title>
		<meeting>FSTTCS 2018</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">122</biblScope>
			<biblScope unit="page" from="1" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Undecidability of first-order modal and intuitionistic logics with two variables and one monadic predicate letter</title>
		<author>
			<persName><forename type="first">Mikhail</forename><forename type="middle">N</forename><surname>Rybakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dmitry</forename><surname>Shkatov</surname></persName>
		</author>
		<idno type="DOI">10.1007/s11225-018-9815-7</idno>
	</analytic>
	<monogr>
		<title level="j">Stud Logica</title>
		<imprint>
			<biblScope unit="volume">107</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="695" to="717" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Why is modal logic so robustly decidable?</title>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
		<respStmt>
			<orgName>Rice University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A new modal framework for epistemic logic</title>
		<author>
			<persName><forename type="first">Yanjing</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.4204/EPTCS.251.38</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TARK 2017</title>
		<meeting>TARK 2017</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="515" to="534" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Beyond Knowing That: A New Generation of Epistemic Logics</title>
		<author>
			<persName><forename type="first">Yanjing</forename><surname>Wang</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-62864-6_21</idno>
	</analytic>
	<monogr>
		<title level="m">Outstanding Contributions to Logic</title>
		<imprint>
			<publisher>Springer Nature</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="499" to="533" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Decidable fragments of first-order modal logics</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Zakharyaschev</surname></persName>
		</author>
		<ptr target="http://www.jstor.org/stable/2695115" />
	</analytic>
	<monogr>
		<title level="j">J. Symb. Log</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1415" to="1438" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
