<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Order-Invariant First-Order Logic over Hollow Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Julien</forename><surname>Grange</surname></persName>
							<email>jgrange@di.ens.fr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">ENS Paris &amp; PSL</orgName>
								<orgName type="institution" key="instit2">INRIA &amp; CNRS</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
							<email>luc.segoufin@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="institution">INRIA &amp; ENS Paris &amp; PSL</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Order-Invariant First-Order Logic over Hollow Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">97A8923CC0579BB806FD1AB89E95D77A</idno>
					<idno type="DOI">10.4230/LIPIcs.CSL.2020.23</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>order-invariance,first-order logic Digital Object Identifier 10</term>
					<term>4230/LIPIcs</term>
					<term>CSL</term>
					<term>2020</term>
					<term>23</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We show that the expressive power of order-invariant first-order logic collapses to first-order logic over hollow trees. A hollow tree is an unranked ordered tree where every non leaf node has at most four adjacent nodes: two siblings (left and right) and its first and last children. In particular there is no predicate for the linear order among siblings nor for the descendant relation. Moreover only the first and last nodes of a siblinghood are linked to their parent node, and the parent-child relation cannot be completely reconstructed in first-order.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>First-order logic (FO) is a classical formalism for expressing properties over finite structures. It is the building block of many other formalisms that are highly expressive such as MSO or logics using fixpoints such as LFP. An important and desirable feature of FO, and of all its extensions mentioned above, is that it expresses only intrinsic properties of the structure, i.e. properties invariant under isomorphisms. A limitation of FO is that it cannot express some simple properties. In particular, as it cannot distinguish between nodes that are related via some automorphism, it cannot always go through all the nodes of a structure in order to perform simple tasks such as counting them.</p><p>In many scenarios, in particular in computer science, the structures under investigation are stored on a disk: this yields an implicit order among the elements of the structure. It is then reasonable to use this order within the logical formalism. In the case of FO this means adding a new binary predicate that is interpreted as a linear order. However, we want to do this in such a way that closure under isomorphisms is retained: the expressible properties should only depend on the structure and not on the way it is stored on the disk, the latter being arbitrary and subject to change. When this property is verified we say that the formula is order-invariant and we denote by &lt; -inv FO the set of first-order formulas that are order-invariant. We stress that being order-invariant is not a decidable property <ref type="bibr">[5]</ref> hence &lt; -inv FO is not a recursive set of formulas.</p><p>Obtaining a "real" logic (in the sense of Gurevich, in particular with a recursive syntax) that has exactly the same expressive power as &lt; -inv FO is a challenging question. Solving the same question for &lt;-inv LFP would solve the longstanding quest of finding a logic for PTime as it follows from Immermann-Vardi Theorem that &lt;-inv LFP captures PTime.</p><p>In order to find a logic for &lt; -inv FO, it is useful to understand a bit better its expressive power; such is the goal of this paper.</p><p>An example, attributed to Gurevich, shows that &lt; -inv FO is in general strictly more Our proof follows a strategy similar to the case of binary trees: we first exhibit a set of operations over hollow trees (actually over structures FO similar to hollow trees) that preserve order-invariance similarity. We then show that if two hollow trees are FO similar then one of them can be transformed using our set of operations into the other, lifting FO similarity to &lt; -inv FO similarity. The first part is standard and makes use of the locality of &lt; -inv <ref type="bibr">FO [8]</ref>. The second part is more combinatorial and forms the main technical contribution of this paper.</p><p>Related work. Besides the papers already mentioned above, there exist several other publications related to our work. We will make use in our proof of the fact that &lt; -inv FO ⊆ MSO over classes of graphs of bounded treewidth, which has been initially claimed in <ref type="bibr">[5]</ref>. Another proof of this result, extended to a broader class called "decomposable structures", can be found in <ref type="bibr">[7]</ref>.</p><p>If testing order invariance is undecidable for FO it is decidable for its two variable fragment <ref type="bibr">[15]</ref>.</p><p>Several authors considered order-invariance for more expressive logics (first-order with modulo predicates <ref type="bibr">[13]</ref>, MSO [7]) or with more expressive numerical predicates [10, 9, 2, 14]. Our proof technique follows lines similar to <ref type="bibr">[5,</ref><ref type="bibr">13]</ref> but is mildly related to the others.</p><p>The proofs that are missing or just sketched in the main part of the paper are given in greater details in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">General notations</head><p>We consider relational structures and use classical terminology for them. We use Σ to denote a relational schema and Σ-structure to denote a structure over Σ. Our structures are always finite and are denoted through calligraphic upper-case letters and their domain through the corresponding standard upper-case letter. For instance, A would denote the domain of the structure A. For a relation symbol R ∈ Σ and a Σ-structure A, we denote by R A the interpretation of R in A.</p><p>Given a relational signature Σ, first-order logic, FO(Σ), and monadic second-order logic, MSO(Σ), are defined in the standard way (see, e.g., <ref type="bibr">[11]</ref>). The main formalism of interest here is order-invariant first-order logic, denoted &lt; -inv FO(Σ). A sentence ϕ in FO(Σ ∪ {&lt;}) belongs to &lt; -inv FO(Σ) if for every Σ-structure A, whether (A, &lt; A ) |= ϕ is independent of the choice of the linear order &lt; A on A. In that case, we write A |= ϕ. For any L ∈ {FO(Σ), MSO(Σ), &lt; -inv FO(Σ)} and two Σ-structures A and B, we write A ≡ L k B to mean that A and B satisfy the same sentences of L of quantifier rank at most k. As usual we omit Σ when it is clear from the context. We use the standard notion of FO-interpretations in order to define a new structure from an existing one. Given a FO-interpretation I, we call arity of I the number of free variables in the formula of I which defines the domain of the new structure, and depth of I the maximum among the quantifier ranks of the formulas defining the domain and the new relations. It is a well known result that for every A, B, and I of arity a and depth d, and for every k ∈ N, if A ≡ L ak+d B then I(A) ≡ L k I(B). Let A be a structure over a vocabulary containing the binary relation symbol R. We say that U ⊆ A is R-stable if ∀x ∈ U, ∀y ∈ A, (R(x, y) ∨ R(y, x)) → y ∈ U .</p><p>For a set σ of symbols, we define the vocabulary P σ := {P s : s ∈ σ}, where every P s is a unary relation symbol.</p><p>C S L 2 0 2 0 23:4</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Order-Invariant First-Order Logic over Hollow Trees</head><p>As usual the Gaifman graph of a relational structure A is the (unoriented) graph whose vertices are the elements of the domain of the structure and the edges relate two vertices that appear in the same tuple of a relation of A. We denote by dist A (x, y) the distance between x and y in the Gaifman graph of A. Given two sets S and T of elements of A and m ∈ N, we say that S and T are m-distant in A, if dist A (x, y) ≥ m for all x ∈ S and all y ∈ T . The k-neighborhood N k A (x) of some x ∈ A is the substructure of A induced by {y ∈ A : dist A (x, y) ≤ k} together with an additional constant interpreted as x. The k-type tp k A (x) of x in A is the isomorphism class of its k-neighborhood. We extend those definitions to tuples of elements in the usual way, fixing the tuples pointwise.</p><p>For k ∈ N, we define the k-enrichment E k (A) of a Σ-structure A as A itself where each element has been recolored with its k-type. E k (A) is a structure over the vocabulary Σ augmented with a unary predicate for every k-type over Σ: there are a finite number of them as long as we consider classes of structures of bounded degree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Hollow trees</head><p>Barát, Hajnal, Lin and Yang <ref type="bibr">[3]</ref> proved that any graph of pathwidth at most 2 can be decomposed in a series of what they called tracks. Thus, a first step towards proving the collapse of &lt; -inv FO to FO on classes of pathwidth at most 2 is to show that &lt; -inv FO = FO on the class of tracks. A typical example of track of degree 3 is depicted in Figure <ref type="figure" target="#fig_0">1</ref>, where the dashed arcs are colored paths, and all the chords are single edges. Each chord could actually be a single edge or the juxtaposition of two edges with a single vertex in the middle; we can however ignore that case, since the middle vertices can be encoded in FO by coloring the chords according to whether they are simple or double edges.</p><p>We show in Figure <ref type="figure">2</ref> how such a track can be turned into a structure resembling a tree. We add color and number identifiers to clarify the translation.</p><p>Note that those two transformations, as well as their inverse, are definable as FOinterpretations as soon as the square edge is part of the track. We will thus see in Lemma 2 that the collapse of &lt; -inv FO to FO on any of these classes of structures amounts to the collapse on the other.</p><p>This remark motivates the definition of hollow trees. Informally, hollow trees resemble the aforementioned tree-like structure with the key difference that the vertical edges (i.e. the parent-child edges) and the horizontal one are distinguishable. In return for that specification, we do not restrict the complexity of the underlying tree, while the tree-like structures resulting         </p><formula xml:id="formula_0">• • • • • • • • 1 2 3 4 5 6 7 8 9 1 9 2 8 3 7 4 6 5 • • • • Figure 2</formula><p>Turning a track of degree 3 into a tree-like structure. One goes from the track to the intermediate structure by cutting the edge represented as a square, and from the intermediate structure to the tree-like structure by contracting each chord into a vertex.</p><p>from the transformation of a track are very constrained. In particular, the class of hollow trees has unbounded pathwidth.</p><p>Let's now formally define hollow trees. An unranked ordered tree is a tree with a successor relation among the children of any node. We see unranked ordered trees as structures over the signature composed of two binary C S L 2 0 2 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:6</head><p>Order-Invariant First-Order Logic over Hollow Trees relation symbols S and S , where S is interpreted as the parent-child relation, and S as the horizontal successor. A set of nodes that share the same parent is called a siblinghood.</p><p>We define a mapping H from the set of unranked ordered trees to structures over two binary predicates S and E. Given an unranked ordered tree T , H(T ) is defined as follows:</p><p>its domain is T H(T ) |= S(x, y) iff T |= S(x, y) and y is either the first or the last of its siblings E is interpreted as the symmetrical closure of S The image of H is the set of hollow trees, denoted H. If P = H(T ) then T is the underlying tree structure of P.</p><p>In other words, within a hollow tree, only the two children at the endpoints of a siblinghood know their parent. Notice that we do not distinguish between the first and last child, nor do we between the left and right sibling. This makes the model more general, as explained in Section 2.4. An example of hollow tree is given in the left part of Figure <ref type="figure">3</ref>.</p><formula xml:id="formula_1">• • • • • • • • • • • • • • • • • • • • • • • • Figure 3</formula><p>An example of hollow tree (left) and of hollow quasitree (right). The dotted arrows represent S and the plain (symmetrical) lines represent E.</p><p>Given a finite alphabet σ, we define H σ , the set of hollow trees over σ, as the set of colored extensions of hollow trees using the vocabulary P σ , where the interpretations of the predicates of P σ partition the domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Main result</head><p>If C is a class of structures, we say that &lt; -inv FO = FO over C if for each property definable in &lt; -inv FO, there exists a first-order formula expressing this property over all structures of C. Notice that for every σ, H σ is a class of structures of treewidth 2. Therefore &lt; -inv FO ⊆ MSO over H σ <ref type="bibr">[5]</ref>. The main result we prove in this paper is:</p><formula xml:id="formula_2">Theorem 1. For all σ, &lt; -inv FO = FO over H σ</formula><p>We outline the proof here, and give more details in the rest of this paper.</p><p>Proof sketch. Our goal is to find some function</p><formula xml:id="formula_3">f such that, ∀α ∈ N, ∀P, Q ∈ H σ , if P ≡ FO f (α) Q then P ≡ &lt;-inv FO α Q. This means that the equivalence relation ≡ FO f (α) refines ≡ &lt;-inv FO α .</formula><p>Both equivalence relations being of finite index and the former being definable in FO for every fixed α, the result follows.</p><p>To show this we fix some α ∈ N and consider two hollow trees P and Q, such that P ≡ FO f (α) Q for a large enough f (α). The general idea is to modify Q through some operations that are invisible to all formulas of &lt; -inv FO of quantifier rank less than α, until we reach P. This will ensure that P ≡ &lt;-inv FO α Q. We will use two kinds of operations as described in Section 3: "swap operations", which preserve &lt; -inv FO, and one which preserves MSO (and a fortiori &lt; -inv FO as &lt; -inv FO ⊆ MSO over H σ by <ref type="bibr">[5]</ref>).</p><p>The MSO-preserving operation will be used in Section 3.3, in order to pump Q to make sure that every neighborhood type is present at least as many times in Q as in P.</p><p>Once this is done, we explain in Section 4 how to transform Q with swap operations in order to include P into it. Since Q may be larger than P, there could be some extra material in Q that we call "loops". The last step is to remove those loops and this is the goal of Section 6.</p><p>When performing the swap operations, there will be a constant need for reorganizing the S-edges (in particular to make sure that the loops are S-stable). Section 5 and Section 6.3 compile the results that allow us to do so.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Bi-FO-interpretations and corollaries</head><p>Before we give more details about the proof of our main result, we recall in this section a classical tool for reducing the collapse of &lt; -inv FO to FO from one class of structures to another. We then state a few corollaries of Theorem 1.</p><p>Let C 1 , C 2 be two classes of structures over the respective vocabularies τ 1 and τ 2 . We say that C 1 is bi-FO-interpretable through C 2 if there exist two FO-interpretations I 12 and I 21 , respectively from τ 1 to τ 2 , and from τ 2 to τ 1 , such that for every A ∈ C 1 , I 12 (A) ∈ C 2 and I 21 (I 12 (A)) A, where denotes the existence of an isomorphism between two structures. The following result is rather straightforward:</p><formula xml:id="formula_4">Lemma 2. If C 1 is bi-FO-interpretable through C 2 and &lt; -inv FO = FO over C 2 , then &lt; -inv FO = FO over C 1</formula><p>Recall that in the definition of hollow trees the relation E is symmetric. This turns out to be more general than choosing E as an arbitrary directed binary relation as shown in the following result where a directed hollow tree is defined as for hollow trees but with a directed binary relation E. Note that we do not assume that E is a successor relation among siblings, the direction of E could be arbitrary, but the result below works in particular when E is a successor relation. Via a simple bi-FO-interpretation which uses extra colors to encode the direction of the edges, we get the following result: Corollary 3. For every σ, &lt; -inv FO = FO on the class of σ directed hollow trees Define a path over σ as a word over the alphabet σ, where the successor edges are symmetrical (the argument used in the proof of Corollary 3 guarantees that paths are a more general model than words). The class of paths over σ is obviously bi-FO-interpretable through H σ : just add a S-parent to the endpoints of the path, and then forget about it. Thus we get: Corollary 4. For every alphabet σ, &lt; -inv FO = FO on the class of paths over σ.</p><p>Similarly, a straightforward bi-FO-interpretation together with Theorem 1 give us back the result from [5] that &lt; -inv FO = FO on ranked trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Swaps and pumping</head><p>In this section we provide a few operations, denoted swaps, that preserve ≡ &lt;-inv FO k . Although the k-type of every element will be left unchanged, applying these operations may break the somewhat rigid structure of hollow trees. In order to work with the intermediate structures, we loosen the definition of hollow trees and define hollow quasitrees as follows:</p><p>C S L 2 0 2 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:8</head><p>Order-Invariant First-Order Logic over Hollow Trees Definition 5. For k &gt; 0 and σ a set of colors, we define the set of hollow k-quasitrees on σ, quasi-H k σ , as the set of all finite structures over {E, S} ∪ P σ such that the k-type of any of their elements is the k-type of some element in some hollow tree in H σ , and which are such that their relation E is acyclic.</p><p>In other words a hollow quasitree differs from a hollow tree by its relation S which may not induce a tree structure: a node may have its S-children in two distinct siblinghoods and a hollow quasitree may have cycles using the relation S (but not using only the relation E). Note that by definition H σ ⊆ quasi-H k σ for every k. An example of what a hollow quasitree could look like is given in the right part of Figure <ref type="figure">3</ref>. Note that locally, it looks like a hollow tree.</p><p>Let T ∈ quasi-H k σ . We define the support of T as its restriction to the vocabulary P σ ∪ {E}. The n-enriched support of T , denoted Supp n (T ), is the support of its nenrichment (and not the other way around). Hence, it keeps in memory the local behavior within T . The set End(T ) of endpoints of T is the set of elements of the support having degree one. A connected component of the support of T is called a thread <ref type="foot" target="#foot_0">1</ref> . Note that by E-acyclicity of T , each of its threads is a path, hence contains exactly two endpoints. We say that a hollow k-quasitree has the matching endpoints property if the two endpoints of each thread have the same S-parent. Note that a hollow tree has the matching endpoints property. Notice also that in a hollow k-quasitree, any thread of length less than 2k + 1 has matching endpoints. For x, y ∈ T belonging to the same thread, [x, y] denotes the set of elements that lie between them (formally, those who disconnect x from y in Supp 0 (T )), including x and y. We naturally define [x, y[ as [x, y] \ {y}.</p><p>The following lemma, implicit in the proof of locality of &lt; -inv FO by Grohe and Schwentick [8], will allow us to prove that our operations preserve order-invariance equivalence: Lemma 6. Let Σ be a relational vocabulary and let p, α ∈ N. There exists o Σ p (α) ∈ N such that for every structure A over Σ, and for every p-tuples of elements ā, b ∈ A p that have the same o Σ p (α)-type in A, there are two orders &lt; āb and &lt;b ā on A such that (A, &lt; āb) ≡ FO α (A, &lt;b ā) āb is an initial segment of &lt; āb bā is an initial segment of &lt;b ā Our operations are divided into three families depending on whether we modify the relation S, the relation E, or whether we do a global pumping, In the following, R is a hollow (m + 1)-quasitree on σ. Proof sketch. In order to prove that R ≡ &lt;-inv FO α R we need to exhibit a linear order over R and one over R such that we can play an α-round Ehrenfeucht-Fraïssé game between the resulting ordered structures. The linear orders are constructed using Lemma 6 applied to (a , a ) and (b , b ) and the structure R -. A simple FO-interpretation is then used to transfer the corresponding orders onto R and R . Proving that the type of an element is unchanged is straightforward.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">crossing-S-swaps</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">E-swaps</head><p>We define four different kinds of E-swaps. Then R is called the m-guarded crossing-E-swap between ab and a b in R (c.f. Figure <ref type="figure" target="#fig_4">5</ref>).   <ref type="figure">,</ref><ref type="figure">E(c,</ref><ref type="figure">d),</ref><ref type="figure">E(a ,</ref><ref type="figure">b ),</ref><ref type="figure">E(c ,</ref><ref type="figure">d</ref> ) and such that {a, b, c, d, a , b , c , d } and End(R) are (2m + 3)-distant in Supp 0 (R). Furthermore, assume that tp  </p><formula xml:id="formula_5">a b a b • ♦ • | | | | | | | | -→ a b a b • ♦ • | | | | | | | |</formula><formula xml:id="formula_6">(R). Furthermore, assume that tp m R (a, b) = tp m R (a , b ). Let R := R \ {E(a, b), E(a , b )} ∪ {E(a, b ), E(a , b)}. Then R is called the m-guarded mirror-E-swap at [b, b ] in R (c.f. Figure 6). a b b a • • &gt;&gt;&gt; | | | | | | -→ a b b a • • &lt;&lt;&lt; | | | | | |</formula><formula xml:id="formula_7">m R (a, b) = tp m R (a , b ) and tp m R (c, d) = tp m R (c , d ). Let R := R \ {E(a, b), E(a , b ), E(c, d), E(c , d )} ∪ {E(a, b ), E(a , b), E(c, d ), E(c , d)}. R is called the m-guarded segment-E-swap between [b, c] and [b , c ] in R (c.f. Figure 7). a b c d a b c d • • ♦ | | | | | | | | | | -→ a b c d a b c d • • ♦ | | | | | | | | | |</formula><formula xml:id="formula_8">(R) are (2m + 3)- distant in Supp 0 (R). Furthermore, suppose that tp m R (a, b) = tp m R (a , b ) = tp m R (a , b ). Let R := R \ {E(a, b), E(a , b ), E(a , b )} ∪ {E(a, b ), E(a , b ), E(a , b)}. R is called the m-guarded contiguous-segment-E-swap between [b, a ] and [b , a ] in R (c.f. Figure 8). a b a b a b • • ♦ | | | | | | | | -→ a b a b a b • • ♦ | | | | | | | |</formula><formula xml:id="formula_9">] in R the m-guarded contiguous-segment-E-swap between [b, a ] and [b , a ] in R the m-guarded segment-E-swap between [b, c] and [b , c ] in R then R ≡ &lt;-inv FO α R, ∀x ∈ R, tp m+1 R (x) = tp m+1 R (x) and R ∈ quasi-H m+1 σ .</formula><p>Proof sketch. The proof is a tedious case analysis. Basically it amounts to the following idea: if the elements involved in the swap are far away from each other then we can use Lemma 6 in the structure R minus the E-edges of interest, and get orders on R and R which make these structures similar as in the proof of Lemma 8.</p><p>On the other hand, if the elements are close to each other, then the fact that they share the same type induces some periodicity on their neighborhoods. These neighborhoods can therefore be decomposed into several consecutive similar pieces. We can then apply Lemma 6 to these smaller components to conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Pumping</head><p>The next operation makes use of the fact that &lt; -inv FO ⊆ MSO over hollow trees. Hence our hollow trees can be "pumped" in order to duplicate some of their parts.</p><p>Given a structure A and a k-type τ , we denote by |A| τ the number of elements of A whose k-type is τ . We will essentially use 0-types as our structures will be enriched by recoloring each element by its k-type. In view of this we denote by [[A]] the function τ → |A| τ whose domain is the set of 0-types over the considered vocabulary.</p><p>Let d, D ∈ N, and f, g be functions from a same domain to N. We say that f ≤ D d g if for every x in the domain:</p><formula xml:id="formula_10">if f (x) ≤ d, then f (x) = g(x) if f (x) = g(x), then g(x) ≥ f (x) + D By f &lt; g, we mean that ∀x, f (x) &lt; g(x) or f (x) = g(x) = 0.</formula><p>In the following proposition &lt; -inv FO can be replaced by MSO.</p><formula xml:id="formula_11">Proposition 10. ∀α, n, d ∈ N, ∃M ∈ N, ∀D ∈ N, ∀P, Q ∈ H σ , if P ≡ FO M Q, then there exists Q ∈ H σ such that Q ≡ &lt;-inv FO α Q and [[E n+1 (P)]] ≤ D d [[E n+1 (Q )]].</formula><p>Proof sketch. This is a pumping argument: by setting M large enough, we make sure in FO that if a (n + 1)-type has more occurrences in P than in Q, then it has enough occurrences in Q so that we can find a context in Q containing at least one occurrence, and no occurrence of a rare type, such that we can duplicate this context inside Q without changing its MSO-type.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Inclusion and pseudo-inclusion</head><p>Recall that our ultimate goal is to show that if two hollow trees agree on the same FO sentences of quantifier rank f (α) then they agree on all &lt; -inv FO sentences of quantifier rank α. For this, we will show that if P and Q are hollow trees that agree on all FO sentences of quantifier rank f (α) then we can use operations such as the swap operations described in Section 3 to transform Q into P. As these operations preserve &lt; -inv FO we get the desired result.</p><p>In this section we perform the first step towards transforming Q into P. We show that using the swap operations we can transform Q into Q so that Q "includes" P. The resulting structure Q will be a hollow quasitree. In the next sections we will continue the transformation and remove from Q all the extra material it contains, deriving P.</p><p>In order to define what we mean by "inclusion" we need the notion of a n-abstract context of a hollow quasitree. Intuitively this is a S-stable n-enriched substructure. More formally, given a hollow quasitree T ∈ quasi-H n σ and a set U of its domain that is S-stable, then C := T |U , together with the function tp n (.) that maps x ∈ U to its n-type in T , is called a n-abstract context denoted C = Ctxt n (T | U ). The set of n-abstract contexts is denoted Ctxt n σ . Note that tp n (x) denotes tp n T (x) and not tp n C (x). We need to remember, at least locally, how C was glued to the rest of T in order to preserve n-types when moving C to some other place.</p><p>We are now ready to define the notion of "inclusion". We actually define both "inclusions" and "pseudo-inclusions". We will need to pseudo-include a hollow quasitree into another (Proposition 12), and then to include an abstract context into a hollow quasitree (Proposition 13). Since a hollow k-quasitree T ∈ quasi-H k σ can be seen as a k-abstract context (T = Ctxt k (T | T )), we only need to define (pseudo-)inclusions from an abstract context into a hollow quasitree.</p><formula xml:id="formula_12">Definition 11. Let k ∈ N, U ∈ Ctxt k σ and Q ∈ quasi-H k σ . We say that h : U → Q is a k-pseudo-inclusion if h is injective</formula><p>and for all x, y, z ∈ U the following is verified:</p><formula xml:id="formula_13">1. tp k Q (h(x)) = tp k (x),</formula><p>C S L 2 0 2 0 23:12 Order-Invariant First-Order Logic over Hollow Trees</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">if x and y are in the same thread of U then h(x) and h(y) are also on the same thread of Q and if moreover z ∈ [x, y] then h(z) ∈ [h(x), h(y)], 3. if U |= E(x, y) and t is the E-neighbor of h(x) in [h(x), h(y)] then t is the image of y</head><p>by an isomorphism (induced by the fact that they share the same k-type) between the n-neighborhood of x and that of h(x).</p><p>If U |= E(x, y) and Q |= E(h(x), h(y)) then {x, y} is said to be a jumping pair for h,</p><formula xml:id="formula_14">and tp k-1 Q (h(x), t), where t is the E-neighbor of h(x) in [h(x), h(y)], is called its type. 2 A k-pseudo-inclusion is said to be reduced if there is at most one jumping pair of a given type. A k-pseudo-inclusion is called a k-inclusion if it has no jumping pairs, that is if it preserves E.</formula><p>The last condition of pseudo-inclusion is a complication induced by the fact that E is not oriented and that we thus cannot distinguish between the two siblings of a node. It ensures that h preserves the neighborhoods in the right order. We can now state the main result of this section. Note that the precondition that Q has more realizations for each type than U or P will not be a problem in view of Proposition 10. The second proposition is stronger than the first one as it derives inclusion instead of pseudo-inclusion, but it requires the stronger hypothesis that every occurring type has strictly more realizations in Q than in U.</p><p>Proposition 12. For every α, m ∈ N, there exists</p><formula xml:id="formula_15">N ∈ N such that ∀P, Q ∈ quasi-H N +1 σ , if [[E N +1 (P)]] ≤ [[E N +1 (Q)]], then there exists Q ∈ quasi-H m+1 σ such that Q ≡ &lt;-inv FO α Q, [[E m+1 (Q )]] = [[E m+1 (Q)]] and h that is a (m + 1)-pseudo-inclusion from P into Q . Proposition 13. For every α, m ∈ N, there exists N ∈ N such that ∀U ∈ Ctxt N +1 σ , ∀Q ∈ quasi-H N +1 σ , if [[E N +1 (U)]] &lt; [[E N +1 (Q)]], then there exists Q ∈ quasi-H m+1 σ such that Q ≡ &lt;-inv FO α Q, [[E m+1 (Q )]] = [[E m+1 (Q)]] and U is (m + 1)-included in Q .</formula><p>Proof sketch. Both propositions have a similar proof: we first prove Proposition 12, and explain afterwards how to move from pseudo-inclusions to inclusions.</p><p>We define the pseudo-inclusion h step by step, extending the domain of h thread by thread and, inside each thread, from one of its endpoint to the other. At each step we modify Q using E-swaps, if necessary.</p><p>We give a special treatment to short threads and portions of the long threads that are close to the endpoints: in that case, no modification of Q is required as the cardinality precondition ensures the presence of the necessary sequences within Q. We then move to the parts of the long threads that are far from the endpoints, adding them one node at a time to the domain of the pseudo-inclusion. Note that as all the elements involved in the E-swaps to come are distant from the endpoints, the E-swaps involved are guarded.</p><p>Let x be the last node of the current thread t that has been given an image by h, and let x be the next node to which we want to extend the domain of h. By hypothesis, we know that there exists a node y / ∈ Im(h) far from any endpoint, that has the same (m + 1)-type as x. We denote by y the neighbor of y that has the same m-type as x , and by x the neighbor of h(x ) having the same m-type as x.</p><p>We proceed to a case analysis depending on the relative position of y, y , h(x ) and x. If y , y are on the same thread as h(x ), x and in the same direction (in particular when y = x), we simply set h(x) to y and we are done. If not, one of the E-swaps will place y to the desired position.</p><p>For instance, if y , y are on the same thread as h(x ), x but in the reverse direction (c.f. Figure <ref type="figure" target="#fig_14">9</ref>, where the double line represents Im(h)), then we consider the m-guarded mirror-E-swap at [x, y] in Q and extend h by setting h(x) to y.</p><formula xml:id="formula_16">h(x ) x y y &gt;&gt;&gt; | | | | | | -→ h(x ) y &lt;&lt;&lt; | | | | | | Figure 9 h(x ),</formula><p>x and y , y are in the same thread, but in reverse order: we use a mirror-E-swap</p><p>Now, if y is on a thread that does not intersect Im(h) (c.f. Figure <ref type="figure" target="#fig_8">10</ref>), we consider the m-guarded crossing-E-swap between h(x )x and y y in Q, and extend h by setting h(x) to y. If y , y are in the same direction as h(x ), x, and are between h(z) and h(z ) where z and z are consecutive node of the current thread (c.f. Figure <ref type="figure" target="#fig_9">11</ref>).</p><formula xml:id="formula_17">h(x ) x y y • • | | | | | | | | -→ h(x ) y • • | | | | | | | |</formula><p>Then we consider the m-guarded segment-E-swap between [u , y ] and [h(z ), h(x )] in Q, and extend h by setting h(x) to y. There are a few other cases that are treated similarly. This concludes the proof for pseudo-inclusion.</p><formula xml:id="formula_18">h(z) u y y h(z ) h(x ) x • • | | | | | | | | | | -→ h(z) h(z ) h(x ) y u y • • | | | | | | | | | |</formula><p>For Proposition 13, as we wish to construct an inclusion, we need to make sure that there is no "jump" in the mapping.</p><p>Note that among all the previously mentioned cases, only one didn't guarantee the absence of a jump, namely when y , y are on the same thread as h(x ), x and in the right direction, but when y = x. We then use the stronger hypothesis on the number of types in Q, which guarantees that there also exist z, z verifying the same conditions as y, y (cf. Figure <ref type="figure" target="#fig_10">12</ref>). We consider the m-guarded contiguous-segment-E-swap between [x, y ] and [y, z ] in Q, and extend h by setting h(x) to y. h is now an inclusion. </p><formula xml:id="formula_19">h(x ) x y y z z • • | | | | | | | | -→ h(x ) y z • • | | | | | | | |</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tools for reorganizing S-edges</head><p>In the previous section, we have seen how to "rewrite" Q using E-swap operations in order to pseudo-include P into the resulting quasitree. By definition, the pseudo-inclusion h of P into Q respects the enriched support but can be completely wild relatively to the S-edges. For instance, in Q, the endpoints of a thread may not have the same S-parent. In this section we show how to use S-swaps in order to ensure that our pseudo-inclusion mapping takes into account (to various degrees) the S-edges. We say that two nodes of a quasitree are S-siblings if they share the same S-parent.</p><p>In Section 5.1, we show how to make sure that the pseudo-inclusion respects the S-siblings relation. In Section 5.2 we show how to ensure that the image of a pseudo-inclusion is S-stable. S-stability is required to define and operate on the loops, as will be established in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">S-siblings re-association</head><p>The following Lemma shows how to modify a pseudo-inclusion in order for it to preserve the S-siblings relation. Note that it doesn't necessarily mean that the image structure has the matching endpoint property because the initial structure itself may not have this property as it is derived from a quasitree.</p><formula xml:id="formula_20">Lemma 14. ∀α, m ∈ N, ∃N ∈ N, ∀W ∈ Ctxt N σ , ∀Q ∈ quasi-H N σ , if h : W → Q is a N - pseudo-inclusion, then there exists some Q ∈ quasi-H m+1 σ and some (m+1)-pseudo-inclusion h : W → Q such that Q ≡ &lt;-inv FO α Q, Supp m+1 (Q ) Supp m+1 (Q) and, if</formula><p>x and y are S-siblings in W, then so are h (x) and h (y) in Q .</p><p>Proof sketch. We correct the S-edges two by two: let x, y be two S-siblings in W such that h(x), h(y) are not S-siblings in Q, and let z ∈ Q be the S-sibling of h(x).</p><p>z and h(y) must have the same (N -2)-type: we can use a crossing-E-swap or a mirror-E-swap (depending on whether they are the endpoints of a same thread) to exchange their positions and make sure h(x) and h(y) are S-siblings.</p><p>However, for these swaps to be guarded, we must operate far enough from the endpoints. This can be done as long as we choose N large enough.</p><p>A particular case of the previous lemma is when W is a hollow tree and h is surjective: then Q has the matching endpoints property. This result will be useful in the proof of Proposition 18.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">S-stabilization</head><p>The image of a pseudo-inclusion has no reason to be S-stable, thus neither has its complement. However, this is a crucial requirement to apply the results presented in the next section, Section 6, in order to remove the extra material not in the image of the pseudo-inclusion.</p><p>The next result provides a method to ensure that the image (and its complement) of a pseudo-inclusion is S-stable.</p><p>Recall that a pseudo-inclusion is said to be reduced if there is at most one jumping pair of a given type. At the end of this process, we get a reduced pseudo-inclusion, which will allow us to minimize the complement of its image in Section 6.1.</p><p>Proposition 15. For every α, m ∈ N, there exist N, d, D ∈ N such that, for every</p><formula xml:id="formula_21">P ∈ H σ , Q ∈ quasi-H N +1 σ such that [[E N +1 (P)]] ≤ D d [[E N +1 (Q)]</formula><p>] and P is (N + 1)-pseudo-included in Q through some h, there are some h and</p><formula xml:id="formula_22">Q ∈ quasi-H m+1 σ such that Q ≡ &lt;-inv FO α Q, Supp m+1 (Q ) Supp m+1 (Q), h is a reduced (m + 1)-pseudo-inclusion of P in Q and Q \ Im(h ) is S-stable in Q .</formula><p>Proof sketch. We consider all the pairs of elements x, y which break the S-stability of Im(h), i.e. such that S(x, y), x ∈ Im(h) and y ∈ Im(h). If there are many of them, then at least two of them are far from each other and we can apply a crossing-S-swap to correct the mapping h. We end up with a bounded number of problematic pairs that can be corrected separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6</head><p>Removing unnecessary material</p><p>In this section we show how to remove the material in Q that is not present in the image of the pseudo-inclusion of P. From the previous section we can assume that the pseudo-inclusion mapping preserves the S-siblings relation and that its image is S-stable. The remaining part of Q is then a union of "loops" in the sense that they connect nodes that have the same type.</p><p>After defining properly the notion of loop, we will use in Section 6.1 a pumping argument in order to reduce the size of the loop to some constant while preserving ≡ &lt;-inv FO α . In Section 6.2 we then show how to remove small loops without affecting the order-invariant equivalence class. Finally, in Section 6.3 we show that if a hollow tree and a hollow quasitree have the same enriched support, then they are ≡ &lt;-inv FO α : this concludes the proof of Theorem 1. We start with the definition of an abstract loop. Let n ∈ N. Let Type n σ <ref type="bibr" target="#b1">[2]</ref> denote the set of (n -1)-types for pairs over the vocabulary P σ ∪ {E, S}, of degree ≤ 4. Let Σ n be the vocabulary enriching P σ ∪ {E, S} with two unary symbols J 1 τ and J 2 τ for every τ ∈ Type n σ <ref type="bibr" target="#b1">[2]</ref>. Let h be a reduced n-pseudo-inclusion from</p><formula xml:id="formula_23">P ∈ H σ to Q ∈ quasi-H n σ , such that V := Q \ Im(h) is S-stable.</formula><p>Let Q + be an extension of Q to Σ n obtained in the following way. Since h is reduced, for every τ ∈ Type n σ <ref type="bibr" target="#b1">[2]</ref>, there is at most one jumping pair of type τ . If there isn't, J 1 τ and J 2 τ are interpreted as the empty set. Else, let {x, x } be this pair, and u (resp. u) be the E-neighbor of h(x) (resp. h(x )) in [h(x), h(x )]. Interpret J 1 τ as {h(x), u } and J 2 τ as {h(x ), u} (the assignments x → 1 and x → 2 are arbitrary). This is illustrated on the left part of Figure <ref type="figure" target="#fig_17">13</ref>, where the double line represents Im(h). We say that Q + is a h-jump-extension of Q.</p><p>We define</p><formula xml:id="formula_24">V + = Ctxt n (Q + | V ) as the extension of Ctxt n (Q| V ) to Σ n where every J i τ is defined consistently with Q + (i.e. ∀x ∈ V, V + |= J i τ (x) iff Q + |= J i τ (x)</formula><p>). This process is illustrated in Figure <ref type="figure" target="#fig_17">13</ref>. V + is called an n-abstract loop. Let L n σ be the set of n-abstract loops.</p><formula xml:id="formula_25">h(x) h(x ) | | | | | | | | | J 1 τ J 2 τ | | | | | J 1 τ J 2 τ Figure 13</formula><p>Example of a h-jump-extension Q+ of Q (on the left), and its associated abstract loop V+ of support V := Q \ Im(h) (on the right) Every Σ n -structure will have a '+' symbol in its name. When we omit it, we mean the reduction of the structure to P σ ∪ {E, S} (for instance, from</p><formula xml:id="formula_26">V + ∈ L n σ , we get V := Ctxt n (Q| V ) ∈ Ctxt n σ ).</formula><p>C S L 2 0 2 0 23:16 Order-Invariant First-Order Logic over Hollow Trees</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Loop minimization</head><p>It will be crucial to bound the size of the loops left by a pseudo-inclusion. The following result does this using a simple pumping argument.</p><p>Proposition 16. For every α, n ∈ N, there exists N ∈ N such that for every P ∈ H σ , Q ∈ quasi-H n σ and reduced n-pseudo-inclusion h :</p><formula xml:id="formula_27">P → Q, if V := Q \ Im(h) is S-stable then there exists some Q ∈ quasi-H n σ and a reduced n-pseudo-inclusion h : P → Q such that Q ≡ &lt;-inv FO α Q, U := Q \ Im(h ) is S-stable and |U | ≤ N .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Loop elimination</head><p>It now remains to get rid of the small loops. This is a consequence of the "aperiodicity" of &lt; -inv FO: we cannot distinguish in &lt; -inv FO between k and k + 1 copies of the same object if k is sufficiently large. Starting from a small loop, we can use the inclusion results of Section 4 to recreate many copies of the loop within Q, then, according to the following proposition, get rid of one copy using aperiodicity.</p><formula xml:id="formula_28">Proposition 17. ∀α ∈ N, ∃l ∈ N, ∀m ∈ N, ∃n ∈ N, ∀M ∈ N, ∃K ∈ N such that for every abstract loop U + ∈ L n+1 σ and every Q ∈ quasi-H n+1 σ such that |U | ≤ M , (l + 1) • [[E n+1 (U)]] &lt; [[E n+1 (Q)]</formula><p>] and such that for every (n + 1)-type χ that occurs in U, |Q| χ ≥ K, there exists</p><formula xml:id="formula_29">Q ∈ quasi-H m σ such that Q ≡ &lt;-inv FO α Q and [[E m (Q)]] = [[E m (Q )]] + [[E m (U)]]</formula><p>Proof sketch. The proof is based on the well known result that first-order formulas of quantifier-rank k cannot distinguish between a linear order of length 2 k and a linear order of length 2 k + 1 (see, for instance, <ref type="bibr">[11]</ref>). Hence if a loop is repeated at least 2 k + 1 times, we can eliminate one instance without changing the ≡ &lt;-inv FO k class of the structure. First, we include many copies of the loop in Q. The inclusion may not preserve S-edges: the next step is to re-associate these S-edges with crossing-S-swaps in order for these copies to be isomorphic. This is made possible by the hypothesis on the number of occurrences of types appearing in U: it gives us room to make sure the crossing-S-swaps are guarded.</p><p>Once this is done, we can remove one copy in a &lt; -inv FO-indistinguishable way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">S-parents re-association</head><p>We now turn to the last step of the proof of Theorem 1.</p><p>After the removal of the extra material in Q, we have transformed our initial hollow tree Q into a hollow quasitree having the same number of occurrences of any type as the initial P. They both have the same threads but may differ with their S-edges. The following proposition states that they are ≡ &lt;-inv FO α , thus ending the proof of Theorem 1. The techniques used in the proof of the following proposition are strongly reminiscent of those used in [4]; it requires a notion of vertical-S-swaps adapted to hollow trees.</p><formula xml:id="formula_30">Proposition 18. ∀α ∈ N, there exists n 1 ∈ N such that ∀P ∈ H σ , ∀Q ∈ quasi-H n1 σ , if Supp n1 (P) Supp n1 (Q) then P ≡ &lt;-inv FO α Q.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have shown that &lt; -inv FO = FO over hollow trees. As we have discussed in Section 2.2, in order to lift this result to tracks of bounded degree, i.e. the basic blocks of structures of pathwidth 2 and bounded degree, it suffices to show that &lt; -inv FO = FO over structures that have the same underlying graph than hollows trees, but without the possibility to distinguish a sibling from a child; in other words, there is only one binary relation that is the union of E and S. This is because there exists a bi-FO-interpretation from tracks of bounded degree through this class of structures. Unfortunately our proof does not extend to this class of structures as it was crucial in our proof to distinguish between E-swaps and S-swaps. We leave this generalization as an open problem.</p><p>We also have no idea yet on what to do when the degree is not assumed to be bounded, as we are then also facing the second difficulty mentioned in the introduction, namely reinterpreting the initial structure within its tree representation.</p><p>In this paper we bypassed the first problem mentioned in the introduction, finding similar tree decompositions given similar structures, by working directly on trees. This problem seems unavoidable when working with graphs. There are examples of similar structures of treewidth 2 that do not have any similar tree decompositions of width 2. It might even be the case that for all k there are two similar structures of treewidth 2 that do not have similar tree decomposition of width k. If that were true, completely new ideas would be needed to solve the treewidth 2 case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A</head><p>Proofs for Section 2 (Preliminaries)</p><formula xml:id="formula_31">Theorem 1. For all σ, &lt; -inv FO = FO over H σ Proof. Let α ∈ N. Recall that we want to find f (α) such that ∀P, Q ∈ H σ , if P ≡ FO f (α) Q then P ≡ &lt;-inv FO α Q.</formula><p>We set, in that order: l as in Proposition 17 (loop elimination), that is such that FO[α] cannot distinguish the linear order on {1, • • • , l} from the linear order on {1, • • • , l + 1} n 1 as in Proposition 18 (S-parents re-association) n 2 as in Proposition 12 (pseudo-inclusion) for n 1 -1 n 3 as in Proposition 17 (loop elimination) for n 2 M as in Proposition 16 (loop minimization) for n 3 + 1 K as in Proposition 17 (loop minimization) for n 2 and M n 4 , d 1 , D as in Proposition 15 (S-stabilization of the image of a pseudo-inclusion) for n 3 n 5 as in Proposition 12 (pseudo-inclusion) for n 4 f (α) as in Proposition 10 (pumping) for n 5 and d := max(d 1 , K)</p><p>Starting from P ≡ FO f (α) Q, we unfold the previously set indexes to apply the corresponding propositions in the reverse order: we transform Q into P along a sequence of ≡ &lt;-inv FO α hollow quasitrees (with smaller and smaller radius) Q i as follows:</p><p>According to Proposition 10, we can pump inside</p><formula xml:id="formula_32">Q to get Q 0 ≡ &lt;-inv FO α Q such that [[E n5+1 (P)]] ≤ D d [[E n5+1 (Q 0 )]]</formula><p>. Now that we've made sure there were at least as many occurrences of every type in Q 0 as in P, Proposition 12 yields a</p><formula xml:id="formula_33">Q 1 ≡ &lt;-inv FO α Q 0 such that [[E n4+1 (Q 1 )]] = [[E n4+1 (Q 0 )]] and P is (n 4 + 1)-pseudo-included in Q 1 by some h. Since [[E n4+1 (P)]] ≤ D d1 [[E n4+1 (Q 1 )]], Proposition 15 gives some Q 2 ≡ &lt;-inv FO α Q 1 such that Supp n3+1 (Q 2 ) Supp n3+1 (Q 1 )</formula><p>, and some reduced h which (n 3 + 1)-pseudo-includes P in Q 2 , where</p><formula xml:id="formula_34">V := Q 2 \ Im(h ) is S-stable in Q 2</formula><p>Proposition 16 gives us some Q 3 and</p><formula xml:id="formula_35">U + ∈ L n3+1 σ such that Q 3 ≡ &lt;-inv FO α Q 2 , |U | ≤ M and [[E n3+1 (Q 3 )]] = [[E n3+1 (P)]] + [[E n3+1 (U)]]</formula><p>Since |U | ≤ M and for every type (n 3 + 1)-type ξ that occurs in</p><formula xml:id="formula_36">U, |Q 3 | ξ ≥ K (indeed: since ξ occurs in U, |Q 0 | ξ = |P| ξ and |Q 3 | ξ &gt; |P| ξ &gt; d ≥ K),</formula><p>we can remove the extra elements by applying Proposition 17, which gives</p><formula xml:id="formula_37">Q 4 ≡ &lt;-inv FO α Q 3 such that [[E n2+1 (Q 4 )]] = [[E n2+1 (Q 3 )]] -[[E n2+1 (U)]] = [[E n2+1 (P)]]</formula><p>P and Q 4 having the same number of occurrences of every (n 2 + 1)-type, we can pseudoinclude one into another according to Proposition 12, which gives</p><formula xml:id="formula_38">Q 5 ≡ &lt;-inv FO α Q 4 such that Supp n1 (Q 5 ) Supp n1 (P) (indeed,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>the pseudo-inclusion cannot have any jumping pair)</head><p>Finally, Proposition 18 allows us to conclude that Q 5 ≡ &lt;-inv FO α P, completing our sequence of transformations.</p><p>This concludes the proof that</p><formula xml:id="formula_39">P ≡ &lt;-inv FO α Q. Lemma 2. If C 1 is bi-FO-interpretable through C 2 and &lt; -inv FO = FO over C 2 , then &lt; -inv FO = FO over C 1</formula><p>Proof. We show that for some function f , for every k ∈ N and</p><formula xml:id="formula_40">A, B ∈ C 1 , if A ≡ FO f (k) B, then A ≡ &lt;-inv FO k B.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C S L 2 0 2 0</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:20 Order-Invariant First-Order Logic over Hollow Trees</head><p>As &lt; -inv FO = FO over C 2 we know that there is a function g such that for all k ∈ N and A, B ∈ C 2 , if A ≡ FO g(k) B, then A ≡ &lt;-inv FO k B: to any order-invariant formula with a quantifier rank less than k, choose an arbitrary first-order equivalent formula over C 2 and take g(k) as the max of their quantifier rank.</p><p>Let The first consequence of this result is that we can assume a normal form over hollow trees without loss of generality. Namely that each S-parent has exactly two S-children, and that no element is at the same time a S-parent and a S-child. Indeed, there is a simple bi-FOinterpretation that transforms a general hollow tree into one having the desired properties (by duplicating nodes that are only child, and those that are simultaneously S-parent and S-child, and marking them with new unary predicates), and back to the initial one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 3. For every σ, &lt; -inv FO = FO on the class of σ directed hollow trees</head><p>Proof. We use Lemma 2 and exhibit a bi-FO-interpretation from directed hollow trees over σ through hollow trees over σ ∪ {-, |}.</p><p>We give the first FO-interpretation I (from directed hollow trees to hollow trees), and leave the reverse one to the reader.</p><p>To avoid confusion in the notations, let's rename the directed binary relation E as F in the vocabulary of directed hollow trees: hence I goes from the vocabulary {F, S} ∪ P σ to {E, S} ∪ P σ∪{-,|} }.</p><p>Given a σ directed hollow tree T , I(T ) is defined as follow: Proof. We first show that R ≡ &lt;-inv FO α R. This is essentially a reduction to Lemma 6 using FO-interpretations. Recall the function o Σ p given by Lemma 6. We use it with p = 2 and Σ := P σ ∪ {E, S, P 1/2 , P 3/4 } where P 1/2 and P 3/4 are unary. Assume now that m ≥ o Σ 2 (α + c) where c is a constant to be chosen later on.</p><p>Consider the extension R of R -to Σ where the interpretation of P 1/2 is {a} and that of P 3/4 is {b}. Since P R Otherwise, there are several cases, according to whether x belongs to</p><formula xml:id="formula_41">N m+1 R -(a), N m+1 R -(a ), N m+1 R -(a ), N m+1 R -(b), N m+1 R -(b ), or N m+1 R -(b );</formula><p>we treat the first one of them, the others being similar.</p><p>Set</p><formula xml:id="formula_42">d a := dist R -(x, a) and d b := dist R -(x, b). By hypothesis, d a ≤ m + 1.</formula><p>We distinguish two cases:</p><formula xml:id="formula_43">if d b &gt; m+1: because of the distance constraint, we can partition N m+1 R (x) into N m+1 R -(x) and N m-da R -</formula><p>(a , a ), with two S-edges joining a in the first and a , a in the second. These two parts are at distance ≥ 2 in R -, hence they are fully independent (no overlap, and no edge between the two except for S(a, a ) and S(a, a )). Likewise, we can partition   the m-guarded segment-E-swap between [b, c] and</p><formula xml:id="formula_44">N m+1 R (x) into N m+1 R -(x) and N m-da R - (b , b ). N m-da R - (a , a ) N m-da R - (b , b ), hence N m+1 R (x) N m+1 R (x). if d b ≤ m + 1: now, we can partition N m+1 R (x) into N m+1 R -(x), N m-da R -</formula><formula xml:id="formula_45">N m+1 R (x) into N m+1 R -(x), N m-da R - (b , b ) and N m-d b R - (a , a ), as shown in Figure 15. N m-da R - (a , a ) N m-da R - (b , b ) and N m-d b R - (a , a ) N m-d b R - (b , b ), hence N m+1 R (x) N m+1 R (x).</formula><formula xml:id="formula_46">N m+1 R -(x) x • N m-da R - (a , a ) N m-d b R - (b , b ) -→ a • a a b • b b N m+1 R -(x) x • N m-d b R - (a , a ) N m-da R - (b , b )</formula><formula xml:id="formula_47">[b , c ] in R then R ≡ &lt;-inv FO α R, ∀x ∈ R, tp m+1 R (x) = tp m+1 R (x) and R ∈ quasi-H m+1 σ .</formula><p>Note. In each of these cases, the swap doesn't introduce any E-loop. Hence, once we've shown that every elements keeps its (m + 1)-type, we immediately get that R ∈ quasi-H m+1 σ . However, these operations do not preserve hollowtreeness. This is the reason why we introduced the notion of quasitree.</p><p>We prove Lemma 9 separately for every type of E-swap. We will need the following lemmas:</p><formula xml:id="formula_48">Lemma 19. Let Q ∈ quasi-H m+1 σ and x, y ∈ Q such that the sets {x}, {y} and End(Q) are pairwise (2m + 3)-distant in Supp 0 (Q). Then dist Q (x, y) ≥ 2m + 3.</formula><p>Proof. This is a consequence of the fact that in a hollow (m + 1)-quasitree, a thread of length less than 2m + 1 must have matching endpoints.</p><p>Suppose that there exists path of length ≤ 2m + 2 in Q from x to y, and let p be such a path of shortest length.</p><p>The path p may use either an E-edge or an S-edges. We divide p into segments between two consecutive S-edges. Let t 1 , • • • , t r be the corresponding threads in that order (with possible repetitions).</p><p>We know that x ∈ t 1 and y ∈ t r . As x and y are at distance at least 2m + 3 when using only E-edges, we must have r ≥ 2.</p><p>There are two ways for p to go from t i to t i+1 : either (1) using and S-edge S(a, e i+1 ) with a ∈ t i and e i+1 ∈ End(t i+1 ), or (2) using an S-edge S(b, e i ) with b ∈ t i+1 and e i ∈ End(t i ).</p><p>As x is far from the endpoints of t 1 , p must go from t 1 to t 2 using case (1). Similarly, p must go from t r-1 to t r using case (2). Hence, there must exist some 1 &lt; i &lt; r such that p moves from t i-1 to t i following (1), and from t i to t i+1 following (2).</p><p>Since p is a shortest path, the two endpoints of t i involved in ( <ref type="formula">1</ref>) and ( <ref type="formula">2</ref>) cannot be the same; hence p goes from one endpoint of t i to the other and the length of t i must be ≤ 2m + 1. Since Q ∈ quasi-H m+1 σ , branches of length ≤ 2m + 1 must have matching endpoints. This contradicts the minimality of p, since p could have avoided t i completely.</p><p>Lemma 20. Let Q ∈ quasi-H m+1 σ and x = y ∈ Q belonging to the same thread, such that {x, y} and End(Q) are (2m + 3)-distant in Supp 0 (Q).</p><p>Every path of length &lt; 2m + 3 between x and y goes through every E-edge of [x, y].</p><p>In other words, if</p><formula xml:id="formula_49">Q -is Q minus any E-edge of [x, y], dist Q -(x, y) ≥ 2m + 3.</formula><p>Proof. The proof is identical as the one of Lemma 19, by considering a shortest path of length ≤ 2m + 2 from x to y that doesn't go through every E-edge of [x, y]: we arrive at the same contradiction.</p><p>The following lemma will only be needed in Section 5; however, we state it here as its proof is very similar to the previous ones.</p><formula xml:id="formula_50">Lemma 21. Let Q ∈ quasi-H m+1 σ , and x, y ∈ End(Q) such that dist Supp 0 (Q) (x, y) ≥ 2m+3.</formula><p>Then any path of length ≤ 2m + 3 from x to y goes through at least one of their S-parents.</p><p>Proof. We proceed similarly as in Lemma 19; let's use the same notations.</p><p>Suppose that p doesn't go through x's parent neither y's. Let's show that p goes from t 1 to t 2 using case (1): if not, it uses case (2) through the other endpoint of t 1 . Hence, t 1 would be of length ≤ 2m + 1 (since it takes at least 2 to reach y from there), and would have matching endpoints; this is absurd, since p would go through x's parent.</p><p>Similarly, we show that p moves from t r-1 to t r following (2). We can conclude exactly as in Lemma 19.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Lemma 9 for crossing-E-swaps</head><p>We let</p><formula xml:id="formula_51">R -:= R \ {E(a, b), E(a , b )}.</formula><p>It follows from Lemma 19 and Lemma 20 that a, b, a and b are at distance at least 2m + 3 from each other in R -.</p><p>First, we show that R ≡ &lt;-inv FO α R. This is essentially a reduction to Lemma 6 using FO-interpretations. Recall the function o Σ p given by Lemma 6. We use it with p = 1 and Σ := P σ ∪ {E, S, P 1 , P 2 } where P 1 and P 2 are unary. Assume now that m ≥ o Σ 1 (α + c) where c is a constant to be chosen later on.</p><p>Consider the extension R of R -to Σ where the interpretation of P 1 is {b} and that of P 2 is {b }. Since P R 1 and P R 2 are at distance &gt; m from a and a in R , we have that tp m R (a) = tp m R (a ). We can therefore apply Lemma 6, and get two orders &lt; aa and &lt; a a such that (R , &lt; aa ) ≡ FO α+c (R , &lt; a a ). Now, consider the FO-interpretation that adds a (symmetrical) E-edge between u and v if either: P 1 (u) and v is the first element of &lt; P 2 (u) and v is the second element of &lt; and then forgets about P 1 and P 2 .</p><p>Take c to be the depth of this FO-interpretation (which has arity 1). Note that the result of this FO-interpretation on (R , &lt; aa ) is an ordered extension of R and that its result on (R , &lt; a a ) is an ordered extension of R . This entails R ≡ &lt;-inv FO α R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Now, let x ∈ R, and let's show that tp</head><formula xml:id="formula_52">m+1 R (x) = tp m+1 R (x). First, if x is at distance &gt; m + 1 of {a, b, a , b } in R, there isn't any change in its (m + 1)-neighborhood.</formula><p>Otherwise, there are several cases, according to whether x belongs to</p><formula xml:id="formula_53">N m+1 R -(a), N m+1 R -(a ), N m+1 R -(b) or N m+1 R -(b );</formula><p>we treat the first one, the others being similar.</p><formula xml:id="formula_54">Set d := dist R (x, a). We can partition N m+1 R (x) into N m+1 R -(x) and N m-d R -(b)</formula><p>, with an E-edge joining a in the first and b in the second.</p><p>Because of the distance condition, these two parts are at distance ≥ 2 in R -, hence they are fully independent (no overlap, and no edge between the two except for E(a, b)).</p><p>Likewise, we can partition</p><formula xml:id="formula_55">N m+1 R (x) into N m+1 R -(x) and N m-d R -(b ).</formula><p>C S L 2 0 2 0 23:24 Order-Invariant First-Order Logic over Hollow Trees</p><formula xml:id="formula_56">N m-d R -(b) N m-d R -(b ), hence N m+1 R (x) N m+1 R (x).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Lemma 9 for mirror-E-swaps</head><p>Let R -:= R \ {E(a, b), E(a , b )}. It follows from Lemma 20 that the three sets {a}, {a } and {b, b } are (2m + 3)-distant in R -. The proof that R ≡ &lt;-inv FO α R is done exactly as in the case of crossing-E-swaps. Now, let x ∈ R, and let's show that tp m+1</p><formula xml:id="formula_57">R (x) = tp m+1 R (x). First, if x is at distance &gt; m + 1 of {a, b, a , b } in R,</formula><p>there isn't any change in its (m + 1)-neighborhood.</p><p>Otherwise, there are several cases, according to whether x belongs to</p><formula xml:id="formula_58">N m+1 R -(a), N m+1 R -(a ), N m+1 R -(b) or N m+1 R -(b )</formula><p>; the first two are similar to the cases appearing in the proof for crossing-E-swaps.</p><p>We treat the third one, the fourth being symmetrical.</p><formula xml:id="formula_59">Set d := dist R -(x, b) and d := dist R -(x, b ). By hypothesis, d ≤ m + 1. N m+1 R (x) can partitioned into N m+1 R -(x), N m-d R -(a)</formula><p>and the possibly empty N m-d R -(a ), with an E-edge joining b in the first to a in the second, and an E-edge joining b in the first to a in the third (if it is nonempty).</p><p>We claim that any two of these three neighborhoods are at distance ≥ 2 in R -, hence they are fully independent: no overlap, and no edge between any two of them, except (possibly) for E(a, b) and (possibly) E(a , b ).</p><p>Indeed, suppose (the other pairs of neighborhoods are treated similarly) that</p><formula xml:id="formula_60">N m+1 R -(x) and N m-d R -(a) are at distance ≤ 1. Then dist R -(a, x) ≤ 2m + 2 -d, hence dist R -(a, b) ≤ 2m + 2</formula><p>, which contradicts Lemma 20 for a and b (recall that {a, b} and End(R) are (2m + 3)-distant in Supp 0 (R)).</p><p>Likewise, we can partition</p><formula xml:id="formula_61">N m+1 R (x) into N m+1 R -(x), N m-d R -(a ) and N m-d R -(a). N m-d R -(a) N m-d R -(a ) and N m-d R -(a ) N m-d R -(a), hence N m+1 R (x) N m+1 R (x).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Lemma 9 for contiguous-segment-E-swaps</head><p>Let R</p><formula xml:id="formula_62">-:= R \ {E(a, b), E(a , b ), E(a , b )}.</formula><p>Let x, y be non-endpoint elements of the same thread of some</p><formula xml:id="formula_63">Q ∈ quasi-H n+1 σ . Let Q -:= Q \ {E(x , x</formula><p>), E(y, y )}, where x (resp. y ) is the E-neighbor of x (resp. y) that doesn't belong to [x, y].</p><p>We denote by [x, y] Q n the substructure of Q -induced by the set of nodes at distance ≤ n in Q -from [x, y], together with a new color marking x as the left endpoint.</p><p>We define concatenation as follows: if x, x 1 , y 1 , y appear in the same thread in that order, and E(x 1 , y 1 ), then we write</p><formula xml:id="formula_64">[x, y] Q n =: [x, x 1 ] Q n • [y 1 , y] Q n . Let us abbreviate dist Supp 0 (Q) (x, y) as |[x, y]| (that</formula><p>is, the distance from x to y if we are only allowed E-edges).</p><p>First, let's prove that (m + 1)-types are unchanged by a m-guarded contiguous-segment-E-swap.</p><p>Let x ∈ R, and let's show that tp m+1</p><formula xml:id="formula_65">R (x) = tp m+1 R (x) If x is at distance &gt; m + 1 of {a, b, a , b , a , b } in R,</formula><p>there isn't any change in its (m + 1)-neighborhood.</p><p>Otherwise, there are several cases, according to whether x belongs to</p><formula xml:id="formula_66">N m+1 R -(a), N m+1 R -(b), N m+1 R -(a ), N m+1 R -(b ), N m+1 R -(a ) or N m+1 R -(b ).</formula><p>We treat the second one, the other ones being similar or simpler. <ref type="figure"></ref>and<ref type="figure">d</ref>  We claim that any two of these four neighborhoods are at distance ≥ 2 in R -, hence they are fully independent: no overlap, and no edge between any two of them except (possibly) for <ref type="figure">E(a,</ref><ref type="figure">b),</ref><ref type="figure">E(a ,</ref><ref type="figure">b</ref> ) and E(a , b ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Set d</head><formula xml:id="formula_67">b := dist R -(x, b), d a := dist R -(x, a ),</formula><formula xml:id="formula_68">b a := dist R -(b , a ). By hypothesis, d b ≤ m + 1. We can partition N m+1 R (x) into N m+1 R -(x), N m-d b R -<label>(a)</label></formula><p>Indeed, suppose (the other pairs of neighborhoods are treated similarly) that</p><formula xml:id="formula_69">N m+1 R -(x) and N m-d b R - (a) are at distance ≤ 1. Then dist R -(a, x) ≤ 2m+2-d b , hence dist R -(a, b) ≤ 2m+2,</formula><p>which contradicts Lemma 20 for a and b (recall that {a, b} and End(R) are (2m + 3)-distant in Supp 0 (R)).</p><p>Likewise, we can partition</p><formula xml:id="formula_70">N m+1 R (x) into N m+1 R -(x), N m-d b R - (a ), N m-1-d b -d b a R - (a) and N m-d a R - (b ). Because tp m R (a, b) = tp m R (a , b ) = tp m R (a , b ), N m-d b R - (a) is isomorphic to the union of N m-d b R - (a ) and N m-1-d b -d b a R - (a)</formula><p>with an E-edge joining b in the first and a in the second (if they are both nonempty).</p><p>Similarly, the union of</p><formula xml:id="formula_71">N m-d a R - (b ) and N m-1-d a -d b a R - (b )</formula><p>with an E-edge joining a in the first and b in the second (if they are both nonempty) is isomorphic to</p><formula xml:id="formula_72">N m-d a R - (b ). Hence N m+1 R (x) N m+1 R (x). Now, let's exhibit a s(α) such that for every m ≥ s(α), m-guarded contiguous-segment- E-swaps preserve ≡ &lt;-inv FO α .</formula><p>We will first set N ∈ N instead of s(α), that will be sufficient for most cases. Then, we will define s(α) ≥ N which will work for all cases.</p><p>Recall the function o Σ p needed for Lemma 6, and consider n := o Σ 2 (α + c) where c is to be chosen later on, and Σ := P σ ∪ {E, S, P 1 , P 4 } where P 1 and P 4 are unary. We distinguish between several cases depending on whether a, a and a are close or not, where "close" is relative to n: </p><formula xml:id="formula_73">1. Assume first that tp n R -(b, a ) = tp n R -(b ,</formula><formula xml:id="formula_74">(α) ≥ n), tp n R (b, a ) = tp n R (b , a</formula><p>). Hence, we can apply Lemma 6, and get two orders &lt; ba b a and &lt; b a ba such that (R , &lt; ba b a ) ≡ FO α+c (R , &lt; b a ba ). Now, consider the FO-interpretation that adds a symmetrical E-edge between u and v if either: P 1 (u) and v is the first element of &lt; u is the second element of &lt; and v is either its third one u is the fourth element of &lt; and P 4 (v)</p><p>and then forgets about P 1 and P 4 . Take c to be the depth of this FO-interpretation (which has arity 1).</p><p>Hence we are in the conditions (since M ≥ s) to apply Lemma 9 in the case of the</p><formula xml:id="formula_75">M -guarded contiguous-segment-E-swap between [d, c] and [ϕ(d), c ] in R 1 . We get R 2 ≡ &lt;-inv FO α R 1 .</formula><p>In R 2 , the segment strictly between a and d can be decomposed as: <ref type="figure">b ,</ref><ref type="figure">c ,</ref><ref type="figure">d ,</ref><ref type="figure">ϕ(c),</ref><ref type="figure">ϕ(d</ref>) appear in that order, i.e. the segment strictly between a and ϕ(d) can be decomposed as:</p><formula xml:id="formula_76">[b , ϕ(c)] R n • [ϕ(d), c ] R n • [d, a ] R n • [b, c] R n = [b , c ] R n • [d, a ] R n • [b, c] R n That is, R 2 = R , and we get R ≡ &lt;-inv FO α R as desired. if a ,</formula><formula xml:id="formula_77">[b, c] R n • [d, a ] R n • [b , c ] R n • [d , ϕ(c)] R n Let R 1 be the M -guarded segment-E-swap between [b, c] and [b , ϕ(c)] in R.</formula><p>This swap falls under the scope of Case 1 since</p><formula xml:id="formula_78">M ≥ n, hence R 1 ≡ &lt;-inv FO α R and ∀z ∈ R, tp M +1 R1 (z) = tp M +1 R (z).</formula><p>In R 1 , the segment strictly between a and ϕ(d) can be decomposed as:</p><formula xml:id="formula_79">[b , c ] R n • [d , ϕ(c)] R n • [d, a ] R n • [b, c] R n</formula><p>Hence we are in the conditions (since M ≥ s) to apply Lemma 9 in the case of the</p><formula xml:id="formula_80">M -guarded contiguous-segment-E-swap between [d , ϕ(c)] and [d, c] in R 1 . We get R 2 ≡ &lt;-inv FO α R 1 .</formula><p>In R 2 , the segment strictly between a and ϕ(d) can be decomposed as:</p><formula xml:id="formula_81">[b , c ] R n • [d, a ] R n • [b, c] R n • [d , ϕ(c)] R n</formula><p>That is, the segment strictly between a and d is</p><formula xml:id="formula_82">[b , c ] R n • [d, a ] R n • [b, c] R n</formula><p>Hence R 2 = R , and we get R ≡ &lt;-inv FO α R as desired.</p><formula xml:id="formula_83">Proposition 10. ∀α, n, d ∈ N, ∃M ∈ N, ∀D ∈ N, ∀P, Q ∈ H σ , if P ≡ FO M Q, then there exists Q ∈ H σ such that Q ≡ &lt;-inv FO α Q and [[E n+1 (P)]] ≤ D d [[E n+1 (Q )]].</formula><p>Proof. The proof is a simple pumping argument. We rely on the fact that hollow trees have bounded treewidth hence &lt; -inv FO ⊆ MSO on H σ . In particular there is a β ∈ N such that</p><formula xml:id="formula_84">≡ MSO β subsumes ≡ &lt;-inv FO α . We will construct Q such that Q ≡ MSO β Q. Let d &gt;</formula><p>d be a number that will be specified during the proof. We choose M large enough to make sure that every (n + 1)-type has the same number of occurrences in P and in Q up to a threshold d (this can be expressed in FO).</p><p>We prove the proposition by induction on the number κ of (n + 1)-types τ such that</p><formula xml:id="formula_85">|P| τ = |Q| τ and |Q| τ &lt; |P| τ + D.</formula><p>If κ = 0, there is nothing to do as Q := Q fits. Otherwise, let τ be such a type. Notice that because P ≡ FO M Q we must have |Q| τ &gt; d . There are two cases to consider: Assume there exists a thread in Q which contains at least l nodes x 1 , x 2 , • • • , x l (in that order) having the same (n + 1)-type, whose subtrees each contains at least one node of type τ in Q, and such that for every i &lt; l, duplicating within the thread the forest below [x i , x i+1 [ does not affect the ≡ MSO β of Q, where l is chosen large enough so that C S L 2 0 2 0 23:30 Order-Invariant First-Order Logic over Hollow Trees there exists i &lt; l such that the forest below [x i , x i+1 [ doesn't contain any occurrence of a (n + 1)-type τ such that |Q| τ ≤ d. Then we construct Q from Q by duplicating the forest below [x i , x i+1 [ as many times as necessary to have enough nodes of type τ . This decreases κ and guarantees that Q ≡ MSO β Q and we can conclude by induction. Assume now that there is a chain for the ancestor relation x 1 , x 2 , • • • , x l having the same (n + 1)-type such that each of the contexts C P (x i , x i+1 ) (we use here the notations introduced for Lemma 26 to denote the context between x i and x i+1 ) contains at least one node of type τ and ∀i, j, S P (x i ) ≡ MSO β S P (x j ) (the subtrees at x i and x j ), where l is large enough to guarantee the existence of some i &lt; l such that C P (x i , x i+1 ) contains no node of any type τ such that |Q| τ ≤ d Let Q := P P (x i ) • C P (x i , x i+1 ) k • S P (x i+1 ) (that is, we've duplicated k times the context between x i and x i+1 ) with k large enough so we have enough nodes of type τ . We have Q ≡ MSO β Q and κ has decreased by 1: we can conclude by induction.</p><p>It remains to fix d large enough so that one of the two cases above must hold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Proofs for Section 4 (Inclusion and pseudo-inclusion)</head><p>Proposition 12. For every α, m ∈ N, there exists</p><formula xml:id="formula_86">N ∈ N such that ∀P, Q ∈ quasi-H N +1 σ , if [[E N +1 (P)]] ≤ [[E N +1 (Q)]], then there exists Q ∈ quasi-H m+1 σ such that Q ≡ &lt;-inv FO α Q, [[E m+1 (Q )]] = [[E m+1 (Q)]</formula><p>] and h that is a (m + 1)-pseudo-inclusion from P into Q . Proposition 13. For every α, m ∈ N, there exists</p><formula xml:id="formula_87">N ∈ N such that ∀U ∈ Ctxt N +1 σ , ∀Q ∈ quasi-H N +1 σ , if [[E N +1 (U)]] &lt; [[E N +1 (Q)]], then there exists Q ∈ quasi-H m+1 σ such that Q ≡ &lt;-inv FO α Q, [[E m+1 (Q )]] = [[E m+1 (Q)]] and U is (m + 1)-included in Q .</formula><p>Proof. We mainly focus on the proof of Proposition 12. We will then explain how to modify the proof using the extra hypothesis in order to get inclusion instead of pseudo-inclusion thus proving Proposition 13.</p><p>We modify Q using E-swaps in order to construct a pseudo-inclusion h from P. This is done step by step, extending the domain of h thread by thread and, inside each thread, from one of its endpoint to the other.</p><p>We distinguish between two kinds of threads of P. The short ones will be easily taken care of as they can be completely described in first-order. The long ones will require more work.</p><p>In view of Lemma 9, we assume that m ≥ s(α). We set n := 3m + 3. We will only perform swaps involving nodes at distance (along E) ≥ n -m from the endpoints; hence, the "distant from endpoints" conditions of m-guarded E-swaps will always be satisfied.</p><p>A thread is short if its length (the distance along E between its two endpoints) is at most 2(n -m). By taking N large enough, our hypothesis</p><formula xml:id="formula_88">[[E N +1 (P)]] ≤ [[E N +1 (Q)]</formula><p>] guarantees that we can find a injective mapping from the short threads of P to that of Q, which sends each short thread to one having an isomorphic (m + 1)-enrichment. We initialize h according to this mapping. It is clear that h is a partial (m + 1)-pseudo-inclusion mapping.</p><p>It remains to extend the domain of h to the long threads.</p><p>Let a be an endpoint of a long thread of P: segtype n-m m+1,P (a) denotes the isomorphism type of the segment [a, b], where b is the element at distance n -m of a in its thread, and every element is colored with its (m + 1)-type in P. By End n-m m+1 (P) ≤ End n-m m+1 (Q), we mean that every segtype n-m m+1,. (.) has at least as many occurrences in P as in Q.</p><p>Now, let's re-associate the S-edges back so that g respects S. We construct a sequence of structures</p><formula xml:id="formula_89">T 0 ≡ &lt;-inv FO α • • • ≡ &lt;-inv FO α</formula><p>T r having the same (n + 1)-enriched support, where T i is the simultaneous crossing-S-swap between g(x j ) and u j in R for j ≤ i.</p><p>Let's prove that for every i, T i verifies (Q i ):</p><p>1. {u i+1 }, {u i+1 , u i+1 }, • • • , {u r }, {u r , u r } are (2n + 5)-scattered wrt. Im(g) 2. ∀j, k &gt; i, let a j ∈ {x j , x j }. Then dist Ti (g(a j ), g(x k )) ≥ min(dist Wi (a j , x k ), 2n + 6)</p><formula xml:id="formula_90">3. ∀j = k &gt; i, a j ∈ {x j , x j } and a k ∈ {x k , x k }, dist Ti (g(a j ), g(a k )) &gt; 2n + 5 Set T 0 := R .</formula><p>We check that (Q 0 ).2 holds, for x j and x k (it is similar for x j ). Let them be such that dist T0 (g(x j ), g(x k )) ≤ 2n + 5, and let's prove that dist W0 (g(x j ), g(x k )) ≤ dist T0 (g(x j ), g(x k )). Consider a shortest path from g(x j ) to g(x k ) in T 0 .</p><p>Suppose it goes through at least one S-edge: the first time it does, it must be one that goes out of the thread containing g(x j ), which is contained (because g is an inclusion) in Im(g). (Q 0 ).1 rules out the possibility for this S-edge to be of the form S(g(x l ), u l ) (or S(g(x l ), u l )): from u l , the only way to reach g(x k ) in ≤ 2n + 4 is through S(g(x l ), u l ), which contradicts the minimality of this path.</p><p>Moreover, it cannot be the S-edge landing on the other endpoint of the thread, since this would mean that the thread is of length ≤ 2n + 4, and since R ∈ quasi-H 2n+6 σ , the other endpoint is guaranteed to be g(x j ). In this case, there would be a shortest path from g(x j ) to u j , which would directly borrow S(u j , g(x j )).</p><p>Hence, the first S-edge can only be S(u j , g(x j )), and (Q 0 ).1 ensures that the only way this would result in a path of length ≤ 2n + 5 is if the second edge it goes through is S(u j , g(x j )), from which we can repeat the same reasoning to prove that from there, the path doesn't go through any S-edge.</p><p>The other possibility is that the path doesn't go through any S-edge. In either case, it means that g(x j ) or g(x j ) and g(x k ) are on the same thread, and the shortest path follows the E-edges of this thread. Hence, a path as short exists in W 0 between x j and x k .</p><p>We now check that (Q 0 ).3 holds: let x j and x k (and similarly for x j and for x k ) be such that dist T0 (g(x j ), g(x k )) ≤ 2n + 5, and consider a shortest path from g(x j ) to g(x k ).</p><p>The same reasoning as before ensures that g(x k ) is on the same thread as g(x j ) or g(x j ), and that the shortest path follows the E-edges of that thread, which must then be of length ≤ 2n + 5 which in turn implies that j = k. Now suppose that we have constructed T i and let T i+1 be the n-guarded crossing-Sswap between g(x i+1 ) and u i+1 in T i . Suppose that dist Ti (g(x i+1 ), u i+1 ) &lt; 2n + 5: then dist Ti (g(x i+1 ), g(x i+1 )) ≤ 2n + 5, and (Q i ).2 ensures that dist Wi (x i+1 , x i+1 ) ≤ 2n + 5, which, as seen above, is absurd.</p><p>Lemma 8 ensures that )), or S(g(x i+1 ), g(x i+1 )), or one then the other. It is not possible for the path to be decomposable as g(x j ) p1 g(a i+1 )Sg(x i+1 ) p2 g(x k ) (for a i+1 ∈ {x i+1 , x i+1 }), because p 1 would be a path of length ≤ 2n + 5 in T i from g(x j ) to g(a i+1 ), which contradicts (Q i ).3 Hence the path can be decomposed as g(x j ) p1 g(x i+1 )Sg(a i+1 ) p2 g(x k ), with p 1 and p 2 , of respective length l 1 and l 2 (with l = l 1 + l 2 + 1) being valid in T i . (Q i ).2 allows us to reflect p 1 as a path from x j to x i+1 in W i of length ≤ l 1 , and p 2 as a path from a i+1 to x k in W i of length ≤ l 2 . Replacing xi+1 by x i+1 in those paths gives us paths at least as short valid in W i+1 . We then link them with S(x i+1 , a i+1 ) ∈ W i+1 , and get that dist</p><formula xml:id="formula_91">T i+1 ≡ &lt;-inv FO α T i and Supp n+1 (T i+1 ) = Supp n+1 (T i ). Let's show that T i+1 verifies (Q i+1 ): (Q i+1 ).</formula><formula xml:id="formula_92">Wi+1 (x j , x k ) ≤ l 1 + l 2 + 1 = l. (Q i+1 ).3 : let j = k &gt; i + 1, a j ∈ {x j , x j } and a k ∈ {x k , x k }.</formula><p>Suppose that there is a path (take a shortest witness) p of length ≤ 2n + 5 between g(a j ) and g(a k ) in T i+1 . Because of (Q i ).3, p cannot be valid in T i . Because of (Q i ).1, it cannot go through S(u i+1 , u i+1 ) or S(u i+1 , u i+1 ). Hence, it must go through S(g(x i+1 ), g(x i+1 )) or S(g(x i+1 ), g(x i+1 )). It cannot go through both, for otherwise we could replace g(x i+1 )Sg(x i+1 )Sg(x i+1 ) in p by g(x i+1 )Su i+1 Sg(x i+1 ) and get a path as short in T i . We can decompose p either as g(a j ) p1 g(a i+1 )Sg(x i+1 ) p2 g(a k ) or, if it goes through the S-edge in the other direction, as g(a j ) p1 g(x i+1 )Sg(a i+1 ) p2 g(a k ), with a i+1 ∈ {x i+1 , x i+1 } and p 1 , p 2 valid in T i , and of length ≤ 2n + 5. This is absurd since either p 1 or p 2 breaks (Q i ).3</p><p>We set Q := T r together with g, which have the desired properties.</p><p>Proposition 17. ∀α ∈ N, ∃l ∈ N, ∀m ∈ N, ∃n ∈ N, ∀M ∈ N, ∃K ∈ N such that for every abstract loop</p><formula xml:id="formula_93">U + ∈ L n+1 σ and every Q ∈ quasi-H n+1 σ such that |U | ≤ M , (l + 1) • [[E n+1 (U)]] &lt; [[E n+1 (Q)]</formula><p>] and such that for every (n + 1)-type χ that occurs in U, |Q| χ ≥ K, there exists</p><formula xml:id="formula_94">Q ∈ quasi-H m σ such that Q ≡ &lt;-inv FO α Q and [[E m (Q)]] = [[E m (Q )]] + [[E m (U)]]</formula><p>Proof. We can assume that m ≥ s(α). Let m 1 be given by Lemma 25 from m, D be given by Lemma 25 from m and M and n be given by Lemma 13 from m 1 . Set K</p><formula xml:id="formula_95">:= D + (l + 1)M We construct U l + , U l+1 + ∈ L n+1 σ , such that [[E n+1 (U l )]] = l • [[E n+1 (U)]] [[E n+1 (U l+1 )]] = (l + 1) • [[E n+1 (U)]] U l + ≡ &lt;-inv FO α U l+1 +</formula><p>Consider the FO-interpretation J (of arity 2 and depth d, independent of n) from the vocabulary Σ n+1 ∪ {N, &lt;} (where N is a unary relational symbol) to Σ n+1 ∪ {&lt;}, which, given a structure V + , returns J (V + ) as follows. For the sake of simplicity, we will name</p><formula xml:id="formula_96">1, • • • , r the elements of N V+ accordingly to &lt; V+ its universe is {1, • • • , r} × (V \ N V+ ) J (V + ) |= S((i, x), (j, y)) iff i = j and V + |= S(x, y) J (V + ) |= E((i, x), (j, y)) ∧ E((j, y), (i, x)) iff i = j and V |= E(x, y), or j = i + 1 and V + |= J 2 τ (x) and V + |= J 1 τ (y) for some τ for every τ , J (V + ) |= J 1 τ (i, x) iff i = 1 and V + |= J 1 τ (x)</formula><p>Hence, A can be decomposed as</p><formula xml:id="formula_97">U 1 • • • U p • V 1 • • • V q ,</formula><p>and such a decomposition can be transposed as in Claim 28 onto each</p><formula xml:id="formula_98">Y i , 0 &lt; i &lt; k, as Y i = Y i 1 • • • Y i p+q ,</formula><p>where all the Y i j , the U i , the V i and the W i are n-similar.</p><formula xml:id="formula_99">T = P • U 1 • • • U p • V 1 • • • V q A • W 1 • • • W p W • Y k-1 1 • • • Y k-1 p+q Y k-1 • • • Y 1 1 • • • Y 1 p+q Y1 B •S</formula><p>Now, we can use Case 2 with A := V q and derive that T is ≡</p><formula xml:id="formula_100">&lt;-inv FO α to P • U 1 • • • U p • V 1 • • • V q-1 • W 1 • • • W p • Y k-1 1 • • • Y k-1 p+q • • • Y 1 1 • • • Y 1 p+q • V q • S</formula><p>Repeating this operation p + q -1 times allows us to conclude that P</p><formula xml:id="formula_101">• A • B • S ≡ &lt;-inv FO α P • B • A • S.</formula><p>We are now ready to conclude the proof of Lemma 26. As in the proof of Lemma 27, we distinguish between two cases. Let n := o Σ 3 (α + c) where c is the depth of some FOinterpretation to be specified later on, and Σ := P σ ∪ {E, S, P 1/2 , P 3 , P 4/5 , P 6 } where P 1/2 , P 3 , P 4/5 and P 6 are new unary symbols. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Assume first that tp</head><formula xml:id="formula_102">-(x , x , x A ) = tp n T -(x B , x B , x C</formula><p>). Hence, we can apply Lemma 6, and get two orders &lt; AC (whose first elements are x , x , x A , x B , x B , x C ) and &lt; CA (whose first elements are x B , x B , x C , x , x , x A ) such that (T -, &lt; AC ) ≡ FO α+c (T -, &lt; CA ). Now, consider the FO-interpretation that adds a S-edge between u and v if either: P 1/2 (u) and v is either the first or the second element of &lt; u is the third element of &lt; and P 3 (v) P 4/5 (u) and v is either the fourth or the fifth element of &lt; u is the sixth element of &lt; and P 6 (v) and then forgets about P 1/2 , P 3 , P 4/5 and P 6 . Take c to be the depth of this FO-interpretation (which has arity 1). Note that the result of this Proof. Let n 0 be the maximum between the integers given by Lemma 26 and Lemma 27, and s(α).</p><p>Let n 1 be the integer given by Lemma 14 for n 0 . Because of the isomorphism between the n 1 -enriched supports, there is a trivial n 1pseudo-inclusion of P in Q. Thus, Lemma 14 yields some Q ∈ quasi-H n0+1 σ such that Q ≡ &lt;-inv FO α Q, Supp n0+1 (Q ) Supp n0+1 (Q) and some h which (n 0 + 1)-pseudo-includes P in Q and which respects S-siblings relation. Now, P is a hollow tree, hence has the matching endpoints property, and h must be surjective: this entails that Q has the matching endpoints property.</p><p>For the remainder of this proof, we will need to apply vertical-S-swaps to Q (and subsequent hollow quasitrees), even though it is not necessarily a hollow tree. However, the matching endpoints property ensures that the connected component R containing its root is a hollow tree.</p><p>We will only apply vertical-S-swaps in R; when we talk of the vertical-S-swap in Q , we mean the disjoint union of the vertical-S-swap in R and of the other connected components of Q .</p><p>A tree-prefix of P or Q is a substructure T which contains the root, is E-stable and such that if S(x, y) and y ∈ T , then x ∈ T .</p><p>Let t be a thread with matching endpoints whose parent is y and an element x. We say that x ≺ t if x y. If u is a thread we write t ≺ u if y ≺ z, where z is the S-parent of both of u's endpoints.</p><p>Let T 0 , • • • , T r be a sequence of tree-prefixes of P such that T 0 contains only the root of P, T r = P , and we go from T i to T i+1 by adding a single thread.</p><p>We construct a sequence of structures Q = Q 0 , • • • , Q r with the following properties:</p><formula xml:id="formula_103">Q i+1 ≡ &lt;-inv FO α Q i Supp n0+1 (Q i+1 ) = Supp n0+1 (Q i )</formula><p>T i is vertically-pseudo-included in Q i , that is for every node x and thread t of T i , if x is the parent of t in T i then x ≺ t in Q i . The smallest tree-prefix of Q i containing all the threads of T i is called the T i -pseudo-tree.</p><p>For i = 0, there is nothing to do: the root of P is vertically-pseudo-included in Q 0 = Q . From T i to T i+1 : we let t be the thread in T i+1 \ T i and let x be the parent of t.</p><p>If t is in the T i -pseudo-tree of Q i , then there exists some element y and some thread u in T i such that in T i , y is the parent of u, and in Q i , y ≺ t ≺ u. In Q i , let's call y the parent of u, u the thread whose parent is y, x the parent of t and t the thread whose parent is x. There are two cases to consider: If y ≺ x in P (c.f. Figure <ref type="figure" target="#fig_7">38</ref>). Then in Q i , we must have y ≺ x, and we can apply Lemma 26. Let Q i+1 be the n 0 -guarded vertical-S-swap between [y, x ] and [y , x] in Q i . Note that in the limit case where y is the parent of t (that is, x = y), we apply Lemma 27 instead of Lemma 26. Otherwise, x and y must be ≺-unrelated in Q i (c.f. Figure <ref type="figure" target="#fig_14">39</ref>). Note that because we work in a hollow tree, the conditions to apply Lemma 8 are met. Set Q to be the n 0 -guarded crossing-S-swap between x and x in Q i . Then, set Q i+1 to be the n 0 -guarded crossing-S-swap between y and y in Q .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1</head><label>1</label><figDesc>Figure 1 Example of track of degree 3. Each dashed arc represent a path.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4</head><label>4</label><figDesc>Figure 4 The crossing-S-swap between a and b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Let a, b, a , b ∈ R be such that E(a, b), E(a , b ), a, b and a , b appear in two different threads of R and such that {a, b, a , b } and End(R) are (2m + 3)-distant in Supp 0 (R). Furthermore, assume that tp m R (a, b) = tp m R (a , b ). Let R := R \ {E(a, b), E(a , b )} ∪ {E(a, b ), E(a , b)}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5</head><label>5</label><figDesc>Figure 5 Illustration of the m-guarded crossing-E-swap between ab and a b in R</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6</head><label>6</label><figDesc>Figure 6 Illustration of the m-guarded mirror-E-swap at [b, b ] in R</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7</head><label>7</label><figDesc>Figure 7 Illustration of the m-guarded segment-E-swap between [b, c] and [b , c ] in R</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8</head><label>8</label><figDesc>Figure 8 Illustration of the m-guarded contiguous-segment-E-swap between [b, a ] and [b , a ] in R</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 y</head><label>10</label><figDesc>Figure 10 y is on a thread disjoint from Im(h): we use a crossing-E-swap</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11</head><label>11</label><figDesc>Figure 11 y , y are between the images of two already included neighbors: we use a segment-Eswap</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12</head><label>12</label><figDesc>Figure12y , y, z , z and h(x ), x are on the same thread, in the same order: we use a contiguoussegment-E-swap to avoid a jump in the inclusion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>its domain is T , plus two new elements v xy and v yx for every x, y ∈ T such that T |= F (x, y) the interpretation of S is unchanged E is interpreted as the union of {(x, v xy ), (v xy , x), (v xy , v yx ), (v yx , v xy ), (v yx , y), (y, v yx )} for every x, y ∈ T such that T |= F (x, y) the interpretation of every P ∈ P σ is unchanged P -is interpreted as{v xy : x, y ∈ T, T |= F (x, y)} P | is interpreted as {v yx : x, y ∈ T, T |= F (x,y)} Intuitively, xF y has been transformed into the (symmetrical) gadget on four elements xE-E|Ey. This encoding allows the converse FO-interpretation to recover the orientation of the F -edges of T from I(T ) in a straightforward way. For all α ∈ N there exists s(α) ∈ N such that for all m ≥ s(α), and every hollow (m + 1)-quasitree R, if R is the m-guarded crossing-S-swap between a and b in R, then R ≡ &lt;-inv FO α R, and ∀x ∈ R, tp m+1 R (x) = tp m+1 R (x). Moreover R ∈ quasi-H m+1 σ and Supp m+1 (R ) = Supp m+1 (R).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>1 / 2</head><label>12</label><figDesc>and P R 3/4 are at distance &gt; m from a , a , b and b in R , we have that tp m R (a , a ) = tp m R (b , b ). We can therefore apply Lemma 6, and get two orders &lt; a a b b and &lt; b b a a such that (R , &lt; a a b b ) ≡ FO α+c (R , &lt; b b a a ). Now, consider the FO-interpretation that adds a S-edge between u and v if either: P 1/2 (u) and v is the first or the second element of &lt; P 3/4 (u) and v is the third or the fourth element of &lt; and then forgets about P 1/2 and P 3/4 . Take c to be the depth of this FO-interpretation (which has arity 1). Note that the result of this FO-interpretation on (R , &lt; a a b b ) is an ordered extension of R and its result on (R , &lt; b b a a ) is an ordered extension of R . This entails R ≡ &lt;-inv FO α R. Now, let x ∈ R, and let's show that tp m+1 R (x) = tp m+1 R (x). First, if x is at distance &gt; m + 1 of {a, a , a , b, b , b } in R, there isn't any change in its (m + 1)-neighborhood.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>(a , a ) and N m-d b R - (b , b ), with two S-edges joining a in the first to a , a in the second and two S-edges joining b in the first to b , b in the third, as depicted in Figure 15. These three parts are at distance ≥ 2 in R -, hence they are fully independent (no overlap, and no edge between the two except for S(a, a ), S(a, a ), S(b, b ) and S(b, b )). Likewise, we can partition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Lemma 9 .C</head><label>9</label><figDesc>For all α ∈ N there exists s(α) ∈ N such that for every m ≥ s(α) and every hollow (m + 1)-quasitree R, if R is either the m-guarded crossing-E-swap between ab and a b in R the m-guarded mirror-E-swap at [b, b ] in R the m-guarded contiguous-segment-E-swap between [b, a ] and [b , a ] in R</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 14</head><label>14</label><figDesc>Figure 14 Evolution of the neighborhood of x before and after a crossing-S-swap in the proof of Lemma 8. We see N m+1 R (x) on the left and N m+1 R (x) on the right.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>, and the possibly empty N m-d a R - (b ) and N m-1-d a -d b a R - (b ), with an E-edge joining b in the first to a in the second, an E-edge joining a in the first to b in the third, and an E-edge joining a in the third to b in the fourth (in the case they are non-empty).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>1 :</head><label>1</label><figDesc>a ). This case covers the instances where [b, a ] R n [b , a ] R n , as well as those where |[a, a ]| and |[a , a ]| are both &gt; 2n + 2. Consider the extension R of R -to Σ where P R = {a} and P R 4 := {b }. Since P R 1 and P R 4 are at distance &gt; n from {b, a , b , a } (this is guaranteed by Lemma 20, because we will make sure that s</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>n A (x , x , x A ) = tp n C (x B , x B , x C ). This case covers the instances where A and C are n-similar, as well as those where dist T (x, x A ) and dist T (x B , x C ) are &gt; 2n + 2. Consider the extension T -of P A B C S to Σ where P T - 1/2 := {x}, P T - 3 := {x A , x A }, P T - 4/5 := {x B } and P T - 6 := {x C , x C } Since P T - 1/2 , P T - 3 , P T - 4/5 and P T - 6 are at distance +∞ from A and C, tp n T</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>2 .Figure 34 T 1 .Figure 35 Figure 36</head><label>23413536</label><figDesc>Figure 34The swaps solving the case xB ≺ ϕ(xA) ≺ xC . The second operation swaps the segments between the dark nodes using Lemma 27.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>a 12 , d 12 (resp. a 21 , d 21 ) be the arity and depth of I 12 (resp. I 21 ), and set f (k) := a 12 g(a 21 k + d 21 ) + d 12 .</figDesc><table><row><cell>Assume now that A, B ∈ C 1 are such that A ≡ FO f (k) B.</cell><cell></cell></row><row><cell cols="2">Applying I 12 to both structures gives us I 12 (A) ≡ FO g(a21k+d21) I 12 (B).</cell></row><row><cell>Hence I 12 (A) ≡ &lt;-inv FO a21k+d21 I 12 (B), which yields A ≡ &lt;-inv FO k</cell><cell>B after applying I 21 .</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>1 is straightforward: we only need to note that the new S-edges appeared at distance≥ 2n + 4 from every A ∈ {{u i+2 }, {u i+2 , u i+2 }, • • • , {u r }, {u r , u r }}, in T i \ S(A).(Q i ).2 allows us to conclude (any path going through xi+1 in W i can now through x i+1 instead). Otherwise, (Q i ).1 ensures that it doesn't go through S(u i+1 , u i+1 ) or S(u i+1 , u i+1 ). Thus we can decompose this path in a sequence of two (since it's a shortest path) paths valid in T i , joined by either S(g(x i+1 ), g(x i+1</figDesc><table><row><cell>(Q i+1 ).2 : let j, k &gt; i + 1 and suppose that there is a path of length l ≤ 2n + 5 between</cell></row><row><cell>g(x</cell></row></table><note><p>j ) (and similarly for g(x j )) and g(x k ) in T i+1 , and consider a shortest such path. Let's show that dist Wi+1 (x j , x k ) ≤ l. If this path doesn't go through any of the new S-edges,</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>A thread is nothing other than a siblinghood when the quasitree is a tree.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This is an ease of notation; to be more precise, we should make the type of a jumping pair symmetrical.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>János Barát, Péter Hajnal, Yixun Lin, and Aifeng Yang. On the structure of graphs with path-width at most two. Studia Scientiarum Mathematicarum Hungarica, 2012.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Michael Benedikt and Luc Segoufin. Regular tree languages definable in FO and in FO mod . ACM Trans. Comput. Log., 2009.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Michael Benedikt and Luc Segoufin. Towards a characterization of order-invariant queries over tame graphs. J. Symb. Log., 2009.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>Hans L. Bodlaender and Joost Engelfriet. Domino treewidth. J.Algorithms, 1997.    </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>Michael Elberfeld, Marlin Frickenschmidt, and Martin Grohe. Order invariance on decomposable structures. In Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS, 2016.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>8 Martin Grohe and Thomas Schwentick. Locality of order-invariant first-order formulas. ACM Trans. Comput. Log., 2000</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>. 9 Frederik Harwath and Nicole Schweikardt. Regular tree languages, cardinality predicates, and addition-invariant FO. In 29th International Symposium on Theoretical Aspects of Computer Science, STACS,</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>2012.10 Frederik Harwath and Nicole Schweikardt. On the locality of arb-invariant first-order logic with modulo counting quantifiers. In Computer Science Logic,</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>CSL, 2013. 11 Leonid Libkin. Elements of Finite Model Theory. Texts in Theoretical Computer Science. An EATCS Series.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_11"><p>Springer, 2004.    12 Roger C Lyndon, Marcel-Paul Schützenberger, et al. The equation a M = b N c P in a free group.The Michigan</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_12"><p>Mathematical Journal, 1962. 13 Hannu Niemistö. On locality and uniform reduction. In 20th IEEE Symposium on Logic in</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_13"><p>Computer Science, LICS, 2005. 14 Nicole Schweikardt and Luc Segoufin. Addition-invariant FO and regularity. In Proceedings of the 25th Annual IEEE Symposium on Logic in Computer Science, LICS, 2010.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_14"><p>Thomas Zeume and Frederik Harwath. Order-invariance of two-variable logic is decidable. In Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS, 2016.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Note that the result of this FO-interpretation on (R , &lt; ba b a ) is an ordered extension of R and that its result on (R , &lt; b a ba ) is an ordered extension of R . This entails R ≡</p><p>, where each of these enriched segments is isomorphic to [b, a ] R n . We can then apply k + 1 times Case 1 and obtain R ≡ &lt;-inv FO α R as desired. 3. From now on, N ≥ l(2n + 2) + n for a large enough l to be chosen later on.</p><p>As we are not in Case 1, we can restrict our study to the cases where |[a, a ]| ≤ 2n + 2 (the cases where |[a , a ]| ≤ 2n + 2 can be treated similarly). We will need the following claim, which is based on the Lyndon-Schützenberger Theorem. </p><p>where all the U i , V i and W i are isomorphic.</p><p>Proof. Consider Θ n which maps [x, y] R n to the word [x, y] where each element is colored with its n-type in</p><p>The hypothesis guarantee u = w and uv = vw. Hence uv = vu. By Lyndon-Schützenberger Theorem, there must exist a word a and integers p, q such that u = w = a p and v = a q [12]. We can decompose</p><p>where all the U i , V i and W i are mapped to a by Θ n , hence are isomorphic.</p><p>Let φ be an isomorphism between the N -neighborhood of (a, b) and that of (a , b ). As |[a, a ]| ≤ 2n+2, a and b are in the N -neighborhood of (a, b): set x 0 := a and y 0 := b . Construct by induction x i+1 := φ(x i ) and y i+1 := φ(y i ) until i &gt; l. Our choice of N ensures that x i and y i are well defined as x i-1 and y i-1 remain in the N -neighborhood of (a, b). For all j ≤ l, X j := [y j-1 , x j ] R n is isomorphic to [b, a ] R n . Likewise, starting from (a , b ) instead of (a , b ), we show that there exist x 1 , y 1 , • • • , x l , y l such that for j ∈ <ref type="bibr">[1, l]</ref> (and with the convention that x 0 = a ), X j := [y j , x j-1 ] R n is isomorphic to [b, a ] R n . We distinguish several cases: a. Suppose that |[a , a ]| ≥ 2N . This ensures that all the (x i ) i≥1 , (y i ) i≥0 , (x i ) i≥0 and (y i</p><p>Let R 1 be the n-guarded contiguous-segment-E-swap between [b, x l-1 ] and [y l-1 , a ] in R (recall that a = x 0 ). If l is chosen large enough, namely l ≥ 2n + 4, this swap falls in Case 1 of this Lemma and therefore R 1 ≡ &lt;-inv FO α R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:27</head><p>In R 1 , [y l-1 , x l-1 ] R1 n (that is, the segment strictly between a and b ) is decomposed as</p><p>Now, let R 2 be the n-guarded contiguous-segment-E-swap between [y l-1 , a ] and [y 0 , x l-1 ] in R 1 .</p><p>By choice of l, this swap falls again in Case 1 of this Lemma. Thus,</p><p>n (the segment strictly between a and b ) is decomposed as</p><p>Hence R 2 = R , and we get R ≡ &lt;-inv FO α R.</p><p>b. Suppose now that |[a , a ]| &lt; 2N . Set s(α) := (2N +1)(2n+2)+n. Just as before (by replacing l with 2N +1), we define x 0 , y 0 , • • • , x 2N +1 , y 2N +1 and x 0 , y 0 , • • • , x 2N +1 , y 2N +1 , and accordingly, X 1 , • • • , X 2N +1 and X 1 , • • • , X 2N +1 that all are isomorphic to [b, a ] R n . Not all of the (x i ) 0≤i≤2N can be in [b , a ]. Let k be the smallest index such that x i / ∈ [b , a ] (we know that 1 ≤ k ≤ 2N ). If x k = a , we can conclude using Case 2. Otherwise, a, b, x k , y k , a , b , x k-1 , y k-1 must appear in that order in the thread.</p><p>n , consider the restriction of an isomorphism between X k and X k+1 to the final segments of length</p><p>We can now apply Claim 22, and get decompositions [b,</p><p>and such a decomposition can be transposed onto each</p><p>where all the Y i j , the U i , the V i and the W i are isomorphic. We can now decompose [b, a ] R n as</p><p>, where in R 1 , the segment strictly between a and b is</p><p>Repeating this operation p + q -1 times allows us to conclude that R ≡ &lt;-inv FO α R.</p><p>C S L 2 0 2 0 23:28 Order-Invariant First-Order Logic over Hollow Trees</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Lemma 9 for segment-E-swaps</head><p>The proof that ∀x ∈ R, tp m+1 R (x) = tp m+1 R (x) is done as for the contiguous-segment-E-swaps.</p><p>Let's now find s(α) ∈ N that guarantees the ≡ &lt;-inv FO α invariance of any m-guarded segment-E-swaps, for m ≥ s(α).</p><p>Let n := o Σ 2 (α + c) where c is the depth of some FO-interpretation to be specified later on, and Σ := P σ ∪ {E, S, P 1 , P 2 , P 3 , P 4 } where P 1 , P 2 , P 3 and P 4 are unary.</p><p>Let </p><p>). Hence, we can apply Lemma 6, and get two orders &lt; bcb c and &lt; b c bc such that (R , &lt; bcb c ) ≡ FO α+c (R , &lt; b c bc ). Now, consider the FO-interpretation that adds a symmetrical E-edge between u and v if either:</p><p>P 1 (u) and v is the first element of &lt; u is the second element of &lt; and P 2 (v) P 3 (u) and v is the third element of &lt; u is the fourth element of &lt; and P 4 (v) and then forgets about P 1 , P 2 , P 3 and P 4 . Take c to be the depth of this FO-interpretation (which has arity 1). Note that the result of this FO-interpretation on (R , &lt; bcb c ) is an ordered extension of R and that its result on (R , &lt; b c bc ) is an ordered extension of R . This entails R ≡ &lt;-inv FO α R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>We can now, without loss of generality, assume that |[a, c]| ≤ 2n + 2.</p><p>Let s be the threshold s(α) from the proof of contiguous-segment-E-swaps. Let us increase that threshold for it to account for segment-E-swaps: set s(α</p><p>for otherwise, we would be in the Case 1), there are only two subcases to consider: if a , b , ϕ(c), ϕ(d), c , d appear in that order, i.e. the segment strictly between a and d can be decomposed as:</p><p>This swap falls under the scope of Case 1 since</p><p>In R 1 , the segment strictly between a and d can be decomposed as:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:31</head><p>Let Sn-m m+1 (P) be the restriction of Supp m+1 (P) to elements that are at distance &gt; n -m from End(P)</p><p>Every intermediate structure Q will verify the following invariant:</p><p>As long as N is large enough, the hypothesis guarantees that Q verifies (1). Assume we have already constructed a partial (m + 1)-pseudo-inclusion h from P to Q where Q verifies <ref type="bibr" target="#b0">(1)</ref>. We show that we can construct a new hollow quasitree Q ∈ quasi-H m+1 σ verifying (1), using a sequence of E-swaps applied to Q in such a way that h can be extended by at least one element of P .</p><p>To this end, assume first that the domain of h is the union of a number of threads, each contained in its entirety (this is the case at the beginning). Let Im(h) denote the image of h. Let t be any thread of P not in the domain of h and let x be an endpoint of t. We want to extend h in order for its domain to contain x.</p><p>(1) ensures that there exists an endpoint y / ∈ Im(h) of a long thread of Q such that segtype n-m m+1,Q (y) = segtype n-m m+1,P (x). We don't modify Q and extend h by sending every z ∈ [x, x ] to the corresponding h(z) ∈ [y, y ] (where x , y are the elements at distance n -m of x, y in their threads). Every z and h(z) have the same (m + 1)-type, and</p><p>By construction, h is a partial (m + 1)-pseudo-inclusion mapping as desired.</p><p>Suppose now that the domain of h contains a set of (entire) threads and the initial segment of a thread t of P, that includes at least the points of t at distance ≤ n -m from its endpoint in the domain of h. Let x be the last element of t in the domain of h and x be the first element of t not in the domain of h. In particular we have E(x , x). Assume furthermore that x is at distance &gt; n -m from the other endpoint of t.</p><p>Since [[ Sn-m</p><p>there exists an element y ∈ Sn-m m+1 (Q ) \ Im(h) having the same (m + 1)-type as x. Let y be the image of x by an isomorphism between N m+1 P (x) and N m+1 Q (y). Let x be the image of x by an isomorphism between N m+1 P (x ) and <ref type="figure">,</ref><ref type="figure">y</ref>). If y = x, leave Q unchanged and let h map x to x. Otherwise, there are several cases to consider depending on the positions of y and y .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">if y is on a thread that does not intersect Im(h).</head><p>Let Q be the m-guarded crossing-E-swap between h(x )x and y y in Q . Extend h by setting h(x) to y (c.f. Figure <ref type="figure">16</ref>, in which Im(h) is represented as double lines). if y is between h(z) and h(z ) where z and z are consecutive node of the current thread t already in the domain of h and such that y is between h(z) and y (that is, they are in the right order for a segment-E-swap), c.f. Figure <ref type="figure">17</ref>.</p><p>Let u and u be the respective E-neighbors of h(z) and h(z</p><p>Let Q be the m-guarded segment-E-swap between [u , y ] and [h(z ), h(x )] in Q , and extend h by setting h(x) to y</p><p>Figure <ref type="figure">16</ref> An illustration of the progression in the (pseudo-)inclusion (case 2)</p><p>3. if y is between h(z) and h(z ) where z and z are consecutive nodes of the current thread t already in the domain of h and such that y is between y and h(z ) (that is, they are not in the right order for a segment-E-swap), c.f. Figure <ref type="figure">18</ref>. This means that y, y , h(x ), x appear in that order. Let R be the m-guarded mirror-E-swap at [y , h(x )] in Q In R, h(z), u , h(z ), u now appear in that order. Let Q be the m-guarded mirror-E-swap at [u , h(z )] in R and extend h by setting h(x) to y.</p><p>Figure <ref type="figure">17</ref> An illustration of the progression in the (pseudo-)inclusion (case 3)</p><p>4. if y is between h(z) and h(z ) where z and z are consecutive node in some thread different from t already in the domain of h (c.f. Figure <ref type="figure">19</ref>). Let R be the m-guarded crossing-E-swap between y y and h(x )x in Q Let Q be the m-guarded crossing-E-swap between h(z)u and uh(z ) in R, and extend h by setting h(x) to y.</p><p>An illustration of the progression in the (pseudo-)inclusion (case 4)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:33</head><p>5. if y is on the same thread as h(x ), such that h(x ), x, y, y appear in that order (c.f. Figure <ref type="figure">20</ref>). Then let Q be the m-guarded mirror-E-swap at [x, y] in Q and extend h by setting h(x) to y.</p><p>An illustration of the progression in the (pseudo-)inclusion (case 5)</p><p>6. finally if y is on the same thread as h(x ) but h(x ), x, y , y appear in that order. This is the case where we cannot achieve inclusion without extra hypothesis. For Proposition 12, we simply allow a "jump" and set h(x) to y without changing Q .</p><p>In the previous case analysis, in order to perform E-swaps, it was important for x (and therefore y) to be far away from the endpoint e of t that is not already in the domain of h. In order to conclude the proof of Proposition 13, it remains to consider the case where x is at distance n -m from e.</p><p>By hypothesis, there exists an endpoint a outside of Im(h) of a long thread such that segtype n-m m+1,Q (a) = segtype n-m m+1,P (e). Let ξ be the isomorphism between [e, x] and [a, y], where y is the element at distance n -m of a in its thread.</p><p>If a is not on the same thread as h(x ), let y be the E-neighbor of y not in [y, a]. We let Q be the m-guarded crossing-E-swap between h(x )x and y y in Q and extend h by setting h(u) to ξ(u) for all u in [x, e].</p><p>Otherwise, we don't modify Q and simply extend h by setting h(u) to ξ(u) for every u in [x, e]. Notice that there may be a jump between h(x ) and h(x).</p><p>This concludes the proof of Proposition 12. We now move to the proof of Proposition 13. We decompose U as P V , where P is the union of the threads of U whose endpoints were endpoints in the structure from which U is derived (that is, their type is a type of endpoint). We let P be (U ) |P and proceed as above with the threads of P.</p><p>It all works as above except for the two cases where we introduced a jump. Consider again the situation of Case 6. Our extra cardinality hypothesis ensures that there is a z = y verifying the same conditions as y (otherwise we would be in a previous case). Assume WLOG that h(x ), y, z appear in that order (c.f. Figure <ref type="figure">21</ref>).. Set Q to be the m-guarded contiguous-segment-E-swap between [x, y ] and [y, z ] in Q , and extend h by setting h(x) to y. h is now an inclusion.</p><p>An illustration of the progression in the inclusion (case 6, for Proposition 13)</p><p>We also introduced a jump when extending h to the endpoint of some thread. But the cardinality condition ensures that we have two endpoints</p><p>Hence at least one of them is on a different thread than h(x ) and the procedure described above yields an inclusion.</p><p>In order to conclude the proof of Proposition 13 it remains to extend the domain of h to V . This done in the exact same way but, as the threads of V may not include the endpoints, C S L 2 0 2 0 23:34 Order-Invariant First-Order Logic over Hollow Trees it gives rise to new cases. We use the same notations. Let t be the thread under investigation and let u be its first element in V . Note that u doesn't have to be an endpoint of t.</p><p>The first difference is in Case 6: it may be the case that there is no z verifying the same conditions as y. In this case, and if no previous case is applicable, it must be the case that such a z appear "before" h(u): that is, z, h(u), h(x ), y appear in that order. There are now two possibilities: as described in Figure <ref type="figure">22</ref>, z , z, h(x ) are in that order, where z is the image of x by an isomorphism mapping the neighborhood of x to that of z. Then set Q to be the m-guarded contiguous-segment-E-swap between [z, h(x )] and [x, y ] in Q , and extend h by setting h(x) to y.</p><p>An illustration of the progression in the inclusion of V, first completion of case 6</p><p>otherwise, z, z , h(x ) appear in that order (c.f. Figure <ref type="figure">23</ref>). Set Q to be the m-guarded mirror-E-swap at [z , h(x )] in Q , and extend h by setting h(x) to z. Notice that we have "reversed" the direction on the inclusion of the current thread but this isn't an issue since E is not oriented.</p><p>An illustration of the progression in the inclusion of V, second completion of case 6</p><p>The second difference is that it is now possible that none of the cases described above are applicable. In that situation, there must exist two nodes y and z "before" h(u) having the same type as x. If at least one of them (say z) is in reverse order (i.e. z, z , h(x ) appear in that order, c.f. Figure <ref type="figure">23</ref>) we proceed exactly as before.</p><p>Otherwise, it means that we can set Q to be (assuming WLOG that y, z, h(x ) appear in that order, c.f. Figure <ref type="figure">24</ref>) the m-guarded contiguous-segment-E-swap between [y, z ] and [z, h(x )] in Q and extend h by setting h(x) to y.</p><p>An illustration of the progression in the inclusion of V, if no previous case is applicable D Proofs for Section 5 (Tools for reorganizing S-edges)</p><p>and some (m+1)-pseudo-inclusion J. Grange and L. Segoufin 23:35</p><p>x and y are S-siblings in W, then so are h (x) and h (y) in Q .</p><p>Proof. We can assume that m ≥ s(α). N is to be fixed later, and will chosen such that 2N ≥ 2(2m + 3) + 1.</p><p>Let (x 1 , y 1 ), • • • , (x r , y r ) denote all the pairs of endpoints of threads of length ≤ 2N -1 of W (they must be S-siblings), and let (x r+1 , y r+1 ), • • • , (x s , y s ) denote the other pairs of S-siblings of W, in an arbitrary order.</p><p>We are going to construct a sequence of structures</p><p>For i = r, set Q r := Q and f r := h. Note that threads of Q of length ≤ 2N -1 must have matching endpoints. N is chosen large enough so that the last property holds (N := 2 + (2m + 3) + (m + 1) is enough).</p><p>Assume now that we have constructed Q i and f i as required. If</p><p>Otherwise, let z be the S-sibling of f i (x i+1 ), Z (resp. Y ) be the element at distance 2m+3 of z (resp. f i (y i+1 )) in Supp 0 (Q i ), and Z (resp. Y ) be the element at distance 2m + 4 of z (resp.</p><p>(witnessed by an isomorphism φ).</p><p>In particular, tp m Qi (Z, Z ) = tp m Qi (Y, Y ), and {Y, Y , Z, Z } and End(Q i ) are (2m + 3)distant in Supp 0 (Q i ) by choice of N .</p><p>We distinguish between two cases:</p><p>if Y, Y and Z, Z are in different threads. Let Q i+1 be the m-guarded crossing-E-swap between ZZ and Y Y in Q i (c.f. Figure <ref type="figure">25</ref>).  <ref type="figure">26</ref>).</p><p>In both cases, we define f i+1 as Φ • f i where Φ the permutation of Q i defined as φ on [z, Z], φ -1 on [f i (y i+1 ), Y ], and the identity elsewhere.</p><p>Lemma 9 guarantees that in both cases,</p><p>C S L 2 0 2 0 23:36 Order-Invariant First-Order Logic over Hollow Trees Furthermore, f i+1 (x i+1 ) and f i+1 (y i+1 ) are S-siblings, and it is straightforward to see that f i+1 is a (m + 1)-pseudo-inclusion, and that the other conditions are still respected.</p><p>In the end, Q := Q s and h := f s fit.</p><p>We will often need to state that several sets are far from each other. To this end we introduce the notion of scattering, which is a compact way of saying that. For a subset A of a structure R whose vocabulary contains the binary relation S, define R \ S(A) to be R minus all the S-edges adjacent to any element of A.</p><p>The following lemma will be useful in a couple of proofs. It gives a setting in which we can apply simultaneous crossing-S-swaps:</p><p>Proof. Recall from Note 7 that 2m + 5 provides a sufficient distance condition to apply a m-guarded crossing-S-swap.</p><p>We construct a sequence of structures</p><p>R s having the same (m + 1)-enriched support, where R i is the simultaneous crossing-S-swap between a j and b j in R for every j ≤ i.</p><p>Let's show by induction that for every i, R i verifies (P i ):</p><p>R verifies (P 0 ). Suppose that we have constructed R i and let R i+1 be the m-guarded crossing-S-swap between a i+1 and b i+1 in R i :</p><p>Let's show that R i+1 verifies (P i+1 ):</p><p>(P i+1 ).1 holds since the (2m + 4)-neighborhoods of the (a j ) j&gt;i+1 haven't seen any change, because of (P i ).1.</p><p>be elements of two different sets. (P i ).2 entails that x and y are each at distance ≥ m in R - i from each other and from B, and (P i ).1 implies (since x and y are at distance 1 of B) that they are at distance ≥ m in R i (hence in R - i ) from {a i+1 , a i+1 , a i+1 }. Hence, the swap doesn't affect their m-neighborhoods in R - i , and they are still at distance ≥ m from each other and from</p><p>i+1 of length ≤ m-1 from a to b or from a to x doesn't go through the new S-edges, hence is valid in R i and contradicts (P i ).1 (in the second case, because</p><p>(a i+1 , a i+1 ) ≥ m (and similarly for a i+1 and a i+1 ).</p><p>Suppose that there is a path of length ≤ m -1 in R - i+1 from a i+1 to a i+1 . This path is valid in R - i . Hence, there would be a "vertical loop" in</p><p>We set R := R s , which has the desired properties.</p><p>Proposition 15. For every α, m ∈ N, there exist N, d, D ∈ N such that, for every</p><p>Proof. We can assume that m ≥ s(α). We will first provide a non-necessarily reduced (m + 1)-pseudo-inclusion verifying those conditions, with m := 2m + 3, and then modify it as well as the underlying structure to get a fitting reduced (m + 1)-pseudo-inclusion.</p><p>For every n ∈ N (we will assign a value to n later on), there is a N such that, under the hypothesis, Lemma 14 yields R ≡ &lt;-inv FO α Q such that Supp n+2 (R) Supp n+2 (Q) and g which (n + 2)-pseudo-includes P in R and respects the S-siblings relation; we denote by V the complement of Im(g) in Q. This implies that two nodes having the same S-parent are both either in Im(g) (and are the two endpoints of the same thread) or in V .</p><p>We say that z ∈ V is misassociated if its S-children are in Im(g). Likewise, we say that g(x) is misassociated if its S-children are in V . The (n + 2)-type of this element is called the type of the misassociation. Note that the number of misassociations in V and in Im(g) is the same.</p><p>First, we deal with all but a bounded number of misassociations. There exists a M (which depends only on n) such that, if there are more than 2M misassociations, then we can find a misassociated element of V and one of Im(g) that have the same type, and are at distance ≥ 2(n + 1) + 5 from one another: this is because a hollow quasitree has degree at most 4. We can solve these misassociations by a (n + 1)-guarded crossing-S-swap, according to Lemma 8 and Note 7, which preserves Supp n+2 (R).</p><p>Once we've done that, we're left with at most M misassociations in V , and the same number in Im(g). Let (z 1 , g(x 1 ), g(x 1 )), • • • , (z r , g(x r ), g(x r )) be an arbitrary enumeration C S L 2 0 2 0 23:38 Order-Invariant First-Order Logic over Hollow Trees of the misassociated elements of V , together with their S-children (recall that x i and x i are S-siblings in P, and let x i be their S-parent).</p><p>Fix i between 1 and r. There exists a sequence x i = x 1 i , • • • , x si i of elements of P , such that, if we name x j i and x j i the S-children of x j i in P, for every j, g(x j i ) is the S-parent of g(x j+1 i ) and g(x j+1 i ), and g(x si i ) is misassociated ; let z i , z i ∈ V be its S-children, and rename y i := x si i for ease. This sequence is represented in Figure <ref type="figure">27</ref>.</p><p>V</p><p>For every j,</p><p>In the end, we get</p><p>)) Let B be the set containing the z i , the g(y i ), for 1 ≤ i ≤ r, and their S-children. Since we've bounded r by M and R is of degree 4, we can choose d and D large enough so that we are able to find t 1 , • • • , t r ∈ V and u 1 , • • • , u r ∈ Im(g), with respective S-children t i , t i and u i , u i , such that t i and u i are of type τ i (since z i ∈ V is of type τ i , there must be at least d elements of this type in Im(g) and D in V ), and such that</p><p>We can apply Lemma 24 with s = 2r, (a</p><p>This ensures that R (which is the simultaneous crossing-S-swaps between z i and t i and crossing-S-swaps between g(y i ) and</p><p>Note that we haven't added any new misassociated element in the process: the only misassociated elements in R are now the t i and the u i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Choose retrospectively n</head><p>Let x, y be distinct elements among them, and let's prove that dist R (x, y) ≥ 2m + 5. Suppose that's false, and consider a shortest path from x to y. It cannot be valid in R, hence it must go though at least one new S-edge, and the first one must be S(x, x ), with x being either</p><p>The only way to reach y from x in less than 2m + 4 is through a S-children y of y. Now, x = y, hence dist Supp 0 (R ) (x , y ) ≥ 2m + 3 (either they are endpoints of two different threads, either the thread they're both in doesn't have the matching endpoint property, which ensures that it is of length &gt; 2n + 1). We can thus apply Lemma 21, which states that the path of length ≤ 2m + 3 from x to y must go through either x or y. This contradicts the minimality hypothesis.</p><p>We can proceed to the sequence of m -guarded crossing-S-swap between u i and t i in R for every i.</p><p>After the r swaps, we end up with R ≡ &lt;-inv FO α Q, such that Supp m +1 (R ) Supp m +1 (Q), and with no misassociation left wrt g.</p><p>If the pseudo-inclusion g isn't reduced, we reduce it by eliminating one by one its redundant jumping pairs.</p><p>Seeing g as a m-pseudo-inclusion, we get that nodes involved in a jumping pair are at distance ≥ 2m + 3 from the endpoints in Supp 0 (R ).</p><p>Let {x, x } and {y, y } be two jumping pairs with the same type, and u , u (resp v , v) be the E-neighbors of g(x), g(x ) (resp. g(y), g(y )) in [g(x), g(x )] (resp. [g(y), g(y )]). We have that tp</p><p>) If their images are on two different threads (c.f. Figure <ref type="figure">28</ref>), we can perform two m-guarded crossing-E-swaps: first, the m-guarded crossing-E-swap between g(x)u and vg(y ) in R , and then the m-guarded crossing-E-swap between g(x)g(y ) and ug(x ) in the previous swap, after which {x, x } is no longer a jumping pair. If their images appear on the same thread in the order g(y), g(y ), g(x), g(x ) (c.f. Figure <ref type="figure">29</ref>), we can perform the m-guarded contiguous-segment-E-swap between [v , g(x)] and [u , u] in R , after which {x, x } is no longer a jumping pair.</p><p>Elimination of a jumping pair among two, with a contiguous-segment-E-swap</p><p>Otherwise, we can assume that the images appear in the order g(y), g(y ), g(x ), g(x) (c.f. Figure <ref type="figure">30</ref>). We can perform two consecutive m-guarded mirror-E-swaps: first the m-guarded mirror-E-swap at [v , g(x )] in R , and then (in order to reverse again the segment [g(y ), g(x )] into the initial direction) the m-guarded mirror-E-swap at [g(x ), u ] in the previous swap, after which {x, x } is no longer a jumping pair. In the end, we get Q ≡ &lt;-inv FO α Q, such that Supp m+1 (Q ) Supp m+1 (Q), and a reduced h that (m + 1)-pseudo-includes P in Q . Notice that during the transformation from g (which was misassociation-free) to h, we never created any misassociation. Hence, Q \ Im(h ) is S-stable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E</head><p>Proofs for Section 6 (Removing unnecessary material)</p><p>Let W + ∈ L n σ , and g be a n-inclusion from W to some R ∈ quasi-H n σ . Let R + be an extension of R to Σ n obtained in the following way. For every τ ∈ Type n σ <ref type="bibr" target="#b1">[2]</ref>, and i ∈ {1, 2}, such that there exists (a unique)</p><p>, where y i τ / ∈ Im(g) and E(g(x i τ ), y i τ ). The existence and unicity of such y i τ is guaranteed. This process is depicted in Figure <ref type="figure">31</ref>. Every other J i τ is interpreted as the empty set. We say that R + is the g-border-extension of R.</p><p>From an inclusion g (double line) of the previous V in R to the g-border-extension R+ Let I n be the FO-interpretation from the vocabulary Σ n to P σ ∪ {E, S}, which adds an E-edge between a and b if a = b, J i τ (a) and J i τ (b) for some i ∈ {1, 2} and τ , and then forgets about the (J i τ ) (i,τ ) . Every I n has arity 1 and depth 0. Hence for every k ∈ N and Σ n -structures A and B, A ≡</p><p>Proposition 16. For every α, n ∈ N, there exists N ∈ N such that for every P ∈ H σ , Q ∈ quasi-H n σ and reduced n-pseudo-inclusion h : P → Q, if V := Q \ Im(h) is S-stable then there exists some Q ∈ quasi-H n σ and a reduced n-pseudo-inclusion h :</p><p>Every thread of P is still sent on a single thread: indeed, for every jumping pair {x, x } for h, h (x) and h (x ) lie on the same thread. This is because in U + ∈ L n σ . All that's left to prove is that for every a ∈ R, tp n Q (a) = tp n Q (a). This follows from the fact that for every τ and i ∈ {1, 2}, the element of U + colored with J i τ and the element of V + coloured with J i τ (if they exist) have the same n-type, once again because U + ∈ L n σ .</p><p>We now turn to loop elimination. Our goal is to get rid of the extra material found outside of the image of the pseudoinclusion. For that, we make sure it is S-stable (Proposition 15), we minimize it (Proposition 16), then we include (Proposition 13) a great number a times this loop in Q. However, to be able to remove a copy while staying in the same ≡ &lt;-inv FO α -class, we need to recreate every of these loops to the original cape we included: recall indeed that the inclusion preserves the E-edges, but not necessarily the S-edges.</p><p>The following lemma gives a method to modify the including structure so that the pseudo-inclusion respects S-edges.</p><p>Proof. We can assume that n ≥ s(α). We'll assign values to m and N later on, in that order.</p><p>Keep in mind from Note 7 that a crossing-S-swap is guarded as long as it happens between elements of same type that are distant enough. First, we re-associate the S-edges going in/out of the images of every S-parent and S-child. The hypothesis on the number of excess occurrences of every type allows us to scatter their S-neighbors across the including structure. Recall that we introduced the notion of scattering in Definition 23.</p><p>Let's enumerate arbitrarily as (</p><p>First, we use Lemma 14 to find R ≡ &lt;-inv FO α Q such that Supp m+1 (R) Supp m+1 (Q) and g such that g : W → R is a (m + 1)-pseudo-inclusion that respects the S-siblings relation, for some m to be specified later on. This sets the value for N .</p><p>the existence of a k comes from the fact that g respects the S-siblings relation). Note that the minimal such B is Im(g) plus the S-children of every g(x i ) (if they are not already in Im(g)), plus the S-parent of every g(x i ), g(x i ) (if it's not already in Im(g)). This guarantees that s ≤ 2r.</p><p>Every hollow 1-quasitree has degree at most 4. In R, | Im(g)| ≤ M ; hence as long as D is large enough, there must exist elements (a i ) 1≤i≤s ∈ R, such that for every i, a i , a i being the S-children of</p><p>We are in the right conditions to apply Lemma 24, and get</p><p>Not all of the a i , a i , a i are of interest. We re-index them, and focus on u 1 , u 1 , u 1 , • • • , u r , u r , u r , where u i is the S-parent of g(x i ), g(x i ) and u i , u i are the S-children of g(x i ).</p><p>The scattering of the a i , a i , a i entails that</p><p>where, for every j &gt; i, S(x j , x j ) and S(x j , x j ) have been replaced by S(x j , x j ) and S(x j , x j ). There cannot be a path of length ≤ 2n + 5 from x j (or x j ) to x j , as long as N + 1 ≥ 2n + 5, for otherwise there would be a vertical loop in tp N +1 W (x j ).</p><p>for every τ , ) is the lexicographical order In other words, if we add r elements to the abstract loop U + , color them with N and add an order, its image by J is the r-fold concatenation of U + to itself (in the same direction each time), with an order.</p><p>Fix an arbitrary order &lt; U on U . For r ∈ N, let U</p><p>[r] + be the Σ n+1 ∪ {N, &lt;}-structure obtained by adding {1, • • • , r} to the universe of U + , interpreting N as {1, • • • , r} and ordering the elements as 1, • • • , r and then accordingly to</p><p>+ ). See Figure <ref type="figure">32</ref> for an example.</p><p>+ . In this illustration, two jumping pair types τ and ξ are relevant in U+. The new order &lt; 3 is the concatenation of the old ones If we choose l := 2 2α+d , we have</p><p>), and</p><p>], thus we can apply Proposition 13 to get</p><p>] and a (m 1 + 1)-inclusion h from U l+1 to R.</p><p>Now, for every (m 1 + 1)-type ξ occurring in</p><p>We can apply Lemma 25, which yields some R l+1 ≡ &lt;-inv FO α R such that Supp m (R l+1 ) Supp m (R), and g m-includes U l+1 in R l+1 , and respects S.</p><p>Let R l+1 + be the g-border-extension of R l+1 . Since g(U l+1 ) is S-stable in R l+1 , we can decompose R l+1 + \ {E(x, y) : x, y ∈ R l+1 , i ∈ {1, 2}, J i τ (x) ∧ J i τ (y)} as g(U l+1 + ) R + for some Σ n structure R + , where g(U l+1 + ) is the abstract loop based upon g(U l+1 ) such that g respects every J i τ . Note that R l+1 = I m (g(U l+1</p><p>+ ) R + ), and let</p><p>The notion of vertical swap in a tree has been introduced in [5] and is a crucial operation in their proof. We need here a version of these vertical swaps adapted to hollow trees. Unlike the other swaps, vertical-S-swap preserve hollow trees. In the following, T is a hollow tree on σ.</p><p>We start by defining classical notions making use of the tree structure of T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:45</head><p>The (strict) ancestor relation within a hollow tree is inherited from the original tree and is denoted by x y (resp. x ≺ y). Note that this relation is not part of the schema and not expressible in FO from E and S.</p><p>Let x, y be two nodes of T such that x ≺ y. We define the context C T (x, y) at x and y in T (referred using the simplified notation C in the following) as the substructure of T , and the suffix S T (x) at x in T as the substructure of T induced by {z ∈ T : x ≺ z} (here, the only additional relation is ). The concatenation between a prefix and a context, a prefix and a suffix, and a context and a suffix are defined in the natural way (and results respectively in a prefix, a hollow tree, and a suffix). Concatenation is associative. We start by proving a special case of Lemma 26. We will reduce the general case to it. This case is illustrated in Figure <ref type="figure">34</ref>.</p><p>Lemma 27. For all α ∈ N, there exists a M ∈ N such that the following holds. Let T ∈ H σ and x ≺ x A ≺ x B ∈ T having for respective S-children (x , x ), (x A , x A ) and Proof. We will first set N ∈ N instead of M , that will be sufficient for most cases. Then, we will define M ≥ N which will work for all cases.</p><p>Recall the function o Σ p introduced in Lemma 6, and consider n := o Σ 3 (α + c) where c is to be chosen later on, and Σ := P σ ∪ {E, S, P 1/2 , P 6 } where P 1/2 and P 6 are new unary symbols. We distinguish between several cases depending on whether x, x A and x B are close or not, where "close" is relative to n:</p><p>). This case covers the instances where A and B are n-similar, as well as those where dist T (x, x A ) and dist T (x A , x B ) are &gt; 2n + 2. Consider the extension T -of P A B S to Σ where the interpretation of P 1/2 only contains the bottom-anchor of P, and that of P 6 contains the top-anchors of S. Since P T - 1/2 and P T - 6 are at distance +∞ from A and B,</p><p>). Hence, we can apply Lemma 6, and get two orders &lt; AB (whose first elements are x , x , x A , x A , x A , x B ) and &lt; BA (whose first elements are x A , x A , x B , x , x , x A ) such that (T -, &lt; AB ) ≡ FO α+c (T -, &lt; BA ). Now, consider the FO-interpretation that adds a S-edge between u and v if either: P 1/2 (u) and v is either the first or the second element of &lt; u is the third element of &lt; and v is either its fourth or fifth one u is the sixth element of &lt; and P 6 (v) and then forgets about P 1/2 and P 6 . Take c to be the depth of this FO-interpretation (which has arity 1). Note that the result of this FO-interpretation of (T -, &lt; AB ) is an ordered extension of P • A • B • S and that its result on (T -, &lt; BA ) is an ordered extension of P</p><p>We can then apply k times Case 1 and obtain P</p><p>3. From now on, N ≥ l(2n + 2) + n for a large enough l to be chosen later on.</p><p>As we are not in Case 1, we can restrict our study to the cases where dist T (x, x A ) ≤ 2n+2 (the cases where dist T (x A , x B ) ≤ 2n + 2 can be treated similarly). We will need the following claims. The first one is just a simple observation. Claim 28. Let U, V be two n-similar contexts of T . For every decomposition U</p><p>Proof. Let ϕ be an isomorphism from Sk n (U) to Sk n (V), and</p><p>remains to show that for every i, U i and V i are n-similar. Again, the ≺-monotonicity of ϕ entails that ϕ(Sk n (U i )) ⊆ Sk n (V i ), which allows us to conclude.</p><p>The next one is a variant of Lyndon-Schützenberger Theorem stated for contexts of hollow trees instead of words.</p><p>Claim 29. Let n ∈ N, let T ∈ H σ , let x ≺ y ≺ z ≺ t be nodes of T , and let</p><p>where all the U i , V i and W i are n-similar.</p><p>Proof. We define θ n which maps two successive vertebrae x i ≺ x i+1 of a context U to the type tp n C U (xi,xi+1) (x i , x i , x i+1 ), where x i and x i are the S-children of x i . Now, let Θ n be the monoïd morphism from contexts to words extending θ n ; that is, if</p><p>By n-similarity of U and W, u = w, and by n-similarity of U • V and V • W, uv = vw. Hence uv = vu. By Lyndon-Schützenberger Theorem, there must exist a word a and integers p, q such that u = w = a p and v = a q [12]. We can decompose U, V and W alongside those decompositions of u, v and w, to get</p><p>where all the U i , V i and W i are mapped to a by Θ n , hence are n-similar.</p><p>Let φ be an isomorphism between the N -neighborhood of x and that of x A . As dist T (x, x A ) ≤ 2n + 2, x A is in the N -neighborhood of x and set x 0 := x A and x 1 := φ(x A ). Construct by induction x i+1 := φ(x i ) until i &gt; l. Our choice of N ensures that x i is well defined as x i-1 remains in the N -neighborhood of x. We claim that for all j ≤ l, X j := C T (x j-1 , x j ) is n-similar to A. This is a simple consequence of the fact that the n-skeleton of of X j is included into the N -neighborhood of x. C S L 2 0 2 0 23:48 Order-Invariant First-Order Logic over Hollow Trees Likewise, starting from x B instead of x A , we show that there exist y 1 , • • • , y l ∈ T such that for j ∈ [1, l] (and with the convention that y 0 := x B ), Y j := C T (y j , y j-1 ) is n-similar to A. We distinguish several cases: a. Suppose that dist T (x A , x B ) ≥ 2N . This ensures that all the (x i ) i≥1 and (y i ) i≥0 belong to B. Suppose x l-1 ≺ y l .</p><p>If we let C := C T (x l-1 , y l ), we can decompose B as X</p><p>If l is chosen large enough, namely l ≥ 2n + 4, the following decomposition of T</p><p>falls in Case 1 of this Lemma and therefore the following equation holds</p><p>Likewise, we get x. By n-similarity of A and Y k , and because dist T (x, x A ) ≤ 2n + 2, we know that height(A) = height(Y k ). Hence, it cannot be the case that y k x. We now have x ≺ y k ≺ x A ≺ y k-1 . Let U := C T (x, y k ), V := C T (y k , x A ) and W := C T (x A , y k-1 ). We have that U • V = A and V • W = Y k are n-similar. To see that U and W are n-similar, look at Y k+1 : there is a isomorphism ϕ from Sk n (Y k ) to Sk n (Y k+1 ), which is by definition ≺-monotonous on V (Y k ). Hence ϕ sends any vertebrate of Y k to the vertebrate of Y k-1 whose depth is height(A) smaller. This entails ϕ(x A ) = x, and by restricting ϕ, W and U are n-similar. We can now apply Claim 29, and get decompositions</p><p>where all the U i , V i and W i are n-similar. Otherwise, if x ≺ t in Q i , we set Q i+1 := Q i Otherwise, x and x are ≺-unrelated in Q i . Once again, we are in the right setting to apply Lemma 8 because we work in a hollow tree. Let Q i+1 be the n 0 -guarded crossing-S-swap between x and x in Q i .</p><p>In the end, we have vertically-pseudo-included P into Q r . Since they have the same support, the vertical-pseudo-inclusion is an isomorphism. Hence, P ≡ &lt;-inv FO α Q.</p><p>C S L 2 0 2 0</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<ptr target="http://webdam.inria.fr/Alice/" />
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Locality from circuit lower bounds</title>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dieter</forename><surname>Van Melkebeek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicole</forename><surname>Schweikardt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Luc</forename><surname>Segoufin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
