<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Coping with Incomplete Data: Recent Advances</title>
				<funder ref="#_WFTFYb9 #_jj9GxFJ">
					<orgName type="full">EPSRC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marco</forename><surname>Console</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Paolo</forename><surname>Guagliardo</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Leonid</forename><surname>Libkin</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Etienne</forename><surname>Toussaint</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">University of Edinburgh ENS-Paris</orgName>
								<orgName type="institution" key="instit2">PSL</orgName>
								<orgName type="institution" key="instit3">INRIA</orgName>
								<orgName type="institution" key="instit4">CNRS</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Coping with Incomplete Data: Recent Advances</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C5E56CC7E9ED3AF1EA7D49322E815AF1</idno>
					<idno type="DOI">10.1145/3375395.3387970</idno>
					<note type="submission">Submitted on 1 Feb 2021</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Theory of computation → Incomplete, inconsistent, and uncertain databases</term>
					<term>Database theory</term>
					<term>Logic and databases</term>
					<term>• Information systems → Incomplete data</term>
					<term>Data management systems</term>
					<term>Structured Query Language</term>
					<term>relational databases, incomplete information, certain answers, naive evaluation, approximate query answering, many-valued logics</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>come from teaching and research institutions in France or abroad, or from public or private research centers. L'archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Handling incomplete data in relational databases is a notoriously hard problem, where a large gap remains between theoretical and practical approaches. Commercial DBMSs, specifically SQL, have been heavily criticized for producing counter-intuitive and/or incorrect answers when handling incomplete data. One often finds statements like "those SQL features are . . . fundamentally at odds with the way the world behaves" <ref type="bibr" target="#b25">[25]</ref> or even "you can never trust the answers you get from a database with nulls" <ref type="bibr" target="#b24">[24]</ref>. Such behavior is often blamed on SQL's three-valued logic (3VL); indeed, programmers tend to think in terms of the familiar two-valued logic, while 3VL underlies the implementation of SQL's null-related features.</p><p>On the theory side, correctness is usually associated with the notion of certain answers, which are answers we can be sure about no matter how we interpret the incomplete information present in the database. That is, such answers are true in each possible world that an incomplete database represents. This approach, first proposed in the late 1970s <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b53">53]</ref>, is now dominant in the literature and it is standard in all applications where incomplete information appears (data integration, data exchange, ontology-based data access, data cleaning, etc.).</p><p>The gap between practice and theory is huge. SQL's designers had first and foremost efficient evaluation in mind, but correctness and efficiency do not always get along. Computing certain answers is coNP-hard even for relational calculus/algebra queries <ref type="bibr" target="#b0">[1]</ref>, i.e., likely to require super-polynomial time in terms of the size of the database. On the other hand, SQL evaluation is very efficient; it is in TC 0 (a small parallel complexity class).</p><p>If SQL cannot produce what is generally viewed as the correct answers, then what kinds of errors can it generate? To understand this, consider the simple database in Figure <ref type="figure" target="#fig_0">1</ref>, adapted from <ref type="bibr" target="#b38">[38]</ref>. It shows orders for books, information about customers paying for them, and basic information about customers themselves.</p><p>Decision support queries against such a database may include finding unpaid orders:</p><p>As expected, the first query produces a single answer o3, while the second returns the empty table. But now assume that just a single entry in these tables is replaced by NULL: specifically, the value of oid in the second tuple of Payments changes from o2 to NULL. Then the answers to queries change drastically, and in different ways: now the unpaid orders query returns the empty table, and the customers without a paid order query returns c2. Because of a single null, we can both miss answers and make up new answers! Specifically, if certain answers are the correct behavior of query answering over incomplete databases, then SQL evaluation can produce false negatives, i.e., miss some of the tuples that belong to certain answers, and can also produce false positives, i.e., return tuples that do not belong to certain answers. For example, c2 returned by the second query is a false positive. The unpaid orders query does not generate any false negatives: certain answers are actually empty since we cannot know which order was unpaid. But a simple query SELECT cid FROM Payments WHERE oid = 'o2' OR oid &lt;&gt; 'o2' returns only c1 in the database with NULL described above, while the certain answer is { c1, c2 }. Can this gap between theory and practice be bridged? In this paper, we survey some recent results whose goal is to do exactly that. Our survey will be structured along three main themes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Certainty of answers.</head><p>What does it even mean for an answer to be certain? The first definition was presented informally <ref type="bibr" target="#b35">[35]</ref> but then two alternative definitions quickly appeared <ref type="bibr" target="#b43">[43,</ref><ref type="bibr" target="#b53">53,</ref><ref type="bibr" target="#b54">54]</ref>. Everyone settled on one of them, from <ref type="bibr" target="#b43">[43,</ref><ref type="bibr" target="#b53">53]</ref>, which works for the model of relational databases as sets. According to this definition, certain answers are the intersection of query answers in all possible worlds. This definition has many shortcomings, and a more principled approach has been developed over the past few years, starting with <ref type="bibr" target="#b47">[47,</ref><ref type="bibr" target="#b49">49]</ref>. The key idea of the approach is to identify what we know about all query answers and then capture this knowledge with an object. The exact shape of certainty depends on how we formulate the knowledge, and which objects can be used to represent it. In particular, this shows that the largely forgotten approach of <ref type="bibr" target="#b54">[54]</ref> has many advantages. We survey this line of work in Section 3.</p><p>Exact and approximate query answering. We saw that SQL can give all kinds of wrong answers: false positives and false negatives. One question is for what classes of queries the standard query evaluation actually computes certain answers. This was known to work for unions of conjunctive queries but, as shown in <ref type="bibr" target="#b32">[32]</ref>, the class is actually much larger. We explain this in Section 4.1.</p><p>If certain answers cannot be computed precisely, the next best thing is to approximate them. There could be different approaches. One is to produce subsets of certain answers, i.e., eliminate false positives. This idea is not new: it was first explored more than 30 years ago <ref type="bibr" target="#b60">[60,</ref><ref type="bibr" target="#b67">67]</ref>. Those papers assumed the model of databases as logical theories and could not lead to implementations that would handle familiar relational databases with nulls.</p><p>The first approximation of certain answers to queries on databases with nulls was proposed in <ref type="bibr" target="#b51">[51]</ref>, but did not lead to an efficient implementation. A modification of it, on the other hand, was shown to behave well on benchmark queries <ref type="bibr" target="#b37">[37]</ref>. It was also more flexible and provided both no-false-positives and no-false-negatives approximations. This line of work is surveyed in Section 4.2.</p><p>Another type of approximation is probabilistic. The idea is to compute the probability that a tuple is an answer to the query on a randomly chosen possible world. The notion of choosing a possible world randomly is very close to the notion used in the study of asymptotic properties of logical sentences and 0-1 laws. The approach, proposed in <ref type="bibr" target="#b52">[52]</ref>, showed that "almost certainly true answers" (those that are correct with probability 1) are much easier to obtain computationally than certain answers. This is described in Section 4.3.</p><p>The role of many-valued logics. SQL uses a three-valued logic to evaluate queries in the presence of nulls. Motivated by this, we extend our techniques to many-valued logics and ask two different questions. The first is: under what conditions a manyvalued query evaluation is guaranteed to produce an approximation of certain answers? We provide a simple sufficient condition for that. We also show that SQL evaluation fails that condition, and explain the exact culprit in SQL's query evaluation. This line of work, originated in <ref type="bibr" target="#b51">[51]</ref>, and further developed in <ref type="bibr" target="#b19">[19]</ref>, is presented in Section 5.1.</p><p>The second question we ask goes even deeper: does SQL even need a three-valued logic? If it does, did SQL use the right one? Or could one have used the familiar two-valued Boolean logic all along? The answer to these questions is twofold. We explain that Kleene's three-valued logic, i.e., SQL's way to propagate truth values through connectives, is the right choice to handle incomplete information, if one wants to use the optimization algorithms implemented in DBMSs. However, going to predicate logics, i.e., the actual formalism underlying SQL, three-valued logic is not really needed, as it provides no additional expressive power compared to standard Boolean first-order logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BASIC CONCEPTS Incomplete databases</head><p>We consider incomplete databases with nulls interpreted as missing information. Below we recall definitions that are standard in the literature <ref type="bibr" target="#b43">[43,</ref><ref type="bibr" target="#b48">48,</ref><ref type="bibr" target="#b66">66]</ref>. Databases are populated by two types of elements: constants and nulls, coming from countably infinite sets denoted by Const and Null, respectively. Nulls are denoted by ⊥, sometimes with subscripts. If nulls can repeat in a database, they are referred to as marked, or labeled, nulls; otherwise one speaks of Codd nulls, which are the usual way of modeling SQL's nulls. Marked nulls are standard in applications such as data integration, data exchange and OBDA <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b45">45]</ref>, and they are more general than Codd nulls; hence we use them here.</p><p>A relational schema is a set of relation names with associated arities. In an incomplete relational instance D, each k-ary relation symbol R from the vocabulary is interpreted as a k-ary relation R D over Const ∪ Null. In other words, such a relation R D is a finite subset of (Const ∪ Null) k . Slightly abusing notation (when it does not lead to confusion) we will call it R as well.</p><p>The sets of constants and nulls that occur in a database D are denoted by Const(D) and Null(D), respectively. The active domain of D is dom(D) = Const(D) ∪ Null(D). If D has no nulls, we say that it is complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Valuations and query answering</head><p>A valuation v on a database D is a map v : Null(D) → Const that assigns constant values to nulls occurring in the database. By v(D) we denote the result of replacing each null ⊥ with v(⊥) in D. The semantics D of an incomplete database D is the set of all complete databases it can represent, i.e.,</p><formula xml:id="formula_0">D = {v(D) | v is a valuation} .</formula><p>This is known as the closed-world semantics of incompleteness, or semantics under cwa, or closed-world assumption <ref type="bibr" target="#b58">[58]</ref>. Semantics of incompleteness can also be defined under owa, or open-world assumption as</p><formula xml:id="formula_1">D owa = {complete D ′ | v(D) ⊆ D ′ for a valuation v} .</formula><p>A k-ary query is a map that, with a database D, associates a subset of k-tuples over its elements, i.e., a subset of dom(D) k . Queries in standard languages such as relational algebra, calculus, Datalog, etc., cannot invent new values, i.e., return constants that are not in the active domain. Such a query is called generic if it commutes with permutations of the domain of constants. That is, a query is</p><formula xml:id="formula_2">generic if Q π (D) = π Q(D) whenever π : Const → Const is a bijection.</formula><p>The class of generic queries will be denoted by GEN. All classes of queries considered in this survey, which do not mention elements of Const explicitly, are generic. Queries that mention constants are generic in a slightly weaker sense: Q π (D) = π Q(D) holds for every bijection π such that π (c) = c for each constant mentioned in the query. A Boolean query is a query of arity zero. There is only one tuple of arity zero, namely the empty tuple (). As usual, we associate false with the empty set , and true with the singleton {()} consisting only of the empty tuple. For Boolean queries, we can write alternatively Q(D) = true or D |= Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Query languages</head><p>As our basic query languages we consider relational calculus and its fragments. Relational calculus has exactly the power of first-order logic, or FO. The atomic formulae of FO are relational atoms R( x), equality atoms x = y, constant test const(x) and null test null(x), where const(x) is true iff x ∈ Const and null(x) is true iff x ∈ Null. FO formulae consist of all atoms above and are closed under conjunction ∧, disjunction ∨, negation ¬, existential quantifiers ∃, and universal quantifiers ∀. If x is the list of free variables of a formula φ, we write φ( x) to indicate this explicitly. We write | x | for the length of x.</p><p>Conjunctive queries (CQs, a.k.a. select-project-join queries) are defined as queries expressed in the ∃, ∧-fragment of FO. The class UCQ of unions of conjunctive queries is the set of formulae of the form φ 1 ∨ • • • ∨ φ m , where each φ i is a conjunctive query. In terms of its expressive power, this is the existential-positive fragment of FO, i.e., the ∃, ∨, ∧-fragment.</p><p>We shall use relational algebra, the procedural language equivalent to FO, that has the operations of selection σ , projection π , Cartesian product ×, union ∪, and difference -. Selection conditions θ are built according to the following grammar:</p><formula xml:id="formula_3">θ const(A) | null(A) | A = B | A = c | A B | A c | θ ∨θ | θ ∧θ</formula><p>where A and B are attributes, c is a constant, and const(A) and null(A) test whether the value of A is a constant or a null, respectively. As there is no explicit negation ¬, negating selection conditions means propagating negations through them, and interchanging = and , and const and null. So, for example, ¬ A = B ∧null(A) denotes the condition A B ∨ const(A). The fragment of relational algebra without the difference operator and inequalities ( ) in the selection conditions is referred to as positive relational algebra. Over complete databases, positive relational algebra has the same expressiveness of existential positive formulae (and thus UCQs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">WHAT ARE CERTAIN ANSWERS?</head><p>An incomplete database can be seen as a compact representation of many possible worlds. When answering queries on an incomplete database, one then wants to find query answers that are "certain", in the sense that they are true in all possible worlds represented by the incomplete database. We first formalize certain answers at an abstract level, and then look at them more specifically in the context of relational databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Query answering on incomplete databases</head><p>We follow the general framework of <ref type="bibr" target="#b49">[49]</ref> by considering databases as abstract "objects"; these could be relational databases, or graphs, or XML documents, or other. We will look at the relational setting in Section 3.2; here, to make clear the distinction with concrete relational databases, we denote database objects with lowercase letters x, y, and so on. For convenience of notation, we also use I D , C D , • D to refer to the set of incomplete objects, the set of complete objects, and the semantic function, respectively, of a database domain D.</p><p>The elements of x are referred to as the possible worlds of x. Intuitively, the more possible worlds a database object represents, the more ambiguous it is. To make this intuition formal, with each database domain D = (I, C, • ), we associate an information preorder ⪯ D (that is, a reflexive and transitive relation) on I, defined as follows: x ⪯ y iff y ⊆ x . That is, x ∈ I is less informative than y ∈ I if every possible world of y is also a possible world of x.</p><p>Given two database domains S (for source) and T (for target), a query from S to T is a mapping Q from C S to C T , i.e., it maps complete databases of a source database domain S to complete databases of a target database domain T. A natural way to define meaningful query answers on an incomplete database object x is to consider answers that are "true" in all possible worlds of x. To this end, for a set C of complete database objects, we let</p><formula xml:id="formula_4">Q(C) = Q(x) | x ∈ C .</formula><p>Then, to formalize the notion of truth, we assume, for each database domain, the existence of a set F of formulae expressing knowledge about incomplete objects, and a satisfaction relation |= indicating when a formula φ is true in a database object x, written x |= φ.</p><p>For a set X of database objects we write X |= φ if x |= φ for each x ∈ X . Similarly, for a set Φ of formulas, we write x |= Φ if x |= φ for each φ ∈ Φ. The theory of X is the set Th(X ) = {φ | X |= φ}, and the models of Φ are given by Mod(Φ) = {x | x |= Φ}. Intuitively, Th(X ) contains the knowledge we have about objects of X , and Mod(Φ) consists of all objects satisfying the knowledge expressed by Φ. When the database domain is not clear from the context, we will explicitly indicate it as superscript in Th by writing, e.g., Th D .</p><p>For a database domain D, we want the knowledge F to satisfy some minimal requirements, such as being compatible with the information pre-order ⪯ D , and being expressive enough to capture at least the semantics of incompleteness • D . To this end, we require that (a) for every φ ∈ F and every x, y ∈ I D , if x ⪯ D y and x |= φ then y |= φ; (b) for every x ∈ I D there exists a formula δ x ∈ F equivalent to Th(x) (i.e., Mod Th(x) = Mod(δ x )), furthermore if x ⪯̸ D y, then y ̸ |= δ x .</p><p>We are finally ready to define what is certainly true when answering queries on incomplete database objects. Definition 3.2. Let Q be a query from S to T, and let x ∈ I S . The certain knowledge of Q on x is the set Th T Q( x S ) . Thus, the certain knowledge of Q on x is the set of all formulae that are true in every possible world of x. However, in practice, we expect the answer to a query on a database object to be an object itself, ideally one that captures the entire certain knowledge of the query, that is, o ∈ I T such that Th T (o) = Th T (Q( x S ). Unfortunately, such an object need not exist in general. To overcome this issue, we define the certain answer as the most informative object (w.r.t. ⪯ T ) whose theory is a subset of the certain knowledge: Th T (o) ⊆ Th T (Q( x S ). Therefore, the definition of certain answers as an object is an under-approximation of the certain knowledge; the most informative one allowed by the database domain, but an approximation nonetheless. Definition 3.3. Let Q be a query from S to T, and let x ∈ I S . The information-based certain answer to</p><formula xml:id="formula_5">Q on x is cert O (Q, x) = Q( x S ) ,<label>(1)</label></formula><p>where the greatest lower bound is with respect to ⪯ T .</p><p>That is, the most informative object that is less informative than every possible answer. This notion satisfies the expected property of answers on incomplete databases: more informative query inputs yield more informative query answers.</p><p>Proposition 3.4 (see <ref type="bibr" target="#b49">[49]</ref>). Let Q be a query from S to T, and let x, y ∈ C S be such that x ⪯ S y.</p><formula xml:id="formula_6">If cert O (Q, x) and cert O (Q, y) exist, then cert O (Q, x) ⪯ T cert O (Q, y).</formula><p>Even though the certain answers as object are an approximation of the certain knowledge, this does not guarantee their existence. Next, we discuss this problem in the context of relational databases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Certain answers on relational databases</head><p>A relational database domain D is such that I D consists of relational databases populated with elements of Const∪Null, C D is the subset of I D of databases without nulls, and • D is either the cwa or owa semantics of incompleteness.</p><p>Under cwa, the facts stored in a database are assumed to be the whole truth. When used on the target domain of queries, this would provide a precise semantics for answers; however, in such a case, information-based certain answers may not exist even for very simple queries. The following result is implicit in <ref type="bibr" target="#b49">[49]</ref>. Proposition 3.5. Let S and T be relational database domains. If • T is the cwa semantics of incompleteness, then there exist a database D ∈ I S and a Boolean conjunctive query Q from S to T for which cert O (Q, D) does not exist.</p><p>To see this, consider the database D = {R(⊥)} and the Boolean query Q returning true iff R(2) belongs to the database. Then, the certain knowledge of Q on D is the set of formulae satisfied by both {()} (when ⊥ → 2) and (otherwise); therefore, this knowledge is empty and, under cwa, there exists no database whose theory is the empty set. The reason for this is that all facts in a database are true, but at the same time, under cwa, all other facts not in it are assumed to be false. So, the theory of the empty database is not empty under cwa.</p><p>To overcome this difficulty, we consider the owa semantics of incompleteness (see Section 2), under which the facts stated in a database are true but they are not assumed to be the whole truth. Thus, the more facts an answer contains, the more knowledge it provides. This fits in well with the idea of approximating query answers: then finding additional tuples in the answer makes approximations more informative. Also, with owa, unlike with cwa, the theory of the empty database is the empty set: Th( ) = . Therefore, as we shall see, the information-based certain answers exist for larger classes of queries.</p><p>In what follows, we implicitly consider queries from S to T, where S and T are relational database domains such that • T is the owa semantics of incompleteness. For the source domain S, either cwa or owa can be used: the former assumes we completely know the real world, while the latter allows for the possibility that we may be missing some facts. When this choice is relevant for the results, we indicate it by saying that a query, or class of queries, is "under cwa" (resp., under "owa"). Proposition 3.6 (see <ref type="bibr" target="#b3">[4]</ref>). The information-based certain answer (i.e., cert O ) always exists (a) for generic queries under cwa; (b) for unions of conjunctive queries under owa.</p><p>There are first-order queries for which the information-based certain answer does not exist under owa. Thus, owa on the source makes a huge difference in the class of queries for which the information-based certain answers exist. The reason for this is that we can find a first-order query Q and a database D (under owa) for which the certain knowledge contains infinitely many non-equivalent formulae. Then, for every finite answer database A whose theory is contained in this infinite set, we can always find a finite A ′ such that:</p><formula xml:id="formula_7">Th(A) ⊂ Th(A ′ ) ⊆ Th Q( D owa )</formula><p>and therefore the greatest lower bound does not exist.</p><p>Other notions of certain answers exist in the literature. The most common ones are intersection-based certain answers <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b53">53,</ref><ref type="bibr" target="#b60">60]</ref>, and certain answers with nulls <ref type="bibr" target="#b51">[51,</ref><ref type="bibr" target="#b54">54]</ref>. While these are specific to the relational domain, and therefore less general than informationbased certain answers, they have the advantage of existing for larger classes of queries.</p><p>Definition 3.7. The intersection-based certain answer to a query Q on a database D is the set:</p><formula xml:id="formula_8">cert ∩ (Q, D) = D ′ ∈ D S Q(D ′ ).</formula><p>(</p><formula xml:id="formula_9">)<label>2</label></formula><p>Observe that cert ∩ (Q, D) consists solely of constants. When the target domain of queries allows only for databases without nulls, the intersection-based certain answers are precisely the informationbased ones: Proposition 3.8 (see <ref type="bibr" target="#b3">[4]</ref>). Let S and T be relational database domains such that • S is under either owa or cwa, • T is under owa, and I T consists of databases without nulls. Then, for every generic query Q from S to T and for every database D ∈ I S , we have that cert O (Q, D) and cert ∩ (Q, D) exist and coincide.</p><p>One of the problems with intersection-based certain answers is that they only consist of constants and, for this reason, may miss tuples that are in fact certain. To see this, consider the database D = R(⊥) and the query Q that simply returns R. Then cert ∩ (Q, D) = , even though we are certain that ⊥ is in R no matter which missing value it represents. To overcome this shortcoming, nulls in certain answers can be allowed as follows: Definition 3.9. The certain answers with nulls to a query Q on a database D is the set:</p><formula xml:id="formula_10">cert ⊥ (Q, D) = t | v( t) ∈ Q(D ′ ) for every valuation v and for every D ′ ∈ v(D) S<label>(3)</label></formula><p>When the source relational database semantics is that of cwa, the definition becomes</p><formula xml:id="formula_11">cert ⊥ (Q, D) = t | v( t) ∈ Q v(D) for every valuation v .</formula><p>In the above example of D containing R(⊥), we have cert ⊥ (R, D) = {⊥}, i.e., we keep the certain information about ⊥ being in R. This is the way the definition was originally given in <ref type="bibr" target="#b54">[54]</ref>. The formulation of Definition 3.9 applies to other semantics, such as owa.</p><p>While cert ⊥ (Q, D) may contain nulls and constants, these may only come from dom(D). Thus, certain answers with nulls exist for every generic query Q and for every database D.</p><p>Unlike intersection-based certain answers, certain answers with nulls cannot be captured by the information-based ones. The reason for this is that the general framework of Section 3.1 cannot distinguish between the possible worlds of a database, whereas a valuation provides an "explanation" for each of them. Certain answers with nulls exploit this by ensuring that the same explanation that accounts for a possible world also accounts for a tuple being an answer on that possible world <ref type="bibr" target="#b3">[4]</ref>. They are also conservative over intersection-based certain answers, as the following proposition shows. Proposition 3.10 (see <ref type="bibr" target="#b51">[51]</ref>). Let S and T be relational database domains under cwa and owa, respectively. Let Q be an m-ary generic query from S to T, and let D ∈ I S . Then, for every valuation v, we have that</p><formula xml:id="formula_12">v cert ⊥ (Q, D) ⊆ Q v(D) cert ∩ (Q, D) = cert ⊥ (Q, D) ∩ Const(D) m .</formula><p>In light of this, we could conclude that certain answers with nulls are a better notion than information-based certain answers, as they exist for a larger class of queries and preserve explanations in the form of valuations. On the other hand, information-based certain answers, unlike certain answers with nulls, permit output values that were not in the input database; they could therefore prove very useful for investigating certainty for value-inventing queries, such as those involving aggregation or arithmetic operations. As the study of these non-generic queries is still in its infancy, here we focus on certain answers with nulls.</p><p>Complexity and size of certain answers. By definition, the information-based certain answer is the most informative database consistent with all query answers. Since answers are interpreted under owa, more informativeness means more tuples, which of course comes at a cost in space. Theorem 3.11 (see <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b5">6]</ref>). For generic queries, under the cwa semantics of input databases, the size of the information-based certain answer is at most doubly exponential in the size of the database. Moreover, under both owa and cwa interpretation of input databases, there exist a query Q ∈ UCQ and a database D for which the size of cert O (Q, D) is exponential in the size of D.</p><p>At the moment we do not know how to close the gap between the single-exponential lower bound and the double exponential upper bound for queries on cwa databases. This depends on some unresolved problems related to families of cores of graphs <ref type="bibr" target="#b41">[41]</ref>; see <ref type="bibr" target="#b3">[4]</ref> for more details.</p><p>On the other hand, as the certain answer with nulls consists only of tuples over the domain of the database, the size of cert ⊥ (Q, D) is at most polynomial in the size of D. However, computing it is intractable in data complexity under cwa, and undecidable (still in data complexity, i.e., for a fixed query) under owa. Theorem 3.12 (see <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b31">31]</ref>). Under owa, there exist a (fixed) firstorder query Q for which, given a database D and a tuple t, it is un-</p><formula xml:id="formula_13">decidable whether t ∈ cert ⊥ (Q, D) (resp., t ∈ cert O (Q, D)).</formula><p>Under cwa, there exist a (fixed) query Q ∈ UCQ such that deciding, given a database D and a tuple t,</p><formula xml:id="formula_14">whether t ∈ cert ⊥ (Q, D) (resp., t ∈ cert O (Q, D) is coNP-complete.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXACT AND APPROXIMATE COMPUTATION OF CERTAIN ANSWERS</head><p>Even for FO queries, computing certain answers is intractable. To find ways around this problem, we will now look at three different scenarios.</p><p>First, we look at cases when the standard efficient evaluation of FO queries produces certain answers. In such an evaluation, called naïve evaluation, nulls are simply treated as new constants.</p><p>Failing that, we look at rewriting queries, so that the rewriting Q ′ of Q returns a subset of the certain answers to Q. It turns out that surprisingly simple modifications of relational algebra queries can achieve this property.</p><p>Finally, we pass from absolute to probabilistic guarantees, and show that for a very large class of queries, including all FO queries, naïve evaluation returns answers which are almost certainly true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Naïve evaluation</head><p>The idea of naïve evaluation is simple: treat nulls as new values, and evaluate the query by using normal evaluation techniques on databases with nulls. For example, if we have a graph with edges {(1, ⊥ 1 ), (⊥ 1 , 2)} and we ask whether there exists a path from 1 to 2, say by a Boolean conjunctive query Q() :-R(1, x 1 ), R(x 1 , 2), then evaluating it naïvely amounts to changing ⊥ 1 to a new constant c, and then evaluating Q on the database {(1, c), (c, 2)}, which results in a positive answer. More precisely, we say that v : Null(D) → Const is a bijective valuation if it is a bijection and v Null(D) is disjoint from dom(D) and all the constants mentioned in q. Then</p><formula xml:id="formula_15">Q naïve (D) = v -1 Q v(D) .</formula><p>It is easy to see that for queries that are generic, i.e., that are invariant under permutations of the domain (see Section 2), this definition does not depend on the choice of a particular valuation v.</p><p>The question we address is the following: when will naïve evaluation produce certain answers, specifically certain answers with nulls? The early result goes back 35 years: Theorem 4.1 (see <ref type="bibr" target="#b43">[43]</ref>). For unions of conjunctive queries, nullfree tuples in the output of the naïve evaluation coincides with intersection-based certain answers under both cwa and owa semantics.</p><p>In other words, if Q is an m-ary query in UCQ, then Q naïve (D) ∩ Const(D) m = cert ∩ (Q, D). This was the state of the art for a long time, until <ref type="bibr" target="#b47">[47]</ref> remarked, using Rossman's preservation theorem <ref type="bibr" target="#b62">[62]</ref>, that the result is optimal for FO queries under owa semantics: Proposition 4.2. If naïve evaluation computes certain answers for an FO Boolean query Q under the owa semantics, then Q is equivalent to a union of conjunctive queries.</p><p>Th connection with Rossman's theorem saying that an FO sentence preserved under homomorphisms is equivalent to an existential positive sentence (and thus to a UCQ) suggested that naïve evaluation could be related to homomorphism preservation. Indeed, the semantics of incomplete databases can be formulated in terms of homomorphisms. We have D ′ ∈ D owa iff D ′ is complete and there is a homomorphism h : D → D ′ that is the identity on constants, that is, h(c) = c for all c ∈ Const(D). One can similarly restate the closed-world semantics: D ′ ∈ D iff D ′ is complete and there is a homomorphism h : D → D ′ that is the identity on constants and D ′ = h(D). Such homomorphisms are called strong onto homomorphisms.</p><p>Let us now look at databases (or more generally first-order relational structures) and connect homomorphism preservation and naïve evaluation more precisely.</p><formula xml:id="formula_16">A homomorphism from D to D ′ is a map h : dom(D) → dom(D ′ ) such that, for each tuple ā ∈ R D , the tuple h( ā) is in R D ′</formula><p>. A sentence (i.e., a Boolean query) φ is preserved under a class H of homomorphisms if D |= φ implies D ′ |= φ whenever there is a homomorphism h : D → D ′ from the class H .</p><p>With each class H of homomorphisms we can also associate a semantics D H that consists of all complete D ′ so that there is a homomorphism h : D → D ′ from H that is the identity on Const(D). When H consists of all homomorphisms, this gives us D owa , while for strong onto homomorphisms we get D . Theorem 4.3 (see <ref type="bibr" target="#b32">[32]</ref>). If H is a class of homomorphisms, then naïve evaluation computes certain answers with nulls to a query Q under the • H semantics if and only if Q is preserved under homomorphisms from H .</p><p>We now look at the specific case of FO queries, and three classes of homomorphisms which give rise to natural semantics of incompleteness, and for which we have preservation results. These are arbitrary homomorphisms, strong onto, and also onto, or surjective homomorphisms h : D → D ′ satisfying h dom(D) = dom(D ′ ). Note that this is not the same as strong onto. For example, with</p><formula xml:id="formula_17">D = {R(⊥ 1 , ⊥ 2 )} and D ′ = {R(1, 2), R(2, 1)}, the homomorphism h(⊥ 1 ) = 1, h(⊥ 2 ) = 2 is an onto homomorphism as h({⊥ 1 , ⊥ 2 }) = {1, 2}</formula><p>, but not strong onto since there is no tuple in D whose image would be (2, 1).</p><p>Note that standard results on preservation under homomorphisms <ref type="bibr" target="#b17">[17]</ref> are shown for arbitrary structures: finite and infinite. They are usually of the following kind: an FO sentence φ is preserved by a class H of homomorphisms iff φ is equivalent to a sentence ψ from a syntactic fragment FO H . In database theory we are of course interested in finite structures. Some of these results work in the finite case, but some do not. However, one direction always works: since sentences in FO H are preserved under homomorphisms from H , they are preserved under them on all structures, in particular finite ones. Hence, even if the results are not "if and only if" in the finite, they can still help us identify syntactic classes where naïve evaluation works. We now list what is known about homomorphism preservation for different classes of homomorphisms.</p><p>Preservation under arbitrary homomorphisms. It is known that an FO formula is preserved under arbitrary homomorphisms iff it equivalent to an existential positive formula, i.e., a formula in the ∃, ∧, ∨-fragment of FO. In other words, such formulae are precisely unions of conjunctive queries. This is true both for arbitrary structures, and for finite structures <ref type="bibr" target="#b62">[62]</ref>.</p><p>Preservation under onto homomorphisms. An FO formula is preserved under onto homomorphisms on arbitrary -finite and infinite -structures iff it equivalent to a positive formula, i.e., a formula in the ∃, ∀, ∧, ∨-fragment of FO, cf. <ref type="bibr" target="#b17">[17]</ref>. This fails however in the finite case <ref type="bibr" target="#b61">[61,</ref><ref type="bibr" target="#b64">64]</ref>: there are FO formulae preserved under onto homomorphisms over all finite structures that are not, over finite structures, equivalent to a positive formula.</p><p>Preservation under strong onto homomorphisms. We start with a sufficient condition using a class of positive formulae with universal guards, denoted Pos ∀G , first defined in <ref type="bibr" target="#b18">[18]</ref>. Formulae in Pos ∀G include all atomic formulae, and they are closed under ∧, ∨, ∃, ∀ and the following formation rule: if φ( x, ȳ) is a formula in Pos ∀G , and α( x) is an atomic formula, with all variables in x distinct, then</p><formula xml:id="formula_18">ψ ( ȳ) = ∀x α( x) → φ( x, ȳ) is a Pos ∀G formula.</formula><p>Formulae in Pos ∀G are preserved under strong onto homomorphisms <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b32">32]</ref>. Moreover, over arbitrary structures, they are exactly the FO formulae preserved under strong onto homomorphisms; however, like in the case of onto homomorphisms, the result does not hold for finite structures <ref type="bibr" target="#b16">[16]</ref>.</p><p>The class Pos ∀G has a natural description in terms of relational algebra: it consists of queries closed under selection, projection, Cartesian product, union, and division by a relation in the schema (or equality). Recall that for a relation S over attributes B 1 , . . . , B m and a relation R over attributes A 1 , . . . , A n , B 1 , . . . , B m , the division of R by S is a new relation R ÷ S over attributes A 1 , . . . , A n that consists of all tuples ā such that for each tuple b ∈ S, the tuple ( ā, b) is in R. This is very useful for expressing universal queries such as "find employees who participate in all projects". Theorem 4.4 (see <ref type="bibr" target="#b32">[32,</ref><ref type="bibr" target="#b49">49]</ref>). Naïve evaluation outputs certain answers with nulls for:</p><p>• unions of conjunctive queries under the owa semantics, and • Pos ∀G queries under the cwa semantics.</p><p>Thus, under the usual closed-world semantics, one can go well beyond unions of conjunctive queries and still produce certain answers with naïve evaluation. There is also an analog of this result for positive formulae and a weaker form of cwa semantics proposed in <ref type="bibr" target="#b59">[59]</ref>.</p><p>For full FO, or relational algebra, this is impossible: naïve evaluation still has very low AC 0 complexity, while finding certain answers is coNP-hard. One can easily give a direct example: {1} -{⊥} results in {1} under naïve evaluation, but the certain answers in this case are empty. Thus, next we shall see how to approximate certain answers for arbitrary relational algebra queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Approximations with absolute guarantees</head><p>When working with full relational algebra, due to the high complexity of computing certain answers, we must settle for approximations that can be computed efficiently. Although efficient, standard SQL evaluation may produce answers that are not certain, so we need alternative evaluation schemes that have correctness guarantees and tractable complexity. Definition 4.5. We say that a query evaluation algorithm has correctness guarantees for a query Q if for every database D it returns a subset of cert ⊥ (Q, D).</p><p>One such scheme was devised in <ref type="bibr" target="#b51">[51]</ref>. The main idea behind it is to translate a query Q into a pair (Q t , Q f ) of queries that have correctness guarantees for Q and its complement Q, respectively. That is, for every database D, the tuples in Q t (D) are certainly true, and the tuples in Q f (D) are certainly false:</p><formula xml:id="formula_19">Q t (D) ⊆ cert ⊥ (Q, D) (4a) Q f (D) ⊆ cert ⊥ (Q, D)<label>(4b)</label></formula><p>The translations of <ref type="bibr" target="#b51">[51]</ref> are shown in Figure <ref type="figure">2</ref>(a), where:</p><p>• Dom refers to the query computing the active domain, and ar(Q) denotes the arity of Q. So, Dom ar(Q ) refers to the Cartesian product Dom × • • • × Dom taken ar(Q) times. • The operator ⋉ ⇑ used in the rule R f is defined as a standard anti-semijoin where the join condition is unifiability of tuples: r and s are unifiable if there exists a valuation v of nulls such that v(r ) = v(s). • The translation θ * of selection conditions θ is obtained by replacing all comparisons of the form A x with -(A x) ∧ const(A), if x is a constant, and</p><formula xml:id="formula_20">-(A x) ∧ const(A) ∧ const(x), if</formula><p>x is an attribute name.</p><p>Theorem 4.6 (see <ref type="bibr" target="#b51">[51]</ref>). The translations of Figure <ref type="figure">2</ref>(a) have correctness guarantees: (4a) and (4b) hold for every relational algebra query Q and for every database D.</p><p>Moreover, both translations Q t and Q f have AC 0 data complexity, and Q t (D) = Q(D) for complete databases.</p><p>Thus, Q t has correctness guarantees and does not miss any answers on complete databases; moreover both Q t and Q f have good theoretical complexity. However, they suffer from a number of problems that hinder their practical implementation. Crucially, they require the computation of active domains and, even worse, their Cartesian products. While expressible in relational algebra, the Q f translations for selections, products, projections, and even base relations become prohibitively expensive. Indeed, they are already infeasible for very small databases: simple queries start running out of memory on instances with fewer than 10 3 tuples <ref type="bibr" target="#b37">[37]</ref>. Although several optimizations (at the price of missing some certain answers) have been suggested in <ref type="bibr" target="#b51">[51]</ref>, the cases of projection and base relations do not appear to have any reasonable alternatives.</p><p>To overcome the practical difficulties posed by the translations in Figure <ref type="figure">2</ref>(a), <ref type="bibr" target="#b37">[37]</ref> proposed an improved approximation scheme that comes with sufficient correctness guarantees and is implementationfriendly. The main idea is to avoid the translation Q f that underapproximates certain answers to the negation of the query. This is the principal source of complexity and, in the Q t translation, it is only used in the rule for difference: a tuple ā is a certain answer to</p><formula xml:id="formula_21">Q 1 -Q 2 if</formula><p>• ā is a certain answer to Q 1 , and • ā is a certain answer to the complement of Q 2 .</p><p>To avoid working with the complex Q f translation, the approach of <ref type="bibr" target="#b37">[37]</ref> uses a different rule: a tuple ā is a certain answer to</p><formula xml:id="formula_22">Q 1 -Q 2 if</formula><p>• ā is a certain answer to Q 1 , and • ā does not match any tuple that could possibly be an answer to Q 2 .</p><p>Following this intuition, a query Q is then translated into a pair (Q + , Q ? ) of queries where Q + has correctness guarantees for Q, and Q ? approximates possible answers to Q. The advantage of this is that the query Q ? is much simpler than Q f . For instance, for a base relation R, it will be just R itself, as opposed to the complex expression involving Dom.</p><p>The translations of <ref type="bibr" target="#b37">[37]</ref> are shown in Figure <ref type="figure">2</ref>(b). Note that the rule Q 1 -Q 2 + captures the intuition discussed earlier:</p><formula xml:id="formula_23">Q + 1 ⋉ ⇑ Q ? 2</formula><p>gives all the tuples r in Q + 1 for which there does not exist a tuple s in Q ?</p><p>2 such that r and s unify.</p><formula xml:id="formula_24">R t = R (Q 1 ∪ Q 2 ) t = Q t 1 ∪ Q t 2 (Q 1 -Q 2 ) t = Q t 1 ∩ Q f 2 σ θ (Q) t = σ θ * (Q t ) (Q 1 × Q 2 ) t = Q t 1 × Q t 2 π α (Q) t = π α (Q t ) R f = Dom ar(R) ⋉ ⇑ R (Q 1 ∪ Q 2 ) f = Q f 1 ∩ Q f 2 (Q 1 -Q 2 ) f = Q f 1 ∪ Q t 2 (σ θ (Q)) f = Q f ∪ σ (¬θ ) * Dom ar(Q ) (Q 1 × Q 2 ) f = Q f 1 × Dom ar(Q 2 ) ∪ Dom ar(Q 1 ) × Q f 2 π α (Q) f = π α (Q f ) -π α Dom ar(Q ) -Q f (a) Translations Q → Q t , Q f in</formula><p>the approximation scheme of <ref type="bibr" target="#b51">[51]</ref>.</p><formula xml:id="formula_25">R + = R (Q 1 ∪ Q 2 ) + = Q + 1 ∪ Q + 2 (Q 1 -Q 2 ) + = Q + 1 ⋉ ⇑ Q ? 2 σ θ (Q) + = σ θ * (Q + ) (Q 1 × Q 2 ) + = Q + 1 × Q + 2 π α (Q) + = π α (Q + ) R ? = R (Q 1 ∪ Q 2 ) ? = Q ? 1 ∪ Q ? 2 (Q 1 -Q 2 ) ? = Q ? 1 -Q + 2 σ θ (Q) ? = σ ¬(¬θ ) * Q ? (Q 1 × Q 2 ) ? = Q ? 1 × Q ? 2 π α (Q) ? = π α Q ? (b) Translations Q + , Q ?</formula><p>in the approximation scheme of <ref type="bibr" target="#b37">[37]</ref>.</p><p>Figure <ref type="figure">2</ref>: Approximation schemes with correctness guarantees for certain answers to relational algebra queries.</p><p>Theorem 4.7 (see <ref type="bibr" target="#b37">[37]</ref>). For the translations in Figure <ref type="figure">2</ref>(b), the queries Q + and Q ? are such that</p><formula xml:id="formula_26">Q + (D) ⊆ cert ⊥ (Q, D) and v Q + (D) ⊆ Q v(D) ⊆ v Q ? (D)<label>(5)</label></formula><p>for every database D and for every valuation v.</p><p>The theoretical complexity bounds for queries Q + and Q t are the same: both have the low AC 0 data complexity. However, the real world performance of Q + is significantly better, as it completely avoids large Cartesian products.</p><p>The good behavior of the translations in Figure <ref type="figure">2</ref>(b) was confirmed in <ref type="bibr" target="#b37">[37]</ref> by proof-of-concept experiments on the TPC Benchmark H <ref type="bibr" target="#b65">[65]</ref>. The results of that evaluation showed that the performance overhead of the rewritten queries is limited to a slowdown of 1-4% w.r.t. the original SQL queries. However, there are also cases where performance becomes an issue, even though this is mainly due to the poor way in which the query optimizers of commercial database systems handle disjunctions.</p><p>Bag semantics. As prescribed by the SQL Standard, relational database management systems use bag semantics in query evaluation. In a data model based on bags, the same tuple can occur more than once in a relation. The multiplicity (i.e., number of occurrences) of a tuple ā in a relation R is denoted by #( ā, R). Relational algebra operations under bag semantics are interpreted in a way that is consistent with SQL evaluation: for example, union adds up multiplicities, while difference subtracts them up to zero (see <ref type="bibr" target="#b22">[22]</ref> for further details).</p><p>In this context, instead of saying that a tuple is certainly in the answer, we have more detailed information: namely, the range of multiplicities of the tuple in query answers. This is captured by the following definitions, that extend the notion of certain answers with nulls:</p><formula xml:id="formula_27">□ Q (D, ā) = min # v( ā), Q(v(D)) | v is a valuation (6a) Q (D, ā) = max # v( ā), Q(v(D)) | v is a valuation (6b)</formula><p>When a query is evaluated under set semantics,</p><formula xml:id="formula_28">□ Q (D, ā) = 1 means that ā ∈ cert ⊥ (Q, D).</formula><p>For full relational algebra under bag semantics, the complexity of the bounds (6a) and (6b) mimics analogous results for set semantics. Thus, also in this case, we need to resort to tractable approximation schemes with correctness guarantees. In this respect, (5) suggests a natural extension of the correctness criterion for the translation scheme (Q + , Q ? ) of <ref type="bibr" target="#b37">[37]</ref>, as follows: Theorem 4.8 (see <ref type="bibr" target="#b20">[20]</ref>). When queries are interpreted under bag semantics, the translation</p><formula xml:id="formula_29">Q → (Q + , Q ? ) in Figure 2(b) satisfies # ā, Q + (D) ≤ □ Q ( ā, D) ≤ # ā, Q ? (D)<label>(7)</label></formula><p>for every database D and every tuple ā.</p><p>On the other hand, the translation of Figure <ref type="figure">2</ref>(a) loses its good theoretical complexity bounds and becomes intractable under bag semantics. A simple analysis of the definition of queries Q t , Q f in Figure <ref type="figure">2</ref>(a) shows that, for every tuple ā,</p><formula xml:id="formula_30"># ā, Q t (D) ≤ □ Q (D, ā) (8a) # ā, Q f (D) ≤ 1 + Q (D, ā) mod 2 (8b)</formula><p>This suggests a natural extension of the translation scheme (Q t , Q f ) to bags: we omit modulo 2 in (8b), since it is only needed to force multiplicities to be either 0 or 1. But this is problematic, as Q (D, ā) is intractable already for base relations <ref type="bibr" target="#b20">[20]</ref>. Thus, when we use bag semantics, implementing this approximation scheme in a real-life RDBMS (which is bag-based) is infeasible not only practically but also theoretically. The approximation scheme in Figure <ref type="figure">2</ref>(b) was tested in a commercial DBMS under bag semantics and compared against approaches that do not have correctness guarantees, that is, may return noncertain answers. That study <ref type="bibr" target="#b27">[27]</ref> found that, w.r.t. the ground truth, the Q + translation had obviously perfect precision (100%), but recall degraded quickly with the increase in the amount of incompleteness present in the database.</p><p>Approximation schemes based on conditional tables. Greco et al. <ref type="bibr" target="#b36">[36]</ref> proposed a number of approximation algorithms with correctness guarantees that make use of conditional tables, or c-tables for short; cf. <ref type="bibr" target="#b43">[43]</ref>. In such tables, each tuple t is associated with a condition φ that indicates when t holds; the pair ⟨ t, φ⟩ is referred to as a c-tuple. In this context, relational algebra operations are evaluated by taking into account the conditions associated with ctuples. For example, for every two input c-tuples ⟨r, φ 1 ⟩ and ⟨s, φ 2 ⟩, Cartesian product produces the output c-tuple ⟨r s, φ 1 ∧ φ 2 ⟩, where juxtaposition of tuples denotes concatenation. We refer the reader to <ref type="bibr" target="#b43">[43]</ref> for further details on the conditional evaluation of queries on c-tables.</p><p>The main idea of <ref type="bibr" target="#b36">[36]</ref> consists in converting a database D into a conditional database D ′ , where all conditions are true, to be used as the starting point for the conditional evaluation of queries. At each step of the query evaluation, the conditions associated with c-tuples can be manipulated and grounded, that is, reduced to either true (t), false (f) or unknown (u). Then, different evaluation strategies are obtained depending on how and when c-tuple conditions are handled. Given one such algorithm Eval, we let</p><formula xml:id="formula_31">Eval t ( Q, D) = t | ⟨ t, t⟩ ∈ Eval(Q, D) (9a) Eval p (Q, D) = t | ⟨ t, τ ⟩ ∈ Eval(Q, D), τ ∈ {t, u}<label>(9b)</label></formula><p>Then, Eval has correctness guarantees for a query</p><formula xml:id="formula_32">Q if Eval t (Q, D) ⊆ cert ⊥ (Q, D) for every database D.</formula><p>The four approximation algorithms proposed in <ref type="bibr" target="#b36">[36]</ref> are informally described as follows:</p><p>(1) Eager Eval e : conditions are grounded immediately after each relational algebra operator is applied. (2) Semi-eager Eval s : similar to the eager strategy, but in addition it also propagates equalities; e.g., the c-tuple ⟨⊥ 2 , ⊥ 1 = c ∧ ⊥ 1 = ⊥ 2 ⟩ would give ⟨c, u⟩ rather than the less informative ⟨⊥ 2 , u⟩. (3) Lazy Eval ℓ : equality propagation and grounding are only performed on the result of each difference operator, but postponed for all other operators. (4) Aware Eval a : equality propagation and grounding are postponed until the very end of query evaluation, and performed on a minimal rewriting of the conditions. Theorem 4.9 (see <ref type="bibr" target="#b36">[36]</ref>). For each ⋆ ∈ {e, s, ℓ, a}, the approximation algorithm Eval ⋆ has correctness guarantees for all relational algebra queries, and Eval ⋆ (Q, D) can be computed in polynomial time in the size of D, for every query Q and every database D. Moreover,</p><formula xml:id="formula_33">Q + (D) = Eval e t (Q, D)</formula><p>and Q ? (D) = Eval e p (Q, D) . All of the above approximation algorithms were implemented in a proof of concept system <ref type="bibr" target="#b28">[28]</ref>. However, the implementation is not integrated into a real DBMS, which makes it hard to compare the overhead of the algorithms w.r.t. the baseline performance of the original SQL queries, as done in <ref type="bibr" target="#b37">[37]</ref>. Another obstacle is the use of conditional tables, which seem to slowdown performance <ref type="bibr" target="#b27">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Approximations with probabilistic guarantees</head><p>Let us look again at the simple example of computing the difference R -S where R = {1} and S = {⊥}. While naïve evaluation gives us {1}, certain answers are empty. However, they are empty only because they have to account for the situation when ⊥ is interpreted as 1. In all other cases, the answer produced by the naïve evaluation is actually correct; if ⊥ can be interpreted as an arbitrary element of Const, then the chance of it being 1 is small. So it seems that naïve evaluation produces answers, in this case, that are very likely to be true. This is no accident; in fact, if we pick an interpretation of nulls uniformly at random and look at answers that are true with probability 1, they are precisely those that are returned by naïve evaluation. To make this intuition precise though, we must say what it means to pick a valuation at random. For a database D, we denote by V(D)</p><p>the set of all valuations on D. This set is infinite, and no uniform distribution can be defined on it. To pick v uniformly at random from V(D), we use the approach from the study of 0-1 laws and asymptotic behavior of logical properties, where one tries to define how likely a randomly chosen structure is to satisfy a given property <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b63">63]</ref>.</p><p>Given a query Q, a database D, and a tuple ā over dom(D), define the support of ā being an answer to Q on D as the set of all valuations that witness it:</p><formula xml:id="formula_34">Supp(Q, D, ā) = v ∈ V(D) | v( ā) ∈ Q v(D) .</formula><p>Supports thus measure how closely a tuple is to certainty. A tuple ā is in cert(Q, D) iff Supp(Q, D, ā) = V(D), i.e., the support includes all valuations. We then want to see how likely a randomly chosen valuation is to be in Supp(Q, D, ā).</p><p>For this, assume that the set of Const constants is enumerated as {c 1 , c 2 , . . .}. Define V k (D) as the set of valuations whose range is contained among the first k elements of this enumeration, i.e.,</p><formula xml:id="formula_35">V k (D) = v ∈ V(D) | range(v) ⊆ {c 1 , . . . , c k } . Let Supp k (Q, D, ā) be the restriction of Supp(Q, D, ā) to V k (D), i.e., Supp(Q, D, ā) ∩ V k (D). Then we define µ k (Q, D, ā) = |Supp k (Q, D, ā)| |V k (D)| as the proportion of valuations from V k (D) that belong to Supp(Q, D, ā). That is, µ k (Q, D, ā)</formula><p>is the probability that a valuation picked uniformly at random from V k (D) witnesses that ā is an answer to Q.</p><p>Finally, to eliminate the dependence on k, we look at the asymptotic behavior of this sequence:</p><formula xml:id="formula_36">µ(Q, D, ā) = lim k →∞ µ k (Q, D, ā) .</formula><p>This definition assumes some particular enumeration of the set Const. However, it is easy to see that the limit value µ(Q, D, ā) is independent of a particular enumeration for generic queries: once the set {c 1 , . . . , c k } contains all constants in Q and Const(D), the value µ k (Q, D, ā) does not depend on the remaining elements of this set, just their number. We then call a tuple ā an almost certainly true answer to</p><formula xml:id="formula_37">Q on D if µ(Q, D, ā) = 1.</formula><p>Theorem 4.10 (see <ref type="bibr" target="#b52">[52]</ref>). A tuple ā is an almost certainly true answer to a generic query</p><formula xml:id="formula_38">Q on D if and only if ā ∈ Q naïve (D). Furthermore, if ā Q naïve (D), then it follows that µ(Q, D, ā) = 0.</formula><p>In other words, we have a version of a 0-1 law: every tuple is either an almost certainly true or an almost certainly false answer. Note that finding almost certainly true answers is much simpler than finding certain answers: for example, for FO, the complexity is AC 0 instead of coNP. An analog of Theorem 4.10 can be shown when instead of counting valuations v witnessing v( ā) ∈ Q v(D) we count isomorphism types on V(D) witnessing the condition, i.e., the set of databases {v(D) | v ∈ V(D)} such that v( ā) ∈ Q v(D) . As distinct valuations may define the same isomorphism type, the ratio of databases in {v(D) | v ∈ V k (D)} such that v( ā) ∈ Q v(D) needs to be the same as the ratio of valuations V k (D) in Supp k (Q, D, ā), for any given k. The asymptotic behavior of these two sequences, however, is the same.</p><p>Let us now change the example a bit and assume that we have a relation T = {1, 2} and we look for answers to T -S under the inclusion constraint S ⊆ T . In this case, ⊥ can only take values 1 or 2, and thus the answer to Q is {1} with probability 1/2 and empty with probability 1/2. Can we use the framework to capture this?</p><p>It turns out that the framework is easily adaptable. In real life databases must satisfy integrity constraints, most commonly keys and foreign keys, which are special cases of functional dependencies and inclusion constraints (which in turn are special cases of equalityand tuple-generating dependencies). A set of constraints Σ can be viewed as a Boolean query, returning true if the constraints are satisfied and false if they are not. Most such constraints, at least those listed above, are generic Boolean queries.</p><p>We want to find the conditional probability µ(Q |Σ, D, ā) of ā being an answer to Q, given that Σ holds. In other words, choose a random assignment of constants to nulls; what is the probability that Q is true under the assumption that Σ is true? As above, we first define it for valuations with the range {c 1 , . . . , c k } and then analyze its asymptotic behavior. That is, define the probability that a randomly chosen valuation v with range(v) ⊆ {c 1 , . . . ,</p><formula xml:id="formula_39">c k } such that v(D) |= Σ also satisfies v( ā) ∈ Q v(D) , i.e., µ k (Q |Σ, D, ā) = |Supp k (Σ ∧ Q, D, ā)| |Supp k (Σ, D)|</formula><p>and then</p><formula xml:id="formula_40">µ(Q |Σ, D, ā) = lim k →∞ µ k (Q |Σ, D, ā)</formula><p>if such a limit exists. If the denominator |Supp k (Σ, D)| is zero, i.e., Supp k (Σ, D) = , adopt the convention that µ k (Q |Σ, D, ā) = 0. Again, it is easy to show that for generic Q and Σ the value µ(Q |Σ, D, ā) does not depend on a particular enumeration of Const.</p><p>Our earlier example showed that µ(Q |Σ, D, ā) could be a number between 0 and 1, namely 1/2. In general, if the 0-1 law fails, the next best thing we can hope for is convergence, i.e., the existence of the limit. Theorem 4.11 (see <ref type="bibr" target="#b52">[52]</ref>). If both Σ and Q are generic, then for every database D and for every tuple ā over the domain, µ(Q |Σ, D, ā) exists and is a rational number in [0, 1].</p><p>Moreover, every number in Q ∩ [0, 1] appears as µ(Q |Σ, D, ā) for a conjunctive query Q and an inclusion constraint Σ.</p><p>In some cases, µ(Q |Σ, D, ā) can only take values 0 or 1. For example, this is so if Σ contains only functional dependencies. In fact in this case µ(Q |Σ, D, ā) = µ(Q, D Σ , ā), where D Σ is the result of chasing D with Σ.</p><p>To describe the complexity of computing µ(Q |Σ, D, ā) note that, as a rational number, it is represented by a pair (p, r ) with p, r ∈ N. Hence computing it is a problem in a function class (rather than a complexity class capturing decision problems), and amounts to computing two numbers. The exact complexity happens to be FP #P , which is the class of functions computable in polynomial time with an access to a #P oracle. Furthermore, there are cases when µ(Q |Σ, D) = p/r such that r can be computed in polynomial time while computing p is #P-hard. </p><formula xml:id="formula_41">∧ t f u t t f u f f f f u u f u ∨ t f u t t t t f t f u u t u u ¬ t f f t u u</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">MANY-VALUED LOGICS FOR INCOMPLETE INFORMATION</head><p>The high complexity of certain answers is unsuitable for real-world query evaluation. The approach most broadly taken, in particular by SQL-based relational DBMSs, is to introduce small and easily implementable modifications to how queries are evaluated, so as to handle incomplete information expressed via null values. SQL's approach, in particular, introduces an additional truth value Unknown (u) to provide extra information about our knowledge of the results produced by operations involving nulls. The truth value u is assigned to comparisons involving nulls, such as 1 = NULL, and it is then propagated through the Boolean connectives ∧, ∨, ¬ using the truth tables in Figure <ref type="figure" target="#fig_2">3</ref>. This particular propositional logic, known as Kleene's logic <ref type="bibr" target="#b13">[13]</ref>, underlies SQL implementations <ref type="bibr" target="#b25">[25]</ref>. More generally, a propositional many-valued logic is a pair (T, Ω), where T is a set of truth values, and Ω is a set of functions ω : T n → T called connectives. The most common of those are ∧, ∨, ¬, but to model SQL properly we need to add one more, as we shall see later. In the familiar two-valued Boolean logic, denoted by L 2v , the set T contains just t (true) and f (false), and the truth tables are the standard ones (in fact, the restriction of those in Figure <ref type="figure" target="#fig_2">3</ref> to {t, f}). In Kleene's logic, denoted by L 3v , the set T is {t, f, u}.</p><p>Database query languages are based on predicate logic, which means that we need to define many-valued first-order logics. Normally, in FO, we have the notion of D |= φ( ā), i.e., a formula φ( x) is true in D if its free variables are interpreted as ā. That means φ( ā) is assigned the truth value t; alternatively, when φ( ā) does not hold, it is assigned truth value f. In a many-valued logic, φ( ā) can be assigned any truth value from T.</p><p>For a propositional logic L, a first-order many-valued logic is a pair (FO(L), • ) where FO(L) is the language of first-order formulae built over the connectives of L, and • is a semantics for FO(L) formulas. That is, for each formula φ( x), database D, and assignment ā of elements of dom(D) to the free variables x of φ, the semantics φ D, ā is a value in T. We assume that such semantics follows the syntax of the connectives, that is,</p><formula xml:id="formula_42">ω(φ 1 , . . . , φ n ) D, ā = ω φ 1 D, ā, . . . , φ n D, ā<label>(10)</label></formula><p>for every n-ary connective ω of L, and</p><formula xml:id="formula_43">∃x φ( x) D, ā = a ∈dom(D) φ D,( ā,a)<label>(11)</label></formula><p>and likewise for ∀x φ with used in the place of .</p><p>We now discuss recent developments on the use of many-valued logics to deal with databases with incomplete information. In Section 5.1, we examine the work of <ref type="bibr" target="#b51">[51]</ref> and <ref type="bibr" target="#b19">[19]</ref> about refining query answers using many-valued logics. In Section 5.2, we consider the many-valued logic underlying SQL, and present results from <ref type="bibr" target="#b21">[21]</ref> showing that it does not add expressiveness beyond the usual Boolean logic, despite the generally held belief that it does.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Correctness of many-valued evaluation procedures</head><p>When does the semantics of first-order many-valued logic produce correct answers? To answer this question, we assume that there is a notion of correct answers, given by a function Answ (φ) D, ā that produces a truth value τ ∈ T. For example, one may want to impose Answ (φ) D, ā = t if ā ∈ cert ⊥ (φ, D) stating that correct true answers are certain answers with nulls.</p><p>To state our assumptions on Answ (•) and explain when the semantics • gives rise to an evaluation procedure for such answers, we need a basic concept related to many-valued logics, namely a knowledge order ⪯ L on truth values of the propositional logic L; see <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b33">33]</ref>. While truth values can be ordered by the degree of truth they provide (in this case, t is more true than f), in the many-valued context they can also be ordered by the degree of knowledge they provide. In L 3v , the natural such ordering is u ⪯ L t and u ⪯ L f. Note that f and t are incomparable: each of them provides complete knowledge, while u has less knowledge than either. Such knowledge orderings exist for many other many-valued logics, and they have been an object of extensive study, especially in connection with paraconsistent logics (see, e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>). One common assumption is the existence of a least element for ⪯ L , denoted by τ 0 ; for L 3v , this is u. Intuitively, τ 0 represents the no-information value, i.e., the fall-back position when we cannot assign any value carrying real information.</p><p>The semantics • has correctness guarantees for query answers Answ (•) if whenever φ D, ā = τ and τ τ 0 , then Answ (φ) D, ā = τ . Intuitively, for every meaningful truth value τ , the semantics of formulae has to agree with the correct answers. In cases when it cannot capture the correct answers precisely, it has to resort to the no-information truth value τ 0 .</p><p>To ensure correctness guarantees we need two conditions, for each n-ary propositional connective ω of L.</p><p>(1) The notion of correct answers must respect the propositional logic</p><formula xml:id="formula_44">L. That is, if Answ (φ i ) D, ā = τ i for 1 ≤ i ≤ n, then Answ ω(φ 1 , . . . , φ n ) D, ā = ω(τ 1 , . . . , τ n )</formula><p>as long as all the truth values are not the bottom truth value τ 0 . (2) The logic L must respect the knowledge order. That is, if</p><p>we have truth values such that</p><formula xml:id="formula_45">τ 1 ⪯ L τ ′ 1 , . . . , τ n ⪯ L τ ′ n , then ω(τ 1 , . . . , τ n ) ⪯ L ω(τ ′ 1 , . . . , τ ′ n ).</formula><p>Theorem 5.1 (see <ref type="bibr" target="#b19">[19]</ref>). Assume that L respects the knowledge order, and that the notion of correct answers respects L, as defined above. If • has correctness guarantees for atomic formulae, then it has correctness guarantees for all FO formulae.</p><p>The results in <ref type="bibr" target="#b19">[19]</ref> are actually more general and establish the lifting criterion for a wider range of semantics. They also show how to define query answers for arbitrary queries, not only FO, in a way that more informative answers are obtained on more informative inputs.</p><p>Data complexity too is lifted from atomic to arbitrary formulae: if • has NC 1 data complexity for atomic formulae, then it has NC 1 data complexity for all FO(L). Moreover, NC 1 can be replaced by AC 0 data complexity if both ∧ and ∨ are idempotent in L.</p><p>Correctness for Kleene's logic. Now, for SQL's many-valued logic L 3v , we give a concrete example of a semantics for FO(L 3v ) with correctness guarantees. As the notion of correctness we take certain answers with nulls:</p><formula xml:id="formula_46">Answ (φ) D, ā =          t ā ∈ cert(φ, D) f ā ∈ cert(¬φ, D) u otherwise</formula><p>First look at the standard two-valued semantics of atomic formulae, that is:</p><formula xml:id="formula_47">R( x) bool D, ā = t ā ∈ R D f ā R D ; x = y bool D,(a,b) = t a = b f a b<label>(12)</label></formula><p>This does not have correctness guarantees. Consider D with the fact R(1, ⊥). Then for ā = (1, 1) we have R( x) bool D, ā = f which, if we had correctness guarantees, would have implied ā ∈ cert ⊥ (¬φ, D). However, the valuation v(⊥) = 1 shows that ā cert ⊥ (¬φ, D)</p><p>Thus, we need a more refined procedure to ensure correctness. By Theorem 5.1, we only need to provide the semantics of atomic formulae. For this, recall the notion of unification of two tuples r and s: they are unifiable, written r ⇑ s, if there is a valuation v such that v(r ) = v(s). This is known to be checkable in linear time <ref type="bibr" target="#b57">[57]</ref>. We then define the three-valued semantics as follows:</p><formula xml:id="formula_48">R( x) unif D, ā =          t ā ∈ R D f b ∈ R D such that ā ⇑ b u otherwise (13a) x = y unif D,(a,b) =          t a = b f a b and a, b ∈ Const u otherwise (13b)</formula><p>The first rule says that ā R D is not yet enough to declare the truth value of R( ā) to be f. There may be a tuple b ∈ R D unifiable with ā, and thus in some possible world given by a valuation v we may have v( ā) ∈ v(R D ). Thus, only when there is no tuple in R D that unifies with ā can we say with certainty that R( ā) is false. The same reasoning for equalities tells us that we can only be sure that a b when both a and b are different constants. Otherwise, if a and b are different, we need to assign truth value u to their comparison.</p><p>Corollary 5.2 (see <ref type="bibr" target="#b51">[51]</ref>). The • unif semantics has correctness guarantees with respect to certain answers with nulls:</p><formula xml:id="formula_49">if φ unif D, ā = t , then ā ∈ cert ⊥ (φ, D) .</formula><p>Moreover, φ unif D, ā can be computed with AC 0 data complexity.</p><p>If one can have three-valued evaluation procedures with correctness guarantees, then why SQL does not provide them? We shall explain this in the next section; for now we offer a simple example. Given three unary relations R, S, T , all with a single attribute A, let Q compute R -(S -T ): If R D = S D = {1} and T D = {⊥}, we have Q(D) = {1}. However, 1 is not a certain answer, and moreover µ(Q, D, 1) = 0. Even with available correct three-valued procedures, SQL can give answers that not only fail to be certain, but do so with probability 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Does SQL need many-valued logics?</head><p>Much of the criticism towards SQL revolves around its behavior with incomplete information, that is, with null values. As we explained earlier, SQL operates with Kleene's logic L 3v , having truth values t, f, and u (i.e., unknown). This was a decision of the committee that designed the language, and we now address the following questions:</p><p>• Was Kleene's logic the right choice for handling incomplete information?</p><p>• Does it add any extra expressiveness compared to the usual Boolean logic for FO queries?</p><p>In what follows, we give a brief account of the results from <ref type="bibr" target="#b21">[21]</ref> that provide answers to these questions -yes and no, respectively.</p><p>Propositional logic for incompleteness. To understand what a predicate logic for incompleteness should look like, we need to give a reasonable meaning to its truth values. To this end, we follow the approach of <ref type="bibr" target="#b33">[33]</ref> and use sets of possible worlds to model incompleteness.</p><p>For a language of propositional formulae L, a propositional interpretation for L is a triple (W , t, f ) where W is a set of possible worlds, and t and f are functions mapping formulae of L into subsets of W . Intuitively, t(α) is the set of worlds that satisfy α, and f (α) is the set of worlds that do not. In our framework, we allow t(α) ∪ f (α) W , i.e., the knowledge we have on α may be partial. We do require that t(α) ∩ f (α) = , as we do not consider inconsistent interpretations. Taking propositional interpretations directly as truth values was advocated in <ref type="bibr" target="#b33">[33]</ref>. This however gives rise to too many truth values. Instead, we want an informative and compact representation of what we know about formulae. To define such a representation, we resort to epistemic logic, and define the epistemic modalities of a propositional formula α ∈ L as the formulae K(α), P(α), and their negations. A propositional interpretation (W , t, f ) satisfies K(α) if t(α) = W , that is, we know α. It satisfies</p><formula xml:id="formula_50">P(α) if t(α)</formula><p>, that is, α is possible. As the truth values for our logic, we take maximally consistent theories of epistemic modalities of a formula and its negation. For every given formula α ∈ L, we can show that there are at most only six such theories, corresponding to the following scenarios:</p><p>• α is true in all worlds (truth value t); • α is false in all worlds (truth value f); • α is true in some worlds, false in others (truth value s, meaning "sometimes"); • There is a world where α is true, but we do not know whether α is always true (truth value st, meaning "sometimes true"); • There is a world where α is false, but we do not know whether α is always false (truth value sf, meaning "sometimes false"); • We have no information whatsoever on α (truth value u, "unknown").</p><p>To derive the truth tables of the propositional connectives ∧, ∨ and ¬, we denote by χ τ α , for a propositional formula α, the epistemic formula that expresses the maximally consistent theory stating that α has truth value τ . For example, χ t α = K(α) ∧ P(α) ∧ ¬K(¬α) ∧ ¬P(¬α). Then, we impose the following two requirements:</p><p>• If ω(τ 1 , τ 2 ) = τ , then τ is consistent with τ 1 , τ 2 , i.e., the epistemic formula χ τ 1 α ∧ χ τ 2 β ∧ χ τ ω(α ,β ) is satisfiable; and • When more than one truth value is consistent with τ 1 , τ 2 , we choose the most general one. The logic derived in this way, denoted by L 6v , is perfectly equipped to handle incomplete information. To be used in database systems, however, a logic needs to be compatible with standard query optimizations, which always require distributivity and idempotency (see <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b44">44]</ref>). The logic L 6v is neither distributive nor idempotent. Therefore, we want to find a maximal sublogic of it with these two properties that make it suitable for the database context. Theorem 5.3 (see <ref type="bibr" target="#b21">[21]</ref>). The maximal sublogic of L 6v that is both distributive and idempotent is Kleene's three-valued logic L 3v .</p><p>Thus, purely at the propositional level, SQL designers did choose the right logic for handling incompleteness.</p><p>Predicate logics and SQL. Using Kleene's three-valued logic in SQL appears to be well justified. However, our justification applies purely at the propositional level, and SQL is, after all, based on a predicate logic. Thus, we would like to understand whether Kleene's logic is still necessary.</p><p>We consider many-valued FO based on a propositional manyvalued logic L as defined above, i.e., FO(L), • . Recall that we lift the semantics from atomic formulae to arbitrary ones by following the semantics of the propositional connectives, as in <ref type="bibr" target="#b9">(10)</ref> and <ref type="bibr" target="#b11">(11)</ref>. Now we look at the common semantics of atoms. The most natural one is, of course, the Boolean semantics given by <ref type="bibr" target="#b12">(12)</ref>. We have also seen the unification semantics given by (13a) and (13b). As our final example, we consider a null-free semantics corresponding to the way SQL treats comparisons:</p><formula xml:id="formula_51">R( x) nullfree D, ā =          t ā ∈ R D and Const( ā) f ā R D and Const( ā) u ¬Const( ā)<label>(14)</label></formula><p>where Const( ā) states that ā consists of constants only. This could apply to the equality predicate as well, by simply viewing it as an extra relation Eq D = {(a, a) | a ∈ dom(D)}.</p><p>These semantics give rise to a number of different logics. The familiar FO we dealt with previously is simply FO(L 2v , bool ). To define FO SQL , a logic underlining SQL, we need a semantics that combines some of the previously defined ones. A mixed semantics is any semantics • of base relations, including Eq, that uses one of • bool , • unif and • nullfree , for different base relations.</p><p>The following mixed semantics captures the behavior of SQL:</p><formula xml:id="formula_52">R( x) sql D, ā = R( x) bool D, ā R relation of the schema R( x) nullfree D, ā R = Eq<label>(15)</label></formula><p>and gives rise to the FO core of SQL, namely</p><formula xml:id="formula_53">FO SQL = (FO(L 3v ), • sql ) .</formula><p>What is the expressiveness of all these different logics? It looks as though we have a huge space of possibilities, but as a matter of fact we do not. We say that Boolean FO captures a logic (FO(L), • ) if for every formula φ( x) of (FO(L), • ) and every truth value τ ∈ T there exists an FO ψ τ such that φ( x) D, ā = τ iff D |= ψ τ ( ā). Theorem 5.4 (see <ref type="bibr" target="#b21">[21]</ref>). Boolean FO captures (FO(L 3v ), • ) for every mixed semantics • .</p><p>The result of <ref type="bibr" target="#b21">[21]</ref> is again more general: Boolean FO captures every many-valued logic (FO(L), • ) as long as it captures atomic formulae and L has connectives ∧ and ∨ that are weakly idempotent (a ∨ a ∨ a = a ∨ a, and likewise for ∧).</p><p>This seems to suggest that all SQL queries evaluated under the three-valued semantics can be expressed in the usual Boolean version of FO. While this is the case, at least for the fragment of SQL that corresponds to relational algebra queries, we need to be careful. To see why, recall that SQL's approach is to keep tuples on which the evaluation of logical conditions produces the truth value t, i.e.:</p><formula xml:id="formula_54">Q φ (D) = ā | φ sql D, ā = t .</formula><p>Then <ref type="bibr" target="#b52">[52]</ref> showed that for every formula φ of FO(L 3v ) the condition ā ∈ Q φ (D) implies µ(Q φ , D, ā) = 1, i.e., ā is an almost certainly true answer. But at the end of the previous section we saw that SQL queries can return tuples that are almost certainly false.</p><p>What is the source of the mismatch? The textbook approach comes close to describing the logic of SQL, but it misses one important feature of such logic. We can think of core SQL queries as expressions of the form:</p><formula xml:id="formula_55">SELECT x FROM Q 1 , . . . , Q n WHERE θ ( x1 , . . . , xn )</formula><p>where Q 1 , . . . , Q n are either queries or relations, xi is a tuple of variables returned by Q i , and θ is a condition composed of equality of variables, or statements Q ′ ( ȳ) in which Q ′ is another query, or statements Q ′ , or a combination of these via ∧, ∨, and ¬. Note that, in SQL's query evaluation, it is the conditions θ that are evaluated in L 3v ; once the evaluation of the WHERE θ clause is finished, only tuples that evaluated to t are kept, i.e., one goes back to two-valued logic. To capture this, we need a propositional operator that collapses f and u into f. Such an operator does exist in propositional many-valued logics <ref type="bibr" target="#b12">[12]</ref> and is known as an assertion operator: ↑p for a proposition p evaluates to t if p evaluates to t, and to f otherwise. Let L ↑ 3v be the extension of L 3v with this operator. The basic SQL query can then be expressed in FO(L ↑ 3v ):</p><formula xml:id="formula_56">Q( x) = ∃ ȳ n i=1 Q i ( xi ) ∧ ↑θ ( x1 , . . . , xn ) ,</formula><p>where ȳ lists variables present in x1 , . . . , xn but not x. Thus, the many-valued predicate logic capturing SQL's behavior is</p><formula xml:id="formula_57">FO ↑ SQL = FO(L ↑ 3v ), • sql</formula><p>rather than just FO SQL . But even this logic is no more expressive than Boolean FO.</p><p>Theorem 5.5 (see <ref type="bibr" target="#b21">[21]</ref>). For every formula φ( x) of FO ↑ SQL , the query Q φ is expressible in Boolean FO.</p><p>Therefore, while justified at the propositional level, the use of a three-valued logic is not needed to handle incomplete databases, at least for queries capturing the expressiveness of relational algebra.</p><p>We conclude by explaining why queries in FO ↑ SQL (and thus reallife SQL) can produce almost certainly false answers, while queries in FO SQL cannot. It turns out that being almost certainly true is guaranteed if the connectives of the many-valued logic preserve the knowledge order u ⪯ t and u ⪯ f. The usual connectives ∧, ∨, ¬ are such, but the assertion operator is not: while u ⪯ t, we do not have ↑u ⪯ ↑t. Therefore, the real culprit in SQL's behavior is not the three-valued logic per se (even though it can be completely avoided) but rather the mix of two-and three-valued logics, i.e., not carrying full information about the three truth values through the entire query evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">OPEN PROBLEMS</head><p>We conclude by discussing possible avenues for future research on incomplete information, which we mostly foresee at the intersection of theory and practice. On the one hand, theoretical investigations should be focused on problems that have practical relevance; for example, queries with arithmetic and aggregation in typed data models (not necessarily limited to the relational setting) under bag semantics. On the other hand, real systems should be built and extended by taking into account the lessons learned from theory; in particular, we need implementations of models of incompleteness that are more expressive and flexible than what is currently provided by SQL. Below, we discuss some of these open problems in more detail.</p><p>Bag semantics. Real-life RDBMSs use a data model that is based on bags, where tuples in a relation are allowed, unlike for sets, to occur more than once. While much theoretical research -like most of the works reviewed in this survey -is focused on set semantics, in recent years there have been several efforts towards handling incomplete data in bag databases <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b42">42,</ref><ref type="bibr" target="#b55">55]</ref>. However, it is still early days for the study of certain answers under bag semantics, and several questions remain open. Under bags, as mentioned in Section 4.2, we have more fine grained information about tuples, namely their minimum and maximum number of occurrences across all possible worlds. In <ref type="bibr" target="#b20">[20]</ref> and <ref type="bibr" target="#b22">[22]</ref>, the minimum multiplicity is taken as the notion of certainty, but is this the right one? When working with bags, valuations can be applied to databases in different ways: tuples that unify under a valuation can be collapsed, or their multiplicities added up <ref type="bibr" target="#b42">[42]</ref>. What are the differences between those when defining and computing certain answers? Are there other possibilities? Marked nulls. While theoretical models of incompleteness rely on marked nulls, in real-life DBMSs based on SQL there is only one single placeholder object for representing missing values: NULL. To bridge this gap, the common approach is to interpret each occurrence of NULL as a distinct marked null. Then, denoting by codd this transformation of SQL nulls into non-repeating marked nulls, known as Codd nulls, it must hold that Q codd(D) and codd Q(D) are the same, up to renaming of nulls, for every database D and query Q. That is, transforming SQL nulls to Codd nulls before or after evaluating queries makes no difference. However, this fails in general, and the class of queries having this property cannot be captured by a syntactic fragment. While syntactic restrictions that enforce it exist <ref type="bibr" target="#b39">[39]</ref>, it seems more interesting to follow a different approach: implement marked nulls directly in SQL. This would increase SQL's expressiveness (e.g., by allowing one to state that two persons have the same unknown age) and avoid some of the semantic ambiguity around NULL (e.g., missing versus non-applicable or undefined values). Of course, this raises several interesting questions, for example: is an implementation of marked nulls possible using only standard SQL features? What are the costs in terms of storage requirements and performance of queries? Quality of approximations. As we have seen in Section 4, several ways to approximate certain answers exist in the literature. But how good are the approximations they provide? For the approximation schemes <ref type="bibr" target="#b36">[36,</ref><ref type="bibr" target="#b37">37,</ref><ref type="bibr" target="#b51">51]</ref> presented in Section 4.2 we can say the following: first, the answers they provide on databases without nulls coincide with those returned by evaluating the original query; second, there is a strict containment (witnessed by specific queries and databases) between the answers returned by any two of the four algorithms proposed in <ref type="bibr" target="#b36">[36]</ref>; third, the answers returned by the approximation schemes of <ref type="bibr" target="#b51">[51]</ref> and <ref type="bibr" target="#b37">[37]</ref> are incomparable (w.r.t. subset inclusion) in general.</p><p>Comparing the quality of different approximation procedures is not always easy. When feasible, one can of course perform experimental analyzes in the spirit of <ref type="bibr" target="#b27">[27]</ref> (cf. also <ref type="bibr" target="#b37">[37]</ref> and <ref type="bibr" target="#b28">[28]</ref>), but we also need principled theoretical approaches. One possibility is to analyze the knowledge provided by an approximation procedure and compare it with the certain knowledge the query and the database give us. Understanding the amount of certain knowledge a procedure is able to compute, and what logic, if any, can express it, would give us a nice characterization of the quality of the approximation provided. Another idea is to use the probabilistic approach of Section 4.3 to estimate how likely a tuple is to be returned by one approximation but not the other.</p><p>Value-inventing queries. Data aggregation and arithmetic operations are among the most used features in SQL, with aggregation alone amounting for the vast majority of the query workloads of many popular benchmarks. For example, no less than 80% of the analytical queries included in the well-known TPC Benchmark H use aggregation <ref type="bibr" target="#b65">[65]</ref>. What these operations have in common is that they can (and typically do) produce values that are not present in the database. The theoretical tools we currently have for dealing with incompleteness prove inadequate for value-inventing operations. Indeed, as mentioned in Section 3, the widespread certain answers with nulls cannot return values that do not appear in the original database. The way the problem is addressed in practical scenarios is also unsatisfactory: the common approach is to apply imputation techniques that replace nulls with "likely" values, and then process analytical queries in the standard way as if the data were complete <ref type="bibr" target="#b29">[29]</ref>. We need new techniques for applying the notions of certainty (either exact or approximate) in the context of value-inventing queries.</p><p>Types of attributes. The results shown here, and in general many results on handling incomplete information, are presented in the standard theoretical model of relational databases with the domain consisting of constants and nulls, and with equality and disequality being the only available predicates. In real life, of course, database columns have types: numerical, strings, etc. How can we extend results to the typed model, where type-specific operations, such as arithmetic, are used in queries? In some cases there are simple extensions: for example, the approximation schemes of Section 4.2 can be used by treating type-specific comparisons similarly to disequalities. On the other hand, the probabilistic approximations of Section 4.3 are more complicated, though they can provide more refined information about query answers <ref type="bibr" target="#b23">[23]</ref>. Bridging the gap between theoretical models and typed real-life schemas is essential for applying these results in practice.</p><p>Other data models. We focused on the relational model, but there are other data models where incompleteness naturally occurs. For XML, for example, incompleteness has been extensively studied <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9]</ref>. For the very popular and fast developing model of graph databases <ref type="bibr" target="#b14">[14]</ref> there has been some initial work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b40">40,</ref><ref type="bibr" target="#b56">56]</ref> but we are nowhere near a well-developed theory similar to what was presented here for relational data. A new standard query language for graph databases called GQL is being designed <ref type="bibr" target="#b68">[68]</ref>. This provides an opportunity to influence the design of its null-related features that would lead to less criticism than that experienced by SQL.</p><p>Certain answers as knowledge. The framework of <ref type="bibr" target="#b49">[49]</ref> presented in Section 3.2 has been used to define certain answers as objects, but there is more to it and we believe it should be further developed. One example of the use the use of the framework is <ref type="bibr" target="#b50">[50]</ref>, which defined negative and possible answers with the help of certain knowledge. It can also be used to handle semantically opaque object identifiers, a problem which is especially relevant in data integration and OBDA, where object identifiers are retrieved from multiple sources and are often encoded using different conventions. An example of this is the notion of referring answers <ref type="bibr" target="#b15">[15]</ref>, which encode the certain knowledge entailed by answer tuples.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A database of orders, payments, and customers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 3 . 1 .</head><label>31</label><figDesc>A database domain D is a triple (I, C, • ), where I is a set of database objects, C ⊆ I is the set of complete objects (over which queries are defined), and • is a semantic function from I to the powerset of C such that x ∈ x for every x ∈ C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Truth tables of Kleene's three-valued logic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>SELECT R.A FROM R WHERE R.A NOT IN ( SELECT S.A FROM S WHERE S.A NOT IN ( SELECT * FROM T ) )</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>Most results presented here were obtained by the authors while they were supported by <rs type="funder">EPSRC</rs> projects <rs type="grantNumber">M025268</rs> "<rs type="projectName">VADA: Value Added Data Systems</rs>" and <rs type="grantNumber">N023056</rs> "<rs type="projectName">Managing Incomplete Data -New Foundations</rs>". Work on the semantics of SQL was in conjunction with our collaboration with Neo4j Inc, supported by a grant from them. Finally, the third author is grateful to <rs type="institution">Foundation Sciences Mathématiques de Paris</rs> for supporting his stay in Paris in the Fall of 2019, during which some of this work was done.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_WFTFYb9">
					<idno type="grant-number">M025268</idno>
					<orgName type="project" subtype="full">VADA: Value Added Data Systems</orgName>
				</org>
				<org type="funded-project" xml:id="_jj9GxFJ">
					<idno type="grant-number">N023056</idno>
					<orgName type="project" subtype="full">Managing Incomplete Data -New Foundations</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the representation and querying of sets of possible worlds</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kanellakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Grahne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="158" to="187" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Representing and querying XML with incomplete information</title>
		<author>
			<persName><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Segoufin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TODS</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="208" to="254" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Towards reconciling SPARQL and certain answers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ahmetaj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Fischl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Simkus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Skritek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="23" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Explainable certain answers</title>
		<author>
			<persName><forename type="first">G</forename><surname>Amendola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1683" to="1690" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Murlak</surname></persName>
		</author>
		<title level="m">Foundations of Data Exchange</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A note on computing certain answers to queries over incomplete databases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Botoeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Ryzhikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AMW</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reasoning with logical bilattices</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arieli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic, Language and Information</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="25" to="63" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">What is an ideal logic for reasoning with inconsistency?</title>
		<author>
			<persName><forename type="first">O</forename><surname>Arieli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Avron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zamansky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="706" to="711" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">XML with incomplete information</title>
		<author>
			<persName><forename type="first">P</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sirangelo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A useful four-valued logic</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Belnap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modern Uses of Multiple-Valued Logic</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Dunn</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Epstein</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="8" to="37" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Reidel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Ontology-mediated query answering with datatractable description logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ortiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reasoning Web</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="218" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On a three-valued logical calculus and its application to the analysis of the paradoxes of the classical extended functional calculus</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Bochvar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">History and Philosophy of Logic</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">46</biblScope>
			<biblScope unit="page" from="287" to="308" />
			<date type="published" when="1938">1981. 1938</date>
		</imprint>
	</monogr>
	<note>Translated from Matematicheskij Sbornik</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Many-Valued Logics: Theoretical Foundations</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bolc</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Borowik</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Querying Graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H L</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Voigt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Yakovets</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Synthesis Lectures on Data Management</title>
		<imprint>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On referring expressions in query answering over first order knowledge bases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Borgida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Weddell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KR</title>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="319" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">F</forename><surname>Capelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gheerbrant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sirangelo</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Private communication</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Keisler</surname></persName>
		</author>
		<title level="m">Model Theory</title>
		<imprint>
			<publisher>North Holland</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Some useful preservation theorems</title>
		<author>
			<persName><forename type="first">K</forename><surname>Compton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="427" to="440" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Approximations and refinements of certain answers via many-valued logics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KR</title>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="349" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On querying incomplete information in databases under bag semantics</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="993" to="999" />
		</imprint>
	</monogr>
	<note>ijcai.org</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Propositional and predicate logics of incomplete information</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KR</title>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="592" to="601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fragments of bag relational algebra: Expressiveness and certain answers</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Queries with arithmetic on incomplete databases</title>
		<author>
			<persName><forename type="first">M</forename><surname>Console</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Database in Depth -Relational Theory for Practitioners</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>O&apos;Reilly</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">A Guide to the SQL Standard</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Date</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Darwen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Probabilities on finite models</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="50" to="58" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Uncertainty annotated databases -A lightweight approach for approximating certain answers</title>
		<author>
			<persName><forename type="first">S</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Glavic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Kennedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1313" to="1330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">ACID: A system for computing approximate certain query answers over incomplete databases</title>
		<author>
			<persName><forename type="first">N</forename><surname>Fiorentino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Greco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Molinaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Trubitsyna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="1685" to="1688" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Query Processing over Incomplete Databases</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Miao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Synthesis Lectures on Data Management</title>
		<imprint>
			<publisher>Morgan &amp; Claypool Publishers</publisher>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Querying incomplete graphs with data</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gheerbrant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fontaine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AMW</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Certain answers over incomplete XML documents: Extending tractability boundary</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gheerbrant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="892" to="926" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Naïve evaluation of queries over incomplete databases</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gheerbrant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sirangelo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Systems</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="31" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Multivalued logics: a uniform approach to reasoning in artificial intelligence</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Ginsberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Intelligence</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="265" to="316" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Query evaluation techniques for large databases</title>
		<author>
			<persName><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="73" to="170" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Null values in a relational data base</title>
		<author>
			<persName><forename type="first">J</forename><surname>Grant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="156" to="157" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Approximation algorithms for querying incomplete databases</title>
		<author>
			<persName><forename type="first">S</forename><surname>Greco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Molinaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Trubitsyna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="28" to="45" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Making SQL queries correct on incomplete databases: A feasibility study</title>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="211" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Correctness of SQL queries on databases with nulls</title>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="5" to="16" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">On the Codd semantics of SQL nulls</title>
		<author>
			<persName><forename type="first">P</forename><surname>Guagliardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="46" to="60" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Certain answers for SPARQL?</title>
		<author>
			<persName><forename type="first">C</forename><surname>Gutiérrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hernández</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Polleres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AMW</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Hell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Nešetřil</surname></persName>
		</author>
		<title level="m">Graphs and homomorphisms</title>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Foundations of information integration under bag semantics</title>
		<author>
			<persName><forename type="first">A</forename><surname>Hernich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Incomplete information in relational databases</title>
		<author>
			<persName><forename type="first">T</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="761" to="791" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Query optimization in database systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="111" to="152" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Data integration: a theoretical perspective</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="233" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Elements of Finite Model Theory</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Incomplete information and certain answers in general data models</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Incomplete information: what went wrong and how to fix it</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Certain answers as objects and knowledge</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">232</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Negative knowledge for certain query answers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><surname>Rr</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="page" from="111" to="127" />
			<date type="published" when="2016">9898. 2016</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">SQL&apos;s three-valued logic and certain answers</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Certain answers meet zero-one laws</title>
		<author>
			<persName><forename type="first">L</forename><surname>Libkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="195" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">On semantic issues connected with incomplete information databases</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="262" to="296" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">On relational algebra with marked nulls</title>
		<author>
			<persName><forename type="first">W</forename><surname>Lipski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="page" from="201" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Foundations of ontology-based data access under bag semantics</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nikolaou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kaminski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">C</forename><surname>Grau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Horrocks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">274</biblScope>
			<biblScope unit="page" from="91" to="132" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Incomplete information in RDF</title>
		<author>
			<persName><forename type="first">C</forename><surname>Nikolaou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Koubarakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">RR</title>
		<imprint>
			<biblScope unit="page" from="138" to="152" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Linear unification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Wegman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="158" to="167" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">On closed world data bases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and Data Bases</title>
		<imprint>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="55" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Equality and domain closure in first-order databases</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="235" to="249" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A sound and sometimes complete query evaluation algorithm for relational databases with null values</title>
		<author>
			<persName><forename type="first">R</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="349" to="347" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Some aspects of model theory and finite structures</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rosen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="380" to="403" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Homomorphism preservation theorems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Rossman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">The Strange Logic of Random Graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Spencer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Finitely monotone properties</title>
		<author>
			<persName><forename type="first">A</forename><surname>Stolboushkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Logic in Computer Science (LICS)</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="324" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<ptr target="http://www.tpc.org/tpc_documents_current_versions/pdf/tpc-h_v2.18.0.pdf" />
		<title level="m">Transaction Processing Performance Council (TPC)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note>TPC Benchmark™ H Standard Specification. revision 2.18.0 edition</note>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Logical approaches to incomplete information: A survey</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Der Meyden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logics for Databases and Information Systems</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="307" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Querying logical databases</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="142" to="160" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">GQL graph query language</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note>Wikipedia contributors</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
