<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adaptive Caching for Data-Intensive Scientific Workflows in the Cloud</title>
				<funder ref="#_2YQxwHQ">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder>
					<orgName type="full">France Grille Scientific Interest Group</orgName>
				</funder>
				<funder ref="#_xHfUD4A">
					<orgName type="full">DigitAg French Convergence Lab</orgName>
				</funder>
				<funder ref="#_smV8X2W">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Gaëtan</forename><surname>Heidsieck</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Inria &amp; LIRMM</orgName>
								<orgName type="institution">Univ. Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>De Oliveira</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Esther</forename><surname>Pacitti</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Inria &amp; LIRMM</orgName>
								<orgName type="institution">Univ. Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Institute of Computing</orgName>
								<orgName type="institution">UFF</orgName>
								<address>
									<country key="BR">Brazil</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Christophe</forename><surname>Pradal</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Inria &amp; LIRMM</orgName>
								<orgName type="institution">Univ. Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">CIRAD &amp; AGAP</orgName>
								<address>
									<settlement>Montpellier SupAgro</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">François</forename><surname>Tardieu</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">INRA &amp; LEPSE SupAgro</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Patrick</forename><surname>Valduriez</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Inria &amp; LIRMM</orgName>
								<orgName type="institution">Univ. Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adaptive Caching for Data-Intensive Scientific Workflows in the Cloud</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">647BD55AE29B0BBF1303A7F15BE9BAA6</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Adaptive Caching</term>
					<term>Scientific Workflow</term>
					<term>Cloud</term>
					<term>Workflow Execution</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>Many scientific experiments are now carried on using scientific workflows, which are becoming more and more data-intensive and complex. We consider the efficient execution of such workflows in the cloud. Since it is common for workflow users to reuse other workflows or data generated by other workflows, a promising approach for efficient workflow execution is to cache intermediate data and exploit it to avoid task re-execution. In this paper, we propose an adaptive caching solution for data-intensive workflows in the cloud. Our solution is based on a new scientific workflow management architecture that automatically manages the storage and reuse of intermediate data and adapts to the variations in task execution times and output data size. We evaluated our solution by implementing it in the <software>OpenAlea</software> system and performing extensive experiments on real data with a data-intensive application in plant phenotyping. The results show that adaptive caching can yield major performance gains, e.g., up to 120.16% with 6 workflow re-executions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">Introduction</head><p>In many scientific domains, e.g., bio-science <ref type="bibr" target="#b7">[8]</ref>, complex experiments typically require many processing or analysis steps over huge quantities of data. They can be represented as scientific workflows (SWfs), which facilitate the modeling, management and execution of computational activities linked by data dependencies. As the size of the data processed and the complexity of the computation keep increasing, these SWfs become data-intensive <ref type="bibr" target="#b7">[8]</ref>, thus requiring execution in a high-performance distributed and parallel environment, e.g. a large-scale virtual cluster in the cloud.</p><p>Most Scientific Workflow Management Systems (SWfMSs) can now execute SWfs in the cloud <ref type="bibr" target="#b11">[12]</ref>. Some examples of such SWfMS are Swift/T, Pegasus, SciCumulus, Kepler and <software ContextAttributes="used">OpenAlea</software>, the latter being widely used in plant science for simulation and analysis.</p><p>It is common for workflow users to reuse other workflows or data generated by other workflows. Reusing and re-purposing workflows allow for the user to develop new analyses faster <ref type="bibr" target="#b6">[7]</ref>. Furthermore, a user may need to execute a workflow many times with different sets of parameters and input data to analyze the impact of some experimental step, represented as a workflow fragment, i.e. a subset of the workflow activities and dependencies. In both cases, some fragments of the workflow will be executed many times, which can be highly resource consuming and unnecessary long. Workflow re-execution can be avoided by storing the intermediate results of these workflow fragments and reuse them in later executions.</p><p>In <software>OpenAlea</software>, this is provided by a lazy evaluation technique, i.e. the intermediate data is simply kept in memory after the execution of a workflow. This allows for a user to visualize and analyze all the activities of a workflow without any re-computation, even with some parameter changes. Although lazy evaluation represents a step forward, it has some limitations, e.g. it does not scale in distributed environments and requires much memory if the workflow is data-intensive.</p><p>In a single user perspective, the reuse of the previous results can be done by storing the relevant outputs of intermediate activities (intermediate data) within the workflow. This requires the user to manually manage the caching of the results that she wants to reuse, which can be difficult as she needs to be aware of the data size, execution time of each task, i.e. the instantiation of an activity during the execution of a workflow, or other factors that could allow deciding which data is the best to store.</p><p>A complementary, promising approach is to reuse intermediate data produced by multiple executions of the same or different workflows. Some SWfMSs support the reuse of intermediate data, yet with some limitations. <software ContextAttributes="used">VisTrails</software> <ref type="bibr" target="#b3">[4]</ref> automatically makes the intermediate data persistent with the workflow definition. With a plugin <ref type="bibr" target="#b19">[20]</ref>, <software ContextAttributes="used">VisTrails</software> allows SWf execution in HPC environments, but does not benefit from reusing intermediate data. <software ContextAttributes="used">Kepler</software> <ref type="bibr" target="#b1">[2]</ref> manages a persistent cache of intermediate data in the cloud, but does not take data transfers from remote servers into account. There is also a trade-off between the cost of re-executing tasks versus storing intermediate data that is not trivial <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6]</ref>. Yuan et al. <ref type="bibr" target="#b17">[18]</ref> propose an algorithm based on the ratio between re-computation cost and storage cost at the task level. The algorithm is improved in <ref type="bibr" target="#b18">[19]</ref> to take into account workflow fragments. Both algorithms are used before the execution of the workflow, using the provenance data of the intermediate datasets. However, this approach is static and cannot deal with variations in tasks' execution times. In data intensive SWf, such variations can be very important depending on the input data, e.g., data compression tasks can be short or long depending on the data itself, regardless of size.</p><p>In this paper, we propose an adaptive caching solution for efficient execution of data-intensive workflows in the cloud. By adapting to the variations in tasks' execution times, our solution can maximize the reuse of intermediate data produced by workflows from multiple users. Our solution is based on a new SWfMS architecture that automatically manages the storage and reuse of intermediate data. Cache management is involved during two main steps: SWf preprocessing, to remove all fragments of the workflow that do not need to be executed; and cache provisioning, to decide at runtime which intermediate data should be cached. We propose an adaptive cache provisioning algorithm that deals with the variations in task execution times and output data. We evaluated our solution by implementing it in <software>OpenAlea</software> and performing extensive experiments on real data with a complex data-intensive application in plant phenotyping.</p><p>This paper is organized as follows. Section 2 presents our real use case in plant phenotyping. Section 3 introduces our SWfMS architecture in the cloud. Section 4 describes our cache algorithm. Section 5 gives our experimental evaluation. Finally, Section 6 concludes.</p></div>
<div><head n="2">Use Case in Plant Phenotyping</head><p>In this section, we introduce in more details a real SWf use case in plant phenotyping that will serve as motivation for the work and basis for the experimental evaluation.</p><p>In the last decade, high-throughput phenotyping platforms have emerged to allow for the acquisition of quantitative data on thousands of plants in wellcontrolled environmental conditions. These platforms produce huge quantities of heterogeneous data (images, environmental conditions and sensor outputs) and generate complex variables with in-silico data analyses. For instance, the seven facilities of the French Phenome project (https://www.phenome-emphasis.fr/ phenome_eng/) produce each year 200 Terabytes of data, which are heterogeneous, multiscale and originate from different sites. Analyzing automatically and efficiently such massive datasets is an open, yet important, problem for biologists <ref type="bibr" target="#b16">[17]</ref>.</p><p>Computational infrastructures have been developed for processing plant phenotyping datasets in distributed environments <ref type="bibr" target="#b13">[14]</ref>, where complex phenotyping analyses are expressed as SWfs. Such analyses can be represented, managed and shared in an efficient way, where compute-and data-based activities are linked by dependencies <ref type="bibr" target="#b4">[5]</ref>.</p><p>One scientific challenge in phenomics, i.e., the systematic study of phenotypes, is to analyze and reconstruct automatically the geometry and topology of thousands of plants in various conditions observed from various sensors <ref type="bibr" target="#b15">[16]</ref>. For this purpose, we developped the <software ContextAttributes="used">OpenAlea Phenomenal</software> software package <ref type="bibr" target="#b2">[3]</ref>. Phenomenal provides fully automatic workflows dedicated to 3D reconstruction, segmentation and tracking of plant organs, and light interception to estimate plant biomass in various scenarios of climatic change <ref type="bibr" target="#b14">[15]</ref>.</p><p>Phenomenal is continuously evolving with new state-of-the-art methods that are added, thus yielding new biological insights (see Figure <ref type="figure">1</ref>). A typical workflow is shown in Figure <ref type="figure">1</ref> sub-workflows. In Figure <ref type="figure">1</ref>.2, the different fragments are for binarization, 3D reconstruction, skeletonization, stem detection, organ segmentation and mesh generation. Other fragments such as greenhouse or field reconstruction, or simulation of light interception, can be reused.</p><p>Based on these different workflow fragments, different users can conduct different biological analyses using the same datasets. The SWf shown in Figure <ref type="figure">1</ref>.4 reuses the Binarize fragment to predict the flowering time in maize. In Figure <ref type="figure">1</ref>.5, the same Binarize fragment is reused and the 3D reconstruction fragment is added to reconstruct the volume of the 1,680 plants in 3D. Finally, in the SWf shown in Figure <ref type="figure">1</ref>.6, the previous SWf is reused, but with different parameters to study the environmental versus genetic influence of biomass accumulation.</p><p>These three studies have in common both the plant species (in our case maize plants) and share some workflow fragments. At least, scientists want to compare their results on previous datasets and extend the existing workflow with their own developed actors or fragments. To save both time and resources, they want to reuse the intermediate results that have already been computed rather than recompute them from scratch.</p><p>The Phenoarch platform is one of the Phenome nodes in Montpellier. It has a capacity of 1,680 plants with a controlled environment (e.g., temperature, humidity, irrigation) and automatic imaging through time. The total size of the raw image dataset for one experiment is 11 Terabytes.</p><p>Currently, processing a full experiment with the phenomenal workflow on local computational resources would take more than one month, while scientists require this to be done over the night (12 hours). Furthermore, they need to restart an analysis by modifying parameters, fix errors in the analysis or extend it by adding new processing activities. Thus, we need to use more computational resources in the cloud including both large data storage that can be shared by multiple users.</p></div>
<div><head n="3">Cloud SWfMS Architecture</head><p>In this section, we present our SWfMS architecture that integrates caching and reuse of intermediate data in the cloud. We motivate our design decisions and describe our architecture in two ways: first, in terms of functional layers (see Figure <ref type="figure" target="#fig_1">2</ref>), which shows the different functions and components; then, in terms of nodes and components (see Figure <ref type="figure">3</ref>), which are involved in the processing of SWfs.</p><p>Our architecture capitalizes on the latest advances in distributed and parallel computing to offer performance and scalability <ref type="bibr" target="#b12">[13]</ref>. We consider a distributed architecture with on premise servers, where raw data is produced (e.g., by a phenotyping experimental platform in our use case), and a cloud site, where the SWf is executed. The cloud site (data center) is a shared-nothing cluster, i.e. a cluster of server machines, each with processor, memory and disk. We choose shared-nothing as it is the most scalable architecture for big data analysis.</p><p>In the cloud, metadata management has a critical impact on the efficiency of SWf scheduling as it provides a global view of data location, e.g. at which nodes some raw data is stored, and enables task tracking during execution <ref type="bibr" target="#b8">[9]</ref>. We organize the metadata in three repositories: catalog, provenance database and cache index. The catalog contains all information about users (access rights, etc.), raw data location and SWfs (code libraries, application code). The provenance database captures all information about SWf execution. The cache index contains information about tasks and intermediate data produced, as well as the location of files that store the intermediate data. Thus, the cache index itself is small (only file references) and the cached data can be managed using the underlying file system. A good solution for implementing these metadata repositories is a modern key-value store, such as <software ContextAttributes="used">Cassandra</software> (https://cassandra.apache. org), which provides efficient key-based access, scalability and fault-tolerance through replication in a shared-nothing cluster.</p><p>The raw data (files) are intially produced at some servers, e.g. in our use case, at the phenotyping platform and get transferred to the cloud site. The cache data (files) are produced at the cloud site after SWf execution. A good solution to store these files in a cluster is a distributed file system like Lustre (http://lustre.org) which is used a lot in HPC as it scales to high numbers of files.   <ref type="bibr" target="#b9">[10]</ref>, which distinguishes various layers, to support intermediate data caching. The SWf manager is the component that the user clients interact with to develop, share and execute worksflows, using the metadata (catalog, provenance database and cache index). It determines the workflow activities that need to be executed, and generates the associated tasks for the scheduler. It also uses the cache index for SWf preprocessing to identify the intermediate data to reuse and the tasks that need not be re-executed.</p><p>The scheduler exploits the catalog and provenance database to decide which tasks should be scheduled to cloud sites. The task manager controls task execution and uses the cache manager to decide whether the task's output data should be placed in the cache. The cache manager implements the adaptive cache provisioning algorithm described in Section 4. The SWf data manager deals with data storage, using a distributed file system. Figure <ref type="figure">3</ref> shows how these components are involved in SWf processing, using the traditional master-worker model. There are three kinds of nodes, master, compute and data nodes, which are all mapped to cluster nodes at configuration time, e.g. using a cluster manager like <software ContextAttributes="used">Yarn</software> ( http://hadoop.apache.org). The master node includes the SWf manager, scheduler and cache manager, and deals with the metadata. The master node is lightly loaded as most of the work of serving clients is done by the compute and data nodes (or worker nodes), which perform task management and execution, and data management, respectively. So, it is not a bootleneck. However, to avoid any single point of failure, there is a standby master node that can perform failover upon the master node's failure.</p><p>Let us now illustrate briefly how SWf processing works. User clients connect to the cloud site's master node. SWf execution is controlled by the master node, which identifies, using the SWf manager, which activities in the fragment can take advantage of cached data, thus avoiding task execution. The scheduler schedules the corresponding tasks that need to be processed on compute nodes which in turn will rely on data nodes for data access. It also adds the transfers of raw data from remote servers that are needed for executing the SWf. For each task, the task manager decides whether the task's output data should be placed in the cache taking into account storage costs, data size, network costs. When a task terminates, the compute node sends to its master the task's execution information to be added in the provenance database. Then, the master node updates the provenance database and may trigger subsequent tasks</p></div>
<div><head n="4">Cache Management</head><p>This section presents in details our techniques for cache management.</p><p>We start by introducing some terms and concepts. A SWf W (A, D) is the abstract representation of a directed acyclic graph (DAG) of computational activities A and their data dependencies D. There is a dependency between two activities if one consumes the data produced by the other. An activity is a description of a piece of work and can be a computational script (computational activity), some data (data activity) or some set-oriented algebraic operator like map or filter <ref type="bibr" target="#b10">[11]</ref>. The parents of an activity are all activities directly connected to its inputs. A task t is the instantiation of an activity during execution with specific associated input data. The input Input(t) of t is the data needed for the task to be computed, and the output Output(t) is the data produced by the execution of t. Whenever necessary, for clarity, we alternatively use the term intermediate data instead of output data. Execution data corresponds to the input and output data related to a task t. For the same activity, if two tasks t i and t j have the equal inputs then they produce the same output data, i.e., Input(t i ) = Input(t j ) ⇒ Output(t i ) = Output(t j ). A SWf's input data is the raw data generated by the experimental platforms, e.g., a phenotyping platform. An executable workflow for workflow W (A, D) is W ex (A, D, T, Input), where T is a DAG of tasks corresponding to activities in A and Input is the input data.</p><p>In our solution, cache management is involved during two main steps: SWf preprocessing and cache provisioning. SWf preprocessing occurs just before execution and is done by the SWf manager using the cache index. The goal is to transform an executable workflow W ex (A, D, T, Input) into an equivalent, simpler subworkflow W ex (A , D , T , Input ), where A is a subgraph of A with dependencies D , T is a subgraph of T corresponding to A and Input ∈ Input. This is done by removing from the executable workflow all tasks and corresponding input data for which the output data is in the cache. The preprocessing step uses a recursive algorithm that traverses the DAG starting from the leaf nodes (corresponding to tasks). For each task t, if Output(t) is already in the cache, this means that the entire subgraph of T whose leaf is t can be removed.</p><p>Figure <ref type="figure">4</ref> illustrates the preprocessing step on the Phenomenal SWf. The yellow tasks have their output data stored in the cache. They are replaced by the corresponding data as input for the subgraphs of tasks that need to be executed. Fig. <ref type="figure">4</ref>: DAG of tasks before pre-processing (left) and the selected fragments that need to be executed (right).</p><p>The second step, cache provisioning, is performed during workflow execution. Traditional (in memory) caching involves deciding, as data is read from disk into memory, which data to replace to make room, using a cache replacement algorithm, e.g. LRU. In our context, using a disk-based cache, the question is different, i.e. to decide which task output data to place in the cache using a cache provisioning algorithm. This algorithm is implemented by the cache manager and used by the task manager when executing a task.</p><p>A simple cache provisioning algorithm, which we will use as baseline, is to use a greedy method that simply stores all tasks' output data in the cache. However, since SWf executions produce huge quantities of output data, this approach would incur high storage costs. Worse, for some short duration tasks, accessing cache data from disk may take much more time than re-executing the corresponding task subgraph from the input data in memory.</p><p>Thus, we propose a cache provisioning algorithm with an adaptive method that deals with the variations in task execution times and output data. The principle is to compute, for each task t, a score based on the sizes of the input and output data it consumes and produces, and the execution time of t. During workflow execution, the execution time of each task t, denoted by ExT ime(t), is stored in the provenance database. If t has already been executed, ExT ime(t) already exists in the provenance database. When t is re-executed, its execution time is recomputed and ExT ime(t) is updated as the average between the new and old execution times.</p><p>The adaptive aspect of our solution is to take into account task compression behavior. With a high compression ratio, it may be efficient to store the output data rather than the input data and recomputing it. In contrary, with a high expansion ratio, storing the input data rather than the output may save disk space.</p><p>Let size(Input(t)) and size(Output(t)) denote the input and output data size of a task t, respectively. The data compression ratio of a task quantifies the reduction of the input data processed by the task, i.e.,</p><formula xml:id="formula_0">CompressRatio(t) = size(Input(t)) size(Output(t))<label>(1)</label></formula><p>Based on this data compression ratio, a cache provisioning score, denoted by <software>CacheScore</software>, is defined. For a task t, let F be a constant to normalize the time factor, ω s and ω t represent the weight for the storage cost and execution time, they are determined by the user and ω s + ω t = 1, the cache provisioning score is obtained by:</p><formula xml:id="formula_1">CacheScore(t) = ω s * CompressRatio(t) + ω t * T exec (t) F<label>(2)</label></formula><p>The cache score reveals the relevancy of caching the output data of t and takes into account the compression metric and execution time. According to the weights provided by the user, she may prefer to give more importance to the compression ratio or executions time, depending on the storage capacity and available computational resources.</p><p>Then, during each task t execution, the task manager calls the cache manager to compute <software>CacheScore</software>(t). If the computed value is bigger than the threshold provided by the user, then t's output data will be cached. This threshold is chosen based on the overhead of cache provisioning (i.e., the time spent to store t's output data) and the cache size.</p></div>
<div><head n="5">Experimental Evaluation</head><p>In this section, we first present our experimental setup. Then, we present our experiments and comparisons of different caching methods in terms of speedup and monetary cost in single user and multiuser modes. Finally, we give concluding remarks.</p></div>
<div><head n="5.1">Experimental Setup</head><p>Our experimental setup includes the cloud infrastructure, SWf implementation and experimental dataset.</p><p>The cloud infrastructure is composed of one site with one data node (N1) and two identical compute nodes (N2, N3). The raw data is originally stored in an external server. During computation, raw data is transferred to N1, which contains Terabytes of persistent storage capacities. Each compute node has much computing power, with 80 vCPUs (virtual CPUs, equivalent to one core each of a 2.2GHz Intel Xeon E7-8860v3) and 3 Terabytes of RAM, but less persistent storage (20 Gigabytes).</p><p>We implemented the Phenomenal workflow (see Section 2) using <software>OpenAlea</software> and deployed it on the different nodes using the Conda multi-OS package manager. The master node is hosted on one of the compute node (N2). The metadata repositories are stored on the same node (N2) using the <software ContextAttributes="used">Cassandra</software> key-value store. Files for raw and cached data are shared between the different nodes using the Lustre file system. File transfer between nodes is implemented with ssh.</p><p>The Phenoarch platform has a capacity of 1,680 plants with 13 images per plant per day. The size of an image is 10 Megabytes and the duration of an experiment is around 50 days. The total size of the raw image dataset represents 11 Terabytes for one experiment. The dataset is structured as 1,680 time series, composed of 50 time points (one per plant and per day).</p><p>We use a version of the Phenomenal workflow composed of 9 main activities. We execute it on a subset of the use case dataset, that is 1 25 of the size of the full datatset, or 440 Gigabytes of raw data, which represents the execution of 30,240 tasks.</p></div>
<div><head n="5.2">Experiments</head><p>We execute the workflow on the subset dataset with different number of vCPUs and different caching methods. We consider workflow executions from a single user or multiple users to test the re-execution of the same workflow several times.</p><p>We compare three different caching methods: 1) no cache, 2) greedy, and 3) adaptive. Greedy and adaptive are described in Section 4.</p><p>In the single user scenario, the execution time corresponds to the transfer time of the raw data from the remote servers, the time to run the workflow and the time for cache provisioning, if any. In the multiuser scenario, the same workflow is executed on the same data several times (up to 6 times).</p><p>The raw data is fetched on the data node as follows: a first chunk is fetched from the remote data servers, then the remaining chunks are fetched while the execution starts on the first chunk. As the execution takes longer than transferring the raw data, we only count the time of transferring the first chunk in the execution time.</p><p>For the adaptive method, the coefficients ω d and ω t defined by the user are set to 0.5 each. The threshold is set to 0.4.  In the rest of this section, we compare the three methods in terms of speedup and monetary cost.</p><p>Speedup. We compare the speedup of the three caching methods. We define speedup as speedup(n) = Tn T10 where T n is the execution time on n vCPUs and T 10 is the execution time of the no cache method on 10 vCPUs.</p><p>The workflow execution is distributed on nodes N2 and N3, for different numbers of vCPUs. For one execution, Figure <ref type="figure" target="#fig_4">5</ref>.a shows that the fastest method is no cache (red curve). This is normal because there is no additional time to make data persistent and provision the cache. However, the overhead of cache provisioning with the adaptive method is very small (green curve in Figure <ref type="figure" target="#fig_4">5</ref>.a) compared with the greedy method (blue curve in Figure <ref type="figure" target="#fig_4">5</ref>.a) where all the output data are saved in the cache.</p><p>The speedup with adaptive goes up to 94.4% of that with no cache, while the speedup with greedy goes up to 59.9%. For instance, with 80 vCPUs, the execu-tion time of the adaptive method (i.e., 3,714 seconds) is only 5.8% higher than that of the no cache method (i.e. 3,510 seconds). This is much faster than the greedy method, which adds 68.2% of computation time in comparison with the no cache method. Re-execution with the greedy and adaptive methods have much smaller execution time than the first execution. The greedy method re-execution time is the fastest, with only 2.3% (i.e., 129 seconds) of the no cache method execution time, because all the output data is already cached. Furthermore, as only the master node is working although no computation is done, the re-execution time is independent of the number of vCPUs and can be computed from a personal computer with limited vCPUs. The adaptive method re-execution time is a bit higher as 16.3% (i.e., 572 seconds) of the no cache method execution time for a gain of 513%. With the adaptive method, some computation still needs to be done when the workflow is re-executed, but such re-execution on the whole dataset can be done in less than a day (i.e., 19.4 hours) on a 10 vCPUs machine, compared with 6.9 days with the no cache method. For three executions, starting without cache, Figure <ref type="figure" target="#fig_4">5</ref>.b shows that the adaptive method is much faster than the other methods. The greedy method is faster than the no cache method in this case, because the additional time for the cache provisioning is compensated by the very short re-execution times of the greedy method. With 80 vCPUs, the speedup of the adaptive method (i.e., 18.1) is 54.70% better than that of the greedy method (i.e., 11.7) and 162.31% better than that of the no cache method (i.e., 6.9). The adaptive method is faster on three executions than the other methods, despite having re-execution time higher than the greedy method, because the overhead of the cache provisioning is 57% smaller. To set the price parameters, we use Amazon's cost model, i.e., Cost disk is $0.1 per Gigabyte per month for storage and two instances at $5.424 per hour for computation, i.e., Cost cpu is $10.848 per hour. As we can see from Figure <ref type="figure" target="#fig_5">6</ref>, the monetary cost of the adaptive method is much smaller than the greedy method due to the amount of cached data produced by the adaptive method (i.e., 390 Gigabytes for the whole experimentation), which is much smaller than for the greedy method (i.e., 3.9 % of the total output data). In terms of monetary cost, the greedy method becomes more efficient than the no cache method at the sixth user in the month. The adaptive method is 28.40% less costly than the no cache method and 254.44% less costly than the greedy method for two executions. For six executions, the adaptive method is still 120.16% less costly than no cache method and 114.38% less costly than the greedy method.</p></div>
<div><head n="5.3">Discussion</head><p>The adaptive method has better speedup compared to the no cache and greedy methods, with performance gains up to 162.31% and 54.70% respectively for three executions. The direct execution time gain for each re-execution is 344.9% for the adaptive method in comparison with the no cache method (i.e., 3.9 hours instead of 17.7). One requirement from the use case was to make workflow execution time shorter than half a day (12 hours). The adaptive method allows for the user to re-execute the workflow on the total dataset (i.e., 11 Terabytes) in less than 4 hours. In terms of monetary costs, the adaptive method yields very good gains, up to 120.16% with 6 workflow re-executions in comparison to the no cache method and up to 254.44% for two workflow re-executions in comparison to the greedy method.</p><p>We also conducted other experiments based on the Phenomenal use case, typical of practical situations. However, because of space limitations, we can only summarize the results for two experiments: 1) execute a SWf that has already been executed with different parameters, and 2) extend an existing SWf by adding new activities. The first experiment corresponds to the situation where the user tests other possibilities with different parameters. When some parameters are changed, all the tasks depending on them and the one below need to be re-executed. For the greedy method, the overhead in cache provisioning and the storage cost increase rapidly as the number of parameters changes goes up. But the adaptive method has small overhead due to less data storage, and thus the increase of the storage cost is an order of magnitude smaller than that with greedy.</p><p>In the second experiment, the structure of the workflow is modified by adding new activities as discussed in Section 2. Similar to what happens with reexecution of a single SWf, the monetary cost of the greedy method is higher than the no cache method for up to 6 executions with different fragments or different parameters. And the execution time of greedy is always better than no cache. The adaptive method is both faster and cheaper than both no cache and greedy.</p></div>
<div><head n="6">Conclusion</head><p>In this paper, we proposed an adaptive caching solution for efficient execution of data-intensive workflows in the cloud. Our solution automatically manages the storage and reuse of intermediate data and adapts to the variations in task execution times and output data size. The adaptive aspect our solution is to take into account task compression behavior.</p><p>We implemented our solution in the <software>OpenAlea</software> system and performed extensive experiments on real data with the Phenomenal workflow, with 11 Terabytes of raw data. We compared three methods : no cache, greedy, and adaptive. Our experimental validation shows that the adaptive method allows caching only the relevant output data for subsequent re-executions by other users, without incurring a high storage cost for the cache. The results show that adaptive caching can yield major performance gains, e.g., up to 120.16% with 6 workflow reexecutions.</p><p>This work solves an important issue in experimental science like biology, where scientists extend existing workflows with new methods or new parameters to test their hypotheses on datasets that have been previously analyzed.</p></div><figure xml:id="fig_0"><head>. 1 .Fig. 1 :</head><label>11</label><figDesc>Fig. 1: Use Cases in Plant Phenotyping. 1) The Phenomenal workflow in Ope-nAlea's visual programming environment. The different colors represent different workflow fragments. 2) A conceptual view of the same workflow. 3) Raw and intermediate data such as RGB images, 3D plant volumes, skeleton, and mesh. 4-5-6) Three different SWfs that reuse the same workflow fragments to address different scientific questions.</figDesc></figure>
<figure xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: SWfMS Functional Architecture</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 3 Fig. 3 :</head><label>33</label><figDesc>Figure 3. SWfMS Technical Architecture</figDesc></figure>
<figure xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>Fig.5: Speedup versus number of vCPUs: without cache (red), greedy caching (blue), and adaptive caching (green).</figDesc></figure>
<figure xml:id="fig_5"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Monetary cost depending on the number of workflow executions.</figDesc><graphic coords="12,134.77,429.88,369.60,186.20" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head n="7">Acknowledgments</head><p>This work was supported by the #<rs type="funder">DigitAg French Convergence Lab</rs>. on Digital Agriculture (http://www.hdigitag.fr/com), the <rs type="projectName">SciDISC Inria associated</rs> team with Brazil, the <rs type="projectName">Phenome-Emphasis project</rs> (<rs type="grantNumber">ANR-11-INBS-0012</rs>) and <rs type="projectName">IFB</rs> (<rs type="grantNumber">ANR-11-INBS-0013</rs>) from the <rs type="funder">Agence Nationale de la Recherche</rs> and the <rs type="funder">France Grille Scientific Interest Group</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_xHfUD4A">
					<orgName type="project" subtype="full">SciDISC Inria associated</orgName>
				</org>
				<org type="funded-project" xml:id="_smV8X2W">
					<idno type="grant-number">ANR-11-INBS-0012</idno>
					<orgName type="project" subtype="full">Phenome-Emphasis project</orgName>
				</org>
				<org type="funded-project" xml:id="_2YQxwHQ">
					<idno type="grant-number">ANR-11-INBS-0013</idno>
					<orgName type="project" subtype="full">IFB</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Maximizing efficiency by trading storage for computation</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">F</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">D</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Storer</surname></persName>
		</author>
		<editor>HotCloud</editor>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Provenance collection support in the kepler scientific workflow system</title>
		<author>
			<persName><forename type="first">I</forename><surname>Altintas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Barney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Jaeger-Frank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Provenance and Annotation Workshop</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="118" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Openalea.phenomenal: A workflow for plant phenotyping</title>
		<author>
			<persName><forename type="first">S</forename><surname>Artzet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Brichet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chopard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mielewczik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Pradal</surname></persName>
		</author>
		<idno type="DOI">10.5281/zenodo.1436634</idno>
		<ptr target="https://doi.org/10.5281/zenodo.1436634" />
		<imprint>
			<date type="published" when="2018-09">Sep 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Vistrails: visualization meets data management</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Santos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD Int. Conf. on Management of Data (SIGMOD)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="745" to="747" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Scientific workflows for computational reproducibility in the life sciences: Status, challenges and opportunities</title>
		<author>
			<persName><forename type="first">S</forename><surname>Cohen-Boulakia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Belhajjame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Collin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chopard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Froidevaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gaignard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Hinsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Larmande</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Le Bras</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lemoine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems (FGCS)</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="284" to="298" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The cost of doing science on the cloud: the montage example</title>
		<author>
			<persName><forename type="first">E</forename><surname>Deelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Berriman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Good</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference forHigh Performance Computing, Networking, Storage and Analysis</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Common motifs in scientific workflows: An empirical analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Garijo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Alper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Belhajjame</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Corcho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Goble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems (FGCS)</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="338" to="351" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Data-intensive science: a new paradigm for biodiversity studies</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kelling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Hochachka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Riedewald</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Caruana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ballard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Hooker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BioScience</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="613" to="620" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient scheduling of scientific workflows using hot metadata in a multisite cloud</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">P</forename><surname>Morales</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pacitti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Costan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Antoniu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mattoso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A survey of data-intensive scientific workflow management</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pacitti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mattoso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Grid Computing</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="457" to="493" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An algebraic approach for data-centric scientific workflows</title>
		<author>
			<persName><forename type="first">E</forename><surname>Ogasawara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Dias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Porto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mattoso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the VLDB Endowment (PVLDB)</title>
		<meeting>of the VLDB Endowment (PVLDB)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1328" to="1339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Towards a taxonomy for cloud computing from an e-science perspective</title>
		<author>
			<persName><forename type="first">D</forename><surname>De Oliveira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Baião</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mattoso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cloud Computing. Computer Communications and Networks</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="47" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Principles of Distributed Database Systems</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Özsu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Third Edition</title>
		<imprint>
			<date type="published" when="2011">2011</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Infraphenogrid: a scientific workflow infrastructure for plant phenomics on the grid</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pradal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Artzet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chopard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dupuis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fournier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mielewczik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Negre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Neveu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parigot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems (FGCS)</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="341" to="353" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Distributed management of scientific workflows for high-throughput plant phenotyping</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pradal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cohen-Boulakia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Heidsieck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Pacitti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Tardieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Valduriez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ERCIM News</title>
		<imprint>
			<biblScope unit="volume">113</biblScope>
			<biblScope unit="page" from="36" to="37" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Review: New sensors and data-driven approaches-a path to next generation phenomics</title>
		<author>
			<persName><forename type="first">T</forename><surname>Roitsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cabrera-Bosquet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Fournier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ghamkhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Jiménez-Berni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Ober</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Plant Science</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Plant phenomics, from sensors to knowledge</title>
		<author>
			<persName><forename type="first">F</forename><surname>Tardieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cabrera-Bosquet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Pridmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bennett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Current Biology</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">15</biblScope>
			<biblScope unit="page" from="R770" to="R783" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A cost-effective strategy for intermediate data storage in scientific cloud workflow systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Int. Symp. on Parallel &amp; Distributed Processing (IPDPS)</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A highly practical approach toward achieving minimum data sets storage cost in the cloud</title>
		<author>
			<persName><forename type="first">D</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1234" to="1244" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Bridging vistrails scientific workflow management system to high performance computing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Votava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nemani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Ninth World Congress on Services</title>
		<imprint>
			<biblScope unit="page" from="29" to="36" />
			<date type="published" when="2013">2013. 2013</date>
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>