<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="fr">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Static Analysis of Graph Database Transformations</title>
				<funder ref="#_KAgtKK7">
					<orgName type="full">Poland's National Science Centre</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Iovka</forename><surname>Boneva</surname></persName>
							<email>iovka.boneva@univ-lille.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>CRIStAL, Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">UMR 9015</orgName>
								<orgName type="institution" key="instit1">Univ. Paris Saclay</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>91405</postCode>
									<settlement>LISN, Orsay</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benoit</forename><surname>Groz</surname></persName>
							<email>groz@lri.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>CRIStAL, Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
							<email>j.hidders@bbk.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>CRIStAL, Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">University of Warsaw</orgName>
								<address>
									<settlement>Warsaw</settlement>
									<country key="PL">Poland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
							<email>f.murlak@uw.edu.pl</email>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>CRIStAL, Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="department">RelationalAI Berkeley</orgName>
								<orgName type="institution">Univ. Lille</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Slawomir</forename><surname>Staworko</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution" key="instit1">Univ. Lille</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>CRIStAL, Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benoît</forename><surname>Groz</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Birkbeck</orgName>
								<orgName type="institution">University of London</orgName>
								<address>
									<settlement>London</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sławek</forename><surname>Staworko</surname></persName>
							<email>slawek.staworko@relational.ai</email>
							<affiliation key="aff5">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution">CNRS</orgName>
								<address>
									<postCode>F-59000</postCode>
									<settlement>CRIStAL, Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Static Analysis of Graph Database Transformations</title>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">BAB8A0D9307B7FDD1AEED9CD7A7D17CE</idno>
					<idno type="DOI">10.1145/3584372.3588654</idno>
					<note type="submission">Submitted on 17 Apr 2023</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>graph databases</term>
					<term>static analysis</term>
					<term>schemas</term>
					<term>query containment Vaccine Antigen Pathogen exhibits +</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>de niveau recherche, publiés ou non, émanant des établissements d'enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="fr">
		<body>
<div><head n="1">INTRODUCTION</head><p>The growing adoption of graph databases calls for suitable data processing methods. Query languages for graph databases typically define their semantics as a set of tuples, which alone is inadequate for scenarios such as (materialized) graph database views and data migration in the context of schema evolution <ref type="bibr" target="#b10">[11]</ref>, with the schema describing the expected structure of the graph. A more adequate mechanism is that of a transformation, which takes a graph as input and produces a graph on the output.</p><p>Example 1.1. Consider a scenario where the schema of a medical knowledge graph undergoes changes due to advances in the understanding of biomolecular processes. The purpose of this knowledge graph is to catalog vaccines based on the antigen they are designed to target and to identify the pathogens that exhibit the antigens, each antigen being exhibited by at least one pathogen. Additionally, some pairs of antigens are known to be cross reacting: if a vaccine v targets an antigen x that is cross reacting with an antigen y, then v also targets y. Thus, the set of all antigens targeted by a vaccine is represented implicitly.</p><p>The schema S 0 of the original knowledge graph is presented in Figure <ref type="figure" target="#fig_7">1</ref> as a graph itself. It specifies the allowed node and edge outputs a graph conforming to the target schema, and equivalence, that verifies if two transformations produce the same output for every graph conforming to the source schema. Additionally, when the target schema is not known, we investigate the problem of target schema elicitation that constructs the containment-minimal target schema that captures the graphs produced by the transformation.</p><p>We study executable graph transformations defined with Dataloglike rules. The rules specify how to construct the output graph from the results of regular path queries evaluated over the input graph. To allow multiple copies of the same input node the rules use node constructors, essentially explicit Skolem functions that create nodes. As an example, the cross-reactivity rule from Example 1.1 gives rise to the following graph transformation rule targets(f V (x), f A (y)) ← (designTarget • crossReacting * )(x, y) , where f V (x) and f A (y) are constructors of Vaccine and Antigen nodes respectively. The two constructors can, for instance, have the following definitions f V (x) = (Vaccine, x) and f A (y) = (Antigen, y); essentially, they take the identifiers of the original nodes and decorate them with their type.</p><p>We investigate transformations that use only acyclic two-way conjunctive regular path queries (acyclic C2RPQs), which is arguably of practical relevance in the context of graph transformations. For instance, we have found no cyclic queries in the transformations implementing graph data migration between consecutive versions of the FHIR data format <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b52">53]</ref> (Fast Healthcare Interoperability Resources is an international standard for interchange of medical healthcare data). Our constructions rely on acyclicity of C2RPQs to obtain relatively low computational complexity. We argue that the acyclicity assumption cannot be lifted without a significant complexity increase (see <ref type="bibr">Section 7)</ref>.</p><p>Node constructors are closely related to object creating functions <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b36">37]</ref>. Our use of node constructors is inspired by analogous constructions in transformation languages such as R2RML <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b54">55]</ref>, where node IRIs are typically obtained by concatenation of a URL prefix and the key values of a object represented by the constructed node. Our node constructors can have an arbitrary arity, thus allowing for instance to create nodes in the target graph that represent relationships (edges) between nodes in the source graph. To isolate the concern of possible overlaps between node constructors, we make the natural assumption that node constructors are injective, have pair-wise disjoint ranges, and for every node kind (label) a single dedicated node constructor is used. These assumptions allow us to remove the need to analyze the definitions of node constructors, which is out of the scope of the present paper, and they are consistent with how the analogous constructions are used in languages such as R2RML and FHIR mapping language.</p><p>For schemas, we employ a natural formalism of graph schemas with participation constraints, inspired by standard data modeling languages such as Entity-Relationship diagrams <ref type="bibr" target="#b16">[17]</ref>, and already studied, for instance, in the context of graph database evolution <ref type="bibr" target="#b10">[11]</ref>. Such schemas allow one to declare the available labels of nodes and edges and to express participation constraints. In contrast to more expressive languages as ShEx and SHACL <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b56">57]</ref>, our formalism allows a single label per node, which determines the node type. Thus, roughly speaking, our schema formalism is to ShEx and SHACL what DTD is to XML Schema.</p><p>The key contributions of the present paper are as follows.</p><p>(1) We define graph database transformations and we reduce the problems of interest to containment of C2RPQs in unions of acyclic C2RPQs modulo schemas. <ref type="bibr" target="#b1">(2)</ref> We reduce the query containment problem to the unrestricted (finite or infinite) satisfiability of a C2RPQ modulo a set of constraints expressed in the Horn fragment of a description logic known as ALCIF .</p><p>The reduction involves an application of the cycle reversing technique <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b37">38]</ref>, carefully tailored to our needs. <ref type="bibr" target="#b2">(3)</ref> The unrestricted satisfiability problem for ALCIF can be solved in EXPTIME owing to a simple model property <ref type="bibr" target="#b15">[16]</ref>, but applying this result directly to the instance obtained via cycle reversing would lead to doubly exponential complexity due to an exponential blow-up inherent to cycle reversing. We provide a new algorithm with improved complexity bounds, which allows to accommodate the blow-up while keeping the overall complexity in EXPTIME.</p><p>We also reformulate the simplicity of models in terms of a graph-theoretical notion of (k, l)-sparsity <ref type="bibr" target="#b43">[44]</ref>, which allows to streamline the reasoning.</p><p>These reductions allow to solve all problems of interest in EXPTIME and we also establish the matching lower bounds. The paper is organized as follows. In Section 2 we discuss related work. In Section 3 we introduce basic notions. In Section 4 we define graph transformations and the problems of interest, which we reduce to query containment modulo schema. In Section 5 we reduce the latter to satisfiability of a query modulo Horn-ALCIF theory, which we solve in Section 6. In Section 7 we summarize our findings and identify directions of future work. Full proofs and some standard definitions have been moved to Appendix.</p></div>
<div><head n="2">RELATED WORK</head><p>Graph-based data models have been proposed in various forms and shapes since the 1980s <ref type="bibr" target="#b3">[4]</ref>.</p><p>The proposals in the 1980s and 1990s included labeled graphs <ref type="bibr" target="#b31">[32]</ref>, graphs where certain nodes represent complex values <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b42">43]</ref>, graphs where nodes have associated complex values <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, and graphs where nodes are associated with nested graphs <ref type="bibr" target="#b44">[45]</ref>. More recently the RDF data model <ref type="bibr" target="#b29">[30]</ref> and the Property Graph data model <ref type="bibr" target="#b2">[3]</ref> have become popular. RDF graphs are similar to labeled graphs except that nodes are unlabeled and participate in at least one edge, and the labels of edges can be nodes and participate in edges. Property Graphs are also similar to labeled graphs except that nodes and edges have multiple labels and properties, and edges have identity. In our work we assume one of the simplest models, namely, labeled graphs where nodes have multiple labels and edges have a single label; our schemas require exactly one label per node. Since we focus here on transformations of the graph structure, we have no explicit notion of value associated with nodes and edges, but there are straightforward ways of adding this, as is done for example in <ref type="bibr" target="#b31">[32]</ref>.</p><p>The term graph transformations can refer to different formalisms <ref type="bibr" target="#b53">[54]</ref>: the purpose of graph grammars is to define graph languages; algebraic graph transformations are mainly used to model systems with infinite behavior and are not functional (they produce multiple outputs on single input). Therefore, not only are these formalisms ill-suited for defining transformations of graph databases, but also the problems studied for them are unrelated to the problems we study here. Monadic second-order (MSO) graph transductions <ref type="bibr" target="#b20">[21]</ref> can capture our transformations only when restricted to unary node constructors; moreover, resorting to MSO logic typically incurs a prohibitive complexity overhead.</p><p>Transformation languages for graph databases are often based on Datalog extended with node-creation syntax in the head of the rules. It could be just a variable that is not bound in the body of the rule, like in IQL <ref type="bibr" target="#b1">[2]</ref> and G-Log <ref type="bibr" target="#b50">[51]</ref>; this ensures a fresh node is created for each valuation that makes the body true. Another option is to replace the unbound variable with a term consisting of a constructor function (sometimes called a Skolem function) applied to bound variables, like in O-logic <ref type="bibr" target="#b45">[46]</ref> and F-logic <ref type="bibr" target="#b40">[41]</ref>; the constructor creates a fresh node when called for the first time for certain arguments, and after that the same node for the same arguments. We adopt the idea of node constructors because we believe it provides a powerful and intuitive way to control the identity of new nodes.</p><p>A different proposal, based on structural recursion, is offered by UnQL <ref type="bibr" target="#b11">[12]</ref>, but the underlying data model considers graphs equivalent if they are bisimilar, which makes the expressive power quite different.</p><p>Graph transformations can also be expressed using query languages such as <software>SPARQL</software> and <software ContextAttributes="used">Cypher</software>.</p><p>Nevertheless, we believe that a rule-based transformation language is more convenient for defining transformations and it can co-exist with an expressive query language. For instance, in the XML world, XSLT <ref type="bibr" target="#b39">[40]</ref> (rule-based) focuses on transformations, while <software ContextAttributes="used">XQuery</software> <ref type="bibr" target="#b55">[56]</ref> is mostly used for querying XML data.</p><p>In the context of data exchange, schema mappings provide a declarative way to define database transformations <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b23">24]</ref>. Our transformations could be simulated by considering canonical solutions for plain SO-tgds <ref type="bibr" target="#b4">[5]</ref> extended to allow acyclic C2RPQs in rule bodies. Note, however, that equivalence is undecidable for plain SO-tgds with keys <ref type="bibr" target="#b24">[25]</ref>, and open for plain SO-tgds <ref type="bibr" target="#b41">[42]</ref>.</p><p>The static type checking problem originates in formal language theory and has been studied for finite state transducers on words and for various kinds of tree transducers, including some designed to capture XML transformation languages <ref type="bibr" target="#b46">[47]</ref><ref type="bibr" target="#b47">[48]</ref><ref type="bibr" target="#b48">[49]</ref><ref type="bibr" target="#b49">[50]</ref>. Type checking has also been studied for graph transformations. In <ref type="bibr" target="#b32">[33]</ref> labelled graphs are transformed using addition, deletion, and reduction operations, and type checking is investigated for schemas similar to ours but without participation constraints. The typing problem for UnQL is studied in <ref type="bibr" target="#b38">[39]</ref>, but the approach relies on schemas specifying graphs up to bisimulation, which limits their power to express participation constraints. Regarding transformations defined by schema mappings, if the mapping does not define target constraints, then the target schema is simply a relational signature and type checking is reduced to trivial syntactic check, and as such it is irrelevant. This is most often the case for graph schema mappings <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13]</ref>, with seldom exceptions such as <ref type="bibr" target="#b9">[10]</ref> for mapping relational to graph-shaped data. Their notion of consistency is related to type checking, but is studied for a simpler formalism without path queries. In the context of XML schema mappings, absolute consistency can be seen as a counterpart of type checking for non-functional transformations <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div><head n="3">PRELIMINARIES</head><p>Graphs. We fix an enumerable set N of node identifiers, a recursively enumerable set Γ of node labels, and an recursively enumerable set Σ of edge labels. We work with labeled directed graphs, and in general, a node may have multiple labels while an edge has precisely one label. We allow, however, multiple edges between the same pair of nodes, as long as these edges have different labels. We model graphs as relational structures over unary relation symbols Γ and binary relation symbols</p><formula xml:id="formula_0">Σ. That is, a graph G is a pair dom(G), • G where dom(G) ⊆ N is the set of nodes of G and the function • G maps each A ∈ Γ to a set A G ⊆ dom(G) and each r ∈ Σ to a binary relation r G ⊆ dom(G) × dom(G). A graph G is finite if dom(G)</formula><p>is finite and A G and r G are empty for all but finitely many A ∈ Γ and r ∈ Σ. In the sequel, we use u, v, . . . to range over node identifiers, A, B, C, . . . to range over node labels, and r , r ′ , . . . to range over edge labels. Also, we use r -for inverse edges and let</p><formula xml:id="formula_1">(r -) G = (u, v) | (v, u) ∈ r G . We let Σ ± = Σ ∪ {r -| r ∈ Σ} and use R, R ′ , . . . to range over Σ ± .</formula><p>Schemas. We consider a class of schemas that constrain the number of edges between nodes of given labels and we express these constraints with the usual symbols: ? for at most one, 1 for precisely one, + for at least one, * for arbitrary many, and 0 for none. We focus on these basic cardinality constraints that are most commonly used in practice; e.g., Chen's original ER diagrams only used those <ref type="bibr" target="#b16">[17]</ref>. In fact, we were unable to find any non-basic cardinality constraints in the FHIR specifications <ref type="bibr" target="#b33">[34]</ref>, while in the SHACL schemas in Yago 4.0 <ref type="bibr" target="#b57">[58]</ref> we found only one: a person may have at most two parents. Now, a schema is a triple S = (Γ S , Σ S , δ S ), where Γ S ⊆ Γ is a finite set of allowed node labels, Σ S ⊆ Σ is a finite set of allowed edge labels, and δ S : Γ S × Σ ± S × Γ S → {?, 1, +, *, 0}. Schemas can be presented as graphs themselves, interpreted as illustrated next.</p><p>Example 3.1. Take the schema S 0 in Figure <ref type="figure" target="#fig_7">1</ref> and consider, for instance, the designTarget edge. It indicates that every Vaccine has a single design target Antigen, in symbols</p><formula xml:id="formula_2">δ S 0 (Vaccine, designTarget, Antigen) = 1 ,</formula><p>and that every Antigen may be the design target of an arbitrary number of Vaccines, in symbols</p><formula xml:id="formula_3">δ S 0 (Antigen, designTarget -, Vaccine) = * .</formula><p>Edges that are not present are implicitly forbidden, e.g., no exhibits edge is allowed from Vaccine to Pathogen:</p><formula xml:id="formula_4">δ S 0 (Vaccine, exhibits, Pathogen) = 0 , δ S 0 (Pathogen, exhibits -, Vaccine) = 0 . □</formula><p>Now, a graph G conforms to a schema S if 1) every node in G has a single node label in Γ S and every edge has a label in Σ S , and 2) for all A, B ∈ Γ S and R ∈ Σ ± S , for every node with label A the number of its R-successors with label B is as specified by δ S (A, R, B). By L(S) we denote the set of all finite graphs that conform to S.</p><p>Queries. We work with conjunctive two-way regular path queries (C2RPQs) that have the form</p><formula xml:id="formula_5">q( x) = ∃ ȳ.φ 1 (z 1 , z ′ 1 ) ∧ . . . ∧ φ k (z k , z ′ k ) , where x = {z 1 , z ′ 1 , . . . , z k , z ′ k } \ ȳ</formula><p>and for every i ∈ {1, . . . , k}, z i and z ′ i are variables and the formula φ i is a regular expression that follows the grammar</p><formula xml:id="formula_6">φ ::= | ϵ | A | R | φ • φ | φ + φ | φ * ,</formula><p>where A ∈ Γ matches nodes, R ∈ Σ ± matches edges, ϵ matches empty paths, and matches no path. The semantics of C2RPQs is defined in the standard fashion <ref type="bibr" target="#b14">[15]</ref> and we denote the set of answers to q( x) in G by [q( x)] G .</p><p>Example 3.2. Recall the schema S 0 in Figure <ref type="figure" target="#fig_7">1</ref>. The following query selects vaccines together with the antigens they are designed to target or target through cross-reaction.</p><formula xml:id="formula_7">q(x, y) = (Vaccine • designTarget • crossReacting * • Antigen)(x, y). □</formula><p>Trivial atoms are of the form (x, x), ϵ(x, x), and A(x, x), and in the sequel, we abuse notation and write them as unary atoms: (x), ϵ(x), and A(x), respectively. The multigraph of a C2RPQ q has variables of q as nodes and an edge from x to y for every nontrivial atom φ(x, y). The subclass of acyclic C2RPQs consists of queries whose multigraph is acyclic i.e., it does not have a path consisting of distinct edges that visits the same node twice. Note that acyclicity for C2RPQs needs to be more restrictive than the classical acyclicity of conjunctive queries based on Gaifman graphs. Indeed, the Gaifman graph of a C2RPQ φ(x, y) ∧ ψ (x, y) is acyclic but its matches may form nontrivial cycles in the input graph.</p><p>A Boolean C2RPQ q has all its variables existentially quantified, and it may have only a single answer, the empty tuple, in which case, we say that q is satisfied in G and write G |= q. We also use unions of C2RPQs (abbreviated as UC2RPQs) represented as sets of C2RPQs Q( x) = {q 1 ( x), . . . , q k ( x)} and extend the notions of answers, satisfaction, and acyclicity to UC2RPQs in the natural fashion. Given two UC2RPQs P( x) and Q( x), and a schema S, we say that</p><formula xml:id="formula_8">P( x) is contained in Q( x) modulo S, in symbols P( x) ⊆ S Q( x), if [P( x)] G ⊆ [Q( x)] G for every G ∈ L(S).</formula><p>Description logics. We operate on properties of graphs formulated in the description logic ALCIF (and its fragments) <ref type="bibr" target="#b5">[6]</ref>. In description logics, elements of Γ and Σ are called concept names and role names, respectively. ALCIF allows to build more complex concepts with the following grammar:</p><formula xml:id="formula_9">C ::= ⊥ | A | C ⊓ C | ¬C | ∃R.C | ∃ ≤1 R.C ,</formula><p>where A ∈ Γ and R ∈ Σ ± . We also use additional operators that are redundant but useful when defining fragments; for brevity we introduce them as syntactic sugar:</p><formula xml:id="formula_10">⊤ := ¬⊥, C 1 ⊔ C 2 := ¬(¬C 1 ⊓ ¬C 2 ),</formula><p>∀R.C := ¬∃R.¬C, R.C := ¬∃R.C. We extend the interpretation function • G to complex concepts as follows: </p><formula xml:id="formula_11">⊥ G = ∅ , (C 1 ⊓ C 2 ) G = C G 1 ∩ C G 2 , (¬C) G = dom(G) \ C G , (∃R.C) G = u ∈ dom(G) | ∃v. (u, v) ∈ R G ∧ v ∈ C G , (∃ ≤1 R.C) G = u ∈ dom(G) | ∃ ≤1 v. (u, v) ∈ R G ∧ v ∈ C G .</formula></div>
<div><head>Statements in description logics</head><formula xml:id="formula_12">G |= T if G |= C ⊑ D for each C ⊑ D ∈ T .</formula><p>In the Horn fragment of ALCIF , written Horn-ALCIF , we only allow concept inclusions in the following normal forms:</p><formula xml:id="formula_13">K ⊑ A , K ⊑ ⊥ , K ⊑ ∀R.K ′ , K ⊑ ∃R.K ′ , K ⊑ R.K ′ , K ⊑ ∃ ≤1 R.K ′ ,</formula><p>where A ∈ Γ, R ∈ Σ ± , and K, K ′ are intersections of concept names (intersection of the empty set of concepts is ⊤). If statements of the form</p><formula xml:id="formula_14">K ⊑ A 1 ⊔ A 2 ⊔ • • • ⊔ A n are</formula><p>allowed too, then we recover the full power of ALCIF (up to introducing auxiliary concept names). Participation constraints of schemas can be expressed with simple Horn-ALCIF statements as illustrated in following example.</p><p>Example 3.3. For instance, the assertion in S 0 (Figure <ref type="figure" target="#fig_7">1</ref>) that Pathogen manifests at least one Antigen is expressed with the statement Pathogen ⊑ ∃exhibits.Antigen. The assertion that an Antigen may be exhibited by an arbitrary number of Pathogens needs no Horn-ALCIF statement. However, statements are needed for implicitly forbidden edges, e.g., Vaccine ⊑ exhibits.Antigen. □</p></div>
<div><head n="4">GRAPH TRANSFORMATIONS</head><p>We propose transformations of graphs defined with Datalog-like rules that use acyclic C2RPQs in their bodies. To allow multiple copies of the same source node we use node constructors. Formally, a k-ary node constructor is a function f : N k → N and we denote the set of node constructors by F . To remove the concern of overlapping node constructors, and the need to analyze their definitions, we assume that for every node label A ∈ Γ we have precisely one node constructor f A , all node constructors are injective, and their ranges are pairwise disjoint. We introduce two kinds of graph transformation rules: node rules and edge rules. A node rule has the form</p><formula xml:id="formula_15">A f A ( x) ← q( x) ,</formula><p>where A ∈ Γ, f A ∈ F , and q is an acyclic C2RPQ. An edge rule has the form r f ( x), f ′ ( ȳ) ← q( x, ȳ) , where r ∈ Σ, f , f ′ ∈ F , and q is an acyclic C2RPQ. Note that an equality between variables z = z ′ can be expressed as ϵ(z, z ′ ), and consequently, we can assume that x and ȳ are disjoint. Now, a graph transformation T is a finite set of graph transformation rules. By Γ T and Σ T we denote the finite sets of node and edge labels, respectively, used in the heads of the rules of T .</p><p>Example 4.1. Below we present rules defining the transformation T 0 of the medical database, described in Example 1.1. We use 3 unary node constructors f A (x) for Antigen nodes, f P (x) for Pathogen nodes, and f V (x) for Vaccine nodes.</p><formula xml:id="formula_16">Vaccine(f V (x)) ← (Vaccine)(x) , Antigen(f A (x)) ← (Antigen)(x) , designTarget(f V (x), f A (y)) ← (designTarget)(x, y) , targets(f V (x), f A (y)) ← (designTarget • crossReacting * )(x, y) , Pathogen(f P (x)) ← (Pathogen)(x) , exhibits(f P (x), f A (y)) ← (exhibits)(x, y) . □</formula><p>Now, given a graph G and a graph transformation T the result of applying T to G is a graph T (G) such that (for A ∈ Γ and r ∈ Σ)</p><formula xml:id="formula_17">A T (G) = f A (t) A f A ( x) ← q( x) ∈ T , t ∈ [q( x)] G , r T (G) = f (t), f ′ (t ′ ) r f ( x), f ′ ( ȳ) ← q( x, ȳ) ∈ T , (t, t ′ ) ∈ [q( x, ȳ)] G .</formula><p>We are interested in the following two classical static analysis tasks.</p><p>Type checking Given a transformation T , a source schema S, and a target schema S ′ check whether for every G that conforms to S the output of transformation T (G) conforms to S ′ . Equivalence Given a source schema S and two transformations T 1 and T 2 check whether T 1 and T 2 agree on every graph that conforms to S. In settings where the target schema is not known, it might be useful to construct one. Naturally, we wish to preclude a trivial solution that produces the universal schema that accepts all graphs over a given set of node and edge labels. Instead, we propose to construct a schema that offers the tightest fit to the set of output graphs. To define formally this requirement, we define schema containment in the classical fashion: a schema S is contained in S ′ if and only if L(S) ⊆ L(S ′ ).</p><p>Schema elicitation Given a transformationT and a source schema S, construct the containment-minimal target schema S ′ such that T (G) ∈ L(S ′ ) for every G ∈ L(S). We observe that T (G) may have nodes with no label, which may preclude it from satisfying any schema, and consequently, schema elicitation may also return error.</p><p>We prove the main result by reducing the problems of interest to query containment modulo schema (and vice versa), which we later show to be EXPTIME-complete. Although schema elicitation is not a decision problem, we show EXPTIME-completeness of deciding if the result of schema elicitation is equivalent to a given schema. Should schema elicitation have lesser complexity, so would have the corresponding decision problem since schema equivalence is easily decided in polynomial time.</p><p>Theorem 4.2. Type checking, schema elicitation, and equivalence of graph transformations are EXPTIME-complete.</p><p>We outline the main ideas of the proof by illustrating how a transformation T can be analyzed with a toolbox of methods based on query containment modulo source schema S. We formulate these methods with an entailment relation:</p><formula xml:id="formula_18">(T , S) |= K ⊑ K ′ iff T (G) |= K ⊑ K ′ for every G ∈ L(S).</formula><p>W.l.o.g. we assume that every rule of transformation T is trim i.e., it uses in its body a query q( x) that is satisfiable modulo S, in symbols ∃ x .q( x) ⊈ S ; otherwise, T can be trimmed.</p><p>First, we group queries from rules of T based on the labels of nodes and edges they create. For A, B ∈ Γ T and r ∈ Σ T we define</p><formula xml:id="formula_19">Q A ( x) = q( x) A f A ( x) ← q( x) ∈ T , Q A,r, B ( x, ȳ) = q( x, ȳ) r f A ( x), f B ( ȳ) ← q( x, ȳ) ∈ T , Q A,r -, B ( x, ȳ) = q( ȳ, x) r f B ( ȳ), f A ( x) ← q( ȳ, x) ∈ T .</formula><p>In essence, Q A ( x) identifies tuples over the input graph that yield a node constructed with f A and with label A while Q A, R, B ( x, ȳ) identifies tuples that yield R-edges from a node created with f A to a node created with f B . </p><formula xml:id="formula_20">Q Vaccine (x) = (Vaccine)(x) , Q Vaccine,targets,Antigen (x, y) = (designTarget • crossReacting * )(x, y) , Q Vaccine,designTarget,Antigen (x, y) = (designTarget)(x, y) . □</formula><p>Since an edge rule does not assign labels to nodes it creates, the result of a transformation may be a graph with nodes without a label. Such a situation precludes type checking from passing and prevents schema elicitation from producing meaningful output. Consequently, we first verify that every node in every output graph has exactly one label, in symbols (T , S) |= ⊤ ⊑ Γ T , where {A 1 , . . . , A k } is a shorthand for A 1 ⊔ . . . ⊔ A k . We prove the following (Lemma B.6).</p><formula xml:id="formula_21">(T , S) |= ⊤ ⊑ Γ T iff ∃ ȳ.Q A, R, B ( x, ȳ) ⊆ S Q A ( x) for all A, B ∈ Γ T and R ∈ Σ ± T .</formula><p>We point out that the restriction of one node constructor per node label ensures that each node of the output has at most one label.</p><p>Example 4.4. Take T 0 from Example 4.1 and S 0 in Figure <ref type="figure" target="#fig_7">1</ref>. Verifying that (T 0 , S 0 ) |= ⊤ ⊑ Γ T 0 requires a number of containment tests including the following two.</p><p>∃y.(designTarget</p><formula xml:id="formula_22">• crossReacting * )(x, y) ⊆ S 0 (Vaccine)(x) , ∃y.(designTarget)(x, y) ⊆ S 0 (Vaccine)(x) . □</formula><p>Now, to perform type checking against a given target schema S ′ , we verify that Γ T ⊆ Γ S ′ and Σ T ⊆ Σ S ′ . Then, we take the TBox T S ′ of concept inclusions that expresses participation constraints of the target schema S ′ and we verify that (T , S) |= T S ′ . Type checking succeeds if and only if all the above tests succeed (Lemma B.2). The TBox T S ′ consists of statements from a small fragment L 0 of Horn-ALCIF which allows only statements of the forms</p><formula xml:id="formula_23">A ⊑ ∃R.B , A ⊑ R.B , A ⊑ ∃ ≤1 R.B ,</formula><p>where A, B ∈ Γ and R ∈ Σ ± . The entailment of such statements is also reduced to query containment (Lemma B.7):</p><formula xml:id="formula_24">(T , S) |= A ⊑ ∃R.B iff Q A ( x) ⊆ S ∃ ȳ.Q A, R, B ( x, ȳ) , (T , S) |= A ⊑ R.B iff ∃ ȳ.Q A ( x)∧Q A, R, B ( x, ȳ) ⊆ S i (x i ) , (T , S) |= A ⊑ ∃ ≤1 R.B iff ∃ x .Q A ( x)∧Q A, R, B ( x, ȳ)∧Q A, R, B ( x, z) ⊆ S i ϵ(y i , z i ) .</formula><p>Example 4.5. Take the transformation T 0 and the schemas S 0 and S 1 in Figure <ref type="figure" target="#fig_7">1</ref>. The schema S 1 requires every vaccine to target at least one antigen, in symbols Vaccine ⊑ ∃targets.Antigen. This statement is entailed by T 0 and S 0 if and only if the following holds</p><formula xml:id="formula_25">(Vaccine)(x) ⊆ S 0 ∃y.(designTarget • crossReacting * )(x, y) . □</formula><p>For schema elicitation, we use a close correspondence between schemas and L 0 TBoxes. It is sufficient to construct the TBox T containing all L 0 statements that are entailed by T and S; T corresponds to the containment-minimal target schema (Lemma B.5). Finally, the equivalence of two transformations T 1 and T 2 is essentially the equivalence (modulo S) of the respective queries and Q A,R, B of both transformations (Lemma B.8). Naturally, query equivalence is reduced to query containment, as usual.</p><formula xml:id="formula_26">Q A S: A s ? + r * * S * : A s 1 1 r * * G 0 : s s s s s r G ∞ : . . . s s s r . . . s s s . . . s s G * ∞ : . . . . . . s s s r s s s</formula><p>We have shown that type checking, schema elicitation, and equivalence of graph transformations are Turing-reducible in polynomial time to testing containment of UC2RPQs in acyclic UC2RPQs modulo schema. We also show polynomial-time reductions of containment of 2RPQs modulo schema to all above problems of interest (Lemma F.2). With that, Theorem 4.2 follows from Theorem 5.1.</p></div>
<div><head n="5">QUERY CONTAINMENT MODULO SCHEMA</head><p>The aim of this section is to show the following result.</p><p>Theorem 5.1. Containment of UC2RPQs in acyclic UC2RPQs modulo schema is EXPTIME-complete.</p><p>The lower bound can be derived from the EXPTIME-hardness of unrestricted containment of 2RPQs (using only edge labels) modulo very simple TBoxes. The latter is obtained by reduction from another reasoning task (satisfiability of ALCI TBoxes) and relies on the inner workings of its hardness proof. For completeness, we provide a direct reduction from the acceptance problem for polynomial-space alternating Turing machines (Theorem F.1). The remainder of this section is devoted to the upper bound. We show it by reduction to unrestricted (finite or infinite) satisfiability of C2RPQs modulo a Horn-ALCIF TBox, which we discuss in Section 6. The principal technique applied in the reduction is cycle reversing <ref type="bibr" target="#b19">[20]</ref>.</p><p>Let S be a schema, P a UC2RPQ, and Q an acyclic UC2RPQ. Without loss of generality we may assume that P and Q are Boolean (see Lemma D.1). The key idea is to pass from finite to possibly infinite graphs, thus making canonical witnesses for non-containment easier to find. However, as Example 5.2 shows, we cannot pass freely from finite to possibly infinite graphs, as this may affect the answer.</p><p>Example 5.2. Consider the schema S in Figure <ref type="figure" target="#fig_2">2</ref>. Observe that S allows infinite graphs that are essentially infinite trees when restricted to s-edges, e.g. G ∞ in Figure <ref type="figure" target="#fig_2">2</ref>. In fact, every infinite graph satisfying S that is connected when restricted to s-edges is an infinite tree. On the other hand, every non-empty finite graph that conforms to S is a collection of disjoint cycles when restricted to s-edges, e.g., G 0 in Figure <ref type="figure" target="#fig_2">2</ref>. Clearly, the topology of finite and infinite graphs defined by the schema differs drastically. Now, take the queries P = ∃x .r (x, x), Q = ∃x, y.(r • s + • r )(x, y), and observe that P ⊆ S Q. However, the containment does not hold over infinite graphs: P is satisfied by G ∞ while Q is not.</p><p>□</p><p>The reason why we cannot pass directly to infinite models is that finite graphs conforming to schema S may display certain additional common properties, detectable by queries, but not shared by infinite graphs conforming to S. The cycle reversing technique <ref type="bibr" target="#b19">[20]</ref> captures these properties in S * such that</p><formula xml:id="formula_27">S: A s ? + r * * G: . . . u u ′ u ′′ A ⊓ B r A ⊓ B r •s + A ⊓ B r •s + s s s r</formula><formula xml:id="formula_28">P ⊆ S Q iff P ⊆ ∞ S * Q</formula><p>where by ⊆ ∞ S * we mean containment over possibly infinite graphs conforming to S * . However, as the following example shows, we cannot obtain S * by analysing S alone.</p><p>Example 5.3. In Example 5.2 we saw that in a finite graph conforming to S, each node has exactly one incoming and one outgoing s-edge. We can use this observation to tighten the original schema S to the schema S * (Figure <ref type="figure" target="#fig_2">2</ref>). Alas, we still have</p><formula xml:id="formula_29">P ⊈ ∞ S * Q because there is an infinite graph G * ∞ that satisfies P but not Q. □</formula><p>Instead, we first reduce containment modulo schema to finite satisfiability, fusing the schema S and the query Q into a single Horn-ALCIF TBox, and then pass from finite to unrestricted satisfiability by applying cycle reversing to the resulting TBox. We follow closely the approach of Ibáñez-García et al. <ref type="bibr" target="#b37">[38]</ref>, relying crucially on some of their results.</p><p>Let T be a Horn-ALCIF TBox. A finmod cycle is a sequence</p><formula xml:id="formula_30">K 1 , R 1 , K 2 , R 2 , . . . , K n-1 , R n-1 , K n where R 1 , . . . , R n-1 ∈ Σ ± and K 1 , . . . , K n are conjunctions of con- cept names such that K n = K 1 and T |= K i ⊑ ∃R i .K i+1 and T |= K i+1 ⊑ ∃ ≤1 R - i .K i for 1 ≤ i &lt; n.</formula><p>By reversing the finmod cycle we mean extending T with concept inclusions</p><formula xml:id="formula_31">K i+1 ⊑ ∃R - i .K i and K i ⊑ ∃ ≤1 R i .K i+1 for 1 ≤ i &lt; n.</formula><p>The completion T * of a TBox T is obtained from T by exhaustively reversing finmod cycles. The following key result is stated in <ref type="bibr" target="#b37">[38]</ref> in terms of sets of ground facts (so-called ABoxes) rather than subgraphs, but our formulation is equivalent. </p><formula xml:id="formula_32">⊤ ⊑ A , A ⊑ ∃s.A , A ⊑ ∃ ≤1 s -.A . Non-satisfaction of Q is captured by TBox T ¬Q that consists of ⊤ ⊑ ∀r .B r , B r ⊑ ∀s.B r •s + , B r •s + ⊑ ∀s.B r •s + , B r •s + ⊑ ∀r .⊥ . Let T = T S ∪ T ¬Q and observe that A ⊓ B r •s + , s , A ⊓ B r •s + is a finmod cycle in T .</formula><p>By reversing it, we obtain</p><formula xml:id="formula_33">A ⊓ B r •s + ⊑ ∃s -.A ⊓ B r •s + and A ⊓ B r •s + ⊑ ∃ ≤1 s.A ⊓ B r •s + .</formula><p>Now, suppose that there exists a (finite or infinite) model G of T * that satisfies P (see Figure <ref type="figure" target="#fig_3">3</ref>). G must have a node u with (u, u) ∈ r G . It follows already from T that u ∈ (A ⊓ B r ) G and that u has an</p><formula xml:id="formula_34">s-successor u ′ ∈ (A ⊓ B r •s + ) G . The statement A ⊓ B r •s + ⊑ ∃s -.A ⊓ B r •s + in T * implies that u ′ has an s --successor u ′′ ∈ (A ⊓ B r •s + ) G .</formula><p>As each node has at most one incoming s-edge, u = u ′′ and u ∈ (B r •s + ) G . But u has an outgoing r -edge, which contradicts the last concept inclusion in T ¬Q . Thus, P is not satisfied in T * . □</p><p>We are now ready to reduce containment modulo schema to unrestricted satisfiability modulo Horn-ALCIF TBox. Note that the guarantees on the resulting TBox in the statement below are sufficient to conclude Theorem 5.1 using Theorem 6.1.</p><p>Theorem 5.6. Given a UC2RPQ P, an acyclic UC2RPQ Q, and a schema S, one can compute in EXPTIME a UC2RPQ P of polynomial size and a Horn-ALCIF TBox T using linearly many additional concept names and polynomially many at-most constraints, such that P ⊆ S Q if and only if P is (unrestrictedly) unsatisfiable modulo T .</p><p>Let us sketch the proof. Let T S be the Horn-ALCIF TBox corresponding to S. Note that apart from the explicit restrictions captured in T S the schema S also ensures that only graphs with exactly one label per node are considered. To ensure at most one label from Γ S per node, we use the TBox</p><formula xml:id="formula_35">T S = T S ∪{A⊓B ⊑ ⊥ | A, B ∈ Γ S , A B}.</formula><p>The concept inclusion ⊤ ⊑ Γ S , expressing that each node has at least one label from Γ S , is not Horn and cannot be used. Instead, we modify the query P.</p><formula xml:id="formula_36">Assuming Γ S = {A 1 , A 2 , . . . , A n }, we include (A 1 + A 2 + • • • + A n ) before</formula><p>and after each edge label used in an atom of P. Additionally, to ensure that P uses only labels allowed by S, we substitute in P each label not in Γ S ∪ Σ ± S by . Letting P be the resulting query, we have</p><formula xml:id="formula_37">P ⊆ S Q iff P ⊆ T S Q (see Lemma D.3</formula><p>). Because Q is acyclic, by adapting the rolling-up technique <ref type="bibr" target="#b34">[35]</ref> one can compute in PTIME a Horn-ALCIF TBox T ¬Q over an extended set of concept names Γ S ∪ Γ Q such that</p><formula xml:id="formula_38">P ⊆ T S Q iff P is finitely unsatisfiable modulo T S ∪ T ¬Q .</formula><p>(see Lemma C.2). Since T S ∪ T ¬Q is a Horn-ALCIF TBox, we can consider its completion T S ∪ T ¬Q *</p><p>. As UC2RPQs are witnessed by finite subgraphs whenever they are satisfied, we can infer from Theorem 5.4 that P is finitely satisfiable modulo T S ∪ T ¬Q iff P is satisfiable modulo T S ∪ T ¬Q * (see Lemma D.4). It remains to compute the completion. Reversing cycles does not introduce new concept names, but it may generate exponentially many concept inclusions. Identifying a finmod cycle involves deciding unrestricted entailment of Horn-ALCIF concept inclusions, which is decidable in EXPTIME <ref type="bibr" target="#b25">[26]</ref>. However, since the input TBox might grow to an exponential size as more and more cycles are reversed, it is unlikely that the completion can be computed in EXPTIME for every Horn-ALCIF TBox. Our key insight is that T S ∪ T ¬Q enjoys a particular property, invariant under reversing cycles, that keeps the complexity under control.</p><p>A concept inclusion (CI) of the form</p><formula xml:id="formula_39">K ⊑ ∃R.K ′ or K ⊑ ∃ ≤1 R.K ′ is relevant for a TBox T if the triple (K, R, K ′ ) is satisfiable modulo T ; that is, some model G of T contains nodes u and u ′ such that u ∈ K G , (u, u ′ ) ∈ R G , and u ′ ∈ (K ′ ) G . We say that T is S-driven if for each relevant CI in T of the form K ⊑ ∃R.K ′ (resp. K ⊑ ∃ ≤1 R.K ′ ), T contains A ⊑ ∃R.A ′ (resp. A ⊑ ∃ ≤1 R.A ′ ) for some A, A ′ ∈ Γ S such that A ∈ K, A ′ ∈ K ′ ;</formula><p>here and later we blur the distinction between conjunctions of concept names and sets of labels. Note that T S ∪ T ¬Q is trivially S-driven, as all its existential and at-most constraints are of the form A ⊑ ∃R.A ′ or A ⊑ ∃ ≤1 R.A ′ . Lemma 5.7. Every S-driven TBox T can be simplified in polynomial time so that it contains at most</p><formula xml:id="formula_40">|Σ ± S | • |Γ S | 2 at-most constraints.</formula><p>From our results in Section 6 it follows that unrestricted entailment for a Horn-ALCIF TBox T with k concept names and ℓ at-most constraints can be solved in time O poly(|T |) • 2 poly(k, ℓ) (Corollary E.7). Hence, it would suffice to show that by reversing a finmod cycle in an S-driven TBox, we obtain another S-driven TBox. In fact, we prove something weaker, but sufficient to compute the completion in EXPTIME, and conclude that it is S-driven.</p><p>Let K 1 , R 1 , . . . , K n-1 , R n-1 , K n be a finmod cycle in an S-driven Horn-ALCIF TBox T . Reversing it will extend T with CIs</p><formula xml:id="formula_41">K i+1 ⊑ ∃R - i .K i and K i ⊑ ∃ ≤1 R i .K i+1 for 1 ≤ i &lt; n. If all triples (K i , R i , K i+1</formula><p>) are unsatisfiable wrt T , then all CIs to be added are irrelevant for T and we are done. Suppose that some</p><formula xml:id="formula_42">(K i , R i , K i+1 ) is satisfiable. Then, in the model for (K i , R i , K i+1 )</formula><p>we can trace the finmod cycle forward, witnessing each triple. Hence, the whole cycle is satisfiable (all its triples are). Then, we can show that there are unique</p><formula xml:id="formula_43">A 1 , A 2 , . . . , A n ∈ Γ S such that A i ∈ K i for all i ≤ n, and A 1 , R 1 , . . . , A n-1 , R n-1 , A n is a finmod cycle in T (Lemma D.6). By reversing it, we can add to T CIs A i+1 ⊑ ∃R - i .A i and A i ⊑ ∃ ≤1 R i .A i+1</formula><p>for 1 ≤ i &lt; n, which makes the resulting extension S-driven.</p><p>Based on the obtained invariant we can compute the completion T S ∪ T ¬Q * in EXPTIME (Lemma D.7). By reducing T S ∪ T ¬Q * as described above, we obtain the desired TBox T , thus completing the proof of Theorem 5.6.</p></div>
<div><head n="6">SATISFIABILITY MODULO TBOX</head><p>The last missing piece is to solve the unrestricted satisfiability of C2RPQs modulo Horn-ALCIF . <ref type="bibr">Calvanese et al.</ref> show that the problem is in EXPTIME not only for Horn-ALCIF , but even for ALCIF extended with additional features <ref type="bibr" target="#b15">[16]</ref>. This result is not directly applicable, because our reduction produces a TBox of exponential size. The following theorem gives the more precise complexity bounds that we need. Calvanese et al. solve the problem by first showing a simple model property and then providing an algorithm testing existence of simple models. We rely on the same simple model property, but design a new algorithm with the desired complexity bounds. Yet, rather than diving into the details of the algorithm, we devote most of this section to the simple model property. We do it to show a connection to an elegant graph-theoretical notion that helps to simplify the reasoning considerably, at least for ALCIF . We begin by illustrating how simple models are obtained for queries satisfiable modulo schemas (rather than arbitrary TBoxes). Example 6.2. Take the schema S in Figure <ref type="figure" target="#fig_6">4</ref> (its two types are represented with a blue square and a red circle), and consider the following satisfiable (cyclic) query</p><formula xml:id="formula_44">p(x, y) = (a • b • c + • d • a)(x, y) ∧ (a * )(x, y) ∧ (a * • b • d • a * )(x, y) .</formula><p>Since p is satisfiable modulo S, we take any graph conforming to S where p is satisfied, and we choose any 3 paths witnessing each of the regular expressions of p. We construct the initial graph G 0 consisting of the 3 paths joined at their ends: it might look like the one in Figure <ref type="figure" target="#fig_6">4</ref>. We observe that S requires every red circle node to have at most one outgoing a-edge and at most one incoming a-edge (to and from a red circle node). The initial graph G 0 violates this requirement and to enforce it we exhaustively merge offending nodes. The final graph G t is a simple model of p modulo S. □</p><p>We formalise simple models using a graph-theoretic notion of sparsity proposed by Lee and Streinu <ref type="bibr" target="#b43">[44]</ref>. We say that a connected graph G with n nodes and m edges is c-sparse if m ≤ n + c. (In Lee and Streinu's terminology this corresponds to (1, -c)-sparsity.) Being c-sparse is preserved under adding and removing nodes of degree 1. By exhaustively removing nodes of degree 1 from a csparse graph G we arrive at single node or a connected c-sparse graph H in which all nodes have degree at least 2. Assuming c ≥ 1, it is not hard to see that such a graph consists of at most k = 2c distinguished nodes connected by at most l = 3c simple paths disjoint modulo endpoints (see Lemma E.1). We call such a graph a (k, l)-skeleton, and we refer to the graph H above as the skeleton of G. Thus, a c-sparse graph consists of a (2c, 3c)-skeleton and a number of attached trees; by attaching a tree to a graph we mean taking their disjoint union and adding a single edge between the root of the tree and some node of the graph.</p><p>For the purpose of the simple model property we need to lift the notion of c-sparsity to infinite graphs. We call a (possibly infinite) graph c-sparse if it consists of a finite connected c-sparse graph with finitely many finitely branching trees attached. Theorem 6.3. A connected C2RPQ p is satisfiable in a possibly infinite model of an ALCIF TBox T iff p is satisfiable in a possibly infinite |p|-sparse model of T .</p><p>Proof. Let c be the difference between the number of atoms and the number of variables of p. Because p is connected, c ≥ -1. By definition, p understood as a graph with variables as nodes and atoms as edges is c-sparse.</p><p>We write H → H ′ to indicate that there is a homomorphism from graph H to graph H ′ ; that is, a function h mapping nodes of H to nodes of H ′ that preserves node labels and the existence of labelled edges between pairs of nodes. Let G be a (possibly infinite) model of p and T . We construct a sequence of finite connected c-sparse graphs of strictly decreasing size</p><formula xml:id="formula_45">G 0 → G 1 → • • • → G t → G</formula><p>such that G 0 |= p and the homomorphism from G t to G is injective over R-successors of every node, for each R.</p><p>To construct G 0 let us fix a match of p in G together with a (finite) witnessing path for each atom of p. We construct G 0 as follows.</p><p>For each variable x of p we include a node v x whose set of labels is identical to that of the image of x in G under the fixed match. Next, for each atom of p that connects variables x and y we add a simple path connecting x and y such that the sequence of edge labels and sets of node labels read off of this path is identical to that of the witnessing path of this atom in G. This graph can be seen as a specialization of p where each regular expression is replaced by a single concrete word, except that we include full sets of labels of nodes, as they are encountered in the witnessing path in G. It follows immediately that G 0 |= p and that G 0 → G. To see that G 0 is c-sparse one can eliminate the internal nodes of the connecting paths one by one, like in the proof of Lemma E.1, until a graph isomorphic to p remains.</p><p>We define the remaining graphs G i inductively, maintaining an additional invariant G i → G. Suppose we already have G i together with a homomorphism h i : G i → G for some i ≥ 0. If h i is injective over R-successors of each node of G i , we are done. If not, there are two different R-successors u 1 and u 2 of a node v in G i that are mapped to the same node u ′ in G. It follows that u 1 and u 2 have the same sets of labels types. We let G i+1 be the graph obtained from G i by merging u 1 and u 2 into a single node u. We include an R ′ -edge between u and each R ′ -successor of u 1 or u 2 . This decreases the number of nodes by one, and the number or edges by at least one. It follows that G i+1 is c-sparse and</p><formula xml:id="formula_46">G i → G i+1 → G.</formula><p>Because the sizes of graphs G i are strictly decreasing, at some point we will arrive at a graph G t such that the homomorphism from G t to G is injective over R-successors.</p><p>The graph G t clearly satisfies p. It also satisfies all concept inclusions in T of the forms</p><formula xml:id="formula_47">K ⊑ A 1 ⊔ A 2 ⊔ • • • ⊔ A n , K ⊑ ⊥, K ⊑ ∀R.K ′ , K ⊑ R.K ′ , and K ⊑ ∃ ≤1 R.K ′ ,</formula><p>because h i is injective over Rsuccessors and G |= T . On the other hand, G t is not guaranteed to satisfy concept inclusions of the form K ⊑ ∃R.K ′ in T . In order to fix it, we exhaustively (ad infinitum) perform the following: whenever a node v in G t is missing an R-successor with some set of labels, we add it and map it to some such R-successor u ′ of the image of v in G (u ′ exists because G |= T ). As c ≤ |p|, the resulting (typically infinite) graph G is |p|-sparse, and it satisfies p and T . □</p><p>The connectedness assumption in Theorem 6.3 is not restrictive, because a witnessing graph for p can be obtained by taking the disjoint union of witnesses for its connected components. Hence, it remains to decide for a given connected p if there exists a |p|sparse graph G that satisfies p and T . To get a finer control of the effect different parameters of the input have on the complexity, we side-step two-way alternating tree automata (2ATA) applied by Calvanese et al. and develop a more direct algorithm.</p><p>Observe that if p is satisfied in a |p|-sparse graph G, then G contains a (4|p|, 5|p|)-skeleton H ′ , extending the skeleton of G, such that all variables of p are mapped to distinguished nodes of H ′ . Indeed, H ′ can be obtained by iteratively extending the skeleton of G. Suppose that some variable is mapped to a node v that is not yet a distinguished node of H ′ . If v already belongs to H ′ , then it is an internal node in a path between two distinguished nodes; we then split the path in two, turning v into a distinguished node. If v does not belong to H ′ , then it belongs to a tree attached to H ′ at a node u. If u is not a distinguished node of H ′ , we turn it into one, as above. Then, we add v to H ′ as a distinguished node, including the path between u and v into H ′ as well. As we start from a (2|p|, 3|p|)skeleton and add at most two distinguished nodes and two paths for each variable of p, we end up with a (4|p|, 5|p|)-skeleton.</p><p>Thus, the algorithm can guess a (4|p|, 5|p|)-skeleton H ′ with each path represented by a single symbolic edge and check that it can be completed to a suitable graph G by materializing symbolic edges into paths and attaching finitely many finitely branching trees in such a way that G is a model of T and there is a match of p in G that maps variables of p to distinguished nodes of H ′ . This can be done within the required time bounds by means of a procedure that can be seen as a variant of type elimination or an emptiness test for an implicitly represented nondeterministic tree automaton (see Theorem E.3).</p></div>
<div><head n="7">DISCUSSION</head><p>Summary. In this paper we have studied several static analysis problems for graph transformations defined with Datalog-like rules that use acyclic C2RPQs. When the source schema is given, we studied the equivalence problem of two given transformations, and the problem of target schema elicitation for a given transformation. If the output schema is also given, we have studied the problem of type checking. We have shown that the above problems can be reduced to containment of C2RPQs in acyclic UC2RPQs modulo schema, a problem that we have reduced to the unrestricted (finite or infinite) satisfiabilty of a C2RPQ modulo Horn-ALCIF TBox using cycle reversing. For the latter problem we have presented an algorithm with sufficiently good complexity to accommodate the exponential blow-up introduced by cycle reversing, thus allowing to solve in EXPTIME all problems of interest. We have also shown matching lower bounds by reducing query containment modulo schema to each of the static analysis problems.</p><p>Finite containment modulo Horn-ALCIF TBox. In the course of the proof of the upper bound for containment modulo schema, we essentially solved (finite) containment modulo Horn-ALCIF TBox. Indeed, while the EXPTIME upper bound relies on the special shape of the TBox expressing the schema, the method can be applied directly to any Horn-ALCIF TBox, at the cost of an exponential increase in complexity. Thus, we immediately get that finite containment of UC2RPQs in acyclic UC2RPQs modulo Horn-ALCIF TBoxes can be solved in 2EXPTIME. To the best of our knowledge this is the first result on finite containment of C2RPQs in the context of description logics. A related problem of finite entailment has been studied for various logics <ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b30">31]</ref>, but while for conjunctive queries the solutions carry over to finite containment, for C(2)RPQs these logics are too weak to allow this. Unrestricted containment of C2RPQs modulo ALCIF TBoxes is known to be in 2EXPTIME <ref type="bibr" target="#b15">[16]</ref>, but passing from unrestricted to finite structures is typically challenging for such problems. For example, finite entailment of CRPQs for a fundamental description logic ALC has been solved only recently <ref type="bibr" target="#b30">[31]</ref>, 15 years after the unrestricted version <ref type="bibr" target="#b13">[14]</ref>.</p><p>Extending queries. It is straightforward to extend our methods to two-way nested regular expressions (NREs) <ref type="bibr" target="#b51">[52]</ref>. We also intend to investigate introducing negation in filter expressions of NREs. Eliminating the acyclicity assumption, on the other hand, is problematic. Containment of arbitrary C2RPQs is EXPSPACE-complete <ref type="bibr" target="#b14">[15]</ref>, and we have shown that it reduces to our problems of interest for transformation rules with cyclic queries. Hence, extending our EX-PTIME upper bounds to transformations allowing cyclic C2RPQs is highly unlikely. In fact, even establishing decidability would be hard. For acyclic queries we could use the rolling-up technique to reduce containment to satisfiability, which allowed us to apply the cycle reversing technique and pass from finite to unrestricted models. When cyclic queries are allowed, the rolling-up technique is inapplicable and we are left with containment of C2RPQs modulo constraints, which is a major open problem, not only for constraints expressed in description logics. The only positive results we are aware of do not go significantly beyond CQs extended with a binary reachability relation <ref type="bibr" target="#b22">[23]</ref>.</p><p>Extending schemas. Extending the schema formalism with disjunction is also challenging: the corresponding description logic would not be Horn any more and the transition to unrestricted models via cycle reversing would not be possible. Supporting multiple labels on nodes would not be a trivial extension either: we rely on the single label per node assumption in the reduction of the problems of interest to containment of UC2RPQs in acyclic UC2RPQs, and in the EXPTIME upper bound. Supporting more general cardinality constraints, on the other hand, should be possible, but it might affect the complexity upper bounds.</p><p>Extending the data model. It is straightforward to encode data values in our graph model, for instance, by using dedicated node labels to designate literal nodes whose identifiers are their data values. Then, one can apply methods similar to type checking to verify that transformations are well-behaved, and in particular, do not attempt to construct literal nodes from non-literal ones. However, the full consequences of allowing literal values in definitions of transformation rules need to be thoroughly investigated.</p><p>Finally, we have considered equivalence of transformations based on equality of results but one could also consider a variant based on isomorphism of results. This would be an entirely different problem, probably much harder.</p></div>
<div><head>A DETAILS ON QUERIES</head><p>A two-way regular expression is an expression defined with the following grammar.</p><p>φ</p><formula xml:id="formula_48">::= | ϵ | A | R | φ • φ | φ + φ | φ * ,</formula><p>where A ∈ Γ and R ∈ Σ ± . We define the semantics with the notion of witnessing paths that we formalize next. Given a graph G, a path from</p><formula xml:id="formula_49">u 0 to u k in G is a sequence π = u 0 • ℓ 1 • u 1 • . . . • u k -1 • ℓ k • u k</formula><p>such that u 0 , . . . , u k are nodes of G, ℓ 1 , . . . , ℓ k ∈ Γ ∪ Σ ± , and for every i ∈ {1, . . . , k } the following conditions are satisfied:</p><formula xml:id="formula_50">(1) if ℓ i ∈ Γ, then u i-1 = u i and u i ∈ ℓ G i , (2) if ℓ i ∈ Σ ± , then (u i-1 , u i ) ∈ ℓ G i . The labeling of π is ℓ 1 •. . .•ℓ n .</formula><p>Given a two-way regular expression φ we define the corresponding binary relation on nodes of the graph: (u, v) ∈ [φ] G iff there is a path from node u to node v in G whose labeling is recognized by φ. Now, a conjunctive two-way regular path query (C2RPQ) is a formula of the form</p><formula xml:id="formula_51">q( x) = ∃ ȳ.φ 1 (z 1 , z ′ 1 ) ∧ . . . ∧ φ k (z k , z ′ k )</formula><p>, where for every i ∈ {1, . . . , k} the formula φ i is a two-way regular expression and x = {z 1 , z ′ 1 , . . . , z k , z ′ k } \ ȳ. A C2RPQ is Boolean if all of its variables are existentially quantified.</p><p>Evaluating a C2RPQ q( x) over a graph G yields a set [q( x)] G of tuples over x i.e., functions that assign nodes of G to elements of x. Formally, t ∈ [q( x)] G iff there is a tuple t ′ over ȳ such that the two tuples combined t ′′ = t ∪ t ′ satisfy all atoms i.e., (t ′′ (z i ), t ′′ (z ′ i )) ∈ [φ i ] G for every i ∈ {1, . . . , k}. When the query is Boolean, then it may have only a single answer, the empty tuple () i.e., the unique function with the empty domain. If indeed () ∈ [q] G we say that q is satisfied in G and denote it by G |= q; otherwise, when [q] G = ∅, we say that q is not satisfied in G and we write G ̸ |= q.</p><p>For defining transformations we employ the subclass of acyclic C2RPQs. Formally, for a query q we construct its query multigraph whose nodes are variables and for every atom φ(x, y) we add an edge (x, y) unless the atom is of the form A(x, x), ϵ(x, x), or (x, x). q is acyclic if its query multigraph is acyclic.</p><p>Finally, the semantics of unions of conjunctive two-way regular path queries (UC2RPQs), represented as sets of C2RPQs, is defined simply as:</p><formula xml:id="formula_52">[{Q 1 ( x), . . . , Q k ( x)}] G = [Q 1 ( x)] G ∪ . . . ∪ [Q k ( x)] G .</formula><p>A UC2RPQ is acyclic if all of its components are acyclic. A Boolean UC2RPQ consists of Boolean C2RPQs.</p></div>
<div><head>B PROOFS FOR TRANSFORMATIONS</head><p>We begin by introducing elements of useful terminology. Given any finite subsets Γ 0 ⊆ Γ and Σ 0 ⊆ Σ, we say that a schema S is over Γ 0 and Σ 0 if Γ S = Γ 0 and Σ S = Σ 0 . Analogously, we say that a ALCIF TBox T is over Γ 0 and Σ 0 if all base concept names and base rule names used in T are from Γ 0 and Σ 0 respectively. Also, we say that a graph G is over Γ 0 and Σ 0 if G does not use any node or edge label outside of Γ 0 and Σ 0 , and we extend this notion to families of graphs in the canonical fashion: G is a family of graphs over Γ 0 and Σ 0 if every graph in G is over Γ 0 and Σ 0 . Finally, a transformation T is over Γ 0 and Σ 0 if all rules in T use in their heads node and edge labels in Γ 0 and Σ 0 respectively.</p><p>However, for a transformation we shall need to identify tighter sets of node and edge labels when the input schema is known. As such, a transformation rule ρ ← q( x) is productive modulo a schema S if q( x) ⊈ S . A transformation T is trimmed modulo S if 1) every rule in T is productive modulo S, 2) for every A ∈ Γ T there is an A-node rule in T , and 3) for every r ∈ Σ T there is a r -edge rule in T . Naturally, checking that a transformation is trimmed can be Turing-reduced in polynomial time to testing query containment modulo schema. Moreover, for a given schema S we can trim a given transformation T by removing all unproductive rules and removing from Γ T and Σ T any symbols that are not present in the head of any of the remaining rules.</p><p>Next, an L 0 TBox over Γ 0 and Σ 0 is a set of statements of the forms</p><formula xml:id="formula_53">A ⊑ ∃R.B, A ⊑ R.B, A ⊑ ∃ ≤1 R.B,</formula><p>where A, B ∈ Γ 0 and R ∈ Σ ± 0 . T is coherent iff 1) T does not contains two contradictory rules A ⊑ ∃R.B and A ⊑ R.B for any A, B ∈ Γ and R ∈ Σ ± , and 2) T contains A ⊑ ∃ ≤1 R.B whenever it contains A ⊑ R.B. Now, for a given schema S the corresponding L 0 TBox T S (over Γ S and Σ S ) is defined as follows.</p><formula xml:id="formula_54">T S = {A ⊑ ∃R.B | A, B ∈ Γ S , R ∈ Σ ± S , δ S (A, R, B) ∈ {1, +}} ∪ {A ⊑ ∃ ≤1 R.B | A, B ∈ Γ S , R ∈ Σ ± S , δ S (A, R, B) ∈ {1, ?, 0}} ∪ {A ⊑ R.B | A, B ∈ Γ S , R ∈ Σ ± S , δ S (A, R, B) = 0}.</formula><p>It is easy to see that there is one-to-one correspondence between schemas and coherent TBoxes. More precisely, given Γ 0 ⊆ Γ and Σ 0 ⊆ Σ, for any schema S over Γ 0 and Σ 0 , T S is a coherent TBox over Γ S and Σ S , and for any coherent TBox T over Γ 0 and Σ 0 there is a unique schema S over Γ 0 and Σ 0 such that T S = T . Naturally, T S also captures the semantics of the cardinality constraints of S. Later we prove how to reduce entailment of statements to query containment. Before, we address the problem of schema elicitation by observing that the correspondence between schemas and their L 0 TBoxes is tighter. We first need to establish two auxiliary results. The first one characterizes the containment of schemas, which is expressed as an extension of a syntactic containment relation ≼ on the symbols used to specify participation constraints. More precisely, we define ≼ as the transitive and reflexive closure of the following assertions: 0 ≼ ?, 1 ≼ ?, ? ≼ +, and + ≼ *.</p><p>Proposition B.3. Take finite Γ 0 ⊆ Γ and Σ 0 ⊆ Σ. Given two schemas S 1 and S 2 over Γ 0 and Σ 0 , L(S 1 ) ⊆ L(S 2 ) if and only if</p><formula xml:id="formula_55">δ S 1 (A, R, B) ≼ δ S 2 (A, R, B)</formula><p>for every A, B ∈ Γ 0 and R ∈ Σ ± 0 . Proof. For the if part, we take any G that conforms to S 1 and we note first that every node of G has exactly one label in Γ 0 . Also, for any A, B, ∈ Γ 0 and any R ∈ Σ ± 0 we observe that</p><formula xml:id="formula_56">δ S 1 (A, R, B) ≼ δ S 2 (A, R, B)</formula><p>implies that any A-node in G whose number of R-successors with label B satisfies the participation constraint δ S 1 (A, R, B) will also satisfy δ S 2 (A, R, B). □</p><p>Next, we establish correspondence between L 0 theories of sets of graphs and their containment-minimal schemas.</p><p>Proposition B.4. Take finite Γ 0 ⊆ Γ and Σ 0 ⊆ Σ and take any nonempty family G of graphs over Γ 0 and Σ 0 such that G |= ⊤ ⊑ Γ 0 and G |= A ⊓ B ⊑ ⊥ for all A, B ∈ Γ 0 . Let T be the set of all L 0 statements over Γ 0 and Σ 0 that hold in every graph in G. Then, T corresponds to the containment minimal schema S over Γ 0 and Σ 0 such that G ⊆ L(S).</p><p>Proof. We first argue that T is coherent. Indeed, should T contain two contradictory statements A ⊑ ∃R.B and A ⊑ R.B, then no graph in G could satisfy T and we know that G is nonempty. Consequently, T corresponds to a schema that we denote</p><formula xml:id="formula_57">S • = (Γ 0 , Σ 0 , δ S • ). Naturally, G ⊆ L(S • ) because G |= ⊤ ⊑ Γ 0 and G |= A ⊓ B ⊑ ⊥.</formula><p>Now, take any schema S over Γ 0 and Σ 0 such that G ⊆ L(S). We show that L(S • ) ⊆ L(S) with a proof by contradiction. Suppose L(S • ) ⊈ L(S). By Proposition B.3, there are A, B ∈ Γ 0 and R ∈ Σ ± 0 such that δ S • (A, R, B) δ S (A, R, B). This means that T S contains an (A, R, B)-constraint ϕ that T S • does not (by (A, R, B)-constraints we mean A ⊑ ∃R.B, A ⊑ ∃ ≤1 R.B, and A ⊑ R.B). Since ϕ T S • there is a graph G ∈ G such that H ̸ |= ϕ, and consequently, G does not conform to S. Thus G ⊈ L(S), a contradiction. □</p><p>We obtain the following result allowing to solve the problem of schema elicitation problem. Proof. The proof follows immediately from Proposition B.4 except for the case when T is empty. Then, however, Γ T and Σ T are empty too and so is T . However, the schema that corresponds to T is also empty and it recognizes only empty graphs. As such it is the containment minimal schema over Γ T and Σ T that contains</p><formula xml:id="formula_58">{T (G) | G ∈ L(S)} ⊆ {∅}. □</formula><p>To move to reducing entailment of statements to query containment we repeat the definitions of the relevant queries but in this version we clearly indicate the transformation in question. More precisely, For a transformation T , A, B ∈ Γ T , and r ∈ Σ T we define:</p><formula xml:id="formula_59">Q T A ( x) = q( x) A f A ( x) ← q( x) ∈ T , Q T A,r, B ( x, ȳ) = q( x, ȳ) r f A ( x), f B ( ȳ) ← q( x, ȳ) ∈ T , Q T A,r -, B ( x, ȳ) = q( ȳ, x) r f B ( ȳ), f A ( x) ← q( ȳ, x) ∈ T .</formula><p>Now, we prove that the entailment of ⊤ ⊑ Γ T is reduced to query containment.</p><p>Lemma B.6. Given a schema S and a transformation T , (T , S)</p><formula xml:id="formula_60">|= ⊤ ⊑ Γ T if and only if ∃ ȳ.Q T A,R, B ( x, ȳ) ⊆ S Q T A ( x) for every A, B ∈ Γ T and R ∈ Σ ± T .</formula><p>Proof. For the if direction, we take any graph G ∈ L(S) and any element in u ∈ dom(T (G)). This element has been introduced by node rule or by an edge rule, but only the latter is of concern. Thus, assume that u = f (t) has been generated by the rule</p><formula xml:id="formula_61">R(f A ( x), f B ( ȳ)) ← Q( x, ȳ) with the valuation x = t and ȳ = t ′ . Since (t, t ′ ) ∈ Q T A, R, B (G) and ∃ ȳ.Q T A, R, B ( x, ȳ) ⊆ S Q T A ( x), t ∈ Q T A (G)</formula><p>, and therefore, there is a node rule</p><formula xml:id="formula_62">A(f A ( x)) ← Q ′ ( x) such that t ∈ Q ′ (G). Consequently, u ∈ A T (G) .</formula><p>For the only if direction, we take any G ∈ L(S) and any answer</p><formula xml:id="formula_63">(t, t ′ ) ∈ Q T A, R, B ( x, ȳ) which implies that (t, t ′ ) ∈ q( x, ȳ) for some rule R(f A ( x), f B ( ȳ)) ← q( x, ȳ). Consequently, T (G) contains the fact R(f A (t), f B (t ′ )).</formula><p>Since T (G) satisfies the statement ⊤ ⊑ Γ T and nodes constructed with f A can only be part of node label assertions with A, T (G) |= f A (t). Therefore, there must be a rule G) . □ Lemma B.7. Take a schema S and a transformation T , such that Γ T ⊆ Γ S , Σ S ⊆ Σ S , and (T , S) |= ⊤ ⊑ Γ T . For any A, B ∈ Γ T and any R ∈ Σ ± T we have that</p><formula xml:id="formula_64">A(f A ( x) ← q ′ ( x) that generated the fact f A (t) with the valuation x = t. Consequently, t ∈ [Q A ] T (</formula><formula xml:id="formula_65">(T , S) |= A ⊑ ∃R.B iff Q A ( x) ⊆ S Q T A, R, B ( x), (T , S) |= A ⊑ R.B iff ∃ ȳ.Q A ( x)∧Q T A, R, B ( x, ȳ) ⊆ S , (T , S) |= A ⊑ ∃ ≤1 R.B iff ∃ x .Q T A ( x)∧Q T A, R, B ( x, ȳ)∧Q T A, R, B ( x, z) ⊆ S i [ϵ(y i , z i ).</formula><p>Proof. We prove each of the 3 claims separately.</p><p>(1) For the if part, we fix a graph G ∈ L(S) and take any node u = f A (t) with label A in T (G). Thus, there is a node rule</p><formula xml:id="formula_66">A(f A ( x)) ← q( x) such that t ∈ [q( x)] G and consequently, t ∈ [Q T A ( x)] G . Since Q T A ( x) ⊆ S Q T A, R, B ( x), t ∈ [Q T A, R, B ( x)] G and there exists rule R(f A ( x), f B ( ȳ)) ← q ′ ( x, ȳ) such that (t, t ′ ) ∈ [q ′ ( x, ȳ)] G . Consequently, T (G) contains the edge R(f A (t), f B (t ′ )). Because T (G) satisfies ⊤ ⊑ Γ T , there is also a rule B(f B ( ȳ)) ← q ′′ ( ȳ) such that t ′ ∈ [q ′′ ( ȳ)] G , and hence the node f B (t ′ ) has label B in G.</formula><p>For the only if part, we fix a graph G ∈ L(S) and take any t ∈</p><formula xml:id="formula_67">[Q T A ] G , which means that there is a node rule A(f A ( x)) ← q( x) with t ∈ [q( x)] G . Consequently, A(f A (t)) belongs to T (G). Since M 0 (G) |= A ⊑ ∃R.B, G has an edge R(f A (t), v)</formula><p>and the node v has label B. This edge must be generated by an edge rule R(f A ( x), f B ( ȳ)) ← q ′ ( x, ȳ). Consequently, t belongs to the answers to ∃ ȳ.q ′ ( x, ȳ)] which is contained in</p><formula xml:id="formula_68">Q A, R, B ( x) modulo S.</formula><p>(2) The proof of this statement is by contradiction and it uses arguments that are analogous to those used in the proof of the above claim and we only outline it. We take a graph G ∈ L(S) such that in T (G) there is a node f A (t) with label A and an R-edge to a node with with label B. This happens if and only if the intersection of Q A ( x) and ∃ ȳ.Q A, R, B ( x, ȳ) is non-empty. (3) Similarly, the proof is by contradiction but uses argument analogous to those in the proof of the first claim and we only outline it. We take a graph G ∈ L(S) such that T (G)</p><formula xml:id="formula_69">has an A-node f A (t) which has R-edges to two different B- nodes f B (t ′ 1 ) and f B (t ′ 2 )</formula><p>. This is possible if and only if the query</p><formula xml:id="formula_70">∃ x .Q T A ( x) ∧ Q T A, R, B ( x, ȳ) returns both t ′ 1 and t ′ 2 , and consequently, ∃ x .Q T A ( x) ∧ Q T A, R, B ( x, ȳ) ∧ Q T A, R, B ( x, z) ⊆ S i ϵ(y i , z i ) returns (t ′ 1 , t ′ 2 )</formula><p>. Because node constructors are invective, t ′ 1 t ′ 2 , and therefore, (t ′ 1 , t ′ 2 ) cannot be answer to i ϵ(y i , z i ).</p><p>□</p><p>For testing equivalence of two transformations we observe that since a transformation is equivalent to its trimmed version, two transformations T 1 and T 2 are equivalent modulo S if and only if they trimmed versions trim S (T 1 ) and trim S (T 2 ) are equivalent modulo S. In the following lemma,</p><formula xml:id="formula_71">Q 1 ≡ S Q 2 is short for Q 1 ⊆ S Q 2 and Q 2 ⊆ S Q 1 .</formula><p>Lemma B.8. Take a schema S and two transformations T 1 and T 2 that are both trimmed modulo S. We have that T 1 ≡ S T 2 if and only if the following conditions are satisfied:</p><formula xml:id="formula_72">(1) Γ T 1 = Γ T 2 and Σ T 1 = Σ T 2 , (2) Q T 1 A ( x) ≡ S Q T 2 A ( x) for every A ∈ Γ T 1 , (3) Q T 1 A, R, B ( x, ȳ) ≡ S Q T 2 A,R, B ( x, ȳ) for every A, B ∈ Γ T 1 , R ∈ Σ T 1 .</formula><p>Proof. The if part is trivial. We prove the only if part by proving the contraposition: we show that if one of the conditions (1), (2), and (3) is not satisfied, then T 1 S T 2 .</p><p>If (1) is not satisfied, then one of the transformations has at least one rule ρ that generate a node or an edge with a label that is not employed by the other transformations. Since both transformations are trimmed, there exists an input graph G such that the rule ρ produces objects on the output. But then T 1 (G) T 2 (G).</p><p>If ( <ref type="formula">2</ref>) is not satisfied, then there is an input graph G such that one of the transformations generates a node that the other does not. Hence, T 1 (G) T 2 (G).</p><p>If (3) is not satisfied, then analogously, there is an input graph G such that one of the transformations generates an edge that the other does not. Hence, T 1 (G) T 2 (G). □</p></div>
<div><head>C ROLLING UP QUERIES</head><p>We next show how to reduce the non-satisfaction of an acyclic UC2RPQ Q to the satisfaction of a Horn-ALCIF TBox T ¬Q . The TBox Q is basically a recursive program that defines a collection of sets (monadic relations) of nodes. We illustrate this construction with the following example.</p><p>Example C.1. We take the following Boolean query.</p><formula xml:id="formula_73">Q 0 = ∃x 0 , x 1 , x 2 , x 3 . (a • b * • c)(x 2 , x 1 ) ∧ (A)(x 3 , x 1 ) ∧ (a -)(x 1 , x 0 ).</formula><p>We construct a TBox that essentially simulates automata for the regular expressions, which are presented in Figure <ref type="figure" target="#fig_8">5</ref>. The TBox T ¬Q 0 consists of the following constraints. ⊤ ⊑ q 0 , q 0 ⊑ ∀a.q 1 , q 1 ⊑ ∀b.q 1 , q 1 ⊑ ∀c.q 2 , ⊤ ⊑ q 3 , q 3 ⊓ A ⊑ q 4 , q 2 ⊓ q 4 ⊑ q 5 , q 5 ⊑ ∀a -.q 6 , q 6 ⊑ ⊥ . □ T ¬Q introduces a set fresh node labels Γ Q and the satisfaction T ¬Q is defined in terms of the existence of valuations of symbols in Γ Q . More precisely, given a graph G over Γ 0 and Σ 0 and a TBox T over Γ 0 ∪ Γ 1 and Σ 0 , we say that G satisfies T if and only if there is an interpretation</p><formula xml:id="formula_74">q 0 q 1 a q 2 c b q 3 q 4 A q 5 q 6 a -</formula><formula xml:id="formula_75">• U : Γ 1 → P(dom(G)) of symbols in Γ 1 such that G ∪ U |= T .</formula><p>Lemma C.2. Given a Boolean acyclic UC2RPQs Q, one can compute in polynomial time a Horn-ALCIF TBox T ¬Q and a reserved set of concept names Γ Q such that for every G that does not use labels in</p><formula xml:id="formula_76">Γ Q , G ̸ |= Q if and only if G satisfies T ¬Q .</formula><p>Proof. We prove the lemma for queries that are Boolean C2RPQs that are acyclic and connected. The claim extends to unions of Boolean acyclic C2RPQs in a straightforward fashion: it suffices to take the union of the desired TBoxes of all connected components of the union. Consequently, the query can be seen as a tree and we assume that it is defined with the following grammar:</p><formula xml:id="formula_77">Q ::= φ(Q, . . . , Q),</formula><p>where φ is a two-way regular expression over Σ and Γ. For instance, the query from Example C.1 is represented as</p><formula xml:id="formula_78">Q 0 = a -(A, a • b * • c).</formula><p>We express the semantics of such defined queries as the set of all nodes that satisfy it.</p><formula xml:id="formula_79">[φ(Q 1 , . . . , Q k )] G = {u ∈ dom(G) | ∃v. (v, u) ∈ [φ] G , v ∈ i [Q i ] G }. Naturally, a graph G satisfies Q iff [Q] G ∅.</formula><p>Now, fix an acyclic Boolean C2RPQ Q and let Φ be the set of all two-way regular expressions used in Q. For any φ ∈ Φ by N φ = (K φ , I φ , δ φ , F φ ) we denote an ϵ-free NDA over the alphabet Σ ∪ Γ that recognizes φ, where K φ is a finite set of states, I φ ⊆ K φ is the set of initial states, F φ ⊆ K φ is the set of final states, and δ φ ⊆ K φ ×(Σ∪Γ)×K φ is the transition table. We assume that the size of N φ is polynomial in the size of the expression φ (such automaton can be obtained for instance with the standard Glushkov technique). We also assume that the sets of states are pair-wise disjoint.</p><p>The set of additional node labels consists of the states of automata: Γ Q = φ K φ . The constructed TBox consists of two subsets of rules: T ¬Q = T 1 ∪ T 0 . The set T 1 encodes transitions of the automata that simulate their execution.</p><p>(1) For every φ and every (q, R, q ′ ) ∈ δ φ such that R ∈ Γ ± , T 1 contains q ⊑ ∀R.q ′ ; (2) For every φ and every (q, A, q ′ ) ∈ δ φ such that A ∈ Σ, T 1 contains q ⊓ A ⊑ q ′ ;</p><p>(3) For every node φ of Q with children φ 1 , . . . , φ k , every q ∈ I φ ,</p><formula xml:id="formula_80">T 1 contains {q ′ | q ′ ∈ F φ i , 1 ≤ i ≤ k} ⊑ q.</formula><p>Note that when φ is a leaf of Q, then T 1 contains ⊤ ⊑ q for every q ∈ I φ .</p><p>The set T 0 contains denial rules that ensure lack of valid run. (4) For every q ∈ F φ of the root φ of Q, T 0 contains q ⊑ ⊥; Now, we fix a graph G whose node labels do not use any symbol in Γ Q . We first argue that there is a unique minimal interpretation U 0 : Γ Q → P(dom(G)) such that G ∪ U 0 |= T 1 . Indeed, since the rules are Horn-like, an intersection of two models of T 1 is also a model of T 1 .</p><p>Next, we prove the main claim with an inductive argument which requires defining subqueries of Q. For φ ∈ Φ and q ∈ K φ by Q q we denote the query ψ (Q 1 , . . . , Q k ), where Q 1 , . . . , Q k are children of φ in Q and ψ is the two-way regular expression corresponding to the automaton M φ,q = (K φ , I q , δ φ , {q}) (essentially, we make q the only final state). We claim that for any φ ∈ Φ, any q ∈ K φ , and any u ∈ N G we have</p><formula xml:id="formula_81">u ∈ [Q q ] G iff u ∈ q U 0 .</formula><p>In essence, the unary predicate q identifies all nodes at which the subquery Q q is satisfied. We prove the above claim with double induction: firstly over the height of the subquery</p><formula xml:id="formula_82">Q q = ψ (Q 1 , . . . , Q k ),</formula><p>and secondly, over the length of the witnessing path for</p><formula xml:id="formula_83">(v, u) ∈ [ψ ] G such that v ∈ i [Q i ] G . If we let I φ = {q 1 , . . . , q k }, then Q is equivalent to the union of Q q 1 ∪ . . . ∪ Q q k . Consequently, Q is satisfied at a node u ∈ N G iff u ∈ q i U 0 for some i ∈ {1, . . . , k }.</formula><p>As such, Q is not satisfied at any node of G if and only if U 0 |= q i ⊑ ⊥ for every i ∈ {1, . . . , k} i.e., U 0 |= T 0 . We finish the proof by observing that if the minimal model U 0 does not satisfy T 0 , then none of supersets of U 0 does. □</p></div>
<div><head>D PROOFS FOR CONTAINMENT</head><p>Lemma D.1. Given a schema S, a UC2RPQ P( x), and an acyclic UC2RPQ Q( x), one can compute in polynomial time a schema S • , a Boolean UC2RPQ P • , and a Boolean acyclic UC2RPQ Q</p><formula xml:id="formula_84">• such that P( x) ⊆ S Q( x) iff P • ⊆ S • Q • .</formula><p>Proof. Let x = (x 1 , x 2 , . . . , x n ) and let Γ S = {A 1 , . . . , A k }. We take a fresh node labels X 1 , . . . , X n Σ S and fresh edge labels r 1 , r 2 , . . . , r n Σ S . The schema S • is obtained from S as follows:</p><formula xml:id="formula_85">Γ S • = Γ S ∪ {A 0 }, Σ S • = Σ S ∪ {r 1 , . . . , r n }, δ S • (A, R, B) =          δ S (A, R, B) if A, B ∈ Γ S and R ∈ Σ ± S , ? if A = X i , R ∈ {r i , r - i }, and B ∈ Γ S ,<label>0</label></formula><p>otherwise. Now, the queries P • and Q • are obtained from P( x) and Q( x) by quantifying existentially x 1 , x 2 , . . . , x n and also adding atoms ∃y.(X i • r i )(y, x i ) for every i ∈ {1, . . . , n}. It is routine to check that P( x) ⊆ S Q( x) if and only if P • ⊆ S • Q • . There are two key facts. Firstly, 2RPQs in P and Q do not use labels r 1 , r 2 , . . . , r n (nor wildcards) and consequently cannot traverse edges with such labels.</p><p>Secondly, the schema S • ensures that the original regular expression can be witnessed only by paths that begin and end in nodes with labels in Σ S only. □ Corollary D.2. Given a schema S, two unary acyclic 2RPQs p(x) and q(x), one can compute in polynomial time a schema S • and Boolean 2RPQs p • and q • such that p(x)</p><formula xml:id="formula_86">⊆ S q(x) iff p • ⊆ S • p • .</formula><p>Proof. The construction of S • is as in Lemma D.1 and the construction of Boolean RPQs depends on the form of the unary RPQ:</p><formula xml:id="formula_87">1) if p(x 1 ) = ∃x 2 .φ(x 1 , x 2 ), then p • = r 1 • φ and 2) if p(x 1 ) = ∃x 2 .φ(y, x), then p • = φ • r - 1 ; q • is constructed in the same way. □ Lemma D.3. P ⊆ S Q iff P ⊆ T S Q.</formula><p>Proof. Each finite graph falsifying the left-hand side condition falsifies the right-hand side condition as well. For the converse, let G be a finite graph falsifying the right-hand side condition. Without loss of generality we can assume that only labels from Γ S ∪ Σ S are used in G. Let G ′ be obtained by dropping all nodes without a label, as well as edges incident with these nodes. Because all concept inclusions in T S that require a witnessing neighbour specify the label of this neighbour, they are not affected by this modification.</p><p>Other concept inclusions are always preserved when passing to a subgraph. It follows that G ′ conforms to S. The RPQs in P can only traverse nodes with a label from Γ S , so P is still satisfied in G ′ . Then, P is satisfied as well.</p><formula xml:id="formula_88">Q is not satisfied in G ′ , because G ′ is a subgraph of G. □ Lemma D.4. P is finitely satisfiable modulo T S ∪ T ¬Q iff P is sat- isfiable modulo T S ∪ T ¬Q * .</formula><p>Proof. Suppose that P is satisfied in a finite model G of T S ∪ T ¬Q . By Theorem 5.4, there is a (possibly infinite) model of T S ∪ T ¬Q * containing G as a subgraph. This model obviously satisfies P. Conversely, suppose that there is a possibly infinite graph G satisfying P and T S ∪ T ¬Q *</p><p>. Let p be the disjunct of P that is satisfied in G. Let H be the image of p in G, including a finite witnessing path for each RPQ. Note that H is finite. By Theorem 5.4, there is a finite model of T S ∪ T ¬Q containing H as a substructure. This models satisfies P as well. □ Lemma D.5. Every S-driven TBox T can be simplified in polynomial time so that it contains at most</p><formula xml:id="formula_89">|Σ ± S | • |Γ S | 2 at-most constraints.</formula><p>Proof. To achieve this, for each such CI of the form K ⊑ ∃ ≤1 R.K ′ in T we do one of the following.</p><formula xml:id="formula_90">• If T contains A ⊑ ∃ ≤1 R.A ′ for some A, A ′ ∈ Γ S such that A ∈ K and A ′ ∈ K ′ , then simply remove K ⊑ ∃ ≤1 R.K ′ from T . This is correct because A ⊑ ∃ ≤1 R.A ′ |= K ⊑ ∃ ≤1 R.K ′ . • Otherwise, because T is S-driven, it follows that the triple (K, R, K ′ ) is not satisfiable modulo T . That is, T |= K ⊑ R.K ′ . Since K ⊑ R.K ′ |= K ⊑ ∃ ≤1 R.K ′ , we can safely replace K ⊑ ∃ ≤1 R.K ′ with K ⊑ R.K ′ in T .</formula><p>The resulting TBox T ′ is equivalent to T and it only contains at-most constraints involving single concept names from Γ S . The number of those is clearly bounded by |Σ ± S | • |Γ S | 2 . □ Lemma D.6. Let T be an S-driven Horn-ALCIF TBox that was obtained from T S ∪ T ¬Q by reversing some finmod cycles. For every satisfiable finmod cycle</p><formula xml:id="formula_91">K 1 , R 1 , . . . , K n-1 , R n-1 , K n in T there exist unique A 1 , A 2 , . . . , A n ∈ Γ S such that A i ∈ K i for all i ≤ n, and A 1 , R 1 , . . . , A n-1 , R n-1 , A n is a finmod cycle in T Proof. Since all triples in K 1 , R 1 , . . . , K n-1 , R n-1 , K n are satisfiable, all CIs K i ⊑ ∃R i .K i+1 and K i+1 ⊑ ∃ ≤1 R -</formula><p>i .K i are relevant for T . We cannot simply apply the fact that T is S-driven, because these CIs need not belong to T : they are only entailed by T . The proof will proceed in several steps.</p><p>The first step is to see that each K i contains a label from Γ S . Towards contradiction, suppose it does not. We construct a graph witnessing that T does not entail K i ⊑ ∃R i .K i+1 , which is a contradiction. Let T i be the tree-shaped graph obtained by unravelling some model of T witnessing that (K i , R i , K i+1 ) is satisfiable, from a node u satisfying K i . Clearly, T i is also a model of T , its root u satisfies K i and has an R i -successor u ′ satisfying K i+1 . We construct G as the graph with a single node u 0 whose labels are copied from the root u of T i but with any letter from Γ S dropped. To see that G ̸ |= K i ⊑ ∃R i .K i+1 , note that as u ∈ (K i ) T i and K i contains no labels from Γ S , also u 0 ∈ (K i ) G ; but clearly u 0 has no R i -successors at all. Let us check that G |= T .</p><p>• New CIs of the form K ⊑ A are not introduced by reversing cycles, so it suffices to look at ones from T S ∪ T ¬Q . There, such CIs are only present in T ¬Q and always satisfy A Γ S (see the proof of Lemma C.2). Hence, as they were satisfied in T i and G was obtained by dropping labels from Γ S , they still hold in G. • CIs of the form K ⊑ ⊥ in T were satisfied in T i and they cannot be violated by dropping labels (recall that K does not use negation). • All CIs of the forms K ⊑ ∀R.K ′ , K ⊑ R.K ′ , and K ⊑ ∃ ≤1 R.K are trivially satisfied in G. • Consider a CI of the form K ⊑ ∃R.K ′ from T . Suppose that u 0 ∈ K G . Then also u ∈ K T i . This means that the CI was "fired" in T i , which implies that (K, R, K ′ ) is satisfiable modulo T and K ⊑ ∃R.K ′ is relevant for T . As T is S-driven, it follows in particular that K contains a label from Γ S . But this contradicts the fact that u 0 ∈ K G . Hence, K ⊑ ∃R.K ′ is trivially satisfied in G. Thus we have shown that G |= T . This concludes the first step. Now, as all K i contain a label from Γ S and all triples (K i , R i , K i+1 ) are satisfiable modulo T , it follows that for each i there exists exactly one label A i ∈ Γ S such that A i ∈ K i . It remains to show that A i ⊑ ∃R i .A i+1 and A i+1 ⊑ ∃ ≤1 R - i .A i . Let us begin with A i ⊑ ∃R i .A i+1 . Consider graph G obtained from T i (same as above) by removing all subtrees rooted at R isuccessors of the root that satisfy K i+1 . Clearly, G ̸ |= K i ⊑ ∃R i .K i+1 . As T |= K i ⊑ ∃R i .K i+1 , it follows that G ̸ |= T . Then, some CI of the form K ⊑ ∃R.K ′ from T is violated in G, because CIs of other forms are preserved when passing to a subgraph. In particular, it must be the case that the root of G satisfies K. But then also the root of T i satisfies K and since T i |= T , the root u of T i has an R-successor u ′ that satisfies K ′ . This means that K ⊑ ∃R.K ′ is relevant for T . Because T is S-driven, it must contain A ⊑ ∃R.A ′ for some A, A ′ ∈ Γ S such that A ∈ K, A ′ ∈ K ′ . As the root of G satisfies both K and K i , and we know that A ∈ K and A i ∈ K i and that labels from Γ S are exclusive, it follows that A = A i . We claim that also R = R i and A ′ = A i+1 . If R R i , then u ′ is not an R i -successor of the root in T i , and it has not been removed in G. That would imply that G actually does satisfy K ⊑ ∃R.K ′ . Since we know this is not the case, we conclude that R = R i . Similarly, suppose that A ′ A i+1 . Because u ′ satisfies K ′ and A ′ ∈ K ′ , it must have label A ′ . But then u ′ cannot have label A i+1 , which means it cannot satisfy K i+1 , and has not been removed in G. This yields a contradiction just like before and we can conclude that A ′ = A i+1 . Wrapping up, we have seen that A ⊑ ∃R.A ′ belongs to T and that A = A i , R = R i , and A ′ = A i+1 . This means that A i ⊑ ∃R i .A i+1 belongs to T .</p><p>Finally, let us see that A i+1 ⊑ ∃ ≤1 R - i .A i belongs to T . Consider the model T i but reorganize it so that the root u satisfies K i+1 and has an R - i -successor u ′ satisfying K i . Let G be the graph obtained from T i by duplicating the whole subtree rooted at u ′ , and adding an R - i -edge from u to the root u ′′ of the copy. Clearly</p><formula xml:id="formula_92">G ̸ |= K i+1 ⊑ ∃ ≤1 R - i .K i and since T |= K i+1 ⊑ ∃ ≤1 R - i .K i ,</formula><p>we conclude that G ̸ |= T . It follows immediately that G violates some CI of the form K ⊑ ∃ ≤1 R.K ′ from T , as CIs of other forms are not affected by the modification turning T i to G. Similarly, it must hold that R = R - i , and that u satisfies K and u ′ and u ′′ satisfy K ′ . It follows that</p><formula xml:id="formula_93">K ⊑ ∃ ≤1 R.K ′ is relevant, A i+1 ∈ K, A i ∈ K ′ , and A i+1 ⊑ ∃ ≤1 R - i .A i belongs to T . □ Lemma D.7.</formula><p>For T = T S ∪T ¬Q , the completion T * can be computed in EXPTIME.</p><p>Proof. Construct a graph G T over all possible intersections K of concept names used in T , including an edge with label R ∈ Σ</p><formula xml:id="formula_94">± from K to K ′ iff T |= K ⊑ ∃R.K ′ and T |= K ′ ⊑ ∃ ≤1 R -.K .</formula><p>G T has exponential size and can be constructed in EXPTIME, because CI entailment by Horn-ALCIF TBoxes can be tested in exponential time <ref type="bibr" target="#b25">[26]</ref>. Repeat the following until the graph stops changing. Pick an R-edge from K to K ′ such that there is no R -edge from K ′ to K. Check if there exists a path from</p><formula xml:id="formula_95">K ′ to K in G T .</formula><p>If so, the identified path combined with the R-edge from K to K ′ constitutes a finmod cycle</p><formula xml:id="formula_96">K 1 , R 1 , . . . , K n-1 , R n-1 , K n in T .</formula><p>Add to G T an R - i -edge from K i+1 to K i for all i &lt; n and extend T with the corresponding concept inclusions. Note that this includes an R --edge from K ′ to K and concept inclusions</p><formula xml:id="formula_97">K ′ ⊑ ∃R -.K and T |= K ⊑ ∃ ≤1 R.K ′ .</formula><p>Moreover, if there are unique A 1 , A 2 , . . . ,</p><formula xml:id="formula_98">A n ∈ Γ S such that A i ∈ K i for i ≤ n, check if A 1 , R 1 , . . . , A n-1 , R n-1 , A n is a cycle in G T .</formula><p>If so, add to G an R - i edge from A i+1 to A i , and the corresponding CIs to T . By Lemma D.6, this ensures that the extended T is S-driven. We can now reduce it and recompute G T based on the updated T . Using the complexity bounds for CI entailment given in Corollary E.7, we conclude that this can be done in EXPTIME. Note that we are indeed relying on the more precise complexity bounds here, because at later iterations of the cycle reversing procedure the TBox might well contain exponentially many concept inclusions. However, it has still only the original concept names and, after reducing, only a polynomial number of at-most restrictions. □</p></div>
<div><head>E PROOFS FOR SATISFIABILITY E.1 Introductory lemmas</head><p>We begin by showing the two lemmas mentioned in the body of the paper. Lemma E.1. For c ≥ 1, if a finite connected c-sparse graph has only nodes of degree at least 2, then it is (2c, 3c)-skeleton.</p><p>Proof. Let G be a finite connected c-sparse graph without nodes of degree 0 or 1. We claim that G consists of at most 2c nodes connected by at most 3c paths disjoint modulo endpoints. If G is empty, we are done. Otherwise, we eliminate vertices of degree 2 that are incident with two different edges by merging these edges into a single edge. This process results in a c-sparse multigraph G 0 , whose edges represent simple paths in G. This graph is either a single node with a loop or all its nodes have degree at least 3. In the first case it follows that G is a single cycle, and thus a (1, 1)-skeleton.</p><p>In the second case, assuming that G 0 has n nodes and m edges, we have 3n</p><formula xml:id="formula_99">/2 ≤ m ≤ n + c. It follows that c &gt; 0, n ≤ 2c, m ≤ 3c. □ Lemma E.2.</formula><p>If p is satisfied in a |p|-sparse graph G, then G contains a (4|p|, 5|p|)-skeleton H , extending the skeleton of G, such that all variables of p are mapped to distinguished nodes of H and G can be obtained by attaching finitely many finitely branching trees to H .</p><p>Proof. The skeleton H 0 of G is a (2|p|, 3|p|)-skeleton. Consider a match of p in G. Some variables of p might well be matched to nodes on the paths connecting the distinguished nodes of H 0 or in the attached trees. We define H as follows. First, we add to H as distinguished nodes all images of variables of p that lie on the paths connecting distinguished nodes of H 0 . Next, for each attached tree T that contains an image of a variable of p, we add to H as distinguished nodes all the images of variables of p that belong to T together with all their least common ancestors in T , as well as the node of H to which the root of T is connected. All ancestors (in T ) of these nodes are added to H as ordinary nodes. The skeleton H thus obtained has the required properties. □</p></div>
<div><head>E.2 The main result</head><p>The goal of this section is to prove the following theorem. Theorem E.3. Given a C2RPQ p and an ALCIF TBox T using k concept names and ℓ at-most constraints, one can decide in time O poly(|T |) • 2 poly(|p |,k, ℓ) if there exists a |p|-sparse graph that satisfies p and T .</p><p>The proof of Theorem E.3 is not very hard, but it combines several components and requires developing some machinery. Let us begin with a road map.</p><p>Relying on Lemma E.2, we guess a (4|p|, 5|p|)-skeleton H . The distinguished nodes of H are represented explicitly, together with all their labels, but each of the connecting paths is represented by a single symbolic edge. Note that there might be multiple symbolic edges between the same pair of distinguished nodes, representing different paths. We need to check that H can be completed to a graph G by materializing the symbolic edges into paths and attaching finitely many finitely branching trees in such a way that G is a model of T and there is a match of p in G that maps variables of p to distinguished nodes of H .</p><p>To achieve this, we guess an annotation of H that summarizes how the witnessing paths of p can traverse the parts of G missing from H , and which witnesses of distinguished nodes required by T these parts provide (Section E.3). We then check if these promises of the annotation are sufficient to guarantee that p and T are satisfied (Section E.4). Finally, we verify that the promises of the annotation can be fulfilled: we check if we can attach trees to the distinguished nodes and expand the symbolic edges into finite paths with attached trees in a way that matches the promises of the annotation and respects the TBox T (Section E.5).</p></div>
<div><head>E.3 Annotated skeleta</head><p>Let Γ p , Σ p , Γ T , Σ T be the sets of edge and node labels used in p and T , respectively. In what follows we only consider graphs and skeleta using only node labels from Γ p ∪ Γ T and edge labels from Σ p ∪ Σ T .</p><p>Let Φ be the set of two-way regular expressions used in p. For each φ ∈ Φ we fix an equivalent linear size non-deterministic automaton A φ over the alphabet Γ p ∪ Σ ± p with states K φ , initial states I φ ⊆ K φ , and final states F φ ⊆ K φ . We assume that all K φ are pairwise disjoint and let δ = φ ∈Φ δ φ .</p><p>An annotation of skeleton H is given by the following functions.</p><p>• β src and β tgt record information about the source and target of the paths represented by each symbolic edge: they both map each symbolic edge e to Σ p ∪ Σ T ± × 2 Γ p ∪Γ T .</p><p>• δ node records how the witnessing paths for p may loop in the subtrees attached to the distinguished nodes. Thus, δ node maps every distinguished node to a subset of φ ∈Φ K φ × K φ . • δ edge records how the witnessing paths for p progress along paths (and the trees attached to them) represented by the symbolic edges in the skeleton. Thus, δ edge maps every edge e to a subset of </p></div>
<div><head>↷</head><p>) ∈ δ edge (e) indicates a loop: some path enters e from v in state s, and exits at the same node v in state s ′ , etc.</p></div>
<div><head>E.4 Verifying annotated skeleta</head><p>An annotation of H is sufficient for TBox T if the witnesses recorded by β src and β tgt respect T ; that is, for each distinguished node u of H the graph G u defined below satisfies the TBox T 0 obtained from T by dropping all concept inclusions of the form A ⊑ ∃R.B. To construct G u we begin from u with labels inherited from H , and then for each symbolic edge e incident with u we add an R-successor v e of u with label set Λ, where (R, Λ) = β src (e) if u is the source of e and (R, Λ) = β tgt (e) if u is the target of e.</p><p>An annotation is sufficient for C2RPQ p if there exists a function η mapping variables of p to distinguished nodes of H such that for each atom φ(x, y) of p, there exists a finite witnessing sequence s 0 u 0 s 1 u 1 . . . s k u k of states and distinguished nodes of H satisfying the following conditions.</p><p>• The witnessing sequence begins and ends correctly; that is,</p><formula xml:id="formula_100">s 0 ∈ I φ , s k ∈ F φ , u 0 = η(x), u k = η(y).</formula><p>• Each transition step along a symbolic edge (or subtree attached to a distinguished node) updates the state as expected: for each i &lt; k one of the following holds:</p><p>-(s i , s i+1 , →) ∈ δ edge (e) for some edge e from u i to u i+1 ; -(s i , s i+1 , ←) ∈ δ edge (e) for some edge e from u i+1 to u i ; -(s i , s i+1 ,</p></div>
<div><head>↷</head><p>) ∈ δ edge (e) for some edge e from u i to some u, and</p><formula xml:id="formula_101">u i = u i+1 ; -(s i , s i+1 ,</formula></div>
<div><head>↷</head><p>) ∈ δ edge (e) for some edge e from some u to u i , and</p><formula xml:id="formula_102">u i = u i+1 ; -(s i , s i+1 ) ∈ δ node (u i ) and u i = u i+1 .</formula><p>We point out that the witnessing sequence may traverse a symbolic edge multiple times. In consequence, each tuple in δ edge (e) must be "realised" by the single path represented by e (and the attached trees).</p><p>Proposition E.4. One can decide if a given annotated skeleton is sufficient for p and T in PTIME.</p><p>Proof. To check that the annotated skeleton is sufficient for T it is enough to examine the graphs G u for each distinguished node u of the skeleton.</p><p>Checking that the annotated skeleton is sufficient for p amounts to guessing the function η and for each atom φ(x, y) running a reachability test in the product graph whose nodes combine distinguished nodes of the skeleton with states from K φ , where edges are defined according to the symbolic edges in the skeleton and the triples from δ edge . In the reachability test we check if there exists a path beginning in {η(x)} × I φ and ending in {η(y)} × F φ . □</p></div>
<div><head>E.5 Implementing annotated skeleta</head><p>Consider an annotated skeleton H = H, β src , β tgt , δ edge , δ node . We say that a graph G implements H if G is obtained from H by replacing each symbolic edge e with a path π e connecting the endpoints of e and by attaching finitely many finitely branching trees in a way consistent with the annotations, in the following sense.</p><p>• For each symbolic edge e from u to u ′ , the subgraph G e of G that consists of π e and all trees attached to the internal nodes of π e is correctly summarized in the annotations:</p><p>for each (s, s ′ , d) ∈ δ edge (e) with s, s ′ ∈ K φ there is a path in G e with endpoints (u, u)</p><formula xml:id="formula_103">if d = ↷ , (u, u ′ ) if d = → , (u ′ , u ′ ) if d = ↷</formula><p>, and (u ′ , u) if d = ← , on which A φ moves from state s to state s ′ ; if β src (e) = (R 1 , Λ 1 ) and β src (e) = (R 2 , Λ 2 ), then the first edge of π e is an R-edge, the last edge of π e is an R - 2 -edge, the second node on π e has the labels set Λ 1 , and the penultimate node on π e has label set Λ 2 .</p><p>• For each distinguished node u, the trees attached to u are summarized correctly in the annotations: for each (s, s ′ ) ∈ δ node (u) with s, s ′ ∈ K φ there is a tree T s,s ′ u attached to u and a path that starts and ends in u and otherwise only visits nodes of T s,s ′ u , on which A φ moves from state s to state s ′ . • G is a model of T .</p><p>Note that all the missing pieces of the graph are essentially trees (finitely branching, but typically infinite). Indeed, each T s,s ′ u simply is a tree, but also G e can be viewed as a tree: its root is the source of e, the root has exactly one child, the path π e constitutes a special finite branch ending in the target of e which is a leaf in this tree. Importantly, each (s, s ′ ) ∈ δ node (u) is witnessed by a finite subgraph of T s,s ′ u , and each triple (s, s ′ , d) ∈ δ edge (e) is witnessed by a finite subgraph of G e . The algorithm to check if there exist such T s,s ′ u and G e can be seen as an emptiness test for tree automaton, or as a variant of type elimination.</p><p>We first define types, which can also be viewed as states of a tree automaton. We assign to each node of the tree a type that records the following information:</p><p>• a subset of Γ p ∪ Γ T , representing the labels of the current node; • an element of Σ ± p ∪ Σ ± T and a subset of Γ p ∪ Γ T , representing the label on the edge to the parent and the parent's label set;</p><p>• with ℓ the number of at-most restrictions in T , a list of t ≤ ℓ + 1 elements of Σ ± p ∪ Σ ± T and subsets of Γ p ∪ Γ T , representing labels on the edges to t children of the current node and the children's label sets; • a Boolean flag indicating whether the current node belongs to the special path (not used for T s,s ′ u at all);</p><p>• a subset of φ ∈Φ K φ ×K φ ×{ ↷ , ↷,↓,↑} recording the progress on witnessing δ edge or δ node :</p><p>-(s, s ′ , ↷ ) indicates that from state s in the current node we can navigate the current subtree and return to the current node in state s ′ , -(s, s ′ , ↷) indicates that from state s in the current node we can navigate outside of the current subtree and return to the current node in state s ′ , -(s, s ′ , ↓) indicates that from state s in the current node, we can reach the target node of e in state s ′ , -(s, s ′ , ↑) indicates that from state s in target node of e we can reach the current node in state s ′ . Actually, all four kinds of triples are required along the special path, but in the remaining nodes we only need the triples of the form (s, s ′ , ↷ ).</p><p>By a pre-type we shall understand a type with the boolean flag and the progress information dropped; that is, a tuple (Λ, R ′ , Λ ′ , R 1 , Λ 1 , . . . , R t , Λ t )</p><p>with Λ, Λ ′ , Λ 1 , . . . , Λ t ⊆ Γ p ∪ Γ T , and R ′ , R 1 , . . . , R t ∈ Σ ± p ∪ Σ ± T , and 0 ≤ t ≤ ℓ + 1. In what follows we blur the distinction between conjunctions K of concept names and sets Λ of labels, as usual, and write K ⊆ Λ.</p><p>A pre-type (Λ, R ′ , Λ ′ , R 1 , Λ 1 , . . . , R t , Λ t ) is compatible with T iff there exists a graph G such that</p><p>• there are pairwise different nodes u, u ′ , u 1 , . . . , u t with label sets Λ, Λ ′ , Λ 1 , . . . , Λ t ;</p><p>And analogously, a macro that asserts heads position only Head i = Config +q pos i • q .</p><p>The negative query. We define a number of queries that detect violations of good structure of a run; their union will be used as the negative query. First, we identify configurations that has two different symbols at a position of the tape.</p><p>q TwoSymbols = Config +i +a b Symbol i,a • Symbol i,b .</p><p>Similarly, we identify configurations with two different heads.</p><p>q TwoHeads = Config +i j∨p q State i,q • State j,p .</p><p>Next, we identify configurations with outgoing transition edges that do not fit their state.</p><formula xml:id="formula_104">q BadTransitionEdges = Config          +q∈K ∀ State q [∃ 1 + ∃ 2 ] + +q∈K ∃ State q [∀ 1 + ∀ 2 ] + State q yes [∀ 1 + ∀ 2 + ∃ 1 + ∃ 2 ] + State q no [∀ 1 + ∀ 2 + ∃ 1 + ∃ 2 ]         </formula><p>.</p><p>Additionally, identify configurations with existential states that have both existential outgoing edges (the definition of a run requires precisely one).</p><formula xml:id="formula_105">q TwoExistentialEdges = +q∈K ∃ State q [∃ 1 ][∃ 2 ] .</formula><p>The initial configuration, which is the only configuration with state q 0 , should be the root of the run and as such it should not have any incoming transition edges.</p><formula xml:id="formula_106">q BadTreeRoot = State q 0 [∃ - 1 + ∃ - 2 + ∀ - 1 + ∀ - 2 ]</formula><p>. To make sure that the run is a tree, no configuration should have two incoming transitions (note that the schema forbids more than one incoming edge with the same label).</p><formula xml:id="formula_107">q BadTreeNode = Config [∃ - 1 ][∃ - 2 ] + [∃ - 1 ][∀ - 1 ] + [∃ - 1 ][∀ - 2 ] + [∃ - 2 ][∀ - 1 ] + [∃ - 2 ][∀ - 2 ] + [∀ - 1 ][∀ - 2 ]</formula><p>.</p><p>Similar requirements apply to tape: we do not allow tape positions that are used by two different configurations.</p><p>q BadTape = +i j Pos[pos - i ][pos - j ] + +p q St[p -][q -] + +a b Symb[a -][b -] .</p><p>Finally, we construct the union of the above queries. q M = q TwoSymbols + q TwoHeads + q BadTransitionEdges + q TwoExistentialEdges + q BadTreeRoot + q BadTreeNode + q BadTape .</p><p>The positive query. We first construct a query that ensures that a configuration is valid and then we design a path query that traverses the tree and ensures that each of its configurations is valid. A valid configuration satisfies the following queries. It has a head at some position.</p><p>p Head = Config [ +i Head i ] .</p><p>Every position has a symbol.</p><p>p Tape = Config +a Symbol 1,a . . . +a Symbol m,a .</p><p>The configuration has the required outgoing transitions and only final states are accepted in leaves.</p><formula xml:id="formula_108">p Transition = Config        +q∈K ∀ State q [∀ 1 ][∀ 2 ] + +q∈K ∃ State q [∃ 1 + ∃ 2 ] + State q yes + State q no       </formula><p>.</p><p>The positive query ensuring that transitions are executed properly is more difficult to define and we decompose it into several macros. First, we define a macro Move i,q,a that verifies that that a configuration in state q at position i with symbol a ∈ Σ has the right children configurations. We define this macro depending on the type of state:</p><p>(1) For q ∈ {q yes , q no } no children are necessary (the negative query q BadTransitionsEdges forbids any)</p><p>Move i,q,a = State q • Symbol i,a .</p><p>(2) For q ∈ K ∃ we check that one of the transitions is implemented (the negative query q TwoExistentialEdges forbids more than one). We let δ 1 (q, a) = (q 1 , b 1 , d 1 ) and δ 2 (q, a) = (q 2 , b 2 , d 2 ).</p><formula xml:id="formula_109">Move i,q,a = [State i,q • Symbol i,a • ∃ 1 • State i+d 1 ,q 1 • Symbol i,b 1 ] + [State i,q • Symbol i,a • ∃ 2 • State i+d 2 ,q 2 • Symbol i,b 2 ] .</formula><p>(3) For q ∈ K ∀ both transitions must be implemented. Again we let δ 1 (q, a) = (q 1 , b 1 , d 1 ) and δ 2 (q, a) = (q 2 , b 2 , d 2 ).</p><formula xml:id="formula_110">Move i,q,a = [State i,q • Symbol i,a • ∀ 1 • State i+d 1 ,q 1 • Symbol i,b 1 ] • [State i,q • Symbol i,a • ∀ 2 • State i+d 2 ,q 2 • Symbol i,b 2 ] .</formula><p>Now, a transition is executed correctly if the following positive query holds at a configuration node.</p><p>p Execution = Config +i,q,a Move i,q,a .</p><p>To handle the tape we need to make sure that 1) the tape of the initial configuration contains precisely the input word and 2) that symbols at the positions without head are copied correctly. For the first, we define the following macro. The next macro verifies that the symbol at a position i of the tape is a correct copy of its preceding configuration.</p><p>PosCopy i = +a Symbol i,a (∃ 1 + ∃ 2 + ∀ 1 + ∀ 2 ) -Symbol i,a .</p><p>Naturally, when the head in the preceding configuration is at position i, then we must only verify that symbols at positions other than i are copied.</p><formula xml:id="formula_111">TapeCopy = +i [(∃ 1 + ∃ 2 + ∀ 1 + ∀ 2 ) -Head i ] • PosCopy 1 • . . . • PosCopy i-1 • PosCopy i+1 • . . . • PosCopy m .</formula><p>Finally, the query that verifies the correctness of the tape follows.</p><p>p TapeCopy = Config State </p></div><figure xml:id="fig_1"><head>Example 4 . 3 .</head><label>43</label><figDesc>A couple of examples of above queries for the transformation T 0 in Example 4.1 follow.</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Query containment over finite and infinite graphs.</figDesc></figure>
<figure xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Cycle reversal argument.</figDesc></figure>
<figure xml:id="fig_4"><head>Theorem 5 . 4 (Example 5 . 5 .</head><label>5455</label><figDesc><ref type="bibr" target="#b37">Ibáñez-García et al., 2014)</ref>. A Horn-ALCIF TBox T has a finite model containing a finite subgraph H iff its completion T * has a possibly infinite model containing H . Schema S from Example 5.2 is equivalent to TBox T S that consists of</figDesc></figure>
<figure xml:id="fig_5"><head>Theorem 6 . 1 .</head><label>61</label><figDesc>Unrestricted satisfiability of a C2RPQ p modulo an ALCIF TBox T using k concept names and ℓ at-most constraints can be decided in time O poly(|T |) • 2 poly(|p |,k, ℓ) .</figDesc></figure>
<figure xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Simple witness for satisfiability.</figDesc></figure>
<figure xml:id="fig_7"><head>Proposition B. 1 .</head><label>1</label><figDesc>For any schema S and for any graph G, G conforms to S if and only if G |= T S , G |= ⊤ ⊑ Γ S , and G |= A⊓B ⊑ ⊥ for any A, B ∈ Γ S . Proof. Straightforward since the ALCIF formulas are translations of the conditions of conformance of a graph to a schema. □ We use the above result to reduce type checking to testing entailment of simple ALCIF statements. Recall that for a schema S and a transformation T we define the entailment relation (T , S) |= K ⊑ K ′ as T (G) |= K ⊑ K ′ for every G ∈ L(S). Lemma B.2. Given two schemas S and S ′ and a transformation T , {T (G) | G ∈ L(S)} ⊆ L(S ′ ) if and only if (T , S) |= ⊤ ⊑ Γ T and (T , S) |= T S ′ . Proof. Immediate consequence of Proposition B.1 and the fact that transformations must use a single dedicated node constructor for each node label. This ensures that (T , S) |= A ⊓ B ⊑ ⊥ holds for any A, B ∈ Γ S ′ . □</figDesc></figure>
<figure xml:id="fig_8"><head>Lemma B. 5 .</head><label>5</label><figDesc>Take a schema S and a transformationT that is trimmed modulo S and such that (T , S) |= ⊤ ⊑ Γ T . Let T be the set of all L 0 statements over Γ T and Σ T that are satisfied by every graph in the family {T (G) | G ∈ L(S)}. Then, T corresponds to the containment minimal schema over Γ T and Σ S that contains {T (G) | G ∈ L(S)}.</figDesc></figure>
<figure xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Automata for regular expressions of Q.</figDesc></figure>
<figure xml:id="fig_10"><head /><label /><figDesc>InitTape = Symbol 1,w 1 •. . . Symbol n,w n •Symbol n+1,□ •. . .•Symbol m,□ .</figDesc></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>have the form of concept inclusions, C ⊑ D where C and D are concepts. A graph G satisfies C ⊑ D, in symbols G |= C ⊑ D, if C G ⊆ D G . A set T of concept inclusions is traditionally called a TBox and we extend satisfaction to TBoxes in the canonical fashion:</figDesc><table /></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>φ ∈Φ K φ ×K φ × {↷ ,</figDesc><table /><note><p><p>↷</p>, ←, →}. If e is an edge from u to v, then (s, s ′ , →) ∈ δ edge (e) indicates that some path enters (the part of the model summarized by) the edge e from u in state s, and exits at node v in state s ′ . Similarly, (s, s ′ ,</p></note></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>1,q 0 • InitTape + TapeCopy . Now, we take the conjunction of the queries that verify local correctness of a configuration. p Config = p Head • p Tape • p Transition • p Execution • p TapeCopy . Additionally, we define a configuration that is a leaf (accepting) p Accept = p Config • State q yes . And, the initial configuration p Start = p Config • State q 0 .</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This work was supported by <rs type="funder">Poland's National Science Centre</rs> grant <rs type="grantNumber">2018/30/E/ST6/00042</rs>. We would like to thank <rs type="person">Sebastian Maneth</rs>, <rs type="person">Mikaël Monet</rs>, <rs type="person">Bruno Guillon</rs>, and <rs type="person">Yazmin Ibáñez-García</rs> for their comments and discussions. For the purposes of open access, the authors have applied a CC BY public copyright licence to any Author Accepted Manuscript version arising from this submission.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_KAgtKK7">
					<idno type="grant-number">2018/30/E/ST6/00042</idno>
				</org>
			</listOrg>
			<div type="annex">
<div><p>• there is an R ′ -edge from u to u ′ and an R i -edge from u to u i for all i ≤ t, and no other edges are incident with u ′ ; • for each K ⊑ ∃ ≤1 R.K ′ in T with K ⊆ Λ, every R-successor of u that satisfies K ′ belongs to {u ′ , u 1 , . . . , u t }; and • G satisfies T except that CIs of the form K ⊑ ∃R.K ′ are not required to be satisfied for u ′ . Note that unlike in the notion of satisfiability used in Appendix D, the witnessing nodes cannot have additional labels, not listed in Λ, Λ ′ , Λ 1 , . . . , Λ t .</p><p>Lemma E.5. Given T and p one can compute the set of pre-types compatible with T within the time bound stated in Theorem E. <ref type="bibr" target="#b2">3</ref> Proof. Each pre-type (Λ, R ′ , Λ ′ , R 1 , Λ 1 , . . . , R t , Λ t ) can be interpreted as a star-shaped graph consisting of nodes u, u ′ , u 1 , . . . , u n with label sets Λ, Λ ′ , Λ 1 , . . . , Λ t such that u ′ is an R ′ -successor of u, u i is an R i -successor of u for all i ≤ t, and there are no other edges. Thus we can speak of a pre-type satisfying a concept inclusion, etc.</p><p>We say a pre-type (Λ, R ′ , Λ ′ , R 1 , Λ 1 , . . . , R t , Λ t ) is repeatable if there is no at-most restriction K ⊑ ∃ ≤1 R.K ′ in T such that K ⊆ Λ ′ , R = (R ′ ) -, and K ′ ⊆ Λ.</p><p>A pre-type (Λ, R ′ , Λ ′ , R 1 , Λ 1 , . . . , R t , Λ t ) is said to be compatible with T modulo a set Θ of pre-types if</p><p>• Θ contains a pre-type (Λ i , R - i , Λ, . . . ) for each i ≤ t; • the pre-type satisfies all CIs in T not of the form K ⊑ ∃R.K ′ ; • for each concept inclusion K ⊑ ∃R.K ′ in T with K ⊆ Λ, at least one of the following holds:</p><p>-R = R ′ and K ′ ⊆ Λ ′ , or -R = R i and K ′ ⊆ Λ i for some 1 ≤ i ≤ t, or -R = R 0 and K ′ ⊆ Λ 0 for some repeatable (Λ 0 , R - 0 , Λ, . . . ) from Θ. Now, to compute the set of pre-types compatible with T , we start with the set Θ = Θ 0 of all pre-types, and exhaustively remove those pre-types that are not compatible with T modulo Θ. This algorithm terminates after at most</p><p>iterations. Each iteration takes time polynomial in |Θ| and |T |.</p><p>The result is the maximum set Θ of pre-types such that each pre-type from Θ is compatible with T modulo Θ. Each pre-type compatible with T will belong to this set, because the graph witnessing the triple can be used to argue that the triple will not be removed at any iteration. Conversely, each triple from Θ is compatible with T , because one can construct a witnessing tree-shaped graph top-down, using the witnesses justifying the presence of pre-types in Θ in the last iteration of the algorithm. □ Lemma E.6. The existence of a graph implementing a given annotated skeleton is decidable within the time bound from Theorem E.3.</p><p>Proof. We call a type</p><p>is compatible with T . Repeatable types are defined analogously, based on the underlying pre-types. Clearly, Lemma E.5 suffices to precompute the set of types compatible with T . Our task is to check if from these types one can construct the witnessing G e and T s,s ′ u . We will build them bottom-up, guaranteeing that each promise related to p is fulfilled in a finite fragment.</p><p>and (s 2 , R - 0 , s ′ ) ∈ δ for some s 1 , s 2 and repeatable (Λ 0 , R - 0 , Λ, . . . , 0, ∆ 0 ) ∈ Θ, where ∆ * i is the set of all s, s ′ , ↷ such that there are states s = s 1 , s 2 , . . . , s m = s ′ with s j , s j+1 , ↷ ∈ ∆ i for all j &lt; m;</p><p>• if b = 1, then for each (s, s ′ , ↷) ∈ ∆ 1 , there are s 1 , . . . , s m such that (s, R - 1 , s 1 ), (s m , R 1 , s ′ ) ∈ δ and for all j &lt; m, ei-</p><p>Let us first see how to decide the existence of G e for a given symbolic edge e. The algorithm begins with the set Θ of all "initial types", which are</p><p>-∆ consists of all (s, s ′ , ↷) such that (s, s ′ , ↷</p><p>) ∈ δ edge (e), as well as all (s, s, ↑) and (s, s, ↓); • types (Λ, R ′ , Λ ′ , . . . , b, ∆) compatible with T such that b = 0, -∆ = ∅.</p><p>Then, we exhaustively extend Θ with types that are compatible with T and compatible with p modulo Θ. When no more types can be added, the graph G e exists iff Θ contains a type (Λ, R ′ , Λ ′ , . . . , b, ∆) such that • Λ is the label set of the source of the symbolic edge e;</p><p>• ∆ contains no triples of the form (s, s ′ , ↷);</p><p>• for each (s, s ′ , ↷ ) ∈ δ edge (e) there are states</p><p>• for each (s, s ′ , ↑) ∈ δ edge (e) there are states s 1 , s 2 such that</p><p>This number of iterations of the algorithm is bounded by the number of all types,</p><p>Each iteration takes time polynomial in |Θ| ℓ and |T |. The promised complexity bounds follow.</p><p>Deciding the existence of the witnessing trees for a node u of the annotated skeleton is very similar. We can reuse the set Θ computed for any symbolic edge e. The only delicate issue is that we need to account for β src (e ′ ) for all edges e ′ outgoing from u and β tgt (e ′′ ) for all edges e ′′ incoming to u. Essentially, we check if there exists a type (Λ, R 1 , Λ 1 , . . . , R t , b, ∆) -note the missing R ′ and Λ ′ -with b = 0 and t ≤ ℓ + deg(u), compatible with T and compatible with p modulo Θ, except that for i = 1, 2, . . . , deg(u), the components R i , Λ i must be as specified by β src (e ′ ) and β tgt (e ′′ ) for outgoing e ′ and incoming e ′′ , and their corresponding types must be (Λ i , R - i , Λ, 0, ∅), not required to belong to Θ. This can be done in time polynomial in |Θ| ℓ , T , and H . □ Corollary E.7. Unrestricted entailment of concept inclusions by an ALCIF TBox T using k concept names and ℓ at-most constraints can be decided in time</p><p>Proof. The result holds in full generality, but we only sketch the arguments for the two kinds of concept inclusions we need to compute the completion. For existential constraints, note that</p><p>where B and B ′ are fresh concept names. For at-most constraints,</p><p>where B and B ′ are fresh concept names. □</p></div>
<div><head>F PROOF OF HARDNESS</head><p>Theorem F.1. Testing containment of Boolean 2RPQs modulo schema is EXPTIME-hard.</p><p>We present a reduction of the acceptance problem of an alternating Turing machine with a polynomial bound on space. We begin by defining a special variant of alternating Turing machines. We also present a number of conceptual tools used in the reduction. Alternating Turing machines. We consider a variant of alternating Turing machine with the following particularities:</p><p>• there is a single distinguished initial state that the machine never reenters; • there are two special states q yes and q no that are final (no transition allowed to follow) 1 ;</p><p>• the transition table has exactly two transitions for any nonfinal state and any symbol; 1 The state q no is not necessary for the purposes of our reduction but we include it for the sake of completeness of this variant of ATM</p><p>• there exists 3 special symbols: □ for empty tape space, ▷ for left tape boundary, and ◁ for right tape boundary; we only assume that the input word does not use those symbols and the transition table handles the boundary symbols appropriately. It's relatively easy to see that any alternating Turing machine with polynomially bounded space can converted to the variant above.</p><p>Formally, an alternating Turing machine (ATM) is a tuple M = (A, K, q 0 , δ 1 , δ 2 ), where A is a finite alphabet, K is a finite set of states with two distinguished final states q yes and q no and partitioned into three pair-wise disjoint subsets K = K ∀ ∪ K ∃ ∪ {q yes , q no }, q 0 ∈ K is a distinguished initial state, and δ i : (K \ {q yes , q no }) × A → (K \ {q 0 }) × A × {-1, +1} are two transition tables such that δ i (q, x) = (q ′ , y, d) satisfies the following two conditions:</p><p>We consider ATMs with polynomially bounded space, a class of Turing machines that defines the class ASPACE known to coincide with EXPTIME. Recall that a binary tree is a finite prefix-closed subset T ⊆ {1, 2} * and a labeled-tree is a function λ that assigns a label to every element (node) of a tree.</p><p>Given an ATM M and a polynomial poly(n), a run of M w.r.t. poly on an input w ∈ (Σ \ {▷, ◁, □}) * is a binary tree λ whose nodes are labeled with configurations of M such that:</p><p>(1) the root node is labeled with</p><p>) is obtained by applying the transition δ i (q, x) to the configuration λ(n). Also, if q ∈ K ∀ , then n has both children n • 1 and n • 2 and if q ∈ K ∃ , then n has precisely one child, (3) for every leaf node n ∈ dom(λ) the configuration λ(n) uses a final state q yes or q no . A run is accepting if and only if all its leaves use the state q yes . The ATM M (with space bound poly) accepts a word w, in symbols M(w) = yes if and only if there is an accepting run of M w.r.t. poly on w. Reduction outline. We present a reduction of the problem of word acceptance by an ATM with polynomial bound on space to the complement of the problem of containment of Boolean 2RPQs in the presence of schema. We point out that the class of ASPACEcomplete problems is closed under complement, and consequently, this reduction proves that the query containment problem is EXP-TIME-hard.</p><p>More precisely, for an ATM M, whose space is bounded by poly(n), and an input word w we construct a schema S and two Boolean 2RPQs p and q such that M(w) = yes iff p ⊈ S q iff ∃G ∈ L(S). G |= p ∧ G ̸ |= q .</p><p>In the sequel, we refer to p as the positive query and to q as the negative query. Naturally, we present a reduction that is polynomial i.e., the combined size of p, q, and S is bounded by polynomial in the size of M and w.</p><p>The reduction constructs a schema S and queries p and q for which the counter-example of p ⊆ S q represents an accepting run of M on w. Before we present the reduction in detail, we introduce 3 conceptual devices that we use in the reduction: nesting queries, encoding disjunction, and enforcing tree structure. Nesting queries. The reduction employs a relatively large and complex queries and throughout the reduction we employ nesting of regular path queries that is expanded as follows:</p><p>with the inverse operator being extended to regular path queries in the standard fashion.</p><p>-= ,</p><p>We point out that, in general, this definition is not equivalent to the standard meaning of nesting of regular expressions but in our reduction nested queries are evaluated at nodes for which the schema ensures the intended meaning. Encoding disjunction. The first conceptual device allows us to express disjunction in schemas, which we illustrate on the following example. Take two node labels A and B and suppose we wish to require A-nodes to have either one outgoing a-edge or one outgoing b-edge to a node with label B. The schema formalism allows us to make the following restriction.</p><p>A → a : B ? , b : B ? .</p><p>Alone, it is insufficient as it allows nodes that do not fulfill the disjunctive requirement: a A-node that has no outgoing edge or has both outgoing edges. We remove those cases with the help of a positive and a negative query. Namely, we define</p><p>and we observe that in a graph that conforms to the above schema any node with label A that satisfies p and does not satisfy q has precisely one outgoing edge. Enforcing tree structure. In our reduction we aim at constructing a tree-shaped counter examples and we use the positive query to diligently enforce disjunction in every node. In essence, the positive query will traverse the counter-example and impose satisfaction of a relevant query in every node. We present this device on an example where we define rooted binary trees. The general shape of the tree follows the schema in Figure <ref type="figure">6</ref>.  Naturally, the schema alone is insufficient to capture the right structure of the tree. Consequently, additional requirements are imposed with the help of the following negative Boolean query</p></div>
<div><head>Node</head><p>that ensures that an inner node does not have two outgoing edges with the same label and that no node has two incoming edges. We point out that when q is not satisfied at a node, schema ensures that it has at most one incoming edge. To enforce the correct tree structure we define the following unary query</p><p>The key observation here is that a - 1 is always followed by a 2 and the query can move up the tree only after a leaf has been reached. This ensures a proper traversal of the structure, with every node satisfying the pattern Node[a 1 ][a 2 ]. Consequently, for any connected graph G that conforms to the above schema, satisfies p, and does not satisfy q, G is a binary tree. The input of the reduction. We fix an ATM M = (A, K, q 0 , δ 1 , δ 2 ) whose space is bounded by poly(n) and we fix an input word w ∈ (A \ {▷, ◁, □}) * . We let n = |w |, m = poly(|w |), and assume that A = {a 1 , . . . , a k } and that K = {q 0 , q 1 , . . . , q ℓ }. Throughout the description of the reduction, unless we say otherwise, we use a, b to range over symbols in A, we use q, p to range over states in K, and we use i, j to range over tape positions {1, . . . , m}. The schema. We construct a schema S whose signature is</p><p>In essence, Config-nodes represent configurations and Pos-nodes represent tape cells. The edges labeled with {∀ 1 , ∀ 2 , ∃ 1 , ∃ 2 } are transition edges that connect configurations. The schema S is presented in Figure <ref type="figure">7</ref>. We introduce macros that illustrate the intended S:</p><p>. . . meaning of the remaining edge labels. The first macro checks that the symbol at position i on the tape is a.</p><p>Symbol i,a = Config pos i • a .</p><p>The next one checks that the configuration is a given state q with the head at a given position i.</p><p>Finally, we also introduce a macro that asserts the state of a configuration without any constraint on the position of the head.</p><p>State q = Config +i pos i • q .</p><p>Finally, we define the positive query, based on the ideas of enforcing tree structure in p Tree . It traverses the counter-example and ensures that it contains only good configurations.</p><p>Before stating the main proof we present in Figure <ref type="figure">8</ref> a conceptual automaton that corresponds to the above Boolean 2RPQ. In the proof below, we refer to p i, j as the query defined with the above automaton whose initial state is q i and final state is q j . The main claim follows.</p><p>Claim. p M,w ⊈ S q M if and only if M(w) = yes.</p><p>Proof. For the if direction, we take the accepting run λ and construct the corresponding graph G as follows. The nodes and their labels are as follows.</p><p>The edges of G are:</p><p>(1) (c n , pos i , t n,i ) for every n ∈ dom(λ) and i ∈ {1, . . . , M }, (2) (t n,i , q, s n ) for every n ∈ dom(λ) where q is the state of configuration λ(n); (3) (t n,i , a, e i,n ) for every n ∈ dom(λ) and i ∈ {1, . . . , M } where a is the symbol at position i of the tape of configuration λ(n);</p><p>for every n ∈ dom(λ) such that the configuration λ(n) is at state q ∈ K ∃ and n has a child n • j in λ for some j ∈ {1, 2}. It is easy to show that G satisfies the schema S, does not satisfy q, all Config-nodes satisfy p Config , the root node satisfies p Start and every leaf node satisfies p Accept .</p><p>With a simple induction, on the height of a node n ∈ dom(λ), we prove that for any n ∈ dom(λ) the node c n satisfies the query p 1,2 . This shows that the root node c ε satisfies the query p 0,3 = p.</p><p>For the only if direction, we take any G that satisfies S, satisfies p, and does not satisfy q. W.l.o.g. we can assume that G is connected; otherwise we take any connected component that satisfies p. We show that G is a tree encoding an accepting run of M on w. Note that q is a Boolean RPQ, and thus a single two-way regular expression. Thus, in the sequel we analyze its witnessing paths in G but p should not be confused with a binary query; a Boolean RPQ ask the existence of a witnessing path without the need to report its endings.</p><p>Take any pair of nodes u 0 and v 0 such that there is a path from u 0 to v 0 that witnesses q (which is a regular expression). Since G does not have a node with two incoming edges (q BadTreeNode and q BadTape are not satisfied at any node), u 0 and v 0 are the same node. Consequently there is a path from u 0 to u 0 that witnesses p 1,2 and we show with an induction on the length of the path from u 0 to any reachable Config-node v that there is a path form v to v that witnesses p 1,2 , and consequently, v satisfies p Config . This implies that G has the form of a tree, all of its Config-nodes satisfy p Config and all its leaves satisfy p Accept . Moreover, we can construct an accepting run λ from G that shows that M(w) = yes. □</p><p>Finally, we observe that the sizes of S, p, and q are polynomial in the size of M and w, which proves the main claim.</p><p>The hardness of containment in the presence of schema implies hardness of the static analysis problems we study.</p><p>Lemma F.2. Type checking, equivalence, and schema elicitation are EXPTIME-hard.</p><p>Proof. We reduce the containment of unary 2RPQs in the presence of schema to the problems of interest. Note that by Theorem F.1 and Corollary D.2, containment of unary acyclic 2RPQs is EXPTIMEhard. We take any schema S and two unary 2RPQs p(x) and q(x). In all reductions S is the input schema and we assume a single unary constructor F = { f A }.</p><p>We begin by showing that testing (T , S) |= Γ T is EXPTIME-hard. We take the transformation T defined with the following rules. A(f A (x)) ← q(x) and a(f A (x), f A (x)) ← p(x) .</p><p>We observe that (T , S) |= Γ T if and only if p(x) ⊆ S q(x).</p><p>For equivalence, we define the following two transformations. T 1 : A(f A (x)) ← q(x) .</p><p>T 2 : A(f A (x)) ← q(x) , A(f A (x)) ← p(x) .</p><p>We observe that T 1 ≡ S T 2 if and only if p(x) ⊆ S q(x).</p><p>For type checking we define the following transformation and output schema T : A(f A (x)) ← p(x) , A(f A (x)) ← q(x) , a(f A (x), f A (x)) ← q(x) .</p><p>S ′ : A → a : A 1 .</p><p>We observe that that T (S) ⊆ S ′ if and only if p(x) ⊆ S q(x).</p><p>To prove that schema elicitation is also EXPTIME-hard, we take the previous transformation T , the input schema S, and show that p(x) ⊆ S q(x) if and only if the ⊆-minimal schema that captures the output graphs is precisely S ′ . We observe that deciding equivalence of two schemas is easily accomplished in polynomial time and therefore any algorithm for schema elicitation must require exponential time. □</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">IFO: A Formal Semantic Database Model</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<idno type="DOI">10.1145/32204.32205</idno>
		<ptr target="https://doi.org/10.1145/32204.32205" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="525" to="565" />
			<date type="published" when="1987-11">1987. Nov. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Object Identity as a Query Language Primitive</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paris</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
		<idno type="DOI">10.1145/290179.290182</idno>
		<ptr target="https://doi.org/10.1145/290179.290182" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="798" to="842" />
			<date type="published" when="1998-09">1998. Sept. 1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Property Graph Database Model</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-2100/paper26.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Alberto Mendelzon International Workshop on Foundations of Data Management</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<meeting>the 12th Alberto Mendelzon International Workshop on Foundations of Data Management<address><addrLine>Cali, Colombia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-05-21">2018. May 21-25, 2018. 2100</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Survey of graph database models</title>
		<author>
			<persName><forename type="first">Renzo</forename><surname>Angles</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Gutierrez</surname></persName>
		</author>
		<idno type="DOI">10.1145/1322432.1322433</idno>
		<ptr target="https://doi.org/10.1145/1322432.1322433" />
	</analytic>
	<monogr>
		<title level="j">Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2008-02">2008. Feb. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The language of plain SO-tgds: Composition, inversion and structural properties</title>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cristian</forename><surname>Riveros</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.jcss.2013.01.002</idno>
		<ptr target="https://doi.org/10.1016/j.jcss.2013.01.002" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<date type="published" when="2013-09">2013. Sept. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Franz</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulrike</forename><surname>Sattler</surname></persName>
		</author>
		<title level="m">An Introduction to Description Logic</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Schema mappings and data exchange for graph databases</title>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Barceló</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<idno type="DOI">10.1145/2448496.2448520</idno>
		<ptr target="https://doi.org/10.1145/2448496.2448520" />
	</analytic>
	<monogr>
		<title level="m">Joint 2013 EDBT/ICDT Conferences, ICDT '13 Proceedings</title>
		<meeting><address><addrLine>Genoa, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-03-18">2013. March 18-22, 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Solutions in XML data exchange</title>
		<author>
			<persName><forename type="first">Mikolaj</forename><surname>Bojanczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Leszek</forename><surname>Aleksander Kolodziejczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.jcss.2013.01.004</idno>
		<ptr target="https://doi.org/10.1016/j.jcss.2013.01.004" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<date type="published" when="2013-09">2013. Sept. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Static Analysis of Graph Database Transformations</title>
		<author>
			<persName><forename type="first">Iovka</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benoit</forename><surname>Groz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sławek</forename><surname>Staworko</surname></persName>
		</author>
		<ptr target="https://hal.science/hal-03937274" />
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Consistency and Certain Answers in Relational to RDF Data Exchange with Shape Constraints</title>
		<author>
			<persName><forename type="first">Iovka</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sławek</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose</forename><surname>Lozano</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-54623-6_9</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-54623-6_9" />
	</analytic>
	<monogr>
		<title level="j">New Trends in Databases and Information Systems</title>
		<imprint>
			<biblScope unit="volume">1259</biblScope>
			<biblScope unit="page" from="97" to="107" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Schema Validation and Evolution for Graph Databases</title>
		<author>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Furniss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alastair</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Russ</forename><surname>Harmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugenia</forename><surname>Oshurko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hannes</forename><surname>Voigt</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-33223-5_37</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-33223-5_37" />
	</analytic>
	<monogr>
		<title level="j">Conceptual Modeling</title>
		<imprint>
			<biblScope unit="page" from="448" to="456" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">UnQL: A Query Language and Algebra for Semistructured Data Based on Structural Recursion</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<idno type="DOI">10.1007/s007780050084</idno>
		<ptr target="https://doi.org/10.1007/s007780050084" />
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="76" to="110" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Simplifying schema mappings</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1145/1938551.1938568</idno>
		<ptr target="https://doi.org/10.1145/1938551.1938568" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Database Theory</title>
		<meeting>the 14th International Conference on Database Theory</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="114" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Answering Regular Path Queries in Expressive Description Logics: An Automata-Theoretic Approach</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Magdalena</forename><surname>Ortiz</surname></persName>
		</author>
		<ptr target="http://www.aaai.org/Library/AAAI/2007/aaai07-061.php" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Second AAAI Conference on Artificial Intelligence<address><addrLine>Vancouver, British Columbia, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2007-07-22">2007. July 22-26, 2007</date>
			<biblScope unit="page" from="391" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Containment of Conjunctive Regular Path Queries with Inverse</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KR 2000, Principles of Knowledge Representation and Reasoning Proceedings of the Seventh International Conference</title>
		<meeting><address><addrLine>Breckenridge, Colorado, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000-04-11">2000. April 11-15, 2000</date>
			<biblScope unit="page" from="176" to="185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Containment of Regular Path Queries under Description Logic Constraints</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Magdalena</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mantas</forename><surname>Simkus</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-141</idno>
		<ptr target="https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-141" />
	</analytic>
	<monogr>
		<title level="m">IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence</title>
		<meeting><address><addrLine>Barcelona, Catalonia, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-07-16">2011. July 16-22, 2011</date>
			<biblScope unit="page" from="805" to="812" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Entity-Relationship Model: Toward a Unified View of Data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1145/1282480.1282492</idno>
		<ptr target="https://doi.org/10.1145/1282480.1282492" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Very Large Data Bases</title>
		<meeting>the International Conference on Very Large Data Bases<address><addrLine>Framingham, Massachusetts, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975-09-22">1975. September 22-24, 1975</date>
			<biblScope unit="page">173</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Semantic Analysis of R2RML Mappings for Ontology-Based Data Access</title>
		<author>
			<persName><forename type="first">Cristina</forename><surname>Civili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose</forename><surname>Mora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Ruzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valerio</forename><surname>Santarelli</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-45276-0_3</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-45276-0_3" />
	</analytic>
	<monogr>
		<title level="j">Web Reasoning and Rule Systems</title>
		<imprint>
			<biblScope unit="page" from="25" to="38" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Semantics and Validation of Recursive SHACL</title>
		<author>
			<persName><forename type="first">Julien</forename><surname>Corman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ognjen</forename><surname>Savkovic</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-00671-6_19</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-00671-6_19" />
	</analytic>
	<monogr>
		<title level="m">The Semantic Web -ISWC</title>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="page" from="318" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Polynomial-Time Implication Problems for Unary Inclusion Dependencies</title>
		<author>
			<persName><forename type="first">Stavros</forename><forename type="middle">S</forename><surname>Cosmadakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paris</forename><forename type="middle">C</forename><surname>Kanellakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1145/78935.78937</idno>
		<ptr target="https://doi.org/10.1145/78935.78937" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="15" to="46" />
			<date type="published" when="1990">1990. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Monadic second-order definable graph transductions: a survey</title>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Courcelle</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(94)90268-2</idno>
		<ptr target="https://doi.org/10.1016/0304-3975(94)90268-2" />
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">R2RML: RDB to RDF Mapping Language</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Cyganiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seema</forename><surname>Sundara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Souripriya</forename><surname>Das</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2012/REC-r2rml-20120927/" />
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation. W3C</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimization Properties for Classes of Conjunctive Regular Path Queries</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-46093-4_2</idno>
		<ptr target="https://doi.org/10.1007/3-540-46093-4_2" />
	</analytic>
	<monogr>
		<title level="j">Database Programming Languages</title>
		<imprint>
			<biblScope unit="page" from="21" to="39" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Renée</forename><forename type="middle">J</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucian</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><surname>Popa</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2004.10.033</idno>
		<ptr target="https://doi.org/10.1016/j.tcs.2004.10.033" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the undecidability of the equivalence of second-order tuple generating dependencies</title>
		<author>
			<persName><forename type="first">Ingo</forename><surname>Feinerer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vadim</forename><surname>Savenkov</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.is.2014.09.003</idno>
		<ptr target="https://doi.org/10.1016/j.is.2014.09.003" />
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">TBox and ABox Reasoning in Expressive Description Logics</title>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giacomo</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting>the Fifth International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="316" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">On Finite Entailment of Non-Local Queries in Description Logics</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Gogacz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Víctor</forename><surname>Gutiérrez-Basulto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Gutowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yazmín</forename><surname>Ibáñez-García</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<idno type="DOI">10.24963/kr.2020/43</idno>
		<ptr target="https://doi.org/10.24963/kr.2020/43" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting>the 17th International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="424" to="433" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On Finite and Unrestricted Query Entailment beyond SQ with Number Restrictions on Transitive Roles</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Gogacz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Víctor</forename><surname>Gutiérrez-Basulto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yazmín</forename><surname>Ibáñez-García</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<idno type="DOI">10.24963/ijcai.2019/238</idno>
		<ptr target="https://doi.org/10.24963/ijcai.2019/238" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJCAI-19</title>
		<meeting>the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJCAI-19</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1719" to="1725" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Finite Query Answering in Expressive Description Logics with Transitive Roles</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Gogacz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yazmín</forename><surname>Angélica Ibáñez-García</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Knowledge Representation and Reasoning: Proceedings of the Sixteenth International Conference</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="369" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<orgName type="collaboration">RDF Working Group</orgName>
		</author>
		<ptr target="https://www.w3.org/RDF/" />
		<title level="m">Resource Description Framework</title>
		<imprint>
			<date type="published" when="2004">2004. 2022. June 03</date>
		</imprint>
	</monogr>
	<note>W3C</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Finite Entailment of UCRPQs over ALC Ontologies</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Gutiérrez-Basulto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Albert</forename><surname>Gutowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yazmin</forename><surname>Ibáñez-Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Filip</forename><surname>Murlak</surname></persName>
		</author>
		<idno type="DOI">10.24963/kr.2022/19</idno>
		<ptr target="https://doi.org/10.24963/kr.2022/19" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting>the 19th International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="184" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A graph-oriented object database model</title>
		<author>
			<persName><forename type="first">Marc</forename><surname>Gyssens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dirk</forename><surname>Van Gucht</surname></persName>
		</author>
		<idno type="DOI">10.1109/69.298174</idno>
		<ptr target="https://doi.org/10.1109/69.298174" />
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="572" to="586" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Typing Graph-Manipulation Operations</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-36285-1_26</idno>
		<ptr target="https://doi.org/10.1007/3-540-36285-1_26" />
	</analytic>
	<monogr>
		<title level="m">Database Theory -ICDT</title>
		<imprint>
			<date type="published" when="2003">2003. 2003</date>
			<biblScope unit="page" from="391" to="406" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">FHIR Mapping Language</title>
		<idno>HL7.org</idno>
		<ptr target="https://hl7.org/fhir/mapping-language.html" />
		<imprint>
			<date type="published" when="2019">2019. 2022-05-25</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A Conjunctive Query Language for Description Logic Aboxes</title>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Tessaris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventeenth National Conference on Artificial Intelligence and Twelfth Conference on Innovative Applications of Artificial Intelligence</title>
		<meeting>the Seventeenth National Conference on Artificial Intelligence and Twelfth Conference on Innovative Applications of Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="399" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">ILOG: Declarative Creation and Manipulation of Object Identifiers</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masatoshi</forename><surname>Yoshikawa</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/1990/P455.PDF" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Very Large Data Bases</title>
		<meeting>the 16th International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="455" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">On the Equivalence of Database Restructurings Involving Object Identifiers (Extended Abstract)</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masatoshi</forename><surname>Yoshikawa</surname></persName>
		</author>
		<idno type="DOI">10.1145/113413.113443</idno>
		<ptr target="https://doi.org/10.1145/113413.113443" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</title>
		<meeting>the Tenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="328" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Finite Model Reasoning in Horn Description Logics</title>
		<author>
			<persName><forename type="first">Yazmín</forename><surname>Angélica Ibáñez-García</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourteenth International Conference on Principles of Knowledge Representation and Reasoning</title>
		<meeting>the Fourteenth International Conference on Principles of Knowledge Representation and Reasoning</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="288" to="297" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Graph-Transformation Verification Using Monadic Second-Order Logic</title>
		<author>
			<persName><forename type="first">Kazuhiro</forename><surname>Inaba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Soichiro</forename><surname>Hidaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhenjiang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hiroyuki</forename><surname>Kato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keisuke</forename><surname>Nakano</surname></persName>
		</author>
		<idno type="DOI">10.1145/2003476.2003482</idno>
		<ptr target="https://doi.org/10.1145/2003476.2003482" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International ACM SIGPLAN Symposium on Principles and Practices of Declarative Programming</title>
		<meeting>the 13th International ACM SIGPLAN Symposium on Principles and Practices of Declarative Programming</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="17" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">XSL Transformations (XSLT) Version 2.0</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kay</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2021/REC-xslt20-20210330/" />
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
	<note>Second Edition). W3C Recommendation. W3C.</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">F-Logic: A Higher-Order Language for Reasoning about Objects, Inheritance, and Scheme</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Lausen</surname></persName>
		</author>
		<idno type="DOI">10.1145/66926.66939</idno>
		<ptr target="https://doi.org/10.1145/66926.66939" />
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="134" to="146" />
			<date type="published" when="1989-06">1989. June 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On the Language of Nested Tuple Generating Dependencies</title>
		<author>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vadim</forename><surname>Sallinger</surname></persName>
		</author>
		<author>
			<persName><surname>Savenkov</surname></persName>
		</author>
		<idno type="DOI">10.1145/3369554</idno>
		<ptr target="https://doi.org/10.1145/3369554" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="8" />
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">The Logical Data Model</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gabriel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Kuper</surname></persName>
		</author>
		<author>
			<persName><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1145/155271.155274</idno>
		<ptr target="https://doi.org/10.1145/155271.155274" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="379" to="413" />
			<date type="published" when="1993-09">1993. Sept. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Pebble game algorithms and sparse graphs</title>
		<author>
			<persName><forename type="first">Audrey</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ileana</forename><surname>Streinu</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.disc.2007.07.104</idno>
		<ptr target="https://doi.org/10.1016/j.disc.2007.07.104" />
	</analytic>
	<monogr>
		<title level="j">Discret. Math</title>
		<imprint>
			<biblScope unit="volume">308</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1425" to="1437" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The hypernode model and its associated query language</title>
		<author>
			<persName><forename type="first">Mark</forename><surname>Levene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Poulovassilis</surname></persName>
		</author>
		<idno type="DOI">10.1109/JCIT.1990.128324</idno>
		<ptr target="https://doi.org/10.1109/JCIT.1990.128324" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Jerusalem Conference on Information Technology</title>
		<meeting>the 5th Jerusalem Conference on Information Technology</meeting>
		<imprint>
			<date type="published" when="1990">1990. 1990</date>
			<biblScope unit="page" from="520" to="530" />
		</imprint>
	</monogr>
	<note>Next Decade in Information Technology</note>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A Logic for Objects</title>
		<author>
			<persName><forename type="first">David</forename><surname>Maier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Foundations of Deductive Databases and Logic Programming</title>
		<meeting>the Workshop on Foundations of Deductive Databases and Logic Programming</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="6" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">XML type checking with macro tree transducers</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Maneth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandru</forename><surname>Berlea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Perst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Helmut</forename><surname>Seidl</surname></persName>
		</author>
		<idno type="DOI">10.1145/1065167.1065203</idno>
		<ptr target="https://doi.org/10.1145/1065167.1065203" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twenty-fourth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</title>
		<meeting>the twenty-fourth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Frontiers of tractability for typechecking simple XML transformations</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Neven</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.jcss.2006.10.005</idno>
		<ptr target="https://doi.org/10.1016/j.jcss.2006.10.005" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Typechecking top-down XML transformations: Fixed input or output schemas</title>
		<author>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Neven</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Gyssens</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.ic.2008.01.002</idno>
		<ptr target="https://doi.org/10.1016/j.ic.2008.01.002" />
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">206</biblScope>
			<biblScope unit="page" from="806" to="827" />
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Typechecking for XML transformers</title>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0022-0000(02)00030-2</idno>
		<ptr target="https://doi.org/10.1016/S0022-0000(02)00030-2" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<date type="published" when="2003">2003. 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">G-Log: a graph-based query language</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Peelman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Letizia</forename><surname>Tanca</surname></persName>
		</author>
		<idno type="DOI">10.1109/69.390249</idno>
		<ptr target="https://doi.org/10.1109/69.390249" />
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="436" to="453" />
			<date type="published" when="1995-06">1995. June 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">nSPARQL: A navigational language for RDF</title>
		<author>
			<persName><forename type="first">Jorge</forename><surname>Pérez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcelo</forename><surname>Arenas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Gutiérrez</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.websem.2010.01.002</idno>
		<ptr target="https://doi.org/10.1016/j.websem.2010.01.002" />
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="255" to="270" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">ShEx, RDF and FHIR</title>
		<author>
			<persName><forename type="first">Eric</forename><surname>Prud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">'</forename><surname>Hommeaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harold</forename><forename type="middle">R</forename><surname>Solbrig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guoqian</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Summit on Clinical Research Informatics, CRI 2017</title>
		<meeting><address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-03-27">2017. March 27-30, 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Handbook of Graph Grammars and Computing by Graph Transformations</title>
		<editor>Grzegorz Rozenberg</editor>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>World Scientific</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">On the Semantics of R2RML and its Relationship with the Direct Mapping</title>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">F</forename><surname>Sequeda</surname></persName>
		</author>
		<ptr target="https://ceur-ws.org/Vol-1035/iswc2013_poster_4.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ISWC 2013 Posters &amp; Demonstrations Track</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<meeting>the ISWC 2013 Posters &amp; Demonstrations Track<address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-10-23">2013. October 23, 2013</date>
			<biblScope unit="volume">1035</biblScope>
			<biblScope unit="page" from="193" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">XQuery 3.1: An XML Query Language</title>
		<author>
			<persName><forename type="first">Josh</forename><surname>Spiegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Dyck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Robie</surname></persName>
		</author>
		<ptr target="https://www.w3.org/TR/2017/REC-xquery-31-20170321/" />
	</analytic>
	<monogr>
		<title level="m">W3C Recommendation. W3C</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Complexity and Expressiveness of ShEx for RDF</title>
		<author>
			<persName><surname>Sławek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iovka</forename><surname>Staworko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose</forename><surname>Boneva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Labra</forename><surname>Emilio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Gayo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><forename type="middle">G</forename><surname>Hym</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harold</forename><surname>Prud</surname></persName>
		</author>
		<author>
			<persName><surname>Solbrig</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2015.195</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2015.195" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Database Theory (ICDT)</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="195" to="211" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Yago: A Core of Semantic Knowledge</title>
		<author>
			<persName><forename type="first">Fabian</forename><forename type="middle">M</forename><surname>Suchanek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gjergji</forename><surname>Kasneci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
		<idno type="DOI">10.1145/1242572.1242667</idno>
		<ptr target="https://doi.org/10.1145/1242572.1242667" />
	</analytic>
	<monogr>
		<title level="m">International Conference on World Wide Web (WWW)</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="697" to="706" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>