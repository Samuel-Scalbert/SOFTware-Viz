<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Semantics of negative sequential patterns</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Philippe</forename><surname>Besnard</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Guyet</forename><surname>Thomas</surname></persName>
						</author>
						<title level="a" type="main">Semantics of negative sequential patterns</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">72FBC63FD3887781488BDB2782E1F70F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:49+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In the field of pattern mining, a negative sequential pattern is specified by means of a sequence consisting of events to occur and of other events, called negative events, to be absent. For instance, containment of the pattern a ¬b c arises with an occurrence of a and a subsequent occurrence of c but no occurrence of b in between.</p><p>This article is to shed light on the ambiguity of such a seemingly intuitive notation and we identify eight possible semantics for the containment relation between a pattern and a sequence. These semantics are illustrated and formally studied, in particular we propose dominance and equivalence relations between them. Also we prove that support is anti-monotonic for some of these semantics. Some of the results are discussed with the aim of developing algorithms to extract efficiently frequent negative patterns.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In many application domains such as predictive maintenance or marketing, decision makers are interested in discovering specific events that trigger or are correlated to undesirable events. Sequential pattern mining <ref type="bibr" target="#b10">[11]</ref> is a technique that extracts such hidden rules from logs.</p><p>Often, the presence but also the absence of a specific action or event partly explains the occurrence of an undesirable situation <ref type="bibr" target="#b3">[4]</ref>. For example in predictive maintenance, if some maintenance operations have not been performed, e.g. damaged parts have not been replaced, then a fault is likely to occur in a short delay whereas if these operations were performed in time the fault would not occur. In marketing, if a marketplace customer has not received special offers or coupons for a long time then s/he has a high probability of churning whereas if s/he were provided with such offers s/he should remain loyal to her/his marketplace. Mining specific events to discover a context under which they occur, or do not occur, may provide interesting information. It is called actionable information as it serves to determine what action should be performed to avoid the undesirable situation, i.e. fault in monitored systems, churn in marketing, . . .  1 CNRS / IRIT, France, email: besnard@irit.fr 2 Institut Agro / IRISA UMR6074, France, email: thomas.guyet@irisa.fr</p><p>Standard sequential pattern mining algorithms <ref type="bibr" target="#b10">[11]</ref> extract sequential patterns that frequently occur in the logs. A sequential pattern is a sequence of events. For example, the sequential pattern a c d is read as "a occurs and then c occurs and finally d occurs". In practice, a pattern is frequent if its number of occurrences exceeds a user-defined threshold. If a c d occurs in most cases where a c occurs, then the sequential rule a c =⇒ d (read as "if a occurs and c occurs later, then d occurs afterwards") is useful to predict occurrences of d. The premise of a rule specifies what actually occurred frequently, but does not inform about what did not happen in these examples. Negative sequential patterns are sequential patterns that also specify non-occurring events. Intuitively, the syntax of a simple negative sequential pattern is as follows: a ¬b c . This pattern is read as "a occurs and then c occurs, but b does not occur in between". A negative sequential pattern can also be the premise of a rule.</p><p>We illustrate the interest of negative sequential patterns via the dataset of sequences in Figure <ref type="figure" target="#fig_0">1</ref>. The rightmost table gives the support (number of sequences containing both premise and conclusion) and the accuracy (ratio of the support with the support of the premise only) of some rules. The sequential patterns a c d and a c e occur thrice each. Rules a c ⇒ d and a c ⇒ e obtained from positive sequential patterns have low accuracy, they are not really interesting. Let s p = a b c ? be a new sequence with an event to predict. The two rules above predict e or d with the same likelihood.</p><p>Modeling the absence of event b in patterns appears to be meaningful to describe the dataset. Indeed, rule a ¬b c ⇒ d occurs in half of the sequences and has an accuracy of 3 /4 (whereas the accuracy of the rule without ¬b is only 1 /2). When it comes to predicting occurrences of d, the absence of b is meaningful. These new rules predict event e with a likelihood of 3 /4 for s p . In a medical context, a, b and c may be drug administration while d and e some medical events, respectively, patient declared cured and patient suffering complications. The situation that is illustrated by our synthetic dataset is the case of adverse drugs reaction. Being exposed to drug b while being treated by drugs a and c leads to complications. Mining positive patterns in a medical database would miss such adverse drug reaction.</p><p>Mining frequent negative sequential patterns is of utmost interest to discover actionable rules taking into account absent events. In <ref type="bibr" target="#b9">[10]</ref>, pattern mining is viewed as the computation of a theory T h(L, D, C) = {ψ ∈ L | C(ψ, D)}. Given a pattern language L, some constraints C and a database D, a pattern mining algorithm enumerates the elements of the language that fulfill the constraints within the data. In the case of frequent pattern mining, C is the minimal support constraint. The success of pattern mining techniques comes from an antimonotonicity property of some support measures <ref type="bibr" target="#b0">[1]</ref>. Intuitively, if a pattern p is not frequent, no pattern "larger" than p is frequent. Pattern mining algorithms prune the search space whenever an unfrequent pattern is found. The "is larger than" relation induces a partial order on the set of patterns, L. For a support measure that is anti-monotonic on this structure, the frequent pattern mining trick can be used to efficiently prune the search space. Ideally, this structure is a lattice, in which case the above strategy is complete and correct.</p><p>As to frequent negative sequential pattern mining, L is the set of negative sequential patterns, D is a dataset of sequences and C is the constraint of minimal frequency. Few approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref> proposed algorithms to extract such patterns and none of them proposed an algorithm based on an anti-monotonic support measure. The questions we address in this article are:</p><p>1. what is a proper support measure for negative sequential patterns? 2. is there a support measure enjoying anti-monotonicity?</p><p>The support measure is strongly related to the containment relation that determines whether a pattern occurs in a sequence or not. In the case of negative sequential patterns, the apparently intuitive notion of absent event appears to be intricate and the negation syntax (the ¬ symbol) used in the literature is hiding different semantics. In logic, it is accepted knowledge that there is more than one kind of negation <ref type="bibr" target="#b12">[13]</ref>. For instance, in classical reasoning ¬p means that p is false while in stable reasoning ¬p means that p cannot be proved <ref type="bibr" target="#b1">[2]</ref>.</p><p>The objective of this article is not to propose a new pattern mining algorithm for negative sequential patterns but to establish formal results on containment relations that can serve as a basis to design such algorithms. The main contributions of our work are as follows:</p><p>• we define eight possible semantics for the containment relation of negative sequential patterns, • we establish dominance and equivalence relations between containment relations, • we provide three partial orders for which some containment relations induce anti-monotonic support measures.   We denote by N the set of negative sequential patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Negative sequential patterns</head><p>It can be noticed that Definition 1 introduces syntactic limitations on negative sequential patterns that are commonly encountered in the state of the art <ref type="bibr" target="#b11">[12]</ref>:</p><p>• a pattern can neither start or finish by a negative itemset, • a pattern cannot have two successive negative itemsets.</p><p>Example 1 (Negative sequential pattern). This example illustrates the notations introduced in Definition 1. Consider I = {a, b, c, d} and p = a ¬(bc) (ad) d ¬(ab) d . Let p 1 = {a}, p 2 = {ad}, p 3 = {d}, p 4 = {d} and q 1 = {bc}, q 2 = ∅, q 3 = {ab}. The length of p is |p| = 6 and p + = a (ad) d d .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Semantics of negative sequential patterns</head><p>The semantics of negative sequential patterns relies upon negative containment: a sequence s supports pattern p (or p matches the sequence s) iff s contains a sub-sequence s ′ such that every positive itemset of p is included in some itemset of s ′ in the same order and for any negative itemset ¬q i of p, q i is not included in any itemset occurring in the sub-sequence of s ′ located between the occurrence of the positive itemset preceding ¬q i in p and the occurrence of the positive itemset following ¬q i in p.</p><p>Definition 2 (Non inclusion). We introduce two relations comparing two itemsets P ∈ 2 I \ {∅} and I ∈ 2 I :</p><p>• partial non inclusion: P G I ⇔ ∃e ∈ P, e I • total non inclusion: P D I ⇔ ∀e ∈ P, e I Partial non-inclusion means that P \ I is non-empty while total noninclusion means that P and I are disjoint. By convention, ∅ D I and ∅ G I for all I ⊆ I.</p><p>In the sequel we will denote the general form of itemset noninclusion by the symbol * , meaning either G or D .</p><p>Intuitively, partial non-inclusion identifies the itemset P with a disjunction of negative constraints, i.e. at least one of the items (of P) has to be absent from I, and total non-inclusion consider the itemset P as a conjunction of negative constraints: all items (of P) have to be absent from I.</p><p>Choosing one non-inclusion interpretation or the other has consequences on extracted patterns as well as on pattern search. Let us illustrate this with the following dataset of sequences:</p><formula xml:id="formula_0">D =                  s 1 = (bc) f a s 2 = (bc) (c f ) a s 3 = (bc) (d f ) a s 4 = (bc) (e f ) a s 5 = (bc) (cde f ) a                  .</formula><p>Table <ref type="table" target="#tab_3">1</ref> compares the support of patterns under the two semantics of itemset non-inclusion. Since the positive part of p 2 is in s 2 , p 2 occurs in the sequence iff (cd) * (c f ). As for total non-inclusion, it is false that (cd) D (c f ) because c occurs in (c f ), and thus p 2 does not occur in s 2 . As for partial non-inclusion, it is true that (cd) G (c f ), because d does not occur in (c f ), and thus p 2 occurs in s 2 . Lemma 1. <ref type="foot" target="#foot_0">3</ref> Let P, I ⊆ I be two itemsets: under the total and partial non-inclusion relations. Each pattern has the form b ¬q i a where q i are itemsets such that q i ⊂ q i+1 . partial total non-inclusion non-inclusion</p><formula xml:id="formula_1">P D I =⇒ P G I (1)</formula><formula xml:id="formula_2">G D p 1 = b ¬c a {s 1 , s 3 , s 4 } {s 1 , s 3 , s 4 } p 2 = b ¬(cd) a {s 1 , s 2 , s 3 , s 4 } {s 1 , s 4 } p 3 = b ¬(cde) a {s 1 , s 2 , s 3 , s 4 } {s 1 } p 4 = b ¬(cdeg) a {s 1 , s 2 , s 3 , s 4 , s 5 } {s 1 }</formula><p>Now, we formulate the notions of sub-sequence, non-inclusion and absence by means of the concept of embedding. </p><formula xml:id="formula_3">• p i ⊆ s e i for all i ∈ [m] • q i * s j , ∀ j ∈ [e i + 1, e i+1 -1] for all i ∈ [m -1]</formula><p>An increasing<ref type="foot" target="#foot_1">4</ref> tuple e = (e i ) i∈[m] ∈ [n] m is a -embedding (read: strict-embedding) of pattern p in sequence s iff:</p><formula xml:id="formula_4">• p i ⊆ s e i for all i ∈ [m] • q i * j∈[e i +1,e i+1 -1] s j for all i ∈ [m -1]</formula><p>Intuitively, the constraint of a negative itemset q i is checked on the sequence's itemsets at positions in interval [e i + 1, e i+1 -1], i.e. between occurrences of the two positive itemsets surrounding the negative itemset in the pattern. A soft embedding considers individually each of the sequence's itemsets of [e i + 1, e i+1 -1] while a strict embedding consider them as a whole.</p><p>Example 2 (Itemset absence semantics). Let p = a ¬(bc) d be a pattern and consider four sequences as follows:</p><formula xml:id="formula_5">Sequence D D G G s 1 = a c b e d ✓ s 2 = a (bc) e d s 3 = a b e d ✓ ✓ s 4 = a e d ✓ ✓ ✓ ✓</formula><p>The reader can notice that each sequence contains a unique occurrence of p + = a d , the positive part of pattern p. Considering softembedding and partial non-inclusion ( * := G ), p occurs in s 1 , s 3 and s 4 but not in s 2 . Considering strict-embedding and partial noninclusion, p occurs in s 3 and s 4 . Indeed, items b and c occur between occurrences of a and d in s 1 and s 2 . Considering total non-inclusion ( * := D ) and either type of embeddings, the absence of an itemset is satisfied if any of its items is absent. Hence, p occurs only in s 4 .</p><p>Lemma 2. If e is a -embedding, then e is a -embedding, regardless of whether * is G or D .</p><formula xml:id="formula_6">Lemma 3. In the case that * is D , e is a -embedding iff e is a -embedding Lemma 4. Let p = p 1 ¬q 1 . . . ¬q n-1 p n ∈ N such that |q i | ≤ 1 for all i ∈ [n -1]</formula><p>, then e is a -embedding iff e is a -embedding.</p><p>Lemma 4 shows that in the simple case of patterns where all negative itemsets are singleton sets, the notions of strict and soft embeddings coincide.</p><p>Lemma 5. Let p ∈ N, if e is an embedding of p in some sequence s, then e is an embedding of p + in s.</p><p>Another point that determines the semantics of negative containment concerns the multiple occurrences of some pattern in a sequence: should at least one or should all occurrences of the pattern positive part in the sequence satisfy the non-inclusion constraints? Definition 5 (Negative pattern occurrence). Let s be a sequence and p be a negative sequential pattern with p + the positive part of p. For * ∈ { D , G } and ∈ { , },</p><p>• p * s denotes that pattern p occurs in sequence s iff there exists at least one -embedding of p in s considering the * noninclusion. • p ⊑ * s denotes that pattern p occurs in sequence s iff for each embedding e of p + in s, e is also a -embedding of p in s considering the * non-inclusion, and there exists at least one embedding e of p + .</p><p>Definition 5 permits to capture two semantics for negative sequential patterns depending on the occurrences of the positive part: p ⊑ * s states that a negative pattern p occurs in a sequence s iff there exists at least one occurrence of the positive part of pattern p in sequence s and every such occurrence satisfies the negative constraints; p * s states that p occurs in a sequence s iff there exists at least one occurrence of the positive part of pattern p in sequence s and at least one of these occurrences satisfies the negative constraints. However, p + occurs four times in s 2 through embeddings (1, 2, 5), <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b7">8)</ref>, <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8)</ref> and <ref type="bibr" target="#b3">(4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8)</ref>. The first two occurrences do not satisfy the negative constraint (¬c) but the last two occurrences do. Under the weak occurrence semantics, pattern p occurs in sequence s 2 whereas it fails to do so under the strong occurrence semantics. Lemma 6. Let p be an NSP and s a sequence. For ∈ { , } and</p><formula xml:id="formula_7">* ∈ { D , G }, p ⊑ * s =⇒ p * s<label>(2)</label></formula><p>Lemma 7. Let p be an NSP and s a sequence. For ∈ { , },</p><formula xml:id="formula_8">p D s =⇒ p G s p ⊑ D s =⇒ p ⊑ G s</formula><p>In this section, we have exhibited several semantics that can be associated to negative patterns. This leads to eight different types of pattern occurrences. We take Θ to denote the set of containment relations:</p><formula xml:id="formula_9">Θ = D , D , G , G , ⊑ D , ⊑ D , ⊑ G , ⊑ G</formula><p>These containment relations allow to disambiguate the semantics of negative pattern containment encountered in the literature. Next, Section 4 investigates possible equivalent containment relations in Θ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Dominance and equivalence between containment relations</head><p>Definition 6 (Dominance). For θ, θ ′ ∈ Θ, θ dominates θ ′ , denoted θ θ ′ , iff pθs =⇒ pθ ′ s for all p ∈ N and all sequence s. We denote by θ θ ′ iff θ θ ′ is false, that is, there is some couple (p, s) such that pθs but not pθ ′ s.</p><p>The idea behind dominance between two containment relations θ and θ ′ is related to the sequences in which a pattern occurs. By definition, if θ θ ′ then a pattern p ∈ N occurs in a sequence s according to the θ ′ containment relation whenever p occurs in s according to the θ containment relation. In the context of pattern mining, this is useful to design algorithms exploiting properties of a dominating containment relation in order to extract efficiently the patterns according to dominated containment relations. Lemma 8. The dominance relation is a pre-order.</p><formula xml:id="formula_10">Definition 7 (Equivalent containment relations). For θ, θ ′ ∈ Θ, θ is equivalent to θ ′ , denoted θ ∼ θ ′ iff θ θ ′ and θ ′ θ. Lemma 9.</formula><p>∼ is an equivalence relation on Θ.</p><p>Two equivalent containment relations have equivalent semantics, in the following sense: the sets of sequences in which a given pattern occurs are the same and, reciprocally, the sets of negative patterns that occur in a sequence are the same when considering these two containment relations.</p><p>We now study the dominance relations that hold between the elements of Θ.</p><p>Proposition 1. The following dominance statements between containment relations hold:</p><formula xml:id="formula_11">⊑ * * (3) * * and ⊑ * ⊑ * (4) D D and ⊑ D ⊑ D (5) D G and ⊑ D ⊑ G (6)</formula><p>and the following non-dominance statements hold:</p><formula xml:id="formula_12">G D and ⊑ G ⊑ D (7) * ⊑ * (8) G G and ⊑ G ⊑ G (9) G ⊑ G (10) ⊑ G G (11) * ⊑ * ′ (12) D ⊑ G (13) ⊑ G D (<label>14</label></formula><formula xml:id="formula_13">)</formula><p>where * ∈ D , G and ∈ { , }.</p><p>Proposition 1 gathers results from Section 3. Each line expresses several relationships between pairs of containment relations. Equations 4-6 are dominance statements deduced from Lemmas 2, 3, 6 and 7. Equations 7-9 state the absence of dominance for which we can exhibit counterexamples. In addition, many other dominance and non dominance relationships can be deduced from Proposition 1 using transitivity of dominance (Lemma 8). Table <ref type="table" target="#tab_5">2</ref> summarizes them.</p><p>An interesting result in Proposition 1 is that there are two pairs of containment relations, ⊑ D , ⊑ D and D , D , whose two members are equivalent. In fact, there are six equivalence classes of containment relations: ⊑ G , ⊑ G , G , G , ⊑ D , ⊑ D and D , D . Figure <ref type="figure" target="#fig_3">2</ref> illustrates the dominance relation on the quotient set Θ/∼.</p><p>We can finally point out that Lemma 4 adds a dominance relationship for the case that, in negative sequential patterns, negative itemsets are restricted to be singleton sets. In this case, the equivalence classes become: D , D , G , G , ⊑ D , ⊑ D and ⊑ G , ⊑ G . Figure <ref type="figure" target="#fig_3">2</ref> illustrates the dominance relation on the quotient set Θ/∼ in this specific case. </p><formula xml:id="formula_14">⊑ D ∼ ⊑ D D ∼ D G G ⊑ G ⊑ G (3) (6) (4) (6) (4)<label>(3)</label></formula><p>(3) Figure <ref type="figure" target="#fig_2">3</ref>. Dominance between containment relations for the case that, in negative sequential patterns, negative itemsets are restricted to be singleton sets. The labels for edges again refer to the equations given in Proposition 1.</p><formula xml:id="formula_15">⊑ D ∼ ⊑ D D ∼ D G ∼ G ⊑ G ∼ ⊑ G (3) (6) (6) (3)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Anti-monotonicity</head><p>It is now time to check whether there are containment relations that enjoy interesting properties. In our initial context of mining frequent negative sequential patterns, we investigate anti-monotonicity properties.</p><p>According to Wang et al. <ref type="bibr" target="#b11">[12]</ref>, "the downward property (. . . ) does not hold in negative sequential analysis". The "downward property" denotes the anti-monotonicity property. We will see that this assertion is actually false with some semantics.</p><p>Anti-monotonicity makes sense only with a partial order on the set of NSPs. We first introduce different possible partial orders and then we introduce anti-monotonicity.</p><p>In the remaining of the section, non-inclusion of itemsets is total non-inclusion, D . Thus, we can count on the anti-monotonicity of non-inclusion of itemsets: q ⊆ q ′ =⇒ ∀p ∈ I, (q ′ D p ⇒ q D p) for all itemsets q, q ′ . </p><formula xml:id="formula_16">⊑ G G ⊑ G G ⊑ D D ⊑ D D ⊑ G • - - - - G - • - - - - - ⊑ G - - • - - - - G - - - • - - - - ⊑ D • D - - - • - ⊑ D • D - - - - •</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Partial orders</head><p>Definition 8 introduces three relations between negative sequential patterns that are partial orders (see Proposition 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 8 (NSP relations). Consider two NSPs</head><formula xml:id="formula_17">p = p 1 ¬q 1 p 2 ¬q 2 • • • p k-1 ¬q k-1 p k and p ′ = p ′ 1 ¬q ′ 1 p ′ 2 ¬q ′ 2 • • • p ′ k ′ -1 ¬q ′ k ′ -1 p ′ k ′ . By definition, p ⊳ • p ′ iff k ≤ k ′ and there exists an increasing 4 tuple (u i ) i∈[k] ∈ [k ′ ] k and: 1. ∀i ∈ [k], p i ⊆ p ′ u i 2. ∀i ∈ [k -1], q i ⊆ j∈[u i ,u i+1 -1] q ′ j 3. k = k ′ =⇒ ∃ j ∈ [k], p j p ′ j or ∃ j ∈ [k -1], q j q ′ j by definition, p ⊳ p ′ iff k ≤ k ′ and: 1. ∀i ∈ [k], p i ⊆ p ′ i 2. ∀i ∈ [k -1], q i ⊆ q ′ i 3. k = k ′ =⇒ p k p ′ k or ∃ j ∈ [k -1] s.t. q j q ′ j</formula><p>and, by definition, p ⊳ + p ′ iff k = k ′ and:</p><formula xml:id="formula_18">1. ∀i ∈ [k], p i = p ′ i 2. ∀i ∈ [k -1], q i ⊆ q ′ i 3. ∃ j ∈ [k -1] s.t. q j q ′ j</formula><p>The ⊳ • relation can be seen as the "classical" inclusion relation between sequential patterns <ref type="bibr" target="#b10">[11]</ref>. An NSP p is less specific than p ′ iff p + is a subsequence of p ′+ and negative constraints are satisfied. The main difference with ⊳ is that ⊳ • permits to insert new positive itemsets in the middle of the sequence while ⊳ permits only insertion of new positive itemsets at the end. 5,6 Nonetheless, it is still possible to insert items to the positive itemsets. The ⊳ + does not even permit such differences: for two NSPs to be comparable via ⊳ + , they must have the same positive itemsets.</p><p>Lemma 10. For p, p ′ ∈ N,</p><formula xml:id="formula_19">p ⊳ + p ′ =⇒ p ⊳ p ′ =⇒ p ⊳ • p ′<label>(15)</label></formula><p>Proposition 2 (Strict partial orders). ⊳ • , ⊳ and ⊳ + are partial orders on N.</p><p>We can notice that the third conditions in Definition 8 enforce the relations to be irreflexive. Removing these conditions enables to define non-strict partial orders.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Anti-monotonicity</head><p>Let us first define the anti-monotonicity property of a containment relation θ ∈ Θ considering a strict partial order ⋉ ∈ {⊳, ⊳ • , ⊳ + }.</p><p>Definition 9 (Anti-monotonicity on (N, ⋉)). Let θ ∈ Θ be a containment relation, θ is anti-monotonic on (N, ⋉) iff for all p, p ′ ∈ N and all sequences s:</p><formula xml:id="formula_20">p ⋉ p ′ =⇒ (p ′ θs =⇒ pθs)</formula><p>First of all, we provide an example showing that none of the containment relations is anti-monotonic on (N, ⊳ • ). Let p = b ¬c a , p ′ = b ¬c d a and s = b e d c a . Then, we have p ⊳ • p ′ . <ref type="foot" target="#foot_4">7</ref> Nonetheless, for each θ ∈ Θ, p ′ θs but it is false that pθs.</p><p>In fact, the presence of the item d in the sequence changes the scope for checking the absence of c. This example is similar to the one used by Zheng et al. <ref type="bibr" target="#b14">[15]</ref> to state that anti-monotonic property does not hold for negative sequential patterns. Nonetheless, the antimonotonicity property holds in case the partial order prevents from changing the scope for absent items.  <ref type="foot" target="#foot_5">8</ref> Nonetheless, p ′ ⊑ D s holds but it is false that p ⊑ D s. In fact, without the presence of the item d in the pattern, there are three possible embeddings of p in s. For ⊑ D each embedding must satisfy the negation of b, which is not the case, but for D it is sufficient to have only one embedding satisfying negations.</p><p>The previous example illustrates the problem when extending the pattern with additional itemsets. The same issue is encountered with the following example considering patterns of equal length while one pattern has an extended itemset. Let p = a ¬b c , p ′ = a ¬b (cd) and s = a (cd) a b c . Then, we have p ⊳ p ′ . Nonetheless, p ′ ⊑ D s holds but it is false that p ⊑ D s. We remind that this section was restricted to the case of total noninclusion ( D ) but the results also hold when D is replaced by G except that we must reverse the inclusion relations for negatives in the partial orders (that is, j∈[u i ,u i+1 -1] q ′ j ⊂ q i for ⊳ • and q ′ i ⊆ q i for ⊳ and ⊳ + ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Application to pattern mining</head><p>The definitions of pattern support, frequent pattern and pattern mining derive naturally from the notion of occurrence of a negative sequential pattern, no matter the choices for embedding (soft or strict), non-inclusion (partial or total) and occurrences (weak or strong). However, these choices about the semantics of NSPs impact directly the number of frequent patterns (under the same minimal threshold constraint) and also computation time. The stronger the negative constraints, the fewer the number of sequences containing a pattern, and the lesser the number of frequent patterns. When there is no ambiguity on the dataset of sequences, supp-</p><formula xml:id="formula_21">θ D (p) is denoted supp-θ(p).</formula><p>Clearly, if a containment relation θ is dominated by another containment relation θ ′ , then the support of the pattern evaluated with θ is lower than the support of the pattern evaluated with θ ′ . The next proposition ensues from Proposition 1.</p><formula xml:id="formula_22">Proposition 5. For p ∈ N, supp-⊑ * (p) ≤ supp- * (p) (16) supp-⊑ * (p) ≤ supp-⊑ * (p) supp- * (p) ≤ supp- * (p) (17) supp-⊑ D (p) ≤ supp-⊑ D (p) supp-D (p) ≤ supp-D (p) (18) supp-⊑ D (p) ≤ supp-⊑ G (p) supp-D (p) ≤ supp-G (p)<label>(19)</label></formula><p>In addition, the following anti-monotonicity properties of support measures ensue from Propositions 3 and 4. Proposition 6. For p, p ′ ∈ N,</p><formula xml:id="formula_23">p ⊳ p ′ =⇒ supp-D (p ′ ≤ supp-D (p) (20) p ⊳ + p ′ =⇒ supp-⊑ D (p ′ ) ≤ supp-⊑ D (p) supp-D (p ′ ) ≤ supp-D (p)<label>(21)</label></formula><p>There are two practical ways to exploit these results to implement efficient frequent NSP mining algorithms. On the one hand, the results from Proposition 6 can be directly used to implement algorithms with efficient and correct strategies to prune the search space. <ref type="foot" target="#foot_6">9</ref>For D containment relation, Equation 20 exploits the ⊳ partial order to early prune a priori unfrequent patterns. For ⊑ D containment relation, the ⊳ + partial order must be used to ensure the correctness of the algorithm (Equation <ref type="formula" target="#formula_23">21</ref>). Unfortunately, ⊳ + is less interesting than ⊳ because there are fewer pairs of comparable patterns. On the other hand, the support evaluated with D is an upper bound for the support of ⊑ D (Equation <ref type="formula">16</ref>). Thus, it is possible also to prune patterns accessible with the partial order ⊳ without losing the correctness of the pruning strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">A proposal to disambiguate syntax of negative sequential patterns</head><p>The ¬ symbol is overloaded in the literature about negative sequential pattern mining. Our intuition was that the different approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b14">15]</ref> do not extract the same set of patterns because of slightly different definition of negative patterns. Our framework deals with the need to define an unambiguous containment relation between a negative sequential pattern p and a sequence s that informs the user about:</p><p>• how multiple occurrences of the positive part of p are handled,</p><p>• how negative itemsets are handled (type of embedding and type of non-inclusion relation).</p><p>We separate these two dimensions of our definition of a containment relation because the second refers to single itemsets, while the first refers to the whole pattern. Thanks to our framework, we are able to assign a containment relation to each approach from the literature. The approaches based on eNSP <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref> are based on the containment relation ⊑ D , PNSP <ref type="bibr" target="#b8">[9]</ref> uses the relation G , and NegPSpan <ref type="bibr" target="#b7">[8]</ref> and NegGSP <ref type="bibr" target="#b14">[15]</ref> deal with the equivalent relations D and D . This confirms our initial intuition: the different approaches do not use the same containment relations and thus they do not aim at extracting the same set of patterns. Moreover, it is worth noticing that these four approaches explore a large range of the possible containment relations. eNSP exploits the strong notion of occurrence while the other approaches exploit the weak notion. All but PNSP approaches are based on total non-inclusion. Strict-embedding ( ) is generally preferred to soft-embedding ( ). eNSP (⊑ D ) made the most restrictive choice by using the containment relation that dominates all the others. On the opposite, the two least restrictive choices ( G and ⊑ G ) have not been explored, presumably due to their obvious lack of suitable properties for pattern mining.</p><p>Finally, it is worth comparing negative sequential patterns with some formulas in Linear Temporal Logic on finite traces (LTLf) <ref type="bibr" target="#b5">[6]</ref>. The question is to find specific LTLf formulas capturing our containment relations between any two patterns p and s. Then, it is interesting to notice that containment relations based on soft-embedding have simple counterparts in the language of LTLf. Indeed, the softembedding constraint imposes each successive itemset of a sequence to not contain some negated items. The strict-embedding constraint, which requires to evaluate a union of items, does not fit well to the linearity of LTLf formulas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions and perspectives</head><p>In this article, we investigated formal properties of the semantics of negation in sequential patterns to answer our two main questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">What is a proper support measure for negative sequential patterns?</head><p>We gave eight possible semantics and as many support measures. We can conclude that there is not a single way to evaluate the support of an NSP. 2. Is there a support measure enjoying anti-monotonicity? We run counter the state of the art by proposing three partial orders for which anti-monotonicity holds although only for some semantics of negative sequential pattern mining.</p><p>The combination of partial order ⊳ and containment relation D appears to be a good candidate for developping a complete, correct and non-redundant negative sequential pattern mining algorithm <ref type="bibr" target="#b7">[8]</ref>. One advantage of an approach based on an anti-monotonic support measure is the benefit from decades of research in pattern mining so as to extend the mining of NSP to the mining of closed NSP or the mining of NSP with maxgap or maxspan constraints.</p><p>Nonetheless, no semantics is "more correct" or relevant than another one. It depends on the notion to be captured. Our objective is to give the opportunity to make an educated choice. It is especially important with NSP as the choice of a mining algorithm is not only a matter of computational efficiency, but also a matter of semantics.</p><p>In view of Definition 4 and Lemma 3, three possibilities arise for evaluating a negative itemset (syntactically distinguished below by writing a negative itemset ¬(a 1 , . . . , a l i ) or ¬{a 1 , . . . , a l i } or ¬|a 1 , . . . , a l i |) as follows:</p><formula xml:id="formula_24">¬(a 1 , . . . , a l i ) is evaluated as {a 1 , . . . , a l i } G s j , ∀ j ∈ [e i + 1, e i+1 -1] for all i ∈ [m -1]</formula><p>Intuitively, you check that, in between s e i (i.e., a match for p i ) and s e i+1 (i.e., a match for p i+1 ), none of these s j include all of a 1 , . . . , a l i . ¬{a 1 , . . . , a l i } is evaluated as</p><formula xml:id="formula_25">{a 1 , . . . , a l i } G j∈[e i +1,e i+1 -1] s j for all i ∈ [m -1]</formula><p>Intuitively, you check that there exists some item in a 1 , . . . , a l i that does not occur at all in between s e i (i.e., a match for p i ) and s e i+1 (i.e., a match for p i+1 ).</p><formula xml:id="formula_26">¬|a 1 , . . . , a l i | is evaluated as {a 1 , . . . , a l i } D j∈[e i +1,e i+1 -1] s j for all i ∈ [m -1]</formula><p>Intuitively, you check that every item in a 1 , . . . , a l i fails to occur in between s e i (i.e. , a match for p i ) and s e i+1 (i.e., a match for p i+1 ). This opens the way for a syntax of negative sequential patterns that is even more expressive. Indeed, it enables to mix different types of negation within a pattern. For instance, we can specify patterns such as a ¬|bc| f ¬{ac} b (intuitively: none of b and c occur between a and f ; also, either a or c (or both) does not occur at all between f and b).</p><p>The first perspective of this work is to evaluate the proposed notations on a panel of real users. A preliminary survey concluded on a lack of any dominant interpretation of the ¬ symbol. We would like to confirm this preliminary result on a larger panel and to evaluate the benefit of having a dedicated syntax for each containment relation.</p><p>Our second perspective is to extend our theoretical results from the pattern recognition perspective. Matching sequential patterns in sequences is a fundamental issue in monitoring of discrete event systems, in genetic data analysis, in text analysis, etc. Adding negations to sequential patterns increases the expressivity of the pattern language. It raises questions about space and time complexity of the recognition and/or enumeration of negative sequential patterns: are the different containment relations equally hard to evaluate in sequences?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proofs</head><p>Proof of Lemma 1. Let P, I ⊆ I s.t. P D I. If P = ∅, by definition, P G I. Otherwise, because P is not empty, then there exists e ∈ P s.t. e I, i.e. P G I.</p><p>Proof of Lemma 2. Let e = (e i ) i∈[m] ∈ [n] m be a -embedding of a NSP p = p 1 ¬q 1 . . . ¬q m-1 p m in a sequence s = s 1 . . . s n . For all positive itemsets p i , the definition of -embedding matches the one for -embedding. For a negative itemset q i , let us start with G := * . By definition 4, q i G j∈[e i +1,e i+1 -1] s j , and by Definition 2, ∃α ∈ q i , α</p><p>j∈[e i +1,e i+1 -1] s j . And then, ∃α ∈ q i , ∀ j ∈ [e i + 1, e i+1 -1], α s j . That is ∀ j ∈ [e i + 1, e i+1 -1], ∃α ∈ q i , α s j . This shows ∀ j ∈ [e i + 1, e i+1 -1], q i G s j ( -embedding definition). It remains D := * . By definition 4, q i D j∈[e i +1,e i+1 -1] s j , and by Definition 2, ∀α ∈ p i , α</p><p>j∈[e i +1,e i+1 -1] s j . And then, ∀α ∈</p><formula xml:id="formula_27">q i , ∀ j ∈ [e i +1, e i+1 -1], α s j . That is ∀ j ∈ [e i +1, e i+1 -1], ∀α ∈ q i , α s j . This shows ∀ j ∈ [e i + 1, e i+1 -1], q i * s j .</formula><p>Proof of Lemma 3. Let s = s 1 . . . s n be a sequence and p = p 1 ¬q 1 . . . ¬q m-1 p m be a negative sequential pattern. Lemma 2 shows that -embedding implies -embedding. It remains the implication to the left. Let e = (e i ) i∈[m] ∈ [n] m be a -embedding of pattern p in sequence s. Then, the definition matches the one for -embedding for positives, p i . For negatives, q i , then ∀ j ∈ [e i +1, e i+1 -1], q i D s j , i.e. ∀ j ∈ [e i +1, e i+1 -1], ∀α ∈ q i , α s j and then ∀α ∈ q i , ∀ j ∈ [e i + 1, e i+1 -1], α s j . It thus implies that ∀α ∈ q i , α</p><p>j∈[e i +1,e i+1 -1] s j , i.e. by definition, q i D j∈[e i +1,e i+1 -1] s j .</p><p>Proof of Lemma 4. Let s = s 1 . . . s n be a sequence and p = p 1 ¬q 1 . . . ¬q m-1 p m be a NSP s.t. ∀i, |q i | ≤ 1. Due to Lemma 3, we only need to deal with the case that * is G . Let e = (e i ) i∈[m] ∈ [n] m be a -embedding of p in s then, by definition, 1) p i ⊆ s e i for all i ∈ [m] and 2) q i G s j for all j ∈ [e i + 1, e i+1 -1]. In case |q i | = 0, there is no constraint. In case |q i | = 1, then 2) becomes q i s j for all j ∈ [e i + 1, e i+1 -1]. Hence, q i j∈[e i +1,e i+1 -1] s j i.e. q i G j∈[e i +1,e i+1 -1] s j . As a consequence e is a -embedding of p.</p><p>Proof of Lemma 5. Let s = s 1 . . . s n be a sequence and p = p 1 ¬q 1 . . . ¬q m-1 p m ∈ N be a pattern. By definition 4, if e = (e i ) i∈[m] ∈ [n] m is an embedding of pattern p in sequence s then ∀i ∈ [m]: p i ⊆ s e i because p i is positive. The condition e i &lt; e i+1 in Definition 3 immediately follows from the requirement in Definition 4 that e be increasing with no repetition. It ensues that e is an embedding of the positive pattern p + .</p><p>Proof of Lemma 6. Let s = s 1 . . . s n be a sequence and p = p 1 ¬q 1 . . . ¬q m-1 p m ∈ N be a pattern s.t. p ⊑ * s. Then, there exists e an embedding of p + in s and, by definition, it is also an embedding of p in s. This means that p * s.</p><p>Proof of Lemma 7. Let s = s 1 . . . s n be a sequence and p = p 1 ¬q 1 . . . ¬q m-1 p m ∈ N be a pattern. We start by considering relations between semantics at the embedding level, and then we will conclude at the pattern level.</p><p>Let's first assume that is . Consider a ( , D)-embedding e = (e i ) i∈[m] of pattern p in sequence s. Hence, ∀i ∈ [m], p i ⊆ s e i and ∀i ∈ [m -1], ∀ j ∈ [e i + 1, e i+1 -1], q i D s j . According to eq. 1, we have q i G s j . It ensues that e is a ( , )-embedding.</p><p>Let's now assume that is . Let e = (e i ) i∈[m] be a ( , D)-embedding of pattern p in sequence s. Hence, ∀i ∈ [m], p i ⊆ s e i and ∀i ∈ [m -1], q i D j∈[e i +1,e i+1 -1] s j . In addition j∈[e i +1,e i+1 -1] s j ⊆ I, hence ∀i ∈ [m -1], q i G j∈[e i +1,e i+1 -1] s j according to eq. 1. It ensues that e is an ( , )-embedding.</p><p>Let's come back to the pattern level. Consider p D s, in the two cases ( ∈ { , ⊑}). In the first case the existing ( , D)-embedding is a ( , G)-embedding, and in the second case, all ( , D)-embeddings are ( , G)-embeddings. Therefore, we have that p G s.</p><p>Proof of Lemma 8. A pre-order is a reflexive, transitive binary relation. The reflexivity of the relation comes with Definition 6. Let θ, θ ′ , θ ′′ ∈ Θ be three dominance relations s.t. θ θ ′ and θ ′ θ ′′ . Then, for all p ∈ N and sequence s: pθs =⇒ pθ ′ s and pθ ′ s =⇒ pθ ′′ s. Hence, we have, pθs =⇒ pθ ′′ s, i.e. θ θ ′′ .</p><p>Proof of Lemma 9. Let θ, θ ′ ∈ Θ, by reflexivity of we have that ∼ is reflexive. By definition (θ θ ′ ∧ θ ′ θ), ∼ is symmetric. And , ∼ is also transitive. Let θ, θ ′ , θ ′′ ∈ Θ be three dominance relations s.t. θ ∼ θ ′ and θ ′ ∼ θ ′′ then, θ θ ′ , θ ′ θ ′′ , θ ′ θ and θ ′′ θ ′ . Hence, by transitivity of , θ θ ′′ and θ ′′ θ, θ ∼ θ ′′ .</p><p>Proof of Proposition 1. Let p ∈ N and s a sequence.</p><p>According to Lemma 6, p ⊑ * s =⇒ p * s. Thus we obtain Equality 3 by Definition 6.</p><p>According to Lemma 7, p D s =⇒ p G s. Thus we obtain Equality 6 by Definition 6.</p><p>According to Lemma 2, a -embedding is a -embedding whatever the itemset non-inclusion operator. Then, we get p * s =⇒ p * s. Lemma 2 holds for any -embedding, hence p ⊑ * s =⇒ p ⊑ * s. All this gives p * s =⇒ p * s (Equality 4).</p><p>In addition, Lemma 3 shows that a -embedding is a -embedding (and vice-versa) in case of total itemset non-inclusion. Then, we can conclude that p D s =⇒ p D s (Equality 5).</p><p>Let now gives some counterexamples for known non-dominance relationships. For each non-dominance relation, θ θ ′ , we provide counterexamples for some θ, θ ′ ∈ Θ, i.e. a pattern p and a sequence s such that pθs but not pθ ′ s.</p><p>• Equation ( <ref type="formula">7</ref> </p><formula xml:id="formula_28">p i = p ′ i , 2. ∀i ∈ [k -1], q i ⊆ q ′ i and 3. ∃ j ∈ [k -1] s.t. q i q ′ i . A particular case of 1. is that ∀i ∈ [k], p i ⊆ p ′ i .</formula><p>In addition, the third condition of ⊳ is obtained easily from 3. by adding a disjunctive condition. Hence, p ⊳ p ′ . We now prove the second implication: p ⊳ p ′ =⇒ p ⊳ • p ′ . Let p, p ′ ∈ N s.t. p ⊳ p ′ . Let's now define the sequence u i such that u i = i for all i ∈ [k]. By construction, we have that u i &lt; u i+1 , for all i ∈ [k -1] (see the increasingness requirement in the definition of ⊳ • ). In addition, by definition of ⊳, we have that ∀i ∈</p><formula xml:id="formula_29">[k], p i ⊆ p ′ i = p ′ u i , and ∀i ∈ [k -1], q i ⊆ q ′ i = j∈[i,(i+1)-1] q ′ j = j∈[u i ,u i+1 -1] q ′ j . Assuming k = k ′ , then p k p ′ k or ∃ j ∈ [k -1] s.t. q j q ′ j . If p k p ′ k the third condition of ⊳ • is satisfied (with j = k).</formula><p>Otherwise, it is also satisfied with the j of the definition of ⊳.</p><p>Note that the proof of the results of Table <ref type="table" target="#tab_5">2</ref> in the article is given at the end of this supplementary material.</p><p>Proof of Proposition 2. We first remind that ⊳ • is a strict partial order iff the three following conditions hold:</p><formula xml:id="formula_30">1. ∀p ∈ N, not p ⊳ • p (irreflexive), 2. ∀p, p ′ , p ′′ ∈ N, p ⊳ • p ′ and p ′ ⊳ • p ′′ =⇒ p ⊳ • p ′′ (transitivity), 3. ∀p, p ′ ∈ N, p ⊳ • p ′ =⇒ not p ′ ⊳ • p (antisymmetry)</formula><p>By Lemma 10, if ⊳ • is irreflexive and antisymmetric then so are ⊳ and ⊳ + . Hence, we only show that ⊳ • is a strict partial order and then show transitivity for ⊳ and ⊳ + .</p><p>We now prove that ⊳ • is a strict partial order. Irreflexivity. Let's assume that ∃p ∈ N s.t. p ⊳ • p. Then, identity is the only possibility for u, i.e. u i = i, for all i ∈ [k]. Then, the third condition implies that ∃ j ∈ [k -1] s.t. q j q j or p j p j , which is absurd.</p><formula xml:id="formula_31">Then ⊳ • is irreflexive. Transitivity. Let p, p ′ , p ′′ ∈ N s.t. p ⊳ • p ′ and p ′ ⊳ • p ′′ . We de- note by (u i ) i ∈ [k ′ ] k and (v i ) i ∈ [k ′′ ] k ′ the respective mapping, and we define (w i ) i ∈ [k ′′ ] [ k] such that w i = v u i for all i ∈ [k]. Then, for all i ∈ [k], p i ⊆ p ′ u i ⊆ p ′′ vu i = p ′′ w i ; q i ⊆ j∈[u i ,u i+1 -1] q ′ j = j∈[u i ,u i+1 -1]</formula><p>l∈[v j ,v j+1 -1] q ′′ l . The union of the q ′′ l in the intervals [v j , v j+1 -1] for j ∈ [u i , u i+1 -1] can be sum up as an union on the interval</p><formula xml:id="formula_32">[v u i , v (u i+1 -1)+1 -1] = [v u i , v u i+1 -1] = [w i , w i+1 -1] be- cause intervals are contiguous. Then, q i ⊆ j∈[w i ,w i+1 -1] q ′′ j . Finally, if k = k ′′ , then k = k ′′ = k ′</formula><p>and then it exists j ∈ [k], s.t. p j p ′ j ⊆ p ′′ j or q j q ′ j ⊆ q ′′ j . Thus, p j p ′′ j or q j q ′′ j . As a consequence, we have p ⊳ • p ′′ . Antisymmetry. Let p, p ′ ∈ N s.t. p ⊳ • p ′ . Then, if k &lt; k ′ we can not have p ′ ⊳ • p. Assuming that k = k ′ (and thus u i = i for all i ∈ [k]), we have that there exists j ∈ [k] s.t. p j p ′ j or q j q ′ j . If p j p ′ j then, according to 1. p j p ′ j , hence p ′ j ⊆ p j fails. If q j q ′ j , then, according to 2. q j j∈[u i ,u i+1 -1] q ′ j = q ′ j . Thus, it is not possible to have q ′ j ⊆ q j = j∈[u i ,u i+1 -1] q j . As a consequence, we can not have p ′ ⊳ • p.</p><p>We now turn to ⊳.</p><formula xml:id="formula_33">Transitivity. Let p, p ′ , p ′′ ∈ N s.t. p ⊳ p ′ and p ′ ⊳ p ′′ . Then, for all i ∈ [k], p i ⊆ p ′ i ⊆ p ′′ i and for all i ∈ [k -1], q i ⊆ q ′ i ⊆ q ′′ i (k ≤ k ′ ≤ k ′′ ). Finally, if k = k ′′ , then k = k ′′ = k ′ . Assuming that p k = p ′ k and p ′ k = p ′′ k then p k = p ′′ k ′′ . Assuming that p k p ′ k or p ′ k p ′′ k , then ∃ j ∈ [k -<label>1</label></formula><p>] s.t. q j q ′ j or q ′ j q ′′ j , and hence q j q ′′ j . Then, we have that p ⊳ p ′′ . We finish with ⊳ + .</p><p>Transitivity. Let p, p ′ , p ′′ ∈ N s.t. p ⊳ + p ′ and p ′ ⊳ + p ′′ . Then, for all</p><formula xml:id="formula_34">i ∈ [k], p i = p ′ i = p ′′ i and for all i ∈ [k -1], q i ⊆ q ′ i ⊆ q ′′ i (k = k ′ = k ′′ ). Finally, it is not possible to have q i = q ′′ i for all i ∈ [k-1].</formula><p>In fact, these equalities would entail q i = q ′ i and q ′ i = q ′′ i for all i ∈ [k -1] because q i ⊆ q ′ i ⊆ q ′′ i . But having all these further equalities is not possible according to 3. Therefore, we have that p ⊳ + p ′′ .</p><p>Proof of Proposition 3. We start this proof by a small result about the anti-monotonicity of D . Let P, Q ∈ I be two itemsets s.t. P ⊆ Q, and I ∈ I another itemset. Then, Q D I =⇒ P D I. In fact, Q D I implies that for all e ∈ Q, e I, and because P ⊆ Q, we also have that e ∈ P, e I.</p><p>Let p = p 1 ¬q 1 . . . ¬q m-1 p m ∈ N and p ′ = p ′ 1 ¬q ′ 1 . . . ¬q ′ m ′ -1 p ′ m ′ ∈ N be two NSPs s.t. p ⊳ p ′ . We first show that an ( , D)-embedding of p ′ in a sequence s, denoted e = (e i ) i∈[m ′ ] , induces an ( , D)-embedding of p. By Definition 4, we have p ′ i ⊆ s e i , ∀i ∈ [m ′ ] and q ′ i D s j , for all j ∈ [e i +1, e i+1 -1] and for all i ∈ [m ′ -1]. On the other hand, p ⊳ p ′ implies that p i ⊆ p ′ i for all i ∈ [m]. Then, because m ≤ m ′ (p ⊳ p ′ ), we have that p i ⊆ s e i for all i ∈ [m]. In addition, p ⊳ p ′ also implies that q i ⊆ q ′ i for all i ∈ [m -1] and thus, by anti-monotonicity of D (and q ′ i D s j ), we have q i D s j for all j ∈ [e i + 1, e i+1 -1] and for all i ∈ [m -1]. In conclusion, we have that e = (e i ) i∈[m] is an ( , D)-embedding of p.</p><p>We now show that an ( , D)-embedding of p ′ in a sequence s, denoted e = (e i ) i∈[m ′ ] , induces an ( , D)-embedding of p. By Definition 4, we have p</p><formula xml:id="formula_35">′ i ⊆ s e i , ∀i ∈ [m ′ ] and q ′ i D j∈[e i +1,e i+1 -1] s j , for all i ∈ [m ′ -1]. However, p ⊳ p ′ implies that p i ⊆ p ′ i for all i ∈ [m].</formula><p>Then, because m ≤ m ′ (p ⊳ p ′ ), we have that p i ⊆ s e i for all i ∈ [m]. In addition, p⊳ p ′ also implies that q i ⊆ q ′ i for all i ∈ [m-1], by anti-monotonicity of D , we have q ′ i D</p><p>j∈[e i +1,e i+1 -1]  Similarly to the proof of Proposition 3, we can show that any ( , D)-embedding of p ′ in s induces an ( , D)-embedding of p in s. This enables to conclude that D is anti-monotonic on (N, ⊳ + ).</p><p>The anti-monotonicity of ⊑ D requires that each embedding of p + in s satisfies the negations. Let us assume that p ′ ⊑ D s, then there exists an embedding (e i ) i∈[k] of p ′ . (e i ) i∈ <ref type="bibr">[k]</ref> is also an embedding of p ′+ (Lemma 5). According to 1. in Definition 8 and because k = k ′ , p ′+ = p + , and then (e i ) i∈ <ref type="bibr">[k]</ref> is an embedding of p + in s. Thus, we have shown that there is at least one embedding of p + in s. If ⊑ D is not anti-monotonic, then there exists an embedding (e i ) i∈ <ref type="bibr">[k]</ref> of p + such that for some j ∈ [k] and l ∈ [e j + 1, e j+1 -1], it is false that q j D s l (∃α ∈ q j , α s l ). According to 2. in Definition 8, q j ⊆ q ′ j , and thus it is false q ′ j D s l . However, (e i ) i∈ <ref type="bibr">[k]</ref> is also an embedding of p ′+ . Since p ′ ⊑ D s, it follows that q ′ j D s l . There is a contradiction, thus ⊑ D is anti-monotonic.</p><p>The anti-monotonicity of ⊑ D requires that each embedding of p + in s satisfies the negations. Let us assume that p ′ ⊑ D s, then there exists an embedding (e i ) i∈[k] of p ′ . (e i ) i∈ <ref type="bibr">[k]</ref> is also an embedding of p ′+ (Lemma 5). According to 1. in Definition 8, and because k = k ′ , p ′+ = p + , and then (e i ) i∈ <ref type="bibr">[k]</ref> is an embedding of p + in s. Thus, we have shown that there is at least one embedding of p + in s. If ⊑ D is not antimonotonic, then there exists an embedding (e i ) i∈ <ref type="bibr">[k]</ref> of p + such that for some j ∈ [k], it is false that q j D l∈[e j +1,e j+1 -1] s l . According to 2. in Definition 8, q j ⊆ q ′ j , and thus it is false q ′ j D</p><p>l∈[e j +1,e j+1 -1] s l . Nonetheless, (e i ) i∈ <ref type="bibr">[k]</ref> is also an embedding of p ′+ . And p ′ ⊑ D s, it implies that q ′ j D</p><p>l∈[e j +1,e j+1 -1] s l . There is a contradiction, thus ⊑ D is anti-monotonic.</p><p>Proof of Proposition 5. Let θ, θ ′ ∈ Θ, then θ θ ′ =⇒ supp θ (p) ≤ supp θ ′ (p) for all p ∈ N (by Definition 6 of the dominance relation). Thus, Proposition 5 comes immediately with Proposition 1.</p><p>Proof of Proposition 6. Let p, p ′ ∈ N be two negative sequential patterns such that p ⊳ p ′ . According to Proposition 3, p ′ D s =⇒ p D s for all s. Thus, supp D, , (p ′ ) ≤ supp D, , (p).</p><p>If p ⊳ + p ′ . According to Proposition 4, p ′ D s =⇒ p D s for all s. Thus, supp D, , (p ′ ) ≤ supp D, , (p).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Additional dominance results</head><p>Table <ref type="table">3</ref> below illustrates the dominance and non-dominance relations that are given in Proposition 1. In this section, we use transitivity of the dominance relation to complete the table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Transitive dominance relation</head><p>Let θ θ ′ and θ ′ θ ′′ then, by transitivity, we have θ ′ θ ′′ • θ = (D, , ⊑), θ ′ = (G, , ⊑) and θ ′′ = (G, , ⊑). θ θ ′ is obtained by ( <ref type="formula">5</ref>) and θ ′ θ ′′ is obtained by <ref type="bibr" target="#b6">(7)</ref>. • ... In Table <ref type="table">3</ref>, we deduce that the x cell is when we have the following scheme (or symmetrical schemes): a square with a diagonal of and a diagonal with x and a cell in the diagonal of the matrix.</p><p>. . . x . . . . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• . . .</head><p>Table <ref type="table">4</ref> illustrates the dominance that can be deduced from the Proposition 1. Table <ref type="table">5</ref> contains additional dominance relations deduced by second order transitivity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Transitive non-dominance relation</head><p>Lemma 11. Let θ, θ ′ and θ ′′ s.t. θ θ ′ and θ θ ′′ then θ ′ θ ′′ Proof. By absurd, suppose θ ′ θ ′′ thus, by transitivity, θ θ ′′ that is not possible.</p><p>In Table <ref type="table">3</ref>, we deduce that the x cell is when we have the following scheme (or symmetrical schemes): a square with a diagonal of and x; and a diagonal with and a cell in the diagonal of the matrix.</p><p>. . . . . . . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• . . . x</head><p>Table <ref type="table">6</ref> illustrates the non dominance relations that can be deduced from previously deduced dominance and non-dominance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. On the left, a synthetic dataset of six sequences. On the right, a set of rules with their support and accuracy in the dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 3 (</head><label>3</label><figDesc>Strong vs weak occurrence semantics). Let p = a b ¬c d be a pattern, s 1 = a b e d and s 2 = a b c a d e b d be two sequences. Thus, p + = a b d occurs once in s 1 hence there is no difference for occurrences of p in s 1 under the two semantics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Dominance between containment relations. The labels for edges refer to the corresponding equations in Proposition 1. Dominance goes from top to bottom i.e. ⊑ D as well as ⊑ D dominate all other containment relations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Proposition 3 .</head><label>3</label><figDesc>D and D are anti-monotonic on (N, ⊳). Proposition 3 shows that using the ⊳ partial order causes antimonotonicity to hold for containment with weak-occurrence. It is not the case with strong-occurrence, though. Let us give a counterexample illustrating what can happen with strong-occurrence. Let p = a ¬b c , p ′ = a ¬b c d and s = a c d a b c . Then, we have p ⊳ p ′ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Proposition 4 .</head><label>4</label><figDesc>D , D , ⊑ D and ⊑ D are anti-monotonic on (N, ⊳ + ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Definition 10 (</head><label>10</label><figDesc>Pattern supports). Let D = {s i } i∈[n] be a dataset of sequences and p be an NSP. The support of p in D, denoted suppθ D (p), is the number of sequences of D in which p occurs according to the θ ∈ Θ containment relation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>): θ = (G, , ), θ ′ = (D, , ): Let p = a ¬(bc) d , s = a b d , then pθs but not pθ ′ s. • Equation (8): θ = ( * , , ), θ ′ = ( * , , ⊑): Let p = a ¬b c , s = a c b c , then pθs but not pθ ′ s. • Equation (9): θ = (G, , ), θ ′ = (G, , ): Let p = a ¬(bc) d , s = a b c d , then pθs but not pθ ′ s. • Equation (10): θ = (G, , ), θ ′ = (G, , ⊑): Let p = a ¬(bc) d , s = a b d c d , then pθs but not pθ ′ s. The strict embedding works for one embedding of the positive partner, but there is a positive partner embedding for which even the soft-embedding. • Equation (11): θ = (G, , ⊑), θ ′ = (G, , ): Let p = a ¬(bc) d , s = a b c d , then pθs but not pθ ′ s. • Equation (12): θ = ( * , , ), θ ′ = ( * ′ , , ⊑): Let p = a ¬b c , s = a c b c , then pθs but not pθ ′ s. Redundant with (8) when * ′ = * . • Equation (13): θ = (D, , ), θ ′ = (G, , ⊑): Let p = a ¬b c , s = a c b c , then pθs but not pθ ′ s. • Equation (14): θ = (G, , ⊑), θ ′ = (D, , ): Let p = a ¬(bc) d , s = a b d , then pθs but not pθ ′ s. Proof of Lemma 10. We start with the implication p ⊳ + p ′ =⇒ p ⊳ p ′ . Let p, p ′ ∈ N s.t. p ⊳ + p ′ . By definition, k = k ′ and 1. ∀i ∈ [k],</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>s j , for all i ∈ [m ′ -1]. In conclusion, we have that e = (e i ) i∈[m] is an ( , D)-embedding of p. Proof of Proposition 4. Let p = p 1 ¬q 1 . . . ¬q k-1 p k ∈ N and p ′ = p ′ 1 ¬q ′ 1 . . . ¬q ′ k ′ -1 p ′ k ′ ∈ N be two NSP s.t. p ⊳ + p ′ . Thus, we have that k = k ′ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 .</head><label>1</label><figDesc>Lists of sequences in D supported by negative patterns ( p i ) i=1..<ref type="bibr" target="#b3">4</ref> </figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Definition 3 (Positive pattern embedding). Let s = s 1 . . . s n be a sequence and p = p 1 . . . p m be a (positive) sequential pattern. A tuple e = (e i ) i∈[m] ∈ [n] m is an embedding of pattern p in sequence s iff ∀i ∈ [m], p i ⊆ s e i and e i &lt; e i+1 for all i ∈ [m -1].Definition 4 (Strict and soft embeddings of negative patterns). Let s = s 1 . . . s n be a sequence and p = p 1 ¬q 1 . . . ¬q m-1 p m be a negative sequential pattern.</figDesc><table><row><cell>An increasing 4 tuple e = (e i ) i∈[m] ∈ [n] m is a -embedding (read:</cell></row><row><cell>soft-embedding) of pattern p in sequence s iff:</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 .</head><label>2</label><figDesc>Dominance. (resp. -) means that the semantics at the left of the row dominates (resp. does not dominate) the semantics at the top of the column.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0"><p>All proofs can be found in the appendix of this article.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>By an increasing tuple e, we mean a tuple such that e i &lt; e i+1 (in particular, repetitions are not allowed).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_2"><p>In sequential pattern mining, it is called a backward-extension of the patterns.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_3"><p><ref type="bibr" target="#b5">6</ref> We remind that, by Definition 1, p i ∅ and that we never have two successive negative itemsets in an NSP.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>In this case, we do not have p ⊳ p ′ nor p ⊳ + p ′</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>In this case, we also have p ⊳ • p ′ (seeLemma 10)  but not p ⊳ + p ′</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_6"><p>Completeness and non-redundancy of algorithms are out of the scope of this article.</p></note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>(G, , )</p><p>•</p><p>(G, , ⊑)</p><p>•</p><p>(G, , )</p><p>•</p><p>(D, , ⊑)</p><p>•</p><p>(D, , )</p><p>•</p><p>(D, , ⊑)</p><p>•</p><p>(D, , )</p><p>•    </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fast Algorithms for Mining Association Rules in Large Databases</title>
		<author>
			<persName><forename type="first">Rakesh</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ramakrishnan</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Very Large Data Bases (VLDB)</title>
		<meeting>the International Conference on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="487" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Stable reasoning</title>
		<author>
			<persName><forename type="first">Pedro</forename><surname>Cabalar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Agustín</forename><surname>Valverde</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Applied Non-Classical Logics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="238" to="254" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">e-NSP: Efficient negative sequential pattern mining</title>
		<author>
			<persName><forename type="first">Longbing</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangjun</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhigang</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">235</biblScope>
			<biblScope unit="page" from="156" to="182" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Nonoccurring behavior analytics: A new area</title>
		<author>
			<persName><forename type="first">Longbing</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vipin</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intelligent Systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="4" to="11" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Discovering time-interval sequential patterns in sequence databases</title>
		<author>
			<persName><forename type="first">Yen-Liang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mei-Ching</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming-Tat</forename><surname>Ko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Expert System with Applications</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="343" to="354" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Linear temporal logic and linear dynamic logic on finite traces</title>
		<author>
			<persName><forename type="first">Giuseppe</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giacomo</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>the International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">e-NSPFI: Efficient mining negative sequential pattern from both frequent and infrequent positive sequential patterns</title>
		<author>
			<persName><forename type="first">Yongshun</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tiantian</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangjun</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohua</forename><surname>Lv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. Journal of Pattern Recognition and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">02</biblScope>
			<biblScope unit="page">1750002</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">NegPSpan: efficient extraction of negative sequential patterns with embedding constraints</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Guyet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">René</forename><surname>Quiniou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Mining and Knowledge Discovery</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="563" to="609" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mining negative sequential patterns for e-commerce recommendations</title>
		<author>
			<persName><forename type="first">Sue-Chen</forename><surname>Hsueh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ming-Yen</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chien-Liang</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Asia-Pacific Services Computing Conference</title>
		<meeting>of Asia-Pacific Services Computing Conference</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1213" to="1218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A database perspective on knowledge discovery</title>
		<author>
			<persName><forename type="first">Tomasz</forename><surname>Imielinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Heikki</forename><surname>Mannila</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="58" to="64" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Sequential pattern miningapproaches and algorithms</title>
		<author>
			<persName><forename type="first">Carl</forename><forename type="middle">H</forename><surname>Mooney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">F</forename><surname>Roddick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Survey</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="39" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Negative sequence analysis: A review</title>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Longbing</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Survey</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="32" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Negation</title>
		<author>
			<persName><forename type="first">Heinrich</forename><surname>Wansing</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>John Wiley &amp; Sons, Ltd</publisher>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="415" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">E-msNSP: Efficient negative sequential patterns mining based on multiple minimum supports</title>
		<author>
			<persName><forename type="first">Tiantian</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangjun</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianliang</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yongshun</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. Journal of Pattern Recognition and Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">02</biblScope>
			<biblScope unit="page">1750003</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Negative-GSP: An efficient method for mining negative sequential patterns</title>
		<author>
			<persName><forename type="first">Zhigang</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanchang</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ziye</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Longbing</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Australasian Data Mining Conference</title>
		<meeting>of the Australasian Data Mining Conference</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="63" to="67" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
