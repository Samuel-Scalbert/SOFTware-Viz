<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bounded Treewidth and the Infinite Core Chase Complications and Workarounds toward Decidable Querying</title>
				<funder ref="#_75C6S47">
					<orgName type="full">European Research Council</orgName>
				</funder>
				<funder ref="#_395rhe3">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
							<email>jfbaget@inria.frmugnier@lirmm.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
							<email>sebastian.rudolph@tu-dresden.de</email>
							<affiliation key="aff1">
								<orgName type="laboratory">Computational Logic Group</orgName>
								<orgName type="institution">TU Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Bounded Treewidth and the Infinite Core Chase Complications and Workarounds toward Decidable Querying</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C98BFEA407E06BADD465374513DC78A5</idno>
					<idno type="DOI">10.1145/3584372.3588659</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>existential rules</term>
					<term>tuple-generating dependencies</term>
					<term>chase</term>
					<term>treewidth</term>
					<term>universal models</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The core chase, a popular algorithm for answering conjunctive queries (CQs) over existential rules, is guaranteed to terminate and compute a finite universal model whenever one exists, leading to the equivalence of the universal-model-based and the chase-based definitions of finite expansion sets (fes) -a class of rulesets featuring decidable CQ entailment. In case of non-termination, however, it is non-trivial to define a "result" of the core chase, due to its non-monotonicity. This causes complications when dealing with advanced decidability criteria based on the existence of (universal) models of finite treewidth. For these, sufficient chase-based conditions have only been established for weaker, monotonic chase variants.</p><p>This paper investigates the -prima facie plausible -hypothesis that the existence of a treewidth-bounded universal model and the existence of a treewidth-bounded core-chase sequence coincidewhich would conveniently entail decidable CQ entailment whenever the latter holds. Perhaps surprisingly, carefully crafted examples show that both directions of this hypothesized correspondence fail. On a positive note, we are still able to define an aggregation scheme for the infinite core chase that preserves treewidth bounds and produces a finitely universal model, i.e., one that satisfies exactly the entailed CQs. This allows us to prove that the existence of a treewidth-bounded core-chase sequence does warrant decidability of CQ entailment (yet, on other grounds than expected). Hence, for the first time, we are able to define a chase-based notion of bounded treewidth sets of rules that subsumes fes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS CONCEPTS</head><p>‚Ä¢ Theory of computation ‚Üí Automated reasoning; ‚Ä¢ Computing methodologies ‚Üí Knowledge representation and reasoning.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The chase is a fundamental tool for the popular formalism of existential rules, also known as tuple-generating dependencies. Given a knowledge base (KB) composed of a finite set ùêπ of facts (the database) and a set Œ£ of (existential) rules, the chase repeatedly applies rules, giving rise to a sequence ùêπ =ùêπ 0 , ùêπ 1 , ùêπ 2 , . . . If, in the course of this, a fixpoint is reached after a finite number of steps, one speaks of chase termination. Then, the final fact set obtained, seen as a structure, constitutes a finite model of the given KB, which is also universal, meaning that it can be homomorphically mapped to any model of the KB. This pleasant property allows one to consider this single model (instead of all models) to answer all queries preserved under homomorphisms, ranging from conjunctive queries (CQs) to datalog and other second-order queries.</p><p>In fact, there are different chase variants with differing behavior regarding redundancy treatment and termination. The simplest, most lavish, known as the oblivious chase, performs all possible rule applications, without checking for any redundancies <ref type="bibr" target="#b5">[6]</ref>. The most frugal, known as the core chase, prunes all redundancies at each step, retaining a minimal set of atoms, which is called a core <ref type="bibr" target="#b8">[9]</ref>. Between these two extremes, the semi-oblivious (aka skolem) and restricted (aka standard) chase avoid the creation of some redundancies, but not all <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b16">17]</ref>. The core chase is the only chase variant that terminates exactly when the KB has a finite universal model, and produces the unique (up to isomorphism) smallest such model. Thus, the core chase is the best choice for a decision procedure that aims at chase termination. This motivates the definition of the fes (finite expansion sets) class containing all rule sets Œ£ for which the core chase for K = (ùêπ, Œ£) terminates for all ùêπ <ref type="bibr" target="#b2">[3]</ref>. For such Œ£, the entailment K |= ùëÑ for any CQ ùëÑ can be decided by computing the core chase and evaluating ùëÑ against the resulting structure.</p><p>Yet, finite universal models may not exist. In such cases, no chase reaches a fixpoint, and there is no last chase sequence element to pick as a result. As a remedy, one may define the "result" of the chase as the infinite union over all the fact sets of the infinite sequence, obtaining an infinite structure. This will still yield a universal model for monotonic chase variants, where ùêπ ùëñ ‚äÜ ùêπ ùëñ+1 holds for all ùëñ, such te rm in at in g cc = fin ite un iv er sa l m od el tw -b ou nd ed rc tw -f in ite un iv er sa l m od el inflating elevator tw -b ou nd ed cc tw-finite finitely universal model steepening staircase Figure <ref type="figure">1</ref>: Venn diagram displaying the (non-)inclusion of decidable classes of existential rule sets discussed in the paper. We abbreviate treewidth by tw, and restricted and core chase by rc and cc, respectively. The rulesets entitled "steepening staircase" and "inflating elevator" demonstrate that existence of treewidth-finite universal models and treewidth-bounded core-chase sequences are independent properties. The tw-bounded cc class actually comes in two flavors, referred to as uniform and recurring boundedness. The latter is more general, but the distinction is irrelevant for this overview.</p><p>as the oblivious, semi-oblivious and restricted chases. However, this does not work well for non-monotonic chase variants such as the core chase, where one cannot even be certain to obtain a model.</p><p>One could argue that these issues are of theoretical interest only, given that the non-terminating chase cannot actually be computed and cannot serve as a decision procedure. However, fortunately, decidability of CQ entailment can be established by other means, even when the chase does not terminate. In particular, it is ensured whenever an infinite universal model exists that is still reasonably "structurally well-behaved" by virtue of having a bounded treewidth <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7]</ref>. This insight gave rise to many existential rule fragments of high practical relevance, mostly based on varying notions of guardedness, which impose syntactic restrictions ensuring treewidthboundedness for all chase sequences <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b15">16</ref>]. Yet, these classes all have in common that the existence of a treewidth-bounded universal model can be established only via chase variants that are necessarily monotonic: the union over all ùêπ ùëñ in a monotonic chase sequence is known to inherit the treewidth bound. Regrettably, for the core chase, which produces "smaller" intermediate structures and hence ensures treewidth-boundedness of the produced facts more often, no adequate model-producing "aggregation" strategy is known, let alone a treewidth-preserving one.</p><p>To overcome this issue, we provide a decidability guarantee, but also bring some unpleasant truths to light. We propose a treewidthpreserving aggregation scheme for the core chase that produces a model, but not a universal one. Luckily, we can still guarantee that the resulting model is finitely universal (that is, any of its finite substructures is universal) and thus sufficient for our purpose of decidable CQ entailment. Also, we show that the failure to construct a treewidth-bounded universal model out of a treewidth-bounded chase sequence is not a flaw of our approach, but unavoidable, by exhibiting the steepening staircase example: a uniformly treewidthbounded core-chase sequence for a KB whose every universal model has infinite treewidth. Conversely, the inflating elevator example presents a KB with a universal model of finite treewidth, yet each of its core-chase sequences consists of structures of ever-growing treewidth, refuting the plausible hypothesis that any universal model of bounded treewidth can be obtained from a treewidthbounded core-chase sequence. Figure <ref type="figure">1</ref> summarizes our findings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>We use countably infinite disjoint sets Œî ùëâ of variables (denoted by uppercase letters) and Œî ùê∂ of constants (denoted by lowercase letters). A schema S is a finite set of relation symbols (or predicates); each p ‚àà S is given an arity ar (p) ‚â• 0. The set of terms is</p><formula xml:id="formula_0">Œî ùëá = Œî ùê∂ ‚à™ Œî ùëâ . A list ùë° 1 , . . . , ùë° ùëò of terms is also denoted by √¨ ùë° with | √¨ ùë° | = ùëò.</formula><p>Atomsets and Homomorphisms. An atom over a schema S is an expression of the form p( √¨ ùë°), p ‚àà S and √¨ ùë° ‚àà (Œî ùëá ) ùëò with ùëò = ar (p). An atomset over S is a countable set of atoms over S. For an atom or atomset ùê¥, we let terms(ùê¥) and vars(ùê¥) denote the set of terms and variables in ùê¥, respectively.</p><p>A substitution of a set of variables Y ‚äÜ Œî ùëâ is a mapping ùúé from Y to Œî ùëá . For an atom at = p(ùë° 1 , . . . , ùë° ùëò ) and a substitution ùúé of Y, let ùúé (at) = p(ùúé + (ùë° 1 ), . . . , ùúé + (ùë° ùëò )) where ùúé + (ùë° ùëñ ) = ùúé (ùë° ùëñ ) whenever ùë° ùëñ ‚àà Y and ùúé + (ùë° ùëñ ) = ùë° ùëñ otherwise. If ùê¥ is an atomset, then ùúé (ùê¥) = {ùúé (at) | at ‚àà ùê¥}. For two substitutions ùúé and ùúé ‚Ä≤ of variable sets Y and Y ‚Ä≤ , respectively, we let ùúé ‚Ä≤ ‚Ä¢ ùúé denote the substitution of Y ‚Ä≤ ‚à™ Y defined by ùëå ‚Ü¶ ‚Üí ùúé ‚Ä≤+ (ùúé + (ùëå )). Two substitutions are compatible if they map the same variables to the same terms.</p><p>A homomorphism from an atomset ùê¥ to an atomset ùêµ is a substitution ùúã with ùúã (ùê¥) ‚äÜ ùêµ. Given such a homomorphism ùúã, we also say that ùúã maps ùê¥ to ùêµ, or that ùê¥ maps to ùêµ (via ùúã). An isomorphism from ùê¥ to ùêµ is a bijective homomorphism ùúã such that ùúã -<ref type="foot" target="#foot_0">1</ref> is a homomorphism from ùêµ to ùê¥ (then ùê¥ and ùêµ are called isomorphic). An endomorphism (automorphism) of ùê¥ is a homomorphism (isomorphism) from ùê¥ to itself. A retraction of ùê¥ is an endomorphism ùúã where the restriction of ùúã to terms(ùúã (ùê¥)) (the retract) is the identity. Note that the classes of homomorphisms, endomorphisms, isomorphisms, and retractions are all closed under composition. A finite atomset ùê¥ is called a core if every retraction of ùê¥ is the identity. Any finite atomset ùê¥ admits a retract that is a core; this retract is unique up to isomorphism and called the core of ùê¥.</p><p>We identify an atomset with the (possibly infinite) formula obtained from the existential closure of the conjunction of its atoms. Finite or infinite atomsets also naturally correspond to first-order interpretations; 1 if we want to emphasize this aspect, we also refer to them as instances. A (Boolean) conjunctive query (CQ) is a finite atomset. Note that we conflate labeled nulls usually used in instances with variables usually used in queries, as they correspond to the same logical notion. We rely on the standard notions of model and semantic entailment, denoted by |=. An instance ùêº is a model of a (possibly infinite) atomset ùê¥ iff ùê¥ maps to ùêº ; for ùê¥ and ùêµ two (possibly infinite) atomsets, ùê¥ |= ùêµ iff ùêµ maps to ùê¥.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Existential</head><p>Rules. An (existential) rule ùëÖ is of the form ùêµ ‚Üí ùêª , where the body ùêµ = body(ùëÖ) and the head ùêª = head (ùëÖ) are nonempty finite atomsets. The variables in ùêµ are called universal, those both in ùêµ and ùêª are called frontier, and those only in ùêª are called existential. We identify a rule with the first-order sentence</p><formula xml:id="formula_1">‚àÄ √¨ ùëã √¨ ùëå. ùêµ [ √¨ ùëã, √¨ ùëå ] ‚Üí ‚àÉ √¨ ùëç. ùêª [ √¨ ùëã, √¨ ùëç ]</formula><p>where √¨ ùëã, √¨ ùëå, √¨ ùëç are the frontier, nonfrontier universal, and existential variables of ùëÖ, respectively. In examples, we use the logical notation but omit universal quantifiers.</p><p>Given an instance ùêº and a rule ùêµ ‚Üí ùêª , a trigger for ùêº is a pair tr = (ùêµ ‚Üí ùêª, ùúã) such that ùúã maps ùêµ to ùêº ; tr is satisfied in ùêº if ùúã can be extended to a homomorphism from ùêµ ‚à™ ùêª to ùêº . Note that an instance ùêº is a model of a rule ùëÖ iff it satisfies every trigger for ùêº of the form (ùëÖ, ùúã). Given a rule ùëÖ = ùêµ ‚Üí ùêª , an instance ùêº and a trigger tr = (ùëÖ, ùúã) for ùêº , the application of tr on ùêº produces the instance ùõº (ùêº, tr) = ùêº ‚à™ ùúã safe (ùêª ), where ùúã safe maps every frontier-variable ùëã of ùëÖ to ùúã (ùëã ) and any existential variable in vars(ùêª ) to a fresh variable (usually called a labeled null). <ref type="foot" target="#foot_1">2</ref>Universal Models. A knowledge base (KB) is a pair K = (ùêπ, Œ£), where ùêπ is a finite instance and Œ£ is a finite set of rules. An instance ùêº is a model of K if it is a model of ùêπ and of each rule in Œ£. An instance ùêº is universal for K if it (homomorphically) maps to every model of K; note that this does not necessarily mean that ùêº is a model of K. An instance ùêº is a universal model of K if it is a model of K and is universal for K. We consider the following CQ entailment problem: given a KB K and a Boolean CQ ùëÑ, does K |= ùëÑ hold? For any universal model ùêº of K, K |= ùëÑ holds iff ùëÑ (homomorphically) maps to ùêº , hence, a universal model of K is sufficient to decide CQ entailment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DERIVATIONS AND THEIR RESULTS</head><p>In this paper, we focus on the restricted and the core chase variants. We now introduce a convenient notion of derivation to define these two variants. Actually, it would allow to define other variants that fall between these two variants in terms of redundancy removal, like e.g., the frugal chase <ref type="bibr" target="#b14">[15]</ref>. Our type of derivation is not only a sequence of rule applications, but also incorporates a retraction that removes (some) redundancies after each rule application. In the following, ‚Ñë denotes either the set N of natural integers (for infinite derivations) or the interval {0, . . . , ùëò } ‚äÜ N (for finite ones). Definition 1 (Derivation). A derivation from a KB K = (ùêπ, Œ£) is a (possibly infinite) sequence D = ((tr ùëñ , ùúé ùëñ , ùêπ ùëñ )) ùëñ ‚àà‚Ñë , where the tr ùëñ are triggers (except tr 0 = ‚àÖ), the ùúé ùëñ are retractions called simplifications, and the ùêπ ùëñ are finite instances such that: ùêπ 0 = ùúé 0 (ùêπ ); and, for all ùëñ ‚àà ‚Ñë\{0}, ùêπ ùëñ = ùúé ùëñ (ùõº (ùêπ ùëñ -1 , tr ùëñ )), where tr ùëñ = (ùëÖ ùëñ , ùúã ùëñ ) with ùëÖ ùëñ ‚àà Œ£ is a trigger for ùêπ ùëñ -1 not satisfied in ùêπ ùëñ -1 .</p><p>For the sake of brevity, we often denote a derivation simply by D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë , leaving the tr ùëñ and ùúé ùëñ implicit. A derivation is called monotonic if ùêπ ùëñ -1 ‚äÜ ùêπ ùëñ holds for all ùëñ ‚àà ‚Ñë\{0}. In a monotonic derivation, the restriction of ùúé ùëñ to the terms of ùêπ ùëñ -1 is the identity.</p><p>When a derivation D = (ùêπ ùëñ ) 0‚â§ùëñ ‚â§ùëò is finite, its result can be defined by just taking its last instance: D + = ùêπ ùëò . However, for infinite derivations of the form D = (ùêπ ùëñ ) ùëñ ‚ààN , the "result" of D is usually defined as the (infinite) union of all instances along D. We denote this union by D * = ùëñ ‚àà‚Ñë ùêπ ùëñ and call it the natural aggregation of D (to distinguish it from the robust aggregation defined in Section 8). Note that if D is a finite monotonic derivation, then D * = D + .</p><p>As stated in the next proposition, D * is universal for K. Yet, to ensure that a model of K is obtained, we need to require fairness, which intuitively means that every trigger for some ùêπ ùëñ has to be satisfied in some ùêπ ùëó with ùëó ‚â• ùëñ. To formalize this notion, a difficulty with our derivation notion (which arises for any non-monotonic type of chase) is that a trigger (ùëÖ, ùúã) for some ùêπ ùëñ may not remain a trigger for some ùêπ ùëó with ùëó &gt; ùëñ: this is because ùúã (body(R)) may be "transformed away" by successive simplifications. To address this issue, we need to "trace" how a set of atoms is transformed along a derivation. Definition 2. Let D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë be a derivation, and ùëã be a variable occurring in some ùêπ ùëñ . For any ùëó ‚àà ‚Ñë with ùëó ‚â• ùëñ, we define œÉùëñ</p><formula xml:id="formula_2">ùëñ (ùëã ) = ùëã and œÉ ùëó ùëñ (ùëã ) = ùúé ùëó ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ùúé ùëñ+1 (ùëã ) when ùëó &gt; ùëñ.</formula><p>It is immediate that œÉ ùëó ùëñ (which is either the identity when ùëñ = ùëó or ùúé ùëó ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ùúé ùëñ+1 otherwise) is a homomorphism from ùêπ ùëñ to ùêπ ùëó . Note also that for a monotonic derivation, œÉ ùëó ùëñ is the identity for any ùëó. In the following, if tr = (ùëÖ, ùúã) is a trigger for ùê¥ and ùúé is a substitution, we note ùúé (tr) = (ùëÖ, ùúé ‚Ä¢ ùúã) the trigger for ùúé (ùê¥).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3 (Fair derivation).</head><p>A derivation D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë is fair if, for any ùëñ ‚àà ‚Ñë and trigger tr for ùêπ ùëñ , there is some ùëó ‚àà ‚Ñë with ùëó ‚â• ùëñ, such that œÉ ùëó ùëñ (tr) is a satisfied trigger for ùêπ ùëó .</p><p>In classical chase procedures, only active triggers (a notion specific to each chase variant) are applied. In the restricted chase, a trigger for ùêπ ùëñ is active if it is not already satisfied in ùêπ ùëñ . The core chase furthermore computes a retraction to a core after each (or a finite number of) rule application. For both variants, the classical definition of a chase sequence coincides with our notion of a fair derivation. A restricted chase sequence can be seen as a fair derivation ((tr ùëñ , ùúé ùëñ , ùêπ ùëñ )) ùëñ ‚àà‚Ñë in which ùúé ùëñ is the identity. Since this derivation is monotonic, it allows for a simpler expression of fairness: any trigger for an ùêπ ùëñ has to be satisfied in some ùêπ ùëó , with ùëñ ‚â§ ùëó. A core chase sequence can be seen as a (non-monotonic) fair derivation in which each ùúé ùëñ produces a core.</p><p>Finally, we adapt to our general framework some well-known properties of these chase variants <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b13">14]</ref>. Albeit D * is not always a model, modelhood is guaranteed for monotonic derivations, as already known for the restricted chase. Proposition 1. Let D be a derivation from K. Then: (1) D * is universal for K;</p><p>(2) if D is monotonic and fair, D * is a model of K;</p><p>(3) if D is fair, for all CQ ùëÑ, K |= ùëÑ iff D * |= ùëÑ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ADDING TREEWIDTH TO THE PICTURE</head><p>We now recall the popular notion of the treewidth of an atomset as well as some well-known facts about it, which will be useful later. Definition 4. Given an atomset ùê¥, a tree decomposition of ùê¥ is a (possibly infinite) tree ùëá = (ùëâ, ùê∏), with vertices ùëâ ‚äÜ 2 terms (ùê¥) and edges ùê∏ ‚àà ùëâ √ó ùëâ , where:</p><p>‚Ä¢ for each at ‚àà ùê¥ exists some ùë£ ‚àà ùëâ with terms(at) ‚äÜ ùë£;</p><p>‚Ä¢ for each ùë° ‚àà terms(ùê¥), letting ùëâ ùë° = {ùë£ ‚àà ùëâ | ùë° ‚àà ùë£ }, the subgraph of ùëá induced by ùëâ ùë° is connected. The width of ùëá = (ùëâ , ùê∏) is the size of its largest vertex, minus 1. The treewidth of an atomset ùê¥, denoted by ùë°ùë§ (ùê¥), is the minimal width among all its tree decompositions.</p><p>Fact 1. ùê¥ ‚äÜ ùêµ implies tw(ùê¥) ‚â§ tw(ùêµ).</p><p>Definition 5. Given a natural number ùëõ, we say that an atomset ùê¥ contains an ùëõ √ó ùëõ-grid, if terms(ùê¥) contains ùëõ 2 distinct terms, denoted ùë° ùëñ ùëó for ùëñ, ùëó ‚àà {1, . . . , ùëõ}, such that for all ùëò ‚àà {1, . . . , ùëõ -1} and ‚Ñì ‚àà {1, . . . , ùëõ}:</p><p>‚Ä¢ there is some at ‚àà ùê¥ with {ùë° ùëò ‚Ñì , ùë° ùëò+1 ‚Ñì } ‚äÜ terms(at), and</p><formula xml:id="formula_3">‚Ä¢ there is some at ‚Ä≤ ‚àà ùê¥ with {ùë° ‚Ñì ùëò , ùë° ‚Ñì ùëò+1 } ‚äÜ terms(at ‚Ä≤ ). Fact 2. If ùê¥ contains an ùëõ √ó ùëõ-grid then tw(ùê¥) ‚â• ùëõ.</formula><p>Treewidth is an important notion in the context of existential rules, as the existence of universal models with finite treewidth implies decidability of CQ entailment <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>. In fact, many concrete and practically relevant classes of existential rule sets enjoy this property. One generic way to guarantee the existence of such models is by imposing conditions on the corresponding derivations. This approach underlies all definitions of so-called bounded treewidth sets of rules from the literature, but there is a certain disagreement and diversity as to certain details and the type of chase employed (cf. Footnote 4). Here, we will provide the most general such definition that is known to guarantee finite-treewidth universal models along the lines of previously established proofs. Definition 6. A ruleset Œ£ is called a bounded treewidth set (bts) if for any finite instance ùêπ , there exist some ùëè ‚àà N and a restricted chase sequence (ùêπ ùëñ ) ùëñ ‚àà‚Ñë such that tw(ùêπ ùëñ ) ‚â§ ùëè for all ùëñ ‚àà ‚Ñë. Proposition 2. CQ entailment for bts is decidable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CORE CHASE &amp; STRUCTURAL MEASURES</head><p>In what follows, we will use the term structural measure to generically denote any function ùúá that maps instances to elements of N ‚à™ {‚àû}. An easy example would be the size of an instance defined by size :</p><formula xml:id="formula_4">ùêº ‚Ü¶ ‚Üí |ùêº |. An instance ùêº is then called ùúá-finite, if ùúá (ùêº ) ‚â† ‚àû.</formula><p>Moreover, we say that a sequence (ùêπ ùëñ ) ùëñ ‚àà‚Ñë of atomsets is uniformly ùúábounded, if there exists some ùëò ‚àà N such that ùúá (ùêπ ùëñ ) ‚â§ ùëò for all ùëñ ‚àà ‚Ñë. (ùêπ ùëñ ) ùëñ ‚àà‚Ñë will be called recurringly ùúá-bounded if there exists some ùëò ‚àà N such that for any ùëó ‚àà ‚Ñë there exists some ùëñ ‚â• ùëó from ‚Ñë for which ùúá (ùêπ ùëñ ) ‚â§ ùëò holds. It is easy to see that uniform ùúá-boundedness implies recurring ùúá-boundedness, but not vice versa.</p><p>Since -on an intuitive level -universal models can be seen as "limits" of appropriate chase sequences, it is a natural question to ask to what extent this limit process preserves structural measures. More specifically, one may ask oneself, given a particular type of chase and structural measure ùúá, if the existence of a (uniformly or recurringly) ùúá-bounded chase sequence for a KB is a necessary and/or sufficient condition for the existence of a ùúá-finite universal model. As mentioned before, for the structural measure of size, this question can be answered positively: A knowledge base K has a (size-)finite universal model iff it has a size-bounded core chase sequence <ref type="bibr" target="#b8">[9]</ref>.</p><p>Turning to the structural measure of treewidth, however, we found that, surprisingly, both directions fail, witnessed by counterexamples for either direction: The "steepening staircase" KB (Section 6) allows for a (even uniformly) treewidth-bounded chase sequence while lacking a treewidth-finite universal model, whereas the "inflating elevator" KB (Section 7) has a universal model of finite treewidth while not exhibiting a (even just recurringly) treewidthbounded core-chase sequence.</p><p>Irrespective of the fact that our presentation focuses on treewidth as the arguably most prominent structural measure, it should be noted that our counterexamples are based on grid structures and therefore also immediately work for other measures, such as cliquewidth <ref type="bibr" target="#b10">[11]</ref> or (generalized) hypertreewidth <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">THE STEEPENING STAIRCASE</head><p>For the KB below, the core chase sequence is uniformly treewidthbounded by 2, but none of its universal models has finite treewidth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7 (The Steepening Staircase KB). We let</head><formula xml:id="formula_5">K h = (ùêπ h , Œ£ h ) where Œ£ h = {ùëÖ h 1 , ùëÖ h 2 , ùëÖ h 3 , ùëÖ h 4 }</formula><p>, as given in Figure <ref type="figure">2</ref>. We now describe the instance ùêº h , which is a universal model of K h that we can obtain via both the restricted and the core chase. Definition 8. We define ùêº h as the infinite instance using the terms terms</p><formula xml:id="formula_6">(ùêº h ) = {ùëã ùëñ ùëó | (ùëñ, ùëó) ‚àà N 2 , ùëñ + 1 ‚â• ùëó } and consisting of the atoms f(ùëã ùëñ 0 ) c(ùëã ùëñ ùëó ) for ùëñ ‚â• ùëó ‚â• 1 h(ùëã ùëñ ùëó , ùëã ùëñ+1 ùëó ) h(ùëã ùëñ ùëó , ùëã ùëñ ùëó ) for ùëñ ‚â§ ùëó . v(ùëã ùëñ ùëó , ùëã ùëñ ùëó+1 )</formula><p>The instance ùêº h is depicted in Figure <ref type="figure">2</ref>; the names ùëã ùëñ ùëó of the variables of ùêº h are in correspondence to their cartesian coordinates (ùëñ, ùëó) in the picture. We now consider some particular subsets of terms(ùêº h ). For any ùëò ‚àà N, let ùëÉ ùëò = {ùëã ùëñ ùëó } ùëñ ‚â§ùëò , ùê∂ ùëò = {ùëã ùëò ùëó } ùëó ‚â§ùëò , and , and so on. The infinite union of all atomsets along this derivation is</p><formula xml:id="formula_7">ùëÜ ùëò = ùê∂ ùëò ‚à™ ùê∂ ùëò+1 ‚à™ {ùëã ùëò ùëò+1 }. Let ùëÉ h ùëò (resp. ùê∂ h ùëò , ùëÜ h ùëò )</formula><formula xml:id="formula_8">D * r = ùêº h . Proposition 3. ùêº h is a result of the restricted chase on K h . h(ùëã , ùëã ) ‚Üí ‚àÉùëã ‚Ä≤ ùëåùëå ‚Ä≤ .h(ùëã , ùëå ) ‚àß v(ùëã , ùëã ‚Ä≤ ) ‚àß h(ùëã ‚Ä≤ , ùëå ‚Ä≤ ) ‚àß v(ùëå , ùëå ‚Ä≤ ) ‚àß c(ùëå ‚Ä≤ ) (ùëÖ h 1 ) h(ùëã , ùëã ) ‚àß v(ùëã , ùëã ‚Ä≤ ) ‚àß h(ùëã ‚Ä≤ , ùëã ‚Ä≤ ) ‚àß h(ùëã ‚Ä≤ , ùëå ‚Ä≤ ) ‚Üí ‚àÉùëå .c(ùëå ‚Ä≤ ) ‚àß h(ùëã , ùëå ) ‚àß v(ùëå , ùëå ‚Ä≤ ) (ùëÖ h 2 ) f(ùëã ) ‚àß h(ùëã , ùëã ) ‚àß h(ùëã , ùëå ) ‚Üí f(ùëå ) ‚àß h(ùëå , ùëå ) (ùëÖ h 3 ) h(ùëã , ùëã ) ‚àß v(ùëã , ùëã ‚Ä≤ ) ‚àß c(ùëã ‚Ä≤ ) ‚Üí h(ùëã ‚Ä≤ , ùëã ‚Ä≤ ) (ùëÖ h 4 ) {f(ùëã 0 0 ), h(ùëã 0 0 , ùëã 0 0 ) } (ùêπ h ) ùêπ h ùëÖ h 1 ùëÖ h 2 ùëÖ h 3 ùëÖ h 4 [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] ùêº h ƒ® h [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] [√ó]</formula><p>Figure <ref type="figure">2</ref>: Left: rules of Œ£ h , fact set ùêπ h , and a graphical representation thereof. Orange (grey) elements represent the rule body, black elements the rule head. Visualization of atoms: denotes h ("horizontal") and denotes v ("vertical"); we write [√ó] for c ("ceiling") and</p><p>[√ó] for f ("floor"). Right: Atomset ùêº h from Definition 8 -an infinite universal model of K h . Atomset ƒ® h at the very right is infinite model of K h , which is not universal but satisfies exactly the same CQs.</p><p>Sketch of proof. The derivation D r given above is a restricted chase sequence. Clearly, no ùõº (ùêπ, ùëÖ, ùúã) in D r retracts to ùêπ, so it remains to check that D r is fair. Indeed, if (ùëÖ, ùúã) is a trigger for some ùêπ ùëñ , then it is a trigger wrt some ùëÖ h ùëò that is necessarily satisfied</p><formula xml:id="formula_9">(at most in ùëÉ h ùëò+2 ). Thus (ùëÖ, ùúã) is satisfied in some ùêπ ùëó ‚äá ùëÉ h ùëò+2 . ‚ñ°</formula><p>As a result of the restricted chase, ùêº h is a universal model of K h . Now, we point out that for any ùëò, ùê∂ h ùëò+1 is a retract of ùëÜ h ùëò that is a core. Then we can use D r to build a derivation D c that relies upon those retractions. D c starts out like D r , but as soon as ùëÜ h 0 is obtained, we retract it to its core ùê∂ h 1 . Then, following D r 's course, D c proceeds to build ùëÜ h 1 that retracts to its core ùê∂ h 2 . . . As for D r , we note that D c is fair. Moreover, each retraction to a core is done a finite number of rule applications after the previous one: D c is thus a core chase sequence. Finally, we point out that every atomset in D c is a subset of some ùëÜ h ùëò , and has thus treewidth at most 2. Proposition 4. There is a core chase sequence for K h that is uniformly treewidth-bounded by 2.</p><p>However, all the core computations done in D c with the goal of producing a "leaner" result turn out to be futile when it comes to the aggregation: D * c = D * r = ùêº h contains an ùëõ √óùëõ grid for any ùëõ, and has thus unbounded treewidth. The next proposition even shows that K h admits no universal model of finite treewidth. For instance, the atomset ƒ® h pictured in Figure <ref type="figure">2</ref> is a model of K h but it is not universal: it does not map to ùêº h , since it features an infinite v-path, while all v-paths contained in ùêº h are of finite length. Proposition 5. No universal model of K h has finite treewidth. Sketch of proof. Any universal model ùëà of K h is homomorphically equivalent to ùêº h . This allows to show that, for any ùëõ ‚â• 1, ùëà contains an ùëõ √ó ùëõ-grid, hence tw(ùëà ) ‚â• ùëõ. ‚ñ°</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">THE INFLATING ELEVATOR</head><p>We now present a knowledge base K v which does have a universal model with a treewidth of 1, while any (fair) core chase sequence for K v contains atomsets whose associated treewidths grow monotonically beyond any given bound.</p><p>Definition 9 (The Inflating Elevator KB). We let</p><formula xml:id="formula_10">K v = (ùêπ v , Œ£ v ) where Œ£ v = {ùëÖ v 1 , ùëÖ v 2 , ùëÖ v 3 , ùëÖ v 4 , ùëÖ v 5 , ùëÖ v 6 , ùëÖ v 7</formula><p>} and ùêπ v are as given in the upper part of Figure <ref type="figure">3</ref>.</p><p>We describe an atomset (shown on the left in Figure <ref type="figure" target="#fig_0">4</ref>) representing a universal model that can be obtained via the natural aggregation over the restricted chase or a core chase. We use the same naming convention for nulls as before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10. Let terms(ùêº</head><formula xml:id="formula_11">h ) = {ùëã ùëñ ùëó | (ùëñ, ùëó) ‚àà N, ùëñ -1 ‚â§ ùëó ‚â§ 2ùëñ}.</formula><p>Then ùêº v consists of the following atoms for all ùëñ, ùëó where all mentioned nulls are in terms(ùêº v ):</p><formula xml:id="formula_12">d(ùëã ùëñ ùëó ) f(ùëã ùëñ ùëó ) c(ùëã ùëñ 2ùëñ ) h(ùëã ùëñ ùëó , ùëã ùëñ+1 ùëó ) h(ùëã ùëñ 2ùëñ , ùëã ùëñ+1 2ùëñ+1 ) h(ùëã ùëñ 2ùëñ , ùëã ùëñ+1 2ùëñ+2 ) v(ùëã ùëñ ùëó , ùëã ùëñ ùëó+1 ) v(ùëã ùëñ ùëó , ùëã ùëñ ùëó ) for ùëñ ‚â§ ùëó Proposition 6. ùêº v is a result of the restricted chase on K v .</formula><p>Sketch of proof. The claim can be shown inductively by assuming that rules without existential variables are prioritized and new nulls are created according to the following scheme:</p><p>‚Ä¢ for every ùëñ ‚â• 1, ùëã ùëñ 2ùëñ -1 and ùëã ùëñ 2ùëñ are introduced as instances of ùëå ‚Ä≤ and ùëå ‚Ä≤‚Ä≤ through an application of Rule</p><formula xml:id="formula_13">ùëÖ v 1 with ùëã ‚Ü¶ ‚Üí ùëã ùëñ -1 2ùëñ -2 and ùëå ‚Ü¶ ‚Üí ùëã ùëñ 2ùëñ -2 . ‚Ä¢ for every ùëñ ‚â• 1, ùëã ùëñ+1 ùëñ is introduced as instance of ùëå ‚Ä≤ through an application of Rule ùëÖ v 2 with ùëã ‚Ü¶ ‚Üí ùëã ùëñ ùëñ -1 and ùëã ‚Ä≤ ‚Ü¶ ‚Üí ùëã ùëñ ùëñ . ‚Ä¢ every remaining ùëã ùëñ ùëó ‚àà terms(ùêº v ) with ùëñ ‚â• 1 is introduced as instance of ùëå ‚Ä≤ through an application of Rule ùëÖ v 3 with ùëã ‚Ü¶ ‚Üí ùëã ùëñ -1 ùëó -1 , ùëã ‚Ä≤ ‚Ü¶ ‚Üí ùëã ùëñ -1</formula><p>ùëó , and ùëå ‚Ü¶ ‚Üí ùëã ùëñ ùëó -1 . Fairness follows from the fact that ùêº v satisfies all its triggers, as can be checked easily. ‚ñ°</p><p>As a result of the restricted chase, ùêº v is a universal model of K v . As it turns out, it even contains another universal model of finite</p><formula xml:id="formula_14">{c(ùëã 0 0 ), d(ùëã 0 0 ), h(ùëã 0 0 , ùëã 1 0 ), f(ùëã 1 0 ) } (ùêπ v ) c(ùëã ) ‚àß h(ùëã , ùëå ) ‚Üí ‚àÉùëå ‚Ä≤ ùëå ‚Ä≤‚Ä≤ .v(ùëå , ùëå ‚Ä≤ ) ‚àß v(ùëå ‚Ä≤ , ùëå ‚Ä≤‚Ä≤ ) ‚àß c(ùëå ‚Ä≤‚Ä≤ ) (ùëÖ v 1 ) v(ùëã , ùëã ‚Ä≤ ) ‚àß h(ùëã , ùëå ) ‚Üí ‚àÉùëå ‚Ä≤ .v(ùëå , ùëå ‚Ä≤ ) ‚àß h(ùëã ‚Ä≤ , ùëå ‚Ä≤ ) (ùëÖ v 3 ) d(ùëã ) ‚àß f(ùëã ) ‚àß v(ùëã , ùëã ‚Ä≤ ) ‚Üí ‚àÉùëå ‚Ä≤ .h(ùëã ‚Ä≤ , ùëå ‚Ä≤ ) ‚àß f(ùëå ‚Ä≤ ) (ùëÖ v 2 ) c(ùëã ) ‚Üí d(ùëã ) (ùëÖ v 4 ) v(ùëã , ùëã ‚Ä≤ ) ‚àß d(ùëã ‚Ä≤ ) ‚Üí d(ùëã ) (ùëÖ v 5 ) h(ùëã , ùëå ) ‚àß d(ùëå ) ‚àß f(ùëå ) ‚Üí f(ùëã ) ‚àß v(ùëã , ùëã ) (ùëÖ v 6 ) c(ùëã ) ‚àß h(ùëã , ùëå ) ‚àß v(ùëå , ùëå ‚Ä≤ ) ‚àß f(ùëå ‚Ä≤ ) ‚Üí h(ùëã , ùëå ‚Ä≤ ) (ùëÖ v 7 ) ùêπ v ùëÖ v 1 ùëÖ v 2 ùëÖ v 3 ùëÖ v 4 ùëÖ v 5 ùëÖ v 6 ùëÖ v 7 A [√ó] [√ó] [√ó] [√ó] [√ó] [√ó] A [√ó] [√ó] [√ó] [√ó] A [√ó] [√ó] [√ó] A [√ó] A [√ó] [√ó] A [√ó] [√ó] A [√ó] [√ó] [√ó]</formula><p>Figure <ref type="figure">3</ref>: ùêπ v and rules of Œ£ v (top) and their graphical depictions (bottom). Orange (grey) elements represent the rule body and black elements the rule head. Atoms are encoded as follows: denotes h ("horizontal") and denotes v ("vertical"); we write</p><p>[√ó] for c ("ceiling"),</p><p>[√ó] for f ("floor"), and</p><p>[√ó] for d ("done"). treewidth. This second universal model ùêº v * , also shown in Figure <ref type="figure" target="#fig_0">4</ref>, is given in the next definition. Definition 11. We define the atomset ùêº v * as the set of those atoms from ùêº v only containing variables of the form ùëã ùëñ 2ùëñ .</p><formula xml:id="formula_15">ùêº v ùêº v * ùêº v 1 ùêº v 2 ùêº v 3 ùêº v 4 ùêº v 5</formula><formula xml:id="formula_16">Proposition 7. ùêº v * is a universal model of K v .</formula><p>Proof. ùêº v * is a model of K v : it receives a homomorphism from ùêπ v and satisfies all rules from Œ£ v . It is universal, since the identity is a homomorphism from ùêº v * to ùêº v which is itself a universal model. ‚ñ°</p><p>This implies that no finite universal model of K v can exist (as any such model would receive a homomorphism from ùêº v * and thus contain a h-cycle, thus not be homomorphically equivalent to ùêº v * ). We next describe a sequence ùêº v 0 , ùêº v 1 , . . . of subsets of ùêº v that exhibit increasing treewidths and will later be shown to occur as substructures in any core chase sequence of K v . Figure <ref type="figure" target="#fig_0">4</ref> depicts the first elements of that sequence. Definition 12. We define the sequence (ùêº v ùëõ ) ùëõ‚ààN of atomsets by letting ùêº v 0 = ùêπ v and, for any ùëõ &gt; 0, obtaining ùêº v ùëõ as the substructure of (3) For every core chase sequence (ùêπ ùëñ ) ùëñ ‚ààN for K v , there is an unbounded monotonic function ùëì : N ‚Üí N such that, for every ùëõ ‚àà N, ùêº v ùëì (ùëõ) is isomorphic to a subset of ùêπ ùëõ . (4) For every core chase sequence (ùêπ ùëñ ) ùëñ ‚ààN for K v and any ùëö ‚àà N exists a ùëò ‚àà N such that tw(ùêπ ùëñ ) ‚â• ùëö for all ùëñ ‚â• ùëò.</p><formula xml:id="formula_17">ùêº v induced by terms(ùêº v ùëõ ) = {ùëã ùëñ 2ùëñ | ùëñ ‚â§ ùëõ 2 } ‚à™ {ùëã ùëñ ùëó | ùëñ ‚â§ ùëõ+1</formula><p>From these technical insights, we obtain the strong guarantee regarding the growth of the treewidth: Corollary 1. No core chase sequence for K v is recurringly or uniformly treewidth-bounded.</p><p>Recall that the steepening staircase example demonstrates that a bounded-treewidth chase sequence does not warrant the existence of a universal model of finite treewidth. This blocks the traditional approach for showing decidability of CQ entailment. However, we are still able to establish this desired result by other means, as demonstrated in the course of the next two sections.</p><p>More specifically, we show that CQ entailment is decidable for the class of KBs having a recurringly treewidth-bounded core chase sequence (forthcoming Theorem 2). To do so, we go through the following steps. Firstly, we resort to a weaker notion than universality, namely finite universality (Definition 13). We show that finitely universal models can play the same role as universal models when it comes to CQ entailment (Proposition 9). Secondly, we define a novel way to compute the result of a derivation, namely the robust aggregation of a derivation, and show that the robust aggregation of any fair derivation is a finitely universal model (Proposition 11). Finally, in Section 9, we show that the robust aggregation of a derivation having recurringly bounded treewidth has finite treewidth (Proposition 12), and conclude by adapting Courcelle's theorem to show that CQ entailment is decidable for KBs admitting a finitely universal model of finite treewidth (Theorem 1). In the following, we detail the employed notions and arguments laid out above. Definition 13 (Finite universality). An atomset ùêº is finitely universal for K if each finite subset of ùêº is universal for K. Defining Robust Aggregations. For non-monotonic derivations D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë , it may happen that an atom at is in some ùêπ ùëñ , but "disappears" at some later step ùëó. Yet, at will still belong to the natural aggregation D * . Intuitively, the natural aggregation generates atomsets that are "too big" (this is why they may not be models). We thus introduce a new type of aggregation, called robust aggregation, that, instead of merely combining all atomsets ùêπ ùëñ along the derivation, combines their collapsed versions obtained via preemptive applications of future simplifications ùúé ùëó along the derivation. Defining this result is not immediate, however, since a variable could be indefinitely re-mapped through simplifications along a derivation. Observe that, in the staircase example, the core chase maps ùëã 0 0 to ùëã 1 0 , then ùëã 1 0 to ùëã 2 0 , etc., and there is no way we can define the ultimate image of ùëã 0 0 unless we can force the simplification to stabilize at some point. This is the goal of the robust renaming, for which we assume a bijection rank of the variables X with N, and use the total ordering &lt; X on X defined by ùëã &lt; X ùëå iff rank(ùëã ) &lt; rank(ùëå ). Definition 14 (Robust renaming). Let ùê¥ be an atomset and let ùúé be a retraction of ùê¥. The robust renaming associated with ùúé is the substitution ùúå ùúé of vars(ùúé (ùê¥)) that maps any variable ùëã of ùúé (ùê¥) to the &lt; X -smallest variable of ùúé -1 (ùëã ). We let It is immediate that ùúå ùúé is an isomorphism from ùúé (ùê¥) to ùúè ùúé (ùê¥), and, for any variable ùëã in ùê¥, ùúè ùúé (ùëã ) is a constant or ùúå ùúé (ùëã ) ‚â§ X ùëã . Let us now inductively apply those robust renamings along a derivation. Definition 15 (Robust seqence). Let D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë be a derivation. The robust sequence associated with D is the sequence of atomsets (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë defined inductively by (see Figure <ref type="figure" target="#fig_2">5</ref> for induction step):</p><formula xml:id="formula_18">ùúè ùúé = ùúå ùúé ‚Ä¢ ùúé. ùê¥ ùëñ -1 ùêπ ùëñ -1 ùê¥ ùëñ ùêπ ùëñ ùê∫ ùëñ -1 ùê∫ ùëñ ùê¥ ‚Ä≤ ùëñ ùêπ ‚Ä≤ ùëñ ùúå ùëñ -1 ùúå ùëñ ùúé ùëñ -1 ùúé ùëñ ùúå ùëñ -1 ùúå ùëñ -1 ùúé ‚Ä≤ ùëñ ùúå ùúé ‚Ä≤ ùëñ ùúè ùëñ ùúè ùëñ homomorphism isomorphism rule application</formula><p>‚Ä¢ With ùê¥ 0 = ùêπ , ùêπ 0 = ùúé 0 (ùê¥ 0 ), and ùúå 0 = ùúå ùúé 0 , we define ùê∫ 0 = ùúå 0 (ùêπ 0 );</p><formula xml:id="formula_19">‚Ä¢ ‚àÄùëñ ‚àà ‚Ñë with ùëñ &gt; 0, if ùêπ ùëñ -1 = ùúé ùëñ -1 (ùê¥ ùëñ -1 ), ùê¥ ùëñ = ùõº (ùêπ ùëñ -1 , tr), ùêπ ùëñ =</formula><p>ùúé ùëñ (ùê¥ ùëñ ) and ùê∫ ùëñ -1 = ùúå ùëñ -1 (ùêπ ùëñ -1 ) (ùêπ ùëñ -1 and ùê∫ ùëñ -1 being isomorphic), we build ùê∫ ùëñ and an isomorphism ùúå ùëñ from ùêπ ùëñ to ùê∫ ùëñ as follows:</p><formula xml:id="formula_20">-let ùê¥ ‚Ä≤ ùëñ = ùúå ùëñ -1 (ùê¥ ùëñ ) (see that ùê¥ ‚Ä≤ ùëñ = ùõº (ùê∫ ùëñ -1 , ùúå ùëñ -1 (tr)))</formula><p>, with the same fresh variables as in ùõº (ùêπ ùëñ -1 , tr)) and</p><formula xml:id="formula_21">ùêπ ‚Ä≤ ùëñ = ùúå ùëñ -1 (ùêπ ùëñ ); -then ùúé ‚Ä≤ ùëñ = ùúå ùëñ -1 ‚Ä¢ ùúé ùëñ ‚Ä¢ ùúå -1 ùëñ -1 is a retraction such that ùúé ‚Ä≤ ùëñ (ùê¥ ‚Ä≤ ùëñ ) = ùêπ ‚Ä≤ ùëñ ; -we define ùê∫ ùëñ = ùúå ùúé ‚Ä≤ ùëñ (ùêπ ‚Ä≤ ùëñ ), with ùúå ùúé ‚Ä≤ ùëñ the robust renaming associated with ùúé ‚Ä≤ ùëñ and ùúå ùëñ = ùúå ùúé ‚Ä≤ ùëñ ‚Ä¢ ùúå ùëñ -1 an isomorphism from ùêπ ùëñ to ùê∫ ùëñ ; -furthermore, we denote by ùúè ùëñ = ùúè ùúé ‚Ä≤ ùëñ = ùúå ùúé ‚Ä≤ ùëñ ‚Ä¢ùúé ‚Ä≤ ùëñ the homomorphism from ùê¥ ‚Ä≤</formula><p>ùëñ to ùê∫ ùëñ . See that ùúè ùëñ also maps ùê∫ ùëñ -1 ‚äÜ ùê¥ ‚Ä≤ ùëñ to ùê∫ ùëñ . Note that (ùê∫ ùëñ ) is not a derivation, since the ùúè ùëñ from ùê¥ ‚Ä≤ ùëñ to ùê∫ ùëñ are not endomorphisms. However, every ùê∫ ùëñ is isomorphic to ùêπ ùëñ , and we show that variables are finitely renamed along this sequence. Proposition 10. Let (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë be an associated robust sequence. For ùëñ, ùëó ‚àà ‚Ñë with ùëñ &lt; ùëó, let œÑ ùëó ùëñ = ùúè ùëó ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ùúè ùëñ+1 denote the composition of all ùúè ‚Ñì between ùê∫ ùëñ and ùê∫ ùëó . Then, for any ùëã ‚àà vars(ùê∫ ùëñ ), there is ùëó ‚àà ‚Ñë with ùëó &gt; ùëñ such that œÑ ùëó ùëñ (ùëã ) = ùëå ‚àà terms(ùê∫ ùëó ) and for all ùëò ‚àà ‚Ñë with ùëò &gt; ùëó, œÑùëò ùëó (ùëå ) = ùëå (i.e., ùëå is stable from ùê∫ ùëó on). We let œÑ (ùëã ) = ùëå . Proof. Let ùëã ‚àà vars(ùê∫ ùëñ ), then ùúè ùëñ+1 (ùëã ) = ùúè ùúé ‚Ä≤ ùëñ+1 (ùëã ) ‚â§ X ùëã. Consider some arbitrary ùëó ‚àà ‚Ñë with ùëó &gt; ùëñ. Among the homomorphisms ùúè ‚Ñì that œÑ ùëó ùëñ is composed of, there can be at most rank X (ùëã ) many of them that are effectively decreasing (causing œÑ‚Ñì-1</p><formula xml:id="formula_22">ùëñ (ùëã ) &lt; X œÑ‚Ñì ùëñ (ùëã )). ‚ñ°</formula><p>We now use the œÑ (ùê∫ ùëñ ) to define the robust aggregation. Note that, contrary to (ùêπ ùëñ ) or (ùê∫ ùëñ ), the sequence ( œÑ (ùê∫ ùëñ )) is monotonic. Definition 16 (Robust aggregation). Given a derivation D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë and its associated robust sequence (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë , the robust aggregation of D is the (possibly infinite) atomset D ‚äõ = ùëñ ‚àà‚Ñë œÑ (ùê∫ ùëñ ).</p><p>Semantic Properties of Robust Aggregations. The steepening staircase shows that the robust aggregation of a derivation is not always universal. Indeed, consider the KB K h (from Definition 7) and let &lt; X be an order on the variables with ùëó &lt; ùëò ‚áí ùëã ùëñ ùëó &lt; X ùëã ùëñ ùëò . The core chase on K h begins building the first step ùëÜ h 0 of ùêº h , and all simplifications are the identity until done. Now, the first proper retraction maps ùëã 0 0 to ùëã 1 0 and ùëã 0 1 to ùëã 1 1 , so the robust renaming generates ùê∫ ùëñ 1 , which is isomorphic to the column ùê∂ h 1 , but its variables are named (from bottom to top) ùëã 0 0 and ùëã 0 1 . Likewise, from successive proper retraction steps, we obtain ùê∫ ùëñ ùëó isomorphic to ùê∂ h ùëó but with variables named ùëã 0 0 , ùëã 0 1 , ùëã 1 2 , . . . , ùëã ùëó ùëó+1 . Note that œÑ (ùê∫ ùëñ ùëó ) = ùê∫ ùëñ ùëó holds: every variable is stable since subsequent re-mappings would have to be within the same row, yet all variables therein are &lt; X -greater. Then, the robust aggregation D ‚äõ is isomorphic to the infinite column ƒ® h , with variables named ùëã 0 0 , ùëã 0 1 , ùëã 1 2 , . . . , ùëã ùëó ùëó+1 , . . . , which is not universal, but is a finitely universal model, as stated below. Proposition 11. Let D be a derivation from K. Then (1) D ‚äõ is finitely universal for K; and (2) if D is fair, D ‚äõ is a model of K.</p><p>To prove this proposition, we rely on the next lemma, which states that any finite part of D ‚äõ is "stably present" from a certain element on in the robust sequence associated with D.</p><p>Lemma 1. Let D be a derivation and let (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë be the robust sequence associated with D. For any finite subset ùê¥ of D ‚äõ , there is some ùëò ‚àà ‚Ñë such that ùê¥ ‚äÜ ùê∫ ùëü for every ùëü ‚àà ‚Ñë with ùëü ‚â• ùëò. Sketch of proof. See that (i) the œÑ (ùê∫ ùëñ ) form a monotonic sequence and then, thanks to Proposition 10, that (ii) for every œÑ (ùê∫ ùëñ ), there exists ùëò ‚àà ‚Ñë such that œÑ (ùê∫ ùëñ ) ‚äÜ ùê∫ ùëü for every ùëü ‚â• ùëò. Thanks to (i), there is some ùëñ with ùê¥ ‚äÜ œÑ (ùê∫ ùëñ ) and we conclude with (ii). ‚ñ°</p><p>Proof of Proposition 11.</p><p>(1) Let ùëÄ be an arbitrary model of K, and let ùêº be be any finite subset of D ‚äõ . By Lemma 1, there is some ùëò such that ùêº ‚äÜ ùê∫ ùëò . Now ùê∫ ùëò is isomorphic to ùêπ ùëò , which is universal (from Proposition 1), so ùê∫ ùëò (hence also ùêº ) maps to ùëÄ.</p><p>(2) Let D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë be a fair derivation from (ùêπ, Œ£) and (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë be its associated robust sequence. Since ùúè 0 maps ùêπ to ùê∫ 0 , œÑ ‚Ä¢ùúè 0 maps ùêπ to D ‚äõ , thus D ‚äõ is a model of ùêπ . Consider now any trigger tr for D ‚äõ . By Lemma 1, there exists some ùëó ‚àà ‚Ñë such that tr is a trigger for ùê∫ ùëü for any ùëü ‚àà ‚Ñë with ùëü ‚â• ùëó. Since ùúå ùëü is an isomorphism from ùêπ ùëü to ùê∫ ùëü , we obtain that ùúå -1 ùëü (tr) is a trigger for ùêπ ùëü . Since D is fair, there exists some ùë† ‚àà ‚Ñë with ùë† ‚â• ùëü such that the trigger œÉùë† </p><formula xml:id="formula_23">‚Ä¢ùúå -1 ùëü = œÑùë† ùëü . Then ùúå ùë† ‚Ä¢ œÉùë† ùëü ‚Ä¢ùúå -1 ùëü (tr) = œÑùë† ùëü (tr)</formula><p>= tr is a trigger for ùê∫ ùë† satisfied in ùê∫ ùë† , and thus satisfied in D ‚äõ . ‚ñ°</p><p>Hence, both natural and robust aggregations indicate whether a CQ is entailed by a KB. Yet, natural aggregation provides an instance that is universal but not always a model, while the more complex robust aggregation provides a model which might be only finitely universal. We show next how the latter case can still be utilized towards proving Theorem 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">DECIDABILITY THROUGH TREEWIDTH</head><p>The steepening staircase example shows that the natural aggregation of the core chase may have infinite treewidth even if the chase sequence is uniformly treewidth-bounded. The next proposition provides two results: Firstly, the natural aggregation is indeed treewidth-preserving for monotonic derivations, generalizing a result by Baget et al. <ref type="bibr" target="#b2">[3]</ref> for the restricted chase. Secondly (and more importantly), robust aggregation is superior to natural aggregation in that treewidth preservation can be shown to hold even for non-monotonic chases. Both results rely upon the compactness of treewidth <ref type="bibr" target="#b17">[18]</ref>: if ùêπ is an atomset where tw(ùêπ ‚Ä≤ ) ‚â§ ùëò holds for every finite subset ùêπ ‚Ä≤ ‚äÜ ùêπ , then tw(ùêπ ) ‚â§ ùëò. Proposition 12. For any derivation D that is recurringly treewidth-bounded by some integer ùëò, the following hold:</p><p>(1) D's natural aggregation D * has treewidth ‚â§ùëò, if D is monotonic.</p><p>(2) D's robust aggregation D ‚äõ has treewidth ‚â§ùëò.</p><p>Proof. Let ùêº be a finite subset of D * (for proof of (1)) or D ‚äõ (for proof of (2)). There is some ùëù ‚àà ‚Ñë such that, ‚àÄùëü ‚â• ùëù ‚àà ‚Ñë, we can exhibit some ùêº ùëü isomorphic to ùêπ ùëü with ùêº ‚äÜ ùêº ùëü . To prove (1), D being monotonic, we can define ùêº ùëü = ùêπ ùëü . To prove (2), we rely upon Lemma 1 and define ùêº ùëü = ùê∫ ùëü . Since D is recurrently treewidth-bounded, there is some ùë† ‚â• ùëù ‚àà ‚Ñë such that tw(ùêπ ùë† ) ‚â§ ùëò. Thus tw(ùêº ) ‚â§ tw(ùêº ùë† ) = tw(ùêπ ùë† ) ‚â§ ùëò, and we conclude, thanks to compactness of treewidth, that D * or D ‚äõ has treewidth ‚â§ ùëò. ‚ñ°</p><p>The last missing insight is that the existence of treewidth-bounded finitely universal models suffices to establish decidability of CQ entailment. <ref type="foot" target="#foot_2">3</ref> We obtain this result via a mild generalization of respective statements for universal models <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b10">11]</ref>. Theorem 1. Let ‚Ñ≠ be a class of knowledge bases for which every K = (ùêπ, Œ£) ‚àà ‚Ñ≠ has a model ùêº that is finitely universal for K and that satisfies ùë°ùë§ (ùêº ) ‚àà N. Then CQ entailment for ‚Ñ≠ is decidable. Sketch of proof. K |= ùëÑ can be detected in finite time due to the completeness of first-order logic. K Ã∏ |= ùëÑ can be detected by incrementing ùëò stepwise and checking if K ‚àß (¬¨ùëÑ) has a model of treewidth ùëò, which is decidable. ‚ñ°</p><p>We finally obtain our main result, which follows from Propositions 11 and 12, and Theorem 1: Theorem 2. CQ entailment is decidable for the class of KBs having a recurringly treewidth-bounded core chase sequence.</p><p>We end this section by using this decidability result to define a new class of rulesets and discussing its relationship with existing abstract decidable classes. As usual in the existential rule setting, the considered property can be abstracted from the underlying database, obtaining a new fragment of existential rules that -thanks to Theorem 2 -warrants decidable CQ entailment and properly subsumes and reconciles other classes with that property. <ref type="foot" target="#foot_3">4</ref>Definition 17. A ruleset Œ£ is called core-bts, if for every finite atomset ùêπ , there exists a core chase sequence for the KB (ùêπ, Œ£), whose treewidth is recurringly bounded by some ùëò ‚àà N. Proposition 13. CQ entailment is decidable for any ruleset that is core-bts. Moreover, core-bts subsumes both finite expansion sets (fes) and bounded treewidth sets (bts), which are mutually incomparable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">CONCLUSION AND FUTURE WORK</head><p>In this paper, we have investigated ways of exploiting properties of the core chase in non-terminating settings, with the main goal of ensuring decidability of CQ entailment based on treewidth guarantees for the atomsets occurring in chase sequence.</p><p>On the negative side, we found that, contrary to plausible expectations, the existence of a treewidth-bounded core-chase sequence does not coincide with the existence of a treewidth-bounded universal model, nor is there a subsumption in one of the two directions: On one hand, we exhibited a KB K h admitting a core-chase sequence the treewidth of which is uniformly bounded by 2, while all its universal models are of unbounded treewidth. On the other hand, we described a KB K v admitting an infinite universal model of treewidth 1, while all corresponding core chase sequences consist of structures of ever increasing treewidth.</p><p>On the positive side, we showed how a given core chase sequence can be robustly aggregated into a (potentially infinite) atomset that is a model of the underlying knowledge base, while satisfying exactly those CQs entailed by it. We also showed that for any such core chase sequence that is recurringly treewidth-bounded, the aggregated atomset will be of finite treewidth. Together, these findings establish decidability of CQ entailment for all knowledge bases with a recurringly treewidth-bounded core chase. Abstracting from concrete databases, this yields a novel, very general abstract class of recurringly treewidth-bounded rulesets, ensuring decidability of CQ entailment and subsuming the two previously known incomparable classes fes and bts.</p><p>Future work on the topic will clarify under what circumstances the robust aggregation produces cores (according to some of the many existing non-equivalent definitions of cores in the infinite <ref type="bibr" target="#b3">[4]</ref>). Also, we will investigate the relationship of our approach to the stable chase introduced by Carral et al. <ref type="bibr" target="#b7">[8]</ref>, which also produces (not necessarily universal) models satisfying exactly the entailed CQs. Note that the stable chase is quite elaborate and not subsumed by our current generic definition of derivation: the computation occasionally "jumps back" to earlier sequence elements and starts rebuilding the sequence from there.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A PROOFS OF SECTION 3</head><p>The following appendices are devoted to the complete proofs that are missing or only sketched in the paper. Fact 3. If tr is a trigger for ùêπ , ùúá maps ùêπ to ùêº and ùêº satisfies ùúá (tr), then there is ùúá ‚Ä≤ (compatible with ùúá) that maps ùõº (ùêπ, tr) to ùêº . Lemma 2. For every fair derivation D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë , there exists a fair monotonic derivation D ùëöùëúùëõ = (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë such that for every ùëñ ‚àà ‚Ñë, there is a retraction from ùê∫ ùëñ to ùêπ ùëñ .</p><p>Proof. From D = (ùêπ ùëñ ) ùëñ ‚àà‚Ñë , let us first build inductively a derivation D ùëöùëúùëõ = (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë such that ùê∫ 0 = ùê¥ 0 = ùêπ , ùêπ 0 = ùúé 0 (ùêπ 0 ) and ‚àÄùëñ &gt; 0 ‚àà ‚Ñë, ùêπ ùëñ = ùúé ùëñ (ùê¥ ùëñ ) with ùê¥ ùëñ = ùõº (ùêπ ùëñ -1 , tr ùëñ ), we can define ùê∫ ùëñ = ùõº (ùê∫ ùëñ -1 , tr ùëñ ). See that ùúé 0 is a retraction from ùê∫ 0 to ùêπ 0 , and so the trigger tr 1 is also a trigger in ùê∫ 0 , allowing us to build ùê∫ 1 . Now we claim that ùúé 0 is a retraction from ùê∫ 1 to ùê¥ 1 , and thus ùúé 1 ‚Ä¢ ùúé 0 is a retraction from ùê∫ 1 to ùêπ 1 . An induction based upon these remarks shows that for ùëñ ‚àà ‚Ñë, œÉùëñ = ùúé ùëñ  (ùëñ,ùëó ) . We make the following observations (which hold for all endomorphisms on ùêº h ):</p><p>(1) ‚Ñé ùë¶ (ùëñ, 0) = 0 since f holds precisely for all nulls ùëã ùëñ 0 .</p><p>(2) ‚Ñé ùë¶ (ùëñ, ùëó) = ùëó, inductively with (1) as base case and the observation that ‚Ñé must preserve the length of incoming v-paths rooted in some f. (3) ‚Ñé ùë• (ùëñ, ùëó) = ‚Ñé ùë• (ùëñ, ùëó +1), since this is the only way for ‚Ñé to preserve the v-atoms. (4) ‚Ñé ùë• (ùëñ, ùëó) = ‚Ñé ùë• (ùëñ, ùëò), via iteration of (3).</p><p>(5) ‚Ñé ùë• (ùëñ, ùëó) ‚â• ùëñ, due to (2) and the fact that ùëã ùëñ ùëó does not exist for ùëó &gt; ùëñ + 1. (6) ‚Ñé ùë• (ùëñ + 1, ùëó) = ‚Ñé ùë• (ùëñ, ùëó) or ‚Ñé ùë• (ùëñ + 1, ùëó) = ‚Ñé ùë• (ùëñ, ùëó) + 1, since this is the only way for ‚Ñé to preserve the h-atoms. (7) ‚Ñé ùë¶ (ùëñ + 1, ùëó) = ‚Ñé ùë¶ (ùëñ, ùëó) since this is the only way for ‚Ñé to preserve the h-atoms. (8) There are ùëò, ‚Ñì ‚àà N such that ‚Ñé ùë• (ùëñ, ùëó) = ùëñ + ‚Ñì for all ùëñ &gt; ùëò. This is a consequence of ( <ref type="formula">5</ref>) and ( <ref type="formula">6</ref>). ( <ref type="formula">9</ref>) There is a ùëò ‚àà N such that the restriction of ‚Ñé to the ùëã ùëñ ùëó with ùëñ &gt; ùëò is injective. Follows from <ref type="bibr" target="#b7">(8)</ref>, for the same ùëò, and (2). If we now let ùêº h -be ùêº h restricted to terms ùëã ùëñ ùëó with ùëñ &gt; ùëò, we obtain that ‚Ñé is an isomorphism from</p><formula xml:id="formula_24">ùêº h -to ‚Ñé(ùêº h -), i.e., ùêº h - ‚Ñé(ùêº h -). Since ‚Ñé = ‚Ñé 2 ‚Ä¢ ‚Ñé 1 , this means that ‚Ñé 1 must be an isomorphism from ùêº h -to ‚Ñé 1 (ùêº h -) and ‚Ñé 2 must be an isomorphism from ‚Ñé 1 (ùêº h -) to ‚Ñé 2 (‚Ñé 1 (ùêº h -)) = ‚Ñé(ùêº h -). Therefore, ùë°ùë§ (ùêº h -) = ùë°ùë§ (‚Ñé 1 (ùêº h -)) = ùë°ùë§ (‚Ñé 2 (‚Ñé 1 (ùêº h -)</formula><p>)) (*). Now, for any given ùëõ ‚àà N with ùëõ &gt; ùëò, take T ùëõ√óùëõ = {ùëã ùëñ ùëó | ùëõ + 1 ‚â§ ùëñ ‚â§ 2ùëõ and 0 ‚â§ ùëñ ‚â§ ùëõ -1} ‚äÜ terms(ùêº h ). Consequently, T ùëõ√óùëõ witnesses that ùêº h -contains a ùëõ √ó ùëõ grid. Yet, as ùëõ can be chosen arbitrarily large, ùêº h -contains grids of arbitrary size and thus cannot have finite treewidth, i.e., ùë°ùë§ (ùêº h -) ‚àâ N (**). From these insights, we can conclude</p><formula xml:id="formula_25">ùêº h -‚äÜ ùêº h =‚áí ‚Ñé 1 (ùêº h -) ‚äÜ ‚Ñé 1 (ùêº h ) ‚äÜ ùëà Fact 1 =‚áí ùë°ùë§ (‚Ñé 1 (ùêº h -)) ‚â§ ùë°ùë§ (ùëà ) (*) =‚áí ùë°ùë§ (ùêº h -) ‚â§ ùë°ùë§ (ùëà ) (**)</formula><p>=‚áí ùë°ùë§ (ùëà ) ‚àâ N.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>‚ñ°</head><p>C PROOFS OF SECTION 7</p><p>Proposition 8. The following hold:</p><p>(1) Every ùêº v ùëõ is a core. (2) ùêº v ùëõ has a treewidth of at least ‚åàùëõ/3‚åâ + 1.</p><p>(3) For every core chase sequence (ùêπ ùëñ ) ùëñ ‚ààN for K v , there is an unbounded monotonic function ùëì : N ‚Üí N such that, for every ùëõ ‚àà N, ùêº v ùëì (ùëõ) is isomorphic to a subset of ùêπ ùëõ . (4) For every core chase sequence (ùêπ ùëñ ) ùëñ ‚ààN for K v and any ùëö ‚àà N exists a ùëò ‚àà N such that tw(ùêπ ùëñ ) ‚â• ùëö for all ùëñ ‚â• ùëò.</p><p>Proof. We show these claims consecutively. (1) It is straightforward to check that ùêº v 0 is a core. To show that ùêº v ùëõ is a core for every ùëõ &gt; 0, pick an arbitrary retraction ùúé of ùêº v ùëõ . Toward showing that ùúé is the identity, first note that it must be column-preserving (i.e., satisfy ùúé (ùëã ùëñ ‚Ñì ) = ùëã ùëñ ‚Ñì ‚Ä≤ ), since for any two ùëã ùëñ ùëò , ùëã ùëó ‚Ñì ‚àà Œî v ùëõ hold: ‚Ä¢ they are connected by a v-path exactly if ùëñ = ùëó, ‚Ä¢ if there is an h connection from the former to the latter, then ùëñ + 1 = ùëó,</p><p>‚Ä¢ if ùëñ + 1 = ùëó, then there are ùëò ‚Ä≤ and ‚Ñì ‚Ä≤ satisfying h(ùëã ùëñ ùëò ‚Ä≤ , ùëã ùëó ‚Ñì ‚Ä≤ ) ‚àà ùêº v ùëõ . Yet then, for every ùëã ùëñ ùëò ‚àà Œî v ùëõ , the corresponding column (the substructure of ùêº v ùëõ induced by all ùëã ùëó ‚Ñì with ùëó = ùëñ) has an retraction obtained by restricting ùúé accordingly. Yet, each of these column-wise retractions must map the unique elements carrying f and c to themselves, which also forces all other elements (on the intermediate directed v-path) to be identically mapped. Consequently, every row-wise retraction must be the identity function. Yet then, ùúé as a whole must be the identity as well.</p><p>(2) This claim is a consequence of Fact 2, since, for every ùëõ, the elements ùëã ùëñ ùëò with ‚åä2ùëõ/3‚åã + 1 ‚â§ ùëñ ‚â§ ùëõ + 1 and ùëõ ‚â§ ùëò ‚â§ ‚åà4ùëõ/3‚åâ witness that ùêº v ùëõ contains a (‚åäùëõ/3‚åã + 1) √ó (‚åäùëõ/3‚åã + 1)-grid. (3) Without loss of generality, we assume the considered core chase employs the same naming scheme as ùêº v . Therefore, any intermediate atomset of the considered chase can be described by a subset of ùêº v . We first observe that ùêº v 0 = ùêπ v , thus the claim is satisfied for ùëõ = 0 once we set ùëì (0) = 0. We proceed iteratively for larger ùëõ. For any subsequent ùëõ, we can assume that ùêπ ùëõ-1 contains some ùêº v ùëö . Therefore, the only interesting case is if, upon producing ùêπ ùëõ , nulls of ùêπ ùëõ-1 are removed through the non-trivial retraction ùúé ùëõ . Among the nulls removed, let ùëã ùëñ ùëó be the one with maximal ùëó and (among all these) the one with minimal ùëñ. By construction (observing ùêº v ), removal of nulls will always simultaneously affect all nulls in a row, leaving behind only those of the form ùëã ùëò 2ùëò . Therefore, we obtain ùëñ = ‚åä ùëó/2‚åã + 1. Also, by maximality of ùëó and the fact that there are no rowdecreasing v-atoms, we know that ùúé ùëõ (ùëã ùëñ ùëó ) = ùëã ùëñ ùëó+1 (note that retractions must be column-preserving, as argued before). Then, for ùúé ùëõ to be a retraction, we require h(ùëã ùëñ -1 2‚åä ùëó/2‚åã , ùëã ùëñ ùëó+1 ) ‚àà ùêº v ùëõ-1 . Yet, as row-increasing h-edges can only be the consequence of a (potentially iterated) prior application of ùëÖ v 7 , the atom f(ùëã ùëñ ùëó+1 ) must occur in some atomset preceding ùêº v</p><p>ùëõ . Yet, this can only be the consequence of the iterated application of ùëÖ v 7 propagating f from "right to left", starting from f(ùëã ùëó+2 ùëó+1 ), d(ùëã ùëó+2 ùëó+1 ). The latter atom must, in turn have been created through iterated application of ùëÖ v 5 , propagating d "top-down" starting from d(ùëã ùëó+2 2ùëó+4 ) which must have been created through application of ùëÖ v 4 to c(ùëã ùëó+2 <ref type="table">2ùëó+4</ref> ). Yet, the only way to produce the latter is through ùëÖ v 1 following iterated application of ùëÖ v 2 preceded by an application of ùëÖ v 3 to d(ùëã ùëó+1 ùëó ), f(ùëã ùëó+1 ùëó ), and v(ùëã ùëó+1 ùëó , ùëã ùëó+1 ùëó+1 ). This argument can then be repeated for columns further left, leading to the insight that removal of ùëã ùëñ ùëó requires that all facts from ùêº v ùëó+1 must have previously existed in the derivation. Among those, the facts involving nulls ùëã ùëò ‚Ñì with ‚Ñì &gt; ùëó, cannot have been removed by our maximality assumption. The remaining facts of ùêº v ùëó+1 are indefinitely exempt from removal because the participating nulls are column-wise unique wrt carrying c. We can therefore conclude that upon removal of ùëã ùëñ ùëó toward the creation of ùêπ ùëõ , the latter must contain ùêº v ùëó+1 . Finally, we observe that, as an indirect consequence of fairness, every ùëã ùëñ ùëó with ùëó ‚â† 2ùëñ will be removed in some derivation step, leading to the consequence that ever growing elements ùêº v ùëó+1 will come into operation. (4) This claim is a direct consequence of Item 2 and Item 3, given monotonicity of treewidth (Fact 1). </p><formula xml:id="formula_26">‚ñ° ùêπ ùêπ 0 ùê¥ 1 ùêπ 1 ùê∫ 0 ùê∫ 1 ùê¥ ‚Ä≤ 1 ùêπ ‚Ä≤ 1 ùê¥ 2 ùêπ 2 ùê∫ 2 ùê¥ ‚Ä≤ 2 ùêπ ‚Ä≤ 2 ùê¥ 2 ùêπ 2 ùê∫ 3 ùê¥ ‚Ä≤ 3 ùêπ ‚Ä≤ 3 ùúå 0 ùúå 1 ùúé 0 ùúé 1 ùúå 0 ùúå 0 ùúé ‚Ä≤ 1 ùúå ùúé ‚Ä≤ 1 ùúè 1 ùúè 1 ùúå 2 ùúé 2 ùúå 1 ùúå 1 ùúé ‚Ä≤ 2 ùúå ùúé ‚Ä≤ 2 ùúè 2 ùúè 2 ùúå 3 ùúé 3 ùúå 2 ùúå 2 ùúé ‚Ä≤ 3 ùúå ùúé ‚Ä≤ 3 ùúè 3 ùúè 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D PROOFS OF SECTION 8</head><p>Lemma 1. Let (ùê∫ ùëñ ) ùëñ ‚àà‚Ñë be the robust sequence associated with a derivation D. If ùê¥ is a finite subset of D ‚äõ , then there exists some ùëò ‚àà ‚Ñë such that, for every ùëü ‚â• ùëò ‚äÜ ‚Ñë, ùê¥ ‚äÜ ùê∫ ùëü .</p><p>Proof. We first prove (i) for every ùëñ &gt; 0 ‚àà ‚Ñë, œÑ (ùê∫ ùëñ -1 ) ‚äÜ œÑ (ùê∫ ùëñ ). Indeed, since ùúè ùëñ is a homomorphism from ùê∫ ùëñ -1 to ùê∫ ùëñ , then ùúè ùëñ (ùê∫ ùëñ -1 ) ‚äÜ ùê∫ ùëñ and thus for any ùëó &gt; ùëñ ‚àà ‚Ñë, œÑ ùëó ùëñ (ùúè ùëñ (ùê∫ ùëó -1 )) ‚äÜ œÑ ùëó ùëñ (ùê∫ ùëñ ), meaning œÑ (ùê∫ ùëñ -1 ) ‚äÜ œÑ (ùê∫ ùëñ ).</p><p>Then we prove (ii) for every œÑ (ùê∫ ùëó ), there exists some ùëò ‚â• ùëó such that for every ùëü ‚â• ùëò, œÑ (ùê∫ ùëó ) ‚äÜ ùê∫ ùëü . For every variable ùëã in ùê∫ ùëó , there is some ùëò ùëã ‚àà ‚Ñë such that œÑ (ùëã ) = ùúè ùëò ùëã ùëó (ùëã ) is stable in all atomsets after ùê∫ ùëò ùëã (Proposition 10). If we take ùëò = max ùëã ‚ààvars (ùê∫ ùëó ) ùëò ùëã , then for every ùëü ‚â• ùëò, ùúè ùëü ùëó = ùúè ùëü ùëò ‚Ä¢ ùúè ùëò ùëó = œÑ is a homomorphism from ùê∫ ùëó to ùê∫ ùëü , and thus œÑ (ùê∫ ùëó ) ‚äÜ ùê∫ ùëü .</p><p>Finally, since ùê¥ is finite and the successive œÑ (ùê∫ ùëñ ) form a monotonic sequence (see (i)), there exists ùëó ‚àà ‚Ñë such that ùê¥ ‚äÜ œÑ (ùê∫ ùëó ). Then (ii) there exists ùëò ‚â• ùëó such that for every ùëü ‚â• ùëò, œÑ (ùê∫ ùëó ) ‚äÜ ùê∫ ùëü and thus ùê¥ ‚äÜ ùê∫ ùëü . ‚ñ°</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E PROOFS OF SECTION 9</head><p>Theorem 1. CQ entailment is decidable for the class of KBs having a recurringly treewidth-bounded core chase sequence.</p><p>Proof. Let ‚Ñ≠ be the class of KBs having a recurringly treewidthbounded core chase sequence. The proof closely follows arguments from previous work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>. An algorithm deciding K |= ùëÑ for a given K ‚àà ‚Ñ≠ and conjunctive query ùëÑ can be devised from two semi-decision procedures (which, when executed in parallel give rise to a decision algorithm): one guaranteed to detect K |= ùëÑ after finite time and another detecting K Ã∏ |= ùëÑ. For the former, we can evoke the fact that thanks to the completeness of first-order logic <ref type="bibr" target="#b11">[12]</ref>, the consequences of a first-order theory are recursively enumerable. So, the first part of the algorithm can just enumerate the consequences of K and terminate answering "yes" as soon as ùëÑ is found among the consequences. It remains to be shown that there is a semi-decision procedure detecting K Ã∏ |= ùëÑ. By assumption, K has a finitely universal model ùêº with ùë°ùë§ (ùêº ) ‚àà N. From ùêº being finitely universal for K and K Ã∏ |= ùëÑ, we can conclude ùêº Ã∏ |= ùëÑ. But then we obtain ùêº |= ùêπ ‚àß ( Œ£) ‚àß (¬¨ùëÑ) (assuming that ùêπ and ùëÑ are represented as first-order sentences and Œ£ as a set of first-order sentences). This means, whenever K Ã∏ |= ùëÑ, then there exists some ùëò (namely ùë°ùë§ (ùêº )) such that the first-order sentence ùêπ ‚àß( Œ£)‚àß(¬¨ùëÑ) is satisfiable over the class of structures of treewidth ùëò. Fortunately, as previously observed <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7]</ref>, satisfiability of monadic second-order logic -and thus also of first-order logic -over classes of structures with a treewidth bounded by a given ùëò is decidable. This allows to design a semi-decision procedure that increases ùëò stepwise and in each step applies the decision procedure that checks if ùêπ ‚àß ( Œ£) ‚àß (¬¨ùëÑ) has a model of treewidth ùëò. If so, the procedure terminates with the output "no", since we have shown that ùëÑ cannot be a consequence of K. If not, we increment ùëò and repeat. Clearly, thanks to the above assumption, this semi-decision procedure will output "no" and terminate exactly if K Ã∏ |= ùëÑ. ‚ñ° Proposition 13. CQ entailment is decidable for any ruleset that is core-bts. Moreover, core-bts subsumes both finite expansion sets (fes) and bounded treewidth sets (bts), which are mutually incomparable.</p><p>Proof. Decidability follows from Theorem 2. We sucessively prove the following items:</p><p>‚Ä¢ fes and bts are incomparable, ‚Ä¢ fes is subsumed by core-bts.</p><p>‚Ä¢ bts is subsumed by core-bts.</p><p>For the first bullet point, note that the singleton ruleset {r(ùëã, ùëå ) ‚Üí ‚àÉùëç .r(ùëå, ùëç )} is bts but not fes, whereas the singleton ruleset {r(ùëã, ùëå )‚àß r(ùëå, ùëç ) ‚Üí ‚àÉùëâ .r(ùëã, ùëã ) ‚àß r(ùëã, ùëç ) ‚àß r(ùëç, ùëâ )} is fes but not bts.</p><p>For the second bullet point, recall that finite extension sets guarantee core-chase termination. Yet, for any finite sequence of finite structures one can find a uniform finite bound on the treewidth, it suffices to pick max ùëñ ‚àà‚Ñë |T (ùêπ ùëñ )|.</p><p>For the third bullet point, we observe that any treewidth-bounded restricted chase sequence (ùêπ ùëñ ) ùëñ ‚àà‚Ñë can be transformed into a corechase sequence (ùêπ ‚Ä≤ ùëñ ) ùëñ ‚àà‚Ñë as follows: Let ùúé ‚Ä≤ 0 be an endomorphism turning ùêπ 0 into a core and let ùêπ ‚Ä≤ 0 = ùúé ‚Ä≤ 0 (ùêπ 0 ) = ùúé ‚Ä≤ 0 (ùêπ ). From this starting point, we can always use ùêπ ùëñ , ùêπ ‚Ä≤ ùëñ , and ùúé ‚Ä≤ ùëñ where ùúé ‚Ä≤ ùëñ (ùêπ ùëñ ) = ùêπ ‚Ä≤ ùëñ is a core, to define ùúé ‚Ä≤ ùëñ+1 and ùêπ ‚Ä≤ ùëñ+1 such that ùúé ‚Ä≤ ùëñ+1 (ùêπ ùëñ+1 ) = ùêπ ‚Ä≤ ùëñ+1 is a core as follows: assuming ùêπ ùëñ+1 = ùõº (ùêπ ùëñ , (ùëÖ, ùúã)), we let ùúé ùëñ+1 be an endomorphism of ùõº (ùúé ‚Ä≤ ùëñ (ùêπ ùëñ ), (ùëÖ, ùúé ‚Ä≤ ùëñ ‚Ä¢ ùúã)) producing a core, which we choose as ùêπ ‚Ä≤ ùëñ+1 . Clearly then ùêπ ‚Ä≤ ùëñ+1 is also a core of ùêπ ùëñ+1 = ùõº (ùêπ ùëñ , (ùëÖ, ùúã)) witnessed by the endomorphism ùúé ‚Ä≤ ùëñ+1 = ùúé ùëñ+1 ‚Ä¢ ùúé ‚Ä≤ ùëñ . Note that (ùêπ ‚Ä≤ ùëñ ) ùëñ ‚àà‚Ñë is indeed a core chase sequence, except for some elements being repeated, which can be removed. Now given that there exists a bound ùëè greater than the treewidth of each element of (ùêπ ùëñ ) ùëñ ‚àà‚Ñë , the same must hold for (ùêπ ‚Ä≤ ùëñ ) ùëñ ‚àà‚Ñë , given that ùêπ ‚Ä≤ ùëñ ‚äÜ ùêπ ùëñ for all ùëñ ‚àà ‚Ñë. Thus (ùêπ ‚Ä≤ ùëñ ) ùëñ ‚àà‚Ñë (and any pruned subsequence of it) is uniformly (and hence also recurrently) treewidth-bounded. ‚ñ°</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Two infinite universal models of K v (ùêº v from Definition 10 and ùêº v * from Definition 11), and finite atomsets ùêº v 1 -ùêº v 5 of the sequence (ùêº v ùëõ ) ùëõ‚ààN from Definition 12 (recall that ùêº v 0 = ùêπ v ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Proposition 9 .</head><label>9</label><figDesc>Let ùëÄ be a finitely universal model of a KB K, and let ùëÑ be a CQ. Then K |= ùëÑ iff ùëÄ |= ùëÑ. Proof. (‚áê) Let ùúé be a homomorphism from ùëÑ to ùëÄ. As ùëÄ is finitely universal, the finite subset ùúé (ùëÑ) of ùëÄ maps to any model ùêº of K by some ùúé ‚Ä≤ , thus ùúé ‚Ä≤ ‚Ä¢ ùúé maps ùëÑ to ùêº . (‚áí) Since K |= ùëÑ and ùëÄ is a model of K, ùëÄ |= ùëÑ. ‚ñ°</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Building the robust sequence associated with D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Depiction of the inductive definition of the robust sequence (Definition 15). Also useful to follow proof of Proposition 11.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>denote the subset of ùêº h induced by ùëÉ ùëò (resp. ùê∂ ùëò , ùëÜ ùëò ). Intuitively, ùëÉ h ùëò is the finite part until column ùëò, ùê∂ h ùëò is the ùëò th column of ùêº h (minus its top element) and ùëÜ h ùëò is a step -a rectangle containing the two columns ùê∂ h ùëò and ùê∂ h ùëò+1 . We first point out that there is a sequence of rule applications from any ùê∂ h ùëò producing ùëÜ h ùëò . Indeed, we can apply ùëÖ h 1 on the top of ùê∂ h ùëò to "complete" ùê∂ h ùëò and obtain the two highest variables of ùê∂ h</figDesc><table><row><cell></cell><cell>ùëò+1 .</cell></row><row><cell cols="2">Then we apply ùëÖ h 2 ùëò times (from top to bottom) to obtain the other</cell></row><row><cell>variables of ùê∂ h ùëò+1 . Once ùëã ùëò+1 0</cell><cell>has been generated, we can apply ùëÖ h 3</cell></row><row><cell cols="2">to generate the h-loop on ùëã ùëò+1 0 , then ùëò successive applications of</cell></row><row><cell cols="2">ùëÖ h 4 propagate the loops on ùê∂ h ùëò+1 , from bottom to top. There is thus</cell></row><row><cell cols="2">a monotonic infinite derivation D r = (ùêπ ùëñ ) ùëñ ‚ààN from K h , the natural</cell></row><row><cell cols="2">aggregation of which yields ùêº h . We successively apply ùëÖ h 1 , ùëÖ h 3 , and</cell></row><row><cell>ùëÖ h 4 on ùêπ</cell><cell></cell></row></table><note><p>h to obtain ùëÜ h 0 = ùëÉ h 1 . Since ùê∂ h 1 ‚äÜ ùëÜ h 0 , we apply the rules on ùê∂ h 1 as seen previously to obtain ùëÖ h 1 and thus ùëÜ h 2</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>and ùëó ‚â• ùëõ} removing all atoms v(ùëã ùëñ ùëó , ùëã ùëñ ùëó ) and f(ùëã ùëñ ùëó ) with ùëó &gt; ùëõ as well as all atoms h(ùëã ùëñ ùëó , ùëã ùëñ+1 ùëò ) with ùëò &gt; ùëó and ùëò &gt; ùëõ.</figDesc><table><row><cell>Proposition 8. The following hold:</cell></row><row><cell>(1) Every ùêº v ùëõ is a core.</cell></row><row><cell>(2) ùêº v ùëõ has a treewidth of at least ‚åàùëõ/3‚åâ + 1.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>ùëü (tr) for ùêπ ùë† is satisfied in ùêπ ùë† . Now since ùúå ùë† is an isomorphism from ùêπ ùë† to ùê∫ ùë† , it follows that ùúå ùë† ‚Ä¢ œÉùë† ùëü ‚Ä¢ùúå -1 ùëü (tr) is a satisfied trigger for ùê∫ ùë† . We first see that ùúé ùëü +1 ‚Ä¢ ùúå -1 ùëü = ùúå -1 ùëü +1 ‚Ä¢ ùúè ùëü +1 . By applying this property iteratively, we show that ùúå ùë† ‚Ä¢ œÉùë† ùëü</figDesc><table /><note><p>ùëü ‚Ä¢ ùúå -1</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ùúé 0 is a retraction from ùê∫ ùëñ to ùêπ ùëñ that allows us to build ùê∫ ùëñ+1 . The derivation D ùëöùëúùëõ we obtain is</figDesc><table><row><cell cols="2">Rule let ‚Ñé(ùëã ùëñ ùëó ) = ùëã ‚Ñé ùë• (ùëñ,ùëó ) ‚Ñé ùë¶</cell><cell>Homomorphism</cell><cell>Atoms produced</cell></row><row><cell>ùëÖ ‚Ñé 1</cell><cell></cell><cell>ùëã ‚Ü¶ ‚Üí ùëã ùëò ùëò</cell><cell>v(ùëã ùëò ùëò , ùëã ùëò ùëò+1 ), h(ùëã ùëò ùëò+1 , ùëã ùëò+1 ùëò+1 ), c(ùëã ùëò+1 ùëò+1 ), h(ùëã ùëò ùëò , ùëã ùëò+1 ,</cell><cell>ùëò), v(ùëã ùëò+1 ùëò , ùëã ùëò+1 ùëò+1 )</cell></row><row><cell>ùëÖ ‚Ñé 2</cell><cell cols="2">ùëã ‚Ü¶ ‚Üí ùëã ùëò ùëò -1 , ùëã ‚Ä≤ ‚Ü¶ ‚Üí ùëã ùëò ùëò , ùëå ‚Ä≤ ‚Ü¶ ‚Üí ùëã ùëò+1 ùëò</cell><cell>h(ùëã ùëò ùëò -1 , ùëã ùëò+1 ùëò -1 ), v(ùëã ùëò+1 ùëò -1 , ùëã ùëò+1 ùëò ), c(ùëã ùëò+1 ùëò )</cell></row><row><cell>. . .</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that we operate under the unique name assumption.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>The notion of fresh variable refers to the underlying assumption that the referred variable is not already present in ùêπ , but also, that it has not occurred at any potential previous computation step (which is particularly relevant when rule applications are iterated and/or intertwined with other operations).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>However, no upper complexity bounds are entailed. This holds even for the more restricted class of KBs with finite, "properly" universal models<ref type="bibr" target="#b4">[5]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Notably, this corrects inaccurate statements in prior work by Baget et al.<ref type="bibr" target="#b2">[3]</ref>, where bts was claimed to subsume fes. The reason for this misconception was a definition of bts using cores, whereas the proof of decidability of CQ entailment for this class was flawed, as it erroneously assumed that the natural aggregation over a (treewidthbounded) core chase sequence produces a (treewidth-bounded) universal model. The current paper also corrects this earlier work, showing that the decidability claim made therein can be salvaged by other means.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>The authors thank the anonymous reviewers for their helpful comments. <rs type="person">Jean-Fran√ßois Baget</rs> and <rs type="person">Marie-Laure Mugnier</rs> were partially supported by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>). <rs type="person">Sebastian Rudolph</rs> has received funding from the <rs type="funder">European Research Council</rs> (<rs type="grantName">Consolidator Grant</rs> Agreement no. <rs type="grantNumber">771779</rs>, DeciGUT).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_395rhe3">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
				<org type="funding" xml:id="_75C6S47">
					<idno type="grant-number">771779</idno>
					<orgName type="grant-name">Consolidator Grant</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof. Let ùëÄ be an arbitrary model of K. We first prove the existence of homomorphisms ùêπ ùëñ ‚Üí ùëÄ by induction over ùëñ. The existence of some homomorphism ùêπ 0 ‚Üí ùëÄ is immediate by assumption. Then, if there is a homomorphism ùúá ùëó from some ùêπ ùëó of D to ùëÄ, then there is a homomorphism ùúá ùëó+1 of ùêπ ùëó+1 to ùëÄ such that ùúá ùëó+1 is compatible with ùúá ùëó . We have ùêπ ùëó+1 = ùúé ùëó+1 (ùõº (ùêπ ùëó , tr ùëñ+1 )). See that ùúá ùëó (tr ùëñ+1 ) is a trigger for ùëÄ, satisfied in ùëÄ since it is a model of K. Then (Fact 3) there is a homomorphism ùúá from ùõº (ùêπ ùëó , tr ùëó+1 ) to ùëÄ compatible with ùúá ùëó and its restriction ùúá ùëó+1 to the variables of ùúé ùëó+1 (ùõº (ùêπ ùëó , tr ùëó+1 )) is a homomorphism from ùêπ ùëó+1 to ùëÄ compatible with ùúá ùëó .</p><p>(2) Hence, ùëÄ is a model of every ùêπ ùëñ in D: each instance ùêπ ùëñ is universal and, if D is finite, then the final result D + = ùêπ ùëò is universal. ‚ñ° (1) Now we claim that since a variable present both in ùêπ ùëñ and ùêπ ùëó must appear in all atomsets between ùêπ ùëñ and ùêπ ùëó (a consequence of the usage of fresh variables), the pairwise compatibility of the ùúá ùëñ between succsessive atomsets implies global compatibility of all ùúá ùëñ . We conclude by pointing out that ùëñ ‚àà‚Ñë ùúá ùëñ is a homomorphism from D * to ùëÄ, and thus that D * is universal. ‚ñ° (4) The final result D + = ùêπ ùëò of a finite derivation is a model of ùêπ ( œÉ ùëó 0 ‚Ä¢ ùúé 0 is a homomorphism from ùêπ to any ùêπ ùëó in the derivation) and, by Definition 3, for any trigger tr for ùêπ ùëò , there is some ùëó ‚â• ùëò (thus ùëó = ùëò) such that œÉùëò ùëò (tr) = tr is a satisfied trigger for ùêπ ùëò . ‚ñ° (3) In the case of an infinite fair derivation, we first point out that D * contains ùêπ 0 = ùúé 0 (ùêπ ), so it is a model of ùêπ . Then consider any trigger tr for D * : it is also a trigger for some ùêπ ùëñ in D. By Definition 3, there exists some ùëó ‚àà ‚Ñë with ùëó ‚â• ùëñ such that œÉ ùëó ùëñ (tr) is a satisfied trigger for ùêπ ùëó . Since D is monotonic, ùúé ùëó ùëñ is the identity and thus œÉ ùëó ùëñ (tr) = tr is satisfied in D * . ‚ñ° (5, ‚áê) Let ùúã be a homomorphism from ùëÑ to D * . Since D * is universal (by (1)), it maps to any model ùëÄ of K. Let ùúè ùëÄ be a homomorphism from D * to ùëÄ, then ùúè ùëÄ ‚Ä¢ ùúã maps ùëÑ to ùëÄ. ‚ñ° (5, ‚áí) Let us now consider the fair monotonic derivation D ùëöùëúùëõ from Lemma 2. We now that D * ùëöùëúùëõ is a model of K, and then if K |= ùëÑ, then there is a homomorphism ùúã from ùëÑ to D * ùëöùëúùëõ . Since ùúã (ùëÑ) is finite, there is some atomset ùê∫ ùëñ in D ùëöùëúùëõ such that ùúã (ùëÑ) ‚äÜ ùê∫ ùëñ . We know there is a retract œÉùëñ from ùê∫ ùëñ to ùêπ ùëñ , so œÉùëñ ‚Ä¢ ùúã is a homomorphism from ùëÑ to ùêπ ùëñ and so from ùëÑ to D * . ‚ñ°</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B PROOFS OF SECTION 6</head><p>We first prove the following claim (see the explanations before Proposition 5.). Claim. There is a sequence of rule applications from any column ùê∂ h ùëò producing step ùëÜ h ùëò .</p><p>Proof. Let us consider ùê∂ ‚Ñé ùëò with variables named (ùëã ùëò 0 , ùëã ùëò 1 , . . . , ùëã ùëò ùëò ), from bottom to top. Let us apply rules as shown in Table <ref type="table">1</ref>. The obtained result is indeed ùëÜ ‚Ñé ùëò . ‚ñ° Proposition 5. No universal model of K h has finite treewidth.</p><p>Proof. We call v-path (resp. h-path) in an atomset a non-empty sequence of nulls such that, for any two consecutive nulls ùëã ùëñ and ùëã ùëñ+1 , the atomset contains the atom v(ùëã ùëñ , ùëã ùëñ+1 ) (resp. h(ùëã ùëñ , ùëã ùëñ+1 )). By analogy to graphs, the length of a path is ùëõ -1 if it is a sequence of ùëõ nulls.</p><p>Let ùëà be an arbitrary universal model of K h . We first point out that ùêº h and ùëà being both universal models, they homomorphically map to each other. We let ‚Ñé 1 denote the homomorphism from ùêº h to ùëà and let ‚Ñé 2 denote the homomorphism from ùëà to ùêº h . Then ‚Ñé = ‚Ñé 2 ‚Ä¢ ‚Ñé 1 is an endomorphism on ùêº h , the properties of which we will now inspect further. We make use of the following notation: for ‚Ñé(ùëã ùëñ ùëó ) = ùëã ùëò ‚Ñì , we denote ùëò by ‚Ñé ùë• (ùëñ, ùëó) and ‚Ñì by ‚Ñé ùë¶ (ùëñ, ùëó), that is, we</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Walking the Decidability Line for Rules with Existential Variables</title>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Lecl√®re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<ptr target="http://aaai.org/ocs/index.php/KR/KR2010/paper/view/1216" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;10)</title>
		<editor>
			<persName><forename type="first">Fangzhen</forename><surname>Lin</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ulrike</forename><surname>Sattler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Miroslaw</forename><surname>Truszczynski</surname></persName>
		</editor>
		<meeting>the 12th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;10)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Walking the Complexity Lines for Generalized Guarded Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Micha√´l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-126</idno>
		<ptr target="https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-126" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</title>
		<editor>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
	<note>IJCAI/AAAI</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">Jean-Fran√ßois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Lecl√®re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Salvat</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2011.03.002</idno>
		<ptr target="https://doi.org/10.1016/j.artint.2011.03.002" />
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Core-like properties of infinite graphs and structures</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName><surname>Bauslaugh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="101" to="111" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Capturing Homomorphism-Closed Decidable Queries with Existential Rules</title>
		<author>
			<persName><forename type="first">Camille</forename><surname>Bourgaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Kr√∂tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Micha√´l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.24963/kr.2021/14</idno>
		<ptr target="https://doi.org/10.24963/kr.2021/14" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Principles of Knowledge Representation and Reasoning</title>
		<editor>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gerhard</forename><surname>Lakemeyer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Esra</forename><surname>Erdem</surname></persName>
		</editor>
		<meeting>the 18th International Conference on Principles of Knowledge Representation and Reasoning<address><addrLine>KR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Taming the Infinite Chase: Query Answering under Expressive Relational Constraints</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cal√¨</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kifer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;08)</title>
		<meeting>the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR&apos;08)</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Taming the Infinite Chase: Query Answering under Expressive Relational Constraints</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Cal√¨</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<idno type="DOI">10.1613/jair.3873</idno>
		<ptr target="https://doi.org/10.1613/jair.3873" />
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="115" to="174" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Preserving Constraints with the Stable Chase</title>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Kr√∂tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maximilian</forename><surname>Marx</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><surname>Ozaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2018.12</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2018.12" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Database Theory (ICDT&apos;18) (LIPIcs</title>
		<editor>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yael</forename><surname>Amsterdamer</surname></persName>
		</editor>
		<meeting>the 21st International Conference on Database Theory (ICDT&apos;18) (LIPIcs</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The chase revisited</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><surname>Nash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">B</forename><surname>Remmel</surname></persName>
		</author>
		<idno type="DOI">10.1145/1376916.1376938</idno>
		<ptr target="https://doi.org/10.1145/1376916.1376938" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS&apos;08)</title>
		<editor>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</editor>
		<meeting>the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS&apos;08)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data Exchange: Semantics and Query Answering</title>
		<author>
			<persName><forename type="first">R</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Finite-Cliquewidth Sets of Existential Rules: Toward a General Criterion for Decidable yet Highly Expressive Querying</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Feller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><forename type="middle">S</forename><surname>Lyon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Piotr</forename><surname>Ostropolski-Nalewaja</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2209.02464" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Database Theory (ICDT 2023) (LIPIcs)</title>
		<meeting>the 26th International Conference on Database Theory (ICDT 2023) (LIPIcs)</meeting>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
		<respStmt>
			<orgName>Schloss Dagstuhl -Leibniz-Zentrum f√ºr Informatik</orgName>
		</respStmt>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Kurt</forename><surname>G√∂del</surname></persName>
		</author>
		<title level="m">√úber die Vollst√§ndigkeit des Logikkalk√ºls</title>
		<imprint>
			<date type="published" when="1929">1929</date>
		</imprint>
		<respStmt>
			<orgName>Universit√§t Wien</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Robbers, Marshals, and Guards: Game Theoretic and Logical Characterizations of Hypertree Width</title>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Scarcello</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0022-0000(03)00030-8</idno>
		<ptr target="https://doi.org/10.1016/S0022-0000(03)00030-8" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="775" to="808" />
			<date type="published" when="2003-06">2003. jun 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Anatomy of the Chase</title>
		<author>
			<persName><forename type="first">G√∂sta</forename><surname>Grahne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Onet</surname></persName>
		</author>
		<idno type="DOI">10.3233/FI-2018-1627</idno>
		<ptr target="https://doi.org/10.3233/FI-2018-1627" />
	</analytic>
	<monogr>
		<title level="j">Fundamenta Informaticae</title>
		<imprint>
			<biblScope unit="volume">157</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="221" to="270" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Optimizing the Chase: Scalable Data Integration under Constraints</title>
		<author>
			<persName><forename type="first">George</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jos√©</forename><surname>Luis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ambite</forename></persName>
		</author>
		<idno type="DOI">10.14778/2733085.2733093</idno>
		<ptr target="https://doi.org/10.14778/2733085.2733093" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="1869" to="1880" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Extending Decidable Existential Rules by Joining Acyclicity and Guardedness</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>Kr√∂tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-166</idno>
		<ptr target="https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-166" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</title>
		<editor>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting>the 22nd International Joint Conference on Artificial Intelligence (IJCAI&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="963" to="968" />
		</imprint>
	</monogr>
	<note>IJCAI/AAAI</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Generalized schema-mappings: from termination to tractability</title>
		<author>
			<persName><forename type="first">B</forename><surname>Marnette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS&apos;09)</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Su</surname></persName>
		</editor>
		<meeting>the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS&apos;09)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">Robin</forename><surname>Thomas</surname></persName>
		</author>
		<ptr target="https://people.math.gatech.edu/~thomas/PAP/twcpt.pdf" />
		<title level="m">The Tree-Width Compactness Theorem for Hypergraphs</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
