<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" />
				<funder ref="#_sRAwrY3">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Olivier</forename><surname>Rodriguez</surname></persName>
							<email>olivier.rodriguez@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
							<email>federico.ulliana@inria.fr</email>
						</author>
						<author>
							<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
							<email>marie-laure.mugnier@inria.fr</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ. Montpellier</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ. Montpellier</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ. Montpellier</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">CNRS Montpellier</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date />
						</imprint>
					</monogr>
					<idno type="MD5">4DFA7CF82D7A8136C4704D47FD4FA394</idno>
					<idno type="DOI">10.14778/3611479.3611481</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:53+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div><p>Data trees, typically encoded in JSON, are ubiquitous in data-driven applications. This ubiquity makes urgent the development of novel techniques for querying heterogeneous JSON data in a flexible manner. We propose a rule language for JSON, called constrained tree-rules, whose purpose is to provide a high-level unified view of heterogeneous JSON data and infer implicit information. As reasoning with constrained tree-rules is undecidable, we identify a relevant subset featuring tractable query answering, for which we design an automata-based query rewriting algorithm. Our approach consists of leveraging NoSQL document stores by means of a novel instance-aware query-rewriting technique. We present an extensive experimental analysis on large collections of several million JSON records. Our results show the importance of instance-aware rewriting as well as the efficiency and scalability of our approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">INTRODUCTION</head><p>Rule-based languages have been studied by the database community for more than four decades because of their importance in processing enterprise data and knowledge <ref type="bibr" target="#b7">[8]</ref>. In the recent years, companies like LogicBlox and Relational-AI commercialized fullfledged solutions for rule-based data processing and explainable AI <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b19">20]</ref>. At the same time, companies like Linkedin, Google, Facebook, and Samsung, among others, developed their own rule engines for reasoning on data <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b65">66,</ref><ref type="bibr" target="#b79">80]</ref>. The interest in such formalisms comes from declarativity and expressivity, which make rules a universal form of knowledge suitable for many tasks such as data-integration <ref type="bibr" target="#b45">[46]</ref>, recursive queries <ref type="bibr" target="#b7">[8]</ref>, ontologies and semantic constraints <ref type="bibr" target="#b34">[35]</ref>, data quality and data preparation for feeding machine learning and analytic tools <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b50">51]</ref>.</p><p>This work is licensed under the Creative Commons BY-NC-ND 4.0 International License. Visit https://creativecommons.org/licenses/by-nc-nd/4.0/ to view a copy of this license. For any use beyond those covered by this license, obtain permission by emailing info@vldb.org. Copyright is held by the owner/author(s). Publication rights licensed to the VLDB Endowment. Proceedings of the VLDB Endowment, Vol. <ref type="bibr" target="#b15">16</ref> The variety of data that can be handled by rule languages led to the design of solutions for reasoning on knowledge graphs and hypergraphs <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b67">68]</ref>. Nevertheless, in many practical cases, data exhibits a simpler structure. There is a sheer amount of semistructured data held by transactional systems, data warehouses, and data lakes, which takes the form of data trees. Today, this data is typically serialized as JSON. Beside this, data trees also permeate the whole Web, where JSON is exchanged at a massive rate. As a bottom line, JSON trees are ubiquitous in data-oriented applications, hence among the most practically relevant formats today. This ubiquity makes urgent the development of novel techniques for querying heterogeneous JSON data in a flexible manner.</p><p>Towards this aim, we study a rule language for JSON suitable to: (1) act as a mediating level to integrate heterogeneous JSON data; (2) allow one to enrich the querying vocabulary, hence to adapt it to specific use-cases and free the end-users from mastering the complexity and irregularity of data; (3) be equipped with reasoning capabilities, i.e., be able to infer information not explicitly stored in the data thereby bringing novel and pertinent answers to the user queries. In the quest for such language, a crucial requirement is that it must enable efficient and scalable query answering techniques. Our new approach is to use NoSQL document stores for query-answering over data-trees together with instance-aware query-rewriting techniques to build a scalable and efficient end-to-end framework for reasoning on JSON databases.</p><p>Example 1.1. Figure <ref type="figure" target="#fig_0">1</ref> shows three JSON trees (pictured in black solid lines) ğ‘‡ 1 , ğ‘‡ 2 , ğ‘‡ 3 holding GitHub data from the public archive <ref type="bibr" target="#b1">[2]</ref>. This collection built for data analysis contains 17 types of events stemming from user actions. Data is complex and irregular. For a data-scientist willing to exploit the archive, tasks like ğ‘–) running short explorative queries or ğ‘–ğ‘–) extracting a training-set for machine learning algorithms can both be extremely time consuming, because of the time required to formulate the "right" queries to the data. To illustrate, a simple information such as the name (login) of a user can appear within different JSON keys (e.g., author for commits, actor for push, user for issues, and more) and within more than 60 different paths in the trees (e.g., actor.login, payload.commits, payload.issue, etc). Let us consider the query ğ‘, which concerns the activity of Linus Torvalds (torvalds). It retrieves the id of the events where the user participated, through the answer variable x. This query is empty on all trees, as it has no matches. Indeed, to query the collection, one must first learn the irregular JSON structure. In contrast, rules ğ‘Ÿ 1 -ğ‘Ÿ 6 can be added (on benefit of all end-users) on top of data thereby providing a unified high-level vision of the JSON records. Rules ğ‘Ÿ 4 -ğ‘Ÿ 6 introduce the high-level notion of event from specific types of events (push, commit, issues), which is handy for queries. Rules ğ‘Ÿ 1 -ğ‘Ÿ 3 abstract on the structure of data to define high-level notions of the same types of events, including the id and the user involved. Altogether, the rules enable implicit inferences (pictured as red dashed edges and nodes) which provide answers to ğ‘ from ğ‘‡ 1 and ğ‘‡ 3 without requiring users to master the whole variability of data. Note that, as pictured, these are tree rules.</p><p>The left-hand-side (the body) encodes a tree structure to match, while the right-hand-side (the head) encodes the inferences. Nodes shared between the body and the head are linked by dotted lines.</p><p>Nodes that belong to the head only (in red), called existential nodes, extend the tree by introducing fresh nodes; they are necessary to restructure data. Further, as we shall see later, rules can be recursive.</p><p>As already said, querying heterogeneous JSON trees in a flexible manner is critical for many data processing and governance tasks. These include scenarios where one-of operations are executed, e.g., the preparation and extraction of training-sets from heterogeneous data <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b50">51]</ref>. These include scenarios where consecutive queries are run and users expect online answers, e.g., in goal-driven explorative queries <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b77">78]</ref>. In both cases, the solution is to use reasoning algorithms based on materialization and query-rewriting techniques <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b26">27]</ref>. These are different approaches complementing each other, for both theoretical and practical concerns <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b51">52]</ref>. First, each can handle only certain rule fragments; this, regardless of the applicative scenarios. Indeed, both suffer from non-termination issues for languages such as Datalog Â± (a.k.a. existential rules or Tuple-Generating-Dependencies) <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b33">34]</ref>. This matters here, as tree rules like those of Example 1.1 are related to these formalisms. Second, assuming termination, every method best fits certain applicative scenarios and hardware constraints.</p><p>Materialization consists at extending the database with the inferences produced by rules, as illustrated by Figure <ref type="figure" target="#fig_0">1</ref>. In-memory materialization is regarded as the most effective approach. Systems based on this approach exhibit extremely high-performances because of their reasoning-oriented algorithms and data-structures <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b67">68</ref>]. Yet, in-memory materialization is tied to the capacity at storing inferences (or even loading data) in memory. Concretely, this may confine the use of the technique to powerful hardware even for medium size datasets. Materialization can also be realized with a DBMS backend but it can be much less performant <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>Rewriting consists at propagating the rules into the query thereby leaving the data untouched. The aim is to produce a set of queries whose evaluation on the data yields the same answers as the evaluation of the input query on the extended database. Figure <ref type="figure" target="#fig_2">2</ref> illustrates the rewriting of query ğ‘ from Example 1.1. In spirit, the rewriting process replaces parts of a query matching a rule head with the rule body itself. The advantages of query rewriting are multiple. First, it requires no additional space to store inferences. Second, it is insensitive to data updates. Third, it allows one to reason with read-only access rights on the database. The most important however is that rewriting can be deployed on top of existing database technology <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b63">64]</ref>. This has two main advantages: it makes the technique resilient to main-memory limitations, as data is stored on disk and inferences not stored at all, and it allows one to delegate query evaluation to the DBMS. On this matter, JSON has been adopted as a data model by several NoSQL document stores, often praised for their performances (e.g., <software ContextAttributes="used">MongoDB</software>, CouchDB, ArangoDB, to cite a few). This opens up for the opportunity of building a novel family of reasoners relying on query rewriting and NoSQL database technology. Indeed, these systems come with adapted data layouts, indexes, query algorithms, buffering, scheduling, and concurrent data access mechanisms among others. All these components can work together to make reasoning on JSON both efficient and scalable. Note that aiming at materialization on top of document stores would almost inevitably lead to data blowups and no scalability because of the tree data-model of JSON <ref type="bibr" target="#b66">[67]</ref>. For these systems, query rewriting is the prominent way to go.</p><p>Contribution. Designing a rewriting-based reasoner on NoSQL document stores has been very little investigated so far <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b66">67]</ref>. This task poses significant technical challenges, namely identifying ğ‘–) adequate languages for the task, together with ğ‘–ğ‘–) algorithms and optimizations to make query answering efficient and scalable.</p><p>Concerning the first point, to start with, one needs a query and rule language that is closed, i.e., it generates only rewritings that can be handled by the underlying NoSQL system. This is subtle, as NoSQL systems often ensure efficient access to data by reducing the expressivity of queries to rooted path-or tree-shaped queries or forbidding joins. Here, we shall present a language of constrained tree queries and rules enjoying this property. Then, the rewriting process must be finite, which can limit the use recursion in rules. Rewriting recursive rules (e.g., Datalog <ref type="bibr" target="#b7">[8]</ref>) is generally disregarded, and the typical solution is to restrict the language to ensure that the set of rewritings of any query is finite <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b37">38]</ref>. Here, we take another approach and rather try to cope with infinite rewriting sets, while encoding them finitely. Finally, query answering with the target rule language must have tractable data complexity (i.e., polynomial complexity in the size of the data) which is the minimum requirement for efficiency over large data <ref type="bibr" target="#b19">[20]</ref>.</p><p>Concerning the second point, to design algorithms and optimizations for efficient and scalable reasoning, we believe that query rewriting process cannot be agnostic to the underlying database. Therefore, our goal is to couple query rewriting with an innovative instance-aware evaluation strategy. This leverages on a combination of data-summaries, partitioning, and parallelization that allow us to achieve efficiency by distributing the evaluation of rewritings where the matching data is and at the same time achieving scalability on very large collections of JSON data thanks to the NoSQL facilities.</p><p>Summing up, our contributions are the following. 1. We introduce a novel language of constrained rules and queries for reasoning on JSON and present a (general) sound and complete query rewriting algorithm for this setting.</p><p>2. As reasoning with constrained rules is undecidable, we identify a relevant subset, made of relabeling and frontier-constrained rules, featuring decidable query answering with PTime data-complexity. We design an automata-based rewriting algorithm for such rules.</p><p>3. We propose a novel set of instance-aware evaluation techniques that -for a fixed database -allow one to efficiently evaluate large rewritings sets and also scale on large collections of data.</p><p>4. We present an extensive experimental analysis on large collections of several million JSON records showing the efficiency of our approach, and its scalability beyond state-of-the-art reasoners.</p><p>Paper Organization. We introduce our framework in Section 2 then give a high-level presentation of our query answering techniques (Sections 3 and 4). Sections 5 and 6 are devoted to formal developments on query rewriting algorithms. The experimental analysis is presented in Section 7. Section 8 discusses related work. Proofs and further details can be found in the technical report <ref type="bibr" target="#b68">[69]</ref>.</p></div>
<div><head n="2">FRAMEWORK</head><p>We begin by presenting an abstract setting for reasoning on JSON. We start by posing the notion of tree which will be used throughout the paper. Then, we introduce a new language made of constrained tree rules and queries and define their semantics.</p><p>Briefly, a JSON record is a set of key-value pairs, where a value is recursively defined as a terminal value (constant or null), a sequence of values, or a record. We see a record as a rooted labeled unordered tree, in which edges are labeled by keys, leaves are labeled by constant or null values, and all the internal nodes are unlabeled. Note that a key-value pair (ğ‘˜, ğ‘£) where ğ‘£ is a sequence is represented by edges labeled by ğ‘˜ leading to the nodes that represent the elements of ğ‘£. <ref type="foot" target="#foot_0">1</ref> Example 1.1 illustrates the tree vision of records.</p><p>Trees Let L and V be (infinite) sets of edge labels and (terminal) node values, respectively. A tree is a tuple ğ‘‡ = (N, E, ğ‘¡, ğœ† E , ğœ† N ) where N is a node set and E âŠ† N 2 is a non-empty edge set such that (N, E) is a directed tree with root ğ‘¡ âˆˆ N . Then, ğœ† E : E â†’ L is a (total) edge labeling function (for JSON keys) and ğœ† N : leaves(ğ‘‡ ) â†’ V âˆª {ğœ–} is a (total) leaf labeling function (for JSON terminal values), where leaves(ğ‘‡ ) âŠ† N is the set of leaves of the tree. We distinguish between valued leaves, which are those labeled by a value in V, and unvalued leaves labeled by ğœ–. The corresponding subsets are denoted by leaves V (ğ‘‡ ) and leaves ğœ– (ğ‘‡ ), respectively. Note that all edges are labeled, while only leaf nodes may be valued. Standard definitions about trees are extended in the obvious way. In particular, a subtree of a tree ğ‘‡ is a tree included in ğ‘‡ ; it is a roooted subtree of ğ‘‡ if it has the same root as ğ‘‡ .</p><p>Processing trees A leaf assignment of a tree ğ‘‡ is a function ğœˆ : leaves ğœ– (ğ‘‡ ) â†’ V whose application is defined as ğœˆ (ğ‘‡ ) = (N, E, ğ‘¡, ğœ† E , ğœˆ âŠğœ† N ). Next, given a function ğ‘“ , a set ğ´ = {ğ‘ 1 , . . . , ğ‘ ğ‘™ } and a sequence b = (ğ‘ 1 , . . . , ğ‘ ğ‘˜ ), we note ğ‘“ (ğ´) = {ğ‘“ (ğ‘ 1 ), . . . , ğ‘“ (ğ‘ ğ‘™ )} and ğ‘“ (b) = (ğ‘“ (ğ‘ 1 ), . . . , ğ‘“ (ğ‘ ğ‘˜ )). Let ğ‘‡ 1 and ğ‘‡ 2 be trees with ğ‘‡ ğ‘– = (N ğ‘– , E ğ‘– , ğ‘¡ ğ‘– , ğœ† Eğ‘– , ğœ† Nğ‘– ). A homomorphism from ğ‘‡ 1 to ğ‘‡ 2 is a total function â„ : N 1 â†’ N 2 such that: (i) for all ğ‘’ âˆˆ E 1 , â„(ğ‘’) âˆˆ E 2 and ğœ† E 1 (ğ‘’) = ğœ† E 2 (â„(ğ‘’)); and (ii) for all ğ‘› âˆˆ leaves V (ğ‘‡ 1 ), ğœ† N 1 (ğ‘›) = ğœ† N 2 (â„(ğ‘›)). A homomorphism â„ is rooted if â„(ğ‘¡ 1 ) = ğ‘¡ 2 . A homomorphism â„ from ğ‘‡ 1 to ğ‘‡ 2 is an isomorphism if â„ -1 is also a homomorphism (from ğ‘‡ 2 to ğ‘‡ 1 ).</p><p>Instances and rules An instance is simply a tree (like ğ‘‡ 1 ,ğ‘‡ 2 ,ğ‘‡ 3 in Figure <ref type="figure" target="#fig_0">1</ref>). To distinguish, we will call collection a set of trees. In pictures, edges are always considered as oriented from the root (black node) to the leaves. The body and the head of a rule are both trees, which share their root and some leaves; moreover, leaves in the body may be constrained, which means that they must be mapped to valued nodes in the data. Formally, a constrained tree-rule (or simply rule) is a triple ğ‘Ÿ = (B, H, C) where B and H are trees representing the body and head of ğ‘Ÿ , also denoted by Body(ğ‘Ÿ ) and Head(ğ‘Ÿ ), and C âŠ† leaves(B) is a (possibly empty) subset of leaves, said constrained; C is also denoted Constrained(ğ‘Ÿ ); ğµ and ğ» share the same root, and, beside the root, only leaves can be shared between B and H . The frontier of ğ‘Ÿ , denoted by frontier (ğ‘Ÿ ), is the set of nodes shared between B and H . Furthermore, frontier leaves (ğ‘Ÿ ) denotes the set of leaves of ğ‘Ÿ shared by B and H , i.e., frontier leaves (ğ‘Ÿ ) = leaves(B)âˆ©leaves(H ) âŠ‚ frontier (ğ‘Ÿ ). In the formal development, w.l.o.g, we assume no constants in the rules (in contrast with data and queries), that is, leaves</p><formula xml:id="formula_0">V (B) = âˆ… = leaves V (H ).</formula><p>Consider again the rules in Figure <ref type="figure" target="#fig_0">1</ref>. Rule ğ‘Ÿ 1 defines a highlevel notion of a push event. First, it verifies if structural conditions defined by the body are met in the data. That is, that a key type with value PushEvent is present, as well as an event id and the login of the user who made the event. Then, it checks for constrained nodes (marked with $ in the picture). That is, it verifies that id and login are associated with terminal values of V. Finally, it computes the result by copying these values within a new structure associated with the key push. Rules ğ‘Ÿ 2 and ğ‘Ÿ 3 are similar. Rule ğ‘Ÿ 4 states that the key push is a particular case of event. This rule is called a relabeling rule. Rules ğ‘Ÿ 5 and ğ‘Ÿ 6 are similar. Note that all frontier leaves are constrained in ğ‘Ÿ 1 -ğ‘Ÿ 3 , and none in ğ‘Ÿ 4 -ğ‘Ÿ 6 . Finally, a key feature of rules is that they may have non-frontier nodes in the head, called existential nodes. This is the case for ğ‘Ÿ 1 -ğ‘Ÿ 3 in Figure <ref type="figure" target="#fig_0">1</ref>, where existential nodes are marked in red. These nodes allow to reorganize extracted values into new structures. In this, our framework is leaning towards DatalogÂ±, which extends Datalog with existentially quantified variables <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b34">35]</ref>.</p><p>Rule Semantics As Figure <ref type="figure" target="#fig_0">1</ref> illustrates, the application of rules leads to an extended instance that we compactly see as a (rooted) acyclic graph. This is to simplify the formal development, in that acyclic graphs can always be unfolded into trees. Regardless, since we will focus on query rewriting, these extended instances never have to be computed, as they remain virtual. A trigger for a rule ğ‘Ÿ = (B, H, C) on an (extended) instance ğ¼ is a pair (ğ‘Ÿ, â„) where â„ is a (not necessarily rooted) homomorphism from B to ğ¼ respecting the constrained nodes, i.e., such that â„(C) âŠ† leaves V (ğ¼ ). The application of (ğ‘Ÿ, â„) to ğ¼ results in ğ¼ âˆª â„ + (H ), where â„ + âŠ‡ â„ is an extension of â„ mapping every non-frontier node of H to a fresh node. Given a set of rules Î , we denote by ğ›¼ (ğ¼, Î ) the instance obtained from ğ¼ by applying all triggers on ğ¼ in parallel, i.e., ğ›¼ (ğ¼, Î ) = ğ¼ âˆª â‹ƒï¸ (ğ‘Ÿ,â„) â„ + (H ) where ğ‘Ÿ âˆˆ Î  and (ğ‘Ÿ, â„) is a trigger on ğ¼ . Given an instance tree ğ‘‡ , we define Sat 0 (ğ‘‡ , Î ) = ğ‘‡ and Sat ğ‘–+1 (ğ‘‡ , Î ) = ğ›¼ (Sat ğ‘– (ğ‘‡ , Î )). Finally, the saturation of ğ‘‡ is Sat (ğ‘‡ , Î ) = â‹ƒï¸ âˆ ğ‘–=0 Sat ğ‘– (ğ‘‡ , Î ). This notion of saturation is also known as chase <ref type="bibr" target="#b7">[8]</ref> and is well-defined since the order in which the rule applications are performed has no incidence on the result (up to isomorphism).</p><p>Queries and Certain Answers A constrained tree-query is a triple ğ‘ = (ğ‘‡ , C, x) where ğ‘‡ is a tree, C âŠ† leaves(ğ‘‡ ) is a set of constrained leaves that must be mapped to valued nodes in the data, and x âˆˆ C |x| is a sequence of answer nodes. We also denote C by Constrained(ğ‘) and x by AnswerSeq(ğ‘). We assume valued leaves are always constrained, i.e., leaves V (ğ‘‡ ) âŠ† C. To illustrate, consider the query ğ‘ in Figure <ref type="figure" target="#fig_0">1</ref>. The only constrained node is the answer node (marked by ğ‘¥). Hence, this node must be mapped to constant values (here, "431" and "695"). A query ğ‘ is called Boolean if x = (). A tuple a âˆˆ V |x| is an answer to a query ğ‘ over an extended instance ğ¼ if there is a rooted homomorphism â„ from ğ‘‡ to ğ¼ such that ğœ† N â€¢ â„ (x) = a and â„(C) âŠ† leaves V (ğ¼ ), i.e., the leaf constraint is fulfilled. The set of answers to ğ‘ on ğ¼ is denoted by Ans(ğ‘, ğ¼ ). A tuple a is a (certain) answer to ğ‘ on ğ¼ and Î  if it is an answer to ğ‘ on Sat (ğ‘‡ , Î ). The set of all answers to ğ‘ on (ğ¼, Î ) is denoted by Ans(ğ‘, ğ¼, Î ). A query ğ‘ is more general than a query ğ‘ â€² , denoted by</p><formula xml:id="formula_1">ğ‘ â‰¥ ğ‘ â€² , if there is a rooted homomorphism â„ from ğ‘‡ ğ‘ to ğ‘‡ â€² ğ‘ such that â„(C ğ‘ ) âŠ† C ğ‘ â€² and â„(x ğ‘ ) = x ğ‘ â€² . A classical query containment property [8] holds here: ğ‘ â‰¥ ğ‘ â€² iff Ans(ğ‘ â€² , ğ¼ ) âŠ† Ans(ğ‘, ğ¼ ), for all ğ¼ .</formula><p>Query Rewritings. A sound and complete set of rewritings of ğ‘ wrt Î  is a set of queries Q such that, for every instance ğ¼ , it holds that Ans(ğ‘, ğ¼, Î ) = â‹ƒï¸ ğ‘ â€² âˆˆ Q Ans(ğ‘ â€² , ğ¼ ); in this equality, âŠ‡ expresses soundness, and âŠ† completeness. In words, Q must embarck all possible ways in which a query ğ‘ can be satisfied via the rules of Î . For example, Figure <ref type="figure" target="#fig_2">2</ref> illustrates a sound and complete rewriting set for ğ‘ of Example 1.1, made by the queries ğ‘, ğ‘ 1 , ğ‘ 2 , ğ‘ 3 , ğ‘ â€² 1 , ğ‘ â€² 2 , ğ‘ â€² 3 . In Section 3 we will show how our query rewriting algorithms exploit two features of rules. First, rules are tree-shaped, and this makes rewriting within the language of tree queries possible, thereby fitting the requirements of NoSQL APIs (a property one can loose beyond tree rules). Second, the applicability of a rule can be limited via constrained leaves, which, as shown later, will pave the way to decidability. As a last remark, note that, as the definition states, a sound and complete set of rewritings Q is independent of any input instance. This may lead to useless rewritings not matching the data, like ğ‘, ğ‘ 1 , ğ‘ 2 , ğ‘ 3 over the trees in Figure <ref type="figure" target="#fig_0">1</ref>. In Section 4 we will present an instance-aware mechanism to prune these efficiently.</p></div>
<div><head n="3">NEW QUERY REWRITING ALGORITHMS</head><p>As a first step towards effective query answering on NoSQL stores, we give a query rewriting algorithm for (general) constrained treerules. We revisit techniques developed for existential rules, based on so-called piece-unifiers <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b60">61]</ref>, also reminiscent of view-based query rewriting <ref type="bibr" target="#b70">[71]</ref>. Roughly speaking, a unifier is a node substitution (i.e., a function replacing nodes with nodes) that, as the name suggests, makes part of a query equal to part of a rule head. A pieceunifier checks further structural constraints that are necessary for the soundness of rewriting when the rule head features existential nodes, as the rules ğ‘Ÿ 1 -ğ‘Ÿ 3 from Figure <ref type="figure" target="#fig_0">1</ref>. Given a piece-unifier of a query ğ‘ with a rule ğ‘Ÿ , a rewriting step produces a new query by substituting the unified part of ğ‘ with the body of ğ‘Ÿ . Then, given a q' 1 q' 2 q' 3 4 r 5 r 6 r 1 r 2 r 3 set of rules Î , a Î -rewriting of ğ‘ is a query obtained by a sequence of rewriting steps with rules from Î . E.g., each query in Figure <ref type="figure" target="#fig_2">2</ref> is a Î -rewriting of ğ‘, with Î  the rule set of Figure <ref type="figure" target="#fig_0">1</ref>.</p><p>The contribution of this work is to identify a restricted class of piece-unifiers, called (semi-)twig-unifiers, which have the nice property of producing tree-shaped rewritings as we sought. <ref type="foot" target="#foot_1">2</ref> The formal development of semi-twig query rewriting is presented in Section 5. This tool allows us to compute a set of rewritings of a query, whose soundness and completeness is stated as follows.</p></div>
<div><head>Theorem 3.1 (Soundness and Completeness of Rewriting).</head><p>For any query ğ‘, instance ğ‘‡ , and set of constrained tree-rules Î , a âˆˆ Ans(ğ‘,ğ‘‡ , Î ) iff there is a Î -rewriting ğ‘ â€² of ğ‘ such that a âˆˆ Ans(ğ‘ â€² ,ğ‘‡ ).</p><p>Hence, semi-twig query rewriting allows one to compute a finite sound and complete set of rewritings when such set exists. And indeed, there are rule sets and queries that only admit infinite sound and complete sets of rewritings (even modulo query containment). This can happen already with simple rules, as shown by Figure <ref type="figure" target="#fig_3">3</ref>. Query ğ‘ searches for projects forkedFrom a repository owned by the keras-team. By rewriting ğ‘ with the rules ğ‘Ÿ 1 and ğ‘Ÿ 2 , one builds paths of arbitrary length along the key from. All of the obtained queries are incomparable to each other w.r.t. query containment, hence the only sound and complete rewriting set here is infinite. This raises the issue of algorithmic feasibility for query answering.</p></div>
<div><head n="3.1">Taming Infinite Rewritings</head><p>In spite of an apparent simplicity, query answering with constrained tree-rules is undecidable. This has been shown already for the specific case of (unconstrained) path rules in various settings <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b39">40]</ref>. This negative result opens the quest for decidable rule languages for reasoning on JSON data. Strategies for recovering decidability include the use of acyclicity notions or syntactic conditions ensuring the termination of (forward or) backward chaining <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b45">46]</ref>. Here, we take a different approach. We consider a language with non-terminating (both forward and) backward chaining, but ensuring that the rewritings of a query can always be finitely captured. We draw inspiration from the language of so-called suffix path-rules proposed in <ref type="bibr" target="#b22">[23]</ref> and lift it to the case of trees, which yields a specific constrained tree-rule fragment we call frontier-constrained rules. Crucially, this fragment makes the rewritings of a query forming a regular tree-language one can capture with automata techniques.</p><p>A Tractable Fragment. We consider combinations of 1) frontierconstrained rules and 2) relabeling rules, which are defined next. Definition 3.2. Let ğ‘Ÿ = (B, H, C) be a constrained tree-rule. Then:</p><p>â€¢ ğ‘Ÿ is frontier-constrained if frontier leaves (ğ‘Ÿ ) âŠ† C â€¢ ğ‘Ÿ is relabeling if B and H are edges and frontier leaves (ğ‘Ÿ ) â‰  âˆ…</p><p>In Figure <ref type="figure" target="#fig_0">1</ref>, ğ‘Ÿ 3 -ğ‘Ÿ 6 are frontier-constrained rules while ğ‘Ÿ 1 -ğ‘Ÿ 4 are relabeling rules. Frontier-constrained rules impose that a trigger maps all the frontier leaves of the rule to data values, but without any further condition on the use of recursion. From a practical viewpoint, they allow one to select values in the data and to reorganize them into structures adapted to the targeted application. Relabeling rules are among the most useful rules for reasoning on trees, as they allow one to define hierarchies of keys. In contrast with frontierconstrained rules, they apply anywhere on a tree instance.</p><p>The decidability of query answering for this fragment follows from a natural translation into first-order logic. Constrained queries and rules are translated into tree-shaped conjunctive queries and existential rules, respectively. Frontier-constrained and relabeling rules are more specifically translated into a decidable fragment of existential rules called body-acyclic frontier-guarded <ref type="bibr" target="#b16">[17]</ref>. For this, we obtain that query answering is in ExpTime for combined complexity <ref type="bibr" target="#b35">[36]</ref>. Our framework can also be translated into a specific description logic, namely ELH V <ref type="bibr" target="#b62">[63]</ref>, which furthermore allows one to derive a PTime upper bound for data complexity. Note however that these complexity results do not make use of query rewriting. By relying on the tree-automata rewriting described next, we will design a query answering technique that effectively runs in polynomial time w.r.t. the size of the data.</p></div>
<div><head>Capturing Infinite Rewritings With Automata</head><p>A key feature of our (general) query rewriting algorithm is that, when rules are frontier-constrained, it is ensured in any direct rewriting of ğ‘ that a single node is shared between the remaining part of ğ‘ and the subtree coming from the rule body. Hence, we fall into an even more specific case of unifiers we call twig-unifiers. As a consequence, infinite sets of rewritings such as those illustrated in Figure <ref type="figure" target="#fig_3">3</ref> can be captured by a tree automaton <ref type="bibr" target="#b43">[44]</ref>. In a nutshell, the constructed automaton is made of sub-automata that encode the initial query ğ‘ as well as all the specializations of rule bodies that can be involved in a rewriting step. This set of sub-automata is finite as there is a finite number of (non-equivalent) specializations for each rule body. Transitions between states of different sub-automata allow to encode rewritings. The detailed construction is provided in Section 6 and its adequacy now stated (follows by Theorem 6.2). Theorem 3.3. Let Î  be a set of frontier-constrained and relabeling rules and ğ‘ be a query. Then, there exists a finite tree automaton A recognizing a sound and complete set of rewritings of ğ‘ w.r.t. Î .</p></div>
<div><head n="4">INSTANCE-AWARE EVALUATION</head><p>The automata approach gives us a ground for query answering but still does not suffice, in practice, to exploit NoSQL databases. Evidently, no database API will take an automaton as a query. Tree queries are instead accepted. Concretely, this means that the automaton language has to be enumerated, and that every single query in a rewriting set has to be evaluated. We are thus facing two issues. First, we need to deal again with the case where rewriting sets are infinite. Second, we need to cope with rewriting sets that are finite but possibly large. To tackle these problems, we extend our query rewriting approach to make it instance-aware, and more specifically able to leverage on structural information of data for the sake of query answering. Our approach consists in using a novel combination of ğ‘–) summarization techniques to make rewritings finite and ğ‘–ğ‘–) partitioning and parallelization techniques for efficiency. Summarization. To always reduce rewritings to finite sound and complete sets -for a given database instance -we use summaries of data. In theory, it is sufficient to know the size of the data, as the automaton allows one to enumerate queries by their size. So, once exceeded the size of data, enumeration can be safely stopped. This rough bound can be improved by considering only the depth of data as nodes in a rewriting have a bounded outdegree (Theorem 6.2).</p><p>In practice, however, as rewriting is independent of the instance, this can generate many queries that are not matching any data. So we consider a data summary built on the set of maximal paths (root to leaf), i.e., a dataguide <ref type="bibr" target="#b52">[53]</ref>. When we enumerate the automaton language we can use this information to discard some empty queries by checking whether the tree query we are generating contains an invalid path according to the summary. For instance, the set of maximal paths of the trees in Figure <ref type="figure" target="#fig_0">1</ref> is</p><formula xml:id="formula_2">(date) (id) (type) (actor â€¢ login) (payload â€¢ commits â€¢ author) (payload â€¢ issue â€¢ user)</formula><p>Obviously, any rewriting featuring a path that is not in this list can be discarded, as it will have no answer on the collection. Summaries can sometimes be simplified when there is little ambiguity in the data, by considering only the depth and the set of edge labels. For the collection of Figure <ref type="figure" target="#fig_0">1</ref> these labels are {date, id, type, actor, login, payload, commits, issue, author, user}. The label summary is less precise but more compact. Paths can also be enriched with ğ‘˜-length prefixes of the values found at their end. For instance, with ğ‘˜ = 5, we can associate the value "gvanr" to path payload.commits.author instead of gvanrossum. This can help in filtering queries which use values not found in the data. Working with ğ‘˜-prefixes instead of the values themselves enables more concise summaries while retaining the precision of filtering. So, the path (dataguide), label, and path+prefix will be the three main summaries we consider. All can be used to filter empty queries in the automaton language, and hence to reduce the (possibly infinite) set of rewritings of a query to a finite and still complete set (for the given instance). Furthermore, they can all be computed with a linear traversal of the data, and are typically of limited size. We will use the depth summary as a baseline. We did not consider bisimilarity-based summaries <ref type="bibr" target="#b54">[55]</ref> as they tend to be quite large and more complex to compute; the label and path summaries also proved to be quite effective.</p><p>Partitioning and Parallelization Even if finite, rewriting sets can be hard to evaluate for any database because of the number of queries they may contain. To improve the situation, our intuition is that we must provide a mean to lead the single queries (within a rewriting set) where the matching data is. With this aim, we define an instance-aware reasoning strategy based on partitioning. In doing so, we therefore introduce a pre-processing of a collection providing means for the efficient evaluation of large rewriting sets.</p><p>Let ğ½ = {ğ‘‡ 1 , . . . ,ğ‘‡ ğ‘› } be a (single) collection of tree instances. Our goal is to define a set of collections ğ½ 1 , . . . , ğ½ ğ‘˜ making for a partitioning of ğ½ . We adopt a simple partitioning function oriented towards rooted queries, defined as follows: Î› ğ‘‘ (ğ‘‡ ) = Î  ğ‘‘ ğ‘–=1 labels ğ‘– (ğ‘‡ ). The function Î› ğ‘‘ (ğ‘‡ ) concatenates the labels of edges at each level (we denote by labels ğ‘– (ğ‘‡ ) the labels of edges going from level ğ‘–-1 to level ğ‘– in ğ‘‡ ) up to the depth set by the parameter ğ‘‘; Î› ğ‘‘ (ğ‘‡ ) is then mapped to an integer denoting the partition number of ğ‘‡ . So, two trees ğ‘‡ 1 ,ğ‘‡ 2 will be in the same partition ğ½ ğ‘– if Î› ğ‘‘ (ğ‘‡ 1 ) = Î› ğ‘‘ (ğ‘‡ 2 ), meaning that they just agree on the set of labels they use level-wise, up to depth ğ‘‘. Note that for Î› ğ‘‘ the number of partitions is not fixed in advance, and rather depends on ğ‘–) the data and ğ‘–ğ‘–) the parameter ğ‘‘. The function Î› ğ‘‘ could also be replaced by more complex clustering functions for trees also taking care of load balancing <ref type="bibr" target="#b9">[10]</ref>; exploring this range of possibilities is however beyond the scope of this work. Note that Î› ğ‘‘ (ğ‘‡ ) can be computed in linear time at the moment when data is loaded into the database.</p><p>The first net advantage of partitioning is that, instead of a rough summarization for the whole collection, we can deploy a set of narrower data-summaries, one for each partition ğ½ ğ‘– . This obviously leads to a greater filtering power. With this scheme, the queries within a rewriting are more likely to be evaluated on the partitions where they can have a match, according to the summary, instead of being evaluated against the whole database. The use of rewriting, summarization, and partitioning is shown in Figure <ref type="figure" target="#fig_4">4</ref>: A rewriting automaton A (ğ‘,Î ) is built from a query ğ‘ and a set of rules Î . A collection ğ½ is partitioned into the collections ğ½ 1 , . . . , ğ½ ğ‘˜ . For every partition ğ½ ğ‘– , the language of A (ğ‘,Î ) is filtered by Summary(ğ½ ğ‘– ). This produces a finite set of queries Q |Summary(ğ½ ğ‘– ) to evaluate on ğ½ ğ‘– .</p><p>Partitioning can be implemented in several ways. Here, we consider physical partitioning, where a distinct database collection is built for every partition. Using a logical partitioning strategy is discussed in <ref type="bibr" target="#b68">[69]</ref> and proved to have similar effectiveness. Finally, with partitioning in place, parallelization can further be added to attack all of these partitions simultaneously by leveraging on the concurrent data access facilities of the underlying database.</p><p>Let us point out that assuming data-awareness is not a strong hypothesis in practice. For instance, data-awareness is implicit in the fact of running a materialization algorithm. Also note that a summary does not capture a single instance, but rather abstracts over a class of instances. Instance-aware query rewriting is evaluated in Section 7. The following sections (5 and 6) present our query rewriting algorithms. The goal of this section is to present semi-twig based unification and query rewriting. As already mentioned, we revisit techniques developed for existential rules, based on so-called piece-unifiers <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b60">61]</ref>. To begin, we need to introduce a key notion, that of separating node. Let ğ‘‡ be a tree and ğ‘† be a subtree of ğ‘‡ . We denote by (ğ‘‡ \ ğ‘†) the forest obtained by removing from ğ‘‡ all edges in ğ‘†. Then, the nodes that belong to both ğ‘† and (ğ‘‡ \ ğ‘†) are said to separate ğ‘† from ğ‘‡ . In other words, these are the nodes of ğ‘† that have their parent or one of their children in (ğ‘‡ \ ğ‘†). Figure <ref type="figure" target="#fig_5">5</ref> pictures a tree ğ‘‡ with four subtrees ğ‘† 1 , ğ‘† 2 ,ğ‘‡ â€² ,ğ‘‡ â€²â€² . The nodes marked with S are separating for at least one subtree. The subtrees ğ‘† 1 (in blue), ğ‘† 2 (in brown) and ğ‘‡ â€² (in red) have the same root as ğ‘‡ . For all of these subtrees the root is separating; indeed the root has other children that do not belong to the subtree. The root of ğ‘‡ â€²â€² (in red) is separating, this time because its parent does not belong to ğ‘‡ â€²â€² . Note that ğ‘† 2 also has a separating leaf and ğ‘‡ â€² also has a separating internal node.</p><p>To simplify definitions, we now assume that the root of a rule head has a single child. This can be done without loss of generality since every rule can be decomposed into an equivalent set of rules satisfying this assumption <ref type="bibr" target="#b68">[69]</ref>.</p><p>Definition 5.1 (Semi-twig). A subtree ğ‘† of ğ‘‡ is called semi-twig if:</p><p>(1) the root of ğ‘† has exactly one child (2) any node separating ğ‘† from ğ‘‡ is either the root of ğ‘† or a leaf of ğ‘† (i.e., no internal node of ğ‘† is separating).</p><p>A semi-twig without separating leaves is called a twig.</p><p>Consider again ğ‘‡ in Figure <ref type="figure" target="#fig_5">5</ref>. Then, ğ‘† 1 is a twig as its only separating node is the root, and ğ‘† 2 is a semi-twig as it has a separating leaf. Finally, ğ‘‡ â€² and ğ‘‡ â€²â€² are not semi-twigs, since ğ‘‡ â€² has an internal separating node and the root of ğ‘‡ â€²â€² has two children. The intuition behind semi-twigs is that these are the parts of the query that can be easily rewritten (Item (1)) while preserving tree-shaped rewritings (Item (2)). We are now ready to define semi-twig unification. Definition 5.2 (Semi-Twig Unification). A semi-twig-unifier ğœ‡ for a constrained query ğ‘ and a (general) constrained rule ğ‘Ÿ is a triple (ğ‘†, H, ğœˆ, ğ‘¢) where:</p><p>â€¢ ğ‘† is a semi-twig of ğ‘ â€¢ H is a rooted subtree of Head(ğ‘Ÿ ) â€¢ ğœˆ is a leaf assignment for the nodes in frontier leaves (ğ‘Ÿ ) â€¢ ğ‘¢ is a rooted homomorphism from ğ‘† to ğœˆ (H ) such that ğ‘¢ (ğ‘†) = ğœˆ (H ) and ğ‘¢ maps:</p><p>(1) each constrained leaf of ğ‘† to a frontier leaf of ğ‘Ÿ (2) each separating leaf of ğ‘† to an unconstrained frontier leaf of ğ‘Ÿ .</p><p>Although the definition of semi-twig unification may seem somewhat involved, it is perfectly natural. The goal is to identify part of the query (i.e., ğ‘†) that is entailed by the application of the rule ğ‘Ÿ . Rewriting will then replace this part by a suitable specialization of the body of ğ‘Ÿ that reflects the way in which the rule is applied. This is captured first by the rooted homomorphism from ğ‘† to a leaf assignment of H . This leaf assignment may only assign to a frontier node in ğ‘Ÿ a value from ğ‘†, since ğ‘¢ (ğ‘†) = ğœˆ (H ). By the homomorphism ğ‘¢, a leaf of ğ‘† is necessarily mapped to a leaf of H . Then, Conditions (1) and ( <ref type="formula">2</ref>) ensure the correctness of rewriting.</p><p>In the next definition of a direct rewriting, the union of the trees ğ‘¢ (ğ‘ \ ğ‘†) and ğœˆ (Body(ğ‘Ÿ )) is defined in the obvious way (i.e, by making the union of the node sets, the edge sets and the functions) and it can be checked that it results in a tree. Definition 5.3 (Semi-Twig Rewriting). Let ğœ‡ = (ğ‘†, H, ğœˆ, ğ‘¢) be a semi-twig-unifier for a constrained query ğ‘ and a (general) constrained rule ğ‘Ÿ . A direct rewriting of ğ‘ with ğœ‡ is a query ğ‘ rew = (ğ‘‡ , C, x) such that:</p><formula xml:id="formula_3">â€¢ ğ‘‡ = ğ‘¢ (ğ‘ \ ğ‘†) âˆª ğœˆ (Body(ğ‘Ÿ )) â€¢ C = ğ‘¢ (Constrained(ğ‘)) âˆª Constrained(ğ‘Ÿ ) â€¢ x = ğ‘¢ (AnswerSeq(ğ‘)).</formula><p>Proposition 5.4 (Closedness). ğ‘ rew is a constrained tree query.</p><p>Let us come back to Conditions (1) and ( <ref type="formula">2</ref>) of semi-twig unification and illustrate them with the query ğ‘ and rules ğ‘Ÿ 1 and ğ‘Ÿ 2 from Figure <ref type="figure" target="#fig_5">5</ref>. Both rules have a constrained leaf in their body. This leaf is frontier for ğ‘Ÿ 1 , but not for ğ‘Ÿ 2 . Hence, an application of ğ‘Ÿ 1 only brings a new edge, while an application of ğ‘Ÿ 2 also brings a new node. One could consider unifying the semi-twig ğ‘† â€² 1 constituted by the sole edge labeled by a. Note that the leaf of ğ‘† â€² 1 is separating, hence can only be mapped to an unconstrained frontier leaf. Unifying ğ‘† â€² 1 with ğ‘Ÿ 1 would violate Condition (2) because the frontier leaf of ğ‘Ÿ 1 is constrained (and the associated rewriting would not be a well-formed query, as it would have an internal constrained node). Unifying ğ‘† â€² 1 with ğ‘Ÿ 2 would also violate Condition (2) because the leaf of Head(ğ‘Ÿ 2 ) is not frontier (and the associated rewriting would not be a well-formed query, as it would be disconnected, and would furthermore be unsound). Now, consider the twig ğ‘† â€² 2 . It can be unified with ğ‘Ÿ 1 thereby yielding the query ğ‘ rew ğ‘Ÿ 1 . However, ğ‘† â€² 2 cannot be unified with ğ‘Ÿ 2 because Condition (1) would be violated (and the associated rewriting would be unsound). Finally, we say that ğ‘ rew is a Î -rewriting of ğ‘ if there is a sequence ğ‘ = ğ‘ 0 , ğœ‡ 1 , ğ‘ â€² 1 , ..., ğœ‡ ğ‘˜ , ğ‘ â€² ğ‘˜ = ğ‘ rew such that ğ‘ ğ‘– is a direct rewriting of ğ‘ ğ‘–-1 with ğœ‡ ğ‘– using a rule of Î  and ğ‘ â€² ğ‘– = (ğ‘ ğ‘– ) safe , where â€¢ safe is a function replacing all nodes of ğ‘ ğ‘– by fresh nodes (1 â‰¤ ğ‘– â‰¤ ğ‘˜). This is merely a technicality, but it is needed to avoid multiple uses of the same node if ğ‘Ÿ is used multiple times in a rewriting sequence. The soundness and completeness of query rewriting ensures that for any query ğ‘, instance ğ‘‡ , and set of constrained tree-rules Î , a âˆˆ Ans(ğ‘,ğ‘‡ , Î ) if and only if there is a Î -rewriting ğ‘ â€² of ğ‘ such that a âˆˆ Ans(ğ‘ â€² ,ğ‘‡ ) (as stated by Theorem 3.1). From this, we can easily build a breadth-first query rewriting operator in the spirit of <ref type="bibr" target="#b60">[61]</ref> that terminates if and only the query admits a finite sound and complete set of rewritings. However, this still leaves the case of infinite rewritings open. An important remark can be made about 2) on which we will focus in the next section.</p><p>Remark 1. Let (ğ‘†, H, ğœˆ, ğ‘¢) be a semi-twig unifier for a query ğ‘ and a frontier-constrained rule ğ‘Ÿ . Then, ğ‘† must be a twig.</p><p>For instance, in Figure <ref type="figure" target="#fig_5">5</ref>, both rules are frontier-constrained, hence ğ‘† â€² 1 can be disregarded for rewriting as it is not a twig.</p></div>
<div><head n="6">AUTOMATA-BASED QUERY REWRITING</head><p>Frontier-constrained rules do not ensure the finiteness of rewriting sets (nor of saturation). However, they have the following key property: the rewriting set of a query under frontier-constrained rules can be characterized by a regular tree language. This means that it can be compactly represented by a tree automaton. Frontierconstrained tree rules generalize context-free path rules in <ref type="bibr" target="#b22">[23]</ref> which are in turn related to suffix-rewriting systems <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b71">72]</ref>. What paves the way for regularity is that frontier-constrained rules make any semi-twig unifier for the query to be necessarily a twig-unifier (Remark 1). Another important insight is that adding relabeling rules (which, in contrast, requires semi-twig unifiers that may not be twig unifiers) still preserves regularity, and so both types of rules can be taken into account jointly. The goal of this section is to present the construction of the automaton A (ğ‘,Î ) recognizing a sound and complete set of rewritings for a query ğ‘ against a set of rules Î . We start by posing the notion of tree automaton needed to capture the rewritings of a query. This follows standard models <ref type="bibr" target="#b43">[44]</ref> adapted to the case of unordered trees. Definition 6.1 (Automaton). A bottom-up automaton for unordered trees is a tuple A = (Î£, S, L, F , Î”) where:</p><p>â€¢ Î£ is an alphabet â€¢ S is a set of states made of S ğ¸ a set of edge-states and S ğ‘ a set of node-states â€¢ L, F âŠ† S ğ‘ are sets of initial (leaves) and final (root) states</p><formula xml:id="formula_4">â€¢ Î” is a set of transitions made of Î” L âŠ† (ï¸ Î£ âˆª {ğœ–} )ï¸ Ã— L a set of leaf nodes transitions Î” ğ¸ âŠ† S ğ‘ Ã— Î£ Ã— S ğ¸ a set of edge transitions Î” ğ‘ âŠ† 2 S ğ¸ Ã— S ğ‘</formula><p>a set of (non-leaf) node transitions A run of A on ğ‘‡ = (N, E, ğ‘¡, ğœ† E , ğœ† N ) is a function ğœŒ : N â†’ S ğ‘ that agrees with the transition rules of A, in the following sense.</p><p>â€¢ Every unlabeled leaf â„“ of ğ‘‡ is recognized by a Î” L -transition</p><formula xml:id="formula_5">âˆ… ğœ– -â†’ ğœŒ (â„“) â€¢ Every labeled leaf â„“ of ğ‘‡ is recognized by a Î” L -transition âˆ… ğœ† N (â„“) -â†’ ğœŒ (â„“)</formula><p>â€¢ Every (non-leaf) node ğ‘› of ğ‘‡ with children ğ‘› 1 , . . . , ğ‘› ğ‘˜ is recognized by the following Î”-transitions {s 1 . . .</p><formula xml:id="formula_6">s ğ‘˜ } -â†’ ğœŒ (ğ‘›) âˆˆ Î” ğ‘ ğœŒ (ğ‘› ğ‘– ) ğœ† E (ğ‘›,ğ‘› ğ‘– ) --â†’ s ğ‘– âˆˆ Î” ğ¸</formula><p>provided that s ğ‘– â‰  s ğ‘— for all 1â‰¤ğ‘–â‰ ğ‘— â‰¤ğ‘˜ â€¢ The root ğ‘¡ of ğ‘‡ is such that ğœŒ (ğ‘¡) is a final state in F An automaton defines a language (or set) of unordered trees L(A).</p><p>The automata framework represents tree languages, but is insensitive to query features such as constrained and answer nodes. So, to proceed, we must define an encoding of a query ğ‘ as a "plain" tree encode(ğ‘) that can manipulated by automata. The idea of the encoding is to store information on constrained and answer leaf nodes as values. The encoding must essentially cover three cases. The first is where the leaf is unconstrained. The second is where the leaf is constrained but does not belong to the answer sequence. The third is where the leaf belongs to the answer sequence (so, by definition, is also constrained). Figure <ref type="figure" target="#fig_8">6</ref> (left) shows a query ğ‘ â€² as well as its corresponding automaton A encode(ğ‘ â€² ) . The query seeks for forked projects (forkee) for all records describing a ForkEvent which also includes the project from which fork originated (forkedFrom). The query has three leaf nodes, which are recognized by three initial states of the automaton. Each initial state is used to define a non-leaf node transition âˆ… -â†’ e ğ‘– where ğ‘˜ 1 = type, ğ‘˜ 2 = forkee, and ğ‘˜ 3 = forkedFrom. Each transition recognizes an edge of the query. Finally, the non-leaf node transition {e 1 , e 2 , e 3 } -â†’ s final allows A encode(ğ‘ â€² ) to recognize the whole tree. Due to space constraints, the formal construction of the automata encoding of queries is detailed in <ref type="bibr" target="#b68">[69]</ref>. The example of Figure <ref type="figure" target="#fig_8">6</ref> illustrates that it is straightforward to build an automaton A ğ‘‡ recognizing a tree ğ‘‡ which is also minimal (i.e., without useless state or transition). We can do so by creating distinct states and transitions for every (1) node label, (2) edge, and (3) internal node of ğ‘‡ . This handling of (un)constrained, valued, and answer nodes, also extends to the encoding of rule bodies introduced from single rewriting steps <ref type="bibr" target="#b68">[69]</ref>. In the remainder of the section, the encoding of a query ğ‘ and of a rule body ğµ specialized by a unifier ğœ‡ are denoted by encode(ğ‘) and encode(ğœ‡ (ğµ)), respectively. This is at the basis of the rewriting process described next.</p><p>Building the Rewriting Automaton Remind that our goal is to construct an automaton A (ğ‘,Î ) recognizing the set of rewritings of a query ğ‘ against a set of rules Î . For clarity, we present the construction of A (ğ‘,Î ) in two steps. First, we provide a declarative construction, showing (ğ‘–) the main steps of the process as well as its connections to the general query rewriting from Section 5 and (ğ‘–ğ‘–) the finiteness of A (ğ‘,Î ) . In the second step, we outline how to also achieve a terminating algorithm. Aencode(q' A(q, {r }) . In there, we do some standard assumptions. First, when constructing an automaton A ğµ from a specialized rule body, we use a fresh set of states. The Extend operation makes the union of two automata A (ğ‘,Î ) = (Î£, S, L, F , Î”) and A ğµ = (Î£ ğµ , S ğµ , L ğµ , F ğµ , Î” ğµ ) but gives precedence to the final state of A (ğ‘,Î ) by returning (Î£ âˆª Î£ ğµ , S âˆª S ğµ , L âˆª L ğµ , F , Î” âˆª Î” ğµ ). Finally, as we work with automata that have a single final state, we denote by s final A the final state of A. Figure <ref type="figure" target="#fig_8">6</ref> (right) illustrates the rewriting of the query ğ‘ presented in Figure <ref type="figure" target="#fig_3">3</ref> with rules ğ‘Ÿ 1 and ğ‘Ÿ 2 . Recall that query ğ‘ searches for projects forkedFrom a repository owned by the keras-team. The query has an infinite rewriting set, which is captured as follows. The process starts by initializing A (ğ‘,Î ) as the automaton for encode(ğ‘). A twig-unifier ğœ‡ for ğ‘Ÿ 2 and ğ‘ is found (steps 3 and 4). Remark that ğœ‡ unifies a twig of the query (actually, the path forkedFrom.owner) with a twig of the rule head. This leads to the extension of A (ğ‘,Î ) with a fresh sub-automaton for encode(ğœ‡ (Body(ğ‘Ÿ 2 ))) (step 5). Also this yields a a novel non-leaf node transition {e 1 , e 2 , e 5 }-â†’s final ğ‘ (step 6) resulting from replacing e 3 by e 5 in {e 1 , e 2 , e 3 }-â†’s final ğ‘ . In Figure <ref type="figure" target="#fig_8">6</ref>, abusing of notation, we picture this with an edge from e 5 to e 3 . At this point, b the relabeling rule ğ‘Ÿ 1 is applied to the fresh sub-automaton (step 2). This in turn yields a new twig-unifier ğœ‡ â€² for ğ‘Ÿ 2 (steps 3, 4). As encode(ğœ‡ (Body(ğ‘Ÿ 2 ))) = encode(ğœ‡ â€² (Body(ğ‘Ÿ 2 ))), no extension of A (ğ‘,Î ) is performed at this time (step 5). However, c a novel non-leaf node transition {e 5 }-â†’s 5 (step 6) capturing the infinite recursion stemming from the rules ğ‘Ÿ 1 and ğ‘Ÿ 2 is added. The correctness of the construction is now stated <ref type="bibr" target="#b68">[69]</ref>. Theorem 6.2 (Soundness and Completeness). Let Î  be a set of frontier-constrained and relabeling rules. For every tree ğ‘‡ and query ğ‘ we have that â‹ƒï¸ encode(ğ‘ â€² ) âˆˆL(A (ğ‘,Î ) ) Ans(ğ‘‡ , ğ‘ â€² ) = Ans(ğ‘‡ , ğ‘, Î ). Also, A (ğ‘,Î ) is finite and its language is made by trees of bounded rank.</p></div>
<div><head>All-at-Once Twig-Unification</head><p>To turn our declarative construction into a terminating algorithm we have to provide a finite procedure for the enumeration of all possible queries and twigunifiers (steps 3 and 4) which may loop when A (ğ‘,Î ) recognizes an infinite language. And indeed, it is possible to manipulate these unifiers all-at-once by directly working on the states of A (ğ‘,Î ) . So, instead of considering every possible query ğ‘ â€² recognized by A (ğ‘,Î ) and every possible twig ğ‘† of ğ‘ â€² we do the following. First, we iterate on the (finite) set of rooted twigs H that belong to the head of the rules in Î . Then, for each H , we iterate on the (finite) set of node-states s of A (ğ‘,Î ) . For every H and s, we check if A (ğ‘,Î ) (s)  (that is, the automaton A (ğ‘,Î ) where the final state is set to be s) recognizes a tree ğ‘‡ such that ğ‘† is a rooted twig of ğ‘‡ and there are ğ‘¢ and ğœˆ such that ğ‘¢ (ğ‘†) = ğœˆ (H ). Because H is finite this can be done in a finite number of steps. In this way, we can capture all unifiers ğœ‡ representing a possibly infinite class of unifiers. Once A (ğ‘,Î ) built, it is possible to perform a single post-order traversal of an instance ğ‘‡ to compute answer to queries <ref type="bibr" target="#b68">[69]</ref>. This adapts classical validation algorithms from <ref type="bibr" target="#b43">[44]</ref>. Follows a PTime data-complexity upper-bound for query answering. The construction is independent from data. Moreover, it can be boostrapped independently from queries. Indeed, the unifiers that hold between the rules only, as those for ğ‘Ÿ 1 and ğ‘Ÿ 2 in Figure <ref type="figure" target="#fig_8">6</ref>, can be precomputed off-line thus reducing rewriting costs at query time.</p></div>
<div><head n="7">EXPERIMENTAL ANALYSIS</head><p>Implementation We implemented our approach for reasoning over document stores in a Java 11 tool: <software ContextAttributes="used">TreeForce (TF)</software>. This library can be seen as a general toolbox for implementing reasoning techniques for tree-shaped data and rules. The tool has been coded from scratch. It is composed of two main modules. The first includes generic data structures and algorithms for trees and tree-automata. The second includes our instance-aware query rewriting and evaluation methods. <software ContextAttributes="used">TreeForce</software> also includes a translation module tied to the target DBMS. We deployed our system on top of a well-known NoSQL database: <software ContextAttributes="used">MongoDB</software> (v5.0.8). Our approach can be ported to systems supporting constrained tree-queries, which is a basic requirement for many stores <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b57">58,</ref><ref type="bibr" target="#b69">70]</ref>. Query translation as well as the deployment on other systems is discussed in <ref type="bibr" target="#b68">[69]</ref>.</p><p>Environment We performed all experiments on a machine with an AMD Ryzen 9 3900XT CPU (4.7 Ghz, 12 cores), 128GB DDR4 2400Mhz memory and 2TB SSD disk, running KDE neon on ext4 FS. By relying on <software>MongoDB</software>, <software ContextAttributes="used">TreeForce</software> has modest memory requirements. We allocated only 10GB memory to the JVM (jdk16). We used <software ContextAttributes="used">MongoDB</software> standard configuration with 8GB cache size.</p><p>Benchmarks used for our study are shown in Table <ref type="table" target="#tab_1">1</ref>. We defined three benchmarks from known benchs: DBLP JR , GitHub JR and <software ContextAttributes="used">XMark</software> JR (JR, for JSON Reasoning). DBLP and GitHub are large corpus of real data. <software ContextAttributes="used">XMark</software>, in contrast, is a synthetic benchmark but equipped with a data generator that helped us in better understanding the scalability question. Both DBLP and <software ContextAttributes="used">XMark</software> come as XML; they have been translated into JSON to feed document stores. These systems are oriented towards the exploitation of limited size records (e.g., 16MB for <software ContextAttributes="used">MongoDB</software>). So, XML trees have been shredded into a collection of JSON records in a standard way, that is, by recording the main objects of the original data in different records (e.g., one record per publication in DBLP JR ). DBLP JR and GitHub JR are tests over several million real world records. For DBLP JR we used 22 queries containing a mix of tree queries of different complexity inspired from those in <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b51">52]</ref>. We manually defined a set of 51 rules with 15 frontier-constrained rules and 36 relabeling rules inspired both from the DBLP ontology (dblp.org/rdf/schema) and <ref type="bibr" target="#b29">[30]</ref>. For GitHub JR we defined 5 queries of different complexity and 54 tree-rules including 40 frontier-constrained and 14 relabeling.</p><p>Overall, these allowed us to gauge our approach on real voluminous data. <software ContextAttributes="used">XMark</software> JR includes a set of 115 distinct JSON collections (up to several million records), 23 rulesets (containing 5 to 62 relabeling rules), and 10 queries. <software ContextAttributes="used">XMark</software> JR is an extension of the well-known <software ContextAttributes="used">XMark</software> <ref type="bibr" target="#b74">[75]</ref> we designed to dispose of a rule-based query answering benchmark over trees to understand the scalability of our approach. First, <software ContextAttributes="used">XMark</software> JR allows us to control the number of rewritings of a query -which is a crucial parameter. We consider 23 rulesets each creating a larger number of rewritings per query (from 1 to 500). Second, it allows us to control the size and variability of data. So for, each ruleset, we considered five collections (see Table <ref type="table" target="#tab_1">1</ref>), with the larger collection having 1.4B edges when data is seen as trees.</p><p>We refer to <ref type="bibr" target="#b68">[69]</ref> for its detailed presentation. Overall, <software ContextAttributes="used">XMark</software> JR is meant to push the limits of rewriting-based query answering.</p><p>Other systems. We are not aware of any system for reasoning with constrained-tree rules on top of JSON data. However, as our rules can be encoded as Datalog Â± rules <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34]</ref> we used reasoners for Datalog Â± designed for knowledge-graphs as a baseline. Materialization-based approaches. We used <software ContextAttributes="used">VLog</software> <ref type="bibr" target="#b40">[41]</ref> via <software ContextAttributes="used">Rulewerk</software> <ref type="bibr" target="#b4">[5]</ref> to study in-memory materialization. <software ContextAttributes="used">VLog</software> is a high-performance state-of-the-art reasoner <ref type="bibr" target="#b10">[11]</ref>. As it runs in-memory, it gives us a point on absolute performance to evaluate DBMS-based approaches. Rewriting-based approaches. <software ContextAttributes="used">Graal</software> is the only rewriting-based system for Datalog Â± we are aware of <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b61">62]</ref>. We used a recent major version of the tool <ref type="bibr" target="#b5">[6]</ref>. <software ContextAttributes="used">Graal</software> is a modular system that allows one to parametrize the storage and reasoning algorithms. So, we leveraged on <software ContextAttributes="used">Graal</software>'s modularity to study three rewriting-based strategies, as follows. In all three cases, we used <software ContextAttributes="used">Graal</software> to compute (finite) rewritings of queries -whenever possible. Then, rewritings were evaluated in two different ways. The first is in-memory, again with <software ContextAttributes="used">VLog</software>. The second is with <software ContextAttributes="used">PostgreSQL</software> (v14.7); data was stored as a  knowledge graph by using indexed property-tables <ref type="bibr" target="#b51">[52]</ref> and integer encoding <ref type="bibr" target="#b80">[81]</ref> and tree-queries were translated as SQL queries. As scaling integer encoding can be challenging, we also considered a <software ContextAttributes="used">PostgreSQL</software> storage without integer encoding.</p><p><software ContextAttributes="used">MongoDB</software> Wrapper Queries have been translated into Mon-goDB with the find() facility which answers true on every record of the collection satisfying a query by returning the record itself. It is also worth noting that for all benchmarks we considered treequeries without answer variables. However, this does not make evaluation easy, as we still ask <software ContextAttributes="used">MongoDB</software> to check if each record satisfies the query. To gauge performances across different systems we asked the competitors compute the set of trees matching a query as for our system. We focused on the computational effort needed for evaluating constrained tree-queries: no input time (i.e., data loading) nor output time (i.e. result serialization) were considered. Inputs were translated into formats recognizable by the other systems (JSON data as CSV, tree queries and rules as DLGP <ref type="bibr" target="#b13">[14]</ref>).</p><p>Overview of the Results We will focus on two aspects. First, a study of the query answering techniques we proposed, then a comparison with the other systems. For space limits, we focus on the main findings and report average query times. Detailed times are reported in <ref type="bibr" target="#b68">[69]</ref>. Results are robust averages over 5 repetitions. All times are in seconds. Experiments with the <software ContextAttributes="used">TreeForce</software> system will be denoted by "TF". The baseline approach for our system uses the depth-summary, this is denoted by TF-depth. Variants of our system with different summaries introduced in Section 4 are denoted TF-{label,path,path+prefix}. We denote by TF-part-parallpath our method with partitioning and parallelization, with the path summary; this is our best resulting approach. The variant of this technique without parallelization is denoted by TF-part-path.</p><p>Linear Scalability of the Underlying Database. Figure <ref type="figure" target="#fig_11">8</ref> illustrates how <software ContextAttributes="used">MongoDB</software> reacts to the evaluation of 1) larger rewriting sets on 2) larger volumes of data produced by <software ContextAttributes="used">XMark</software> JR . Every data point indicates the time taken for evaluating a rewriting set. We can clearly see that the response time is linear both in the size of the rewriting sets and in the size of the data. This is expected as the evaluation algorithm of <software ContextAttributes="used">MongoDB</software> is based on a database scan. This observation is also confirmed on DBLP JR and GitHub JR .</p><p>Summary-based Filtering is Critical. Figure <ref type="figure" target="#fig_12">9</ref> shows average query answering times for the depth, label, path and path+prefix summaries for DBLP JR and GitHub JR . It reports both the query rewriting and the evaluation time. For the path+prefix summary, we fixed ğ‘˜ = 5, i.e., prefixes have length 5. We also tested longer prefixes but this did not bring any sensible improvement. For DBLP JR , the label summary leads to an average speedup of 3x on a single query. This raises to 5x for the path summary and to 23x when ğ‘˜-prefixes are added. For GitHub JR , the label summary leads to a speedup of 4x on average, which raises to 17x for the path summary. While for GitHub JR prefixes did not improve much things, for DBLP JR queries with text values, gains with ğ‘˜-prefixes can be in orders of magnitude for single queries <ref type="bibr" target="#b68">[69]</ref>. Overall, it is unavoidable to use data summaries for efficiency as the underlying database system is unable to discard empty queries based on their structure, which slows down performances. Summaries have no effect on <software ContextAttributes="used">XMark</software> JR , which by design produces almost no empty queries, and forces the underlying database to evaluate all queries in a rewriting set. However, summaries will have again the same powerful filtering role combined with partitioning, as discussed next. As a last remark, summaries were relatively lightweight for DBLP JR and GitHub JR . For DBLP JR , they included 50 labels, 188 paths, and 957K 5-prefixes while GitHub JR had 250 labels, 991 paths, and 3.3M 5-prefixes.</p><p>Evaluation Dominates Query Rewriting Costs. Recall that query rewriting is divided in 1) automaton construction and 2) summary-based filtering and query generation. As expected, the query rewriting time depends on the complexity of rules and the size of the resulting rewriting set <ref type="bibr" target="#b68">[69]</ref>. For DBLP JR , the average automaton construction time was 300ms and within 1 second even for thousands of rewritings. For GitHub JR the average automaton construction time was 1.5s and within 3.5 seconds. For <software ContextAttributes="used">XMark</software> JR , it was within 0.1 seconds in general. After the automaton construction follow filtering and query generation. Rewriting generation was on average in the order of tens of milliseconds and within 200ms for large rewritings, across all benchmarks. Figure <ref type="figure" target="#fig_12">9</ref> allows one to compare the rewriting time (automaton construction+query generation) and the evaluation time of a rewriting set, with different data summaries. The main observation is that for large volumes of data query answering is likely to be dominated by the evaluation of a rewriting-set rather than by rewriting itself. Also, automaton construction could be boostrapped off-line as discussed in Section 6 further reducing rewriting costs at query time.</p><p>Partitioning and Parallelization Bring Big Improvements. For partitioning, we used the Î› ğ‘‘ function with ğ‘‘ = 2 (Section 4). This led to 8 partitions for DBLP JR , 30 for GitHub JR , and between 6 and 130 for <software ContextAttributes="used">XMark</software> JR . We report the results for the path summary without prefixes. We use this as a yardstick to show that partitioning and parallelization have sensible effects; gains cannot decrease when prefixes are added. Recall we focus on physical partitioning; we found logical partitioning having similar effectiveness <ref type="bibr" target="#b68">[69]</ref>.</p><p>For DBLP JR , we start by looking at the gain provided by partitioning alone (i.e., without parallelization), as illustrated in Figure <ref type="figure" target="#fig_13">10</ref> (TF-part-path). The advantage of partitioning alone is that ğ‘–) a query is evaluated on smaller portions of the database and ğ‘–ğ‘–) partitions can be skipped when the data summary rules out any answer on a specific partition. In this experiment, partitions are queried sequentially and times added up. For DBLP JR queries that took more than 200ms (20 out 22) the average speedup for (sequentially) querying the partition was of 16.1x; the value increases if all 22 queries are considered <ref type="bibr" target="#b68">[69]</ref>. For GitHub JR , the average speedup was 30x. By introducing parallelization (TF-part-parall-path) the runtime is dominated by the time of querying the "slowest" partition (to which we add the management of the parallel data access). So, the gains further raise to 22.9x for (again: 20 out of 22) DBLP queries and 53x for GitHub JR wrt the baseline TF-depth. For comparison, recall that the path summary had an average speedup of 5.5x (on all 22 queries) on DBLP JR , and of 17.6x on GitHub JR , which means partitioning and parallelization allow one to go 2x to 4x faster wrt the path summary alone on these datasets. As said above, we reported on the path summary to have a yardstick for performances. Interestingly, we found the label summary on DBLP JR to provide essentially the same results <ref type="bibr" target="#b68">[69]</ref>. This is because partitions have a reduced variability of data, hence labels are used with less ambiguity. So, summaries can be both very small and efficient when combined with partitioning. As expected, adding prefixes to the path summary improves the filtering power and reduces the size of rewritings. This can again further improve the speed-up by at least 3x on DBLP JR with respect to using partitioning, parallelization and the path summary without ğ‘˜-prefixes. Overall, these results show the gains provided by partitioning and parallelization.</p><p>Partitioning Leads Towards Horizontal Scalability. Partitioning and parallelization can be extremely efficient in distributing the query answering effort on large databases. Figure <ref type="figure" target="#fig_0">11</ref> (left) reports answering times on an <software ContextAttributes="used">XMark</software> JR ruleset generating rewritings of size 100 over several instances. Data points indicate the average query time for the 10 <software ContextAttributes="used">XMark</software> JR queries. Let us focus on two variants of our system: the baseline (TF-depth) and with partitioning, parallelization, and the path summary (TF-part-parall-path). While for small data the two are closer, gains can reach peaks of two orders of magnitude for single queries on large JSON collections. The average gain on 100M is 2x (over all 23 rulesets), and raises 13.5x on 1G and to 68.2x for 10GB and to 88.8x for 50G. Figure <ref type="figure" target="#fig_0">11</ref> (right) reports single query time with TF-part-parall-path for 10GB and 50G <software ContextAttributes="used">XMark</software> JR data (note, across all rulesets). We observe that the greater is the number of partitions attacked by a query, the lower is the query evaluation time, as the querying effort can be better distributed. For 10GB data we can answer queries with 100 rewritings in 1.3 seconds, which is encouraging. This suggests that other partitioning functions could achieve better load balancing leading towards horizontal scalability; this is left for future work.</p><p>No Stored Inferences and Low Memory Consumption Our method achieves both efficiency and scalability thanks the underlying database. Its persistent storage enables querying on large data, and query rewriting avoids to store any inference. Let us go back to Figure <ref type="figure" target="#fig_0">11</ref> (left), showing average query times for rewriting sets of size 100. Experiments confirm that in-memory materialization with <software ContextAttributes="created">VLog</software> is extremely efficient, especially on small to medium instances, because of its dedicated algorithms and data-structures. <software ContextAttributes="created">TreeForce</software> with partitioning, parallelization, and path summary is slower on small instances but, as data increases, it reaches similar performances (already for ğœ‚ = 100). This was confirmed also on <software ContextAttributes="created">XMark</software> JR ruleset generating rewritings of size 10 and 500 <ref type="bibr" target="#b68">[69]</ref>. For ğœ‚ = 500, <software ContextAttributes="created">VLog</software> could not load the data as it consumed all of the RAM we allocated. This shows that in-memory solutions may require powerful hardware for their deployment on large datasets, while relying on database solutions allows one to scale with modest memory resources. For DBLP and GitHub the average query time for <software ContextAttributes="created">VLog</software> was 5.9s on DBLP (against 7.4s for TF-part-parall-path) and 0.7s on GitHub JR (against 2.2s for TF-part-parall-path). For a fair comparison, this data does not include the time taken by <software ContextAttributes="created">VLog</software> to apply the rules alone (without computing answers to queries) which can be considered either a one-of operation or not. We report however that rule application time was 160s for DBLP and 65s for GitHub JR (no input nor output time). We conclude that for one-of operations our approach can be relevant also on smaller instances. Finally, note that <software ContextAttributes="created">VLog</software> rule-application is negligible for <software ContextAttributes="created">XMark</software> JR as relabeling rules are kept intensional <ref type="bibr" target="#b56">[57]</ref>; this makes the comparison of Figure <ref type="figure" target="#fig_0">11</ref> meaningful. All of this is interesting also because a DBMS can be considered at disadvantage when compared with main-memory solutions in terms of pure response time.</p><p>Rewriting Algorithms Tailored for Data-Tree. For GitHub JR and <software>XMark</software> JR , we could use <software ContextAttributes="created">Graal</software> to compute rewritings of queries. However, this was not possible for all DBLP JR queries as the translation of DBLP JR tree also yields Datalog Â± rules which are recursive. Indeed, rewriting with <software ContextAttributes="created">Graal</software> terminated only on 6 queries out of 22. Note that this is not a limitation of this tool, but of any general rewriting algorithm that makes no hypothesis on the shape of data. In contrast, our rewriting algorithm tailored for tree rules terminated in all cases. Hence, times reported next for rewriting-based approaches on DBLP JR only consider those 6 queries.</p><p>The main feature of interest of rewriting-based systems is their frugality in terms of main memory. However, they may face other challenges when scaling out reasoning. The first, is the evaluation of large rewriting sets, which is a well-known issue <ref type="bibr" target="#b32">[33]</ref>. The second is computing dictionary encoding over large collections, which is a question in itself <ref type="bibr" target="#b80">[81]</ref>. Figure <ref type="figure" target="#fig_13">10</ref> illustrates rewriting-based approaches on DBLP JR andGitHub JR showing the effectiveness of our optimizations. <software ContextAttributes="created">XMark</software> JR results for rewriting-based systems are reported in Figure <ref type="figure" target="#fig_0">11</ref>. We include only average times for the cases where all of the 10 <software ContextAttributes="created">XMark</software> JR queries were answered by a system <ref type="bibr" target="#b68">[69]</ref>. For ğœ‚ = 500, again data could not be loaded in main memory by <software ContextAttributes="created">VLog</software>. On the other side, <software ContextAttributes="created">Graal</software> could not encode the data, as the dictionary encoding computation ran out of memory. By disabling dictionary encoding data was loaded into <software ContextAttributes="created">PostgreSQL</software>. However, already for ğœ‚ = 100, disabling encoding did not allow to answer all the queries of the benchmark (recall, each with 100 rewritings). Our approach, in both its baseline and optimized versions, was able to provide answers across all benchmarks. Overall, we believe these results on rewriting over <software ContextAttributes="created">MongoDB</software> to be very promising.</p></div>
<div><head n="8">RELATED WORK AND CONCLUSION</head><p>There has been little work on reasoning on top of JSON databases. Prior work studied path-rules for JSON <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b66">67]</ref>; we focus on treerules. More specifically, our frontier-constrained tree-rules extend the context-free fragment of suffix-path rules from <ref type="bibr" target="#b22">[23]</ref>, while keeping suitability for query rewriting on document-stores. Still on the theoretical level, the work of <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b55">56]</ref> focuses on the computational complexity of some logical query languages for JSON. Note that the frameworks from <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b66">67]</ref> have not been implemented. Another line of work considers the definition of virtual RDF views of JSON data as well as reasoning with RDFS/OWL ontologies at the RDF level <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b31">32]</ref>; we do reasoning at the JSON level.</p><p>With respect to the area of knowledge graphs and hypergraphs, constrained tree-rules allow for existential nodes in the rule head: these are analogous to existentially quantified variables in Datalog Â± <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b33">34]</ref>. As already said, our decidable fragment can be seen as a strict subset of body-acyclic frontier-guarded existential rules <ref type="bibr" target="#b16">[17]</ref>, as well as of the description logic ELH V <ref type="bibr" target="#b62">[63]</ref>. Many reasoners have been implemented for knowledge graphs. State-of-the-art materialization-based systems include in-memory solutions like <software ContextAttributes="created">VLog</software> <ref type="bibr" target="#b40">[41]</ref>, RDFox <ref type="bibr" target="#b67">[68]</ref> and Vadalog <ref type="bibr" target="#b19">[20]</ref> (the latter being restricted to a specific rule fragment) and RDBMS-based solutions like LLunatic <ref type="bibr" target="#b50">[51]</ref> and DLV <ref type="bibr" target="#b11">[12]</ref>. Note that materialization does not always halt for frontier-constraint tree-rules. State-of-the-art rewritingbased systems include <software ContextAttributes="created">OnTop</software> <ref type="bibr" target="#b36">[37]</ref> and <software ContextAttributes="created">Mastro</software> <ref type="bibr" target="#b38">[39]</ref>, both devoted to lightweight OWL ontologies incomparable with our rules, and <software ContextAttributes="created">Graal</software> for existential rules <ref type="bibr" target="#b14">[15]</ref>. Note that <software ContextAttributes="created">Graal</software> accepts any set of existential rules and conjunctive query, but query rewriting terminates only if the rewriting set is finite <ref type="bibr" target="#b60">[61]</ref>, a property that is not fulfilled by frontier-constrained tree-rules (recall Figure <ref type="figure" target="#fig_3">3</ref>). Also, our query rewriting technique based on semi-twig-unifiers exploits the fact that data is tree-shaped and generates only tree queries.</p><p>Various formalisms for reasoning on XML and object-oriented databases have been studied <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b73">74]</ref>. A difference between our framework and most of these proposals is that they are tied to XML and XPath. Among the rule-based languages for XML, decidable fragments such as XPathLog <ref type="bibr" target="#b64">[65]</ref>, Elog <ref type="bibr" target="#b17">[18]</ref> and F-Logic <ref type="bibr" target="#b58">[59,</ref><ref type="bibr" target="#b59">60]</ref>, which do not allow for existential nodes, are incomparable with our frontier-constrained tree-rules in terms of expressivity. Another sharp difference is that <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b64">65]</ref> have been designed with a forward-chaining reasoning in mind; our focus is query rewriting. <software ContextAttributes="created">Xcerpt</software> <ref type="bibr" target="#b73">[74]</ref> is the closest language to our tree-rules for which backward chaining (over ordered trees) has been studied <ref type="bibr" target="#b72">[73]</ref>. Our work differs as <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b73">74]</ref> provides no guarantees for the termination of <software ContextAttributes="created">Xcerpt</software> rules, while we identify a decidable fragment via query rewriting (over unordered trees). Active XML <ref type="bibr" target="#b6">[7]</ref> is not based on rules but on function calls. UnQL <ref type="bibr" target="#b28">[29]</ref> and XML-QL <ref type="bibr" target="#b44">[45]</ref> are not rule-languages but query-languages based on recursive functions. Although these approaches can be assimilated with ours, their technical development is quite different. A last crucial difference with all these proposals is that our work is the first to consider (and implement) the use of NoSQL document stores to support rule-based query answering over data-trees.</p><p>Rewriting-based techniques have been considered for answering queries over virtual XML views defined either from SQL data <ref type="bibr" target="#b48">[49,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b76">77]</ref> or XML data <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b78">79]</ref> to support data-integration and secure access to information. Note first that view languages are different from rule languages, which are typically more general. Automata have been proved effective for tackling problems related to XML queries in many settings <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b75">76]</ref>. Very few work considers the presence of recursion in the definition of views. From the automata perspective, the work of <ref type="bibr" target="#b47">[48]</ref> is the closest to ours in spirit as it considers automata-based rewriting for regular XPath queries over recursive XML views. However, the decidable language stemming from recursive view definitions is much closer to <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b64">65]</ref> which makes it orthogonal to frontier-constrained tree-rules. Further, <ref type="bibr" target="#b47">[48]</ref> produces regular-XPath rewritings which are not supported by any system and calls for an ad-hoc implementation. In contrast, our instance-aware method outputs tree-queries and relies on efficient NoSQL systems. To conclude on this matter, note that the problem of answering queries with materialized views <ref type="bibr" target="#b53">[54]</ref> (the input query targets the source database, rewritings target the views) is opposite to the one with virtual views (the input query targets the virtual database, rewritings target the source database). Our approach can nevertheless benefit from the presence of materialized views containing certain answers to queries over the original database. Having materialized views opens for two types of opportunities. First, evaluating a subset of the rewriting-set of a query on the materialized views. Second, the development of early stop techniques for our rewriting algorithms when answers to single rewritings (over views) are found. The study of these questions is however left as the subject of future work.</p><p>In conclusion, we have shown that NoSQL stores can be used to build an efficient and scalable tool for reasoning on JSON databases. We have outlined the importance of instance-aware query rewriting techniques and shown that the combination of data summaries, partitioning and parallelization result in high performances on large data. We believe that some of these ideas can be transposed to the case of knowledge graphs and hypergraphs. Future work also includes the extension to more expressive rule languages, for example including suitable forms of equality constraints and contexts.</p></div><figure xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Rule-based Querying of GitHub Data</figDesc></figure>
<figure xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Query Rewriting Associated with Example 1.1</figDesc></figure>
<figure xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Rules and Infinite Rewriting Sequences</figDesc></figure>
<figure xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Instance-Aware Rewriting and Evaluation</figDesc></figure>
<figure xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Separating Nodes and (Semi-)Twig Unification</figDesc></figure>
<figure xml:id="fig_6"><head /><label /><figDesc>ğ‘–where ğ‘£ ğ‘– is the encoding of a query leaf. State s initial 1 recognizes the query leaf labeled by value ForkEvent. By definition, this is a constrained node. Hence its encoding is ğ‘£ 1 = ($ â€¢ ForkEvent) where the reserved symbol $ is used to denote a constrained node. State s initial 2 recognizes the answer variable x, which by definition is also constrained. This is encoded as ğ‘£ 2 = ($ â€¢ 1), where 1 denotes the position of the answer variable in the answer node sequence. State s initial 3 recognizes an existential node. This is encoded as ğ‘£ 3 = (#) where # denotes that the node is not constrained. Moving on, the initial states are used to define three edge transitions of the form s initial ğ‘– ğ‘˜ ğ‘–</figDesc></figure>
<figure xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Query and Rewriting Automata</figDesc></figure>
<figure xml:id="fig_9"><head>( 1 )( 2 ) 6 )</head><label>126</label><figDesc>Construction of A (ğ‘,Î ) from ğ‘ and Î  Initialize A (ğ‘,Î ) to be equal to A encode(ğ‘) For every edge transition s a --â†’ e in Î” ğ¸ and rule ğ‘Ÿ âˆˆ Î  relabeling b into a Add the transition s b --â†’ e in Î” ğ¸ (3) For every tree encode(ğ‘ â€² ) recognized by A (ğ‘,Î ) via a run ğœŒ (4) For every twig-unifier ğœ‡ = (ğ‘†, H, ğœˆ, ğ‘¢) for ğ‘ â€² and rule ğ‘Ÿ âˆˆ Î  (5) Extend A (ğ‘,Î ) with an automaton for A encode(ğœ‡ (Body(ğ‘Ÿ ))) (if not already done) (Add to Î” ğ‘ a (non-leaf) node transition ( U \ T ) âˆª B --â†’ ğœŒ (Root(ğ‘†)) where â€¢ U = {ğœŒ (ğ‘› 1 ), . . . , ğœŒ (ğ‘› ğ‘˜ )} is a set of node-states where ğ‘› 1 , . . . , ğ‘› ğ‘˜ are the children of Root(ğ‘†) within the query ğ‘ â€² â€¢ T = {ğ‘› ğ‘— } is a singleton node-state where ğ‘› ğ‘— is the (only) child of Root(ğ‘†) within the twig ğ‘† â€¢ B is a set of states such that B --â†’ s final encode(ğœ‡ (Body(ğ‘Ÿ ))) (7) Repeat (2-6) until no more transitions can be added.</figDesc></figure>
<figure xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Rewriting Automaton Construction</figDesc></figure>
<figure xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Answering Time (baseline) -XMark JR</figDesc><graphic coords="11,75.82,81.22,197.19,98.60" type="bitmap" /></figure>
<figure xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Answering Time (average) vs Summaries</figDesc><graphic coords="11,56.36,207.75,118.57,78.99" type="bitmap" /></figure>
<figure xml:id="fig_13"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Answering Time (average) -Rewriting Systems</figDesc><graphic coords="12,317.56,80.31,124.05,81.19" type="bitmap" /></figure>
<figure type="table" xml:id="tab_0"><head /><label /><figDesc>, No. 11 ISSN 2150-8097.</figDesc><table /><note><p>doi:10.14778/3611479.3611481</p></note></figure>
<figure type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Dataset Size</figDesc><table><row><cell>XMark JR</cell></row></table></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>We do not represent the ordering on the elements of a sequence, since the considered queries do not exploit this order. Moreover, a nested sequence is seen as a constant.</p></note>
			<note place="foot" n="2" xml:id="foot_1"><p>In passing, note we cannot use the query rewriting algorithm based on piece-unifiers as-it-is, because 1) it may yield (more specific) rewritings that are not trees and 2) it may not terminate when it should, as it does not take into account the shape of data.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>We are grateful to <rs type="person">Florent Tornil</rs> for his help with the experiments. This work was financially supported by the <rs type="funder">ANR</rs> project <rs type="projectName">CQFD</rs> (<rs type="grantNumber">ANR-18-CE23-0003</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_sRAwrY3">
					<idno type="grant-number">ANR-18-CE23-0003</idno>
					<orgName type="project" subtype="full">CQFD</orgName>
				</org>
			</listOrg>

			<div type="availability">
<div><p>The source code, data, and/or other artifacts have been made available at https://gitlab.inria.fr/boreal-artifacts/pvldb2023.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Software) MongoDB</title>
		<ptr target="www.mongodb.com" />
		<imprint>
			<date type="published" when="2009">2009. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">GitHub (GH) Archive</title>
		<ptr target="www.gharchive.org" />
		<imprint>
			<date type="published" when="2011">2011. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="www.arangodb.com" />
		<title level="m">Software) ArangoDB</title>
		<imprint>
			<date type="published" when="2011">2011. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="https://asterixdb.apache.org" />
		<title level="m">Software) AsterixDB</title>
		<imprint>
			<date type="published" when="2016">2016. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="www.github.com/knowsys/rulewerk" />
		<title level="m">Software) Rulewerk</title>
		<imprint>
			<date type="published" when="2018">2018. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<ptr target="https://gitlab.inria.fr/rules/integraal" />
		<title level="m">Software) InteGraal</title>
		<imprint>
			<date type="published" when="2022">2022. 2023-05-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Positive Active XML</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Omar</forename><surname>Benjelloun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<idno type="DOI">10.1145/1055558.1055564</idno>
		<ptr target="https://doi.org/10.1145/1055558.1055564" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-third ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">Catriel</forename><surname>Beeri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</editor>
		<meeting>the Twenty-third ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004-06-14">2004. June 14-16, 2004</date>
			<biblScope unit="page" from="35" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Foundations of Databases: The Logical Level</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<pubPlace>Boston, MA, USA</pubPlace>
		</imprint>
	</monogr>
	<note>1st ed.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Regular Path Queries with Constraints</title>
		<author>
			<persName><forename type="first">Serge</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Victor</forename><surname>Vianu</surname></persName>
		</author>
		<idno type="DOI">10.1006/jcss.1999.1627</idno>
		<ptr target="https://doi.org/10.1006/jcss.1999.1627" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="428" to="452" />
			<date type="published" when="1999-06">1999. June 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">XML Data Clustering: An Overview</title>
		<author>
			<persName><forename type="first">Alsayed</forename><surname>Algergawy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Mesiti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richi</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gunter</forename><surname>Saake</surname></persName>
		</author>
		<idno type="DOI">10.1145/1978802.1978804</idno>
		<ptr target="https://doi.org/10.1145/1978802.1978804" />
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">41</biblScope>
			<date type="published" when="2011-10">2011. oct 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">ForBackBench: A Benchmark for Chasing vs. Query-Rewriting</title>
		<author>
			<persName><forename type="first">Afnan</forename><surname>Alhazmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Blount</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Konstantinidis</surname></persName>
		</author>
		<idno type="DOI">10.14778/3529337.3529338</idno>
		<ptr target="https://doi.org/10.14778/3529337.3529338" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1519" to="1532" />
			<date type="published" when="2022-06">2022. jun 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Disjunctive Datalog System DLV</title>
		<author>
			<persName><forename type="first">Mario</forename><surname>Alviano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>Faber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicola</forename><surname>Leone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simona</forename><surname>Perri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Pfeifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giorgio</forename><surname>Terracina</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-24206-9_17</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-24206-9_17" />
	</analytic>
	<monogr>
		<title level="m">Datalog Reloaded -First International Workshop, Datalog 2010</title>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Oege De Moor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Tim</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Andrew</forename><forename type="middle">Jon</forename><surname>Furche</surname></persName>
		</editor>
		<editor>
			<persName><surname>Sellers</surname></persName>
		</editor>
		<meeting><address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-03-16">2010. March 16-19, 2010</date>
			<biblScope unit="volume">6702</biblScope>
			<biblScope unit="page" from="282" to="301" />
		</imprint>
	</monogr>
	<note>Revised Selected Papers (Lecture Notes in Computer Science</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design and Implementation of the LogicBlox System</title>
		<author>
			<persName><forename type="first">Molham</forename><surname>Aref</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">J</forename><surname>Balder Ten Cate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benny</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Kimelfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emir</forename><surname>Olteanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Todd</forename><forename type="middle">L</forename><surname>Pasalic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Geoffrey</forename><surname>Veldhuizen</surname></persName>
		</author>
		<author>
			<persName><surname>Washburn</surname></persName>
		</author>
		<idno type="DOI">10.1145/2723372.2742796</idno>
		<ptr target="https://doi.org/10.1145/2723372.2742796" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIG-MOD International Conference on Management of Data</title>
		<meeting>the 2015 ACM SIG-MOD International Conference on Management of Data<address><addrLine>Melbourne, Victoria, Australia; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1371" to="1382" />
		</imprint>
	</monogr>
	<note>SIGMOD '15)</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Datalog+, RuleML and OWL 2: Formats and Translations for Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alain</forename><surname>Gutierrez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swan</forename><surname>Rocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">ClÃ©ment</forename><surname>Sipieter</surname></persName>
		</author>
		<ptr target="https://ceur-ws.org/Vol-1417/paper9.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the RuleML 2015 Challenge, the Special Track on Rule-based Recommender Systems for the Web of Data, the Special Industry Track and the RuleML 2015 Doctoral Consortium hosted by the 9th International Web Rule Symposium (RuleML 2015)</title>
		<editor>
			<persName><forename type="first">Nick</forename><surname>Bassiliades</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Paul</forename><surname>Fodor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Adrian</forename><surname>Giurca</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">TomÃ¡s</forename><surname>Kliegr</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Grzegorz</forename><forename type="middle">J</forename><surname>Nalepa</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Monica</forename><surname>Palmirani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Adrian</forename><surname>Paschke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Mark</forename><surname>Proctor</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dumitru</forename><surname>Roman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fariba</forename><surname>Sadri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Nenad</forename><surname>Stojanovic</surname></persName>
		</editor>
		<meeting>the RuleML 2015 Challenge, the Special Track on Rule-based Recommender Systems for the Web of Data, the Special Industry Track and the RuleML 2015 Doctoral Consortium hosted by the 9th International Web Rule Symposium (RuleML 2015)<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08-02">2015. August 2-5, 2015</date>
			<biblScope unit="volume">1417</biblScope>
		</imprint>
	</monogr>
	<note>CEUR Workshop Proceedings)</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Graal: A Toolkit for Query Answering with Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Swan</forename><surname>Rocher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">ClÃ©ment</forename><surname>Sipieter</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-21542-6_21</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-21542-6_21" />
	</analytic>
	<monogr>
		<title level="m">Rule Technologies: Foundations, Tools, and Applications -9th International Symposium, RuleML 2015</title>
		<editor>
			<persName><forename type="first">Nick</forename><surname>Bassiliades</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fariba</forename><surname>Sadri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Adrian</forename><surname>Paschke</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dumitru</forename><surname>Roman</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015-08-02">2015. August 2-5, 2015. 9202</date>
			<biblScope unit="page" from="328" to="344" />
		</imprint>
	</monogr>
	<note>Proceedings (Lecture Notes in Computer Science)</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On rules with existential variables: Walking the decidability line</title>
		<author>
			<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Salvat</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2011.03.002</idno>
		<ptr target="https://doi.org/10.1016/j.artint.2011.03.002" />
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="page" from="1620" to="1654" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Walking the Complexity Lines for Generalized Guarded Existential Rules</title>
		<author>
			<persName><forename type="first">Jean-FranÃ§ois</forename><surname>Baget</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MichaÃ«l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.5591/978-1-57735-516-8/IJCAI11-126</idno>
		<ptr target="https://doi.org/10.5591/978-1-57735-516-8/IJCAI11-126" />
	</analytic>
	<monogr>
		<title level="m">IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Toby</forename><surname>Walsh</surname></persName>
		</editor>
		<meeting><address><addrLine>Barcelona, Catalonia, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-07-16">2011. July 16-22, 2011</date>
			<biblScope unit="page" from="712" to="717" />
		</imprint>
	</monogr>
	<note>IJCAI/AAAI</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Supervised Wrapper Generation with Lixto</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Baumgartner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sergio</forename><surname>Flesca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/2001/P715.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB 2001, Proceedings of 27th International Conference on Very Large Data Bases</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Peter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Paolo</forename><surname>Apers</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Atzeni</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Ceri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kotagiri</forename><surname>Paraboschi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Ramamohanarao</surname></persName>
		</editor>
		<editor>
			<persName><surname>Snodgrass</surname></persName>
		</editor>
		<meeting><address><addrLine>Roma, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2001-09-11">2001. September 11-14, 2001</date>
			<biblScope unit="page" from="715" to="716" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Proof Procedure for Data Dependencies</title>
		<author>
			<persName><forename type="first">Catriel</forename><surname>Beeri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1145/1634.1636</idno>
		<ptr target="https://doi.org/10.1145/1634.1636" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="718" to="741" />
			<date type="published" when="1984-09">1984. Sept. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Vadalog System: Datalog-based Reasoning for Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Luigi</forename><surname>Bellomarini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<idno type="DOI">10.14778/3213880.3213888</idno>
		<ptr target="https://doi.org/10.14778/3213880.3213888" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="975" to="987" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Benchmarking the Chase</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">George</forename><surname>Konstantinidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giansalvatore</forename><surname>Mecca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Papotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donatello</forename><surname>Santoro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Efthymia</forename><surname>Tsamoura</surname></persName>
		</author>
		<idno type="DOI">10.1145/3034786.3034796</idno>
		<ptr target="https://doi.org/10.1145/3034786.3034796" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems<address><addrLine>Chicago, Illinois, USA; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="37" to="52" />
		</imprint>
	</monogr>
	<note>) (PODS '17)</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Goal-Driven Query Answering for Existential Rules With Equality</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Benedikt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Efthymia</forename><surname>Tsamoura</surname></persName>
		</author>
		<ptr target="https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/16927" />
	</analytic>
	<monogr>
		<title level="m">AAAI-18), the 30th innovative Applications of Artificial Intelligence (IAAI-18), and the 8th AAAI Symposium on Educational Advances in Artificial Intelligence (EAAI-18)</title>
		<editor>
			<persName><forename type="first">Sheila</forename><forename type="middle">A</forename><surname>Mcilraith</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kilian</forename><forename type="middle">Q</forename><surname>Weinberger</surname></persName>
		</editor>
		<meeting><address><addrLine>New Orleans, Louisiana, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2018-02-02">2018. February 2-7, 2018</date>
			<biblScope unit="page" from="1761" to="1770" />
		</imprint>
	</monogr>
	<note>Proceedings of the Thirty-Second AAAI Conference on Artificial Intelligence</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Ontology-Mediated Query Answering for Key-Value Stores</title>
		<author>
			<persName><forename type="first">Meghyn</forename><surname>Bienvenu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
		</author>
		<idno type="DOI">10.24963/ijcai.2017/117</idno>
		<ptr target="https://doi.org/10.24963/ijcai.2017/117" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017</title>
		<meeting>the Twenty-Sixth International Joint Conference on Artificial Intelligence, IJCAI 2017<address><addrLine>Melbourne, Australia; Carles Sierra</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-08-19">2017. August 19-25, 2017</date>
			<biblScope unit="page" from="844" to="851" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">OBDA Beyond Relational DBs: A Study for MongoDB</title>
		<author>
			<persName><forename type="first">Elena</forename><surname>Botoeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-1577/paper_40.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Workshop on Description Logics</title>
		<meeting>the 29th International Workshop on Description Logics<address><addrLine>Cape Town, South Africa</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-04-22">2016. April 22-25, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Expressivity and Complexity of MongoDB Queries</title>
		<author>
			<persName><forename type="first">Elena</forename><surname>Botoeva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2018.9</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2018.9" />
	</analytic>
	<monogr>
		<title level="m">21st International Conference on Database Theory, ICDT 2018</title>
		<editor>
			<persName><forename type="first">)</forename><surname>Lipics</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Benny</forename><surname>Kimelfeld</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yael</forename><surname>Amsterdamer</surname></persName>
		</editor>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-03-26">2018. March 26-29, 2018</date>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">JSON: Data model, Query languages and Schema specification</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Bourhis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juan</forename><forename type="middle">L</forename><surname>Reutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><surname>SuÃ¡rez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domagoj</forename><surname>Vrgoc</surname></persName>
		</author>
		<idno type="DOI">10.1145/3034786.3056120</idno>
		<ptr target="https://doi.org/10.1145/3034786.3056120" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017</title>
		<editor>
			<persName><forename type="first">Emanuel</forename><surname>Sallinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
		</editor>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017-05-14">2017. May 14-19, 2017</date>
			<biblScope unit="page" from="123" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Foundations of Rule-Based Query Answering</title>
		<author>
			<persName><forename type="first">FranÃ§ois</forename><surname>Bry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norbert</forename><surname>Eisinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Furche</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Clemens</forename><surname>Ley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benedikt</forename><surname>Linse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Pichler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fang</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Summer School Conference on Reasoning Web</title>
		<meeting>the Third International Summer School Conference on Reasoning Web<address><addrLine>Dresden, Germany; Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Path constraints in semistructured databases</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Weinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="146" to="193" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">UnQL: a query language and algebra for semistructured data based on structural recursion</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="76" to="110" />
			<date type="published" when="2000">2000. 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Raisonnement efficace sur des grands graphes hÃ©tÃ©rogÃ¨nes</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<ptr target="http://www.theses.fr/2020IPPAX061" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
		<respStmt>
			<orgName>Institut polytechnique de Paris</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">These de doctorat</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Obi-Wan: Ontology-Based RDF Integration of Heterogeneous Data</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">FranÃ§ois</forename><surname>GoasdouÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<idno type="DOI">10.14778/3415478.3415512</idno>
		<ptr target="https://doi.org/10.14778/3415478.3415512" />
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="2933" to="2936" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Ontology-Based RDF Integration of Heterogeneous Data</title>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Buron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">FranÃ§ois</forename><surname>GoasdouÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<idno type="DOI">10.5441/002/edbt.2020.27</idno>
		<ptr target="https://doi.org/10.5441/002/edbt.2020.27" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Extending Database Technology, EDBT 2020</title>
		<editor>
			<persName><forename type="first">Angela</forename><surname>Bonifati</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yongluan</forename><surname>Zhou</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Marcos</forename><surname>Antonio Vaz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alexander</forename><surname>Salles</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dan</forename><surname>BÃ¶hm</surname></persName>
		</editor>
		<editor>
			<persName><surname>Olteanu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>George</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Arijit</forename><surname>Fletcher</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Bin</forename><surname>Khan</surname></persName>
		</editor>
		<editor>
			<persName><surname>Yang</surname></persName>
		</editor>
		<meeting>the 23rd International Conference on Extending Database Technology, EDBT 2020<address><addrLine>Copenhagen, Denmark</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020-03-30">2020. March 30 -April 02, 2020</date>
			<biblScope unit="page" from="299" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Teaching an RDBMS about ontological constraints</title>
		<author>
			<persName><forename type="first">Damian</forename><surname>Bursztyn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">FranÃ§ois</forename><surname>GoasdouÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<idno type="DOI">10.14778/2994509.2994532</idno>
		<ptr target="https://doi.org/10.14778/2994509.2994532" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1161" to="1172" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A general datalogbased framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1145/1559795.1559809</idno>
		<ptr target="https://doi.org/10.1145/1559795.1559809" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</title>
		<editor>
			<persName><forename type="first">Jianwen</forename><surname>Paredaens</surname></persName>
		</editor>
		<editor>
			<persName><surname>Su</surname></persName>
		</editor>
		<meeting>the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems<address><addrLine>PODS; Providence, Rhode Island, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009-06-19">2009. 2009. June 19 -July 1, 2009. Jan</date>
			<biblScope unit="page" from="77" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A general Datalogbased framework for tractable query answering over ontologies</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Lukasiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.websem.2012.03.001</idno>
		<ptr target="https://doi.org/10.1016/j.websem.2012.03.001" />
	</analytic>
	<monogr>
		<title level="j">J. Web Semant</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="57" to="83" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Towards more expressive ontology languages: The query answering problem</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>CalÃ¬</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Pieris</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.artint.2012.08.002</idno>
		<ptr target="https://doi.org/10.1016/j.artint.2012.08.002" />
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">193</biblScope>
			<biblScope unit="page" from="87" to="128" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Ontop: Answering SPARQL queries over relational databases</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Cogrel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarah</forename><surname>Komla-Ebri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Roman</forename><surname>Kontchakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Lanti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Rezk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guohui</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="471" to="487" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10817-007-9078-x</idno>
		<ptr target="https://doi.org/10.1007/s10817-007-9078-x" />
	</analytic>
	<monogr>
		<title level="j">J. Autom. Reasoning</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="385" to="429" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The MASTRO system for ontology-based data access</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giuseppe</forename><forename type="middle">De</forename><surname>Giacomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><surname>Lembo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maurizio</forename><surname>Lenzerini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antonella</forename><surname>Poggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mariano</forename><surname>Rodriguez-Muro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Riccardo</forename><surname>Rosati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Ruzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Domenico</forename><forename type="middle">Fabio</forename><surname>Savo</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-2011-0029</idno>
		<ptr target="https://doi.org/10.3233/SW-2011-0029" />
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="43" to="53" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Verification of Evolving Graph-structured Data under Expressive Path Constraints</title>
		<author>
			<persName><forename type="first">Diego</forename><surname>Calvanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Magdalena</forename><surname>Ortiz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mantas</forename><surname>Simkus</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ICDT.2016.15</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.ICDT.2016.15" />
	</analytic>
	<monogr>
		<title level="m">19th International Conference on Database Theory, ICDT 2016</title>
		<editor>
			<persName><forename type="first">)</forename><surname>Lipics</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Wim</forename><surname>Martens</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Zeume</surname></persName>
		</editor>
		<meeting><address><addrLine>Bordeaux, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-03-15">2016. March 15-18, 2016</date>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">VLog: A Rule Engine for Knowledge Graphs</title>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Irina</forename><surname>Dragoste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>GonzÃ¡lez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Ceriel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>KrÃ¶tzsch</surname></persName>
		</author>
		<author>
			<persName><surname>Urbani</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-30796-7_2</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-30796-7_2" />
	</analytic>
	<monogr>
		<title level="m">The Semantic Web -ISWC 2019 -18th International Semantic Web Conference</title>
		<editor>
			<persName><forename type="first">Chiara</forename><surname>Ghidini</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Olaf</forename><surname>Hartig</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Maria</forename><surname>Maleshkova</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Vojtech</forename><surname>SvÃ¡tek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Isabel</forename><forename type="middle">F</forename><surname>Cruz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Aidan</forename><surname>Hogan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jie</forename><surname>Song</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Maxime</forename><surname>LefranÃ§ois</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Fabien</forename><surname>Gandon</surname></persName>
		</editor>
		<meeting><address><addrLine>Auckland, New Zealand</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019-10-26">2019. October 26-30, 2019</date>
			<biblScope unit="volume">11779</biblScope>
			<biblScope unit="page" from="19" to="35" />
		</imprint>
	</monogr>
	<note>Proceedings, Part II (Lecture Notes in Computer Science)</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On word rewriting systems having a rational derivation</title>
		<author>
			<persName><forename type="first">Didier</forename><surname>Caucal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Science and Computation Structures: Third International Conference, FOSSACS 2000 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2000</title>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000-03-25">2000. March 25-April 2, 2000</date>
			<biblScope unit="page" from="48" to="62" />
		</imprint>
	</monogr>
	<note>Proceedings 3</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Yedalog: Exploring Knowledge at Scale</title>
		<author>
			<persName><forename type="first">Brian</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vuk</forename><surname>Daniel Von Dincklage</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Ercegovac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">S</forename><surname>Hawkins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franz</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Och</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fernando</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName><surname>Pereira</surname></persName>
		</author>
		<ptr target="http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=5017" />
	</analytic>
	<monogr>
		<title level="m">1st Summit on Advances in Programming Languages (SNAPL 2015)</title>
		<meeting><address><addrLine>Dagstuhl, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="63" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName><forename type="first">Max</forename><surname>Hubert Comon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florent</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Denis</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sophie</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://www.grappa.univ-lille3.fr/tata" />
		<title level="m">Tree automata techniques and applications</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A query language for XML</title>
		<author>
			<persName><forename type="first">Alin</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Levy</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer networks</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1155" to="1169" />
			<date type="published" when="1999">1999. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Data exchange: semantics and query answering</title>
		<author>
			<persName><forename type="first">Ronald</forename><surname>Fagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Phokion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">RenÃ©e</forename><forename type="middle">J</forename><surname>Kolaitis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lucian</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><surname>Popa</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2004.10.033</idno>
		<ptr target="https://doi.org/10.1016/j.tcs.2004.10.033" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">336</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="89" to="124" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Secure XML querying with security views</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chee-Yong</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minos</forename><surname>Garofalakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2004 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="587" to="598" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Rewriting regular XPath queries on XML views</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xibei</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasios</forename><surname>Kementsietsidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 23rd International Conference on Data Engineering</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007. 2007</date>
			<biblScope unit="page" from="666" to="675" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Query translation from XPath to SQL in the presence of recursive DTDs</title>
		<author>
			<persName><forename type="first">Wenfei</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeffrey</forename><forename type="middle">Xu</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianzhong</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bolin</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lu</forename><surname>Qin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB journal</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="857" to="883" />
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">SilkRoute: A framework for publishing relational data in XML</title>
		<author>
			<persName><forename type="first">Mary</forename><surname>FernÃ¡ndez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yana</forename><surname>Kadiyska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atsuyuki</forename><surname>Morishima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wang-Chiew</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="438" to="493" />
			<date type="published" when="2002">2002. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">That's All Folks! Llunatic Goes Open Source</title>
		<author>
			<persName><forename type="first">Floris</forename><surname>Geerts</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giansalvatore</forename><surname>Mecca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Papotti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Donatello</forename><surname>Santoro</surname></persName>
		</author>
		<idno type="DOI">10.14778/2733004.2733031</idno>
		<ptr target="https://doi.org/10.14778/2733004.2733031" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1565" to="1568" />
			<date type="published" when="2014-08">2014. Aug. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Efficient query answering against dynamic RDF databases</title>
		<author>
			<persName><forename type="first">FranÃ§ois</forename><surname>GoasdouÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>RoatiÅŸ</surname></persName>
		</author>
		<idno type="DOI">10.1145/2452376.2452412</idno>
		<ptr target="https://doi.org/10.1145/2452376.2452412" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Extending Database Technology (EDBT '13)</title>
		<meeting>the 16th International Conference on Extending Database Technology (EDBT '13)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="299" to="310" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">DataGuides: Enabling Query Formulation and Optimization in Semistructured Databases</title>
		<author>
			<persName><forename type="first">Roy</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Very Large Data Bases (VLDB '97)</title>
		<meeting>the 23rd International Conference on Very Large Data Bases (VLDB '97)</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Answering queries using views: A survey</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Alon</surname></persName>
		</author>
		<author>
			<persName><surname>Halevy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="270" to="294" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Computing Simulations on Finite and Infinite Graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Kopke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual Symposium on Foundations of Computer Science (FOCS '95)</title>
		<meeting>the 36th Annual Symposium on Foundations of Computer Science (FOCS '95)<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page">453</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">J-Logic: Logical foundations for JSON querying</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Paredaens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</title>
		<meeting>the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="137" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Datalog Reasoning over Compressed RDF Knowledge Bases</title>
		<author>
			<persName><forename type="first">Pan</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<idno type="DOI">10.1145/3357384.3358147</idno>
		<idno>2065-2068</idno>
		<ptr target="https://doi.org/10.1145/3357384.3358147" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th ACM International Conference on Information and Knowledge Management, CIKM 2019</title>
		<editor>
			<persName><forename type="first">Peng</forename><surname>Cheng</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Elke</forename><forename type="middle">A</forename><surname>Cui</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Rundensteiner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Qi</forename><surname>Carmel</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jeffrey</forename><surname>He</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yu</forename><surname>Xu</surname></persName>
		</editor>
		<meeting>the 28th ACM International Conference on Information and Knowledge Management, CIKM 2019<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019-11-03">2019. November 3-7, 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Couchbase Analytics: NoETL for Scalable NoSQL Data Analysis</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">I</forename><surname>Murtadha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ali</forename><surname>Hubail</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Alsuliman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Blow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dmitry</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Lychagin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Till</forename><surname>Maxon</surname></persName>
		</author>
		<author>
			<persName><surname>Westmann</surname></persName>
		</author>
		<idno type="DOI">10.14778/3352063.3352143</idno>
		<ptr target="https://doi.org/10.14778/3352063.3352143" />
	</analytic>
	<monogr>
		<title level="j">Proc. VLDB Endow</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2275" to="2286" />
			<date type="published" when="2019-08">2019. aug 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Rules and Ontologies in F-Logic</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<idno type="DOI">10.1007/11526988_2</idno>
		<ptr target="https://doi.org/10.1007/11526988_2" />
	</analytic>
	<monogr>
		<title level="m">Reasoning Web, First International Summer School 2005</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Norbert</forename><surname>Eisinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jan</forename><surname>Maluszynski</surname></persName>
		</editor>
		<meeting><address><addrLine>Msida, Malta</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005-07-25">2005. July 25-29, 2005</date>
			<biblScope unit="volume">3564</biblScope>
			<biblScope unit="page" from="22" to="34" />
		</imprint>
	</monogr>
	<note>Tutorial Lectures</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Logical Foundations of Object-Oriented and Frame-Based Languages</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Georg</forename><surname>Lausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1145/210332.210335</idno>
		<ptr target="https://doi.org/10.1145/210332.210335" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="741" to="843" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Sound, complete and minimal UCQ-rewriting for existential rules</title>
		<author>
			<persName><forename type="first">MÃ©lanie</forename><surname>KÃ¶nig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>LeclÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MichaÃ«l</forename><surname>Thomazo</surname></persName>
		</author>
		<idno type="DOI">10.3233/SW-140153</idno>
		<ptr target="https://doi.org/10.3233/SW-140153" />
	</analytic>
	<monogr>
		<title level="j">Semantic Web</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="451" to="475" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Query rewriting for existential rules with compiled preorder</title>
		<author>
			<persName><forename type="first">MÃ©lanie</forename><surname>KÃ¶nig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Leclere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI: International Joint Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3006" to="3112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Nominal Schemas in Description Logics: Complexities Clarified</title>
		<author>
			<persName><forename type="first">Markus</forename><surname>KrÃ¶tzsch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Rudolph</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference</title>
		<editor>
			<persName><forename type="first">Chitta</forename><surname>Baral</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Giuseppe</forename><surname>De</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Giacomo</forename></persName>
		</editor>
		<editor>
			<persName><forename type="first">Thomas</forename><surname>Eiter</surname></persName>
		</editor>
		<meeting><address><addrLine>KR; Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2014-07-20">2014. 2014. July 20-24, 2014</date>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Conjunctive Query Answering in the Description Logic EL Using a Relational Database System</title>
		<author>
			<persName><forename type="first">Carsten</forename><surname>Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wolter</surname></persName>
		</author>
		<ptr target="http://ijcai.org/Proceedings/09/Papers/341.pdf" />
	</analytic>
	<monogr>
		<title level="m">IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence</title>
		<meeting><address><addrLine>Pasadena, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Craig Boutilier</publisher>
			<date type="published" when="2009-07-11">2009. July 11-17, 2009</date>
			<biblScope unit="page" from="2070" to="2075" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A rule-based querying and updating language for XML</title>
		<author>
			<persName><forename type="first">Wolfgang</forename><surname>May</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Database Programming Languages: 8th International Workshop, DBPL 2001</title>
		<meeting><address><addrLine>Frascati, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2002. September 8-10, 2001</date>
			<biblScope unit="page" from="165" to="181" />
		</imprint>
	</monogr>
	<note>Revised Papers 8</note>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Datalography: Scaling datalog graph analytics on graph processing systems</title>
		<author>
			<persName><forename type="first">Vicky</forename><surname>Walaa Eldin Moustafa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ken</forename><surname>Papavasileiou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alin</forename><surname>Yocum</surname></persName>
		</author>
		<author>
			<persName><surname>Deutsch</surname></persName>
		</author>
		<idno type="DOI">10.1109/BigData.2016.7840589</idno>
		<ptr target="https://doi.org/10.1109/BigData.2016.7840589" />
	</analytic>
	<monogr>
		<title level="m">2016 IEEE International Conference on Big Data (IEEE BigData 2016</title>
		<editor>
			<persName><forename type="first">George</forename><surname>Karypis</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ling</forename><surname>Liu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Xiaohua</forename><surname>Hu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Ronay</forename><surname>Ak</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yinglong</forename><surname>Xia</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Weijia</forename><surname>Xu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Aki-Hiro</forename><surname>Sato</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sudarsan</forename><surname>Rachuri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Lyle</forename><forename type="middle">H</forename><surname>Ungar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Philip</forename><forename type="middle">S</forename><surname>Yu</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Rama</forename><surname>Govindaraju</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Toyotaro</forename><surname>Suzumura</surname></persName>
		</editor>
		<meeting><address><addrLine>Washington DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2016-12-05">2016. December 5-8, 2016</date>
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Ontology-Mediated Queries for NOSQL Databases</title>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marie-Christine</forename><surname>Rousset</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Federico</forename><surname>Ulliana</surname></persName>
		</author>
		<ptr target="http://www.aaai.org/ocs/index.php/AAAI/AAAI16/paper/view/12395" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth AAAI Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">Dale</forename><surname>Schuurmans</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Michael</forename><forename type="middle">P</forename><surname>Wellman</surname></persName>
		</editor>
		<meeting>the Thirtieth AAAI Conference on Artificial Intelligence<address><addrLine>Phoenix, Arizona, USA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2016-02-12">2016. February 12-17, 2016</date>
			<biblScope unit="page" from="1051" to="1057" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">RDFox: A highly-scalable RDF store</title>
		<author>
			<persName><forename type="first">Yavor</forename><surname>Nenov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Piro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Motik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ian</forename><surname>Horrocks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhe</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jay</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Semantic Web Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="3" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<author>
			<persName><forename type="first">Rodriguez</forename><surname>Olivier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ulliana</forename><surname>Federico</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mugnier</forename><surname>Marie-Laure</surname></persName>
		</author>
		<ptr target="https://gitlab.inria.fr/boreal-artifacts/pvldb2023" />
		<title level="m">Scalable Reasoning on Document Stores via Instance-Aware Query Rewriting</title>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>with Appendix</note>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">The SQL++ Semi-structured Data Model and Query Language: A Capabilities Survey of SQL-on-Hadoop, NoSQL and NewSQL Databases</title>
		<author>
			<persName><forename type="first">Win</forename><surname>Kian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannis</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Romain</forename><surname>Papakonstantinou</surname></persName>
		</author>
		<author>
			<persName><surname>Vernoux</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1405.3631</idno>
		<ptr target="http://arxiv.org/abs/1405.3631" />
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">A Scalable Algorithm for Answering Queries Using Views</title>
		<author>
			<persName><forename type="first">Rachel</forename><surname>Pottinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alon</forename><forename type="middle">Y</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Very Large Data Bases (VLDB '00)</title>
		<meeting>the 26th International Conference on Very Large Data Bases (VLDB '00)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="484" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Regular canonical systems</title>
		<author>
			<persName><forename type="first">BÃ¼chi</forename><surname>Richard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Archiv fÃ¼r mathematische Logik und Grundlagenforschung</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="91" to="111" />
			<date type="published" when="1964">1964. 1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title level="m" type="main">Xcerpt: A rule-based query and transformation language for the Web</title>
		<author>
			<persName><forename type="first">Finn</forename><surname>Sebastian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Schaffert</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
		<respStmt>
			<orgName>LMU MÃ¼nchen: Faculty of Mathematics, Computer Science and Statistics</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Dissertation. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">A gentle introduction to Xcerpt, a rulebased query and transformation language for XML</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Schaffert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">FranÃ§ois</forename><surname>Bry</surname></persName>
		</author>
		<ptr target="https://ceur-ws.org/Vol-60/bry_schaffert.pdf" />
	</analytic>
	<monogr>
		<title level="m">First International Semantic Web Conference ISWC2002 and hosted by SIG2 of the OntoWeb Network (CEUR Workshop Proceedings)</title>
		<editor>
			<persName><forename type="first">Michael</forename><surname>Schroeder</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gerd</forename><surname>Wagner</surname></persName>
		</editor>
		<meeting><address><addrLine>Sardinia, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06-14">2002. 14 June 2002</date>
			<biblScope unit="volume">60</biblScope>
		</imprint>
	</monogr>
	<note>RuleML 2002, Proceedings of the International Workshop on Rule Markup Languages for Business Rules on the Semantic Web</note>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">XMark: A Benchmark for XML Data Management</title>
		<author>
			<persName><forename type="first">Albrecht</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Florian</forename><surname>Waas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><forename type="middle">L</forename><surname>Kersten</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioana</forename><surname>Manolescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralph</forename><surname>Busse</surname></persName>
		</author>
		<idno type="DOI">10.1016/B978-155860869-6/50096-2</idno>
		<ptr target="https://doi.org/10.1016/B978-155860869-6/50096-2" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of 28th International Conference on Very Large Data Bases, VLDB 2002</title>
		<meeting>28th International Conference on Very Large Data Bases, VLDB 2002<address><addrLine>Hong Kong</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2002-08-20">2002. August 20-23, 2002</date>
			<biblScope unit="page" from="974" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Automata for XML-a survey</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Schwentick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="289" to="315" />
			<date type="published" when="2007">2007. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Querying XML Views of Relational Data</title>
		<author>
			<persName><forename type="first">Jayavel</forename><surname>Shanmugasundaram</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jerry</forename><surname>Kiernan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eugene</forename><forename type="middle">J</forename><surname>Shekita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Catalina</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">E</forename><surname>Funderburk</surname></persName>
		</author>
		<ptr target="http://www.vldb.org/conf/2001/P261.pdf" />
	</analytic>
	<monogr>
		<title level="m">VLDB 2001, Proceedings of 27th International Conference on Very Large Data Bases</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Peter</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Paolo</forename><surname>Apers</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Atzeni</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Stefano</forename><surname>Ceri</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kotagiri</forename><surname>Paraboschi</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Ramamohanarao</surname></persName>
		</editor>
		<editor>
			<persName><surname>Snodgrass</surname></persName>
		</editor>
		<meeting><address><addrLine>Roma, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="2001-09-11">2001. September 11-14, 2001</date>
			<biblScope unit="page" from="261" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">More efficient datalog queries: subsumptive tabling beats magic sets</title>
		<author>
			<persName><forename type="first">Tekle</forename><surname>Tuncay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanhong</forename><forename type="middle">A</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2011 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="661" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Rewriting of visibly pushdown languages for xml data integration</title>
		<author>
			<persName><forename type="first">Alex</forename><surname>Thomo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srinivasan</forename><surname>Venkatesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM Conference on Information and Knowledge Management</title>
		<meeting>the 17th ACM Conference on Information and Knowledge Management</meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="521" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Materializing knowledge bases via trigger graphs</title>
		<author>
			<persName><forename type="first">Efthymia</forename><surname>Tsamoura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Carral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Enrico</forename><surname>Malizia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="943" to="956" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">KOGNAC: Efficient Encoding of Large Knowledge Graphs</title>
		<author>
			<persName><forename type="first">Jacopo</forename><surname>Urbani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sourav</forename><surname>Dutta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sairam</forename><surname>Gurajada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><surname>Weikum</surname></persName>
		</author>
		<ptr target="http://www.ijcai.org/Abstract/16/548" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016</title>
		<editor>
			<persName><forename type="first">Subbarao</forename><surname>Kambhampati</surname></persName>
		</editor>
		<meeting>the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IJCAI/AAAI Press</publisher>
			<date type="published" when="2016-07">2016. July 2016</date>
			<biblScope unit="page" from="3896" to="3902" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>