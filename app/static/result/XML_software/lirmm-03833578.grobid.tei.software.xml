<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xml:space="preserve" xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Deciding Hyperproperties Combined with Functional Specifications</title>
				<funder ref="#_JEmEAjn">
					<orgName type="full">Center for Perspicuous Systems)</orgName>
				</funder>
				<funder ref="#_bcZcRJj">
					<orgName type="full">German Research Foundation (DFG)</orgName>
				</funder>
				<funder ref="#_RaccuPu">
					<orgName type="full">Center for Advancing Electronics Dresden</orgName>
				</funder>
				<funder ref="#_2ZKn6m8">
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
				<funder ref="#_vxXfdrg">
					<orgName type="full">Bundesministerium fÃ¼r Bildung und Forschung (BMBF)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher />
				<availability status="unknown"><licence /></availability>
				<date type="published" when="2022-05-30">30 May 2022</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">CISPA Helmholtz Center for Information Security Germany</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">David</forename><surname>Carral</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">University of Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS France</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">CISPA Helmholtz Center for Information Security Germany</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jana</forename><surname>Hofmann</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">CISPA Helmholtz Center for Information Security Germany</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Markus</forename><surname>KrÃ¶tzsch</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Technische UniversitÃ¤t Dresden</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Deciding Hyperproperties Combined with Functional Specifications</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2022-05-30">30 May 2022</date>
						</imprint>
					</monogr>
					<idno type="MD5">6AF4BFFD862E50007D25F7701F6602DE</idno>
					<idno type="DOI">10.1145/3531130.3533369</idno>
					<idno type="arXiv">arXiv:2205.15138v1[cs.LO]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid" />
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CCS Concepts:</term>
					<term>Theory of computation â†’ Logic and verification; Modal and temporal logics Hyperproperties</term>
					<term>HyperLTL</term>
					<term>Satisfiability ACM</term>
				</keywords>
			</textClass>
			<abstract>
<div><p>We study satisfiability for HyperLTL with a âˆ€ * âˆƒ * quantifier prefix, known to be highly undecidable in general. HyperLTL can express system properties that relate multiple traces (socalled hyperproperties), which are often combined with trace properties that specify functional behavior on single traces. Following this conceptual split, we first define several safety and liveness fragments of âˆ€ * âˆƒ * HyperLTL, and characterize the complexity of their (often much easier) satisfiability problem. We then add LTL trace properties as functional specifications. Though (highly) undecidable in many cases, this way of combining "simple" HyperLTL and arbitrary LTL also leads to interesting new decidable fragments. This systematic study of âˆ€ * âˆƒ * fragments is complemented by a new (incomplete) algorithm for âˆ€âˆƒ * -HyperLTL satisfiability.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div><head n="1">Introduction</head><p>Hyperproperties are properties that relate multiple execution traces of a system <ref type="bibr" target="#b12">[13]</ref> and comprise a range of relevant properties from many areas of computer science. Examples are symmetry, optimality, robustness, and noninterference. The most prominent logic for expressing hyperproperties is HyperLTL <ref type="bibr" target="#b11">[12]</ref>, which extends LTL with trace quantification. Generalized noninterference <ref type="bibr" target="#b33">[33]</ref>, for example, states that high-security inputs do not influence the input-output behavior observable by a low-security user, which can be expressed in HyperLTL as follows.</p><p>âˆ€ğœ‹âˆ€ğœ‹ â€² âˆƒğœ‹ â€²â€² .</p><formula xml:id="formula_0">ğ‘ âˆˆğ¿ out âˆªğ¿ in (ğ‘ ğœ‹ â†” ğ‘ ğœ‹ â€²â€² ) âˆ§ ğ‘ âˆˆğ» in (ğ‘ ğœ‹ â€² â†” ğ‘ ğœ‹ â€²â€² )</formula><p>The formula states that for every two traces ğœ‹, ğœ‹ â€² , there exists a trace ğœ‹ â€²â€² that combines the low-security inputs and outputs on ğœ‹ and the high-security inputs on ğœ‹ â€² .</p><p>In this paper, we study the satisfiability problem of Hyper-LTL. For LTL, satisfiability is PSPACE-complete <ref type="bibr" target="#b39">[39]</ref>. For hyperproperties, satisfaction cannot be decided by analyzing single traces in isolation, making formal reasoning challenging. Deciding satisfiability in the âˆƒ * âˆ€ * fragment of HyperLTL is already EXPSPACE-complete <ref type="bibr" target="#b18">[19]</ref>; and deciding hyperproperties with a âˆ€ * âˆƒ * trace quantifier alternations is, in general, strongly undecidable, namely Î£ 1 1 -complete <ref type="bibr" target="#b23">[24]</ref>. The âˆ€ * âˆƒ * fragment contains many relevant properties like generalized noninterference, program refinement, and software doping <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b33">33]</ref>. However, positive results for this important fragment have been very rare and were only obtained by heavy restrictions on the use of temporal operators or by assuming finite models <ref type="bibr" target="#b32">[32]</ref> (see related work below). Algorithms, even if incomplete, are similarly missing.</p><p>In this work, we address these shortcomings by studying ways of solving satisfiability of âˆ€ * âˆƒ * HyperLTL specifications. We identify simple yet expressive fragments of âˆ€ * âˆƒ * with better computational properties, where our approach derives interesting fragments in two steps. First, we split a specification into hyperproperty and trace property, so that we can focus on "simple" hyperproperties. Second, to find such simple hyperproperties, we systematically study fragments of temporal safety and temporal liveness hyperproperties. This work towards new decidable fragments is complemented by a new (incomplete but often successful) algorithm that is applicable to arbitrary âˆ€âˆƒ * specifications.</p><p>Splitting in Hyperproperties and Trace Properties. So far, all HyperLTL decidability results were obtained by considering HyperLTL specifications in isolation. Most of the time, however, specifications refer to a specific system. The hyperproperty itself is often relatively simple (like the noninterference property above) and only gets difficult to satisfy given a specification of the functional behavior of the system. <ref type="foot" target="#foot_0">1</ref> The following example highlights this interplay between functional property and hyperproperty.</p><p>Example 1.1. Consider a system of agents that send and receive data. Each trace describes the behavior of a single agent. We want the system to satisfy the following hyperproperty.</p><formula xml:id="formula_1">ğœ‘ âˆ€ğœ‹âˆƒğœ‹ â€² . (send ğœ‹ âˆ§ rec ğœ‹ â€² )</formula><p>The formula states that each agent eventually sends its information and that there exists some agent receiving it. The formula on its own is easily satisfiable already by a one-trace model. In addition to the hyperproperty we add the simple functional specification (trace property)</p><formula xml:id="formula_2">ğœ“ (Â¬rec) U (rec âˆ§ Â¬rec) âˆ§ (rec â†” send)</formula><p>which expresses that each agent receives data exactly once and sends it forth in the next step. Every model that satisfies the combination of ğœ‘ and ğœ“ needs to be infinite. Automatically checking satisfiability is thus complex as we cannot iteratively search for models of bounded (finite) size. â—</p><p>A satisfiability checker that distinguishes between a functional specification and hyperproperties could be used to sanity-check whether a hyperproperty is satisfiable in combination with the specification of the system at hand.</p><p>Temporal Safety and Temporal Liveness. The classification into safety and liveness has a long tradition in the study of trace properties, where especially safety often allows for easier algorithms. For our analysis, we define analogous fragments: a HyperLTL formula is temporal safety (resp. temporal liveness) if its LTL body describes a safety (resp. liveness) property. We study the relationship to the existing notations of hypersafety and hyperliveness defined by Clarkson and Schneider <ref type="bibr" target="#b12">[13]</ref>. Guided by our insights into the complete fragments, we derive several more specific classes of temporal safety and liveness properties, for which satisfiability is easier to decide.</p><p>Main Results. Our results are summarized in Table <ref type="table" target="#tab_0">1</ref>, where each line represents a class of HyperLTL properties, and the columns distinguish whether or not additional (arbitrarily complex) LTL specifications are allowed. All hardness results for âˆ€ * âˆƒ * fragments, except in the NEXP cases, already hold for âˆ€âˆƒ * . The restriction to temporal safety makes the satisfiability of HyperLTL drop from Î£ 1  1 to coRE, which we show by an effective reduction to satisfiability of first-order logic. While still undecidable, this enables the use of common first-order techniques such as resolution, tableaux, and related methods <ref type="bibr" target="#b36">[36]</ref>. Hardness already holds for simple formulas consisting only of a single with s in its scope. If we add (non-safety) functional specifications, hardness jumps back to Î£ 1 1 . In contrast to temporal safety properties, the class of temporal liveness HyperLTL formulas is of analytical complexity, even without additional LTL specifications. However, again in contrast to ( * ), formulas from the âˆ€âˆƒ * . ( * ) fragment are decidable, even when combined with an arbitrary LTL specification. This is the first Hyper-LTL decidability result for formulas that can enforce models with infinitely many traces. The class also contains the specification from Example 1.1. This decidability result is tight in the sense that already conjunctions of multiple eventualities are analytical again.</p><p>Finally, to complement our decidability results, we propose a general approximation algorithm to find the largest model for specifications consisting of a HyperLTL formula and an LTL formula. Our experimental evaluation shows that our algorithm performs significantly better than approaches that iteratively search for models of bounded size <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">32]</ref> and can even show unsatisfiability for many formulas (which is impossible in bounded approaches).</p><p>Structure. The remainder of this paper is structured as follows. We give some basic preliminaries and introduce HyperLTL in Section 2. We study the fragment of temporal safety in Section 3. We begin this study with the full fragment, and then gradually decrease in expressiveness all the way to the fragment containing only operators. We then move to temporal liveness in Section 4. Analogous to the safety case, we begin with the full fragment, gradually decreasing to the fragment of pure eventualities, for which we establish decidability. Finally, in Section 5, we describe our approximation for finding the largest models and report on experimental results in Section 6.</p><p>Related Work. In recent years, many logics to express hyperproperties have been developed. Most approaches extend existing logics with trace or path quantification, examples besides HyperLTL are HyperCTL * <ref type="bibr" target="#b12">[13]</ref>, HyperQPTL <ref type="bibr" target="#b35">[35]</ref>, HyperPDL-Î” <ref type="bibr" target="#b26">[26]</ref>, and HyperATL * <ref type="bibr" target="#b5">[6]</ref>. Monadic first-order logics can be extended by adding a special equal-level predicate <ref type="bibr" target="#b21">[22]</ref> or using different types of quantifiers <ref type="bibr" target="#b3">[4]</ref>. Recently, hyperproperties have also been obtained via a team semantics for trace logics <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b42">42]</ref>. Apart from plain temporal logics, there are also hyperlogics for hyperproperties that are asynchronous <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b27">27]</ref>, quantitative <ref type="bibr" target="#b20">[21]</ref>, or probabilistic <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>HyperLTL remains the most used among the proposed hyperlogics. Its satisfiability problem is known to be challenging: if we define fragments based on quantifier prefixes (but with an arbitrary body), then âˆƒ * âˆ€ * is the most general fragment for which satisfiability is still decidable (and EXPSPACEcomplete), whereas âˆ€âˆƒ * already leads to undecidability <ref type="bibr" target="#b18">[19]</ref>. In fact, the âˆ€ * âˆƒ * fragment is already satisfiability-complete: any HyperLTL formula can be effectively translated into equisatisfiable âˆ€ * âˆƒ * formula <ref type="bibr" target="#b32">[32]</ref>. Analyzing the case of (unrestricted) HyperLTL in more detail, Fortin et al. show satisfiability to be Î£ 1 1 -complete, and therefore above all problems in the arithmetic hierarchy <ref type="bibr" target="#b23">[24]</ref>. In a more fine-grained analysis, Mascle and Zimmermann show that the problem becomes decidable if one only considers models of a bounded size or if, for selected quantifier prefixes, temporal operators are not nested <ref type="bibr" target="#b32">[32]</ref>. In particular, âˆ€âˆƒ * properties using only and (without s) are decidable (and always have a finite model), as no "diagonal" comparison between trace positions is possible <ref type="bibr" target="#b32">[32]</ref>. The satisfiability of the logics HyperQPTL and HyperCTL * , which both subsume HyperLTL, has been studied as well <ref type="bibr" target="#b13">[14]</ref>.</p></div>
<div><head n="2">Preliminaries</head><p>We assume a fixed, finite set of atomic propositions AP and write Î£ 2 AP . Given a symbol ğœ‹, we write AP ğœ‹ for the set</p><formula xml:id="formula_3">{ğ‘ ğœ‹ | ğ‘ âˆˆ AP }. A trace ğ‘¡ is an element in Î£ ğœ” . For ğ‘– âˆˆ N, ğ‘¡<label>(</label></formula><p>ğ‘–) denotes the ğ‘–th element in ğ‘¡ (starting with the 0th) and ğ‘¡ [ğ‘–, âˆ] is the suffix of a trace starting in point in time ğ‘–. For a finite trace ğ‘¢ âˆˆ Î£ * and an infinite trace ğ‘¡ âˆˆ Î£ ğœ” , ğ‘¢ is a prefix of ğ‘¡ (written ğ‘¢ â‹– ğ‘¡) if for every 0 â‰¤ ğ‘– &lt; |ğ‘¢ |, ğ‘¢ (ğ‘–) = ğ‘¡ (ğ‘–). A trace property ğ‘ƒ is a set of traces, whereas a hyperproperty ğ» is a set of sets of traces <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div><head n="2.1">Trace Properties and LTL</head><p>Linear temporal logic (LTL) defines trace properties by combining temporal operators with boolean connectives. Its syntax is defined by the following grammar.</p><formula xml:id="formula_4">ğœ“ ğ‘ | Â¬ğœ“ | ğœ“ âˆ§ ğœ“ | ğœ“ | ğœ“ U ğœ“</formula><p>where ğ‘ âˆˆ AP. We also use the standard Boolean connectives âˆ§, â†’, â†” and constants âŠ¤, âŠ¥, as well as the derived LTL operators eventually ğœ“ âŠ¤ U ğœ“ , and globally ğœ“ Â¬ Â¬ğœ“ . The semantics of LTL is defined as usual.</p></div>
<div><head>ğ‘¡ |= ğ‘</head><p>iff ğ‘ âˆˆ ğ‘¡ (0)</p><formula xml:id="formula_5">ğ‘¡ |= Â¬ğœ“ iff ğ‘¡ Ì¸ |= ğœ“ ğ‘¡ |= ğœ“ 1 âˆ§ ğœ“ 2 iff ğ‘¡ |= ğœ“ 1 and ğ‘¡ |= ğœ“ 2 ğ‘¡ |= ğœ“ iff ğ‘¡ [1, âˆ] |= ğœ“ ğ‘¡ |= ğœ“ 1 U ğœ“ 2 iff âˆƒğ‘–. ğ‘¡ [ğ‘–, âˆ] |= ğœ“ 2 and âˆ€ğ‘— &lt; ğ‘–. ğ‘¡ [ ğ‘—, âˆ] |= ğœ“ 1</formula><p>Safety and liveness properties are prominent classes of trace properties <ref type="bibr" target="#b1">[2]</ref>. Safety properties are characterized by the fact that each violation is caused after a finite time. Liveness properties characterize that something good happens eventually.</p><p>Definition 2.1. A property ğ‘ƒ is safety if it holds that for every trace ğ‘¡ âˆ‰ ğ‘ƒ, there exists a ğ‘¢ â‹– ğ‘¡ such that for every ğ‘¡ â€² with ğ‘¢ â‹– ğ‘¡ â€² , we have ğ‘¡ â€² âˆ‰ ğ‘ƒ. A property ğ‘ƒ is liveness if for every ğ‘¢ âˆˆ Î£ * , there exists a ğ‘¡ âˆˆ Î£ ğœ” with ğ‘¢ â‹– ğ‘¡ and ğ‘¡ âˆˆ ğ‘ƒ.</p></div>
<div><head n="2.2">Hyperproperties and HyperLTL</head><p>HyperLTL <ref type="bibr" target="#b11">[12]</ref> extends LTL with explicit quantification over traces, thereby lifting it from a logic expressing trace properties to one expressing hyperproperties <ref type="bibr" target="#b12">[13]</ref>. Let V be a set of trace variables. We define HyperLTL formulas with the following grammar.</p><formula xml:id="formula_6">ğœ‘ âˆƒğœ‹ . ğœ‘ | âˆ€ğœ‹ . ğœ‘ | ğœ™ ğœ™ ğ‘ ğœ‹ | Â¬ğœ™ | ğœ™ âˆ§ ğœ™ | ğœ™ | ğœ™ U ğœ™</formula><p>Here, ğœ‹ âˆˆ V and ğ‘ âˆˆ AP. We consider only closed formulas, i.e., formulas where for each atom ğ‘ ğœ‹ the trace variable ğœ‹ is bound by some trace quantifier. The semantics of HyperLTL is given with respect to a set of traces ğ‘‡ and a trace assignment Î , which is a partial mapping Î  : V â‡€ Î£ ğœ” . For ğœ‹ âˆˆ V and ğ‘¡ âˆˆ ğ‘‡ , we write Î [ğœ‹ â†¦ â†’ ğ‘¡] for the trace assignment obtained by updating the value of ğœ‹ to ğ‘¡. We write</p><formula xml:id="formula_7">Î [ğ‘–, âˆ] for the assignment Î [ğ‘–, âˆ] (ğœ‹) Î (ğœ‹) [ğ‘–, âˆ]. Î  |= ğ‘‡ ğ‘ ğœ‹ iff ğ‘ âˆˆ Î (ğœ‹) (0) Î  |= ğ‘‡ Â¬ğœ™ iff Î  Ì¸ |= ğ‘‡ ğœ™ Î  |= ğ‘‡ ğœ™ 1 âˆ§ ğœ™ 2 iff Î  |= ğ‘‡ ğœ™ 1 and Î  |= ğ‘‡ ğœ™ 2 Î  |= ğ‘‡ ğœ™ iff Î [1, âˆ] |= ğ‘‡ ğœ™ Î  |= ğ‘‡ ğœ™ 1 U ğœ™ 2 iff âˆƒğ‘–. Î [ğ‘–, âˆ] |= ğ‘‡ ğœ™ 2 and âˆ€ğ‘— &lt; ğ‘–. Î [ ğ‘—, âˆ] |= ğ‘‡ ğœ™ 1 Î  |= ğ‘‡ âˆƒğœ‹ . ğœ‘ iff âˆƒğ‘¡ âˆˆ ğ‘‡ . Î [ğœ‹ â†¦ â†’ ğ‘¡] |= ğ‘‡ ğœ‘ Î  |= ğ‘‡ âˆ€ğœ‹ . ğœ‘ iff âˆ€ğ‘¡ âˆˆ ğ‘‡ . Î [ğœ‹ â†¦ â†’ ğ‘¡] |= ğ‘‡ ğœ‘</formula><p>We say that ğ‘‡ is a model of Analogous to trace properties, we can characterize hyperproperties as hypersafety and hyperliveness <ref type="bibr" target="#b12">[13]</ref>. We lift the prefix relation â‹– to sets of traces: a set ğ‘ˆ âŠ† Î£ * of finite traces is a prefix of a set ğ‘‡ âŠ† Î£ ğœ” (written ğ‘ˆ â‹–ğ‘‡ ) if, for every ğ‘¢ âˆˆ ğ‘ˆ , there exists a ğ‘¡ âˆˆ ğ‘‡ such that ğ‘¢ â‹– ğ‘¡. Definition 2.3. A hyperproperty ğ» is hypersafety if for every ğ‘‡ âŠ† Î£ ğœ” with ğ‘‡ âˆ‰ ğ» , there exists a finite set ğ‘ˆ âŠ† Î£ * with ğ‘ˆ â‹– ğ‘‡ such that, for every ğ‘‡ â€² âŠ† Î£ ğœ” with ğ‘ˆ â‹– ğ‘‡ â€² , we have ğ‘‡ â€² âˆ‰ ğ» . A property ğ» is hyperliveness if for every finite set ğ‘ˆ âŠ† Î£ * , there exists ğ‘‡ âŠ† Î£ ğœ” with ğ‘ˆ â‹– ğ‘‡ and ğ‘‡ âˆˆ ğ» .</p><p>Intuitively, a violation of a hypersafety property can be explained by the finite interaction of finitely many traces. Conversely, a hyperproperty is hyperliveness, if such a set can always be extended to a set satisfying the property.</p></div>
<div><head n="2.3">Specifications and Notation</head><p>We study the combination of âˆ€ * âˆƒ * HyperLTL formulas and arbitrary LTL formulas, and call such pairs specifications. Definition 2.4. A specification is a pair (ğœ“, ğœ‘) where ğœ“ is an LTL formula and ğœ‘ a HyperLTL formula. We say that (ğœ“, ğœ‘) is satisfiable iff there exists a non-empty set of traces ğ‘‡ âŠ† Î£ ğœ” such that âˆ€ğ‘¡ âˆˆ ğ‘‡ . ğ‘¡ |= ğœ“ and ğ‘‡ |= ğœ‘.</p><p>In general, we write (ğœ“, ğœ‘) for specifications with arbitrary LTL and HyperLTL formulas. We use the following notation for fragments of specifications. We write (âŠ¤, ğœ‘) to indicate that no LTL formula is given or, equivalently, the trace specification is true. We represent the quantifier prefix of the HyperLTL property using regular expressions. For example, âˆ€âˆƒ * is a prefix consisting of a single universal quantifier followed by any number of existential quantifiers. We write ğ‘„ * for an arbitrary prefix. The body of a HyperLTL formula is structured based on the use of temporal operators. We allow propositional (temporal-operator-free) formulas as conjuncts if not stated otherwise Consider the following example. A âˆ€ * âˆƒ * . ( * ) formula is of the form âˆ€ğœ‹ 1 . . . âˆ€ğœ‹ ğ‘› âˆƒğœ‹ ğ‘›+1 . . . âˆƒğœ‹ ğ‘›+ğ‘š . ( ğœ™) âˆ§ ğœ™ â€² , where ğœ™ may contain (potentially nested) operators and ğœ™ â€² does not contain any temporal operators. Analogously, a formula in âˆ€ * âˆƒ * . describes formulas as the one above but ğœ™ may not contain s. A formula in âˆ€ * âˆƒ * . âˆ§ uses a conjunction of two eventualities (also without s).</p></div>
<div><head n="2.4">Complexity of Undecidable Problems</head><p>Many problems considered in this paper are highly undecidable. To enable precise quantification of "how undecidable", we briefly recall the arithmetic and analytical hierarchy. We only provide a brief overview and refer to <ref type="bibr" target="#b37">[37]</ref> for details.</p><p>The arithmetic hierarchy contains all problems (languages) that can be expressed in first-order arithmetic over the natural numbers. It contains the class of recursively enumerable (RE) and co-enumerable problems (coRE) in its first level. The class Î£ 1 1 (sitting in the analytical hierarchy) contains all problems that can be expressed with existential second-order quantification (over sets of numbers) followed by a firstorder arithmetic formula. Analogously, the class Î  1  1 contains all problems expressible using universal second-order quantification. Consequently, both Î£ 1 1 and Î  1 1 (strictly) contain the entire arithmetic hierarchy.</p></div>
<div><head n="2.5">Machines</head><p>As a basic model of computation to show hardness we use two-counter machines. A nondeterministic 2-counter machine (2CM) consists of a finite set of instructions ğ‘™ 1 , . . . ğ‘™ ğ‘› , which modify two counters ğ‘ 1 , ğ‘ </p><formula xml:id="formula_8">. A config- uration of a 2CM is a tuple (ğ‘™ ğ‘– , ğ‘£ 1 , ğ‘£ 2 )</formula><p>, where ğ‘™ ğ‘– is the next instruction to be executed, and ğ‘£ 1 , ğ‘£ 2 âˆˆ N denote the values of the counters. The initial configuration of a 2CM is (ğ‘™ 1 , 0, 0). The transition relation between configurations is defined as expected. Decrementing a counter that is already 0 leaves the counter unchanged. A 2CM halts if a configuration with a halt instruction is reached. Deciding if a machine has a halting computation is RE-complete and deciding if it has an infinite computation is coRE-complete <ref type="bibr" target="#b34">[34]</ref>. An infinite computation is recurring if it visits instruction ğ‘™ 1 infinitely many times. Deciding if a machine has a recurring computation, is Î£ 1 1 -hard <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23]</ref>.</p></div>
<div><head n="3">Temporal Safety</head><p>In this section, we study the satisfiability problem of temporal safety HyperLTL formulas. We begin by defining temporal safety and argue why, compared to hypersafety, it is the more suitable fragment in the context of satisfiability. Subsequently, we show that temporal safety specifications improve the general Î£ 1 1 -hardness of âˆ€ * âˆƒ * hyperproperties <ref type="bibr" target="#b23">[24]</ref> to coRE-complete. We obtain this result by a reduction to satisfiability of first-order logic. In the next step, we investigate the combination of temporally safe hyperproperties with arbitrary functional trace specifications given in LTL. The complexity jumps again to Î£ 1 1 -completeness, perhaps surprisingly already for very basic âˆ€âˆƒ * formulas only using one as temporal operator. We, therefore, analyze the remaining fragments for decidability results and establish that hyperproperties that only use s as temporal operators are NEXPTIME-complete, even when adding arbitrary LTL specifications. The same holds for hyper-invariants (using ) without an LTL specification.</p></div>
<div><head n="3.1">Hypersafety and Temporal Safety</head><p>The safety fragment of LTL is one of the most successful fragments of temporal logics as it is amendable to easier monitoring and verification than arbitrary ğœ”-regular properties <ref type="bibr" target="#b30">[30]</ref>. The concept of a safety property (i.e., every violation is caused after a finite time) naturally extends to hyperproperties, giving the general class of hypersafety (cf. Definition 2.3) <ref type="bibr" target="#b12">[13]</ref>. However, hypersafety is not well suited for a systematic study of the decidability of hyperproperties.</p><p>Deciding if a property is hypersafety is already highly undecidable and deciding if a hypersafety property is satisfiable is directly reducible to LTL satisfiability.</p><p>Proposition 3.1. Deciding if a HyperLTL formula ğœ‘ is hypersafety is Î  1 1 -hard. Proof. As shown in <ref type="bibr" target="#b17">[18,</ref><ref type="bibr">Thm. 23]</ref>, for any HyperLTL formula ğœ‘ we can effectively construct a formula ğœ‘ â€² such that ğœ‘ is unsatisfied iff ğœ‘ â€² is hypersafety. As HyperLTL unsatisfiability is Î  1 1 -hard <ref type="bibr" target="#b23">[24]</ref>, the hardness follows. â–¡ Proposition 3.2. Given a HyperLTL formula ğœ‘ that is hypersafety, satisfiability of ğœ‘ is decidable in PSPACE.</p><p>Proof. As hypersafety properties are closed under subsets <ref type="bibr" target="#b12">[13]</ref>, ğœ‘ is satisfiable iff it is satisfiable by a single trace model. Therefore, we can collapse all quantifiers in ğœ‘ to universal ones, giving an equisatisfiable (but not equivalent) âˆ€ * formula for which satisfiability is decidable in PSPACE <ref type="bibr" target="#b18">[19]</ref>. â–¡ Instead of focusing on hypersafety, we study the satisfiability problem for a broader fragment of formulas which we call temporally safe. Definition 3.3. A HyperLTL formula ğ‘„ğœ‹ 1 . . . ğ‘„ğœ‹ ğ‘› . ğœ™ is temporal safety if ğœ™ (interpreted as an LTL formula over AP ğœ‹ 1 âˆª . . . âˆª AP ğœ‹ ğ‘› ) describes a safety property.</p><p>Similar to the case of LTL <ref type="bibr" target="#b30">[30]</ref>, the safety restriction on the body of the HyperLTL formula allows for easier verification (see, e.g., <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>). We argue that temporal safety is also an interesting fragment to study in the context of satisfiability. First, compared with hypersafety, it is decidable whether a formula is temporally safe, as safety is recognizable for LTL <ref type="bibr" target="#b38">[38]</ref>. Second, the next two propositions show that temporal safety defines an expressive fragment: it subsumes all âˆ€ * âˆƒ * hypersafety properties. Proposition 3.4. For any âˆ€ * hypersafety property, there exists an equivalent âˆ€ * property that is temporally safe.</p><p>Proof. Let ğœ‘ = âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› . ğœ™ be the hypersafety property. For any function ğ‘“ : {1, . . . , ğ‘›} â†’ {1, . . . , ğ‘›} (of which there are ğ‘› ğ‘› many) we define the formula ğœ™ [ğ‘“ ] as the formula obtained by replacing each trace variable ğœ‹ ğ‘– for 1 â‰¤ ğ‘– â‰¤ ğ‘š with ğœ‹ ğ‘“ (ğ‘–) . Define ğœ‘ â€² âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› . ğœ™ â€² where ğœ™ â€² ğ‘“ :{1,...,ğ‘› }â†’{1,...,ğ‘› }</p></div>
<div><head>ğœ™ [ğ‘“ ]</head><p>It is easy to see that ğœ‘ â‰¡ ğœ‘ â€² (using the semantics of universal quantification). We claim that ğœ™ â€² expresses a safety property when interpreted as trace property over</p><formula xml:id="formula_9">AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘› . Take any trace ğ‘¡ over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆªAP ğœ‹ ğ‘› with ğ‘¡ Ì¸ |= ğœ™ â€² (</formula><p>as in the definition of safety, cf. Definition 2.1). Let ğ‘‡ = {ğ‘¡ 1 , . . . , ğ‘¡ ğ‘› } be the set obtained by splitting ğ‘¡ into ğ‘› traces, i.e., ğ‘¡ ğ‘– is a trace over AP that copies the assignments to AP ğœ‹ ğ‘– on ğ‘¡. By construction of ğ‘‡ we get ğ‘‡ Ì¸ |= ğœ‘ â€² and, as ğœ‘ â‰¡ ğœ‘ â€² is hypersafety, we get a finite set of finite traces ğ‘ˆ â‹–ğ‘‡ such that no extension of ğ‘ˆ satisfies ğœ‘. We assume that ğ‘ˆ = {ğ‘¢ 1 , . . . , ğ‘¢ ğ‘› } where ğ‘¢ ğ‘– â‹–ğ‘¡ ğ‘– for each ğ‘–. This assumption is w.l.o.g., as we can replace multiple prefixes of the same ğ‘¡ ğ‘– by the longest among those prefixes, and add an arbitrary prefix of each ğ‘¡ ğ‘– that previously had no prefix in ğ‘ˆ . We further assume, again w.l.o.g., that all ğ‘¢ ğ‘– s have the same length, say ğ‘˜. Now define ğ‘¢ as the finite trace (of length ğ‘˜) over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘› , where the assignment to AP ğœ‹ ğ‘– is taken from ğ‘¢ ğ‘– . As ğ‘¢ ğ‘– â‹– ğ‘¡ ğ‘– for each ğ‘–, we get ğ‘¢ â‹– ğ‘¡. It remains to argue that ğ‘¢ is a bad prefix of ğœ™ â€² . Let ğ‘¡ â€² be any trace with ğ‘¢ â‹– ğ‘¡ â€² . We, again, split </p><formula xml:id="formula_10">ğ‘¡ â€² into traces ğ‘¡ â€² 1 , . . . , ğ‘¡ â€² ğ‘› . Now ğ‘‡ â€² {ğ‘¡ â€² 1 , . . . , ğ‘¡ â€² ğ‘› } satisfies ğ‘ˆ â‹– ğ‘‡ â€² , so ğ‘‡ â€² Ì¸ |= ğœ‘. By the semantics of universal quantification, there thus exists a ğ‘“ such that [ğœ‹ 1 â†¦ â†’ ğ‘¡ â€² ğ‘“ (1) , . . . , ğœ‹ ğ‘› â†¦ â†’ ğ‘¡ â€² ğ‘“ (ğ‘›) ] Ì¸ |= ğœ™ and so [ğœ‹ 1 â†¦ â†’ ğ‘¡ â€² 1 , . . . , ğœ‹ ğ‘› â†¦ â†’ ğ‘¡ â€² ğ‘› ] Ì¸ |= ğœ™ [ğ‘“ ] . This implies that ğ‘¡ â€² Ì¸ |= ğœ™ [ğ‘“ ] in</formula></div>
<div><head n="3.2">Temporal Safety without Functional Specifications</head><p>Having established that temporal safety spans a broad spectrum of properties, we now establish that the general analytical hardness of HyperLTL <ref type="bibr" target="#b23">[24]</ref> drops to coRE-completeness for temporal safety.</p><p>Theorem 3.7. The satisfiability problem of temporally safe HyperLTL is coRE-complete.</p><p>We show the upper bound of Theorem 3.7 by giving an effective translation from temporally safe HyperLTL to firstorder logic using the fact that satisfiability of first-order logic is coRE-complete <ref type="bibr" target="#b25">[25]</ref>. Our translation enables the application of first-order satisfiability solvers in the realm of hyperproperties.</p><p>Definition 3.8. A safety automaton over alphabet Î£ is a tuple A = (ğ‘„, ğ‘ 0 , ğ›¿) where ğ‘„ is a finite set of states, ğ‘ 0 âˆˆ ğ‘„ the initial state, and ğ›¿ âŠ† ğ‘„ Ã—Î£Ã—ğ‘„ is the transition relation. A trace ğ‘¡ âˆˆ Î£ ğœ” is accepted by A if there exists some infinite run ğ‘Ÿ âˆˆ ğ‘„ ğœ” such that ğ‘Ÿ (0) = ğ‘ 0 and for all ğ‘–, (ğ‘Ÿ (ğ‘–), ğ‘¡ (ğ‘–), ğ‘Ÿ (ğ‘– + 1)) âˆˆ ğ›¿. For every safety trace property ğœ™, there exists a safety automaton that accepts ğœ™ <ref type="bibr" target="#b30">[30]</ref>.</p><p>Proposition 3.9. The satisfiability problem of temporally safe HyperLTL is in coRE.</p><formula xml:id="formula_11">Proof. Let ğœ‘ = ğ‘„ 1 ğœ‹ 1 . . . ğ‘„ ğ‘› ğœ‹ ğ‘› . ğœ™ be a temporally safe Hyper- LTL formula. Let A ğœ™ = (ğ‘„ ğœ™ , ğ‘ 0,ğœ™ , ğ›¿ ğœ™ ) be a safety automaton over Î£ 2 AP ğœ‹ 1 âˆªâ€¢â€¢â€¢âˆªAP ğœ‹ğ‘› that accepts ğœ™ (when interpreted as an LTL formula over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘› ).</formula><p>We define in the following an equisatisfiable first-order formula Î˜, which can be computed from ğœ‘. For readability, we use two-sorted first-order logic, which is equisatisfiable to standard firstorder logic. We use two sorts: Trace, which contains trace variables, and TimePoint, which contains time variables. We use the constant ğ‘– 0 : To complement the upper bound, we show coRE-hardness by reducing the complement of the halting problem of deterministic Turing machines. The proof shows that already a single with nested suffices for coRE-hardness.</p><p>Lemma 3.10. The satisfiability problem is coRE-hard for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . ( * ).</p><p>Proof sketch. We encode the non-termination of deterministic Turning machines, which is coRE-hard. Each trace represents a configuration of the machine and the âˆ€âˆƒ formula demands that each configuration encoded in trace ğœ‹ has a successor configuration on some trace ğœ‹ â€² . As the transitions of a TM can be checked locally, we can encode a successor configuration by comparing every three consecutive positions on ğœ‹ and ğœ‹ â€² , which is possible with a single globally. We give a detailed proof in Appendix A. â–¡</p><p>This completes the proof of Theorem 3.7.</p></div>
<div><head n="3.3">Temporal Safety with Functional Specifications</head><p>We now investigate satisfiability for the combination of temporally safe HyperLTL formulas and LTL properties. If the LTL specification is safety, we can simply merge the trace property with the temporally safe hyperproperty, maintaining the applicability of Theorem 3.7. The situation changes if we allow non-safety trace properties.</p><p>Theorem 3.11. The satisfiability problem is Î£ 1 1 -complete for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . . Proof sketch. Membership in Î£ 1  1 follows from <ref type="bibr" target="#b23">[24]</ref>. For hardness, we encode recurring computations of nondeterministic two-counter machines. We represent each configuration by encoding the current instruction and two atomic propositions c 1 , c 2 that hold exactly once, i.e., counter ğ‘¥ has value ğ‘£ if c ğ‘¥ occurs in the ğ‘£th position. To ensure a recurring computation, we add a third counter ğ‘¡ that decreases in each step. When it reaches 0, the trace must encode the initial instruction, at which point ğ‘¡ is reset to any value. The key idea of the proof is that each trace in the model represents two consecutive configurations, which are encoded over disjoint copies of AP (for ğ‘– âˆˆ {1, 2}, AP ğ‘– = {ğ‘ ğ‘– | ğ‘ âˆˆ AP}). In LTL, we can express that the second configuration encoded in a trace is a successor of the first configuration in that trace. Furthermore, we express in LTL that the value of ğ‘¡ either decreases or the initial instruction is executed. In the HyperLTL property we ensure the existence of the initial configuration, and state that for each trace ğœ‹, there exist a ğœ‹ â€² such that the second configuration on ğœ‹ equals the first on ğœ‹ â€² . We can express the latter as</p><formula xml:id="formula_12">âˆ€ğœ‹âˆƒğœ‹ â€² . ğ‘ âˆˆAP ğ‘ 2 ğœ‹ â†” ğ‘ 1 ğœ‹ â€² .</formula><p>The resulting specification is satisfiable if and only if the machine has a recurring computation. We give a detailed proof in Appendix A. â–¡</p></div>
<div><head n="3.4">Propositional Hyperproperties and Invariants</head><p>As we have seen, with arbitrary LTL properties present, a single operator suffices to jump to Î£ 1 1 . This leaves hyperproperties expressed using only s as the only sub-analytical fragment. We settle the precise complexity of the resulting problem to be NEXPTIME-complete.</p><p>Theorem 3.12. The satisfiability problem is NEXPTIME-complete for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form ğ‘„ * . * . Hardness holds already for ğœ“ = âŠ¤, a âˆ€ * âˆƒ * prefix, and no s.</p><p>Proof sketch. To show containment, we nondeterministically guess a set of finite traces ğ‘€ âŠ† Î£ ğ‘˜ , where ğ‘˜ is the number of operators in the formula. We then verify that each trace in ğ‘€ can be extended to one satisfying ğœ“ and that ğ‘€ is a model of the hyperproperty. For the lower bound, we reduce the acceptance of an exponential-time bounded nondeterministic Turing machine to a HyperLTL formula. Our encoding is a âˆ€ * âˆƒ * -formula, which does not contain any temporal operators (not even ) and no trace property. Each trace in our model encodes a piece of information (ğ‘ , ğ‘, ğ›¾, ğ‘), where ğ‘ , ğ‘ âˆˆ N, ğ›¾ is a tape symbol of the TM, and ğ‘ either a state of the TM or âŠ¥. The tuple (ğ‘ , ğ‘, ğ‘¡, ğ‘) encodes that in time-step ğ‘  and at position ğ‘, the tape content is ğ›¾, and either the head is at position ğ‘ and the machine is in state ğ‘, or the head is not at position ğ‘ (if ğ‘ = âŠ¥). As the TM is time (and thus space) bounded, ğ‘  and ğ‘ are bound by 2 ğ‘› for some ğ‘›. We show that we can express in HyperLTL that the information encoded in a given model defines a valid accepting run of the TM. The resulting formula is satisfiable iff TM has an accepting computation. As we can never refer to all exponentially many positions explicitly, we use âˆ€ * âˆƒ * formulas to encode a counter that references all positions. We give a formal proof in the Appendix A.</p><p>â–¡ We note that HyperLTL without temporal operators has a strong connection to quantified boolean formulas (QBF), the validity of which is a standard PSPACE-complete problem <ref type="bibr" target="#b40">[40]</ref>. In contrast to QBF, where the quantifier structure spans the polynomial hierarchy, our proof shows that in Hyper-LTL, the âˆ€ * âˆƒ * fragment suffices to show NEXPTIME-hardness (refuting a conjecture in <ref type="bibr" target="#b32">[32]</ref> that temporal-operator-free HyperLTL is equivalent to QBF). The reason is that Hyper-LTL satisfiability asks for the existence of some model for which the formula holds (which is related to the more general second-order QBF problem <ref type="bibr" target="#b31">[31]</ref>).</p><p>If we forgo the additional trace property, we can also show the following lemma. Hardness already holds if we disallow propositional formulas outside of the . Lemma 3.13. The satisfiability problem is NEXPTIME-complete for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€ * âˆƒ * . . Proof. A property ğœ‘ = âˆ€ ğ‘› âˆƒ ğ‘š . ( ğœ™) âˆ§ ğœ™ â€² (where ğœ™, ğœ™ â€² do not contain any temporal operators) is satisfiable iff âˆ€ ğ‘› âˆƒ ğ‘š . ğœ™ âˆ§ğœ™ â€² is satisfiable. The result then follows using Theorem 3.12. â–¡</p></div>
<div><head n="4">Temporal Liveness</head><p>The natural counterparts of safety properties are liveness properties, which postulate that "something good happens eventually". Similar to the case of hypersafety, hyperliveness as a fragment is not well-suited when studying satisfiability: any hyperliveness property is, by definition, satisfiable. Analogously to our study of temporal safety, we instead study HyperLTL properties whose body is a liveness property. We examine the temporal liveness fragment following the structure of Section 3 and point out analogous results wherever possible. As in Section 3, we first examine the entire class of temporal liveness and then gradually restrict this class to obtain new decidability results.</p></div>
<div><head n="4.1">Hyperliveness and Temporal Liveness</head><p>As opposed to the safety case (cf. Proposition 3.6), temporal liveness and hyperliveness are incomparable. In temporal liveness, we can easily express falsity via âˆ€ğœ‹âˆ€ğœ‹ â€² . (ğ‘ ğœ‹ âˆ§ Â¬ğ‘ ğœ‹ â€² ), which is not hyperliveness. Conversely, the property âˆ€ğœ‹âˆƒğœ‹ â€² . (ğ‘ ğœ‹ â†® ğ‘ ğœ‹ â€² ) is hyperliveness (as we can always add more witness traces) but not expressible in temporal liveness.</p></div>
<div><head n="4.2">General Temporal Liveness</head><p>Analogous to Theorem 3.7, we consider the full fragment of temporal liveness. Different from the fragment of temporal safety, the class of temporal liveness is already Î£ 1 1 -hard. Theorem 4.2. The satisfiability problem is Î£ 1  1 -hard for âˆ€âˆƒ * temporal liveness HyperLTL formulas.</p><p>To prove Theorem 4.2, we show a stronger result: we can effectively reduce every âˆ€ * âˆƒ * HyperLTL property to an equisatisfiable temporal liveness property.</p><p>Theorem 4.3. Let (ğœ“, ğœ‘) be a specification where ğœ‘ is of the form âˆ€ ğ‘› âˆƒ ğ‘š . ğœ™, and ğœ“ and ğœ™ are arbitrary but satisfiable LTL formulas. Then there is an effectively computable specification (ğœ“ â€² , ğœ‘ â€² ) such that ğœ“ â€² is an LTL liveness property, ğœ‘ â€² is a âˆ€ ğ‘› âˆƒ ğ‘š temporal liveness property, and (ğœ“, ğœ‘) and (ğœ“ â€² , ğœ‘ â€² ) are equisatisfiable.</p><p>Proof. The idea is to move the start position of the formula under a operator. We introduce a fresh atomic proposition â€  and ensure that all traces satisfy the liveness property ( â€  âˆ§ Â¬ â€ ). The unique position where â€  âˆ§ Â¬ â€  holds (the last time that â€  is true) is then the "start position" to evaluate the formula. Let ğœ‘ = ğ‘„ * . ğœ™ where ğ‘„ * = âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› âˆƒğœ‹ ğ‘›+1 . . . ğœ‹ ğ‘›+ğ‘š is the quantifier prefix of ğœ‘. Define</p><formula xml:id="formula_13">ğœ‘ â€² ğ‘„ * . ğ‘›+ğ‘š ğ‘–=1 â€  ğœ‹ ğ‘– âˆ§ ğ‘›+ğ‘š ğ‘–=1 Â¬ â€  ğœ‹ ğ‘– âˆ§ ğœ™</formula><p>In similar fashion, we define ğœ“ â€² ( â€  âˆ§ ( Â¬ â€ ) âˆ§ğœ“ ). It is easy to see that both the LTL body of ğœ‘ â€² and ğœ“ â€² are liveness properties. Here it is crucial that we assumed that ğœ“ and ğœ™ are satisfiable.</p><p>We now claim that (ğœ“, ğœ‘) is satisfiable if and only if (ğœ“ â€² ğœ‘ â€² ) is satisfiable. For the first direction, assume that ğ‘‡ is a model for (ğœ“, ğœ‘). The model with â€  added to the first step of all traces satisfies (ğœ“ â€² , ğœ‘ â€² ). For the other direction, let ğ‘‡ be a model of (ğœ“ â€² , ğœ‘ â€² ). We assume w.l.o.g. that there is no subset ğ‘‡ â€² âŠŠ ğ‘‡ such that ğ‘‡ â€² is also a model for (ğœ“ â€² , ğœ‘ â€² ). The property enforces that for any traces ğ‘¡ 1 , . . . , ğ‘¡ ğ‘›+ğ‘š , where ğ‘¡ ğ‘›+1 , . . . , ğ‘¡ ğ‘›+ğ‘š are the witness traces for ğ‘¡ 1 , . . . , ğ‘¡ ğ‘š , â€  holds for the last time at a common time point. As ğ‘‡ â€² is minimal, every trace serves as a witness for some other traces. Therefore the last position where â€  holds is the same for all traces in ğ‘‡ â€² . Let ğ‘– be this position. Then {ğ‘¡ [ğ‘–, âˆ] | ğ‘¡ âˆˆ ğ‘‡ â€² } is a model of (ğœ“, ğœ‘). â–¡ By Theorem 3.11, satisfiability of âˆ€âˆƒ * HyperLTL is Î£ 1 1hard (note that we transform any specification (ğœ“, âˆ€ ğ‘› âˆƒ ğ‘š . ğœ™) with ğ‘› â‰¥ 1 into a specification (âŠ¤, âˆ€ ğ‘› âˆƒ ğ‘š . ğœ™ â€² ) by integrating the trace property into the body of the HyperLTL formula). Theorem 4.3 thus gives a proof of Theorem 4.2. More generally, every HyperLTL formula can be effectively reduced to an equisatisfiable âˆ€<ref type="foot" target="#foot_1">2</ref> âˆƒ * HyperLTL formula <ref type="bibr" target="#b32">[32,</ref><ref type="bibr">Thm. 5]</ref>, so Theorem 4.3 shows that deciding temporal liveness can be used to decide full HyperLTL.</p></div>
<div><head n="4.3">Simple Liveness Properties</head><p>The general class of temporal liveness thus does not define an "easier" fragment of HyperLTL. As in the case of safety properties, we study the precise boundary at which the jump to Î£ 1 1 occurs by restricting to simpler forms of temporal liveness. Analogously to the case of invariants (described with ), we study eventualities ( ). Proof sketch. We collapse all universal quantifiers in ğœ‘ and thereby reduce satisfiability of (âŠ¤, ğœ‘) to boolean satisfiability. We give a detailed proof in Appendix B. â–¡ Note that if we allow properties where propositional formulas occur outside of the operators, the complexity jumps back to NEXPTIME (see Lemma B.1). It is worth to contrast this result with the analogous findings for simple temporally safe formulas. <ref type="bibr">Lemma 4.4</ref> shows that when adding an operator around a propositional formula, the problem drops from NEXPTIME (Theorem 3.12) to NP. This is in contrast to adding operators, which remains NEXPTIME-complete (Lemma 3.13). Invariants with nested and propositional conjuncts are undecidable (Lemma 3.10), whereas eventualities with nested operators and propositional conjuncts remain decidable (see Lemma B.1).</p></div>
<div><head n="4.4">Eventualities with Functional Specifications</head><p>Surprisingly, the sharp contrast between and continues if we add functional specifications as LTL trace properties. For , the resulting problem directly jumps to full analytical hardness (cf. Theorem 3.11). For , we now show that the problem remains decidable. Our result reads as follows.</p><p>Theorem 4.5. The satisfiability problem is decidable for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . ( * ).</p><p>This result is interesting for two reasons. First, it outlines the precise difference between and . Second, it defines a new decidable class that contains many properties of interest. In particular, formulas of the fragment can enforce infinite models. 2 For example, the specification in Example 1.1 falls in this newly identified fragment.</p><p>The remainder of this subsection provides a proof for Theorem 4.5. We introduce necessary concepts along the way.</p></div>
<div><head n="4.4.1">Eliminating</head><p>Nexts. We first show how to eliminate the operators in ğœ‘.</p><p>Lemma 4.6. Let (ğœ“, ğœ‘) be a specification where ğœ‘ is of the form âˆ€ ğ‘› âˆƒ ğ‘š . ( * ). There exists an effectively computable specification (ğœ“ â€² , ğœ‘ â€² ) where ğœ‘ â€² is the of the form âˆ€ ğ‘› âˆƒ ğ‘š . such that (ğœ“, ğœ‘) and (ğœ“ â€² , ğœ‘ â€² ) are equisatisfiable.</p><p>Proof sketch. Let ğœ‘ = âˆ€ ğ‘› âˆƒ ğ‘š . ( ğœ™) âˆ§ ğœ™ â€² . We eliminate operators in ğœ™ by letting traces range over tuples. Instead of considering traces in Î£ ğœ” , we consider traces in (Î£ ğ‘˜ ) ğœ” , where ğ‘˜ is the lookahead needed to evaluate ğœ™ (which is upper bounded by the number of s in ğœ™). For each trace ğ‘¡ âˆˆ Î£ ğœ” , we define ğ‘¡ â€² âˆˆ (Î£ ğ‘˜ ) ğœ” by ğ‘¡ â€² (ğ‘–) (ğ‘¡ (ğ‘–), ğ‘¡ (ğ‘– + 1), . . . , ğ‘¡ (ğ‘– + ğ‘˜)). This reduces the evaluation of ğœ™ to a formula without s. We also modify the LTL formula (which is allowed to contain operators) to assert that the tuples in each tuple trace are consistent, i.e., for each step ğ‘– if ğ‘¡ (ğ‘–) = (ğ‘™ 1 , . . . , ğ‘™ ğ‘˜ ) then ğ‘¡ (ğ‘– + 1) = (ğ‘™ 2 , . . . , ğ‘™ ğ‘˜ , ğ‘™ ğ‘˜+1 ). A detailed proof can be found in Appendix B. â–¡ Using Lemma 4.6, we can assume that in Theorem 4.5, the HyperLTL formula ğœ‘ contains a single as the only temporal operator. For now, we make two further assumptions: First, we assume that ğœ‘ contains only a single âˆƒ quantifier, and, second, we assume that there are no additional propositional conjuncts outside the . So let ğœ‘ = âˆ€ğœ‹âˆƒğœ‹ â€² . ğœ™ where ğœ™ contains no temporal operators. We begin by translating the trace property ğœ“ into a BÃ¼chi automaton. Definition 4.7. A state-labeled BÃ¼chi automaton over alphabet Î£ is a tuple A = (ğ‘„, ğ‘„ 0 , ğ›¿, ğ¹, ğ¿), where ğ‘„ is a finite set of states, ğ‘„ 0 âŠ† ğ‘„ the initial states, ğ›¿ âŠ† ğ‘„ Ã— ğ‘„ the transition relation, ğ¹ âŠ† ğ‘„ the set of accepting states, and ğ¿ : ğ‘„ â†’ Î£ a state labeling function. An accepting run ğ‘Ÿ of A is an infinite sequence ğ‘Ÿ âˆˆ ğ‘„ ğœ” such that 1) ğ‘Ÿ (0) âˆˆ ğ‘„ 0 , 2) (ğ‘Ÿ (ğ‘–), ğ‘Ÿ (ğ‘– + 1)) âˆˆ ğ›¿ for every ğ‘–, and 3) ğ‘Ÿ (ğ‘–) âˆˆ ğ¹ for infinitely many ğ‘–. The trace ğ¿(ğ‘Ÿ ) âˆˆ Î£ ğœ” associated to a run is defined by ğ¿(ğ‘Ÿ ) (ğ‘–) ğ¿(ğ‘Ÿ (ğ‘–)). For a set ğ‘‹ âŠ† ğ‘„, we define Step A (ğ‘‹ ) {ğ‘ âˆˆ ğ‘„ | âˆƒğ‘ â€² âˆˆ ğ‘‹ . (ğ‘ â€² , ğ‘) âˆˆ ğ›¿ } as all states reachable in one step from ğ‘‹ and Reach A (ğ‘›) as all states reachable in ğ‘› steps from a state in ğ‘„ 0 .</p><p>Note that we use state-labeled automata (as opposed to transition-labeled automata) to simplify our construction. Let A ğœ“ = (ğ‘„ ğœ“ , ğ‘„ 0,ğœ“ , ğ›¿ ğœ“ , ğ¹ ğœ“ , ğ¿ ğœ“ ) be a (state-labeled) BÃ¼chi automaton over 2 AP accepting ğœ“ <ref type="bibr" target="#b41">[41]</ref>. A state ğ‘ âˆˆ ğ‘„ ğœ“ is nonempty if there exists an accepting infinite run starting in ğ‘. W.l.o.g., we assume that A ğœ“ only includes non-empty states, as we can remove all empty states without changing the language of A ğœ“ . Detecting if a state is non-empty can be done easily using, e.g., nested depth-first search.</p><p>4.4.2 Models for âˆ€âˆƒ. Intuitively, our decidability result can be derived as follows. Assume we had a model ğ‘‡ of (ğœ“, ğœ‘). Let ğ‘… âŠ† ğ‘„ ğœ” ğœ“ be a set of accepting runs of A ğœ“ associated to ğ‘‡ , i.e., ğ‘‡ = {ğ¿ ğœ“ (ğ‘Ÿ ) | ğ‘Ÿ âˆˆ ğ‘…}. As we consider a âˆ€âˆƒ formula, we As an intermediate step, we describe an infinite-state BÃ¼chi system (a BÃ¼chi automaton without labels) that guesses such a "linear" model of (ğœ“, ğœ‘). The states of the system are triples (ğ‘, ğ‘, ğ‘›), where ğ‘ âˆˆ ğ‘„ ğœ“ is a state in A ğœ“ , ğ‘ âˆˆ {â‡›, â‡š} gives a running direction, and ğ‘› âˆˆ N. Each state (ğ‘, ğ‘, ğ‘›) additionally satisfies ğ‘ âˆˆ Reach A ğœ“ (ğ‘›). The initial states of the system are all states (ğ‘ 0 , â‡›, 0) with ğ‘ 0 âˆˆ ğ‘„ 0,ğœ“ . In each step, the system has three options: it can either run forwards, run backwards, or claim to have found a witness. In a forward step (F-step), the automaton moves from (ğ‘, â‡›, ğ‘›) to (ğ‘ â€² , â‡›, ğ‘› + 1), where (ğ‘, ğ‘ â€² ) âˆˆ ğ›¿ ğœ“ . Similarly, in a backwards step (B-step), it runs from (ğ‘, â‡š, ğ‘› + 1) to (ğ‘ â€² , â‡š, ğ‘›), where (ğ‘ â€² , ğ‘) âˆˆ ğ›¿ ğœ“ . Note that in the backwards step, we always ensure that ğ‘ â€² âˆˆ Reach A ğœ“ (ğ‘›). Lastly, the system can claim to have found a witness (W-step): if in state (ğ‘, ğ‘, ğ‘›), it can select any ğ‘ â€² âˆˆ Reach A ğœ“ (ğ‘›) such that ğ¿ ğœ“ (ğ‘) Ã— ğ¿ ğœ“ (ğ‘ â€² ) |= ğœ™. Afterwards, the system continues in state (ğ‘ â€² , ğ‘ â€² , ğ‘›), where ğ‘ â€² âˆˆ {â‡›, â‡š} is chosen nondeterministically. Call the resulting system S. We claim the following. Lemma 4.8. S has an infinite run that uses W-steps infinitely often if and only if (ğœ“, ğœ‘) is satisfiable.</p><formula xml:id="formula_14">ğ‘Ÿ 0 ğ‘Ÿ 1 ğ‘Ÿ 2 ğ‘Ÿ 3 ğ‘Ÿ 4 â€¢ â€¢ â€¢ F W F F W B W B B W Figure 1.</formula><p>Proof. We sketch both directions. For the "if" direction, assume there is a model for (ğœ“, ğœ‘). We can arrange a subset of this model as depicted in Figure <ref type="figure">1</ref>. Let ğ‘Ÿ 0 , ğ‘Ÿ 1 , . . . , with ğ‘Ÿ ğ‘– âˆˆ ğ‘„ ğœ” ğœ“ be the sequence of accepting runs in A ğœ“ and ğ‘› ğ‘– the witness points. Traversing the graph as shown by the small blue states in Figure <ref type="figure">1</ref> creates a run of S. We start in (ğ‘Ÿ 0 (0), â‡›, 0) and move forward (using F-steps) until the counter reaches ğ‘› 0 . At this point, we take the W-step from (ğ‘Ÿ 0 (ğ‘› 0 ), â‡›, ğ‘› 0 ) to (ğ‘Ÿ 1 (ğ‘› 0 ), ğ‘, ğ‘› 0 ) and run towards counter value ğ‘› 1 . If ğ‘› 1 &lt; ğ‘› 0 , we set the running direction ğ‘ to â‡š and otherwise to â‡›. We continue this procedure to construct an infinite run. For the example situation depicted in Figure <ref type="figure">1</ref>, the resulting run would start with:</p><formula xml:id="formula_15">(ğ‘Ÿ 0 (0), â‡›, 0) F - â†’ (ğ‘Ÿ 0 (1), â‡›, 1) W --â†’ (ğ‘Ÿ 1 (1), â‡›, 1) F - â†’ (ğ‘Ÿ 1 (2), â‡›, 2) F - â†’ (ğ‘Ÿ 1 (3), â‡›, 3) W --â†’ (ğ‘Ÿ 2 (3), â‡š, 3) B -â†’ (ğ‘Ÿ 2 (2), â‡š, 2) W --â†’ â€¢ â€¢ â€¢</formula><p>The resulting sequence is a run of S and uses W-steps infinitely many times.</p><p>For the "only if" direction, assume an infinite run ğ‘Ÿ = (ğ‘ 0 , ğ‘ 0 , ğ‘š 0 ) â†’ (ğ‘ 1 , ğ‘ 1 , ğ‘š 1 ) â†’ â€¢ â€¢ â€¢ of S. We split ğ‘Ÿ into infinitely many finite segments ğ‘¥ 0 , ğ‘¥ 1 , . . . , by splitting each time ğ‘Ÿ takes a W-step. In the example run above we would get ğ‘¥ 0 = (ğ‘Ÿ 0 (0), 0) (ğ‘Ÿ 0 (1), 1), BÃ¼chi pushdown system has an accepting run <ref type="bibr" target="#b9">[10]</ref>.</p><formula xml:id="formula_16">ğ‘¥ 1 = (ğ‘Ÿ 1 (1), 1) (ğ‘Ÿ 1 (2), 2) (ğ‘Ÿ 1 (3), 3), . . ..</formula><p>We replace S with a pushdown system P. Conceptually, we represent a state (ğ‘, ğ‘, ğ‘›) in S by the pushdown configuration with state (ğ‘, ğ‘) and stack content [Reach A ğœ“ (ğ‘›), . . . , Reach A ğœ“ (0)], i.e., the length of the stack is ğ‘› + 1 and the ğ‘–th element are all states reachable in ğ‘– steps. The states in the pushdown system thus have the form (ğ‘, ğ‘) with ğ‘ âˆˆ ğ‘„ ğœ“ , ğ‘ âˆˆ {â‡›, â‡š} and the stack alphabet is 2 ğ‘„ ğœ“ . The initial stack symbol is ğ›¾ 0 ğ‘„ 0,ğœ“ and the initial states are {(ğ‘ 0 , â‡›) | ğ‘ 0 âˆˆ ğ‘„ 0,ğœ“ }. The transitions are of the following form:</p><formula xml:id="formula_17">(ğ‘, ğ‘ â€² ) âˆˆ ğ›¿ ğœ“ (F) (ğ‘, â‡›), [ğ´] â‡ (ğ‘ â€² , â‡›), [Step A ğœ“ (ğ´), ğ´] ğ‘ â€² âˆˆ ğ´ 2 (ğ‘ â€² , ğ‘) âˆˆ ğ›¿ ğœ“ (B) (ğ‘, â‡š), [ğ´ 1 , ğ´ 2 ] â‡ (ğ‘ â€² , â‡š), [ğ´ 2 ] ğ‘ â€² âˆˆ ğ´ ğ¿ ğœ“ (ğ‘) Ã— ğ¿ ğœ“ (ğ‘ â€² ) |= ğœ™ ğ‘, ğ‘ â€² âˆˆ {â‡›, â‡š} (W) (ğ‘, ğ‘), [ğ´] â‡ (ğ‘ â€² , ğ‘ â€² ), [ğ´]</formula><p>Note the close correspondence with the transitions in S. In particular, in F-steps, we compute Reach A ğœ“ (ğ‘› + Lastly, we can easily translate a BÃ¼chi pushdown system with transition-based acceptance (as in P) to state-based acceptance (as in Definition 4.9). Using the decidability of pushdown systems <ref type="bibr" target="#b9">[10]</ref>, we thus get that the satisfiability of (ğœ“, ğœ‘) is decidable. Note that our proof gives an elementary upper bound of 2EXPTIME (for âˆ€âˆƒ properties). <ref type="foot" target="#foot_2">3</ref>4.4.4 Propositional Conjuncts and âˆ€âˆƒ * . We can now lift the two assumptions we made earlier. As a first extension, we modify our construction to also support formulas of the form âˆ€ğœ‹âˆƒğœ‹ â€² .( ğœ™) âˆ§ ğœ™ â€² . To do so, we keep track of the first state of the run we are currently considering. In a W-step, we then only select a witness state ğ‘ â€² that stems from an initial state which satisfies the propositional requirement ğœ™ â€² when combined with the initial state of the current run. We can access the set of all such states by keeping track of the set of states reachable from every individual state (by changing the stack alphabet to functions ğ‘„ ğœ“ â†’ 2 ğ‘„ ğœ“ ).</p><p>As a second extension, we can show decidability for a âˆ€âˆƒ ğ‘š prefix by moving to alternating BÃ¼chi pushdown systems (defined as expected, see <ref type="bibr" target="#b9">[10]</ref> for details). For âˆ€âˆƒ ğ‘š , we can no longer arrange the traces of a model in a linear sequence (as depicted in Figure <ref type="figure">1</ref>) and instead use ğ‘š-ary trees labeled by traces such that the children of a node correspond to witness traces of that trace. In a W-step from a state (ğ‘, ğ‘), we now select ğ‘š states ğ‘ 1 , . . . , ğ‘ ğ‘š (whereas we previously picked only ğ‘ â€² ) such that ğ‘ together with ğ‘ 1 , . . . , ğ‘ ğ‘š satisfy ğœ™. Afterwards, we need to find a new witnesses for each of the ğ‘ ğ‘– . We accomplish this by introducing a universal transition that branches into states (ğ‘ ğ‘– , ğ‘ ğ‘– ) for each 1 â‰¤ ğ‘– â‰¤ ğ‘š (leaving the stack unchanged as before). The F and B step stay purely nondeterministic. The resulting alternating pushdown system has an accepting run (which now has the form of a tree) iff (ğœ“, ğœ‘) is satisfiable. As emptiness of alternating pushdown systems is still decidable (albeit only in exponential time) <ref type="bibr" target="#b9">[10]</ref>, we get a proof of Theorem 4.5 for the full âˆ€âˆƒ * -fragment. For the âˆ€âˆƒ * -fragment, our proof gives an elementary upper bound of 3EXPTIME.</p></div>
<div><head n="4.5">Conjunctions of Eventualities</head><p>We show that Theorem 4.5 is tight in the sense that already a conjunction of eventualities combined with an arbitrary trace property is undecidable (and even Î£ 1 1 -hard). Theorem 4.11. The satisfiability problem is Î£ 1  1 -hard for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . âˆ§ âˆ§ .</p><p>Proof. We encode the problem of whether a nondeterministic 2CM with instructions ğ‘™ 1 , . . . , ğ‘™ ğ‘› has a recurring computation <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b22">23]</ref>.</p><formula xml:id="formula_18">Let AP = ğ‘¥ âˆˆ {1,2,ğ‘¡ } { ğ‘¥ , â–  ğ‘¥ , isZero ğ‘¥ } âˆª {l 1 , . . . , l ğ‘› }.</formula><p>Each trace encodes a configuration of the machine as follows. The current value of counter ğ‘¥ âˆˆ {1, 2} is encoded as a trace in âˆ… * { ğ‘¥ }{â–  ğ‘¥ }âˆ… ğœ” such that the (unique) step at which ğ‘¥ holds indicates the current value of ğ‘ ğ‘¥ . We later use proposition â–  ğ‘¥ (which always holds the step after ğ‘¥ ) to encode the update of the counter. The proposition isZero ğ‘¥ holds exactly if the counter is zero. The current instruction is encoded by propositions {l 1 , . . . , l ğ‘› }, of which exactly one holds globally along a trace. Finally, to ensure a recurring computation, we use a third counter ğ‘¡, which is encoded analogously to the counters above and counts down the steps to the next visit to ğ‘™ 1 . It is easy to see that we can encode the validity of a configuration in an LTL formula ğœ“ . For ğ‘¥ âˆˆ {1, 2, ğ‘¡ } we ensure a valid counter via</p><formula xml:id="formula_19">(Â¬ ğ‘¥ âˆ§Â¬â–  ğ‘¥ ) U ( ğ‘¥ âˆ§ Â¬â–  ğ‘¥ ) âˆ§ (â–  ğ‘¥ âˆ§ Â¬ ğ‘¥ ) âˆ§ (Â¬ ğ‘¥ âˆ§Â¬â–  ğ‘¥ )</formula><p>and ensure correct placement of isZero ğ‘¥ by ( isZero ğ‘¥ ) âˆ¨ ( Â¬isZero ğ‘¥ ) together with isZero ğ‘¥ â†” ğ‘¥ . Finally, we assert that the propositions {l 1 , . . . , l ğ‘› } are set correctly via ğ‘– l ğ‘– âˆ§ ğ‘—â‰ ğ‘– Â¬l ğ‘— . In the hyperproperty, we encode that there exists a trace representing the initial configuration as follows (note that we allow counter ğ‘¡ to have any value):</p><formula xml:id="formula_20">ğœ‘ init âˆƒğœ‹ .(l 1 ) ğœ‹ âˆ§ (isZero 1 ) ğœ‹ âˆ§ (isZero 2 ) ğœ‹</formula><p>Lastly, we express that each trace has a successor. For each instruction ğ‘™ ğ‘– , we write ğ‘ (ğ‘™ ğ‘– ) âˆˆ {1, 2} for the counter that is changed or tested in instruction ğ‘™ ğ‘– . We define 1 2 and 2 1 for the other counter. We then define</p><formula xml:id="formula_21">ğœ‘ âˆ€ğœ‹âˆƒğœ‹ â€² . ğ‘– âˆˆ {1,...,ğ‘› } (l ğ‘– ) ğœ‹ âˆ§ exec(ğ‘™ ğ‘– ) âˆ§ ğ‘– âˆˆ {1,...,ğ‘› } (l ğ‘– ) ğœ‹ âˆ§ ( ğ‘ (ğ‘™ ğ‘– ) ) ğœ‹ âˆ§ ( ğ‘ (ğ‘™ ğ‘– ) ) ğœ‹ â€² âˆ§ (isZero ğ‘¡ ) ğœ‹ âˆ§ (l 1 ) ğœ‹ âˆ¨ ( ğ‘¡ ) ğœ‹ âˆ§ (â–  ğ‘¡ ) ğœ‹ â€² .</formula><p>Here, exec(ğ‘™ ğ‘– ) denotes that the action or test of instruction ğ‘™ ğ‘– is performed on ğ‘ (ğ‘™ ğ‘– ). For example, if ğ‘™ ğ‘– = ğ‘ ğ‘¥ ğ‘ ğ‘¥ + 1; goto{ğ‘™ ğ‘— , ğ‘™ ğ‘˜ } , we define exec(ğ‘™ ğ‘– ) as</p><formula xml:id="formula_22">(l ğ‘— ) ğœ‹ â€² âˆ¨ (l ğ‘˜ ) ğœ‹ â€² âˆ§ (â–  ğ‘¥ ) ğœ‹ âˆ§ ( ğ‘¥ ) ğœ‹ â€² .</formula><p>Note that (â–  ğ‘¥ ) ğœ‹ âˆ§ ( ğ‘¥ ) ğœ‹ â€² encodes that the counter ğ‘¥ is increased. For a decrement operation, we can replace this with (â–  ğ‘¥ ) ğœ‹ â€² âˆ§ ( ğ‘¥ ) ğœ‹ . If ğ‘™ ğ‘– = if ğ‘ ğ‘¥ = 0 then goto ğ‘™ ğ‘— else goto ğ‘™ ğ‘˜ , we define exec(ğ‘™ ğ‘– ) as</p><formula xml:id="formula_23">( ğ‘¥ ) ğœ‹ âˆ§ ( ğ‘¥ ) ğœ‹ â€² âˆ§ (isZero ğ‘¥ ) ğœ‹ â†’ (l ğ‘— ) ğœ‹ â€² âˆ§ Â¬(isZero ğ‘¥ ) ğœ‹ â†’ (l ğ‘˜ ) ğœ‹ â€² .</formula><p>In ğœ‘, the first conjunct thus encodes that the counter ğ‘ (ğ‘™ ğ‘– ) is updated and/or tested as required by ğ‘™ ğ‘– . The second conjunct states that the counter that is not involved in ğ‘™ ğ‘– is left unchanged. As the current instruction is set consistently along a trace, both eventualities refer to the same instruction. Finally, the third conjunct ensures that the counter ğ‘¡ either decreases or is already zero, at which point the current instruction is ğ‘™ 1 . In case the ğ‘¡-counter is zero, it can be reset to any value on ğœ‹ â€² . This ensures a recurring computation of the machine. It is easy to see that (ğœ“, ğœ‘ init âˆ§ ğœ‘) is satisfiable iff the 2CM has a recurring computation (note that ğœ‘ init âˆ§ ğœ‘ is a âˆ€âˆƒ 2 -formula). â–¡ While Theorem 4.11 requires three conjunctions of eventualities to show Î£ 1 1 -hardness, already two eventualities suffice to show undecidability. To do so, we can encode the nontermination of a 2CM (avoiding the ğ‘¡ counter). This further underlines the tightness of Theorem 4.5.</p><p>Lemma 4.12. The satisfiability problem is undecidable for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . âˆ§ . Example 4.13. Using similar ideas as in Theorem 4.11, we can encode that a one-counter machine has an infinite computation with only a single eventuality (as we only need to ensure that the single counter is updated consistently). Combined with Theorem 4.5, we derive that we can decide the existence of an infinite computation in a one-counter machine. While this is long known (see, e.g., <ref type="bibr" target="#b28">[28]</ref>), it nevertheless emphasizes that our newly identified decidable class is broader than it seems at first glance. â—</p></div>
<div><head n="4.6">Deterministic Liveness</head><p>Livness for trace properties (cf. Definition 2.1) and hyperliveness (cf. Definition 2.3) already imply that a property is satisfiable. As demonstrated by Theorem 4.2, the same does not hold for temporal liveness hyperproperties. We can, however, identify a fragment within temporal liveness for which the intuition that liveness implies satisfiability transfers to the realm of hyperproperties. We say an LTL property ğœ™ is a deterministic liveness property if it is a liveness property and can be recognized by a deterministic BÃ¼chi automaton.</p><p>Proposition 4.14. HyperLTL formulas of the form ğœ‘ = âˆ€âˆƒ * . ğœ™ where ğœ™ is a deterministic liveness property are always satisfiable and have a finite model.</p><p>Proof sketch. In a deterministic automaton describing a liveness property, any reachable state has a path to an accepting state. We use this to iteratively construct a model. The full proof can be found in Appendix B. â–¡ Note that the same does not hold if we consider more than one universal quantifier. As an example, the formula âˆ€ğœ‹âˆ€ğœ‹ â€² . (ğ‘ ğœ‹ âˆ§ Â¬ğ‘ ğœ‹ â€² ) is unsatisfiable but (ğ‘ ğœ‹ âˆ§ Â¬ğ‘ ğœ‹ â€² ) is a deterministic liveness property. If we consider deterministic liveness in combination with trace properties, we again obtain a jump to Î£ 1 1 -hardness. Corollary 4.15. Satisfiability is Î£ 1  1 -hard for specifications of the form (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . ğœ™ and ğœ™ is a deterministic liveness property.</p><p>Proof. Follows directly from Theorem 4.11 as conjunctions of eventualities are deterministic liveness. â–¡</p></div>
<div><head n="4.7">Overview: Liveness vs Safety</head><p>Our results provide a clear picture of the (un)decidability boundaries within fragments of HyperLTL. In particular, our systematic study allows a direct comparison between temporal safety and temporal liveness. For the full fragment, temporal liveness already subsumes satisfiability of full HyperLTL, which contrasts strongly with the much cheaper (albeit still undecidable) problem for temporal safety. This changes if we consider simpler fragments. Here, the fragment is drastically better behaved in terms of complexity and even admits large decidable fragments for cases where the safety counterpart already exhibits full analytical hardness.</p></div>
<div><head n="5">Finding Largest Models</head><p>To complement the decidability results from the previous sections, we propose a new (incomplete) algorithm to detect (un)satisfiability of âˆ€âˆƒ * HyperLTL formulas. So far, the only available algorithm checks for finite models of bounded size and then iteratively increases the bound <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b32">32]</ref>. Such an approach finds smallest models and cannot determine unsatisfiability. The key insight for our algorithm is that âˆ€âˆƒ * formulas are closed under union, therefore, a formula ğœ‘ is satisfiable iff there is a (unique) largest model satisfying ğœ‘. To find such models algorithmically, we iteratively eliminate choices for the âˆƒ * quantifiers that admit no witness trace when chosen for the âˆ€ quantifier. Thereby, we do not only find largest models but can also detect unsatisfiability. Our incremental elimination is closely related to a recent algorithm used in the context of finite-trace properties (which was developed independently) <ref type="bibr" target="#b8">[9]</ref>.</p><p>For presentation reasons, we present the algorithm for âˆ€âˆƒ formulas. Our implementation (see Section 6) supports full âˆ€âˆƒ * properties.</p><p>Algorithm 1 Algorithm that searches for the largest model of a âˆ€âˆƒ property. Initially, A is a BÃ¼chi automaton that accepts the body the HyperLTL property.</p><formula xml:id="formula_24">1: procedure findModel(A) 2: if L (A âˆ€ ) = âˆ… then 3: return UNSAT; 4: if L (A âˆƒ ) âŠ† L (A âˆ€ ) then 5:</formula><p>return SAT, model: L (A âˆ€ ); 6:</p><formula xml:id="formula_25">A new A âˆ© A âˆ€ ğœ‹ â€² ; 7:</formula><p>findModel(A new );</p></div>
<div><head n="5.1">Algorithm</head><p>For a BÃ¼chi automaton A over AP ğœ‹ âˆª AP ğœ‹ â€² , we define A âˆ€ and A âˆƒ as the automata (over AP) that (existentially) project A on the alphabet AP ğœ‹ and AP ğœ‹ â€² , respectively. Now let a HyperLTL formula ğœ‘ = âˆ€ğœ‹âˆƒğœ‹ â€² . ğœ™ be given and let A ğœ™ be an automaton over AP ğœ‹ âˆª AP ğœ‹ â€² accepting ğœ™. In particular, A âˆ€ ğœ™ accepts all words for which there exists a witness trace for the existential quantifier. Our algorithm is depicted in Algorithm 1. Initially, we call findModel(A ğœ™ ).</p><p>The first candidate is</p><formula xml:id="formula_26">A = A ğœ™ . If L (A âˆ€ ) = âˆ…, i.e.</formula><p>, no trace has a witness trace in A, ğœ‘ is unsatisfiable. If all potential witness traces in L (A âˆƒ ) are contained in L (A âˆ€ ) (so they have a witness trace themself), ğœ‘ is satisfiable and L (A âˆ€ ) is a model. If neither is the case, we refine A by removing all traces whose âˆƒ component is not in L (A âˆ€ ). We define A new as the intersection A âˆ© A âˆ€ ğœ‹ â€² where A âˆ€ ğœ‹ â€² is A âˆ€ with the alphabet changed from AP to AP ğœ‹ â€² . We can compute A new via a standard intersection construction on BÃ¼chi automata. Note that A new might again contain witness traces that themselves have no witness trace, so we recurse.</p></div>
<div><head n="5.2">Correctness</head><p>The algorithm maintains the following invariants. Lemma 5.1. In every iteration of the algorithm it holds that L (A new ) âŠ† L (A), and for any trace setğ‘‡ withğ‘‡ |= âˆ€ğœ‹âˆƒğœ‹ â€² . ğœ™, ğ‘‡ âŠ† L (A âˆ€ ).</p><p>Using Lemma 5.1 it is easy to see the following. Proposition 5.2. Given a formula ğœ‘ = âˆ€ğœ‹âˆƒğœ‹ â€² . ğœ™, if Algorithm 1 terminates with UNSAT, the formula is unsatisfiable. If it terminates with SAT and model L (A âˆ€ ), then L (A âˆ€ ) is the unique largest model of ğœ‘.</p><p>To generalize to âˆ€âˆƒ * , we intersect the universal projection with each of the projections on existentially quantified positions. Models for âˆ€ * âˆƒ * -properties are, in general, not closed under union, so our algorithm does not extend beyond âˆ€âˆƒ * .</p></div>
<div><head n="6">Implementation and Experiments</head><p>We have implemented the algorithm described in Section 5 in a tool called <software ContextAttributes="used">LMHyper</software> (short for Largest Model of Hy-perLTL). <software ContextAttributes="used">LMHyper</software> reads both a âˆ€âˆƒ * HyperLTL formula ğœ‘ and Table <ref type="table">2</ref>. Comparison of <software ContextAttributes="used">LMHyper</software> and <software ContextAttributes="used">MGHyper</software> on 100 random formulas generated with <software ContextAttributes="used">randltl</software> <ref type="bibr" target="#b16">[17]</ref>. Size refers to the size of the AST, ğ‘ is the percentage of solved formulas, ğ‘¡ the average time spent on solved cases in milliseconds, and #Iter is the average number of iterations (number of recursive calls) used by <software ContextAttributes="used">LMHyper</software>. The timeout is set to 5sec. LTL formula ğœ“ and searches for an (un)satisfiability proof for (ğœ“, ğœ‘). Internally, we represent the current candidate as a generalized BÃ¼chi automaton and use spot <ref type="bibr" target="#b16">[17]</ref> to perform automata operations. The only other available tool for âˆ€âˆƒ * HyperLTL satisfiability is <software ContextAttributes="used">MGHyper</software> <ref type="bibr" target="#b19">[20]</ref>, which implements the incremental approach to find models of bounded size.</p></div>
<div><head>MGHyper</head></div>
<div><head n="6.1">Random Benchmarks</head><p>We compare <software ContextAttributes="used">LMHyper</software> against <software ContextAttributes="used">MGHyper</software> on random formulas where we sample the LTL body of a formula using <software ContextAttributes="used">randltl</software> <ref type="bibr" target="#b16">[17]</ref>. The results are given in Table <ref type="table">2</ref>. On our benchmarks, <software ContextAttributes="used">LMHyper</software> usually takes longer than <software ContextAttributes="used">MGHyper</software> but can handle a larger percentage of formulas. We observe that randomly generated HyperLTL formulas are, in most cases, satisfiable by a model with a single trace, as the atomic propositions are seldom shared between different trace variables. This explains the high success rate of <software ContextAttributes="used">MGHyper</software> (see <ref type="bibr" target="#b19">[20]</ref>) even though <software ContextAttributes="used">MGHyper</software> cannot prove unsatisfiability.</p></div>
<div><head n="6.2">Infinite and Large Models</head><p>We compiled a small number of more interesting properties that do not have single-trace models. Our results are depicted in Table <ref type="table" target="#tab_8">3</ref> </p></div>
<div><head n="7">Conclusion</head><p>We have studied the satisfiability problem for âˆ€ * âˆƒ * Hyper-LTL formulas in combination with LTL formulas describing functional behavior. To obtain results below the general Î£ 1  1 complexity of HyperLTL, we have focused on simpler hyperproperties belonging to the classes of temporal safety and temporal liveness as well as fragments thereof. We have shown that temporal safety is an expressive class that is very well suited for satisfiability studies and enjoys coRE-completeness. In combination with general LTL properties, already very simple formulas like invariants cause Î£ 1  1 -completeness. The temporal liveness class, on the other hand, is Î£ 1 1 -complete in general but contains non-trivial fragments that are decidable, even in combination with arbitrary LTL formulas.</p><p>We have shown that functional specifications given in LTL play a significant role in the undecidability of general hyperproperties. The main open question for future work is whether further decidable fragments can be found by restricting the operator structure of the functional specification. change in the position of the old head.</p><formula xml:id="formula_27">ğœ“ LxorR (Â¬â„ ğœ‹ âˆ§ (Â¬â„ ğœ‹ âˆ§ Â¬â„ ğœ‹ )) â†’ ğ‘ âˆˆAP ğ‘ ğœ‹ â†” ğ‘ ğœ‹ â€² âˆ§ â„ ğœ‹ â†’ Â¬â„ ğœ‹ â€² âˆ§ (â„ ğœ‹ â€² âŠ• â„ ğœ‹ â€² ) âˆ§ ğ‘ âˆˆÎ“ (ğ‘ ğœ‹ â†” ğ‘ ğœ‹ â€² ) âˆ§ (ğ‘ ğœ‹ â†” ğ‘ ğœ‹ â€² )</formula><p>Now we translate each transition (ğ‘, ğ‘), (ğ‘ â€² , ğ‘ â€² , ğ¿) âˆˆ ğ›¿ as follows. If the head moves right instead of left, we change the position of the operator accordingly.</p><formula xml:id="formula_28">ğœ“ trans 1 (â„ ğœ‹ âˆ§ ğ‘ ğœ‹ âˆ§ ğ‘ ğœ‹ ) â†’ â„ ğœ‹ â€² âˆ§ ğ‘ â€² ğœ‹ â€² âˆ§ ğ‘ â€² ğœ‹ â€²</formula><p>The final transition formula is the following:</p><formula xml:id="formula_29">âˆ€ğœ‹ . âˆƒğœ‹ â€² . (ğœ“ LxorR âˆ§ (ğœ“ trans 1 âˆ¨ ğœ“ trans 2 âˆ¨ â€¢ â€¢ â€¢ ))</formula><p>We only encode transitions where ğ‘ â€² âˆ‰ ğ¹ , i.e. only those transitions that do not make the TM halt. The conjunction of the above formulas can be easily transformed into a âˆ€âˆƒ 2 formula with a single and only non-nested operators in the scope of . Now, the TM has an infinite non-halting run iff the conjunction of the above formulas has a satisfying model. The trace set might not only contain the witnessing run but also non-valid configurations or non-reachable configurations, which we can just ignore. â–¡ Theorem 3.11. The satisfiability problem is Î£ 1 1 -complete for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . . Proof. Membership in Î£ 1  1 follows from <ref type="bibr" target="#b23">[24]</ref>. We reduce from the recurring computation problem of nondeterministic twocounter machines. The key idea is to use LTL formulas over pairs of encoded configurations and use the hyperproperty only to ensure that every second component matches with some first component of another trace. We thus set AP = AP 1 âˆª AP 2 and each AP ğ‘– = {l ğ‘– 1 , . . . , l ğ‘– ğ‘› , c ğ‘– 1 , c ğ‘– 2 , t ğ‘– }. The counter values for counter ğ‘ 1 , ğ‘ 2 are encoded by two atomic propositions c 1 and c 2 which hold exactly once, i.e., counter ğ‘¥ has value ğ‘£ if c ğ‘¥ occurs in the ğ‘£th position. We use ğ‘› atomic propositions for the instructions, and require that in the first position, exactly one instruction label holds. Note that all of the above requirements for a valid configuration are easily expressible in LTL. To ensure that the computation visits the initial instruction ğ‘™ 1 infinitely often, we use a proposition t, which must also hold exactly once and decreases with every computation step. When ğ‘¡ is in position 0, l 1 must hold. We encode this requirement as l 1  1 âˆ¨ (t 2 â†” t 1 ). We also encode that each trace denotes an update step of the 2CM. For example instruction ğ‘™ ğ‘– = ğ‘ 1 ğ‘ 1 + 1 goto {ğ‘™ ğ‘— , ğ‘™ ğ‘˜ } can be encoded as:</p><formula xml:id="formula_30">l 1 ğ‘– â†’ ((c 1 2 â†” c 2 2 ) âˆ§ (c 1 1 â†” c 2<label>1</label></formula><p>)) âˆ§ (l 2 ğ‘— âˆ¨ l 2 ğ‘˜ ) Decrement instructions are analogous. Instructions of the form ğ‘™ ğ‘– = if ğ‘ 1 = 0 then goto ğ‘™ ğ‘— else goto ğ‘™ ğ‘˜ can be encoded as.</p><formula xml:id="formula_31">l 1 ğ‘– â†’ (c 1 1 â†’ l 2 ğ‘— ) âˆ§ (Â¬c 1 1 â†’ l 2 ğ‘˜ ) âˆ§ ğ‘¥ âˆˆ1,2 (c 1 ğ‘¥ â†” c 2 ğ‘¥ )</formula><p>We then take the conjunction over the resulting formulas for each instruction.</p><p>What is left to state is the hyperproperty ğœ‘, which matches second components to first components. To show hardness we reduce the acceptance of a timebounded nondeterministic Turing machine on the empty word to a HyperLTL formula (our construction does not require any temporal operators, not even s). Consequently, only the first position of each trace is relevant. Let ğ‘‡ = (ğ‘„, ğ‘„ 0 , Î“, ğ›¿, ğ¹ ) be a exponential time-bounded nondeterministic TM. As our formula uses no s, only the first position is relevant so we can see each trace as a propositional evaluation over AP. The idea is that each trace in the model encodes a piece of information of an accepting run of ğ‘‡ . Such a piece of information is a tuple (ğ‘ , ğ‘, ğ›¾, ğ‘) where ğ‘ , ğ‘ âˆˆ N, ğ›¾ âˆˆ Î“ and ğ‘ âˆˆ ğ‘„ âˆª {âŠ¥}. The information encodes that in time-step ğ‘  and at position ğ‘, the tape content is ğ›¾ and the head is at that position and the machine in state ğ‘ if ğ‘ âˆˆ ğ‘„ or the head is not at that position (if ğ‘ = âŠ¥). As ğ‘‡ is time (and thus space) bounded, ğ‘  and ğ‘ are bound by 2 ğ‘› for some ğ‘›.</p><p>In our formula we now use propositions Ã¬ s = s 1 , . . . , s ğ‘› to encode a time step and Ã¬ p = p 1 , . . . , p ğ‘› to encode a position on the tape (both as a binary counter). Moreover, for each state ğ‘ âˆˆ ğ‘„ âˆª {âŠ¥} and each letter ğ›¾ âˆˆ Î“, we introduce an atomic proposition ğ‘ and ğ›¾. In each evaluation exactly one of the tape-content propositions holds and at most one stateproposition holds (if none holds, the head is at a different step).</p><p>Using HyperLTL, we specify that the information encoded in the traces is consistent and forms an accepting run of the TM:</p><p>(1) At most one of the state-propositions and exactly one of the tape-propositions holds:</p><formula xml:id="formula_32">âˆ€ğœ‹ . ğ›¾ âˆˆÎ“ ğ›¾ ğœ‹ âˆ§ ğ›¾ â‰ ğ›¾ â€² âˆˆÎ“ Â¬ğ›¾ â€² ğœ‹ âˆ§ ğ‘â‰ ğ‘ â€² âˆˆğ‘„ Â¬(ğ‘ ğœ‹ âˆ§ ğ‘ â€² ğœ‹ )</formula><p>(2) If two traces agree in time step and position they also agree on tape content, state (and thus head position):</p><formula xml:id="formula_33">âˆ€ğœ‹âˆ€ğœ‹ â€² . ğ‘› ğ‘–=1 (s ğ‘– ğœ‹ â†” s ğ‘– ğœ‹ â€² ) âˆ§ (p ğ‘– ğœ‹ â†” p ğ‘– ğœ‹ â€² ) â†’ ğ‘ âˆˆğ‘„ (ğ‘ ğœ‹ â†” ğ‘ ğœ‹ â€² ) âˆ§ ğ›¾ âˆˆÎ“ (ğ›¾ ğœ‹ â†” ğ›¾ ğœ‹ â€² )<label>(3)</label></formula><p>The TM state (and therefore also head position) agrees across all traces that are in the same time step. Phrased differently, for any two different traces that agree on the step and the automaton state, are already equal. Here we write ğœ‹ = ğœ‹ â€² to mean that ğœ‹ and ğœ‹ â€² agree (in the first position)</p><formula xml:id="formula_34">âˆ€ğœ‹âˆ€ğœ‹ â€² . ğ‘› ğ‘–=1 (s ğ‘– ğœ‹ â†” s ğ‘– ğœ‹ â€² ) âˆ§ ğ‘ âˆˆğ‘„ (ğ‘ ğœ‹ â†” ğ‘ ğœ‹ â€² ) â†’ ğœ‹ = ğœ‹ â€² (4)</formula><p>The initial configuration of the TM is in the model. We cannot encode this with existential quantification directly, as we would need to refer to exponentially many positions and therfiore also exponentially many traces. Instead, we express it as a âˆ€âˆƒ property. We use syntactic sugar and write Ã¬ p ğœ‹ = Ã¬ p ğœ‹ â€² + 1 to indicate that the binary counter increases by one position. This can easily be encoded in propositional logic in quadratic size. For a constant ğ‘ we write Ã¬ p ğœ‹ = ğ‘ to denote the binary counter given by Ã¬ p equals ğ‘. We express the desired property as a conjunction of the following two formulas. The first formula is given by:</p><formula xml:id="formula_35">âˆƒğœ‹ . Ã¬ s ğœ‹ = 0 âˆ§ Ã¬ p ğœ‹ = 0 âˆ§ # ğœ‹ âˆ§ ğ‘ âˆˆğ‘„ 0 ğ‘ ğœ‹</formula><p>Which expresses that at step 0 at least the very first position is filled with # and the head is at that poistion (in an initial state). The second information propagates this information to all remaining positions in the first step:</p><formula xml:id="formula_36">âˆ€ğœ‹âˆƒğœ‹ â€² . Ã¬ s ğœ‹ = 0 âˆ§ Ã¬ p ğœ‹ â‰  2 ğ‘› -1 â†’ Ã¬ s ğœ‹ â€² = 0 âˆ§ Ã¬ p ğœ‹ â€² = Ã¬ p ğœ‹ + 1 âˆ§ # ğœ‹ â€²</formula><p>Note that (3) already implies that the position is set consistently in the same step, so we do not need to require that âŠ¥ ğœ‹ â€² holds.</p><p>(5) The model encodes valid steps of the TM. As the transitions of a TM are local, it is sufficient to compare three consecutive tape positions with the same three tape positions in the next step. Thus, for every three traces that share the same time step and encode consecutive positions, there exists three traces on the next time step with the same positions such that the step is possible in the TM. The resulting âˆ€ 3 âˆƒ 3 formula then consists of a finite conjunction over those valid "transitions triples" of ğ‘‡ . We do not give the formula explicitly, as the notation gets clustered.</p><formula xml:id="formula_37">)<label>(6</label></formula><p>The TM is eventually in an accepting state which we can express via âˆƒğœ‹ . ğ‘ âˆˆğ¹ ğ‘ ğœ‹ . Note that because of the explicit step count (via Ã¬ s), each model directly encodes a unique run of the TM. In particular, there can not be spurious facts that do not hold on the defined run of the TM. Consequently, we get that the resulting formula is satisfiable iff TM has a 2 We claim that we can actually assume that ğœ™ contains no s operators. We assume that in ğœ™ the s occur directly in from of atomic proportions, i.e., ğœ™ is a boolean formula over atoms of the form ğ‘› ğ‘ ğœ‹ ğ‘– . Transforming a formula in this form is possible in polynomial time. Now let ğ‘˜ be the lookahead needed to evaluate ğœ™ (which is upper bounded by the number of s in ğœ™). We define ğœ™ â€² as the formula over AP 0 âˆª â€¢ For the reverse, assume that ğœ is satisfiable and let ğ›¼ be a satisfying variable assignment over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘›+ğ‘š . We construct a model with ğ‘› + ğ‘š traces ğ‘¡ 1 , . . . , ğ‘¡ ğ‘›+ğ‘š as follows: For every indices ğ‘– 1 , . . . , ğ‘– ğ‘› âˆˆ {1, . . . , ğ‘› + ğ‘š} we choose ğ‘š distinct indices ğ‘— 1 , . . . , ğ‘— ğ‘š âˆˆ {1, . . . , ğ‘› +ğ‘š} that are also different from all ğ‘– 1 , . . . , ğ‘– ğ‘› (this is possible as we fixed ğ‘› + ğ‘š traces). Now fix some fresh position ğ‘› âˆˆ N and ensure that [ğœ‹ 1 â†¦ â†’ ğ‘¡ ğ‘– 1 , . . . , ğœ‹ ğ‘› â†¦ â†’ ğ‘¡ ğ‘– ğ‘› , ğœ‹ ğ‘›+1 â†¦ â†’ ğ‘¡ ğ‘— 1 . . . ğœ‹ ğ‘›+ğ‘š â†¦ â†’ ğ‘¡ ğ‘— ğ‘š ] [ğ‘›, âˆ] |= ğœ™. This is always possible as we can use ğ›¼ to construct the assignments of all involved traces at position ğ‘˜. Here it is crucial that we added the second conjunct ğ‘› ğ‘–=2 ğ‘ âˆˆAP (ğ‘ ğœ‹ ğ‘– â†” ğ‘ ğœ‹ 1 ) to ğœ as this ensures that we construct a position at which the property holds even if ğ‘¡ ğ‘– 1 , . . . , ğ‘¡ ğ‘– ğ‘› are not distinct. We iterate this for every of the finitely many elements in {1, . . . , ğ‘› + ğ‘š} ğ‘› (always choosing a fresh position ğ‘›), thereby defining a model of ğœ‘.</p><p>To show NP-hardness, we can easily reduce from propositional SAT problem: A formula ğœ over AP is satisfiable iff âˆƒğœ‹ . ğœ ğœ‹ is satisfiable (we write ğœ ğœ‹ for ğœ when replacing all atoms ğ‘ with ğ‘ ğœ‹ ).</p><p>To handle multiple eventualities, reuse the above proof. Let ğœ‘ = âˆ€ * âˆƒ * . ğœ™ 1 âˆ§ â€¢ â€¢ â€¢ âˆ§ ğœ™ ğ‘› . We again assume, w.l.o.g., that each ğœ™ ğ‘– contains no s. We introduce a different copy of AP ğ‘– for the ğ‘–th operator. In each -subformula, the propositional variables are exchanged accordingly, i.e., let ğœ™ â€² ğ‘– be ğœ™ ğ‘– where the atomic propositions from AP are replaced with those from AP ğ‘– . It is easy to see that ğœ‘ is satisfiable iff âˆ€ * âˆƒ * . (ğœ™ â€² 1 âˆ§ â€¢ Proof. Let ğœ‘ = âˆ€ ğ‘› âˆƒ ğ‘š . ğœ™. Let ğ‘˜ be the lookahead needed to evaluate ğœ™ (which is upper bounded by the number of s in ğœ™). Similar to the proof of Lemma 4.4 we eliminate s by using letting traces range over tuples. We construct a formula ğœ™ â€² over AP 0 âˆª â€¢ â€¢ â€¢ âˆª AP ğ‘˜ (where AP ğ‘– = {ğ‘ ğ‘– | ğ‘ âˆˆ AP }) as follows: We assume that in ğœ™ the s occur directly in from of atomic proportions, i.e., ğœ™ is a boolean formula over atoms of the form ğ‘› ğ‘ ğœ‹ ğ‘– . Transforming a formula in this form is possible in polynomial time. We then define ğœ™ â€² as the formula over AP 0 âˆª â€¢ â€¢ â€¢ âˆª AP ğ‘˜ obtained from ğœ™ by replacing each atom ğ‘› ğ‘ ğœ‹ ğ‘– with the atomic proposition (ğ‘ ğ‘› ) ğœ‹ ğ‘– .</p><p>The traces we consider now range over letters from AP 0 âˆª â€¢ â€¢ â€¢ âˆª AP ğ‘˜ , i.e., over the window of the next ğ‘˜ + 1 steps. In the LTL part of the specification we assert that this window is consistent, i.e., the ğ‘– + 1th state (evaluation over AP ğ‘–+1 equals the evaluation of the ğ‘–th state in the next step). We define ğœ“ â€² as</p><formula xml:id="formula_38">ğœ“ â€² ğœ“ 0 âˆ§ ğ‘˜-1 ğ‘–=0 ğ‘ âˆˆAP ğ‘ ğ‘–+1 â†” ğ‘ ğ‘–</formula><p>where ğœ“ 0 is obtained from ğœ“ by replacing each proposition ğ‘ âˆˆ AP with ğ‘ 0 âˆˆ AP 0 . We define ğœ‘ â€² = âˆ€ ğ‘› âˆƒ ğ‘š . ğœ™ â€² . It is easy to see that (ğœ“, ğœ‘) and (ğœ“ â€² , ğœ‘ Let ğ‘¡ 1 , . . . ğ‘¡ ğ‘š+1 be the infinite traces constructed in the limit. It is easy to see that ğ‘‡ = {ğ‘¡ 1 , . . . , ğ‘¡ ğ‘š+1 } is a model of ğœ‘. In the limit, this constructs traces of infinite length which serve as a model for ğœ‘. For each trace ğ‘¡ ğ‘– , the traces with index determined by ğ‘“ (ğ‘–) can be chosen as witness traces for existential quantification. By construction, the (unique) run of A ğœ™ on the resulting tuple of traces is accepting. â–¡ C Additional Material for Section 5 Lemma 5.1. In every iteration of the algorithm it holds that L (A new ) âŠ† L (A), and for any trace setğ‘‡ withğ‘‡ |= âˆ€ğœ‹âˆƒğœ‹ â€² . ğœ™, ğ‘‡ âŠ† L (A âˆ€ ).</p><p>Proof. Initially, the property obviously holds as A encodes ğœ‘ and every trace which occurs in any satisfying trace set must have a run through A as the âˆ€ trace. It remains to show that A new does not exclude traces that occur in satisfying ğ‘‡ . The construction ensures that if ğ‘¡ âˆˆ L (A âˆ€ ) but ğ‘¡ âˆ‰ L (A âˆ€ new ), then there exists no witness trace ğ‘¡ â€² such that ğ‘¡ ğœ‹ âˆªğ‘¡ â€² ğœ‹ â€² âˆˆ L (A) and ğ‘¡ â€² âˆˆ L (A âˆ€ ). By induction, L (A) is a superset of the union of all satisfying trace sets, therefore, there can be no ğ‘‡ such that ğ‘¡ âˆˆ ğ‘‡ and ğ‘‡ |= âˆ€ğœ‹âˆƒğœ‹ â€² . ğœ™. â–¡</p></div><figure xml:id="fig_0"><head>Definition 4 . 1 .</head><label>41</label><figDesc>A HyperLTL formula ğ‘„ğœ‹ 1 . . . ğ‘„ğœ‹ ğ‘› . ğœ™ is a temporal liveness property if ğœ™ (interpreted as an LTL formula over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘› ) describes a liveness property.</figDesc></figure>
<figure xml:id="fig_1"><head>Lemma 4 . 4 .</head><label>44</label><figDesc>The satisfiability problem is NP-complete for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€ * âˆƒ * . ( * ) âˆ§ â€¢ â€¢ â€¢ âˆ§ ( * ) and no propositional formulas occur outside of the operators. Hardness already holds for a single eventuality.</figDesc></figure>
<figure type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Deciding satisfiability of HyperLTL specifications. All results, expect for decidability (dec.), denote completeness. Our notation is found in Section 2.3, e.g., âˆ€ * âˆƒ * . ( * ) is the class of âˆ€ * âˆƒ * formulas whose LTL body uses a single operator with optional operators in its scope.</figDesc><table><row><cell /><cell /><cell cols="2">no LTL spec. with LTL spec.</cell></row><row><cell>Temporal</cell><cell>Safety</cell><cell cols="2">complete fragment coRE [Thm. 3.7] âˆ€  *  âˆƒ  *  .  *  NEXP [Thm. 3.12] NEXP [Thm. 3.12] Î£ 1 1 [Thm. 3.11] âˆ€  *  âˆƒ  *  . NEXP [Lem. 3.13] Î£ 1 1 [Thm. 3.11] âˆ€  *  âˆƒ  *  . (  *  ) coRE [Lem. 3.10] Î£ 1 1 [Thm. 3.11]</cell></row><row><cell>Temporal</cell><cell>Liveness</cell><cell>complete fragment âˆ€âˆƒ  *  . det-liveness trivial [Prop. 4.14] Î£ 1 1 [Thm. 4.2] âˆ€âˆƒ  *  . (  *  ) NP [Lem. 4.4] âˆ€  *  âˆƒ  *  . âˆ§ â€¢ â€¢ â€¢ âˆ§ NP [Lem. 4.4]</cell><cell>Î£ 1 1 [Thm. 4.2] Î£ 1 1 [Cor. 4.15] dec. [Thm. 4.5] Î£ 1 1 [Thm. 4.11]</cell></row></table></figure>
<figure type="table" xml:id="tab_1"><head /><label /><figDesc>HyperLTL formulas ğœ‘ 1 , ğœ‘ 2 , we therefore write ğœ‘ 1 âˆ§ ğœ‘ 2 for some HyperLTL formula expressing the conjunction of ğœ‘ 1 , ğœ‘ 2 . For examples (âˆ€ğœ‹âˆƒğœ‹ â€² . (ğ‘ ğœ‹ â†® ğ‘ ğœ‹ â€² )) âˆ§ (âˆ€ğœ‹ . ğ‘ ğœ‹ ) can be expressed as âˆ€ğœ‹âˆ€ğœ‹ â€² âˆƒğœ‹ â€²â€² . (ğ‘ ğœ‹ â†® ğ‘ ğœ‹ â€²â€² ) âˆ§ ğ‘ ğœ‹ â€² . â—</figDesc><table /><note><p>ğœ‘ (written ğ‘‡ |= ğœ‘) if âˆ… |= ğ‘‡ ğœ‘, where âˆ… denotes the empty trace assignment. Remark 2.2. HyperLTL is closed under conjunction (and, more generally, under any boolean combination). For two</p></note></figure>
<figure type="table" xml:id="tab_2"><head /><label /><figDesc>2 . Each instruction ğ‘™ ğ‘– is of one of the following forms, where ğ‘¥ âˆˆ {1, 2} and 1 â‰¤ ğ‘–, ğ‘—, ğ‘˜ â‰¤ ğ‘›. 1) ğ‘™ ğ‘– : ğ‘ ğ‘¥ ğ‘ ğ‘¥ + 1; goto {ğ‘™ ğ‘— , ğ‘™ ğ‘˜ } 2) ğ‘™ ğ‘– : ğ‘ ğ‘¥ ğ‘ ğ‘¥ -1; goto {ğ‘™ ğ‘— , ğ‘™ ğ‘˜ } 3) ğ‘™ ğ‘– : if ğ‘ ğ‘¥ = 0 then goto ğ‘™ ğ‘— else goto ğ‘™ ğ‘˜ 4) ğ‘™ ğ‘– : halt Here, goto {ğ‘™ ğ‘— , ğ‘™ ğ‘˜ } indicates that the machine nondeterministically chooses between instructions ğ‘™ ğ‘— and ğ‘™ ğ‘˜</figDesc><table /></figure>
<figure type="table" xml:id="tab_3"><head /><label /><figDesc>the LTL semantics so ğ‘¡ â€² Ì¸ |= ğœ™ â€² as required. {1, . . . , ğ‘š} â†’ {1, . . . , ğ‘›} we define the formula ğœ™ [ğ‘”] as the formula obtained by replacing each trace variable ğœ‹ â€² ğ‘¡ ğ‘– . The trace assignment [ğœ‹ 1 â†¦ â†’ ğ‘¡ 1 , . . . , ğœ‹ ğ‘› â†¦ â†’ ğ‘¡ ğ‘› ] satisfies ğœ™ [ğ‘”] . As we can find such a ğ‘” for every ğ‘¡ 1 , . . . , ğ‘¡ ğ‘› âˆˆ ğ‘‡ , we get that ğ‘‡ |= ğœ‘ â€² as required. As ğœ‘ â€² is a âˆ€ * formula, we can conclude using Proposition 3.4. â–¡ While temporal safety subsumes âˆ€ * âˆƒ * hypersafety, it is a strictly larger fragment as shown by the following formula. âˆƒğœ‹ . ğ‘ ğœ‹ âˆ§ âˆ€ğœ‹ . (ğ‘ ğœ‹ â†’ Â¬ğ‘ ğœ‹ ) âˆ§ âˆ€ğœ‹âˆƒğœ‹ â€² . (ğ‘ ğœ‹ â†” ğ‘ ğœ‹ â€² ) Every model of this property must contain infinitely many traces. Hypersafety properties, on the other hand, are closed under subsets and are therefore always satisfiable by a single trace model (if satisfiable at all) [13].</figDesc><table /><note><p><p><p><p><p><p>â–¡ Remark 3.5. We do not claim that every âˆ€ * hypersafety property is temporally safe. Instead, Proposition 3.4 only states that there exists an equivalent temporally safe property. For example, âˆ€ğœ‹âˆ€ğœ‹ â€² . (ğ‘ ğœ‹ âˆ§ Â¬ğ‘ ğœ‹ â€² ) is unsatisfiable and thus hypersafety but (ğ‘ ğœ‹ âˆ§ Â¬ğ‘ ğœ‹ â€² ) is not a safety property. â— Proposition 3.6. For any âˆ€ * âˆƒ * hypersafety property, there exists an equivalent âˆ€ * property that is temporally safe.</p>Proof. Let ğœ‘ = âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› âˆƒğœ‹ â€² 1 . . . ğœ‹ â€² ğ‘š . ğœ™ be hypersafety. For a function ğ‘” : ğ‘– for 1 â‰¤ ğ‘– â‰¤ ğ‘š with ğœ‹ ğ‘” (ğ‘–) . Now define:</p>ğœ‘ â€² âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› .</p>ğ‘”:{1,...,ğ‘š }â†’{1,...,ğ‘› }</p>ğœ™ [ğ‘”]</p>We claim that ğœ‘ â‰¡ ğœ‘ â€² . Showing that ğœ‘ â€² implies ğœ‘ is easy as the disjunction gives an explicit witness for the existential quantifiers. For the other direction, assume ğ‘‡ |= ğœ‘ for some model ğ‘‡ . Let ğ‘¡ 1 , . . . , ğ‘¡ ğ‘› âˆˆ ğ‘‡ be arbitrary. As ğœ‘ is a hypersafety property and {ğ‘¡ 1 , . . . , ğ‘¡ ğ‘› } âŠ† ğ‘‡ , we get that {ğ‘¡ 1 , . . . , ğ‘¡ ğ‘› } |= ğœ‘. In particular, if we bind each ğœ‹ ğ‘– to ğ‘¡ ğ‘– (in ğœ‘), we get witness traces ğ‘¡ â€² 1 , . . . , ğ‘¡ â€² ğ‘š âˆˆ {ğ‘¡ 1 , . . . , ğ‘¡ ğ‘› } for the existential quantifiers in ğœ‘. Now define ğ‘” by mapping each 1 â‰¤ ğ‘— â‰¤ ğ‘š to ğ‘– âˆˆ {1, . . . , ğ‘›} with ğ‘¡ â€² ğ‘— =</p></note></figure>
<figure type="table" xml:id="tab_4"><head /><label /><figDesc>TimePoint to indicate that on trace ğ‘¡, ğ‘ holds at point in time ğ‘–. For each state ğ‘ âˆˆ ğ‘„ ğœ™ we use a predicate State ğ‘ over Trace ğ‘› Ã— TimePoint. Informally, State ğ‘ (ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› , ğ‘–) indicates that a run of A on traces ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› is in state ğ‘ at timepoint ğ‘–.We first ensure that each point in time has a successor and that the set of traces is non-empty.For each state ğ‘ âˆˆ ğ‘„ ğœ™ , we construct a formula ğœŒ ğ‘ (over free variables ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› ), describing that, for any choice of traces and at any point in time, there is a transition in A.ğœŒğ‘ âˆ€ğ‘–, ğ‘– â€² : TimePoint. State ğ‘ (ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› , ğ‘–) âˆ§ Succ(ğ‘–, ğ‘– â€² ) â†’ (ğ‘,ğœ,ğ‘ â€² ) âˆˆğ›¿ ğœ™ ğ‘ ğœ‹ ğ‘— âˆˆğœ ğ‘ƒ ğ‘ (ğ‘¥ ğ‘— , ğ‘–) âˆ§</figDesc><table><row><cell>ğœ™ succ</cell></row></table><note><p>TimePoint to indicate the initial time point. The predicate Succ(â€¢, â€¢) over TimePoint Ã— TimePoint encodes the successor relation on time. For each ğ‘ âˆˆ AP, we use a predicate ğ‘ƒ ğ‘ (â€¢, â€¢) over Trace Ã— âˆ€ğ‘– : TimePoint. âˆƒğ‘– â€² : TimePoint. Succ(ğ‘–, ğ‘– â€² ) ğœ™ non-empty âˆƒğ‘¥ : Trace. âŠ¤ ğ‘ ğœ‹ ğ‘— âˆ‰ğœ Â¬ğ‘ƒ ğ‘ (ğ‘¥ ğ‘— , ğ‘–) âˆ§ State ğ‘ â€² (ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› , ğ‘– â€² ) Now, Î˜ is defined as follows Î˜ ğ‘„ 1 ğ‘¥ 1 : Trace. . . . ğ‘„ ğ‘› ğ‘¥ ğ‘› : Trace. ğœ™ succ âˆ§ ğœ™ non-empty âˆ§ ğ‘ âˆˆğ‘„ ğœŒ ğ‘ âˆ§ State ğ‘ 0 (ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› , ğ‘– ğ‘œ ). The last conjunct ensures that all trace tuples chosen by the quantifiers have an infinite run in A starting in the initial state and in the initial time point. If Î˜ is satisfiable, we can construct a trace assignment by setting the propositions based on the evaluation of ğ‘ƒ ğ‘ (â€¢, â€¢) in a satisfying first-order model of Î˜ and vice versa. A detailed proof can be found in Appendix A. â–¡</p></note></figure>
<figure type="table" xml:id="tab_5"><head /><label /><figDesc>Model for âˆ€ğœ‹ . âˆƒğœ‹ â€² . ğœ™ formulas. Dashed boxes indicate the witness points for the operator.can arrange the runs in ğ‘… as a sequence: we choose ğ‘Ÿ 0 , ğ‘Ÿ 1 , . . . âˆˆ ğ‘… (not necessarily distinct) such that, for each ğ‘–, ğ‘Ÿ ğ‘–+1 serves as a witness for ğ‘Ÿ</figDesc><table /><note><p><p><p><p><p>ğ‘– , i.e., [ğœ‹ â†¦ â†’ ğ¿ ğœ“ (ğ‘Ÿ ğ‘– ), ğœ‹ â€² â†¦ â†’ ğ¿ ğœ“ (ğ‘Ÿ ğ‘–+1 )] |= ğœ™. We say ğ‘› 0 , ğ‘› 1 , . . . are witness points if</p>[ğœ‹ â†¦ â†’ ğ¿ ğœ“ (ğ‘Ÿ ğ‘– ), ğœ‹ â€² â†¦ â†’ ğ¿ ğœ“ (ğ‘Ÿ ğ‘–+1 )] [ğ‘› ğ‘– , âˆ]</p>|= ğœ™ for every ğ‘–, i.e., the ğ‘› ğ‘– point to a step at which the eventuality holds. The trace arrangement is depicted in Figure</p>1</p>(ignoring the blue smaller nodes and gray edges for now). For each ğ‘–, the dashed box denotes the witness point ğ‘› ğ‘– where ğ‘Ÿ ğ‘– and ğ‘Ÿ ğ‘–+1 satisfy ğœ™.</p></note></figure>
<figure type="table" xml:id="tab_6"><head /><label /><figDesc>In general, let ğ‘¥ ğ‘– be the sequence (ğ‘ 0 ğ‘– , ğ‘› 0 ğ‘– ) . . . (ğ‘ ğ‘˜ ğ‘– ğ‘– , ğ‘› ğ‘˜ ğ‘– ğ‘– ). From ğ‘¥ ğ‘– , we construct a finite run ğ‘Ÿ ğ‘– âˆˆ ğ‘„ * ğœ“ of A ğœ“ starting in a state in ğ‘„ 0,ğœ“ such that for every 0 â‰¤ ğ‘— â‰¤ ğ‘˜ ğ‘– , ğ‘Ÿ ğ‘– (ğ‘› ğ‘— ğ‘– ) = ğ‘ ğ‘— ğ‘– . Using the fact that for each (ğ‘, ğ‘, ğ‘›) in S, we have ğ‘ âˆˆ Reach A ğœ‹ (ğ‘›), this is always possible. It is crucial that we cannot reverse directions between two W-steps. The finite ğ‘Ÿ ğ‘– ends in a state in A ğœ“ , so by the assumption that all states are nonempty, we can extend it into an infinite accepting run. The set {ğ¿ ğœ“ (ğ‘Ÿ 0 ), ğ¿ ğœ“ (ğ‘Ÿ 1 ), . . .} is a model of (ğœ“, ğœ‘). to the stack and moves to state ğ‘ â€² . An accepting run is an infinite sequence of configurations that starts in âŸ¨ğ‘ 0 , [ğ›¾ 0 ]âŸ© for some ğ‘ 0 âˆˆ ğ‘„ 0 , respects ğ›¿, and visits states in ğ¹ infinitely many times. It is decidable in polynomial time if a</figDesc><table /><note><p>â–¡ 4.4.3 From Infinite State to Pushdown. The construction of S requires infinitely many states as we need to carry the natural number ğ‘› to ensure valid B and W steps (which need access to Reach A ğœ“ (ğ‘›)). We show next that we can replace this infinite state space by a finite pushdown system. Definition 4.9. A BÃ¼chi pushdown system is a tuple P = (ğ‘„, Î“, ğ‘„ 0 , ğ›¾ 0 , ğ›¿, ğ¹ ), where ğ‘„ is a finite set of states, Î“ the finite stack alphabet, ğ‘„ 0 âŠ† ğ‘„ initial states, ğ›¾ 0 âˆˆ Î“ the initial stack symbol, ğ›¿ âŠ† (ğ‘„ Ã— Î“ + ) Ã— (ğ‘„ Ã— Î“ * ) a finite transition relation, and ğ¹ âŠ† ğ‘„ a set of accepting states. The system operates on configuration âŸ¨ğ‘, ğ›¼âŸ©, where ğ‘ âˆˆ ğ‘„ and ğ›¼ âˆˆ Î“ * . A transition âŸ¨ğ‘, ğ›¼âŸ© â‡ âŸ¨ğ‘ â€² , ğ›¼ â€² âŸ© âˆˆ ğ›¿ describes that the system, if in state ğ‘ and ğ›¼ âˆˆ Î“ + is a prefix of the current stack, pops ğ›¼, pushes ğ›¼ â€² âˆˆ Î“ *</p></note></figure>
<figure type="table" xml:id="tab_7"><head /><label /><figDesc>1) based onReach A ğœ“ (ğ‘›). In B-steps, the stack provides access to all states that are reachable, and thus guarantees the invariant that ğ‘ âˆˆ Reach A ğœ“ (ğ‘›) for each state (ğ‘, ğ‘, ğ‘›) in S. It is not hard to see that P has a run that uses W-steps infinitely often iff S has a run that uses W-steps infinitely often. Combined with Lemma 4.8 we thus get:</figDesc><table /><note><p>Lemma 4.10. P has an accepting run that uses W-steps infinitely often if and only if (ğœ“, ğœ‘) is satisfiable.</p></note></figure>
<figure type="table" xml:id="tab_8"><head>Table 3 .</head><label>3</label><figDesc>Comparison of LMHyper and MGHyper on handcrafted specifications. We give the result (âœ“ if the specification is satisfiable and âœ— if it is unsatisfiable), the time in ms, and the number of iterations needed by LMHyper. The timeout is set to 5min.</figDesc><table><row><cell /><cell /><cell /><cell cols="3">LMHyper</cell></row><row><cell>Size</cell><cell>ğ‘</cell><cell>ğ‘¡</cell><cell>ğ‘</cell><cell>ğ‘¡</cell><cell cols="2">#Iter</cell></row><row><cell>15</cell><cell cols="2">95% 40</cell><cell cols="3">100% 235 0.38</cell></row><row><cell>16</cell><cell cols="2">93% 39</cell><cell cols="3">99% 239 0.44</cell></row><row><cell>17</cell><cell cols="2">95% 39</cell><cell cols="3">100% 221 0.43</cell></row><row><cell>18</cell><cell cols="2">92% 38</cell><cell cols="3">100% 201 0.39</cell></row><row><cell>19</cell><cell cols="2">95% 40</cell><cell cols="3">100% 180 0.43</cell></row><row><cell>20</cell><cell cols="2">97% 42</cell><cell cols="3">100% 215 0.27</cell></row><row><cell /><cell cols="2">MGHyper</cell><cell /><cell /><cell cols="2">LMHyper</cell></row><row><cell>Problem</cell><cell cols="2">Res ğ‘¡</cell><cell>Res</cell><cell /><cell>ğ‘¡</cell><cell>#Iter</cell></row><row><cell>Inf</cell><cell>-</cell><cell>TO</cell><cell>âœ“</cell><cell /><cell>350</cell><cell>1</cell></row><row><cell>Example 1.1</cell><cell>-</cell><cell>TO</cell><cell>âœ“</cell><cell /><cell>232</cell><cell>1</cell></row><row><cell>Enforce-2</cell><cell cols="2">âœ“ 444</cell><cell>âœ“</cell><cell /><cell>262</cell><cell>0</cell></row><row><cell>Enforce-3</cell><cell>-</cell><cell>TO</cell><cell>âœ“</cell><cell /><cell>334</cell><cell>0</cell></row><row><cell>Enforce-5</cell><cell>-</cell><cell>TO</cell><cell>âœ“</cell><cell /><cell>491</cell><cell>0</cell></row><row><cell>Unsat-3</cell><cell>-</cell><cell>TO</cell><cell>âœ—</cell><cell /><cell>777</cell><cell>3</cell></row><row><cell>Unsat-5</cell><cell>-</cell><cell>TO</cell><cell cols="3">âœ— 1363</cell><cell>5</cell></row><row><cell>Unsat-9</cell><cell>-</cell><cell>TO</cell><cell cols="3">âœ— 1681</cell><cell>9</cell></row></table></figure>
<figure type="table" xml:id="tab_9"><head /><label /><figDesc>. The Inf specification expresses that a model has infinitely many traces. Example 1.1 is the example from the introduction. The Enforce-ğ‘› specification enforces a model that has at least ğ‘› traces. It is defined asâˆ€ğœ‹âˆƒğœ‹ 1 . . . ğœ‹ ğ‘› . ğ‘–â‰ ğ‘— (ğ‘ ğœ‹ ğ‘– â†® ğ‘ ğœ‹ ğ‘— ). ğ‘› Â¬ğ‘ combined with the hyperproperty ğœ‘ âˆ€ğœ‹âˆƒğœ‹ â€² . (ğ‘ ğœ‹ âˆ§ ğ‘ ğœ‹ â€² ).The formula is designed such that Algorithm 1 requires ğ‘› iterations to discover unsatisfiability. MGHyper times out for most of the examples; even on simple properties like Enforce-3. In contrast, LMHyper can verify properties enforcing many traces in a single iteration because the number of iterations is independent of the number of traces in a model. As expected, Unsat-ğ‘› is unsatisfiable and LMHyper requires multiple iterations to show this.</figDesc><table><row><cell /><cell /><cell>The Unsat-ğ‘› specifica-</cell></row><row><cell cols="3">tions are unsatisfiable. Their definition is a trace property</cell></row><row><cell>ğœ“</cell><cell>(Â¬ğ‘) U (ğ‘ âˆ§</cell><cell>Â¬ğ‘) âˆ§</cell></row></table></figure>
<figure type="table" xml:id="tab_10"><head /><label /><figDesc>âˆ€ğœ‹ . âˆƒğœ‹ â€² . ğœ‹ The resulting specification (ğœ“, ğœ‘) is satisfiable iff the 2CM has a recurring computation starting in the initial state. The formula ğœ‘ is from the âˆ€âˆƒ 2 fragment and uses only a single without nested temporal operators. â–¡ Theorem 3.12. The satisfiability problem is NEXPTIME-complete for specifications (ğœ“, ğœ‘) where ğœ‘ is of the form ğ‘„ * . * . Hardness holds already for ğœ“ = âŠ¤, a âˆ€ * âˆƒ * prefix, and no s. Proof. Let ğœ‘ = ğ‘„ * . ğœ™. For membership in NEXPTIME, let ğ‘˜ be the lookahead needed to evaluate ğœ™, which is upperbounded the number of operators occurring in ğœ™. Now define ğ‘€ âŠ† Î£ ğ‘˜ as all finite traces ğœ of length ğ‘˜ such that ğœ can be extended to a trace satisfying ğœ“ . ğ‘€ can be constructed in exponential time by converting ğœ“ to a BÃ¼chi automaton and checking if each ğœ âˆˆ ğ‘€ has an accepting run in linear time. We then nondeterministically guess a subset ğ‘€ â€² âŠ† ğ‘€ and verify that ğ‘€ â€² |= ğœ‘ which can easily be done in nondeterministic exponential time, giving the desired NEXPTIME-upper bound.</figDesc><table><row><cell>ğ‘ 2 ğœ‹ â†” ğ‘ 1 ğœ‹ â€²</cell></row><row><cell>ğ‘ âˆˆAP</cell></row><row><cell>Additionally, the initial configuration must be present in the</cell></row><row><cell>first component of a trace.</cell></row><row><cell>âˆƒğœ‹ . (c 1 1 ) ğœ‹ âˆ§ (c 1 2 ) ğœ‹ âˆ§ (l 1 1 )</cell></row></table></figure>
<figure type="table" xml:id="tab_11"><head /><label /><figDesc>ğ‘› -time bounded accepting run. The reduction outlined above can be done in logspace, giving the desired NEXPTIME-hardness.</figDesc><table /><note><p><p>â–¡ B Additional Material for Section 4 Lemma 4.4. The satisfiability problem is NP-complete for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€ * âˆƒ * . ( * ) âˆ§ â€¢ â€¢ â€¢ âˆ§ ( * ) and no propositional formulas occur outside of the operators. Hardness already holds for a single eventuality.</p>Proof. We first consider the case where we have only a single eventuality. Let ğœ‘ = âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› âˆƒğœ‹ ğ‘›+1 . . . ğœ‹ ğ‘›+ğ‘š . ğœ™.</p></note></figure>
<figure type="table" xml:id="tab_12"><head /><label /><figDesc>â€¢ â€¢ âˆª AP ğ‘˜ (where AP ğ‘– = {ğ‘ ğ‘– | ğ‘ âˆˆ AP }) obtained from ğœ™ by replacing each atom ğ‘› ğ‘ ğœ‹ ğ‘– with the atomic proposition (ğ‘ ğ‘› ) ğœ‹ ğ‘– . As ğœ™ occurs under a , it is easy to see that âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› âˆƒğœ‹ ğ‘›+1 . . . ğœ‹ ğ‘›+ğ‘š . ğœ™ is satisfiable iff âˆ€ğœ‹ 1 . . . ğœ‹ ğ‘› âˆƒğœ‹ ğ‘›+1 . . . ğœ‹ ğ‘›+ğ‘š . ğœ™ â€² is satisfiable. So let us assume in the following that ğœ™ contains no temporal operators, i.e., ğœ™ is a propositional boolean formula over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘›+ğ‘š . We claim that ğœ‘ is satisfiable iff Let ğ‘› âˆˆ N be such that [ğœ‹ 1 â†¦ â†’ ğ‘¡, . . . , ğœ‹ ğ‘› â†¦ â†’ ğ‘¡, ğœ‹ ğ‘›+1 â†¦ â†’ ğ‘¡ ğ‘›+1 , . . . , ğœ‹ ğ‘›+ğ‘š â†¦ â†’ ğ‘¡ ğ‘›+ğ‘š ] [ğ‘›, âˆ] |= ğœ™. We construct an assignment ğ›¼ : AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢âˆªAP ğœ‹ ğ‘›+ğ‘š â†’ B as follows: For each ğ‘ ğœ‹ ğ‘– we define ğ›¼ (ğœ‹ ğ‘– ) ğ‘¡ (ğ‘›) (ğ‘) if 1 â‰¤ ğ‘– â‰¤ ğ‘› and ğ›¼ (ğœ‹ ğ‘– ) ğ‘¡ ğ‘– (ğ‘›) (ğ‘) if ğ‘› +1 â‰¤ ğ‘– â‰¤ ğ‘› +ğ‘š. It is easy to see that ğ›¼ satisfies ğœ (note that all universally quantified copies are chosen by ğ‘¡ so ğ‘› ğ‘–=2 ğ‘ âˆˆAP (ğ‘ ğœ‹ ğ‘– â†” ğ‘ ğœ‹ 1 ) holds trivially).</figDesc><table><row><cell /><cell>ğ‘›</cell><cell /></row><row><cell>ğœ</cell><cell>ğœ™ âˆ§</cell><cell>(ğ‘ ğœ‹ ğ‘– â†” ğ‘ ğœ‹ 1 )</cell></row><row><cell /><cell>ğ‘–=2 ğ‘ âˆˆAP</cell><cell /></row><row><cell cols="3">is satisfiable (viewed as a propositional formula). For the</cell></row><row><cell cols="3">left to right direction, assume that ğœ‘ is satisfiable by ğ‘‡ . We</cell></row><row><cell cols="3">now pick any ğ‘¡ âˆˆ ğ‘‡ and instantiate all universal quanti-</cell></row></table><note><p>fiers with ğ‘¡. Then let ğ‘¡ ğ‘›+1 , . . . , ğ‘¡ ğ‘›+ğ‘š âˆˆ ğ‘‡ , be witness traces for the existential quantification. So [ğœ‹ 1 â†¦ â†’ ğ‘¡, . . . , ğœ‹ ğ‘› â†¦ â†’ ğ‘¡, ğœ‹ ğ‘›+1 â†¦ â†’ ğ‘¡ ğ‘›+1 , . . . , ğœ‹ ğ‘›+ğ‘š â†¦ â†’ ğ‘¡ ğ‘›+ğ‘š ] |= ğœ™.</p></note></figure>
<figure type="table" xml:id="tab_13"><head /><label /><figDesc>â€¢ â€¢ âˆ§ ğœ™ â€² ğ‘› ) is satisfiable, as we can simply fulfill all eventualities at different timepoints. â–¡ Lemma B.1. The satisfiability problem is NEXPTIME-complete for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€ * âˆƒ * . ( * ) âˆ§ â€¢ â€¢ â€¢ âˆ§ ( * ) (and we do allow propositional formulas occur outside of the operators). Proof. We prove this lemma by combining Lemma 4.4 and Theorem 3.12. The crux is that we can separate the propositional formulas outside the . Assume we are given a formula ğœ‘ = âˆ€ * âˆƒ * . ( ğœ™ 1 )âˆ§â€¢ â€¢ â€¢âˆ§( ğœ™ ğ‘› )âˆ§ğœ™ â€² where ğœ™ 1 , . . . , ğœ™ ğ‘› , ğœ™ â€² contain only s. It it easy to see that ğœ‘ is satisfiable iff both âˆ€ * âˆƒ * . ( ğœ™ 1 ) âˆ§ â€¢ â€¢ â€¢ âˆ§ ( ğœ™ ğ‘› ) and âˆ€ * âˆƒ * . ğœ™ â€² are satisfiable. The former is decidable in NP (see Lemma 4.4) and the latter in NEXPTIME (see Theorem 3.12), so the NEXPTIME upper bound follows. For the lower bound, we can directly use the hardness shown in Theorem 3.12 and ignore the ability to use formulas. â–¡ Lemma 4.6. Let (ğœ“, ğœ‘) be a specification where ğœ‘ is of the form âˆ€ ğ‘› âˆƒ ğ‘š . ( * ). There exists an effectively computable specification (ğœ“ â€² , ğœ‘ â€² ) where ğœ‘ â€² is the of the form âˆ€ ğ‘› âˆƒ ğ‘š . such that (ğœ“, ğœ‘) and (ğœ“ â€² , ğœ‘ â€² ) are equisatisfiable.</figDesc><table /></figure>
<figure type="table" xml:id="tab_14"><head /><label /><figDesc>â€² ) are equisatisfiable. â–¡ Proposition 4.14. HyperLTL formulas of the form ğœ‘ = âˆ€âˆƒ * . ğœ™ where ğœ™ is a deterministic liveness property are always satisfiable and have a finite model.Proof. Let ğœ‘ = âˆ€ğœ‹ 1 âˆƒğœ‹ 2 . . . ğœ‹ ğ‘š+1 . ğœ™ and let A ğœ™ be a deterministic BÃ¼chi automaton for ğœ™ over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘š+1 . For finite traces ğ‘¢ 1 , . . . , ğ‘¢ ğ‘š+1 of the same length (say ğ‘˜), we define zip(ğ‘¢ 1 , . . . , ğ‘¢ ğ‘š+1 ) as the finite trace (of length ğ‘˜) over AP ğœ‹ 1 âˆª â€¢ â€¢ â€¢ âˆª AP ğœ‹ ğ‘š+1 that combines ğ‘¢ 1 , . . . , ğ‘¢ ğ‘š+1 , i.e., the evaluation of AP ğœ‹ ğ‘– is copied from ğ‘¡ ğ‘– . The crucial property we use is that for a deterministic liveness property, we can always revisit an accepting state even after having read an arbitrary finite word. We claim that there always exists a finite model of size at most ğ‘š + 1. For any ğ‘– âˆˆ {1, . . . , ğ‘š + 1} define ğ‘“ (ğ‘–) as the vector (1, . . . , ğ‘– -1, ğ‘– + 1, . . . , ğ‘š + 1) (which has length ğ‘š). We iteratively constructs a model as follows: Initially, we set ğ‘¢ 1 , . . . , ğ‘¢ ğ‘š+1 = ğœ–. For each ğ‘— = 0, 1, 2, . . . let ğ‘– = ( ğ‘—%(ğ‘š + 1)) + 1 (this way we consider each ğ‘– âˆˆ {1, . . . , ğ‘š + 1} infinitely many times) and ( ğ‘— 1 , . . . , ğ‘— ğ‘š ) = ğ‘“ (ğ‘–). We now extend each of the traces in ğ‘‡ by some finite, non-empty word ğ‘¢ â€² 1 , . . . , ğ‘¢ â€² ğ‘š+1 of the same length such that zip(ğ‘¢ ğ‘– ğ‘¢ â€² ğ‘– , ğ‘¢ ğ‘— 1 ğ‘¢ â€² ğ‘— 1 , . . . , ğ‘¢ ğ‘— ğ‘š ğ‘¢ â€² ğ‘— ğ‘š ) reaches an accepting state in A ğœ™ . As A ğœ™ is a deterministic liveness automaton this is always possible.</figDesc><table /></figure>
			<note place="foot" n="1" xml:id="foot_0"><p>Of course, we can incorporate the LTL property in the HyperLTL formula: we conceptually divide the specification into a (complicated) trace property and a (simple) hyperproperty.</p></note>
			<note place="foot" n="2" xml:id="foot_1"><p>Existing decidability results for HyperLTL consider fragments that, if satisfiable, are satisfiable by a finite set of traces of bounded size. This includes the âˆƒ * âˆ€ * fragment studied in<ref type="bibr" target="#b18">[19]</ref> and the decidable fragments identified in<ref type="bibr" target="#b32">[32]</ref>.</p></note>
			<note place="foot" n="3" xml:id="foot_2"><p>The size of ğ‘„ ğœ“ is at most exponential in ğœ“<ref type="bibr" target="#b41">[41]</ref>, so the size of the stack alphabet of P (which is 2 ğ‘„ ğœ“ ) is at most double exponential in ğœ“ . As deciding the emptiness of a BÃ¼chi pushdown system is polynomial, the 2EXPTIME upper bound follows.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments All authors are partially supported by the <rs type="funder">German Research Foundation (DFG)</rs> in project <rs type="grantNumber">389792660</rs>, <rs type="grantNumber">TRR 248</rs> (<rs type="funder">Center for Perspicuous Systems)</rs>. <rs type="person">M. KrÃ¶tzsch</rs> is additionally supported by the <rs type="funder">Bundesministerium fÃ¼r Bildung und Forschung (BMBF)</rs> in project <rs type="projectName">ScaDS</rs>.<rs type="projectName">AI (Center for Scalable Data Analytics and Artificial Intelligence</rs>), and by the <rs type="funder">Center for Advancing Electronics Dresden</rs> (cfaed). <rs type="person">R. Beutner</rs>, <rs type="person">B. Finkbeiner</rs> and <rs type="person">J. Hofmann</rs> are additionally supported by the <rs type="funder">European Research Council (ERC)</rs> in project <rs type="projectName">OSARES</rs> (No. <rs type="grantNumber">68330</rs>). <rs type="person">R. Beutner</rs> and <rs type="person">J. Hofmann</rs> carried out this work as members of the <rs type="institution">SaarbrÃ¼cken Graduate School of Computer Science</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_bcZcRJj">
					<idno type="grant-number">389792660</idno>
				</org>
				<org type="funding" xml:id="_JEmEAjn">
					<idno type="grant-number">TRR 248</idno>
				</org>
				<org type="funded-project" xml:id="_vxXfdrg">
					<orgName type="project" subtype="full">ScaDS</orgName>
				</org>
				<org type="funded-project" xml:id="_RaccuPu">
					<orgName type="project" subtype="full">AI (Center for Scalable Data Analytics and Artificial Intelligence</orgName>
				</org>
				<org type="funded-project" xml:id="_2ZKn6m8">
					<idno type="grant-number">68330</idno>
					<orgName type="project" subtype="full">OSARES</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div><p>A Additional Material For Section 3 Definition A.1. A nondeterministic Turing machine is a tuple ğ‘‡ = (ğ‘„, ğ‘„ 0 , Î“, ğ›¿, ğ¹ ) where ğ‘„ is a finite set of states, ğ‘„ 0 âŠ† ğ‘„ the initial states, Î“ a finite alphabet, ğ›¿ âŠ† (ğ‘„ Ã— Î“) Ã— (ğ‘„ Ã— Î“ Ã— {ğ¿, ğ‘…}) the transition relation and ğ¹ âŠ† ğ‘„ a set of accepting states. A transition ((ğ‘, ğ‘), (ğ‘ â€² , ğ‘ â€² , ğ‘‘)) âˆˆ ğ›¿ means that the if the TM is in state ğ‘ and reads ğ‘, it updates its state to ğ‘ â€² , writes ğ‘ â€² , and moves either to the left (ğ‘‘ = ğ¿) or the right (ğ‘‘ = ğ‘…). We assume a dedicated blank symbol # âˆˆ Î“. In an initial configuration for a finite word ğ‘¤ âˆˆ Î“ (not containing #), the head is at position 0, the state is in some state in ğ‘„ 0 and the tape contains ğ‘¤ (followed by infinitely many #). We say that a TM accepts the empty word if there is a run starting in an initial configuration that eventually visits a configuration where the state is in ğ¹ . A TM is deterministic if ğ‘„ 0 = {ğ‘ 0 } and for each (ğ‘, ğ‘), there exists at most one successor in ğ›¿.</p><p>Proposition 3.9. The satisfiability problem of temporally safe HyperLTL is in coRE.</p><p>Proof. We already gave the construction of a FOL formula Î˜ in the proof sketch in the main part (in Section 3). Here we only show its correctness, i.e., we show that the FOL formula Î˜ and HyperLTL formula ğœ‘ are equisatisfiable.</p><p>Assume Î˜ is satisfiable and fix a first-order model. Let the set ğ‘‹ be the set of elements from the Trace domain which may be assigned to some variable ğ‘¥ ğ‘– in any possible evaluation of the quantifiers. We iteratively construct a trace for any element of ğ‘‹ . To do so, let ğ‘– 0 , ğ‘– 1 , . . . be a fixed sequence of element from TimePoint such that Succ(ğ‘– ğ‘— , ğ‘– ğ‘—+1 ) for any ğ‘— âˆˆ N and ğ‘– 0 is the constant described above. This sequence might not be unique and elements might occur several times but we need to fix one such sequence to obtain well-defined traces. For each element ğ‘£ âˆˆ ğ‘‹ , we define a trace ğ‘¡ ğ‘£ âˆˆ Î£ ğœ” , by setting ğ‘¡ ğ‘£ (ğ‘›) {ğ‘ | ğ‘ƒ ğ‘ (ğ‘£, ğ‘– ğ‘› )} for every ğ‘› âˆˆ N, where we write ğ‘ƒ ğ‘ (ğ‘£, ğ‘– ğ‘› ) whenever this holds in the fixed firs-order model of Î˜. It is easy to see that ğ‘‡ {ğ‘¡ ğ‘£ | ğ‘£ âˆˆ ğ‘‹ } is a model of ğœ‘. This holds as Î˜ minims the quantification in ğœ‘, so whenever a quantifier is instantiated with ğ‘£ âˆˆ ğ‘‹ , we use trace ğ‘¡ ğ‘£ âˆˆ ğ‘‡ for the respective quantifier in ğœ‘. By construction of ğœŒ ğ‘ we ensure that A ğœ™ has an accepting run on all tuples of ğ‘› traces chosen in the quantifier prefix.</p><p>For the other direction, assume that ğœ‘ is satisfiable by trace set ğ‘‡ , which we choose as domain for sort Trace. For TimePoints, we choose the set of natural numbers with ğ‘– 0 = 0. We set ğ‘ƒ ğ‘ (ğ‘¡, ğ‘–) to true iff ğ‘ âˆˆ ğ‘¡ [ğ‘–]. For every assignment of ğ‘¡ 1 , . . . ğ‘¡ ğ‘› to the trace variables, we fix a run through A and set State ğ‘ (ğ‘¡ 1 , . . . , ğ‘¡ ğ‘› , ğ‘–) to true iff the the run is in state ğ‘ in step ğ‘–. The resulting structure satisfies ğœ™. â–¡ Lemma 3.10. The satisfiability problem is coRE-hard for specifications (âŠ¤, ğœ‘) where ğœ‘ is of the form âˆ€âˆƒ * . ( * ).</p><p>Proof. We reduce from the non-halting problem of deterministic Turing machines on the empty word, which is coRE complete. We assume, w.l.o.g., that the tape of the Turing machine is left-bounded and only takes a step to the left when it is possible. We encode the position of the head with a proposition â„. Throughout the construction, we maintain the invariant on all relevant traces that â„ is set exactly once on the trace. We cannot encode this property directly as it would require to nest multiple operators. We encode the alphabet Î“ and the set of states ğ‘„ with sets of atomic propositions, one for each symbol and enforce that in each step, exactly one for each set holds, for ğ‘† = Î“ or ğ‘† = ğ‘„:</p><p>We fix the current state to be the one that holds in the position of the head. Initially, the TM is in state ğ‘ 0 , the head at position 0, and the tape is blank. We require that the initial configuration is present in the set:</p><p>Now we encode the possible transitions with a âˆ€ğœ‹âˆƒğœ‹ â€² formula. We ensure that if the configuration encoded by ğœ‹ is a valid one (i.e., â„ only holds once), then the successor configuration is also valid. For correct transitions, all positions on ğœ‹ â€² , which are not left or right of the head in ğœ‹, must remain unchanged. Second, the head must move either left or right and the symbol and state propositions are only allowed to</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Probabilistic Hyperproperties with Nondeterminism</title>
		<author>
			<persName><forename type="first">Erika</forename><surname>ÃbrahÃ¡m</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ezio</forename><surname>Bartocci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Borzoo</forename><surname>Bonakdarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oyendrila</forename><surname>Dobe</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-59152-6_29</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-59152-6_29" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Automated Technology for Verification and Analysis, ATVA 2020</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">12302</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Defining Liveness</title>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Alpern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
		<idno type="DOI">10.1016/0020-0190(85)90056-0</idno>
		<ptr target="https://doi.org/10.1016/0020-0190(85)90056-0" />
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Really Temporal Logic</title>
		<author>
			<persName><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<idno type="DOI">10.1145/174644.174651</idno>
		<ptr target="https://doi.org/10.1145/174644.174651" />
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Flavors of Sequential Information Flow</title>
		<author>
			<persName><forename type="first">Ezio</forename><surname>Bartocci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>FerrÃ¨re</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">A</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dejan</forename><surname>Nickovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ana</forename><surname>Oliveira Da</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Costa</forename></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-94583-1_1</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-94583-1_1" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Verification, Model Checking, and Abstract Interpretation</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2022">2022</date>
			<biblScope unit="volume">13182</biblScope>
		</imprint>
	</monogr>
	<note>VMCAI 2022</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Temporal Logic for Asynchronous Hyperproperties</title>
		<author>
			<persName><forename type="first">Jan</forename><surname>Baumeister</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Norine</forename><surname>Coenen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Borzoo</forename><surname>Bonakdarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">CÃ©sar</forename><surname>SÃ¡nchez</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-81685-8_33</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-81685-8_33" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="volume">12759</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Temporal Logic for Strategic Hyperproperties</title>
		<author>
			<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CONCUR.2021.24</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CONCUR.2021.24" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 2021</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">203</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Prophecy Variables for Hyperproperty Verification</title>
		<author>
			<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Security Foundations Symposium</title>
		<meeting><address><addrLine>CSF</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Software Verification of Hyperproperties Beyond ğ‘˜-Safety</title>
		<author>
			<persName><forename type="first">Raven</forename><surname>Beutner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2022">2022. 2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">Borzoo</forename><surname>Bonakdarpour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarai</forename><surname>Sheinvald</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2201.01670[cs.FL</idno>
		<title level="m">Finite-Word Hyperlanguages</title>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reachability Analysis of Pushdown Automata: Application to Model-Checking</title>
		<author>
			<persName><forename type="first">Ahmed</forename><surname>Bouajjani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Esparza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Maler</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-63141-0_10</idno>
		<ptr target="https://doi.org/10.1007/3-540-63141-0_10" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 1997</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1243</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Asynchronous Extensions of HyperLTL</title>
		<author>
			<persName><forename type="first">Laura</forename><surname>Bozzelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adriano</forename><surname>Peron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">CÃ©sar</forename><surname>SÃ¡nchez</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS52264.2021.9470583</idno>
		<ptr target="https://doi.org/10.1109/LICS52264.2021.9470583" />
	</analytic>
	<monogr>
		<title level="m">Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2021</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Temporal Logics for Hyperproperties</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Masoud</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kristopher</forename><forename type="middle">K</forename><surname>Koleini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><forename type="middle">N</forename><surname>Micinski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">CÃ©sar</forename><surname>Rabe</surname></persName>
		</author>
		<author>
			<persName><surname>SÃ¡nchez</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-54792-8_15</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-54792-8_15" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Principles of Security and Trust</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>POST</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="volume">8414</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hyperproperties</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fred</forename><forename type="middle">B</forename><surname>Clarkson</surname></persName>
		</author>
		<author>
			<persName><surname>Schneider</surname></persName>
		</author>
		<idno type="DOI">10.1109/CSF.2008.7</idno>
		<ptr target="https://doi.org/10.1109/CSF.2008.7" />
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Security Foundations Symposium, CSF</title>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Hierarchy of Hyperlogics</title>
		<author>
			<persName><forename type="first">Norine</forename><surname>Coenen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jana</forename><surname>Hofmann</surname></persName>
		</author>
		<idno type="DOI">10.1109/LICS.2019.8785713</idno>
		<ptr target="https://doi.org/10.1109/LICS.2019.8785713" />
	</analytic>
	<monogr>
		<title level="m">Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2019</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Is Your Software on Dope? -Formal Analysis of Surreptitiously "enhanced" Programs</title>
		<author>
			<persName><forename type="first">Pedro</forename><forename type="middle">R</forename><surname>D'argenio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Barthe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Biewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Holger</forename><surname>Hermanns</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-54434-1_4</idno>
		<ptr target="https://doi.org/10.1007/978-3-662-54434-1_4" />
	</analytic>
	<monogr>
		<title level="m">European Symposium on Programming, ESOP 2017</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10201</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Probabilistic Hyperproperties of Markov Decision Processes</title>
		<author>
			<persName><forename type="first">Rayna</forename><surname>Dimitrova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hazem</forename><surname>Torfah</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-59152-6_27</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-59152-6_27" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Automated Technology for Verification and Analysis</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
	<note>ATVA</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Spot 2.0 -A Framework for LTL and ğœ”-Automata Manipulation</title>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Duret-Lutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandre</forename><surname>Lewkowicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Amaury</forename><surname>Fauchille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thibaud</forename><surname>Michaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Etienne</forename><surname>Renault</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Xu</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-46520-3_8</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-46520-3_8" />
	</analytic>
	<monogr>
		<title level="m">ternational Symposium on Automated Technology for Verification and Analysis</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="2016">2016. 9938</date>
			<biblScope unit="volume">2016</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Canonical Representations of k-Safety Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lennart</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hazem</forename><surname>Torfah</surname></persName>
		</author>
		<idno type="DOI">10.1109/CSF.2019.00009</idno>
		<ptr target="https://doi.org/10.1109/CSF.2019.00009" />
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Security Foundations Symposium</title>
		<meeting><address><addrLine>CSF</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Deciding Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CONCUR.2016.13</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CONCUR.2016.13" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 2016 (LIPIcs</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">59</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">MGHyper: Checking Satisfiability of HyperLTL Formulas Beyond the âˆƒ * âˆ€ * Fragment</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Hans</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-030-01090-4_31</idno>
		<ptr target="https://doi.org/10.1007/978-3-030-01090-4_31" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Automated Technology for Verification and Analysis</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">2018</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Model Checking Quantitative Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hazem</forename><surname>Torfah</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-96145-3_8</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-96145-3_8" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018">2018. 2018</date>
			<biblScope unit="volume">10981</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The First-Order Logic of Hyperproperties</title>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.STACS.2017.30</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.STACS.2017.30" />
	</analytic>
	<monogr>
		<title level="m">Symposium on Theoretical Aspects of Computer Science, STACS 2017 (LIPIcs</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">66</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Propositional Dynamic Logic of Regular Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">E</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><surname>Ladner</surname></persName>
		</author>
		<idno type="DOI">10.1016/0022-0000(79)90046-1</idno>
		<ptr target="https://doi.org/10.1016/0022-0000(79)90046-1" />
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">Marie</forename><surname>Fortin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louwe</forename><forename type="middle">B</forename><surname>Kuijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Totzke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<title level="m">HyperLTL Satisfiability is Î£ 1 1 -complete, HyperCTL* Satisfiability is Î£ 2</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">1 -complete</title>
		<idno type="DOI">10.4230/LIPIcs.MFCS.2021.47</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.MFCS.2021.47" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Mathematical Foundations of Computer Science, MFCS 2021</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<biblScope unit="volume">202</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Ãœber die vollstÃ¤ndigkeit des logikkalkÃ¼ls</title>
		<author>
			<persName><forename type="first">Kurt</forename><surname>GÃ¶del</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1929">1929</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Propositional Dynamic Logic for Hyperproperties</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Oliver Gutsfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>MÃ¼ller-Olm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Ohrem</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CONCUR.2020.50</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CONCUR.2020.50" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory, CONCUR 2020</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">171</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Automata and fixpoints for asynchronous hyperproperties</title>
		<author>
			<persName><forename type="first">Jens</forename><surname>Oliver Gutsfeld</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>MÃ¼ller-Olm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Ohrem</surname></persName>
		</author>
		<idno type="DOI">10.1145/3434319</idno>
		<ptr target="https://doi.org/10.1145/3434319" />
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Program. Lang</title>
		<meeting>ACM Program. Lang</meeting>
		<imprint>
			<publisher>POPL</publisher>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Reachability in Succinct and Parametric One-Counter Automata</title>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Haase</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Kreutzer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">JoÃ«l</forename><surname>Ouaknine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Worrell</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-04081-8_25</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-04081-8_25" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Concurrency Theory</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="volume">5710</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Team Semantics for the Specification and Verification of Hyperproperties</title>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Krebs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arne</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonni</forename><surname>Virtema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.MFCS.2018.10</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.MFCS.2018.10" />
	</analytic>
	<monogr>
		<title level="m">International Symposium on Mathematical Foundations of Computer Science, MFCS 2018</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">117</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Model Checking of Safety Properties</title>
		<author>
			<persName><forename type="first">Orna</forename><surname>Kupferman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-48683-6_17</idno>
		<ptr target="https://doi.org/10.1007/3-540-48683-6_17" />
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<meeting><address><addrLine>CAV</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999">1999. 1999</date>
			<biblScope unit="volume">1633</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Complete Problems of Propositional Logic for the Exponential Hierarchy</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>LÃ¼ck</surname></persName>
		</author>
		<idno>CoRR abs/1602.03050</idno>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The Keys to Decidable HyperLTL Satisfiability: Small Models or Very Simple Formulas</title>
		<author>
			<persName><forename type="first">Corto</forename><surname>Mascle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Zimmermann</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.CSL.2020.29</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.CSL.2020.29" />
	</analytic>
	<monogr>
		<title level="m">EACSL Annual Conference on Computer Science Logic</title>
		<title level="s">Schloss Dagstuhl</title>
		<meeting><address><addrLine>CSL</addrLine></address></meeting>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="volume">152</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Noninterference and the composability of security properties</title>
		<author>
			<persName><forename type="first">Daryl</forename><surname>Mccullough</surname></persName>
		</author>
		<idno type="DOI">10.1109/SECPRI.1988.8110</idno>
		<ptr target="https://doi.org/10.1109/SECPRI.1988.8110" />
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<meeting><address><addrLine>Oakland, SP</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988">1988. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Computation</title>
		<author>
			<persName><forename type="first">Marvin</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minsky</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1967">1967</date>
			<publisher>Prentice-Hall Englewood Cliffs</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<author>
			<persName><forename type="first">Markus</forename><forename type="middle">N</forename><surname>Rabe</surname></persName>
		</author>
		<title level="m">A temporal logic approach to Information-flow control</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
		<respStmt>
			<orgName>Saarland University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph. D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Handbook of Automated Reasoning</title>
		<editor>John Alan Robinson and Andrei Voronkov</editor>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Theory of recursive functions and effective computability</title>
		<author>
			<persName><forename type="first">Hartley</forename><surname>Rogers</surname><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<publisher>MIT press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Safety, liveness and fairness in temporal logic</title>
		<author>
			<persName><forename type="first">Sistla</forename><surname>Prasad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Formal Aspects of Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">5</biblScope>
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The complexity of propositional linear temporal logics</title>
		<author>
			<persName><forename type="first">Prasad</forename><surname>Sistla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Edmund</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The Polynomial-Time Hierarchy</title>
		<author>
			<persName><forename type="first">Larry</forename><forename type="middle">J</forename><surname>Stockmeyer</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(76)90061-X</idno>
		<ptr target="https://doi.org/10.1016/0304-3975(76)90061-X" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1976">1976. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Reasoning About Infinite Computations</title>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Wolper</surname></persName>
		</author>
		<idno type="DOI">10.1006/inco.1994.1092</idno>
		<ptr target="https://doi.org/10.1006/inco.1994.1092" />
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Linear-Time Temporal Logic with Team Semantics: Expressivity and Complexity</title>
		<author>
			<persName><forename type="first">Jonni</forename><surname>Virtema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jana</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Finkbeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juha</forename><surname>Kontinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fan</forename><surname>Yang</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.FSTTCS.2021.52</idno>
		<ptr target="https://doi.org/10.4230/LIPIcs.FSTTCS.2021.52" />
	</analytic>
	<monogr>
		<title level="m">IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2021</title>
		<title level="s">Schloss Dagstuhl</title>
		<imprint>
			<publisher>LIPIcs</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="volume">213</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>