<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scrutable robot actions using a hierarchical ontological model</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Martin</forename><surname>Jedwabny</surname></persName>
							<email>martin.jedwabny@lirmm.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pierre</forename><surname>Bisquert</surname></persName>
							<email>pierre.bisquert@inrae.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">IATE</orgName>
								<orgName type="institution" key="instit1">INRAE</orgName>
								<orgName type="institution" key="instit2">Institut Agro</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Madalina</forename><surname>Croitoru</surname></persName>
							<email>madalina.croitoru@lirmm.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Univ Montpellier</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Scrutable robot actions using a hierarchical ontological model</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">CE0F18C5B0F4B7ADC9FB6B864474716A</idno>
					<idno type="DOI">10.1007/978-3-031-16663-1_2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2024-04-12T14:47+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We place ourselves in the context of representing knowledge inside the cognitive model of a robot that needs to reason about its actions. We propose a new ontological transformation system able to model different levels of knowledge granularity. This model will allow to unfold the sequences of actions the robot performs for better scrutability.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In this paper, we present a formal approach to knowledge representation and reasoning in the setting of a robot making decisions about which action to perform. We propose a hierarchical structure to examine information about actions in depth, by unfolding actions into several layers of complexity. The intuition of this work relies on ideas from episodic memory theory <ref type="bibr" target="#b0">[1]</ref>, that organizes information in layers of detail retrievable at the right time, in the right granularity.</p><p>We propose a hierarchical information structure composed by two combinatorial structures that can be applied in an Artificial Intelligence (AI) planning <ref type="bibr" target="#b1">[2]</ref> setting: (i) an ontology of fluent and action symbols, and (ii) a hierarchical structure encoding preconditions and effects for the various actions.</p><p>The proposed layered catalog of actions is influenced by work on conceptual graph-based ontological knowledge representation <ref type="bibr" target="#b2">[3]</ref>. This work can be seen as a continuation of previous work on hierarchical conceptual graphs <ref type="bibr" target="#b3">[4]</ref>, with a focus on reasoning about action.</p><p>The salient points of the paper are the following:</p><p>• A knowledge representation model relevant for ontologies of fluents and actions, and</p><p>• A formal method for translating between the different layers of details corresponding to these ontologies. After providing a motivating example in Section 2, we recall in Section 3 the necessary notions for graphical knowledge representation. In Section 4 we introduce the structures that allow to represent the robot's knowledge about the world and its possible actions. Section 5 analyses the related work and discusses ways in which our framework can be used to make a planner more scrutable for an user. Finally, we will conclude in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivating Example</head><p>Consider a situation in which a robot has to board an elevator in a building to get from floor f A to f B . An action model of the situation might represent this as a single action U seElevator that, upon execution, takes a situation in which the robot is in f A and transforms it in such a way the robot goes to f B . Modeling the action of using the elevator as a single atomic step comes with the immediate advantage of compactness.</p><p>However, in certain cases the elevator could malfunction due to electricity shortages, a certain button not working, or any other internal or external factor that disturbs its normal functioning. In this case, the robot could perceive that the action U seElevator is no longer producing its intended result, but would have a hard time realizing the cause without modeling the state of the electricity in the building. On the other hand, keeping track of this property might be irrelevant to actions other than U seElevator and make it harder to a user to understand the model and sequence of actions chosen by the robot if many other properties are introduced.</p><p>Upon closer inspection, we realize that the action U seElevator depends on many factors like the state of electricity, the buttons used to operate the elevator and the electronic circuit that receives the button's signal. Furthermore, the action can be broken down to several steps, as depicted in Figure <ref type="figure" target="#fig_0">1</ref>: (i) CallElevator using button b A from whichever floor it is currently at to f A , and (ii) T akeElevator by selecting the destination floor f B with selector button b B . Then, (i) can also be separated into two actions: P ressCallButton, and BoardElevator. In the same way, these actions can be iteratively broken down into several layers of increasing complexity.</p><p>Nevertheless, from a user point of view, all of these factors and step breakdown could be irrelevant in correct operation circumstances. Both for a monitoring user and a automatic planning robot, it can be useful to take these multiple levels of model complexity into account and use them only when they are needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Background notions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Bipartite graphs</head><formula xml:id="formula_0">A bipartite graph is a graph G = (V G , E G ) with the nodes set V G = V F ∪ V A , where V F and V A are finite disjoint sets, and each edge e ∈ E G is a two-element set e = {v F , v A }, where v F ∈ V F and v A ∈ V A . Usually, a bipartite graph G is denoted as G = (V F , V A , E G ).</formula><p>We call G ∅ the empty bipartite graph without nodes and edges.</p><p>We make the informal observation that, later on in the paper, the node set V F and V A will be used to represent, respectively, the uninstanced fluent (i.e., the description of a scene) and action symbols of the planning setting. Edges in the bipartite graph will thus capture the preconditions and effects, in terms of fluents that compose an action.</p><p>Let</p><formula xml:id="formula_1">G = (V F , V A , E G ) be a bipartite graph. The number of edges incident to a node v ∈ V (G) is the degree, d G (v), of the node v. If, for each v A ∈ V A there is a linear order e 1 = {v A , v 1 }, . . . , e k = {v A , v k } on the set of edges incident to v A (where k = d g (v)</formula><p>), then G is called an ordered bipartite graph. A simple way to express that G is ordered is to provide a labelling l : E G → {1, . . . , |V F |} with l({v A , w}) the index of the edge {v A , w} in the above ordering of the edges incident in G to v A . l is called a order labelling of the edges of G. We denote an ordered bipartite graph by G = (V F , V A , E G , l). It will be useful for the next sections to note that the labelling l can be generalized into a collection of labellings of different kinds by extending its definition to l : E G → 2 K×{1,...,|V F |} -{∅} with K a predefined set of kinds, while still being trivial to construct an overall labelling l ′ :</p><formula xml:id="formula_2">E G → {1, . . . , |V F |} from it. For a vertex v ∈ V F ∪ V A , the symbol N G (v) denotes its neighbors set, i.e. N G (v) = {w ∈ V F ∪ V A |{v, w} ∈ E G }. Similarly, if A ⊆ V A ∪ V F , the set of its neighbors is N G (A) = ∪ v∈A N G (v) -A.</formula><p>If G is an ordered bipartite graph, then for each r ∈ V A , the symbol N i G (r) denotes the i-th neighbor of r, i.e. v = N i G (r) if and only if {r, v} ∈ E G and l({r, v}) = i. Throughout this paper we use a particular type of subgraph of a bipartite graph:</p><formula xml:id="formula_3">G 1 = (V 1 F , V 1 A , E 1 G ) is a subgraph of G = (V F , V A , E G ) if V 1 F ⊆ V F , V 1 A ⊆ V A , N G (V 1 A ) ⊆ V 1 F and E 1 G = { {v, w} ∈ E G |v ∈ V 1 F , w ∈ V 1 A }.</formula><p>In other words, we require that the (ordered) set of all edges incident in G to a vertex from V 1</p><p>A must appear in G 1 . Therefore, a subgraph is completely specified by its vertex set. In particular, if A ⊆ V F :</p><formula xml:id="formula_4">• The subgraph spanned by A in G, denoted as ⌈A⌉ G , has V F (⌈A⌉ G ) = A ∪ N G (N G (A)) and V A (⌈A⌉ G ) = N G (A).</formula><p>• The subgraph generated by A in G, denoted as ⌊A⌋ G , has</p><formula xml:id="formula_5">V F (⌊A⌋ G ) = A and V A (⌊A⌋ G ) = {v ∈ N G (A)|N G (v) ⊆ A} . • For A ⊆ V A , the subgraph induced by A in G, denoted [A] G , has V F ([A] G ) = N G (A) and V A ([A] G ) = A .</formula><p>Now that we can represent the links between actions and fluents as a graph, we will see in the following section how we can define the types of their arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Planning</head><p>We will use an abstract representation inspired by the one in <ref type="bibr" target="#b4">[5]</ref> to model belief state planning. This representation allows to model non-deterministic/belief states and deterministic actions with conditional effects, i.e., conformant planning.</p><p>It is assumed that one is given a set of fluents F P and actions A P , denoting the properties of a problem and the actions the agent can perform, respectively. A literal is either f ∈ F P a fluent, or ¬f its negation. A state s ⊆ F P is a set of fluents denoting what properties hold in a state. This takes into account the closed-world assumption, in that all fluents that are not in a state are assumed to be false. A belief state B ⊆ 2 F P is a set of states.</p><p>An action a ∈ A P is of the form a = (pre(a), ef f (a)), where pre(a) is a set of literals over F P called the preconditions.</p><formula xml:id="formula_6">Then, ef f (a) = {ef f 1 (a), . . . , ef f n (a)} is a set of effects of the form ef f i (a) = cond i (a) → post i (a)</formula><p>, where cond i (a) and post i (a) are sets of literals called condition and postcondition, respectively. We say that a set of literals L over F P is compatible with a state s ⊆ F P , denoted compat(L, s), when ∀f ∈</p><formula xml:id="formula_7">F P it holds that f ∈ L ⇒ f ∈ s and ¬f ∈ L ⇒ f ̸ ∈ s.</formula><p>An action a ∈ A P is applicable in state s ⊆ F P , denoted applicable(a, s), if and only if compat(pre(a), s) holds. Similarly, given a belief state B ⊆ 2 F P , applicable(a, B) holds if and only if ∀s ∈ B it is the case that applicable(a, s) is true.</p><p>If an action a is applicable in state s, the successor state, i.e, the state that results from performing a in s, is defined as succ(a, s) = (s -{f ∈</p><formula xml:id="formula_8">F P : ∃i s.t. ¬f ∈ post i (a) and compat(cond i (a), s)}) ∪ {f ∈ F P : ∃i s.t. f ∈ post i (a)</formula><p>and compat(cond i (a), s)}. The successor to a belief state B ⊆ 2 F P is defined as succ(a, B) = s∈B succ(a, s).</p><p>A sequence of actions π = [a 0 , a 1 , . . . , a n ] where n ∈ N 0 and a i ∈ A P is applicable to belief state B ⊆ 2 F P , denoted applicable(π, B) if and only if either n = 0, or otherwise applicable(a 0 , B) and applicable([a 1 , . . . , a n ], succ(a 0 , B))</p><formula xml:id="formula_9">hold. If applicable(π, B) does indeed hold, then succ(π, B) = B if n = 0, otherwise succ(π, B) = succ([a 1 , . . . , a n ], succ(a 0 , B)).</formula><p>A planning problem is a tuple P = (F P , A P , I P , G P ):</p><formula xml:id="formula_10">• F P is a set of fluents,</formula><p>• A P is a set of actions over F P ,</p><p>• I P ⊆ 2 F P is a non-empty set of states called the initial belief state, and</p><p>• G P ⊆ 2 F P is a non-empty set of states called the goal.</p><p>A sequence π of actions is a strong plan, i.e., a solution that always reaches the goal, when succ(π, I P ) ⊆ G P . Less restrictive, π is a weak plan, i.e., a sequence that sometimes reaches the goal, when ∃s ∈ succ(π, I P ) such that s ∈ G P .</p><p>We refer the reader to <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7]</ref> for results on the complexity and heuristics methods to generate strong and weak plans for a planning model such as the one described here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Layered Catalog Graphs</head><p>Influenced by episodic memory theory <ref type="bibr" target="#b0">[1]</ref>, the knowledge of an agent is defined by two combinatorial structures.</p><p>• On one hand, we will consider an ontology of fluent and action symbols.</p><p>The fluent symbols (represented by unary concepts) are organized in a type hierarchy. Similarly, the action symbols, represented by binary or nary relations are also organized in a relation hierarchy. The action symbols have a signature of their arguments, represented as fluent concept types.</p><p>• On the other hand, the agent will dispose of a hierarchical structure encoding preconditions and effects for various actions.</p><p>We only consider unary fluents for simplification purposes, however it is immediate to see how we could extend this work in order to consider fluents of any arity.</p><p>Let us note that the following definitions 1-7 are based on previous work on conceptual graphs <ref type="bibr" target="#b3">[4]</ref>, although adapted to represent fluents and actions instead of abstract concepts. Moreover, the framework presented in this paper could not be modeled as-is with the mentioned literature due to the way in which multiple fluents can relate to actions as preconditions and effects at the same time.</p><p>The ontology is defined as follows:</p><p>Definition 1. An ontology is a 4-tuple S = (T F , T A , I, * ) where:</p><p>• T F is a finite partially ordered set (poset) (T F , ≤) of fluent types, defining a type hierarchy which has a greatest element ⊤ C , namely the universal type. In this specialization hierarchy, ∀x, y ∈ T F the symbolism x ≤ y is used to denote that x is a subtype of y.</p><p>• T A is a finite set of action types partitioned into k posets</p><formula xml:id="formula_11">(T i A , ≤) i=1,k of relation types of arity i (1 ≤ i ≤ k),</formula><p>where k is the maximum arity of an action type in T A . Moreover, each action type of arity i, r ∈ T i A , has an associated signature σ(r) ∈ T F × . . . × T F i times , which specifies the maximum fluent type of each of its arguments. This means that if we use r(x 1 , . . . , x i ), then x j is a fluent with type(x j ) ≤ σ(r) j (1 ≤ j ≤ i), where type is the function that returns the type of a fluent. The partial orders on relation types of the same arity must be signature-compatible, i.e., it must be such that</p><formula xml:id="formula_12">∀r 1 , r 2 ∈ T i A r 1 ≤ r 2 ⇒ σ(r 1 ) ≤ σ(r 2 ).</formula><p>• I is a countable set of individual markers, used represent to given constants.</p><p>• * is the generic marker to denote an unspecified fluent (with a known type).</p><p>• The sets T F , T A , I and { * } are mutually disjoint and I ∪ { * } is partially ordered by x ≤ y if and only if x = y or y = * , for any given x, y ∈ I ∪{ * }.</p><p>It is worth to notice that the generic marker ' * ' will be used in this framework to represent variables/un-instanced concepts in the arguments of fluents and actions later.</p><p>The following depicts an ontology for the situation described before:</p><p>Example 1 (Elevator continued). We specify the types of fluents and actions as:</p><p>• T F = {Button, F loor, ⊤ C }, the fluent types, where Button, F loor ≤ ⊤ C are the only subtypes,</p><p>• T A = {U seElevator T }, the action types, where σ(U seElevator T ) = (Button, Button, F loor, F loor).</p><formula xml:id="formula_13">• I = {b A , b B , f A , f B }, individuals.</formula><p>As we can see, the ontology provides a support of types for fluents and actions.</p><p>In this case, we represent a basic action type for pressing the elevator button that has a signature composed of elements of type Button and of type F loor, corresponding to the arguments of such an action.</p><p>For the representation of the hierarchical knowledge of the agent we define a simple graphical catalog of actions (SC) with their preconditions and effects. The simple graph catalog is rendered hierarchical by a transformation called transitional description defined further in the paper. The result will be a layered graphical catalog of actions (LC) that the robot can access according to the need at hand.</p><p>A SC provides a semantic set of pointers to the ontology of fluents and action symbols.</p><p>Definition 2. A simple graphical catalog of actions is a 3-tuple SC = [S, G, λ], where:</p><formula xml:id="formula_14">• S = (T F , T A , I, * ) is the ontological support, • G = (V F , V A , E G , l</formula><p>) is an ordered bipartite graph, where V F are called fluent symbols and V A action symbols,</p><p>• l is a labelling that maps each edge {v</p><formula xml:id="formula_15">A , v F } ∈ E G to a non-empty set of pairs (k, i) ∈ l({v A , v F }) where i ∈ {1, . . . , d G (v A )}</formula><p>and k is either pre + , pre -, cond + j , cond - j , post + j , or post - j , with j ∈ N &gt;0 , denoting whether v F is a positive or negative literal in the precondition, jth effect condition, or jth effect postcondition of v A .</p><p>• λ is a labelling of the nodes of G with elements from the support S:</p><formula xml:id="formula_16">∀r ∈ V A , λ(r) ∈ T n A A such that n A ∈ N &gt;0 ; ∀c ∈ V F , λ(c) ∈ T F × I ∪ { * } such that if c = N i G (r), λ(r) = t r and λ(c) = (t c , ref c ), then t c ≤ σ(t r ) i .</formula><p>Intuitively, λ allows to make the link between nodes in G that represent fluent and action symbols, and their respective types defined in S. Moreover, the labelling allows to denote that a fluent is a precondition and/or effect of an action. Let us depict the meaning of λ and l with the following example. • V A = {U seElevator}, the set of action symbols, where λ(U seElevator) = U seElevator T .</p><p>• E G = {{U seElevator, X} : X ∈ {InF loorElevator, InF loorAgent, CanU seCallButton, CanU seSelectButton}}, • l the labelling assigns l({U seElevator, CanU seCallButton}) = {(cond + 1 , 1)}, l({U seElevator, CanU seSelectButton}) = {(cond + 1 , 2)}, l({U seElevator, InF loorAgent}) = {(pre + , 3), (post + 1 , 4), (post - 1 , 3), l({U seElevator, InF loorElevator}) = (post + 1 , 4). We can see the SC [S, G, λ] in Figure <ref type="figure" target="#fig_1">2</ref>. The fluent symbols in V F are mapped by λ to the generic marker '*' to denote that they refer to a variable and not a specific constant. In particular, the symbol InF loorElevator represents the current floor of the elevator, InF loorAgent the floor of the agent, CanU seCallButton whether the agent can use the button to call the elevator, and CanU seSelectButton the same for the button inside the elevator. The action symbol U seElevator has type U seElevator T with signature σ(U seElevator) = (Button, Button, F loor, F loor). This will be used to characterize the type of the arguments of the (instanced) action. Then, a label l({U seElevator, v F }) = (k, i) denotes that the ith argument of U seElevator corresponds to the (unique) argument of the fluent v F , while k represents the role of the fluent in the action. As we will see later, such an action will get translated in our planning framework to something similar to an action U seElevator(x, y, z, w) = ({InF loorAgent(z)}, {cond 1 → ef f 1 }), where cond 1 = {CanU seCallButton(x), CanU seSelectButton(y)} and ef f 1 = {InF loorAgent(w), ¬InF loorAgent(z), InF loorElevator(w)}. • D ⊆ V F is a set of complex fluent symbols, i.e: a subset of the original fluents symbols in V F that can be expanded into a more complex representation.</p><formula xml:id="formula_17">InFloorElevator InFloorAgent CanUseCallButton CanUseSelectButton UseElevator {(cond + 1 , 2)} {(cond + 1 , 1)} {post + 1 , 4)} {(pre + , 3), (post + 1 , 4), (post - 1 , 3)}</formula><formula xml:id="formula_18">• For each d ∈ D ∪ N G (D) G.d is a bipartite graph. • If d ∈ D then G.d is the non-empty (G.d ̸ = G ∅ ) description of the complex fluent symbol d. Distinct complex fluent symbols d, d ′ ∈ D have disjoint descriptions G.d ∩ G.d ′ = G ∅ . • If d ∈ N G (D) then G.d ̸ = G ∅ , N G (d) -D ⊆ V F (G.d) and V F (G.d) ∩ V F (G.d ′ ) ̸ = ∅ if and only if d ′ ∈ N G (d) ∩ D. Note that (G.d) d∈D∪N G (D)</formula><p>is the collection of bipartite graphs for each node d of the original bipartite graph that we want to expand. Moreover, when one expands a fluent symbol, so do the action symbols it is related to. Conversely, when an action symbol is expanded, the nodes in its expanded graph are the same as those in the expansion of its related complex fluent symbols, or its non-complex neighbors.</p><p>Let us illustrate this definition as follows.</p><p>Example 3 (Elevator continued). As we explained in Figure <ref type="figure" target="#fig_0">1</ref>, we would like to be able to separate the action symbol U seElevator into two: CallElevator and T akeElevator. We can do this by using a transitional description T D = (D, (G.d) d∈D∪N G (D) ) as depicted in Figure <ref type="figure" target="#fig_5">3</ref>, where D = {CanU seCallButton, CanU seSelectButton}. Here, we see three SCs, namely 'G.CanUseCallButton', 'G.CanUseSelectButton' and 'G.CanUseElevator '. While the first two represent the corresponding SCs obtained by augmenting the granularity of those fluents, the third one showcases the augmented version of the action 'UseElevator ', whose new level of granularity is obtained using the updated SCs of its fluents, all of which is generated with the transitional description T D.</p><p>Finally let us now define how to apply a transitional description to a simple catalog to expand the representation.  In the case of the previous example, due to the fact that there is only one action symbol in the catalog [S, G, λ] defined previously, the bipartite graphs T D(G) and G.U seElevator are identical.</p><p>The following property for bipartite graphs follows.</p><formula xml:id="formula_19">Proposition 1. If G = (V F , V A , E G )</formula><p>is a bipartite graph and T D is a transitional description associated to G, then the graph T D(G) obtained from G by applying T D is also a bipartite graph.</p><p>Proof sketch. We follow the construction given in the previous definition regarding the application of a transitional description T D to a bipartite graph G.</p><p>It is immediate to see that the starting graph in (1) ⌊V F -D⌋ G is a bipartite one because G was bipartite. Then for point <ref type="bibr" target="#b1">(2)</ref>, each expanded graph G.d is a bipartite one by definition and by applying a disjoint union with another bipartite graph, the property is preserved. Finally, point (3) only links fluent nodes to actions nodes, which also preserves the bipartite property. This proposition ensures that the graph obtained by applying the transitional description can itself be expanded using another.</p><p>So far, our definition of transitional description only accounts for nodes and actions, but not that their expansions match their types, when considering ontological supports. The following definition extends the notion for a simple graphical catalog of actions to account for the types of fluents and actions. Definition 5. Let SC = [S, G, λ] be a graphical catalog of actions, where G = (V F , V A , E G , l). A transitional description associated to SC is a pair T D = (D, (SC.d) d∈D∪N G (D) ) where:</p><formula xml:id="formula_20">• D ⊆ V F is a set of complex fluent symbols. • For each d ∈ D ∪ N G (D), SC.d = [S.d, G.d, λ.d] is a SC. • If d ∈ D, then G.d is the non-empty (G.d ̸ = G ∅ ) description of the complex fluent symbol d. Distinct complex fluent symbols d, d ′ ∈ D have disjoint descriptions G.d ∩ G.d ′ = G ∅ . Moreover, for all v ∈ V F (G.d), it holds that λ(d) = λ.d(v). • If d ∈ N G (D), then G.d ̸ = G ∅ , N G (d) -D ⊆ V F (G.d), and V F (G.d) ∩ V F (G.d ′ ) ̸ = ∅ for each d ′ ∈ N G (d) ∩ D. Moreover, S.d ⊇ S ∪ d ′ ∈N G (d) S.d ′ , λ.d(v) = λ(v) for v ∈ N G (d) -D and λ.d(v) = λ.d ′ (v) for v ∈ V F (G.d) ∩ V F (G.d ′ ). Finally, for each d ′ ∈ V A (G.d), it holds that λ(d) = λ.d(d ′ ),</formula><p>i.e., when decomposing an action through a transitional description, the corresponding actions preserve its type.</p><p>Note that we disallow G.d = G ∅ , as this would erase the node when applying a transitional description. In the simplest case, the new graph can only be composed of the original node itself, thus not producing any changes.</p><p>Analogously to the extension of transitional descriptions from bipartite graphs to SCs, the following definition extends the application of a T D, to take into account the types. Note that the last condition in Definition 5 (concerning the preservation of types for the expanded action nodes) is the one that ensures that when expanding the nodes, the types coming from the ontologies will be preserved when applying a transitional description.</p><p>Moreover, using Proposition 1 we can verify that T D(SC) is a simple graphical catalog of actions. This means that we can nest the application of transitional description to produce several expanded catalogs of actions of increasing complexity, which we define as follows: Definition 7. Let n be a non-negative integer. A layered catalog graph (LC) of depth n is a family LC = SC 0 , T D 0 , . . . , T D n-1 where:</p><formula xml:id="formula_21">• SC 0 = [S 0 , (V 0 F , V 0 A , E 0 ), λ 0 )] is a SC,</formula><p>• T D 0 is a transitional description associated to SC 0 ,</p><formula xml:id="formula_22">• for each k, 1 ≤ k ≤ n -1, T D k is a transitional description associated to SC k = [S k , (V k F , V k A , E k ), λ k )] = T D k-1 (SC k-1 ).</formula><p>SC 0 is the base simple graphical catalog of actions of the layered graph LC and SC k = T D k-1 (SC k-1 ) (k = 1, . . . , n), are its layers.</p><p>In other words, if we have an interconnected world described by a SC and if we can provide details about both some complex fluent and action symbols, then we can construct a second level of knowledge about this world, describing these new details as graphs and applying the corresponding substitutions. This process can be similarly performed with the last constructed level, thus obtaining a coherent set of layered representations of the initial world.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related work</head><p>As we mentioned in the introduction, the motivation behind our work was to provide a mechanism that improved the scrutability of a planner for a human user. Unfolding representations between multiple granularity levels has been studied in the context of AI planning optimization <ref type="bibr" target="#b7">[8]</ref> and generic conceptual graphs <ref type="bibr" target="#b3">[4]</ref>, but not for scrutability and neither in such a way that fluents and actions can be unfolded with the support of an ontology. In recent years, the AI planning community has taken interest in what in known as explainable AI planning (XAIP) <ref type="bibr" target="#b8">[9]</ref>. Notably, this branch has proposed several critical questions for AI planners that can be of interest to human users: (i) why did you do that?, (ii) why didn't you do something else?, (iii) why is what you propose to do more efficient/safe/cheap than something else?, (iv) why can't you do that?, (v) why do I need to replan at this point? and (vi) why do I not need to replan at this point?. With that in mind, our framework could reinforce other techniques <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> to provide an appropriate level of detail for the generated plan generated tailored to a specific kind of user. At the same time, it could be applied in cases where no plan can be generated by using counterfactuals <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b12">13]</ref>, so that the planner can iteratively inform the reason behind its failures.</p><p>Moreover, as far as we know, there is no work coupling structured hierarchical knowledge of fluents and actions in such a way that the robot can expand sets of fluents to assess which action could be applied using a general abstract graph-based ontology. Although our work extends previous literature for conceptual graphs <ref type="bibr" target="#b3">[4]</ref>, the mentioned literature would not allow to model action preconditions and effects, due to the fact that the same fluent node cannot be attached multiple times as one or the other, to the same action.</p><p>With regards to classical AI planning, our framework can be related to the concept of 'macro operators' <ref type="bibr" target="#b13">[14]</ref>. Macro operators were developed as an optimization technique for PDDL planners, which consists in learning operators (actions) composed of several others before computing the plan for a complex task, based on simpler ones. While this approach indeed allows to couple actions together, this does not allow for several fluent granularity levels as we proposed here.</p><p>That being said, the proposed approach is related to the field of hierarchical task networks (HTN) <ref type="bibr" target="#b14">[15]</ref> where dependencies among actions can be structured in the form of hierarchies linking actions to higher level compound ones. However, this framework does not allow for the structured representation of knowledge we provide. Some works have proposed ontologies for HTNs <ref type="bibr" target="#b15">[16]</ref> domains, but not with a focus on the transformation from one level of detail to another on the fly as we do here. Similar to the macro operators, their work does not allow for multiple fluent granularity levels and neither a mechanism to unfold them.</p><p>Perhaps closer to our work, hierarchical models for STRIPS-like planners have been studied <ref type="bibr" target="#b7">[8]</ref> as a method to improve the efficiency of plan generation by mapping tasks to different granularity levels. In contrast to out framework, this avenue of work focused on mapping fluent parameters, instead of fluent and action symbols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, we introduced a graph-based hierarchical model of knowledge about actions and fluents that allows to represent structured knowledge about the world under the form of increasingly detailed levels. We developed a graphbased framework supported by an ontology, called layered catalog of actions, to characterize an agent's actions. We showed how the fluents and actions of the framework can be specified using this catalog. Our work not only formalized this model, but also provided a method to adjust the level of detail of the fluents and actions using the concept of transitional description.</p><p>The proposed approach that joins structured and layered knowledge of actions opens different avenues of research for future work. In particular, by adapting the level of granularity, an agent could adapt to the level of understanding of the user. This could pave the way for robot-user explanation by task measurement, i.e., testing if the user can perform a task where multiple actions have to be performed after being exposed to an explanation by the robot of a similar problem.</p><p>Finally, because our framework relies on an ontology to represent the fluents of states and considers belief states, it could potentially allow for plausible reasoning <ref type="bibr" target="#b16">[17]</ref> through the type of individuals. More precisely, when the properties of a certain individual are not fully known, it could be represented by using different beliefs about the types of that individual and then implementing plausible reasoning through the planner. In future work, this approach could also be extended to other kind of uncertainty, such as partial observability planning <ref type="bibr" target="#b17">[18]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Elevator example illustration</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Example 2 (</head><label>2</label><figDesc>Elevator continued). Having defined an ontological support S = (T F , T A , I, * ), we can instantiate a simple graphical catalog of actions SC = [S, G, λ] by specifying G = (V F , V A , E G , l) and λ as follows: • V F = {InF loorElevator, InF loorAgent, CanU seCallButton, CanU seSelectButton}, the set of fluent symbols, where λ(InF loorElevator) = ( * , F loor), λ(InF loorAgent) = ( * , F loor), λ(CanU seCallButton) = ( * , Button), λ(CanU seSelectButton) = ( * , Button).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Bipartite graph for the action symbol U seElevator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Transitional descriptions will allow for the definition of layered catalogs, which represent the different levels of complexity in which we can break down the model. Briefly, they represent a single step of expansion of action and fluents into a new layer of complexity. A transitional description T D contains a collection of bipartite graphs for each node of the original bipartite graph G that one wants to expand, which represent the new added knowledge. Let us now define what is a transitional description for a graph. Definition 3. Let G = (V F , V A , E G ) be a bipartite graph. A transitional description associated to G is a pair T D = (D, (G.d) d∈D∪N G (D) ) where</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 4 .</head><label>4</label><figDesc>If T D = (D, (G.d) d∈D∪N G (D)) is a transitional description associated to the bipartite graph G = (V F , V A , E G ), then the graph T D(G) obtained from G by applying T D is constructed as follows:1. Take a new copy of ⌊V F -D⌋ G .2. For each d ∈ D, take a new copy of the graph G.d and make the disjoint union of it with the current graph constructed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Transitional description for the elevator example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Definition 6 .</head><label>6</label><figDesc>If T D = (D, (SC.d) d∈D∪N G (D) ) is a transitional description associated to SC = [S, G, λ], then the simple graphical catalog of actions T D(SC) obtained from SC by applying T D is T D(SC) = [S ′ , T D(G), λ ′ ]. Here, T D(G) is the bipartite graph T D(G) obtained from G by applying T D, S ′ = ∪ d∈D∪N G (D) S.d and λ ′ is any legal labelling function defined on V (T D(G)) which preserves the labels given to the vertices in V (G) and V (G.d) for all v ∈ D ∪ N G (D).</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G.CanUseCallButton</head><note type="other">HasElectricityCallButton</note></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The concept of episodic memory</title>
		<author>
			<persName><forename type="first">Alan</forename><surname>Baddeley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philosophical Transactions of the Royal Society of London. Series B: Biological Sciences</title>
		<imprint>
			<biblScope unit="volume">356</biblScope>
			<biblScope unit="issue">1413</biblScope>
			<biblScope unit="page" from="1345" to="1350" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Automated Planning: theory and practice</title>
		<author>
			<persName><forename type="first">Malik</forename><surname>Ghallab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><surname>Nau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Traverso</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Conceptual graphs: Fundamental notions</title>
		<author>
			<persName><forename type="first">Marie-Laure</forename><surname>Mugnier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michel</forename><surname>Chein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Revue d&apos;intelligence artificielle</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="365" to="406" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hierarchical knowledge integration using layered conceptual graphs</title>
		<author>
			<persName><forename type="first">Madalina</forename><surname>Croitoru</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ernesto</forename><surname>Compatangelo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Mellish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Conceptual Structures</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="267" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Planning graph heuristics for belief space search</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Bryce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Subbarao</forename><surname>Kambhampati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">E</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="35" to="99" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Planning with incomplete information as heuristic search in belief space</title>
		<author>
			<persName><forename type="first">Blai</forename><surname>Bonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hector</forename><surname>Geffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Conference on Artificial Intelligence Planning Systems</title>
		<meeting>the Fifth International Conference on Artificial Intelligence Planning Systems</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="52" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Weak, strong, and strong cyclic planning via symbolic model checking</title>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Cimatti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Pistore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marco</forename><surname>Roveri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Traverso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="35" to="84" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Improving efficiency in mobile robot task planning through world abstraction</title>
		<author>
			<persName><forename type="first">Cipriano</forename><surname>Galindo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-A</forename><surname>Fernandez-Madrigal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Javier</forename><surname>Gonzalez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Robotics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="677" to="690" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">Maria</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Derek</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniele</forename><surname>Magazzeni</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1709.10256</idno>
		<title level="m">Explainable planning</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Towards explainable ai planning as a service</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Cashmore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anna</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benjamin</forename><surname>Krarup</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Senka</forename><surname>Krivic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniele</forename><surname>Magazzeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Smith</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1908.05059</idno>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">The emerging landscape of explainable ai planning and decision making</title>
		<author>
			<persName><forename type="first">Tathagata</forename><surname>Chakraborti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sarath</forename><surname>Sreedharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Subbarao</forename><surname>Kambhampati</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2002.11697</idno>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Counterfactuals in explainable artificial intelligence (xai): Evidence from human reasoning</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Ruth</surname></persName>
		</author>
		<author>
			<persName><surname>Byrne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="6276" to="6282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Explainable ai for robot failures: Generating explanations that improve user assistance in fault recovery</title>
		<author>
			<persName><forename type="first">Devleena</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddhartha</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sonia</forename><surname>Chernova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2021 ACM/IEEE International Conference on Human-Robot Interaction</title>
		<meeting>the 2021 ACM/IEEE International Conference on Human-Robot Interaction</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="351" to="360" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Macro-ff: Improving ai planning with automatically learned macrooperators</title>
		<author>
			<persName><forename type="first">Adi</forename><surname>Botea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Markus</forename><surname>Enzenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Schaeffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="581" to="621" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Semantics for hierarchical task-network planning</title>
		<author>
			<persName><forename type="first">Kutluhan</forename><surname>Erol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">A</forename><surname>Hendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dana</forename><forename type="middle">S</forename><surname>Nau</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>MARYLAND UNIV COLLEGE PARK INST FOR SYSTEMS RESEARCH</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Using ontologies as semantic representations of hierarchical task network planning domains</title>
		<author>
			<persName><forename type="first">Artur</forename><surname>Freitas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniela</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felipe</forename><surname>Meneguzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Renata</forename><surname>Vieira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><forename type="middle">H</forename><surname>Bordini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of WWW</title>
		<meeting>WWW</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page">124</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The logic of plausible reasoning: A core theory</title>
		<author>
			<persName><forename type="first">Allan</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryszard</forename><surname>Michalski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">cognitive science</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="49" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Planning under partial observability by classical replanning: Theory and experiments</title>
		<author>
			<persName><forename type="first">Blai</forename><surname>Bonet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hector</forename><surname>Geffner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-Second International Joint Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
